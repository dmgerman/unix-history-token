begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* 32-bit ELF support for S+core.    Copyright 2006, 2007 Free Software Foundation, Inc.    Contributed by    Mei Ligang (ligang@sunnorth.com.cn)    Pei-Lin Tsai (pltsai@sunplus.com)     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf/score.h"
end_include

begin_include
include|#
directive|include
file|"elf/common.h"
end_include

begin_include
include|#
directive|include
file|"elf/internal.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_comment
comment|/* Score ELF linker hash table.  */
end_comment

begin_struct
struct|struct
name|score_elf_link_hash_table
block|{
comment|/* The main hash table.  */
name|struct
name|elf_link_hash_table
name|root
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The SCORE ELF linker needs additional information for each symbol in    the global hash table.  */
end_comment

begin_struct
struct|struct
name|score_elf_link_hash_entry
block|{
name|struct
name|elf_link_hash_entry
name|root
decl_stmt|;
comment|/* Number of R_SCORE_ABS32, R_SCORE_REL32 relocs against this symbol.  */
name|unsigned
name|int
name|possibly_dynamic_relocs
decl_stmt|;
comment|/* If the R_SCORE_ABS32, R_SCORE_REL32 reloc is against a readonly section.  */
name|bfd_boolean
name|readonly_reloc
decl_stmt|;
comment|/* We must not create a stub for a symbol that has relocations related to      taking the function's address, i.e. any but R_SCORE_CALL15 ones.  */
name|bfd_boolean
name|no_fn_stub
decl_stmt|;
comment|/* Are we forced local?  This will only be set if we have converted      the initial global GOT entry to a local GOT entry.  */
name|bfd_boolean
name|forced_local
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Traverse a score ELF linker hash table.  */
end_comment

begin_define
define|#
directive|define
name|score_elf_link_hash_traverse
parameter_list|(
name|table
parameter_list|,
name|func
parameter_list|,
name|info
parameter_list|)
define|\
value|(elf_link_hash_traverse \    (&(table)->root, \     (bfd_boolean (*) (struct elf_link_hash_entry *, void *)) (func), \     (info)))
end_define

begin_comment
comment|/* Get the SCORE elf linker hash table from a link_info structure.  */
end_comment

begin_define
define|#
directive|define
name|score_elf_hash_table
parameter_list|(
name|info
parameter_list|)
define|\
value|((struct score_elf_link_hash_table *) ((info)->hash))
end_define

begin_comment
comment|/* This structure is used to hold .got entries while estimating got sizes.  */
end_comment

begin_struct
struct|struct
name|score_got_entry
block|{
comment|/* The input bfd in which the symbol is defined.  */
name|bfd
modifier|*
name|abfd
decl_stmt|;
comment|/* The index of the symbol, as stored in the relocation r_info, if      we have a local symbol; -1 otherwise.  */
name|long
name|symndx
decl_stmt|;
union|union
block|{
comment|/* If abfd == NULL, an address that must be stored in the got.  */
name|bfd_vma
name|address
decl_stmt|;
comment|/* If abfd != NULL&& symndx != -1, the addend of the relocation        that should be added to the symbol value.  */
name|bfd_vma
name|addend
decl_stmt|;
comment|/* If abfd != NULL&& symndx == -1, the hash table entry        corresponding to a global symbol in the got (or, local, if        h->forced_local).  */
name|struct
name|score_elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
block|}
name|d
union|;
comment|/* The offset from the beginning of the .got section to the entry      corresponding to this symbol+addend.  If it's a global symbol      whose offset is yet to be decided, it's going to be -1.  */
name|long
name|gotidx
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This structure is passed to score_elf_sort_hash_table_f when sorting    the dynamic symbols.  */
end_comment

begin_struct
struct|struct
name|score_elf_hash_sort_data
block|{
comment|/* The symbol in the global GOT with the lowest dynamic symbol table index.  */
name|struct
name|elf_link_hash_entry
modifier|*
name|low
decl_stmt|;
comment|/* The least dynamic symbol table index corresponding to a symbol with a GOT entry.  */
name|long
name|min_got_dynindx
decl_stmt|;
comment|/* The greatest dynamic symbol table index corresponding to a symbol      with a GOT entry that is not referenced (e.g., a dynamic symbol      with dynamic relocations pointing to it from non-primary GOTs).  */
name|long
name|max_unref_got_dynindx
decl_stmt|;
comment|/* The greatest dynamic symbol table index not corresponding to a      symbol without a GOT entry.  */
name|long
name|max_non_got_dynindx
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|score_got_info
block|{
comment|/* The global symbol in the GOT with the lowest index in the dynamic      symbol table.  */
name|struct
name|elf_link_hash_entry
modifier|*
name|global_gotsym
decl_stmt|;
comment|/* The number of global .got entries.  */
name|unsigned
name|int
name|global_gotno
decl_stmt|;
comment|/* The number of local .got entries.  */
name|unsigned
name|int
name|local_gotno
decl_stmt|;
comment|/* The number of local .got entries we have used.  */
name|unsigned
name|int
name|assigned_gotno
decl_stmt|;
comment|/* A hash table holding members of the got.  */
name|struct
name|htab
modifier|*
name|got_entries
decl_stmt|;
comment|/* In multi-got links, a pointer to the next got (err, rather, most      of the time, it points to the previous got).  */
name|struct
name|score_got_info
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A structure used to count GOT entries, for GOT entry or ELF symbol table traversal.  */
end_comment

begin_struct
struct|struct
name|_score_elf_section_data
block|{
name|struct
name|bfd_elf_section_data
name|elf
decl_stmt|;
union|union
block|{
name|struct
name|score_got_info
modifier|*
name|got_info
decl_stmt|;
name|bfd_byte
modifier|*
name|tdata
decl_stmt|;
block|}
name|u
union|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|score_elf_section_data
parameter_list|(
name|sec
parameter_list|)
define|\
value|((struct _score_elf_section_data *) elf_section_data (sec))
end_define

begin_comment
comment|/* The size of a symbol-table entry.  */
end_comment

begin_define
define|#
directive|define
name|SCORE_ELF_SYM_SIZE
parameter_list|(
name|abfd
parameter_list|)
define|\
value|(get_elf_backend_data (abfd)->s->sizeof_sym)
end_define

begin_comment
comment|/* In case we're on a 32-bit machine, construct a 64-bit "-1" value    from smaller values.  Start with zero, widen, *then* decrement.  */
end_comment

begin_define
define|#
directive|define
name|MINUS_ONE
value|(((bfd_vma)0) - 1)
end_define

begin_define
define|#
directive|define
name|MINUS_TWO
value|(((bfd_vma)0) - 2)
end_define

begin_define
define|#
directive|define
name|PDR_SIZE
value|32
end_define

begin_comment
comment|/* The number of local .got entries we reserve.  */
end_comment

begin_define
define|#
directive|define
name|SCORE_RESERVED_GOTNO
value|(2)
end_define

begin_define
define|#
directive|define
name|ELF_DYNAMIC_INTERPRETER
value|"/usr/lib/ld.so.1"
end_define

begin_comment
comment|/* The offset of $gp from the beginning of the .got section.  */
end_comment

begin_define
define|#
directive|define
name|ELF_SCORE_GP_OFFSET
parameter_list|(
name|abfd
parameter_list|)
value|(0x3ff0)
end_define

begin_comment
comment|/* The maximum size of the GOT for it to be addressable using 15-bit offsets from $gp.  */
end_comment

begin_define
define|#
directive|define
name|SCORE_ELF_GOT_MAX_SIZE
parameter_list|(
name|abfd
parameter_list|)
value|(ELF_SCORE_GP_OFFSET(abfd) + 0x3fff)
end_define

begin_define
define|#
directive|define
name|SCORE_ELF_STUB_SECTION_NAME
value|(".SCORE.stub")
end_define

begin_define
define|#
directive|define
name|SCORE_FUNCTION_STUB_SIZE
value|(16)
end_define

begin_define
define|#
directive|define
name|STUB_LW
value|0xc3bcc010
end_define

begin_comment
comment|/* lw r29, [r28, -0x3ff0]  */
end_comment

begin_define
define|#
directive|define
name|STUB_MOVE
value|0x8363bc56
end_define

begin_comment
comment|/* mv r27, r3  */
end_comment

begin_define
define|#
directive|define
name|STUB_LI16
value|0x87548000
end_define

begin_comment
comment|/* ori r26, .dynsym_index  */
end_comment

begin_define
define|#
directive|define
name|STUB_BRL
value|0x801dbc09
end_define

begin_comment
comment|/* brl r29  */
end_comment

begin_define
define|#
directive|define
name|SCORE_ELF_GOT_SIZE
parameter_list|(
name|abfd
parameter_list|)
define|\
value|(get_elf_backend_data (abfd)->s->arch_size / 8)
end_define

begin_define
define|#
directive|define
name|SCORE_ELF_ADD_DYNAMIC_ENTRY
parameter_list|(
name|info
parameter_list|,
name|tag
parameter_list|,
name|val
parameter_list|)
define|\
value|(_bfd_elf_add_dynamic_entry (info, (bfd_vma) tag, (bfd_vma) val))
end_define

begin_comment
comment|/* The size of an external dynamic table entry.  */
end_comment

begin_define
define|#
directive|define
name|SCORE_ELF_DYN_SIZE
parameter_list|(
name|abfd
parameter_list|)
define|\
value|(get_elf_backend_data (abfd)->s->sizeof_dyn)
end_define

begin_comment
comment|/* The size of an external REL relocation.  */
end_comment

begin_define
define|#
directive|define
name|SCORE_ELF_REL_SIZE
parameter_list|(
name|abfd
parameter_list|)
define|\
value|(get_elf_backend_data (abfd)->s->sizeof_rel)
end_define

begin_comment
comment|/* The default alignment for sections, as a power of two.  */
end_comment

begin_define
define|#
directive|define
name|SCORE_ELF_LOG_FILE_ALIGN
parameter_list|(
name|abfd
parameter_list|)
define|\
value|(get_elf_backend_data (abfd)->s->log_file_align)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|NUM_ELEM
end_ifndef

begin_define
define|#
directive|define
name|NUM_ELEM
parameter_list|(
name|a
parameter_list|)
value|(sizeof (a) / (sizeof (a)[0]))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|bfd_byte
modifier|*
name|hi16_rel_addr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This will be used when we sort the dynamic relocation records.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd
modifier|*
name|reldyn_sorting_bfd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* SCORE ELF uses two common sections.  One is the usual one, and the    other is for small objects.  All the small objects are kept    together, and then referenced via the gp pointer, which yields    faster assembler code.  This is what we use for the small common    section.  This approach is copied from ecoff.c.  */
end_comment

begin_decl_stmt
specifier|static
name|asection
name|score_elf_scom_section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asymbol
name|score_elf_scom_symbol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asymbol
modifier|*
name|score_elf_scom_symbol_ptr
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|bfd_reloc_status_type
name|score_elf_hi16_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asymbol
modifier|*
name|symbol
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|asection
modifier|*
name|input_section
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|hi16_rel_addr
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_status_type
name|score_elf_lo16_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asymbol
modifier|*
name|symbol
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|bfd_vma
name|addend
init|=
literal|0
decl_stmt|,
name|offset
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|val
decl_stmt|;
name|unsigned
name|long
name|hi16_offset
decl_stmt|,
name|hi16_value
decl_stmt|,
name|uvalue
decl_stmt|;
name|hi16_value
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|hi16_rel_addr
argument_list|)
expr_stmt|;
name|hi16_offset
operator|=
operator|(
operator|(
operator|(
operator|(
name|hi16_value
operator|>>
literal|16
operator|)
operator|&
literal|0x3
operator|)
operator|<<
literal|15
operator|)
operator||
operator|(
name|hi16_value
operator|&
literal|0x7fff
operator|)
operator|)
operator|>>
literal|1
expr_stmt|;
name|addend
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|(
operator|(
operator|(
operator|(
name|addend
operator|>>
literal|16
operator|)
operator|&
literal|0x3
operator|)
operator|<<
literal|15
operator|)
operator||
operator|(
name|addend
operator|&
literal|0x7fff
operator|)
operator|)
operator|>>
literal|1
expr_stmt|;
name|val
operator|=
name|reloc_entry
operator|->
name|addend
expr_stmt|;
if|if
condition|(
name|reloc_entry
operator|->
name|address
operator|>
name|input_section
operator|->
name|size
condition|)
return|return
name|bfd_reloc_outofrange
return|;
name|uvalue
operator|=
operator|(
operator|(
name|hi16_offset
operator|<<
literal|16
operator|)
operator||
operator|(
name|offset
operator|&
literal|0xffff
operator|)
operator|)
operator|+
name|val
expr_stmt|;
name|hi16_offset
operator|=
operator|(
name|uvalue
operator|>>
literal|16
operator|)
operator|<<
literal|1
expr_stmt|;
name|hi16_value
operator|=
operator|(
name|hi16_value
operator|&
operator|~
literal|0x37fff
operator|)
operator||
operator|(
name|hi16_offset
operator|&
literal|0x7fff
operator|)
operator||
operator|(
operator|(
name|hi16_offset
operator|<<
literal|1
operator|)
operator|&
literal|0x30000
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|hi16_value
argument_list|,
name|hi16_rel_addr
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|(
name|uvalue
operator|&
literal|0xffff
operator|)
operator|<<
literal|1
expr_stmt|;
name|addend
operator|=
operator|(
name|addend
operator|&
operator|~
literal|0x37fff
operator|)
operator||
operator|(
name|offset
operator|&
literal|0x7fff
operator|)
operator||
operator|(
operator|(
name|offset
operator|<<
literal|1
operator|)
operator|&
literal|0x30000
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|addend
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_comment
comment|/* Set the GP value for OUTPUT_BFD.  Returns FALSE if this is a    dangerous relocation.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|score_elf_assign_gp
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|bfd_vma
modifier|*
name|pgp
parameter_list|)
block|{
name|unsigned
name|int
name|count
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|sym
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* If we've already figured out what GP will be, just return it.  */
operator|*
name|pgp
operator|=
name|_bfd_get_gp_value
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pgp
condition|)
return|return
name|TRUE
return|;
name|count
operator|=
name|bfd_get_symcount
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
name|sym
operator|=
name|bfd_get_outsymbols
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
comment|/* The linker script will have created a symbol named `_gp' with the      appropriate value.  */
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
name|i
operator|=
name|count
expr_stmt|;
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|sym
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|bfd_asymbol_name
argument_list|(
operator|*
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'_'
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"_gp"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|pgp
operator|=
name|bfd_asymbol_value
argument_list|(
operator|*
name|sym
argument_list|)
expr_stmt|;
name|_bfd_set_gp_value
argument_list|(
name|output_bfd
argument_list|,
operator|*
name|pgp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|i
operator|>=
name|count
condition|)
block|{
comment|/* Only get the error once.  */
operator|*
name|pgp
operator|=
literal|4
expr_stmt|;
name|_bfd_set_gp_value
argument_list|(
name|output_bfd
argument_list|,
operator|*
name|pgp
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* We have to figure out the gp value, so that we can adjust the    symbol value correctly.  We look up the symbol _gp in the output    BFD.  If we can't find it, we're stuck.  We cache it in the ELF    target data.  We don't need to adjust the symbol value for an    external symbol if we are producing relocatable output.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|score_elf_final_gp
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|bfd_boolean
name|relocatable
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
parameter_list|,
name|bfd_vma
modifier|*
name|pgp
parameter_list|)
block|{
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
operator|&&
operator|!
name|relocatable
condition|)
block|{
operator|*
name|pgp
operator|=
literal|0
expr_stmt|;
return|return
name|bfd_reloc_undefined
return|;
block|}
operator|*
name|pgp
operator|=
name|_bfd_get_gp_value
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pgp
operator|==
literal|0
operator|&&
operator|(
operator|!
name|relocatable
operator|||
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|relocatable
condition|)
block|{
comment|/* Make up a value.  */
operator|*
name|pgp
operator|=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
literal|0x4000
expr_stmt|;
name|_bfd_set_gp_value
argument_list|(
name|output_bfd
argument_list|,
operator|*
name|pgp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|score_elf_assign_gp
argument_list|(
name|output_bfd
argument_list|,
name|pgp
argument_list|)
condition|)
block|{
operator|*
name|error_message
operator|=
operator|(
name|char
operator|*
operator|)
name|_
argument_list|(
literal|"GP relative relocation when _gp not defined"
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_dangerous
return|;
block|}
block|}
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_status_type
name|score_elf_gprel15_with_gp
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd_boolean
name|relocateable
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|bfd_vma
name|gp
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|bfd_vma
name|relocation
decl_stmt|;
name|unsigned
name|long
name|insn
decl_stmt|;
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
else|else
name|relocation
operator|=
name|symbol
operator|->
name|value
expr_stmt|;
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
if|if
condition|(
name|reloc_entry
operator|->
name|address
operator|>
name|input_section
operator|->
name|size
condition|)
return|return
name|bfd_reloc_outofrange
return|;
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|reloc_entry
operator|->
name|addend
operator|&
literal|0xffffc000
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|reloc_entry
operator|->
name|addend
operator|&
literal|0xffffc000
operator|)
operator|!=
literal|0xffffc000
operator|)
condition|)
return|return
name|bfd_reloc_overflow
return|;
name|insn
operator|=
operator|(
name|insn
operator|&
operator|~
literal|0x7fff
operator|)
operator||
operator|(
name|reloc_entry
operator|->
name|addend
operator|&
literal|0x7fff
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|insn
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
argument_list|)
expr_stmt|;
if|if
condition|(
name|relocateable
condition|)
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_status_type
name|gprel32_with_gp
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd_boolean
name|relocatable
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|bfd_vma
name|gp
parameter_list|)
block|{
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
else|else
name|relocation
operator|=
name|symbol
operator|->
name|value
expr_stmt|;
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
if|if
condition|(
name|reloc_entry
operator|->
name|address
operator|>
name|bfd_get_section_limit
argument_list|(
name|abfd
argument_list|,
name|input_section
argument_list|)
condition|)
return|return
name|bfd_reloc_outofrange
return|;
comment|/* Set val to the offset into the section or symbol.  */
name|val
operator|=
name|reloc_entry
operator|->
name|addend
expr_stmt|;
if|if
condition|(
name|reloc_entry
operator|->
name|howto
operator|->
name|partial_inplace
condition|)
name|val
operator|+=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
argument_list|)
expr_stmt|;
comment|/* Adjust val for the final section location and GP value.  If we      are producing relocatable output, we don't want to do this for      an external symbol.  */
if|if
condition|(
operator|!
name|relocatable
operator|||
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|!=
literal|0
condition|)
name|val
operator|+=
name|relocation
operator|-
name|gp
expr_stmt|;
if|if
condition|(
name|reloc_entry
operator|->
name|howto
operator|->
name|partial_inplace
condition|)
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|val
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
argument_list|)
expr_stmt|;
else|else
name|reloc_entry
operator|->
name|addend
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|relocatable
condition|)
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_status_type
name|score_elf_gprel15_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
parameter_list|)
block|{
name|bfd_boolean
name|relocateable
decl_stmt|;
name|bfd_reloc_status_type
name|ret
decl_stmt|;
name|bfd_vma
name|gp
decl_stmt|;
if|if
condition|(
name|output_bfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
operator|&&
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|==
literal|0
operator|&&
name|reloc_entry
operator|->
name|addend
operator|==
literal|0
condition|)
block|{
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
if|if
condition|(
name|output_bfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
name|relocateable
operator|=
name|TRUE
expr_stmt|;
else|else
block|{
name|relocateable
operator|=
name|FALSE
expr_stmt|;
name|output_bfd
operator|=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|owner
expr_stmt|;
block|}
name|ret
operator|=
name|score_elf_final_gp
argument_list|(
name|output_bfd
argument_list|,
name|symbol
argument_list|,
name|relocateable
argument_list|,
name|error_message
argument_list|,
operator|&
name|gp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|bfd_reloc_ok
condition|)
return|return
name|ret
return|;
return|return
name|score_elf_gprel15_with_gp
argument_list|(
name|abfd
argument_list|,
name|symbol
argument_list|,
name|reloc_entry
argument_list|,
name|input_section
argument_list|,
name|relocateable
argument_list|,
name|data
argument_list|,
name|gp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Do a R_SCORE_GPREL32 relocation.  This is a 32 bit value which must    become the offset from the gp register.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|score_elf_gprel32_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
parameter_list|)
block|{
name|bfd_boolean
name|relocatable
decl_stmt|;
name|bfd_reloc_status_type
name|ret
decl_stmt|;
name|bfd_vma
name|gp
decl_stmt|;
comment|/* R_SCORE_GPREL32 relocations are defined for local symbols only.  */
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
operator|&&
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|==
literal|0
operator|&&
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_LOCAL
operator|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|error_message
operator|=
operator|(
name|char
operator|*
operator|)
name|_
argument_list|(
literal|"32bits gp relative relocation occurs for an external symbol"
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_outofrange
return|;
block|}
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
condition|)
name|relocatable
operator|=
name|TRUE
expr_stmt|;
else|else
block|{
name|relocatable
operator|=
name|FALSE
expr_stmt|;
name|output_bfd
operator|=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|owner
expr_stmt|;
block|}
name|ret
operator|=
name|score_elf_final_gp
argument_list|(
name|output_bfd
argument_list|,
name|symbol
argument_list|,
name|relocatable
argument_list|,
name|error_message
argument_list|,
operator|&
name|gp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|bfd_reloc_ok
condition|)
return|return
name|ret
return|;
name|gp
operator|=
literal|0
expr_stmt|;
comment|/* FIXME.  */
return|return
name|gprel32_with_gp
argument_list|(
name|abfd
argument_list|,
name|symbol
argument_list|,
name|reloc_entry
argument_list|,
name|input_section
argument_list|,
name|relocatable
argument_list|,
name|data
argument_list|,
name|gp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* A howto special_function for R_SCORE_GOT15 relocations.  This is just    like any other 16-bit relocation when applied to global symbols, but is    treated in the same as R_SCORE_HI16 when applied to local symbols.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|score_elf_got15_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
parameter_list|)
block|{
if|if
condition|(
operator|(
name|symbol
operator|->
name|flags
operator|&
operator|(
name|BSF_GLOBAL
operator||
name|BSF_WEAK
operator|)
operator|)
operator|!=
literal|0
operator|||
name|bfd_is_und_section
argument_list|(
name|bfd_get_section
argument_list|(
name|symbol
argument_list|)
argument_list|)
operator|||
name|bfd_is_com_section
argument_list|(
name|bfd_get_section
argument_list|(
name|symbol
argument_list|)
argument_list|)
condition|)
comment|/* The relocation is against a global symbol.  */
return|return
name|bfd_elf_generic_reloc
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
argument_list|,
name|symbol
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
name|error_message
argument_list|)
return|;
return|return
name|score_elf_hi16_reloc
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
argument_list|,
name|symbol
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
name|error_message
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_status_type
name|score_elf_got_lo16_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asymbol
modifier|*
name|symbol
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|bfd_vma
name|addend
init|=
literal|0
decl_stmt|,
name|offset
init|=
literal|0
decl_stmt|;
name|signed
name|long
name|val
decl_stmt|;
name|signed
name|long
name|hi16_offset
decl_stmt|,
name|hi16_value
decl_stmt|,
name|uvalue
decl_stmt|;
name|hi16_value
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|hi16_rel_addr
argument_list|)
expr_stmt|;
name|hi16_offset
operator|=
operator|(
operator|(
operator|(
operator|(
name|hi16_value
operator|>>
literal|16
operator|)
operator|&
literal|0x3
operator|)
operator|<<
literal|15
operator|)
operator||
operator|(
name|hi16_value
operator|&
literal|0x7fff
operator|)
operator|)
operator|>>
literal|1
expr_stmt|;
name|addend
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|(
operator|(
operator|(
operator|(
name|addend
operator|>>
literal|16
operator|)
operator|&
literal|0x3
operator|)
operator|<<
literal|15
operator|)
operator||
operator|(
name|addend
operator|&
literal|0x7fff
operator|)
operator|)
operator|>>
literal|1
expr_stmt|;
name|val
operator|=
name|reloc_entry
operator|->
name|addend
expr_stmt|;
if|if
condition|(
name|reloc_entry
operator|->
name|address
operator|>
name|input_section
operator|->
name|size
condition|)
return|return
name|bfd_reloc_outofrange
return|;
name|uvalue
operator|=
operator|(
operator|(
name|hi16_offset
operator|<<
literal|16
operator|)
operator||
operator|(
name|offset
operator|&
literal|0xffff
operator|)
operator|)
operator|+
name|val
expr_stmt|;
if|if
condition|(
operator|(
name|uvalue
operator|>
operator|-
literal|0x8000
operator|)
operator|&&
operator|(
name|uvalue
operator|<
literal|0x7fff
operator|)
condition|)
name|hi16_offset
operator|=
literal|0
expr_stmt|;
else|else
name|hi16_offset
operator|=
operator|(
name|uvalue
operator|>>
literal|16
operator|)
operator|&
literal|0x7fff
expr_stmt|;
name|hi16_value
operator|=
operator|(
name|hi16_value
operator|&
operator|~
literal|0x37fff
operator|)
operator||
operator|(
name|hi16_offset
operator|&
literal|0x7fff
operator|)
operator||
operator|(
operator|(
name|hi16_offset
operator|<<
literal|1
operator|)
operator|&
literal|0x30000
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|hi16_value
argument_list|,
name|hi16_rel_addr
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|(
name|uvalue
operator|&
literal|0xffff
operator|)
operator|<<
literal|1
expr_stmt|;
name|addend
operator|=
operator|(
name|addend
operator|&
operator|~
literal|0x37fff
operator|)
operator||
operator|(
name|offset
operator|&
literal|0x7fff
operator|)
operator||
operator|(
operator|(
name|offset
operator|<<
literal|1
operator|)
operator|&
literal|0x30000
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|addend
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|elf32_score_howto_table
index|[]
init|=
block|{
comment|/* No relocation.  */
name|HOWTO
argument_list|(
name|R_SCORE_NONE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SCORE_NONE"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* R_SCORE_HI16 */
name|HOWTO
argument_list|(
name|R_SCORE_HI16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|1
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|score_elf_hi16_reloc
argument_list|,
comment|/* special_function */
literal|"R_SCORE_HI16"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0x37fff
argument_list|,
comment|/* src_mask */
literal|0x37fff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* R_SCORE_LO16 */
name|HOWTO
argument_list|(
name|R_SCORE_LO16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|1
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|score_elf_lo16_reloc
argument_list|,
comment|/* special_function */
literal|"R_SCORE_LO16"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0x37fff
argument_list|,
comment|/* src_mask */
literal|0x37fff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/*  R_SCORE_DUMMY1 */
name|HOWTO
argument_list|(
name|R_SCORE_DUMMY1
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|1
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SCORE_DUMMY1"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/*R_SCORE_24 */
name|HOWTO
argument_list|(
name|R_SCORE_24
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|24
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|1
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SCORE_24"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x3ff7fff
argument_list|,
comment|/* src_mask */
literal|0x3ff7fff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/*R_SCORE_PC19 */
name|HOWTO
argument_list|(
name|R_SCORE_PC19
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|19
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|1
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SCORE_PC19"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x3ff03fe
argument_list|,
comment|/* src_mask */
literal|0x3ff03fe
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/*R_SCORE16_11 */
name|HOWTO
argument_list|(
name|R_SCORE16_11
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|11
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|1
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SCORE16_11"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x000000ffe
argument_list|,
comment|/* src_mask */
literal|0x000000ffe
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* R_SCORE16_PC8 */
name|HOWTO
argument_list|(
name|R_SCORE16_PC8
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SCORE16_PC8"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x000000ff
argument_list|,
comment|/* src_mask */
literal|0x000000ff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 32 bit absolute */
name|HOWTO
argument_list|(
name|R_SCORE_ABS32
argument_list|,
comment|/* type  8 */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SCORE_ABS32"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16 bit absolute */
name|HOWTO
argument_list|(
name|R_SCORE_ABS16
argument_list|,
comment|/* type 11 */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SCORE_ABS16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* R_SCORE_DUMMY2 */
name|HOWTO
argument_list|(
name|R_SCORE_DUMMY2
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SCORE_DUMMY2"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0x00007fff
argument_list|,
comment|/* src_mask */
literal|0x00007fff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* R_SCORE_GP15 */
name|HOWTO
argument_list|(
name|R_SCORE_GP15
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|score_elf_gprel15_reloc
argument_list|,
comment|/* special_function */
literal|"R_SCORE_GP15"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0x00007fff
argument_list|,
comment|/* src_mask */
literal|0x00007fff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* GNU extension to record C++ vtable hierarchy.  */
name|HOWTO
argument_list|(
name|R_SCORE_GNU_VTINHERIT
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|NULL
argument_list|,
comment|/* special_function */
literal|"R_SCORE_GNU_VTINHERIT"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* GNU extension to record C++ vtable member usage */
name|HOWTO
argument_list|(
name|R_SCORE_GNU_VTENTRY
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|_bfd_elf_rel_vtable_reloc_fn
argument_list|,
comment|/* special_function */
literal|"R_SCORE_GNU_VTENTRY"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Reference to global offset table.  */
name|HOWTO
argument_list|(
name|R_SCORE_GOT15
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|score_elf_got15_reloc
argument_list|,
comment|/* special_function */
literal|"R_SCORE_GOT15"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0x00007fff
argument_list|,
comment|/* src_mask */
literal|0x00007fff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Low 16 bits of displacement in global offset table.  */
name|HOWTO
argument_list|(
name|R_SCORE_GOT_LO16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|1
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|score_elf_got_lo16_reloc
argument_list|,
comment|/* special_function */
literal|"R_SCORE_GOT_LO16"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0x37ffe
argument_list|,
comment|/* src_mask */
literal|0x37ffe
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 15 bit call through global offset table.  */
name|HOWTO
argument_list|(
name|R_SCORE_CALL15
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SCORE_CALL15"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 32 bit GP relative reference.  */
name|HOWTO
argument_list|(
name|R_SCORE_GPREL32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|score_elf_gprel32_reloc
argument_list|,
comment|/* special_function */
literal|"R_SCORE_GPREL32"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 32 bit symbol relative relocation.  */
name|HOWTO
argument_list|(
name|R_SCORE_REL32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SCORE_REL32"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* R_SCORE_DUMMY_HI16 */
name|HOWTO
argument_list|(
name|R_SCORE_DUMMY_HI16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|1
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|score_elf_hi16_reloc
argument_list|,
comment|/* special_function */
literal|"R_SCORE_DUMMY_HI16"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0x37fff
argument_list|,
comment|/* src_mask */
literal|0x37fff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|score_reloc_map
block|{
name|bfd_reloc_code_real_type
name|bfd_reloc_val
decl_stmt|;
name|unsigned
name|char
name|elf_reloc_val
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|score_reloc_map
name|elf32_score_reloc_map
index|[]
init|=
block|{
block|{
name|BFD_RELOC_NONE
block|,
name|R_SCORE_NONE
block|}
block|,
block|{
name|BFD_RELOC_HI16_S
block|,
name|R_SCORE_HI16
block|}
block|,
block|{
name|BFD_RELOC_LO16
block|,
name|R_SCORE_LO16
block|}
block|,
block|{
name|BFD_RELOC_SCORE_DUMMY1
block|,
name|R_SCORE_DUMMY1
block|}
block|,
block|{
name|BFD_RELOC_SCORE_JMP
block|,
name|R_SCORE_24
block|}
block|,
block|{
name|BFD_RELOC_SCORE_BRANCH
block|,
name|R_SCORE_PC19
block|}
block|,
block|{
name|BFD_RELOC_SCORE16_JMP
block|,
name|R_SCORE16_11
block|}
block|,
block|{
name|BFD_RELOC_SCORE16_BRANCH
block|,
name|R_SCORE16_PC8
block|}
block|,
block|{
name|BFD_RELOC_32
block|,
name|R_SCORE_ABS32
block|}
block|,
block|{
name|BFD_RELOC_16
block|,
name|R_SCORE_ABS16
block|}
block|,
block|{
name|BFD_RELOC_SCORE_DUMMY2
block|,
name|R_SCORE_DUMMY2
block|}
block|,
block|{
name|BFD_RELOC_SCORE_GPREL15
block|,
name|R_SCORE_GP15
block|}
block|,
block|{
name|BFD_RELOC_VTABLE_INHERIT
block|,
name|R_SCORE_GNU_VTINHERIT
block|}
block|,
block|{
name|BFD_RELOC_VTABLE_ENTRY
block|,
name|R_SCORE_GNU_VTENTRY
block|}
block|,
block|{
name|BFD_RELOC_SCORE_GOT15
block|,
name|R_SCORE_GOT15
block|}
block|,
block|{
name|BFD_RELOC_SCORE_GOT_LO16
block|,
name|R_SCORE_GOT_LO16
block|}
block|,
block|{
name|BFD_RELOC_SCORE_CALL15
block|,
name|R_SCORE_CALL15
block|}
block|,
block|{
name|BFD_RELOC_GPREL32
block|,
name|R_SCORE_GPREL32
block|}
block|,
block|{
name|BFD_RELOC_32_PCREL
block|,
name|R_SCORE_REL32
block|}
block|,
block|{
name|BFD_RELOC_SCORE_DUMMY_HI16
block|,
name|R_SCORE_DUMMY_HI16
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* got_entries only match if they're identical, except for gotidx, so    use all fields to compute the hash, and compare the appropriate    union members.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|score_elf_got_entry_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|entry_
parameter_list|)
block|{
specifier|const
name|struct
name|score_got_entry
modifier|*
name|entry
init|=
operator|(
expr|struct
name|score_got_entry
operator|*
operator|)
name|entry_
decl_stmt|;
return|return
name|entry
operator|->
name|symndx
operator|+
operator|(
operator|!
name|entry
operator|->
name|abfd
condition|?
name|entry
operator|->
name|d
operator|.
name|address
else|:
name|entry
operator|->
name|abfd
operator|->
name|id
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|score_elf_got_entry_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|entry1
parameter_list|,
specifier|const
name|void
modifier|*
name|entry2
parameter_list|)
block|{
specifier|const
name|struct
name|score_got_entry
modifier|*
name|e1
init|=
operator|(
expr|struct
name|score_got_entry
operator|*
operator|)
name|entry1
decl_stmt|;
specifier|const
name|struct
name|score_got_entry
modifier|*
name|e2
init|=
operator|(
expr|struct
name|score_got_entry
operator|*
operator|)
name|entry2
decl_stmt|;
return|return
name|e1
operator|->
name|abfd
operator|==
name|e2
operator|->
name|abfd
operator|&&
name|e1
operator|->
name|symndx
operator|==
name|e2
operator|->
name|symndx
operator|&&
operator|(
operator|!
name|e1
operator|->
name|abfd
condition|?
name|e1
operator|->
name|d
operator|.
name|address
operator|==
name|e2
operator|->
name|d
operator|.
name|address
else|:
name|e1
operator|->
name|symndx
operator|>=
literal|0
condition|?
name|e1
operator|->
name|d
operator|.
name|addend
operator|==
name|e2
operator|->
name|d
operator|.
name|addend
else|:
name|e1
operator|->
name|d
operator|.
name|h
operator|==
name|e2
operator|->
name|d
operator|.
name|h
operator|)
return|;
block|}
end_function

begin_comment
comment|/* If H needs a GOT entry, assign it the highest available dynamic    index.  Otherwise, assign it the lowest available dynamic    index.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|score_elf_sort_hash_table_f
parameter_list|(
name|struct
name|score_elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|score_elf_hash_sort_data
modifier|*
name|hsd
init|=
name|data
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|score_elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
comment|/* Symbols without dynamic symbol table entries aren't interesting at all.  */
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|dynindx
operator|==
operator|-
literal|1
condition|)
return|return
name|TRUE
return|;
comment|/* Global symbols that need GOT entries that are not explicitly      referenced are marked with got offset 2.  Those that are      referenced get a 1, and those that don't need GOT entries get      -1.  */
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|got
operator|.
name|offset
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|hsd
operator|->
name|max_unref_got_dynindx
operator|==
name|hsd
operator|->
name|min_got_dynindx
condition|)
name|hsd
operator|->
name|low
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|dynindx
operator|=
name|hsd
operator|->
name|max_unref_got_dynindx
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|got
operator|.
name|offset
operator|!=
literal|1
condition|)
name|h
operator|->
name|root
operator|.
name|dynindx
operator|=
name|hsd
operator|->
name|max_non_got_dynindx
operator|++
expr_stmt|;
else|else
block|{
name|h
operator|->
name|root
operator|.
name|dynindx
operator|=
operator|--
name|hsd
operator|->
name|min_got_dynindx
expr_stmt|;
name|hsd
operator|->
name|low
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|asection
modifier|*
name|score_elf_got_section
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_boolean
name|maybe_excluded
parameter_list|)
block|{
name|asection
modifier|*
name|sgot
init|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".got"
argument_list|)
decl_stmt|;
if|if
condition|(
name|sgot
operator|==
name|NULL
operator|||
operator|(
operator|!
name|maybe_excluded
operator|&&
operator|(
name|sgot
operator|->
name|flags
operator|&
name|SEC_EXCLUDE
operator|)
operator|!=
literal|0
operator|)
condition|)
return|return
name|NULL
return|;
return|return
name|sgot
return|;
block|}
end_function

begin_comment
comment|/* Returns the GOT information associated with the link indicated by    INFO.  If SGOTP is non-NULL, it is filled in with the GOT section.  */
end_comment

begin_function
specifier|static
name|struct
name|score_got_info
modifier|*
name|score_elf_got_info
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
modifier|*
name|sgotp
parameter_list|)
block|{
name|asection
modifier|*
name|sgot
decl_stmt|;
name|struct
name|score_got_info
modifier|*
name|g
decl_stmt|;
name|sgot
operator|=
name|score_elf_got_section
argument_list|(
name|abfd
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|elf_section_data
argument_list|(
name|sgot
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g
operator|=
name|score_elf_section_data
argument_list|(
name|sgot
argument_list|)
operator|->
name|u
operator|.
name|got_info
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|g
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sgotp
condition|)
operator|*
name|sgotp
operator|=
name|sgot
expr_stmt|;
return|return
name|g
return|;
block|}
end_function

begin_comment
comment|/* Sort the dynamic symbol table so that symbols that need GOT entries    appear towards the end.  This reduces the amount of GOT space    required.  MAX_LOCAL is used to set the number of local symbols    known to be in the dynamic symbol table.  During    _bfd_score_elf_size_dynamic_sections, this value is 1.  Afterward, the    section symbols are added and the count is higher.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|score_elf_sort_hash_table
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|unsigned
name|long
name|max_local
parameter_list|)
block|{
name|struct
name|score_elf_hash_sort_data
name|hsd
decl_stmt|;
name|struct
name|score_got_info
modifier|*
name|g
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|g
operator|=
name|score_elf_got_info
argument_list|(
name|dynobj
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|hsd
operator|.
name|low
operator|=
name|NULL
expr_stmt|;
name|hsd
operator|.
name|max_unref_got_dynindx
operator|=
name|hsd
operator|.
name|min_got_dynindx
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynsymcount
comment|/* In the multi-got case, assigned_gotno of the master got_info        indicate the number of entries that aren't referenced in the        primary GOT, but that must have entries because there are        dynamic relocations that reference it.  Since they aren't        referenced, we move them to the end of the GOT, so that they        don't prevent other entries that are referenced from getting        too large offsets.  */
operator|-
operator|(
name|g
operator|->
name|next
condition|?
name|g
operator|->
name|assigned_gotno
else|:
literal|0
operator|)
expr_stmt|;
name|hsd
operator|.
name|max_non_got_dynindx
operator|=
name|max_local
expr_stmt|;
name|score_elf_link_hash_traverse
argument_list|(
operator|(
operator|(
expr|struct
name|score_elf_link_hash_table
operator|*
operator|)
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|)
argument_list|,
name|score_elf_sort_hash_table_f
argument_list|,
operator|&
name|hsd
argument_list|)
expr_stmt|;
comment|/* There should have been enough room in the symbol table to      accommodate both the GOT and non-GOT symbols.  */
name|BFD_ASSERT
argument_list|(
name|hsd
operator|.
name|max_non_got_dynindx
operator|<=
name|hsd
operator|.
name|min_got_dynindx
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|hsd
operator|.
name|max_unref_got_dynindx
operator|<=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynsymcount
argument_list|)
expr_stmt|;
comment|/* Now we know which dynamic symbol has the lowest dynamic symbol      table index in the GOT.  */
name|g
operator|->
name|global_gotsym
operator|=
name|hsd
operator|.
name|low
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Create an entry in an score ELF linker hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|score_elf_link_hash_newfunc
parameter_list|(
name|struct
name|bfd_hash_entry
modifier|*
name|entry
parameter_list|,
name|struct
name|bfd_hash_table
modifier|*
name|table
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|struct
name|score_elf_link_hash_entry
modifier|*
name|ret
init|=
operator|(
expr|struct
name|score_elf_link_hash_entry
operator|*
operator|)
name|entry
decl_stmt|;
comment|/* Allocate the structure if it has not already been allocated by a subclass.  */
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
name|ret
operator|=
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|score_elf_link_hash_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
comment|/* Call the allocation method of the superclass.  */
name|ret
operator|=
operator|(
operator|(
expr|struct
name|score_elf_link_hash_entry
operator|*
operator|)
name|_bfd_elf_link_hash_newfunc
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|NULL
condition|)
block|{
name|ret
operator|->
name|possibly_dynamic_relocs
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|readonly_reloc
operator|=
name|FALSE
expr_stmt|;
name|ret
operator|->
name|no_fn_stub
operator|=
name|FALSE
expr_stmt|;
name|ret
operator|->
name|forced_local
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Returns the first relocation of type r_type found, beginning with    RELOCATION.  RELEND is one-past-the-end of the relocation table.  */
end_comment

begin_function
specifier|static
specifier|const
name|Elf_Internal_Rela
modifier|*
name|score_elf_next_relocation
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|unsigned
name|int
name|r_type
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocation
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relend
parameter_list|)
block|{
while|while
condition|(
name|relocation
operator|<
name|relend
condition|)
block|{
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|relocation
operator|->
name|r_info
argument_list|)
operator|==
name|r_type
condition|)
return|return
name|relocation
return|;
operator|++
name|relocation
expr_stmt|;
block|}
comment|/* We didn't find it.  */
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* This function is called via qsort() to sort the dynamic relocation    entries by increasing r_symndx value.  */
end_comment

begin_function
specifier|static
name|int
name|score_elf_sort_dynamic_relocs
parameter_list|(
specifier|const
name|void
modifier|*
name|arg1
parameter_list|,
specifier|const
name|void
modifier|*
name|arg2
parameter_list|)
block|{
name|Elf_Internal_Rela
name|int_reloc1
decl_stmt|;
name|Elf_Internal_Rela
name|int_reloc2
decl_stmt|;
name|bfd_elf32_swap_reloc_in
argument_list|(
name|reldyn_sorting_bfd
argument_list|,
name|arg1
argument_list|,
operator|&
name|int_reloc1
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloc_in
argument_list|(
name|reldyn_sorting_bfd
argument_list|,
name|arg2
argument_list|,
operator|&
name|int_reloc2
argument_list|)
expr_stmt|;
return|return
operator|(
name|ELF32_R_SYM
argument_list|(
name|int_reloc1
operator|.
name|r_info
argument_list|)
operator|-
name|ELF32_R_SYM
argument_list|(
name|int_reloc2
operator|.
name|r_info
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return whether a relocation is against a local symbol.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|score_elf_local_relocation_p
parameter_list|(
name|bfd
modifier|*
name|input_bfd
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocation
parameter_list|,
name|asection
modifier|*
modifier|*
name|local_sections
parameter_list|,
name|bfd_boolean
name|check_forced
parameter_list|)
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|score_elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|size_t
name|extsymoff
decl_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|relocation
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|extsymoff
operator|=
operator|(
name|elf_bad_symtab
argument_list|(
name|input_bfd
argument_list|)
operator|)
condition|?
literal|0
else|:
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|extsymoff
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|elf_bad_symtab
argument_list|(
name|input_bfd
argument_list|)
operator|&&
name|local_sections
index|[
name|r_symndx
index|]
operator|!=
name|NULL
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|check_forced
condition|)
block|{
comment|/* Look up the hash table to check whether the symbol was forced local.  */
name|h
operator|=
operator|(
expr|struct
name|score_elf_link_hash_entry
operator|*
operator|)
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
index|[
name|r_symndx
operator|-
name|extsymoff
index|]
expr_stmt|;
comment|/* Find the real hash-table entry for this symbol.  */
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|score_elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|forced_local
condition|)
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Returns the dynamic relocation section for DYNOBJ.  */
end_comment

begin_function
specifier|static
name|asection
modifier|*
name|score_elf_rel_dyn_section
parameter_list|(
name|bfd
modifier|*
name|dynobj
parameter_list|,
name|bfd_boolean
name|create_p
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|dname
index|[]
init|=
literal|".rel.dyn"
decl_stmt|;
name|asection
modifier|*
name|sreloc
decl_stmt|;
name|sreloc
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|dname
argument_list|)
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
operator|&&
name|create_p
condition|)
block|{
name|sreloc
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|dynobj
argument_list|,
name|dname
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_READONLY
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|sreloc
argument_list|,
name|SCORE_ELF_LOG_FILE_ALIGN
argument_list|(
name|dynobj
argument_list|)
argument_list|)
condition|)
return|return
name|NULL
return|;
block|}
return|return
name|sreloc
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|score_elf_allocate_dynamic_relocations
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|unsigned
name|int
name|n
parameter_list|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|score_elf_rel_dyn_section
argument_list|(
name|abfd
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|size
operator|==
literal|0
condition|)
block|{
comment|/* Make room for a null element.  */
name|s
operator|->
name|size
operator|+=
name|SCORE_ELF_REL_SIZE
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
operator|++
name|s
operator|->
name|reloc_count
expr_stmt|;
block|}
name|s
operator|->
name|size
operator|+=
name|n
operator|*
name|SCORE_ELF_REL_SIZE
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create a rel.dyn relocation for the dynamic linker to resolve.  REL    is the original relocation, which is now being transformed into a    dynamic relocation.  The ADDENDP is adjusted if necessary; the    caller should store the result in place of the original addend.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|score_elf_create_dynamic_relocation
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
parameter_list|,
name|struct
name|score_elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|bfd_vma
name|symbol
parameter_list|,
name|bfd_vma
modifier|*
name|addendp
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|)
block|{
name|Elf_Internal_Rela
name|outrel
index|[
literal|3
index|]
decl_stmt|;
name|asection
modifier|*
name|sreloc
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|int
name|r_type
decl_stmt|;
name|long
name|indx
decl_stmt|;
name|bfd_boolean
name|defined_p
decl_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|sreloc
operator|=
name|score_elf_rel_dyn_section
argument_list|(
name|dynobj
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sreloc
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sreloc
operator|->
name|contents
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sreloc
operator|->
name|reloc_count
operator|*
name|SCORE_ELF_REL_SIZE
argument_list|(
name|output_bfd
argument_list|)
operator|<
name|sreloc
operator|->
name|size
argument_list|)
expr_stmt|;
name|outrel
index|[
literal|0
index|]
operator|.
name|r_offset
operator|=
name|_bfd_elf_section_offset
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|input_section
argument_list|,
name|rel
index|[
literal|0
index|]
operator|.
name|r_offset
argument_list|)
expr_stmt|;
name|outrel
index|[
literal|1
index|]
operator|.
name|r_offset
operator|=
name|_bfd_elf_section_offset
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|input_section
argument_list|,
name|rel
index|[
literal|1
index|]
operator|.
name|r_offset
argument_list|)
expr_stmt|;
name|outrel
index|[
literal|2
index|]
operator|.
name|r_offset
operator|=
name|_bfd_elf_section_offset
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|input_section
argument_list|,
name|rel
index|[
literal|2
index|]
operator|.
name|r_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|outrel
index|[
literal|0
index|]
operator|.
name|r_offset
operator|==
name|MINUS_ONE
condition|)
comment|/* The relocation field has been deleted.  */
return|return
name|TRUE
return|;
if|if
condition|(
name|outrel
index|[
literal|0
index|]
operator|.
name|r_offset
operator|==
name|MINUS_TWO
condition|)
block|{
comment|/* The relocation field has been converted into a relative value of 	 some sort.  Functions like _bfd_elf_write_section_eh_frame expect 	 the field to be fully relocated, so add in the symbol's value.  */
operator|*
name|addendp
operator|+=
name|symbol
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* We must now calculate the dynamic symbol table index to use      in the relocation.  */
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
operator|!
name|info
operator|->
name|symbolic
operator|||
operator|!
name|h
operator|->
name|root
operator|.
name|def_regular
operator|)
comment|/* h->root.dynindx may be -1 if this symbol was marked to 	 become local.  */
operator|&&
name|h
operator|->
name|root
operator|.
name|dynindx
operator|!=
operator|-
literal|1
condition|)
block|{
name|indx
operator|=
name|h
operator|->
name|root
operator|.
name|dynindx
expr_stmt|;
comment|/* ??? glibc's ld.so just adds the final GOT entry to the 	   relocation field.  It therefore treats relocs against 	   defined symbols in the same way as relocs against 	   undefined symbols.  */
name|defined_p
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|indx
operator|=
literal|0
expr_stmt|;
name|defined_p
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* If the relocation was previously an absolute relocation and      this symbol will not be referred to by the relocation, we must      adjust it by the value we give it in the dynamic symbol table.      Otherwise leave the job up to the dynamic linker.  */
if|if
condition|(
name|defined_p
operator|&&
name|r_type
operator|!=
name|R_SCORE_REL32
condition|)
operator|*
name|addendp
operator|+=
name|symbol
expr_stmt|;
comment|/* The relocation is always an REL32 relocation because we don't      know where the shared library will wind up at load-time.  */
name|outrel
index|[
literal|0
index|]
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|indx
argument_list|,
name|R_SCORE_REL32
argument_list|)
expr_stmt|;
comment|/* For strict adherence to the ABI specification, we should      generate a R_SCORE_64 relocation record by itself before the      _REL32/_64 record as well, such that the addend is read in as      a 64-bit value (REL32 is a 32-bit relocation, after all).      However, since none of the existing ELF64 SCORE dynamic      loaders seems to care, we don't waste space with these      artificial relocations.  If this turns out to not be true,      score_elf_allocate_dynamic_relocations() should be tweaked so      as to make room for a pair of dynamic relocations per      invocation if ABI_64_P, and here we should generate an      additional relocation record with R_SCORE_64 by itself for a      NULL symbol before this relocation record.  */
name|outrel
index|[
literal|1
index|]
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_SCORE_NONE
argument_list|)
expr_stmt|;
name|outrel
index|[
literal|2
index|]
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_SCORE_NONE
argument_list|)
expr_stmt|;
comment|/* Adjust the output offset of the relocation to reference the      correct location in the output file.  */
name|outrel
index|[
literal|0
index|]
operator|.
name|r_offset
operator|+=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|outrel
index|[
literal|1
index|]
operator|.
name|r_offset
operator|+=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|outrel
index|[
literal|2
index|]
operator|.
name|r_offset
operator|+=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
comment|/* Put the relocation back out.  We have to use the special      relocation outputter in the 64-bit case since the 64-bit      relocation format is non-standard.  */
name|bfd_elf32_swap_reloc_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
index|[
literal|0
index|]
argument_list|,
operator|(
name|sreloc
operator|->
name|contents
operator|+
name|sreloc
operator|->
name|reloc_count
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* We've now added another relocation.  */
operator|++
name|sreloc
operator|->
name|reloc_count
expr_stmt|;
comment|/* Make sure the output section is writable.  The dynamic linker      will be writing to it.  */
name|elf_section_data
argument_list|(
name|input_section
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_flags
operator||=
name|SHF_WRITE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|score_elf_create_got_section
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd_boolean
name|maybe_exclude
parameter_list|)
block|{
name|flagword
name|flags
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|bh
decl_stmt|;
name|struct
name|score_got_info
modifier|*
name|g
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
comment|/* This function may be called more than once.  */
name|s
operator|=
name|score_elf_got_section
argument_list|(
name|abfd
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
if|if
condition|(
operator|!
name|maybe_exclude
condition|)
name|s
operator|->
name|flags
operator|&=
operator|~
name|SEC_EXCLUDE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|flags
operator|=
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator|)
expr_stmt|;
if|if
condition|(
name|maybe_exclude
condition|)
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
comment|/* We have to use an alignment of 2**4 here because this is hardcoded      in the function stub generation and in the linker script.  */
name|s
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|abfd
argument_list|,
literal|".got"
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
literal|4
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Define the symbol _GLOBAL_OFFSET_TABLE_.  We don't do this in the      linker script because we don't want to define the symbol if we      are not creating a global offset table.  */
name|bh
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|,
name|BSF_GLOBAL
argument_list|,
name|s
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|collect
argument_list|,
operator|&
name|bh
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|bh
expr_stmt|;
name|h
operator|->
name|non_elf
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|def_regular
operator|=
literal|1
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|STT_OBJECT
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|score_got_info
argument_list|)
expr_stmt|;
name|g
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|g
operator|->
name|global_gotsym
operator|=
name|NULL
expr_stmt|;
name|g
operator|->
name|global_gotno
operator|=
literal|0
expr_stmt|;
name|g
operator|->
name|local_gotno
operator|=
name|SCORE_RESERVED_GOTNO
expr_stmt|;
name|g
operator|->
name|assigned_gotno
operator|=
name|SCORE_RESERVED_GOTNO
expr_stmt|;
name|g
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|g
operator|->
name|got_entries
operator|=
name|htab_try_create
argument_list|(
literal|1
argument_list|,
name|score_elf_got_entry_hash
argument_list|,
name|score_elf_got_entry_eq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|got_entries
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|score_elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|u
operator|.
name|got_info
operator|=
name|g
expr_stmt|;
name|score_elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|elf
operator|.
name|this_hdr
operator|.
name|sh_flags
operator||=
name|SHF_ALLOC
operator||
name|SHF_WRITE
operator||
name|SHF_SCORE_GPREL
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Calculate the %high function.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|score_elf_high
parameter_list|(
name|bfd_vma
name|value
parameter_list|)
block|{
return|return
operator|(
operator|(
name|value
operator|+
operator|(
name|bfd_vma
operator|)
literal|0x8000
operator|)
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
return|;
block|}
end_function

begin_comment
comment|/* Create a local GOT entry for VALUE.  Return the index of the entry,    or -1 if it could not be created.  */
end_comment

begin_function
specifier|static
name|struct
name|score_got_entry
modifier|*
name|score_elf_create_local_got_entry
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd
modifier|*
name|ibfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|score_got_info
modifier|*
name|gg
parameter_list|,
name|asection
modifier|*
name|sgot
parameter_list|,
name|bfd_vma
name|value
parameter_list|,
name|unsigned
name|long
name|r_symndx
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|score_elf_link_hash_entry
modifier|*
name|h
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|r_type
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|struct
name|score_got_entry
name|entry
decl_stmt|,
modifier|*
modifier|*
name|loc
decl_stmt|;
name|struct
name|score_got_info
modifier|*
name|g
decl_stmt|;
name|entry
operator|.
name|abfd
operator|=
name|NULL
expr_stmt|;
name|entry
operator|.
name|symndx
operator|=
operator|-
literal|1
expr_stmt|;
name|entry
operator|.
name|d
operator|.
name|address
operator|=
name|value
expr_stmt|;
name|g
operator|=
name|gg
expr_stmt|;
name|loc
operator|=
operator|(
expr|struct
name|score_got_entry
operator|*
operator|*
operator|)
name|htab_find_slot
argument_list|(
name|g
operator|->
name|got_entries
argument_list|,
operator|&
name|entry
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|loc
condition|)
return|return
operator|*
name|loc
return|;
name|entry
operator|.
name|gotidx
operator|=
name|SCORE_ELF_GOT_SIZE
argument_list|(
name|abfd
argument_list|)
operator|*
name|g
operator|->
name|assigned_gotno
operator|++
expr_stmt|;
operator|*
name|loc
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|loc
condition|)
return|return
name|NULL
return|;
name|memcpy
argument_list|(
operator|*
name|loc
argument_list|,
operator|&
name|entry
argument_list|,
sizeof|sizeof
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|assigned_gotno
operator|>=
name|g
operator|->
name|local_gotno
condition|)
block|{
operator|(
operator|*
name|loc
operator|)
operator|->
name|gotidx
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* We didn't allocate enough space in the GOT.  */
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"not enough GOT space for local GOT entries"
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|value
argument_list|,
operator|(
name|sgot
operator|->
name|contents
operator|+
name|entry
operator|.
name|gotidx
operator|)
argument_list|)
expr_stmt|;
return|return
operator|*
name|loc
return|;
block|}
end_function

begin_comment
comment|/* Find a GOT entry whose higher-order 16 bits are the same as those    for value.  Return the index into the GOT for this entry.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|score_elf_got16_entry
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd
modifier|*
name|ibfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd_vma
name|value
parameter_list|,
name|bfd_boolean
name|external
parameter_list|)
block|{
name|asection
modifier|*
name|sgot
decl_stmt|;
name|struct
name|score_got_info
modifier|*
name|g
decl_stmt|;
name|struct
name|score_got_entry
modifier|*
name|entry
decl_stmt|;
if|if
condition|(
operator|!
name|external
condition|)
block|{
comment|/* Although the ABI says that it is "the high-order 16 bits" that we 	 want, it is really the %high value.  The complete value is 	 calculated with a `addiu' of a LO16 relocation, just as with a 	 HI16/LO16 pair.  */
name|value
operator|=
name|score_elf_high
argument_list|(
name|value
argument_list|)
operator|<<
literal|16
expr_stmt|;
block|}
name|g
operator|=
name|score_elf_got_info
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
argument_list|,
operator|&
name|sgot
argument_list|)
expr_stmt|;
name|entry
operator|=
name|score_elf_create_local_got_entry
argument_list|(
name|abfd
argument_list|,
name|ibfd
argument_list|,
name|g
argument_list|,
name|sgot
argument_list|,
name|value
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|R_SCORE_GOT15
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
condition|)
return|return
name|entry
operator|->
name|gotidx
return|;
else|else
return|return
name|MINUS_ONE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|_bfd_score_elf_hide_symbol
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|entry
parameter_list|,
name|bfd_boolean
name|force_local
parameter_list|)
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|got
decl_stmt|;
name|struct
name|score_got_info
modifier|*
name|g
decl_stmt|;
name|struct
name|score_elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
operator|(
expr|struct
name|score_elf_link_hash_entry
operator|*
operator|)
name|entry
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|forced_local
condition|)
return|return;
name|h
operator|->
name|forced_local
operator|=
name|TRUE
expr_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
if|if
condition|(
name|dynobj
operator|!=
name|NULL
operator|&&
name|force_local
condition|)
block|{
name|got
operator|=
name|score_elf_got_section
argument_list|(
name|dynobj
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|got
operator|==
name|NULL
condition|)
return|return;
name|g
operator|=
name|score_elf_section_data
argument_list|(
name|got
argument_list|)
operator|->
name|u
operator|.
name|got_info
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|next
condition|)
block|{
name|struct
name|score_got_entry
name|e
decl_stmt|;
name|struct
name|score_got_info
modifier|*
name|gg
init|=
name|g
decl_stmt|;
comment|/* Since we're turning what used to be a global symbol into a 	     local one, bump up the number of local entries of each GOT 	     that had an entry for it.  This will automatically decrease 	     the number of global entries, since global_gotno is actually 	     the upper limit of global entries.  */
name|e
operator|.
name|abfd
operator|=
name|dynobj
expr_stmt|;
name|e
operator|.
name|symndx
operator|=
operator|-
literal|1
expr_stmt|;
name|e
operator|.
name|d
operator|.
name|h
operator|=
name|h
expr_stmt|;
for|for
control|(
name|g
operator|=
name|g
operator|->
name|next
init|;
name|g
operator|!=
name|gg
condition|;
name|g
operator|=
name|g
operator|->
name|next
control|)
if|if
condition|(
name|htab_find
argument_list|(
name|g
operator|->
name|got_entries
argument_list|,
operator|&
name|e
argument_list|)
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|g
operator|->
name|global_gotno
operator|>
literal|0
argument_list|)
expr_stmt|;
name|g
operator|->
name|local_gotno
operator|++
expr_stmt|;
name|g
operator|->
name|global_gotno
operator|--
expr_stmt|;
block|}
comment|/* If this was a global symbol forced into the primary GOT, we 	     no longer need an entry for it.  We can't release the entry 	     at this point, but we must at least stop counting it as one 	     of the symbols that required a forced got entry.  */
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|got
operator|.
name|offset
operator|==
literal|2
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|gg
operator|->
name|assigned_gotno
operator|>
literal|0
argument_list|)
expr_stmt|;
name|gg
operator|->
name|assigned_gotno
operator|--
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|g
operator|->
name|global_gotno
operator|==
literal|0
operator|&&
name|g
operator|->
name|global_gotsym
operator|==
name|NULL
condition|)
comment|/* If we haven't got through GOT allocation yet, just bump up the 	      number of local entries, as this symbol won't be counted as 	      global.  */
name|g
operator|->
name|local_gotno
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|got
operator|.
name|offset
operator|==
literal|1
condition|)
block|{
comment|/* If we're past non-multi-GOT allocation and this symbol had 	          been marked for a global got entry, give it a local entry 		  instead.  */
name|BFD_ASSERT
argument_list|(
name|g
operator|->
name|global_gotno
operator|>
literal|0
argument_list|)
expr_stmt|;
name|g
operator|->
name|local_gotno
operator|++
expr_stmt|;
name|g
operator|->
name|global_gotno
operator|--
expr_stmt|;
block|}
block|}
name|_bfd_elf_link_hash_hide_symbol
argument_list|(
name|info
argument_list|,
operator|&
name|h
operator|->
name|root
argument_list|,
name|force_local
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If H is a symbol that needs a global GOT entry, but has a dynamic    symbol table index lower than any we've seen to date, record it for    posterity.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|score_elf_record_global_got_symbol
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|struct
name|score_got_info
modifier|*
name|g
parameter_list|)
block|{
name|struct
name|score_got_entry
name|entry
decl_stmt|,
modifier|*
modifier|*
name|loc
decl_stmt|;
comment|/* A global symbol in the GOT must also be in the dynamic symbol table.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
condition|)
block|{
case|case
name|STV_INTERNAL
case|:
case|case
name|STV_HIDDEN
case|:
name|_bfd_score_elf_hide_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
name|entry
operator|.
name|abfd
operator|=
name|abfd
expr_stmt|;
name|entry
operator|.
name|symndx
operator|=
operator|-
literal|1
expr_stmt|;
name|entry
operator|.
name|d
operator|.
name|h
operator|=
operator|(
expr|struct
name|score_elf_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
name|loc
operator|=
operator|(
expr|struct
name|score_got_entry
operator|*
operator|*
operator|)
name|htab_find_slot
argument_list|(
name|g
operator|->
name|got_entries
argument_list|,
operator|&
name|entry
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
comment|/* If we've already marked this entry as needing GOT space, we don't      need to do it again.  */
if|if
condition|(
operator|*
name|loc
condition|)
return|return
name|TRUE
return|;
operator|*
name|loc
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|loc
condition|)
return|return
name|FALSE
return|;
name|entry
operator|.
name|gotidx
operator|=
operator|-
literal|1
expr_stmt|;
name|memcpy
argument_list|(
operator|*
name|loc
argument_list|,
operator|&
name|entry
argument_list|,
sizeof|sizeof
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|offset
operator|!=
name|MINUS_ONE
condition|)
return|return
name|TRUE
return|;
comment|/* By setting this to a value other than -1, we are indicating that      there needs to be a GOT entry for H.  Avoid using zero, as the      generic ELF copy_indirect_symbol tests for<= 0.  */
name|h
operator|->
name|got
operator|.
name|offset
operator|=
literal|1
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Reserve space in G for a GOT entry containing the value of symbol    SYMNDX in input bfd ABDF, plus ADDEND.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|score_elf_record_local_got_symbol
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|long
name|symndx
parameter_list|,
name|bfd_vma
name|addend
parameter_list|,
name|struct
name|score_got_info
modifier|*
name|g
parameter_list|)
block|{
name|struct
name|score_got_entry
name|entry
decl_stmt|,
modifier|*
modifier|*
name|loc
decl_stmt|;
name|entry
operator|.
name|abfd
operator|=
name|abfd
expr_stmt|;
name|entry
operator|.
name|symndx
operator|=
name|symndx
expr_stmt|;
name|entry
operator|.
name|d
operator|.
name|addend
operator|=
name|addend
expr_stmt|;
name|loc
operator|=
operator|(
expr|struct
name|score_got_entry
operator|*
operator|*
operator|)
name|htab_find_slot
argument_list|(
name|g
operator|->
name|got_entries
argument_list|,
operator|&
name|entry
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|loc
condition|)
return|return
name|TRUE
return|;
name|entry
operator|.
name|gotidx
operator|=
name|g
operator|->
name|local_gotno
operator|++
expr_stmt|;
operator|*
name|loc
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|loc
condition|)
return|return
name|FALSE
return|;
name|memcpy
argument_list|(
operator|*
name|loc
argument_list|,
operator|&
name|entry
argument_list|,
sizeof|sizeof
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Returns the GOT offset at which the indicated address can be found.    If there is not yet a GOT entry for this value, create one.    Returns -1 if no satisfactory GOT offset can be found.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|score_elf_local_got_index
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd
modifier|*
name|ibfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd_vma
name|value
parameter_list|,
name|unsigned
name|long
name|r_symndx
parameter_list|,
name|struct
name|score_elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|int
name|r_type
parameter_list|)
block|{
name|asection
modifier|*
name|sgot
decl_stmt|;
name|struct
name|score_got_info
modifier|*
name|g
decl_stmt|;
name|struct
name|score_got_entry
modifier|*
name|entry
decl_stmt|;
name|g
operator|=
name|score_elf_got_info
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
argument_list|,
operator|&
name|sgot
argument_list|)
expr_stmt|;
name|entry
operator|=
name|score_elf_create_local_got_entry
argument_list|(
name|abfd
argument_list|,
name|ibfd
argument_list|,
name|g
argument_list|,
name|sgot
argument_list|,
name|value
argument_list|,
name|r_symndx
argument_list|,
name|h
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|entry
condition|)
return|return
name|MINUS_ONE
return|;
else|else
return|return
name|entry
operator|->
name|gotidx
return|;
block|}
end_function

begin_comment
comment|/* Returns the GOT index for the global symbol indicated by H.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|score_elf_global_got_index
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|)
block|{
name|bfd_vma
name|index
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
name|struct
name|score_got_info
modifier|*
name|g
decl_stmt|;
name|long
name|global_got_dynindx
init|=
literal|0
decl_stmt|;
name|g
operator|=
name|score_elf_got_info
argument_list|(
name|abfd
argument_list|,
operator|&
name|sgot
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|global_gotsym
operator|!=
name|NULL
condition|)
name|global_got_dynindx
operator|=
name|g
operator|->
name|global_gotsym
operator|->
name|dynindx
expr_stmt|;
comment|/* Once we determine the global GOT entry with the lowest dynamic      symbol table index, we must put all dynamic symbols with greater      indices into the GOT.  That makes it easy to calculate the GOT      offset.  */
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|dynindx
operator|>=
name|global_got_dynindx
argument_list|)
expr_stmt|;
name|index
operator|=
operator|(
operator|(
name|h
operator|->
name|dynindx
operator|-
name|global_got_dynindx
operator|+
name|g
operator|->
name|local_gotno
operator|)
operator|*
name|SCORE_ELF_GOT_SIZE
argument_list|(
name|abfd
argument_list|)
operator|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|index
operator|<
name|sgot
operator|->
name|size
argument_list|)
expr_stmt|;
return|return
name|index
return|;
block|}
end_function

begin_comment
comment|/* Returns the offset for the entry at the INDEXth position in the GOT.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|score_elf_got_offset_from_index
parameter_list|(
name|bfd
modifier|*
name|dynobj
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|bfd
modifier|*
name|input_bfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd_vma
name|index
parameter_list|)
block|{
name|asection
modifier|*
name|sgot
decl_stmt|;
name|bfd_vma
name|gp
decl_stmt|;
name|struct
name|score_got_info
modifier|*
name|g
decl_stmt|;
name|g
operator|=
name|score_elf_got_info
argument_list|(
name|dynobj
argument_list|,
operator|&
name|sgot
argument_list|)
expr_stmt|;
name|gp
operator|=
name|_bfd_get_gp_value
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
return|return
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
name|index
operator|-
name|gp
return|;
block|}
end_function

begin_comment
comment|/* Follow indirect and warning hash entries so that each got entry    points to the final symbol definition.  P must point to a pointer    to the hash table we're traversing.  Since this traversal may    modify the hash table, we set this pointer to NULL to indicate    we've made a potentially-destructive change to the hash table, so    the traversal must be restarted.  */
end_comment

begin_function
specifier|static
name|int
name|score_elf_resolve_final_got_entry
parameter_list|(
name|void
modifier|*
modifier|*
name|entryp
parameter_list|,
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|score_got_entry
modifier|*
name|entry
init|=
operator|(
expr|struct
name|score_got_entry
operator|*
operator|)
operator|*
name|entryp
decl_stmt|;
name|htab_t
name|got_entries
init|=
operator|*
operator|(
name|htab_t
operator|*
operator|)
name|p
decl_stmt|;
if|if
condition|(
name|entry
operator|->
name|abfd
operator|!=
name|NULL
operator|&&
name|entry
operator|->
name|symndx
operator|==
operator|-
literal|1
condition|)
block|{
name|struct
name|score_elf_link_hash_entry
modifier|*
name|h
init|=
name|entry
operator|->
name|d
operator|.
name|h
decl_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|score_elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|d
operator|.
name|h
operator|==
name|h
condition|)
return|return
literal|1
return|;
name|entry
operator|->
name|d
operator|.
name|h
operator|=
name|h
expr_stmt|;
comment|/* If we can't find this entry with the new bfd hash, re-insert 	 it, and get the traversal restarted.  */
if|if
condition|(
operator|!
name|htab_find
argument_list|(
name|got_entries
argument_list|,
name|entry
argument_list|)
condition|)
block|{
name|htab_clear_slot
argument_list|(
name|got_entries
argument_list|,
name|entryp
argument_list|)
expr_stmt|;
name|entryp
operator|=
name|htab_find_slot
argument_list|(
name|got_entries
argument_list|,
name|entry
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|entryp
condition|)
operator|*
name|entryp
operator|=
name|entry
expr_stmt|;
comment|/* Abort the traversal, since the whole table may have 	     moved, and leave it up to the parent to restart the 	     process.  */
operator|*
operator|(
name|htab_t
operator|*
operator|)
name|p
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* We might want to decrement the global_gotno count, but it's 	 either too early or too late for that at this point.  */
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Turn indirect got entries in a got_entries table into their final locations.  */
end_comment

begin_function
specifier|static
name|void
name|score_elf_resolve_final_got_entries
parameter_list|(
name|struct
name|score_got_info
modifier|*
name|g
parameter_list|)
block|{
name|htab_t
name|got_entries
decl_stmt|;
do|do
block|{
name|got_entries
operator|=
name|g
operator|->
name|got_entries
expr_stmt|;
name|htab_traverse
argument_list|(
name|got_entries
argument_list|,
name|score_elf_resolve_final_got_entry
argument_list|,
operator|&
name|got_entries
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|got_entries
operator|==
name|NULL
condition|)
do|;
block|}
end_function

begin_comment
comment|/* Add INCREMENT to the reloc (of type HOWTO) at ADDRESS. for -r  */
end_comment

begin_function
specifier|static
name|void
name|score_elf_add_to_rel
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_byte
modifier|*
name|address
parameter_list|,
name|reloc_howto_type
modifier|*
name|howto
parameter_list|,
name|bfd_signed_vma
name|increment
parameter_list|)
block|{
name|bfd_signed_vma
name|addend
decl_stmt|;
name|bfd_vma
name|contents
decl_stmt|;
name|unsigned
name|long
name|offset
decl_stmt|;
name|unsigned
name|long
name|r_type
init|=
name|howto
operator|->
name|type
decl_stmt|;
name|unsigned
name|long
name|hi16_addend
decl_stmt|,
name|hi16_offset
decl_stmt|,
name|hi16_value
decl_stmt|,
name|uvalue
decl_stmt|;
name|contents
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|address
argument_list|)
expr_stmt|;
comment|/* Get the (signed) value from the instruction.  */
name|addend
operator|=
name|contents
operator|&
name|howto
operator|->
name|src_mask
expr_stmt|;
if|if
condition|(
name|addend
operator|&
operator|(
operator|(
name|howto
operator|->
name|src_mask
operator|+
literal|1
operator|)
operator|>>
literal|1
operator|)
condition|)
block|{
name|bfd_signed_vma
name|mask
decl_stmt|;
name|mask
operator|=
operator|-
literal|1
expr_stmt|;
name|mask
operator|&=
operator|~
name|howto
operator|->
name|src_mask
expr_stmt|;
name|addend
operator||=
name|mask
expr_stmt|;
block|}
comment|/* Add in the increment, (which is a byte value).  */
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_SCORE_PC19
case|:
name|offset
operator|=
operator|(
operator|(
operator|(
name|contents
operator|&
name|howto
operator|->
name|src_mask
operator|)
operator|&
literal|0x3ff0000
operator|)
operator|>>
literal|6
operator|)
operator||
operator|(
operator|(
name|contents
operator|&
name|howto
operator|->
name|src_mask
operator|)
operator|&
literal|0x3ff
operator|)
expr_stmt|;
name|offset
operator|+=
name|increment
expr_stmt|;
name|contents
operator|=
operator|(
name|contents
operator|&
operator|~
name|howto
operator|->
name|src_mask
operator|)
operator||
operator|(
operator|(
operator|(
name|offset
operator|<<
literal|6
operator|)
operator|&
name|howto
operator|->
name|src_mask
operator|)
operator|&
literal|0x3ff0000
operator|)
operator||
operator|(
name|offset
operator|&
literal|0x3ff
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|contents
argument_list|,
name|address
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_SCORE_HI16
case|:
break|break;
case|case
name|R_SCORE_LO16
case|:
name|hi16_addend
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|address
operator|-
literal|4
argument_list|)
expr_stmt|;
name|hi16_offset
operator|=
operator|(
operator|(
operator|(
operator|(
name|hi16_addend
operator|>>
literal|16
operator|)
operator|&
literal|0x3
operator|)
operator|<<
literal|15
operator|)
operator||
operator|(
name|hi16_addend
operator|&
literal|0x7fff
operator|)
operator|)
operator|>>
literal|1
expr_stmt|;
name|offset
operator|=
operator|(
operator|(
operator|(
operator|(
name|contents
operator|>>
literal|16
operator|)
operator|&
literal|0x3
operator|)
operator|<<
literal|15
operator|)
operator||
operator|(
name|contents
operator|&
literal|0x7fff
operator|)
operator|)
operator|>>
literal|1
expr_stmt|;
name|offset
operator|=
operator|(
name|hi16_offset
operator|<<
literal|16
operator|)
operator||
operator|(
name|offset
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|uvalue
operator|=
name|increment
operator|+
name|offset
expr_stmt|;
name|hi16_offset
operator|=
operator|(
name|uvalue
operator|>>
literal|16
operator|)
operator|<<
literal|1
expr_stmt|;
name|hi16_value
operator|=
operator|(
name|hi16_addend
operator|&
operator|(
operator|~
operator|(
name|howto
operator|->
name|dst_mask
operator|)
operator|)
operator|)
operator||
operator|(
name|hi16_offset
operator|&
literal|0x7fff
operator|)
operator||
operator|(
operator|(
name|hi16_offset
operator|<<
literal|1
operator|)
operator|&
literal|0x30000
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|hi16_value
argument_list|,
name|address
operator|-
literal|4
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|(
name|uvalue
operator|&
literal|0xffff
operator|)
operator|<<
literal|1
expr_stmt|;
name|contents
operator|=
operator|(
name|contents
operator|&
operator|(
operator|~
operator|(
name|howto
operator|->
name|dst_mask
operator|)
operator|)
operator|)
operator||
operator|(
name|offset
operator|&
literal|0x7fff
operator|)
operator||
operator|(
operator|(
name|offset
operator|<<
literal|1
operator|)
operator|&
literal|0x30000
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|contents
argument_list|,
name|address
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_SCORE_24
case|:
name|offset
operator|=
operator|(
operator|(
operator|(
name|contents
operator|&
name|howto
operator|->
name|src_mask
operator|)
operator|>>
literal|1
operator|)
operator|&
literal|0x1ff8000
operator|)
operator||
operator|(
operator|(
name|contents
operator|&
name|howto
operator|->
name|src_mask
operator|)
operator|&
literal|0x7fff
operator|)
expr_stmt|;
name|offset
operator|+=
name|increment
expr_stmt|;
name|contents
operator|=
operator|(
name|contents
operator|&
operator|~
name|howto
operator|->
name|src_mask
operator|)
operator||
operator|(
operator|(
operator|(
name|offset
operator|<<
literal|1
operator|)
operator|&
name|howto
operator|->
name|src_mask
operator|)
operator|&
literal|0x3ff0000
operator|)
operator||
operator|(
name|offset
operator|&
literal|0x7fff
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|contents
argument_list|,
name|address
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_SCORE16_11
case|:
name|contents
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|address
argument_list|)
expr_stmt|;
name|offset
operator|=
name|contents
operator|&
name|howto
operator|->
name|src_mask
expr_stmt|;
name|offset
operator|+=
name|increment
expr_stmt|;
name|contents
operator|=
operator|(
name|contents
operator|&
operator|~
name|howto
operator|->
name|src_mask
operator|)
operator||
operator|(
name|offset
operator|&
name|howto
operator|->
name|src_mask
operator|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|contents
argument_list|,
name|address
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_SCORE16_PC8
case|:
name|contents
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|address
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|(
name|contents
operator|&
name|howto
operator|->
name|src_mask
operator|)
operator|+
operator|(
operator|(
name|increment
operator|>>
literal|1
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|contents
operator|=
operator|(
name|contents
operator|&
operator|(
operator|~
name|howto
operator|->
name|src_mask
operator|)
operator|)
operator||
operator|(
name|offset
operator|&
name|howto
operator|->
name|src_mask
operator|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|contents
argument_list|,
name|address
argument_list|)
expr_stmt|;
break|break;
default|default:
name|addend
operator|+=
name|increment
expr_stmt|;
name|contents
operator|=
operator|(
name|contents
operator|&
operator|~
name|howto
operator|->
name|dst_mask
operator|)
operator||
operator|(
name|addend
operator|&
name|howto
operator|->
name|dst_mask
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|contents
argument_list|,
name|address
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Perform a relocation as part of a final link.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|score_elf_final_link_relocate
parameter_list|(
name|reloc_howto_type
modifier|*
name|howto
parameter_list|,
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|rel
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|relocs
parameter_list|,
name|bfd_vma
name|symbol
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
specifier|const
name|char
modifier|*
name|sym_name
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|sym_flags
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|score_elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|asection
modifier|*
modifier|*
name|local_sections
parameter_list|,
name|bfd_boolean
name|gp_disp_p
parameter_list|)
block|{
name|unsigned
name|long
name|r_type
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|bfd_byte
modifier|*
name|hit_data
init|=
name|contents
operator|+
name|rel
operator|->
name|r_offset
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|;
comment|/* The final GP value to be used for the relocatable, executable, or      shared object file being produced.  */
name|bfd_vma
name|gp
init|=
name|MINUS_ONE
decl_stmt|;
comment|/* The place (section offset or address) of the storage unit being relocated.  */
name|bfd_vma
name|rel_addr
decl_stmt|;
comment|/* The value of GP used to create the relocatable object.  */
name|bfd_vma
name|gp0
init|=
name|MINUS_ONE
decl_stmt|;
comment|/* The offset into the global offset table at which the address of the relocation entry      symbol, adjusted by the addend, resides during execution.  */
name|bfd_vma
name|g
init|=
name|MINUS_ONE
decl_stmt|;
comment|/* TRUE if the symbol referred to by this relocation is a local symbol.  */
name|bfd_boolean
name|local_p
decl_stmt|;
comment|/* The eventual value we will relocate.  */
name|bfd_vma
name|value
init|=
name|symbol
decl_stmt|;
name|unsigned
name|long
name|hi16_addend
decl_stmt|,
name|hi16_offset
decl_stmt|,
name|hi16_value
decl_stmt|,
name|uvalue
decl_stmt|,
name|offset
decl_stmt|,
name|abs_value
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|elf_gp
argument_list|(
name|output_bfd
argument_list|)
operator|==
literal|0
condition|)
block|{
name|struct
name|bfd_link_hash_entry
modifier|*
name|bh
decl_stmt|;
name|asection
modifier|*
name|o
decl_stmt|;
name|bh
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|info
operator|->
name|hash
argument_list|,
literal|"_gp"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bh
operator|!=
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|)
name|NULL
operator|&&
name|bh
operator|->
name|type
operator|==
name|bfd_link_hash_defined
condition|)
name|elf_gp
argument_list|(
name|output_bfd
argument_list|)
operator|=
operator|(
name|bh
operator|->
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|bh
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|bh
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
block|{
name|bfd_vma
name|lo
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Find the GP-relative section with the lowest offset.  */
for|for
control|(
name|o
operator|=
name|output_bfd
operator|->
name|sections
init|;
name|o
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
if|if
condition|(
name|o
operator|->
name|vma
operator|<
name|lo
condition|)
name|lo
operator|=
name|o
operator|->
name|vma
expr_stmt|;
comment|/* And calculate GP relative to that.  */
name|elf_gp
argument_list|(
name|output_bfd
argument_list|)
operator|=
name|lo
operator|+
name|ELF_SCORE_GP_OFFSET
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If the relocate_section function needs to do a reloc              involving the GP value, it should make a reloc_dangerous              callback to warn that GP is not defined.  */
block|}
block|}
comment|/* Parse the relocation.  */
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|rel_addr
operator|=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|rel
operator|->
name|r_offset
operator|)
expr_stmt|;
name|local_p
operator|=
name|score_elf_local_relocation_p
argument_list|(
name|input_bfd
argument_list|,
name|rel
argument_list|,
name|local_sections
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_SCORE_GOT15
condition|)
block|{
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relend
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|lo16_rel
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
name|bfd_vma
name|lo_value
init|=
literal|0
decl_stmt|;
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|input_section
operator|->
name|reloc_count
operator|*
name|bed
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
expr_stmt|;
name|lo16_rel
operator|=
name|score_elf_next_relocation
argument_list|(
name|input_bfd
argument_list|,
name|R_SCORE_GOT_LO16
argument_list|,
name|rel
argument_list|,
name|relend
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|local_p
operator|)
operator|&&
operator|(
name|lo16_rel
operator|!=
name|NULL
operator|)
condition|)
block|{
name|bfd_vma
name|tmp
init|=
literal|0
decl_stmt|;
name|tmp
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|lo16_rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|lo_value
operator|=
operator|(
operator|(
operator|(
name|tmp
operator|>>
literal|16
operator|)
operator|&
literal|0x3
operator|)
operator|<<
literal|14
operator|)
operator||
operator|(
operator|(
name|tmp
operator|&
literal|0x7fff
operator|)
operator|>>
literal|1
operator|)
expr_stmt|;
block|}
name|addend
operator|=
name|lo_value
expr_stmt|;
block|}
else|else
block|{
name|addend
operator|=
operator|(
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
argument_list|)
operator|>>
name|howto
operator|->
name|bitpos
operator|)
operator|&
name|howto
operator|->
name|src_mask
expr_stmt|;
block|}
comment|/* If we haven't already determined the GOT offset, or the GP value,      and we're going to need it, get it now.  */
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_SCORE_CALL15
case|:
case|case
name|R_SCORE_GOT15
case|:
if|if
condition|(
operator|!
name|local_p
condition|)
block|{
name|g
operator|=
name|score_elf_global_got_index
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
argument_list|,
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
operator|||
operator|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|info
operator|->
name|symbolic
operator|||
name|h
operator|->
name|root
operator|.
name|dynindx
operator|==
operator|-
literal|1
operator|)
operator|&&
name|h
operator|->
name|root
operator|.
name|def_regular
operator|)
operator|)
condition|)
block|{
comment|/* This is a static link or a -Bsymbolic link.  The                  symbol is defined locally, or was forced to be local.                  We must initialize this entry in the GOT.  */
name|bfd
modifier|*
name|tmpbfd
init|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|sgot
init|=
name|score_elf_got_section
argument_list|(
name|tmpbfd
argument_list|,
name|FALSE
argument_list|)
decl_stmt|;
name|bfd_put_32
argument_list|(
name|tmpbfd
argument_list|,
name|value
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|g
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|r_type
operator|==
name|R_SCORE_GOT15
operator|||
name|r_type
operator|==
name|R_SCORE_CALL15
condition|)
block|{
comment|/* There's no need to create a local GOT entry here; the 	     calculation for a local GOT15 entry does not involve G.  */
empty_stmt|;
block|}
else|else
block|{
name|g
operator|=
name|score_elf_local_got_index
argument_list|(
name|output_bfd
argument_list|,
name|input_bfd
argument_list|,
name|info
argument_list|,
name|symbol
operator|+
name|addend
argument_list|,
name|r_symndx
argument_list|,
name|h
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|==
name|MINUS_ONE
condition|)
return|return
name|bfd_reloc_outofrange
return|;
block|}
comment|/* Convert GOT indices to actual offsets.  */
name|g
operator|=
name|score_elf_got_offset_from_index
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
argument_list|,
name|output_bfd
argument_list|,
name|input_bfd
argument_list|,
name|g
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_SCORE_HI16
case|:
case|case
name|R_SCORE_LO16
case|:
case|case
name|R_SCORE_GPREL32
case|:
name|gp0
operator|=
name|_bfd_get_gp_value
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|gp
operator|=
name|_bfd_get_gp_value
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_SCORE_GP15
case|:
name|gp
operator|=
name|_bfd_get_gp_value
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
default|default:
break|break;
block|}
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_SCORE_NONE
case|:
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_SCORE_ABS32
case|:
case|case
name|R_SCORE_REL32
case|:
if|if
condition|(
operator|(
name|info
operator|->
name|shared
operator|||
operator|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
operator|&&
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|root
operator|.
name|def_dynamic
operator|&&
operator|!
name|h
operator|->
name|root
operator|.
name|def_regular
operator|)
operator|)
operator|&&
name|r_symndx
operator|!=
literal|0
operator|&&
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* If we're creating a shared library, or this relocation is against a symbol              in a shared library, then we can't know where the symbol will end up.              So, we create a relocation record in the output, and leave the job up              to the dynamic linker.  */
name|value
operator|=
name|addend
expr_stmt|;
if|if
condition|(
operator|!
name|score_elf_create_dynamic_relocation
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|rel
argument_list|,
name|h
argument_list|,
name|symbol
argument_list|,
operator|&
name|value
argument_list|,
name|input_section
argument_list|)
condition|)
return|return
name|bfd_reloc_undefined
return|;
block|}
else|else
block|{
if|if
condition|(
name|r_type
operator|!=
name|R_SCORE_REL32
condition|)
name|value
operator|=
name|symbol
operator|+
name|addend
expr_stmt|;
else|else
name|value
operator|=
name|addend
expr_stmt|;
block|}
name|value
operator|&=
name|howto
operator|->
name|dst_mask
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|value
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_SCORE_ABS16
case|:
name|value
operator|+=
name|addend
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|value
operator|>
literal|0x7fff
operator|||
operator|(
name|long
operator|)
name|value
operator|<
operator|-
literal|0x8000
condition|)
return|return
name|bfd_reloc_overflow
return|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|value
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_SCORE_24
case|:
name|addend
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|(
operator|(
operator|(
name|addend
operator|&
name|howto
operator|->
name|src_mask
operator|)
operator|>>
literal|1
operator|)
operator|&
literal|0x1ff8000
operator|)
operator||
operator|(
operator|(
name|addend
operator|&
name|howto
operator|->
name|src_mask
operator|)
operator|&
literal|0x7fff
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|offset
operator|&
literal|0x1000000
operator|)
operator|!=
literal|0
condition|)
name|offset
operator||=
literal|0xfe000000
expr_stmt|;
name|value
operator|+=
name|offset
expr_stmt|;
name|addend
operator|=
operator|(
name|addend
operator|&
operator|~
name|howto
operator|->
name|src_mask
operator|)
operator||
operator|(
operator|(
operator|(
name|value
operator|<<
literal|1
operator|)
operator|&
name|howto
operator|->
name|src_mask
operator|)
operator|&
literal|0x3ff0000
operator|)
operator||
operator|(
name|value
operator|&
literal|0x7fff
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|addend
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_SCORE_PC19
case|:
name|addend
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|(
operator|(
operator|(
name|addend
operator|&
name|howto
operator|->
name|src_mask
operator|)
operator|&
literal|0x3ff0000
operator|)
operator|>>
literal|6
operator|)
operator||
operator|(
operator|(
name|addend
operator|&
name|howto
operator|->
name|src_mask
operator|)
operator|&
literal|0x3ff
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|offset
operator|&
literal|0x80000
operator|)
operator|!=
literal|0
condition|)
name|offset
operator||=
literal|0xfff00000
expr_stmt|;
name|abs_value
operator|=
name|value
operator|=
name|value
operator|-
name|rel_addr
operator|+
name|offset
expr_stmt|;
comment|/* exceed 20 bit : overflow.  */
if|if
condition|(
operator|(
name|abs_value
operator|&
literal|0x80000000
operator|)
operator|==
literal|0x80000000
condition|)
name|abs_value
operator|=
literal|0xffffffff
operator|-
name|value
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|abs_value
operator|&
literal|0xfff80000
operator|)
operator|!=
literal|0
condition|)
return|return
name|bfd_reloc_overflow
return|;
name|addend
operator|=
operator|(
name|addend
operator|&
operator|~
name|howto
operator|->
name|src_mask
operator|)
operator||
operator|(
operator|(
operator|(
name|value
operator|<<
literal|6
operator|)
operator|&
name|howto
operator|->
name|src_mask
operator|)
operator|&
literal|0x3ff0000
operator|)
operator||
operator|(
name|value
operator|&
literal|0x3ff
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|addend
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_SCORE16_11
case|:
name|addend
operator|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
name|offset
operator|=
name|addend
operator|&
name|howto
operator|->
name|src_mask
expr_stmt|;
if|if
condition|(
operator|(
name|offset
operator|&
literal|0x800
operator|)
operator|!=
literal|0
condition|)
comment|/* Offset is negative.  */
name|offset
operator||=
literal|0xfffff000
expr_stmt|;
name|value
operator|+=
name|offset
expr_stmt|;
name|addend
operator|=
operator|(
name|addend
operator|&
operator|~
name|howto
operator|->
name|src_mask
operator|)
operator||
operator|(
name|value
operator|&
name|howto
operator|->
name|src_mask
operator|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|addend
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_SCORE16_PC8
case|:
name|addend
operator|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|(
name|addend
operator|&
name|howto
operator|->
name|src_mask
operator|)
operator|<<
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|offset
operator|&
literal|0x100
operator|)
operator|!=
literal|0
condition|)
comment|/* Offset is negative.  */
name|offset
operator||=
literal|0xfffffe00
expr_stmt|;
name|abs_value
operator|=
name|value
operator|=
name|value
operator|-
name|rel_addr
operator|+
name|offset
expr_stmt|;
comment|/* Sign bit + exceed 9 bit.  */
if|if
condition|(
operator|(
operator|(
name|value
operator|&
literal|0xffffff00
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|value
operator|&
literal|0xffffff00
operator|)
operator|!=
literal|0xffffff00
operator|)
condition|)
return|return
name|bfd_reloc_overflow
return|;
name|value
operator|>>=
literal|1
expr_stmt|;
name|addend
operator|=
operator|(
name|addend
operator|&
operator|~
name|howto
operator|->
name|src_mask
operator|)
operator||
operator|(
name|value
operator|&
name|howto
operator|->
name|src_mask
operator|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|addend
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_SCORE_HI16
case|:
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_SCORE_LO16
case|:
name|hi16_addend
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
operator|-
literal|4
argument_list|)
expr_stmt|;
name|hi16_offset
operator|=
operator|(
operator|(
operator|(
operator|(
name|hi16_addend
operator|>>
literal|16
operator|)
operator|&
literal|0x3
operator|)
operator|<<
literal|15
operator|)
operator||
operator|(
name|hi16_addend
operator|&
literal|0x7fff
operator|)
operator|)
operator|>>
literal|1
expr_stmt|;
name|addend
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|(
operator|(
operator|(
operator|(
name|addend
operator|>>
literal|16
operator|)
operator|&
literal|0x3
operator|)
operator|<<
literal|15
operator|)
operator||
operator|(
name|addend
operator|&
literal|0x7fff
operator|)
operator|)
operator|>>
literal|1
expr_stmt|;
name|offset
operator|=
operator|(
name|hi16_offset
operator|<<
literal|16
operator|)
operator||
operator|(
name|offset
operator|&
literal|0xffff
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|gp_disp_p
condition|)
name|uvalue
operator|=
name|value
operator|+
name|offset
expr_stmt|;
else|else
name|uvalue
operator|=
name|offset
operator|+
name|gp
operator|-
name|rel_addr
operator|+
literal|4
expr_stmt|;
name|hi16_offset
operator|=
operator|(
name|uvalue
operator|>>
literal|16
operator|)
operator|<<
literal|1
expr_stmt|;
name|hi16_value
operator|=
operator|(
name|hi16_addend
operator|&
operator|(
operator|~
operator|(
name|howto
operator|->
name|dst_mask
operator|)
operator|)
operator|)
operator||
operator|(
name|hi16_offset
operator|&
literal|0x7fff
operator|)
operator||
operator|(
operator|(
name|hi16_offset
operator|<<
literal|1
operator|)
operator|&
literal|0x30000
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|hi16_value
argument_list|,
name|hit_data
operator|-
literal|4
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|(
name|uvalue
operator|&
literal|0xffff
operator|)
operator|<<
literal|1
expr_stmt|;
name|value
operator|=
operator|(
name|addend
operator|&
operator|(
operator|~
operator|(
name|howto
operator|->
name|dst_mask
operator|)
operator|)
operator|)
operator||
operator|(
name|offset
operator|&
literal|0x7fff
operator|)
operator||
operator|(
operator|(
name|offset
operator|<<
literal|1
operator|)
operator|&
literal|0x30000
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|value
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_SCORE_GP15
case|:
name|addend
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
name|offset
operator|=
name|addend
operator|&
literal|0x7fff
expr_stmt|;
if|if
condition|(
operator|(
name|offset
operator|&
literal|0x4000
operator|)
operator|==
literal|0x4000
condition|)
name|offset
operator||=
literal|0xffffc000
expr_stmt|;
name|value
operator|=
name|value
operator|+
name|offset
operator|-
name|gp
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|value
operator|&
literal|0xffffc000
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|value
operator|&
literal|0xffffc000
operator|)
operator|!=
literal|0xffffc000
operator|)
condition|)
return|return
name|bfd_reloc_overflow
return|;
name|value
operator|=
operator|(
name|addend
operator|&
operator|~
name|howto
operator|->
name|src_mask
operator|)
operator||
operator|(
name|value
operator|&
name|howto
operator|->
name|src_mask
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|value
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_SCORE_GOT15
case|:
case|case
name|R_SCORE_CALL15
case|:
if|if
condition|(
name|local_p
condition|)
block|{
name|bfd_boolean
name|forced
decl_stmt|;
comment|/* The special case is when the symbol is forced to be local.  We need the              full address in the GOT since no R_SCORE_GOT_LO16 relocation follows.  */
name|forced
operator|=
operator|!
name|score_elf_local_relocation_p
argument_list|(
name|input_bfd
argument_list|,
name|rel
argument_list|,
name|local_sections
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|value
operator|=
name|score_elf_got16_entry
argument_list|(
name|output_bfd
argument_list|,
name|input_bfd
argument_list|,
name|info
argument_list|,
name|symbol
operator|+
name|addend
argument_list|,
name|forced
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|MINUS_ONE
condition|)
return|return
name|bfd_reloc_outofrange
return|;
name|value
operator|=
name|score_elf_got_offset_from_index
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
argument_list|,
name|output_bfd
argument_list|,
name|input_bfd
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
name|g
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|long
operator|)
name|value
operator|>
literal|0x3fff
operator|||
operator|(
name|long
operator|)
name|value
operator|<
operator|-
literal|0x4000
condition|)
return|return
name|bfd_reloc_overflow
return|;
name|addend
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
name|value
operator|=
operator|(
name|addend
operator|&
operator|~
name|howto
operator|->
name|dst_mask
operator|)
operator||
operator|(
name|value
operator|&
name|howto
operator|->
name|dst_mask
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|value
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_SCORE_GPREL32
case|:
name|value
operator|=
operator|(
name|addend
operator|+
name|symbol
operator|-
name|gp
operator|)
expr_stmt|;
name|value
operator|&=
name|howto
operator|->
name|dst_mask
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|value
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_SCORE_GOT_LO16
case|:
name|addend
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
name|value
operator|=
operator|(
operator|(
operator|(
name|addend
operator|>>
literal|16
operator|)
operator|&
literal|0x3
operator|)
operator|<<
literal|14
operator|)
operator||
operator|(
operator|(
name|addend
operator|&
literal|0x7fff
operator|)
operator|>>
literal|1
operator|)
expr_stmt|;
name|value
operator|+=
name|symbol
expr_stmt|;
name|value
operator|=
operator|(
name|addend
operator|&
operator|(
operator|~
operator|(
name|howto
operator|->
name|dst_mask
operator|)
operator|)
operator|)
operator||
operator|(
operator|(
name|value
operator|&
literal|0x3fff
operator|)
operator|<<
literal|1
operator|)
operator||
operator|(
operator|(
operator|(
name|value
operator|>>
literal|14
operator|)
operator|&
literal|0x3
operator|)
operator|<<
literal|16
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|value
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_SCORE_DUMMY_HI16
case|:
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_SCORE_GNU_VTINHERIT
case|:
case|case
name|R_SCORE_GNU_VTENTRY
case|:
comment|/* We don't do anything with these at present.  */
return|return
name|bfd_reloc_continue
return|;
default|default:
return|return
name|bfd_reloc_notsupported
return|;
block|}
block|}
end_function

begin_comment
comment|/* Score backend functions.  */
end_comment

begin_function
specifier|static
name|void
name|_bfd_score_info_to_howto
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|arelent
modifier|*
name|bfd_reloc
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|elf_reloc
parameter_list|)
block|{
name|unsigned
name|int
name|r_type
decl_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|elf_reloc
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|>=
name|NUM_ELEM
argument_list|(
name|elf32_score_howto_table
argument_list|)
condition|)
name|bfd_reloc
operator|->
name|howto
operator|=
name|NULL
expr_stmt|;
else|else
name|bfd_reloc
operator|->
name|howto
operator|=
operator|&
name|elf32_score_howto_table
index|[
name|r_type
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Relocate an score ELF section.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|_bfd_score_elf_relocate_section
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|relocs
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|local_syms
parameter_list|,
name|asection
modifier|*
modifier|*
name|local_sections
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relend
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|long
name|offset
decl_stmt|;
name|unsigned
name|long
name|hi16_addend
decl_stmt|,
name|hi16_offset
decl_stmt|,
name|hi16_value
decl_stmt|,
name|uvalue
decl_stmt|;
name|size_t
name|extsymoff
decl_stmt|;
name|bfd_boolean
name|gp_disp_p
init|=
name|FALSE
decl_stmt|;
comment|/* Sort dynsym.  */
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
name|bfd_size_type
name|dynsecsymcount
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
name|asection
modifier|*
name|p
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|output_bfd
argument_list|)
decl_stmt|;
for|for
control|(
name|p
operator|=
name|output_bfd
operator|->
name|sections
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
operator|(
name|p
operator|->
name|flags
operator|&
name|SEC_EXCLUDE
operator|)
operator|==
literal|0
operator|&&
operator|(
name|p
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
operator|&&
operator|!
call|(
modifier|*
name|bed
operator|->
name|elf_backend_omit_section_dynsym
call|)
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|p
argument_list|)
condition|)
operator|++
name|dynsecsymcount
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|score_elf_sort_hash_table
argument_list|(
name|info
argument_list|,
name|dynsecsymcount
operator|+
literal|1
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|extsymoff
operator|=
operator|(
name|elf_bad_symtab
argument_list|(
name|input_bfd
argument_list|)
operator|)
condition|?
literal|0
else|:
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|rel
operator|=
name|relocs
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|input_section
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|int
name|r_type
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|score_elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|bfd_vma
name|relocation
init|=
literal|0
decl_stmt|;
name|bfd_reloc_status_type
name|r
decl_stmt|;
name|arelent
name|bfd_reloc
decl_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|_bfd_score_info_to_howto
argument_list|(
name|input_bfd
argument_list|,
operator|&
name|bfd_reloc
argument_list|,
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
name|rel
argument_list|)
expr_stmt|;
name|howto
operator|=
name|bfd_reloc
operator|.
name|howto
expr_stmt|;
name|h
operator|=
name|NULL
expr_stmt|;
name|sym
operator|=
name|NULL
expr_stmt|;
name|sec
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|extsymoff
condition|)
block|{
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|relocation
operator|=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|sym
operator|->
name|st_value
operator|)
expr_stmt|;
name|name
operator|=
name|bfd_elf_sym_name
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
argument_list|,
name|sym
argument_list|,
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|relocatable
operator|&&
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_MERGE
operator|)
operator|!=
literal|0
operator|&&
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_SECTION
condition|)
block|{
name|asection
modifier|*
name|msec
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|,
name|value
decl_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_SCORE_HI16
case|:
break|break;
case|case
name|R_SCORE_LO16
case|:
name|hi16_addend
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|-
literal|4
argument_list|)
expr_stmt|;
name|hi16_offset
operator|=
operator|(
operator|(
operator|(
operator|(
name|hi16_addend
operator|>>
literal|16
operator|)
operator|&
literal|0x3
operator|)
operator|<<
literal|15
operator|)
operator||
operator|(
name|hi16_addend
operator|&
literal|0x7fff
operator|)
operator|)
operator|>>
literal|1
expr_stmt|;
name|value
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|(
operator|(
operator|(
operator|(
name|value
operator|>>
literal|16
operator|)
operator|&
literal|0x3
operator|)
operator|<<
literal|15
operator|)
operator||
operator|(
name|value
operator|&
literal|0x7fff
operator|)
operator|)
operator|>>
literal|1
expr_stmt|;
name|addend
operator|=
operator|(
name|hi16_offset
operator|<<
literal|16
operator|)
operator||
operator|(
name|offset
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|msec
operator|=
name|sec
expr_stmt|;
name|addend
operator|=
name|_bfd_elf_rel_local_sym
argument_list|(
name|output_bfd
argument_list|,
name|sym
argument_list|,
operator|&
name|msec
argument_list|,
name|addend
argument_list|)
expr_stmt|;
name|addend
operator|-=
name|relocation
expr_stmt|;
name|addend
operator|+=
name|msec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|msec
operator|->
name|output_offset
expr_stmt|;
name|uvalue
operator|=
name|addend
expr_stmt|;
name|hi16_offset
operator|=
operator|(
name|uvalue
operator|>>
literal|16
operator|)
operator|<<
literal|1
expr_stmt|;
name|hi16_value
operator|=
operator|(
name|hi16_addend
operator|&
operator|(
operator|~
operator|(
name|howto
operator|->
name|dst_mask
operator|)
operator|)
operator|)
operator||
operator|(
name|hi16_offset
operator|&
literal|0x7fff
operator|)
operator||
operator|(
operator|(
name|hi16_offset
operator|<<
literal|1
operator|)
operator|&
literal|0x30000
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|hi16_value
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|-
literal|4
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|(
name|uvalue
operator|&
literal|0xffff
operator|)
operator|<<
literal|1
expr_stmt|;
name|value
operator|=
operator|(
name|value
operator|&
operator|(
operator|~
operator|(
name|howto
operator|->
name|dst_mask
operator|)
operator|)
operator|)
operator||
operator|(
name|offset
operator|&
literal|0x7fff
operator|)
operator||
operator|(
operator|(
name|offset
operator|<<
literal|1
operator|)
operator|&
literal|0x30000
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|value
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_SCORE_GOT_LO16
case|:
name|value
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|addend
operator|=
operator|(
operator|(
operator|(
name|value
operator|>>
literal|16
operator|)
operator|&
literal|0x3
operator|)
operator|<<
literal|14
operator|)
operator||
operator|(
operator|(
name|value
operator|&
literal|0x7fff
operator|)
operator|>>
literal|1
operator|)
expr_stmt|;
name|msec
operator|=
name|sec
expr_stmt|;
name|addend
operator|=
name|_bfd_elf_rel_local_sym
argument_list|(
name|output_bfd
argument_list|,
name|sym
argument_list|,
operator|&
name|msec
argument_list|,
name|addend
argument_list|)
operator|-
name|relocation
expr_stmt|;
name|addend
operator|+=
name|msec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|msec
operator|->
name|output_offset
expr_stmt|;
name|value
operator|=
operator|(
name|value
operator|&
operator|(
operator|~
operator|(
name|howto
operator|->
name|dst_mask
operator|)
operator|)
operator|)
operator||
operator|(
operator|(
name|addend
operator|&
literal|0x3fff
operator|)
operator|<<
literal|1
operator|)
operator||
operator|(
operator|(
operator|(
name|addend
operator|>>
literal|14
operator|)
operator|&
literal|0x3
operator|)
operator|<<
literal|16
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|value
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
break|break;
default|default:
name|value
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
comment|/* Get the (signed) value from the instruction.  */
name|addend
operator|=
name|value
operator|&
name|howto
operator|->
name|src_mask
expr_stmt|;
if|if
condition|(
name|addend
operator|&
operator|(
operator|(
name|howto
operator|->
name|src_mask
operator|+
literal|1
operator|)
operator|>>
literal|1
operator|)
condition|)
block|{
name|bfd_signed_vma
name|mask
decl_stmt|;
name|mask
operator|=
operator|-
literal|1
expr_stmt|;
name|mask
operator|&=
operator|~
name|howto
operator|->
name|src_mask
expr_stmt|;
name|addend
operator||=
name|mask
expr_stmt|;
block|}
name|msec
operator|=
name|sec
expr_stmt|;
name|addend
operator|=
name|_bfd_elf_rel_local_sym
argument_list|(
name|output_bfd
argument_list|,
name|sym
argument_list|,
operator|&
name|msec
argument_list|,
name|addend
argument_list|)
operator|-
name|relocation
expr_stmt|;
name|addend
operator|+=
name|msec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|msec
operator|->
name|output_offset
expr_stmt|;
name|value
operator|=
operator|(
name|value
operator|&
operator|~
name|howto
operator|->
name|dst_mask
operator|)
operator||
operator|(
name|addend
operator|&
name|howto
operator|->
name|dst_mask
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|value
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
comment|/* For global symbols we look up the symbol in the hash-table.  */
name|h
operator|=
operator|(
operator|(
expr|struct
name|score_elf_link_hash_entry
operator|*
operator|)
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
index|[
name|r_symndx
operator|-
name|extsymoff
index|]
operator|)
expr_stmt|;
comment|/* Find the real hash-table entry for this symbol.  */
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|score_elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
comment|/* Record the name of this symbol, for our caller.  */
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
comment|/* See if this is the special GP_DISP_LABEL symbol.  Note that such a 	     symbol must always be a global symbol.  */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|GP_DISP_LABEL
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Relocations against GP_DISP_LABEL are permitted only with 		 R_SCORE_HI16 and R_SCORE_LO16 relocations.  */
if|if
condition|(
name|r_type
operator|!=
name|R_SCORE_HI16
operator|&&
name|r_type
operator|!=
name|R_SCORE_LO16
condition|)
return|return
name|bfd_reloc_notsupported
return|;
name|gp_disp_p
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* If this symbol is defined, calculate its address.  Note that 	      GP_DISP_LABEL is a magic symbol, always implicitly defined by the 	      linker, so it's inappropriate to check to see whether or not 	      its defined.  */
elseif|else
if|if
condition|(
operator|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
condition|)
block|{
name|sec
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|output_section
condition|)
name|relocation
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|)
expr_stmt|;
else|else
block|{
name|relocation
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
comment|/* We allow relocations against undefined weak symbols, giving 	       it the value zero, so that you can undefined weak functions 	       and check to see if they exist by looking at their addresses.  */
name|relocation
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|info
operator|->
name|unresolved_syms_in_objects
operator|==
name|RM_IGNORE
operator|&&
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|root
operator|.
name|other
argument_list|)
operator|==
name|STV_DEFAULT
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"_DYNAMIC_LINK"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* If this is a dynamic link, we should have created a _DYNAMIC_LINK symbol 	         in _bfd_score_elf_create_dynamic_sections.  Otherwise, we should define                  the symbol with a value of 0.  */
name|BFD_ASSERT
argument_list|(
operator|!
name|info
operator|->
name|shared
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
literal|".dynamic"
argument_list|)
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|relocation
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|info
operator|->
name|relocatable
condition|)
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
operator|(
name|info
operator|->
name|unresolved_syms_in_objects
operator|==
name|RM_GENERATE_ERROR
operator|)
operator|||
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|root
operator|.
name|other
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|bfd_reloc_undefined
return|;
name|relocation
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sec
operator|!=
name|NULL
operator|&&
name|elf_discarded_section
argument_list|(
name|sec
argument_list|)
condition|)
block|{
comment|/* For relocs against symbols from removed linkonce sections, 	     or sections discarded by a linker script, we just want the 	     section contents zeroed.  Avoid any special processing.  */
name|_bfd_clear_contents
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|rel
operator|->
name|r_info
operator|=
literal|0
expr_stmt|;
name|rel
operator|->
name|r_addend
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
block|{
comment|/* This is a relocatable link.  We don't have to change              anything, unless the reloc is against a section symbol,              in which case we have to adjust according to where the              section symbol winds up in the output section.  */
if|if
condition|(
name|sym
operator|!=
name|NULL
operator|&&
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_SECTION
condition|)
name|score_elf_add_to_rel
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|,
name|howto
argument_list|,
operator|(
name|bfd_signed_vma
operator|)
name|sec
operator|->
name|output_offset
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|r
operator|=
name|score_elf_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|output_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
argument_list|,
name|relocs
argument_list|,
name|relocation
argument_list|,
name|info
argument_list|,
name|name
argument_list|,
operator|(
name|h
condition|?
name|ELF_ST_TYPE
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
argument_list|)
else|:
name|ELF_ST_TYPE
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|sym
operator|->
name|st_info
argument_list|)
operator|)
argument_list|,
name|h
argument_list|,
name|local_sections
argument_list|,
name|gp_disp_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|bfd_reloc_ok
condition|)
block|{
specifier|const
name|char
modifier|*
name|msg
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
literal|0
decl_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|bfd_reloc_overflow
case|:
comment|/* If the overflowing reloc was to an undefined symbol,                  we have already printed one error message and there                  is no point complaining again.  */
if|if
condition|(
operator|(
operator|(
operator|!
name|h
operator|)
operator|||
operator|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefined
operator|)
operator|)
operator|&&
operator|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|info
argument_list|,
name|NULL
argument_list|,
name|name
argument_list|,
name|howto
operator|->
name|name
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
operator|)
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|bfd_reloc_undefined
case|:
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|info
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|TRUE
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|bfd_reloc_outofrange
case|:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: out of range error"
argument_list|)
expr_stmt|;
goto|goto
name|common_error
goto|;
case|case
name|bfd_reloc_notsupported
case|:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: unsupported relocation error"
argument_list|)
expr_stmt|;
goto|goto
name|common_error
goto|;
case|case
name|bfd_reloc_dangerous
case|:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: dangerous error"
argument_list|)
expr_stmt|;
goto|goto
name|common_error
goto|;
default|default:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: unknown error"
argument_list|)
expr_stmt|;
comment|/* fall through */
name|common_error
label|:
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|warning
call|)
argument_list|(
name|info
argument_list|,
name|msg
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
break|break;
block|}
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Look through the relocs for a section during the first phase, and    allocate space in the global offset table.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|_bfd_score_elf_check_relocs
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|struct
name|score_got_info
modifier|*
name|g
decl_stmt|;
name|size_t
name|extsymoff
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel_end
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
name|asection
modifier|*
name|sreloc
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
return|return
name|TRUE
return|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|extsymoff
operator|=
operator|(
name|elf_bad_symtab
argument_list|(
name|abfd
argument_list|)
operator|)
condition|?
literal|0
else|:
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynobj
operator|==
name|NULL
condition|)
block|{
name|sgot
operator|=
name|NULL
expr_stmt|;
name|g
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|sgot
operator|=
name|score_elf_got_section
argument_list|(
name|dynobj
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sgot
operator|==
name|NULL
condition|)
name|g
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|BFD_ASSERT
argument_list|(
name|score_elf_section_data
argument_list|(
name|sgot
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g
operator|=
name|score_elf_section_data
argument_list|(
name|sgot
argument_list|)
operator|->
name|u
operator|.
name|got_info
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|g
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
name|sreloc
operator|=
name|NULL
expr_stmt|;
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|rel_end
operator|=
name|relocs
operator|+
name|sec
operator|->
name|reloc_count
operator|*
name|bed
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|rel_end
condition|;
operator|++
name|rel
control|)
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|unsigned
name|int
name|r_type
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|extsymoff
condition|)
block|{
name|h
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r_symndx
operator|>=
name|extsymoff
operator|+
name|NUM_SHDR_ENTRIES
argument_list|(
name|symtab_hdr
argument_list|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: Malformed reloc detected for section %s"
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
else|else
block|{
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|extsymoff
index|]
expr_stmt|;
comment|/* This may be an indirect symbol created because of a version.  */
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
block|}
block|}
comment|/* Some relocs require a global offset table.  */
if|if
condition|(
name|dynobj
operator|==
name|NULL
operator|||
name|sgot
operator|==
name|NULL
condition|)
block|{
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_SCORE_GOT15
case|:
case|case
name|R_SCORE_CALL15
case|:
if|if
condition|(
name|dynobj
operator|==
name|NULL
condition|)
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
operator|=
name|dynobj
operator|=
name|abfd
expr_stmt|;
if|if
condition|(
operator|!
name|score_elf_create_got_section
argument_list|(
name|dynobj
argument_list|,
name|info
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|g
operator|=
name|score_elf_got_info
argument_list|(
name|dynobj
argument_list|,
operator|&
name|sgot
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_SCORE_ABS32
case|:
case|case
name|R_SCORE_REL32
case|:
if|if
condition|(
name|dynobj
operator|==
name|NULL
operator|&&
operator|(
name|info
operator|->
name|shared
operator|||
name|h
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
operator|=
name|dynobj
operator|=
name|abfd
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|h
operator|&&
operator|(
name|r_type
operator|==
name|R_SCORE_GOT_LO16
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|score_elf_record_local_got_symbol
argument_list|(
name|abfd
argument_list|,
name|r_symndx
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|,
name|g
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_SCORE_CALL15
case|:
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: CALL15 reloc at 0x%lx not against global symbol"
argument_list|)
argument_list|,
name|abfd
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
else|else
block|{
comment|/* This symbol requires a global offset table entry.  */
if|if
condition|(
operator|!
name|score_elf_record_global_got_symbol
argument_list|(
name|h
argument_list|,
name|abfd
argument_list|,
name|info
argument_list|,
name|g
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* We need a stub, not a plt entry for the undefined function.  But we record                  it as if it needs plt.  See _bfd_elf_adjust_dynamic_symbol.  */
name|h
operator|->
name|needs_plt
operator|=
literal|1
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|STT_FUNC
expr_stmt|;
block|}
break|break;
case|case
name|R_SCORE_GOT15
case|:
if|if
condition|(
name|h
operator|&&
operator|!
name|score_elf_record_global_got_symbol
argument_list|(
name|h
argument_list|,
name|abfd
argument_list|,
name|info
argument_list|,
name|g
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|R_SCORE_ABS32
case|:
case|case
name|R_SCORE_REL32
case|:
if|if
condition|(
operator|(
name|info
operator|->
name|shared
operator|||
name|h
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
block|{
name|sreloc
operator|=
name|score_elf_rel_dyn_section
argument_list|(
name|dynobj
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
define|#
directive|define
name|SCORE_READONLY_SECTION
value|(SEC_ALLOC | SEC_LOAD | SEC_READONLY)
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
comment|/* When creating a shared object, we must copy these reloc types into                      the output file as R_SCORE_REL32 relocs.  We make room for this reloc                      in the .rel.dyn reloc section.  */
name|score_elf_allocate_dynamic_relocations
argument_list|(
name|dynobj
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SCORE_READONLY_SECTION
operator|)
operator|==
name|SCORE_READONLY_SECTION
condition|)
comment|/* We tell the dynamic linker that there are 		       relocations against the text segment.  */
name|info
operator|->
name|flags
operator||=
name|DF_TEXTREL
expr_stmt|;
block|}
else|else
block|{
name|struct
name|score_elf_link_hash_entry
modifier|*
name|hscore
decl_stmt|;
comment|/* We only need to copy this reloc if the symbol is                      defined in a dynamic object.  */
name|hscore
operator|=
operator|(
expr|struct
name|score_elf_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
operator|++
name|hscore
operator|->
name|possibly_dynamic_relocs
expr_stmt|;
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SCORE_READONLY_SECTION
operator|)
operator|==
name|SCORE_READONLY_SECTION
condition|)
comment|/* We need it to tell the dynamic linker if there 		       are relocations against the text segment.  */
name|hscore
operator|->
name|readonly_reloc
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Even though we don't directly need a GOT entry for this symbol,                  a symbol must have a dynamic symbol table index greater that                  DT_SCORE_GOTSYM if there are dynamic relocations against it.  */
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dynobj
operator|==
name|NULL
condition|)
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
operator|=
name|dynobj
operator|=
name|abfd
expr_stmt|;
if|if
condition|(
operator|!
name|score_elf_create_got_section
argument_list|(
name|dynobj
argument_list|,
name|info
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|g
operator|=
name|score_elf_got_info
argument_list|(
name|dynobj
argument_list|,
operator|&
name|sgot
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|score_elf_record_global_got_symbol
argument_list|(
name|h
argument_list|,
name|abfd
argument_list|,
name|info
argument_list|,
name|g
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
break|break;
comment|/* This relocation describes the C++ object vtable hierarchy.              Reconstruct it for later use during GC.  */
case|case
name|R_SCORE_GNU_VTINHERIT
case|:
if|if
condition|(
operator|!
name|bfd_elf_gc_record_vtinherit
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|h
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
comment|/* This relocation describes which C++ vtable entries are actually              used.  Record for later use during GC.  */
case|case
name|R_SCORE_GNU_VTENTRY
case|:
if|if
condition|(
operator|!
name|bfd_elf_gc_record_vtentry
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|h
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
default|default:
break|break;
block|}
comment|/* We must not create a stub for a symbol that has relocations          related to taking the function's address.  */
switch|switch
condition|(
name|r_type
condition|)
block|{
default|default:
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|struct
name|score_elf_link_hash_entry
modifier|*
name|sh
decl_stmt|;
name|sh
operator|=
operator|(
expr|struct
name|score_elf_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
name|sh
operator|->
name|no_fn_stub
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
case|case
name|R_SCORE_CALL15
case|:
break|break;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|_bfd_score_elf_add_symbol_hook
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|namep
name|ATTRIBUTE_UNUSED
parameter_list|,
name|flagword
modifier|*
name|flagsp
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
modifier|*
name|secp
parameter_list|,
name|bfd_vma
modifier|*
name|valp
parameter_list|)
block|{
switch|switch
condition|(
name|sym
operator|->
name|st_shndx
condition|)
block|{
case|case
name|SHN_COMMON
case|:
if|if
condition|(
name|sym
operator|->
name|st_size
operator|>
name|elf_gp_size
argument_list|(
name|abfd
argument_list|)
condition|)
break|break;
comment|/* Fall through.  */
case|case
name|SHN_SCORE_SCOMMON
case|:
operator|*
name|secp
operator|=
name|bfd_make_section_old_way
argument_list|(
name|abfd
argument_list|,
literal|".scommon"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|secp
operator|)
operator|->
name|flags
operator||=
name|SEC_IS_COMMON
expr_stmt|;
operator|*
name|valp
operator|=
name|sym
operator|->
name|st_size
expr_stmt|;
break|break;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|_bfd_score_elf_symbol_processing
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asymbol
modifier|*
name|asym
parameter_list|)
block|{
name|elf_symbol_type
modifier|*
name|elfsym
decl_stmt|;
name|elfsym
operator|=
operator|(
name|elf_symbol_type
operator|*
operator|)
name|asym
expr_stmt|;
switch|switch
condition|(
name|elfsym
operator|->
name|internal_elf_sym
operator|.
name|st_shndx
condition|)
block|{
case|case
name|SHN_COMMON
case|:
if|if
condition|(
name|asym
operator|->
name|value
operator|>
name|elf_gp_size
argument_list|(
name|abfd
argument_list|)
condition|)
break|break;
comment|/* Fall through.  */
case|case
name|SHN_SCORE_SCOMMON
case|:
if|if
condition|(
name|score_elf_scom_section
operator|.
name|name
operator|==
name|NULL
condition|)
block|{
comment|/* Initialize the small common section.  */
name|score_elf_scom_section
operator|.
name|name
operator|=
literal|".scommon"
expr_stmt|;
name|score_elf_scom_section
operator|.
name|flags
operator|=
name|SEC_IS_COMMON
expr_stmt|;
name|score_elf_scom_section
operator|.
name|output_section
operator|=
operator|&
name|score_elf_scom_section
expr_stmt|;
name|score_elf_scom_section
operator|.
name|symbol
operator|=
operator|&
name|score_elf_scom_symbol
expr_stmt|;
name|score_elf_scom_section
operator|.
name|symbol_ptr_ptr
operator|=
operator|&
name|score_elf_scom_symbol_ptr
expr_stmt|;
name|score_elf_scom_symbol
operator|.
name|name
operator|=
literal|".scommon"
expr_stmt|;
name|score_elf_scom_symbol
operator|.
name|flags
operator|=
name|BSF_SECTION_SYM
expr_stmt|;
name|score_elf_scom_symbol
operator|.
name|section
operator|=
operator|&
name|score_elf_scom_section
expr_stmt|;
name|score_elf_scom_symbol_ptr
operator|=
operator|&
name|score_elf_scom_symbol
expr_stmt|;
block|}
name|asym
operator|->
name|section
operator|=
operator|&
name|score_elf_scom_section
expr_stmt|;
name|asym
operator|->
name|value
operator|=
name|elfsym
operator|->
name|internal_elf_sym
operator|.
name|st_size
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|_bfd_score_elf_link_output_symbol_hook
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|,
name|asection
modifier|*
name|input_sec
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* If we see a common symbol, which implies a relocatable link, then      if a symbol was small common in an input file, mark it as small      common in the output file.  */
if|if
condition|(
name|sym
operator|->
name|st_shndx
operator|==
name|SHN_COMMON
operator|&&
name|strcmp
argument_list|(
name|input_sec
operator|->
name|name
argument_list|,
literal|".scommon"
argument_list|)
operator|==
literal|0
condition|)
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_SCORE_SCOMMON
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|_bfd_score_elf_section_from_bfd_section
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|,
literal|".scommon"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|retval
operator|=
name|SHN_SCORE_SCOMMON
expr_stmt|;
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Adjust a symbol defined by a dynamic object and referenced by a    regular object.  The current definition is in some section of the    dynamic object, but we're not including those sections.  We have to    change the definition to something the rest of the link can understand.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|_bfd_score_elf_adjust_dynamic_symbol
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|)
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|struct
name|score_elf_link_hash_entry
modifier|*
name|hscore
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
comment|/* Make sure we know what is going on here.  */
name|BFD_ASSERT
argument_list|(
name|dynobj
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|needs_plt
operator|||
name|h
operator|->
name|u
operator|.
name|weakdef
operator|!=
name|NULL
operator|||
operator|(
name|h
operator|->
name|def_dynamic
operator|&&
name|h
operator|->
name|ref_regular
operator|&&
operator|!
name|h
operator|->
name|def_regular
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* If this symbol is defined in a dynamic object, we need to copy      any R_SCORE_ABS32 or R_SCORE_REL32 relocs against it into the output      file.  */
name|hscore
operator|=
operator|(
expr|struct
name|score_elf_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|relocatable
operator|&&
name|hscore
operator|->
name|possibly_dynamic_relocs
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|||
operator|!
name|h
operator|->
name|def_regular
operator|)
condition|)
block|{
name|score_elf_allocate_dynamic_relocations
argument_list|(
name|dynobj
argument_list|,
name|hscore
operator|->
name|possibly_dynamic_relocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|hscore
operator|->
name|readonly_reloc
condition|)
comment|/* We tell the dynamic linker that there are relocations            against the text segment.  */
name|info
operator|->
name|flags
operator||=
name|DF_TEXTREL
expr_stmt|;
block|}
comment|/* For a function, create a stub, if allowed.  */
if|if
condition|(
operator|!
name|hscore
operator|->
name|no_fn_stub
operator|&&
name|h
operator|->
name|needs_plt
condition|)
block|{
if|if
condition|(
operator|!
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
return|return
name|TRUE
return|;
comment|/* If this symbol is not defined in a regular file, then set          the symbol to the stub location.  This is required to make          function pointers compare as equal between the normal          executable and the shared library.  */
if|if
condition|(
operator|!
name|h
operator|->
name|def_regular
condition|)
block|{
comment|/* We need .stub section.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|SCORE_ELF_STUB_SECTION_NAME
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|s
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|s
operator|->
name|size
expr_stmt|;
comment|/* XXX Write this stub address somewhere.  */
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
name|s
operator|->
name|size
expr_stmt|;
comment|/* Make room for this stub code.  */
name|s
operator|->
name|size
operator|+=
name|SCORE_FUNCTION_STUB_SIZE
expr_stmt|;
comment|/* The last half word of the stub will be filled with the index              of this symbol in .dynsym section.  */
return|return
name|TRUE
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|h
operator|->
name|type
operator|==
name|STT_FUNC
operator|)
operator|&&
operator|!
name|h
operator|->
name|needs_plt
condition|)
block|{
comment|/* This will set the entry for this symbol in the GOT to 0, and          the dynamic linker will take care of this.  */
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
literal|0
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* If this is a weak symbol, and there is a real definition, the      processor independent code will have arranged for us to see the      real definition first, and we can just use the same value.  */
if|if
condition|(
name|h
operator|->
name|u
operator|.
name|weakdef
operator|!=
name|NULL
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
argument_list|)
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* This is a reference to a symbol defined by a dynamic object which      is not a function.  */
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* This function is called after all the input files have been read,    and the input sections have been assigned to output sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|_bfd_score_elf_always_size_sections
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|struct
name|score_got_info
modifier|*
name|g
decl_stmt|;
name|int
name|i
decl_stmt|;
name|bfd_size_type
name|loadable_size
init|=
literal|0
decl_stmt|;
name|bfd_size_type
name|local_gotno
decl_stmt|;
name|bfd
modifier|*
name|sub
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
if|if
condition|(
name|dynobj
operator|==
name|NULL
condition|)
comment|/* Relocatable links don't have it.  */
return|return
name|TRUE
return|;
name|g
operator|=
name|score_elf_got_info
argument_list|(
name|dynobj
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
comment|/* Calculate the total loadable size of the output.  That will give us the      maximum number of GOT_PAGE entries required.  */
for|for
control|(
name|sub
operator|=
name|info
operator|->
name|input_bfds
init|;
name|sub
condition|;
name|sub
operator|=
name|sub
operator|->
name|link_next
control|)
block|{
name|asection
modifier|*
name|subsection
decl_stmt|;
for|for
control|(
name|subsection
operator|=
name|sub
operator|->
name|sections
init|;
name|subsection
condition|;
name|subsection
operator|=
name|subsection
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|subsection
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|loadable_size
operator|+=
operator|(
operator|(
name|subsection
operator|->
name|size
operator|+
literal|0xf
operator|)
operator|&
operator|~
operator|(
name|bfd_size_type
operator|)
literal|0xf
operator|)
expr_stmt|;
block|}
block|}
comment|/* There has to be a global GOT entry for every symbol with      a dynamic symbol table index of DT_SCORE_GOTSYM or      higher.  Therefore, it make sense to put those symbols      that need GOT entries at the end of the symbol table.  We      do that here.  */
if|if
condition|(
operator|!
name|score_elf_sort_hash_table
argument_list|(
name|info
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|g
operator|->
name|global_gotsym
operator|!=
name|NULL
condition|)
name|i
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynsymcount
operator|-
name|g
operator|->
name|global_gotsym
operator|->
name|dynindx
expr_stmt|;
else|else
comment|/* If there are no global symbols, or none requiring        relocations, then GLOBAL_GOTSYM will be NULL.  */
name|i
operator|=
literal|0
expr_stmt|;
comment|/* In the worst case, we'll get one stub per dynamic symbol.  */
name|loadable_size
operator|+=
name|SCORE_FUNCTION_STUB_SIZE
operator|*
name|i
expr_stmt|;
comment|/* Assume there are two loadable segments consisting of      contiguous sections.  Is 5 enough?  */
name|local_gotno
operator|=
operator|(
name|loadable_size
operator|>>
literal|16
operator|)
operator|+
literal|5
expr_stmt|;
name|g
operator|->
name|local_gotno
operator|+=
name|local_gotno
expr_stmt|;
name|s
operator|->
name|size
operator|+=
name|g
operator|->
name|local_gotno
operator|*
name|SCORE_ELF_GOT_SIZE
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
name|g
operator|->
name|global_gotno
operator|=
name|i
expr_stmt|;
name|s
operator|->
name|size
operator|+=
name|i
operator|*
name|SCORE_ELF_GOT_SIZE
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
name|score_elf_resolve_final_got_entries
argument_list|(
name|g
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|size
operator|>
name|SCORE_ELF_GOT_MAX_SIZE
argument_list|(
name|output_bfd
argument_list|)
condition|)
block|{
comment|/* Fixme. Error message or Warning message should be issued here.  */
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Set the sizes of the dynamic sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|_bfd_score_elf_size_dynamic_sections
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_boolean
name|reltext
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|dynobj
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
comment|/* Set the contents of the .interp section to the interpreter.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".interp"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|size
operator|=
name|strlen
argument_list|(
name|ELF_DYNAMIC_INTERPRETER
argument_list|)
operator|+
literal|1
expr_stmt|;
name|s
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|ELF_DYNAMIC_INTERPRETER
expr_stmt|;
block|}
block|}
comment|/* The check_relocs and adjust_dynamic_symbol entry points have      determined the sizes of the various dynamic sections.  Allocate      memory for them.  */
name|reltext
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|s
operator|=
name|dynobj
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LINKER_CREATED
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* It's OK to base decisions on the section name, because none          of the dynobj section names depend upon the input files.  */
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONST_STRNEQ
argument_list|(
name|name
argument_list|,
literal|".rel"
argument_list|)
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|size
operator|==
literal|0
condition|)
block|{
comment|/* We only strip the section if the output section name                  has the same name.  Otherwise, there might be several                  input sections for this output section.  FIXME: This                  code is probably not needed these days anyhow, since                  the linker now does not create empty output sections.  */
if|if
condition|(
name|s
operator|->
name|output_section
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|bfd_get_section_name
argument_list|(
name|s
operator|->
name|output_section
operator|->
name|owner
argument_list|,
name|s
operator|->
name|output_section
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|s
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|outname
decl_stmt|;
name|asection
modifier|*
name|target
decl_stmt|;
comment|/* If this relocation section applies to a read only                  section, then we probably need a DT_TEXTREL entry.                  If the relocation section is .rel.dyn, we always                  assert a DT_TEXTREL entry rather than testing whether                  there exists a relocation to a read only section or                  not.  */
name|outname
operator|=
name|bfd_get_section_name
argument_list|(
name|output_bfd
argument_list|,
name|s
operator|->
name|output_section
argument_list|)
expr_stmt|;
name|target
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
name|outname
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|target
operator|!=
name|NULL
operator|&&
operator|(
name|target
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|target
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
operator|)
operator|||
name|strcmp
argument_list|(
name|outname
argument_list|,
literal|".rel.dyn"
argument_list|)
operator|==
literal|0
condition|)
name|reltext
operator|=
name|TRUE
expr_stmt|;
comment|/* We use the reloc_count field as a counter if we need                  to copy relocs into the output file.  */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".rel.dyn"
argument_list|)
operator|!=
literal|0
condition|)
name|s
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|CONST_STRNEQ
argument_list|(
name|name
argument_list|,
literal|".got"
argument_list|)
condition|)
block|{
comment|/* _bfd_score_elf_always_size_sections() has already done 	     most of the work, but some symbols may have been mapped 	     to versions that we must now resolve in the got_entries 	     hash tables.  */
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|SCORE_ELF_STUB_SECTION_NAME
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* IRIX rld assumes that the function stub isn't at the end              of .text section. So put a dummy. XXX  */
name|s
operator|->
name|size
operator|+=
name|SCORE_FUNCTION_STUB_SIZE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|CONST_STRNEQ
argument_list|(
name|name
argument_list|,
literal|".init"
argument_list|)
condition|)
block|{
comment|/* It's not one of our sections, so don't allocate space.  */
continue|continue;
block|}
comment|/* Allocate memory for the section contents.  */
name|s
operator|->
name|contents
operator|=
name|bfd_zalloc
argument_list|(
name|dynobj
argument_list|,
name|s
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|contents
operator|==
name|NULL
operator|&&
name|s
operator|->
name|size
operator|!=
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
comment|/* Add some entries to the .dynamic section.  We fill in the 	 values later, in _bfd_score_elf_finish_dynamic_sections, but we 	 must add the entries now so that we get the correct size for 	 the .dynamic section.  The DT_DEBUG entry is filled in by the 	 dynamic linker and used by the debugger.  */
if|if
condition|(
operator|!
name|SCORE_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_DEBUG
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|reltext
condition|)
name|info
operator|->
name|flags
operator||=
name|DF_TEXTREL
expr_stmt|;
if|if
condition|(
operator|(
name|info
operator|->
name|flags
operator|&
name|DF_TEXTREL
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|SCORE_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_TEXTREL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|SCORE_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_PLTGOT
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|score_elf_rel_dyn_section
argument_list|(
name|dynobj
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|SCORE_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_REL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|SCORE_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_RELSZ
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|SCORE_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_RELENT
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|SCORE_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_SCORE_BASE_ADDRESS
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|SCORE_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_SCORE_LOCAL_GOTNO
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|SCORE_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_SCORE_SYMTABNO
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|SCORE_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_SCORE_UNREFEXTNO
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|SCORE_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_SCORE_GOTSYM
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|SCORE_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_SCORE_HIPAGENO
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|_bfd_score_elf_create_dynamic_sections
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|bh
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|flags
operator|=
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_READONLY
operator|)
expr_stmt|;
comment|/* ABI requests the .dynamic section to be read only.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|flags
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* We need to create .got section.  */
if|if
condition|(
operator|!
name|score_elf_create_got_section
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|score_elf_rel_dyn_section
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Create .stub section.  */
if|if
condition|(
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|SCORE_ELF_STUB_SECTION_NAME
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|s
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|abfd
argument_list|,
name|SCORE_ELF_STUB_SECTION_NAME
argument_list|,
name|flags
operator||
name|SEC_CODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
literal|"_DYNAMIC_LINK"
expr_stmt|;
name|bh
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
name|name
argument_list|,
name|BSF_GLOBAL
argument_list|,
name|bfd_abs_section_ptr
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|collect
argument_list|,
operator|&
name|bh
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|bh
expr_stmt|;
name|h
operator|->
name|non_elf
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|def_regular
operator|=
literal|1
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|STT_SECTION
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Finish up dynamic symbol handling.  We set the contents of various    dynamic sections here.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|_bfd_score_elf_finish_dynamic_symbol
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|)
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
name|struct
name|score_got_info
modifier|*
name|g
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|!=
name|MINUS_ONE
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_byte
name|stub
index|[
name|SCORE_FUNCTION_STUB_SIZE
index|]
decl_stmt|;
comment|/* This symbol has a stub.  Set it up.  */
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|SCORE_ELF_STUB_SECTION_NAME
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* FIXME: Can h->dynindex be more than 64K?  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|&
literal|0xffff0000
condition|)
return|return
name|FALSE
return|;
comment|/* Fill the stub.  */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|STUB_LW
argument_list|,
name|stub
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|STUB_MOVE
argument_list|,
name|stub
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|STUB_LI16
operator||
operator|(
name|h
operator|->
name|dynindx
operator|<<
literal|1
operator|)
argument_list|,
name|stub
operator|+
literal|8
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|STUB_BRL
argument_list|,
name|stub
operator|+
literal|12
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|<=
name|s
operator|->
name|size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|s
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
argument_list|,
name|stub
argument_list|,
name|SCORE_FUNCTION_STUB_SIZE
argument_list|)
expr_stmt|;
comment|/* Mark the symbol as undefined.  plt.offset != -1 occurs 	 only for the referenced symbol.  */
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_UNDEF
expr_stmt|;
comment|/* The run-time linker uses the st_value field of the symbol 	  to reset the global offset table entry for this external 	  to its stub address when unlinking a shared object.  */
name|sym
operator|->
name|st_value
operator|=
operator|(
name|s
operator|->
name|output_section
operator|->
name|vma
operator|+
name|s
operator|->
name|output_offset
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|)
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|||
name|h
operator|->
name|forced_local
argument_list|)
expr_stmt|;
name|sgot
operator|=
name|score_elf_got_section
argument_list|(
name|dynobj
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|score_elf_section_data
argument_list|(
name|sgot
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g
operator|=
name|score_elf_section_data
argument_list|(
name|sgot
argument_list|)
operator|->
name|u
operator|.
name|got_info
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|g
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Run through the global symbol table, creating GOT entries for all      the symbols that need them.  */
if|if
condition|(
name|g
operator|->
name|global_gotsym
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|dynindx
operator|>=
name|g
operator|->
name|global_gotsym
operator|->
name|dynindx
condition|)
block|{
name|bfd_vma
name|offset
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
name|value
operator|=
name|sym
operator|->
name|st_value
expr_stmt|;
name|offset
operator|=
name|score_elf_global_got_index
argument_list|(
name|dynobj
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|value
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|offset
argument_list|)
expr_stmt|;
block|}
comment|/* Mark _DYNAMIC and _GLOBAL_OFFSET_TABLE_ as absolute.  */
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"_DYNAMIC"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|)
operator|==
literal|0
condition|)
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_ABS
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"_DYNAMIC_LINK"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_ABS
expr_stmt|;
name|sym
operator|->
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_GLOBAL
argument_list|,
name|STT_SECTION
argument_list|)
expr_stmt|;
name|sym
operator|->
name|st_value
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|GP_DISP_LABEL
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_ABS
expr_stmt|;
name|sym
operator|->
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_GLOBAL
argument_list|,
name|STT_SECTION
argument_list|)
expr_stmt|;
name|sym
operator|->
name|st_value
operator|=
name|elf_gp
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Finish up the dynamic sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|_bfd_score_elf_finish_dynamic_sections
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|sdyn
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|struct
name|score_got_info
modifier|*
name|g
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|sdyn
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
name|sgot
operator|=
name|score_elf_got_section
argument_list|(
name|dynobj
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sgot
operator|==
name|NULL
condition|)
name|g
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|BFD_ASSERT
argument_list|(
name|score_elf_section_data
argument_list|(
name|sgot
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g
operator|=
name|score_elf_section_data
argument_list|(
name|sgot
argument_list|)
operator|->
name|u
operator|.
name|got_info
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|g
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
name|bfd_byte
modifier|*
name|b
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|sdyn
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|g
operator|!=
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|b
operator|=
name|sdyn
operator|->
name|contents
init|;
name|b
operator|<
name|sdyn
operator|->
name|contents
operator|+
name|sdyn
operator|->
name|size
condition|;
name|b
operator|+=
name|SCORE_ELF_DYN_SIZE
argument_list|(
name|dynobj
argument_list|)
control|)
block|{
name|Elf_Internal_Dyn
name|dyn
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|size_t
name|elemsize
decl_stmt|;
name|bfd_boolean
name|swap_out_p
decl_stmt|;
comment|/* Read in the current dynamic entry.  */
operator|(
operator|*
name|get_elf_backend_data
argument_list|(
name|dynobj
argument_list|)
operator|->
name|s
operator|->
name|swap_dyn_in
operator|)
operator|(
name|dynobj
operator|,
name|b
operator|,
operator|&
name|dyn
operator|)
expr_stmt|;
comment|/* Assume that we're going to modify it and write it out.  */
name|swap_out_p
operator|=
name|TRUE
expr_stmt|;
switch|switch
condition|(
name|dyn
operator|.
name|d_tag
condition|)
block|{
case|case
name|DT_RELENT
case|:
name|s
operator|=
name|score_elf_rel_dyn_section
argument_list|(
name|dynobj
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|SCORE_ELF_REL_SIZE
argument_list|(
name|dynobj
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_STRSZ
case|:
comment|/* Rewrite DT_STRSZ.  */
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|_bfd_elf_strtab_size
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_PLTGOT
case|:
name|name
operator|=
literal|".got"
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|s
operator|->
name|vma
expr_stmt|;
break|break;
case|case
name|DT_SCORE_BASE_ADDRESS
case|:
name|s
operator|=
name|output_bfd
operator|->
name|sections
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|s
operator|->
name|vma
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
literal|0xffff
expr_stmt|;
break|break;
case|case
name|DT_SCORE_LOCAL_GOTNO
case|:
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|g
operator|->
name|local_gotno
expr_stmt|;
break|break;
case|case
name|DT_SCORE_UNREFEXTNO
case|:
comment|/* The index into the dynamic symbol table which is the 		 entry of the first external symbol that is not 		 referenced within the same object.  */
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|bfd_count_sections
argument_list|(
name|output_bfd
argument_list|)
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|DT_SCORE_GOTSYM
case|:
if|if
condition|(
name|g
operator|->
name|global_gotsym
condition|)
block|{
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|g
operator|->
name|global_gotsym
operator|->
name|dynindx
expr_stmt|;
break|break;
block|}
comment|/* In case if we don't have global got symbols we default 		  to setting DT_SCORE_GOTSYM to the same value as 		  DT_SCORE_SYMTABNO, so we just fall through.  */
case|case
name|DT_SCORE_SYMTABNO
case|:
name|name
operator|=
literal|".dynsym"
expr_stmt|;
name|elemsize
operator|=
name|SCORE_ELF_SYM_SIZE
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|s
operator|->
name|size
operator|/
name|elemsize
expr_stmt|;
break|break;
case|case
name|DT_SCORE_HIPAGENO
case|:
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|g
operator|->
name|local_gotno
operator|-
name|SCORE_RESERVED_GOTNO
expr_stmt|;
break|break;
default|default:
name|swap_out_p
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|swap_out_p
condition|)
operator|(
operator|*
name|get_elf_backend_data
argument_list|(
name|dynobj
argument_list|)
operator|->
name|s
operator|->
name|swap_dyn_out
operator|)
operator|(
name|dynobj
operator|,
operator|&
name|dyn
operator|,
name|b
operator|)
expr_stmt|;
block|}
block|}
comment|/* The first entry of the global offset table will be filled at      runtime. The second entry will be used by some runtime loaders.      This isn't the case of IRIX rld.  */
if|if
condition|(
name|sgot
operator|!=
name|NULL
operator|&&
name|sgot
operator|->
name|size
operator|>
literal|0
condition|)
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
literal|0
argument_list|,
name|sgot
operator|->
name|contents
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
literal|0x80000000
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|SCORE_ELF_GOT_SIZE
argument_list|(
name|output_bfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sgot
operator|!=
name|NULL
condition|)
name|elf_section_data
argument_list|(
name|sgot
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
operator|=
name|SCORE_ELF_GOT_SIZE
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
comment|/* We need to sort the entries of the dynamic relocation section.  */
name|s
operator|=
name|score_elf_rel_dyn_section
argument_list|(
name|dynobj
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
name|s
operator|->
name|size
operator|>
operator|(
name|bfd_vma
operator|)
literal|2
operator|*
name|SCORE_ELF_REL_SIZE
argument_list|(
name|output_bfd
argument_list|)
condition|)
block|{
name|reldyn_sorting_bfd
operator|=
name|output_bfd
expr_stmt|;
name|qsort
argument_list|(
operator|(
name|Elf32_External_Rel
operator|*
operator|)
name|s
operator|->
name|contents
operator|+
literal|1
argument_list|,
name|s
operator|->
name|reloc_count
operator|-
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
argument_list|,
name|score_elf_sort_dynamic_relocs
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* This function set up the ELF section header for a BFD section in preparation for writing    it out.  This is where the flags and type fields are set for unusual sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|_bfd_score_elf_fake_sections
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|Elf_Internal_Shdr
modifier|*
name|hdr
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".got"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".srdata"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sdata"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sbss"
argument_list|)
operator|==
literal|0
condition|)
name|hdr
operator|->
name|sh_flags
operator||=
name|SHF_SCORE_GPREL
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* This function do additional processing on the ELF section header before writing    it out.  This is used to set the flags and type fields for some sections.  */
end_comment

begin_comment
comment|/* assign_file_positions_except_relocs() check section flag and if it is allocatable,    warning message will be issued.  backend_fake_section is called before    assign_file_positions_except_relocs(); backend_section_processing after it.  so, we    modify section flag there, but not backend_fake_section.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|_bfd_score_elf_section_processing
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|Elf_Internal_Shdr
modifier|*
name|hdr
parameter_list|)
block|{
if|if
condition|(
name|hdr
operator|->
name|bfd_section
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|bfd_section
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sdata"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hdr
operator|->
name|sh_flags
operator||=
name|SHF_ALLOC
operator||
name|SHF_WRITE
operator||
name|SHF_SCORE_GPREL
expr_stmt|;
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_PROGBITS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sbss"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hdr
operator|->
name|sh_flags
operator||=
name|SHF_ALLOC
operator||
name|SHF_WRITE
operator||
name|SHF_SCORE_GPREL
expr_stmt|;
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_NOBITS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".srdata"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hdr
operator|->
name|sh_flags
operator||=
name|SHF_ALLOC
operator||
name|SHF_SCORE_GPREL
expr_stmt|;
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_PROGBITS
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|_bfd_score_elf_write_section
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|)
block|{
name|bfd_byte
modifier|*
name|to
decl_stmt|,
modifier|*
name|from
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
literal|".pdr"
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|score_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|u
operator|.
name|tdata
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|to
operator|=
name|contents
expr_stmt|;
name|end
operator|=
name|contents
operator|+
name|sec
operator|->
name|size
expr_stmt|;
for|for
control|(
name|from
operator|=
name|contents
operator|,
name|i
operator|=
literal|0
init|;
name|from
operator|<
name|end
condition|;
name|from
operator|+=
name|PDR_SIZE
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|score_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|u
operator|.
name|tdata
operator|)
index|[
name|i
index|]
operator|==
literal|1
condition|)
continue|continue;
if|if
condition|(
name|to
operator|!=
name|from
condition|)
name|memcpy
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|PDR_SIZE
argument_list|)
expr_stmt|;
name|to
operator|+=
name|PDR_SIZE
expr_stmt|;
block|}
name|bfd_set_section_contents
argument_list|(
name|output_bfd
argument_list|,
name|sec
operator|->
name|output_section
argument_list|,
name|contents
argument_list|,
operator|(
name|file_ptr
operator|)
name|sec
operator|->
name|output_offset
argument_list|,
name|sec
operator|->
name|size
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Copy data from a SCORE ELF indirect symbol to its direct symbol, hiding the old    indirect symbol.  Process additional relocation information.  */
end_comment

begin_function
specifier|static
name|void
name|_bfd_score_elf_copy_indirect_symbol
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|dir
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|ind
parameter_list|)
block|{
name|struct
name|score_elf_link_hash_entry
modifier|*
name|dirscore
decl_stmt|,
modifier|*
name|indscore
decl_stmt|;
name|_bfd_elf_link_hash_copy_indirect
argument_list|(
name|info
argument_list|,
name|dir
argument_list|,
name|ind
argument_list|)
expr_stmt|;
if|if
condition|(
name|ind
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_indirect
condition|)
return|return;
name|dirscore
operator|=
operator|(
expr|struct
name|score_elf_link_hash_entry
operator|*
operator|)
name|dir
expr_stmt|;
name|indscore
operator|=
operator|(
expr|struct
name|score_elf_link_hash_entry
operator|*
operator|)
name|ind
expr_stmt|;
name|dirscore
operator|->
name|possibly_dynamic_relocs
operator|+=
name|indscore
operator|->
name|possibly_dynamic_relocs
expr_stmt|;
if|if
condition|(
name|indscore
operator|->
name|readonly_reloc
condition|)
name|dirscore
operator|->
name|readonly_reloc
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|indscore
operator|->
name|no_fn_stub
condition|)
name|dirscore
operator|->
name|no_fn_stub
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove information about discarded functions from other sections which mention them.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|_bfd_score_elf_discard_info
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|elf_reloc_cookie
modifier|*
name|cookie
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|asection
modifier|*
name|o
decl_stmt|;
name|bfd_boolean
name|ret
init|=
name|FALSE
decl_stmt|;
name|unsigned
name|char
modifier|*
name|tdata
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|skip
decl_stmt|;
name|o
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".pdr"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|o
operator|)
operator|||
operator|(
name|o
operator|->
name|size
operator|==
literal|0
operator|)
operator|||
operator|(
name|o
operator|->
name|size
operator|%
name|PDR_SIZE
operator|!=
literal|0
operator|)
operator|||
operator|(
name|o
operator|->
name|output_section
operator|!=
name|NULL
operator|&&
name|bfd_is_abs_section
argument_list|(
name|o
operator|->
name|output_section
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
name|tdata
operator|=
name|bfd_zmalloc
argument_list|(
name|o
operator|->
name|size
operator|/
name|PDR_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tdata
condition|)
return|return
name|FALSE
return|;
name|cookie
operator|->
name|rels
operator|=
name|_bfd_elf_link_read_relocs
argument_list|(
name|abfd
argument_list|,
name|o
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cookie
operator|->
name|rels
condition|)
block|{
name|free
argument_list|(
name|tdata
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|cookie
operator|->
name|rel
operator|=
name|cookie
operator|->
name|rels
expr_stmt|;
name|cookie
operator|->
name|relend
operator|=
name|cookie
operator|->
name|rels
operator|+
name|o
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|skip
operator|=
literal|0
init|;
name|i
operator|<
name|o
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bfd_elf_reloc_symbol_deleted_p
argument_list|(
name|i
operator|*
name|PDR_SIZE
argument_list|,
name|cookie
argument_list|)
condition|)
block|{
name|tdata
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|skip
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|skip
operator|!=
literal|0
condition|)
block|{
name|score_elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|u
operator|.
name|tdata
operator|=
name|tdata
expr_stmt|;
name|o
operator|->
name|size
operator|-=
name|skip
operator|*
name|PDR_SIZE
expr_stmt|;
name|ret
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|free
argument_list|(
name|tdata
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|cookie
operator|->
name|rels
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Signal that discard_info() has removed the discarded relocations for this section.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|_bfd_score_elf_ignore_discarded_relocs
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
literal|".pdr"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Return the section that should be marked against GC for a given    relocation.  */
end_comment

begin_function
specifier|static
name|asection
modifier|*
name|_bfd_score_elf_gc_mark_hook
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|rel
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|)
block|{
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
switch|switch
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_SCORE_GNU_VTINHERIT
case|:
case|case
name|R_SCORE_GNU_VTENTRY
case|:
return|return
name|NULL
return|;
block|}
return|return
name|_bfd_elf_gc_mark_hook
argument_list|(
name|sec
argument_list|,
name|info
argument_list|,
name|rel
argument_list|,
name|h
argument_list|,
name|sym
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Support for core dump NOTE sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|_bfd_score_elf_grok_prstatus
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Note
modifier|*
name|note
parameter_list|)
block|{
name|int
name|offset
decl_stmt|;
name|unsigned
name|int
name|raw_size
decl_stmt|;
switch|switch
condition|(
name|note
operator|->
name|descsz
condition|)
block|{
default|default:
return|return
name|FALSE
return|;
case|case
literal|148
case|:
comment|/* Linux/Score 32-bit.  */
comment|/* pr_cursig */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_signal
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|note
operator|->
name|descdata
operator|+
literal|12
argument_list|)
expr_stmt|;
comment|/* pr_pid */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_pid
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|note
operator|->
name|descdata
operator|+
literal|24
argument_list|)
expr_stmt|;
comment|/* pr_reg */
name|offset
operator|=
literal|72
expr_stmt|;
name|raw_size
operator|=
literal|72
expr_stmt|;
break|break;
block|}
comment|/* Make a ".reg/999" section.  */
return|return
name|_bfd_elfcore_make_pseudosection
argument_list|(
name|abfd
argument_list|,
literal|".reg"
argument_list|,
name|raw_size
argument_list|,
name|note
operator|->
name|descpos
operator|+
name|offset
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|_bfd_score_elf_grok_psinfo
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Note
modifier|*
name|note
parameter_list|)
block|{
switch|switch
condition|(
name|note
operator|->
name|descsz
condition|)
block|{
default|default:
return|return
name|FALSE
return|;
case|case
literal|124
case|:
comment|/* Linux/Score elf_prpsinfo.  */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_program
operator|=
name|_bfd_elfcore_strndup
argument_list|(
name|abfd
argument_list|,
name|note
operator|->
name|descdata
operator|+
literal|28
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_command
operator|=
name|_bfd_elfcore_strndup
argument_list|(
name|abfd
argument_list|,
name|note
operator|->
name|descdata
operator|+
literal|44
argument_list|,
literal|80
argument_list|)
expr_stmt|;
block|}
comment|/* Note that for some reason, a spurious space is tacked      onto the end of the args in some (at least one anyway)      implementations, so strip it off if it exists.  */
block|{
name|char
modifier|*
name|command
init|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_command
decl_stmt|;
name|int
name|n
init|=
name|strlen
argument_list|(
name|command
argument_list|)
decl_stmt|;
if|if
condition|(
literal|0
operator|<
name|n
operator|&&
name|command
index|[
name|n
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
name|command
index|[
name|n
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Score BFD functions.  */
end_comment

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|elf32_score_reloc_type_lookup
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd_reloc_code_real_type
name|code
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_ELEM
argument_list|(
name|elf32_score_reloc_map
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|elf32_score_reloc_map
index|[
name|i
index|]
operator|.
name|bfd_reloc_val
operator|==
name|code
condition|)
return|return
operator|&
name|elf32_score_howto_table
index|[
name|elf32_score_reloc_map
index|[
name|i
index|]
operator|.
name|elf_reloc_val
index|]
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|elf32_score_reloc_name_lookup
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|r_name
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|elf32_score_howto_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|elf32_score_howto_table
index|[
literal|0
index|]
argument_list|)
operator|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|elf32_score_howto_table
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
operator|&&
name|strcasecmp
argument_list|(
name|elf32_score_howto_table
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|r_name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|&
name|elf32_score_howto_table
index|[
name|i
index|]
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Create a score elf linker hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_link_hash_table
modifier|*
name|elf32_score_link_hash_table_create
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|struct
name|score_elf_link_hash_table
modifier|*
name|ret
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|score_elf_link_hash_table
argument_list|)
decl_stmt|;
name|ret
operator|=
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|_bfd_elf_link_hash_table_init
argument_list|(
operator|&
name|ret
operator|->
name|root
argument_list|,
name|abfd
argument_list|,
name|score_elf_link_hash_newfunc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|score_elf_link_hash_entry
argument_list|)
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
operator|&
name|ret
operator|->
name|root
operator|.
name|root
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elf32_score_print_private_bfd_data
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|FILE
modifier|*
name|file
init|=
operator|(
name|FILE
operator|*
operator|)
name|ptr
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|abfd
operator|!=
name|NULL
operator|&&
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Print normal ELF private data.  */
name|_bfd_elf_print_private_bfd_data
argument_list|(
name|abfd
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
comment|/* xgettext:c-format */
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"private flags = %lx:"
argument_list|)
argument_list|,
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_SCORE_PIC
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [pic]"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_SCORE_FIXDEP
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [fix dep]"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elf32_score_merge_private_bfd_data
parameter_list|(
name|bfd
modifier|*
name|ibfd
parameter_list|,
name|bfd
modifier|*
name|obfd
parameter_list|)
block|{
name|flagword
name|in_flags
decl_stmt|;
name|flagword
name|out_flags
decl_stmt|;
if|if
condition|(
operator|!
name|_bfd_generic_verify_endian_match
argument_list|(
name|ibfd
argument_list|,
name|obfd
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|in_flags
operator|=
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
name|out_flags
operator|=
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|ibfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
operator|||
name|bfd_get_flavour
argument_list|(
name|obfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
return|return
name|TRUE
return|;
name|in_flags
operator|=
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
name|out_flags
operator|=
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
if|if
condition|(
operator|!
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
condition|)
block|{
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
operator|=
name|TRUE
expr_stmt|;
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|=
name|in_flags
expr_stmt|;
if|if
condition|(
name|bfd_get_arch
argument_list|(
name|obfd
argument_list|)
operator|==
name|bfd_get_arch
argument_list|(
name|ibfd
argument_list|)
operator|&&
name|bfd_get_arch_info
argument_list|(
name|obfd
argument_list|)
operator|->
name|the_default
condition|)
block|{
return|return
name|bfd_set_arch_mach
argument_list|(
name|obfd
argument_list|,
name|bfd_get_arch
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|bfd_get_mach
argument_list|(
name|ibfd
argument_list|)
argument_list|)
return|;
block|}
return|return
name|TRUE
return|;
block|}
if|if
condition|(
operator|(
operator|(
name|in_flags
operator|&
name|EF_SCORE_PIC
operator|)
operator|!=
literal|0
operator|)
operator|!=
operator|(
operator|(
name|out_flags
operator|&
name|EF_SCORE_PIC
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: warning: linking PIC files with non-PIC files"
argument_list|)
argument_list|,
name|ibfd
argument_list|)
expr_stmt|;
block|}
comment|/* FIXME: Maybe dependency fix compatibility should be checked here.  */
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elf32_score_new_section_hook
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|)
block|{
name|struct
name|_score_elf_section_data
modifier|*
name|sdata
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
operator|*
name|sdata
argument_list|)
decl_stmt|;
name|sdata
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdata
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|sec
operator|->
name|used_by_bfd
operator|=
name|sdata
expr_stmt|;
return|return
name|_bfd_elf_new_section_hook
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|USE_REL
value|1
end_define

begin_define
define|#
directive|define
name|TARGET_LITTLE_SYM
value|bfd_elf32_littlescore_vec
end_define

begin_define
define|#
directive|define
name|TARGET_LITTLE_NAME
value|"elf32-littlescore"
end_define

begin_define
define|#
directive|define
name|TARGET_BIG_SYM
value|bfd_elf32_bigscore_vec
end_define

begin_define
define|#
directive|define
name|TARGET_BIG_NAME
value|"elf32-bigscore"
end_define

begin_define
define|#
directive|define
name|ELF_ARCH
value|bfd_arch_score
end_define

begin_define
define|#
directive|define
name|ELF_MACHINE_CODE
value|EM_SCORE
end_define

begin_define
define|#
directive|define
name|ELF_MAXPAGESIZE
value|0x8000
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto
value|0
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto_rel
value|_bfd_score_info_to_howto
end_define

begin_define
define|#
directive|define
name|elf_backend_relocate_section
value|_bfd_score_elf_relocate_section
end_define

begin_define
define|#
directive|define
name|elf_backend_check_relocs
value|_bfd_score_elf_check_relocs
end_define

begin_define
define|#
directive|define
name|elf_backend_add_symbol_hook
value|_bfd_score_elf_add_symbol_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_symbol_processing
value|_bfd_score_elf_symbol_processing
end_define

begin_define
define|#
directive|define
name|elf_backend_link_output_symbol_hook
define|\
value|_bfd_score_elf_link_output_symbol_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_section_from_bfd_section
define|\
value|_bfd_score_elf_section_from_bfd_section
end_define

begin_define
define|#
directive|define
name|elf_backend_adjust_dynamic_symbol
define|\
value|_bfd_score_elf_adjust_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_always_size_sections
define|\
value|_bfd_score_elf_always_size_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_size_dynamic_sections
define|\
value|_bfd_score_elf_size_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_omit_section_dynsym
define|\
value|((bfd_boolean (*) (bfd *, struct bfd_link_info *, asection *)) bfd_true)
end_define

begin_define
define|#
directive|define
name|elf_backend_create_dynamic_sections
define|\
value|_bfd_score_elf_create_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_symbol
define|\
value|_bfd_score_elf_finish_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_sections
define|\
value|_bfd_score_elf_finish_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_fake_sections
value|_bfd_score_elf_fake_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_section_processing
value|_bfd_score_elf_section_processing
end_define

begin_define
define|#
directive|define
name|elf_backend_write_section
value|_bfd_score_elf_write_section
end_define

begin_define
define|#
directive|define
name|elf_backend_copy_indirect_symbol
value|_bfd_score_elf_copy_indirect_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_hide_symbol
value|_bfd_score_elf_hide_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_discard_info
value|_bfd_score_elf_discard_info
end_define

begin_define
define|#
directive|define
name|elf_backend_ignore_discarded_relocs
define|\
value|_bfd_score_elf_ignore_discarded_relocs
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_mark_hook
value|_bfd_score_elf_gc_mark_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_grok_prstatus
value|_bfd_score_elf_grok_prstatus
end_define

begin_define
define|#
directive|define
name|elf_backend_grok_psinfo
value|_bfd_score_elf_grok_psinfo
end_define

begin_define
define|#
directive|define
name|elf_backend_can_gc_sections
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_want_plt_sym
value|0
end_define

begin_define
define|#
directive|define
name|elf_backend_got_header_size
value|(4 * SCORE_RESERVED_GOTNO)
end_define

begin_define
define|#
directive|define
name|elf_backend_plt_header_size
value|0
end_define

begin_define
define|#
directive|define
name|elf_backend_collect
value|TRUE
end_define

begin_define
define|#
directive|define
name|elf_backend_type_change_ok
value|TRUE
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_reloc_type_lookup
value|elf32_score_reloc_type_lookup
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_reloc_name_lookup
define|\
value|elf32_score_reloc_name_lookup
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_link_hash_table_create
value|elf32_score_link_hash_table_create
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_print_private_bfd_data
value|elf32_score_print_private_bfd_data
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_merge_private_bfd_data
value|elf32_score_merge_private_bfd_data
end_define

begin_define
define|#
directive|define
name|bfd_elf32_new_section_hook
value|elf32_score_new_section_hook
end_define

begin_include
include|#
directive|include
file|"elf32-target.h"
end_include

end_unit

