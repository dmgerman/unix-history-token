begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD backend for Extended Tektronix Hex Format  objects.    Copyright (C) 1992, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.    Written by Steve Chamberlain of Cygnus Support<sac@cygnus.com>.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* SUBSECTION 	Tektronix Hex Format handling  DESCRIPTION 	 	Tek Hex records can hold symbols and data, but not 	relocations. Their main application is communication with 	devices like PROM programmers and ICE equipment. 	 	It seems that the sections are descibed as being really big,         the example I have says that the text section is 0..ffffffff. 	BFD would barf with this, many apps would try to alloc 4GB to 	read in the file.  	Tex Hex may contain many sections, but the data which comes in 	has no tag saying which section it belongs to, so we create 	one section for each block of data, called "blknnnn" which we 	stick all the data into.  	TekHex may come out of 	order and there is no header, so an 	initial scan is required  to discover the minimum and maximum 	addresses used to create the vma and size of the sections we 	create. 	We read in the data into pages of CHUNK_MASK+1 size and read 	them out from that whenever we need to.  	Any number of sections may be created for output, we save them 	up and output them when it's time to close the bfd.   	A TekHex record looks like: EXAMPLE 	%<block length><type><checksum><stuff><cr> 	 DESCRIPTION 	Where 	o length 	is the number of bytes in the record not including the % sign. 	o type 	is one of: 	3) symbol record 	6) data record 	8) termination record 	  The data can come out of order, and may be discontigous. This is a serial protocol, so big files are unlikely, so we keep a list of 8k chunks */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_typedef
typedef|typedef
struct|struct
block|{
name|bfd_vma
name|low
decl_stmt|;
name|bfd_vma
name|high
decl_stmt|;
block|}
name|addr_range_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|tekhex_symbol_struct
block|{
name|asymbol
name|symbol
decl_stmt|;
name|struct
name|tekhex_symbol_struct
modifier|*
name|prev
decl_stmt|;
block|}
name|tekhex_symbol_type
typedef|;
end_typedef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|digs
index|[]
init|=
literal|"0123456789ABCDEF"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|sum_block
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NOT_HEX
value|20
end_define

begin_define
define|#
directive|define
name|NIBBLE
parameter_list|(
name|x
parameter_list|)
value|hex_value(x)
end_define

begin_define
define|#
directive|define
name|HEX
parameter_list|(
name|buffer
parameter_list|)
value|((NIBBLE((buffer)[0])<<4) + NIBBLE((buffer)[1]))
end_define

begin_define
define|#
directive|define
name|TOHEX
parameter_list|(
name|d
parameter_list|,
name|x
parameter_list|)
define|\
value|(d)[1] = digs[(x)& 0xf]; \ (d)[0] = digs[((x)>>4)&0xf];
end_define

begin_define
define|#
directive|define
name|ISHEX
parameter_list|(
name|x
parameter_list|)
value|hex_p(x)
end_define

begin_decl_stmt
specifier|static
name|void
name|tekhex_init
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|getvalue
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tekhex_print_symbol
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|asymbol
operator|*
operator|,
name|bfd_print_symbol_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tekhex_get_symbol_info
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|symbol_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asymbol
modifier|*
name|tekhex_make_empty_symbol
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tekhex_sizeof_headers
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|tekhex_write_object_contents
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|int
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|writesym
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
name|CONST
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|writevalue
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|tekhex_set_section_contents
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|sec_ptr
operator|,
name|PTR
operator|,
name|file_ptr
operator|,
name|bfd_size_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|tekhex_set_arch_mach
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|enum
name|bfd_architecture
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|tekhex_get_section_contents
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|,
name|file_ptr
operator|,
name|bfd_size_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|move_section_contents
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|,
name|file_ptr
operator|,
name|bfd_size_type
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|bfd_target
modifier|*
name|tekhex_object_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|tekhex_mkobject
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|tekhex_get_symtab_upper_bound
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|tekhex_get_symtab
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pass_over
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|bfd
operator|*
argument_list|,
name|int
argument_list|,
name|char
operator|*
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|first_phase
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|insert_byte
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|int
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|data_struct
modifier|*
name|find_chunk
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|getsym
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Here's an example %3A6C6480004E56FFFC4E717063B0AEFFFC6D0652AEFFFC60F24E5E4E75 %1B3709T_SEGMENT1108FFFFFFFF %2B3AB9T_SEGMENT7Dgcc_compiled$1087hello$c10 %373829T_SEGMENT80int$t1$r1$$214741080char$t2$r2$0$12710 %373769T_SEGMENT80long$int$t3$r1$$1080unsigned$int$t4$10 %373CA9T_SEGMENT80long$unsigned$in1080short$int$t6$r1$10 %373049T_SEGMENT80long$long$int$t71080short$unsigned$i10 %373A29T_SEGMENT80long$long$unsign1080signed$char$t10$10 %373D69T_SEGMENT80unsigned$char$t11080float$t12$r1$4$010 %373D19T_SEGMENT80double$t13$r1$8$1080long$double$t14$10 %2734D9T_SEGMENT8Bvoid$t15$151035_main10 %2F3CA9T_SEGMENT81$1081$1681$1E81$21487main$F110 %2832F9T_SEGMENT83i$18FFFFFFFC81$1481$214 %07 8 10 10  explanation: %3A6C6480004E56FFFC4E717063B0AEFFFC6D0652AEFFFC60F24E5E4E75  ^ ^^ ^     ^-data  | || +------ 4 char integer 0x8000  | |+-------- checksum  | +--------- type 6 (data record)  +----------- length 3a chars<---------------------- 3a (58 chars) ------------------->  %1B3709T_SEGMENT1108FFFFFFFF       ^         ^^ ^- 8 character integer 0xffffffff       |         |+-   1 character integer 0       |         +--   type 1 symbol (section definition)       +------------   9 char symbol T_SEGMENT  %2B3AB9T_SEGMENT7Dgcc_compiled$1087hello$c10 %373829T_SEGMENT80int$t1$r1$$214741080char$t2$r2$0$12710 %373769T_SEGMENT80long$int$t3$r1$$1080unsigned$int$t4$10 %373CA9T_SEGMENT80long$unsigned$in1080short$int$t6$r1$10 %373049T_SEGMENT80long$long$int$t71080short$unsigned$i10 %373A29T_SEGMENT80long$long$unsign1080signed$char$t10$10 %373D69T_SEGMENT80unsigned$char$t11080float$t12$r1$4$010 %373D19T_SEGMENT80double$t13$r1$8$1080long$double$t14$10 %2734D9T_SEGMENT8Bvoid$t15$151035_main10 %2F3CA9T_SEGMENT81$1081$1681$1E81$21487main$F110 %2832F9T_SEGMENT83i$18FFFFFFFC81$1481$214 %0781010  Turns into sac@thepub$ ./objdump -dx -m m68k f  f:     file format tekhex -----x--- 9/55728 -134219416 Sep 29 15:13 1995 f architecture: UNKNOWN!, flags 0x00000010: HAS_SYMS start address 0x00000000 SECTION 0 [D00000000]	: size 00020000 vma 00000000 align 2**0  ALLOC, LOAD SECTION 1 [D00008000]	: size 00002001 vma 00008000 align 2**0  SECTION 2 [T_SEGMENT]	: size ffffffff vma 00000000 align 2**0  SYMBOL TABLE: 00000000  g       T_SEGMENT gcc_compiled$ 00000000  g       T_SEGMENT hello$c 00000000  g       T_SEGMENT int$t1$r1$$21474 00000000  g       T_SEGMENT char$t2$r2$0$127 00000000  g       T_SEGMENT long$int$t3$r1$$ 00000000  g       T_SEGMENT unsigned$int$t4$ 00000000  g       T_SEGMENT long$unsigned$in 00000000  g       T_SEGMENT short$int$t6$r1$ 00000000  g       T_SEGMENT long$long$int$t7 00000000  g       T_SEGMENT short$unsigned$i 00000000  g       T_SEGMENT long$long$unsign 00000000  g       T_SEGMENT signed$char$t10$ 00000000  g       T_SEGMENT unsigned$char$t1 00000000  g       T_SEGMENT float$t12$r1$4$0 00000000  g       T_SEGMENT double$t13$r1$8$ 00000000  g       T_SEGMENT long$double$t14$ 00000000  g       T_SEGMENT void$t15$15 00000000  g       T_SEGMENT _main 00000000  g       T_SEGMENT $ 00000000  g       T_SEGMENT $ 00000000  g       T_SEGMENT $ 00000010  g       T_SEGMENT $ 00000000  g       T_SEGMENT main$F1 fcffffff  g       T_SEGMENT i$1 00000000  g       T_SEGMENT $ 00000010  g       T_SEGMENT $   RELOCATION RECORDS FOR [D00000000]: (none)  RELOCATION RECORDS FOR [D00008000]: (none)  RELOCATION RECORDS FOR [T_SEGMENT]: (none)  Disassembly of section D00000000: ... 00008000 ($+)7ff0 linkw fp,#-4 00008004 ($+)7ff4 nop 00008006 ($+)7ff6 movel #99,d0 00008008 ($+)7ff8 cmpl fp@(-4),d0 0000800c ($+)7ffc blts 00008014 ($+)8004 0000800e ($+)7ffe addql #1,fp@(-4) 00008012 ($+)8002 bras 00008006 ($+)7ff6 00008014 ($+)8004 unlk fp 00008016 ($+)8006 rts ...  */
end_comment

begin_function
specifier|static
name|void
name|tekhex_init
parameter_list|()
block|{
name|unsigned
name|int
name|i
decl_stmt|;
specifier|static
name|boolean
name|inited
init|=
name|false
decl_stmt|;
name|int
name|val
decl_stmt|;
if|if
condition|(
name|inited
operator|==
name|false
condition|)
block|{
name|inited
operator|=
name|true
expr_stmt|;
name|hex_init
argument_list|()
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|sum_block
index|[
name|i
operator|+
literal|'0'
index|]
operator|=
name|val
operator|++
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|'A'
init|;
name|i
operator|<=
literal|'Z'
condition|;
name|i
operator|++
control|)
block|{
name|sum_block
index|[
name|i
index|]
operator|=
name|val
operator|++
expr_stmt|;
block|}
name|sum_block
index|[
literal|'$'
index|]
operator|=
name|val
operator|++
expr_stmt|;
name|sum_block
index|[
literal|'%'
index|]
operator|=
name|val
operator|++
expr_stmt|;
name|sum_block
index|[
literal|'.'
index|]
operator|=
name|val
operator|++
expr_stmt|;
name|sum_block
index|[
literal|'_'
index|]
operator|=
name|val
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|'a'
init|;
name|i
operator|<=
literal|'z'
condition|;
name|i
operator|++
control|)
block|{
name|sum_block
index|[
name|i
index|]
operator|=
name|val
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* The maximum number of bytes on a line is FF */
end_comment

begin_define
define|#
directive|define
name|MAXCHUNK
value|0xff
end_define

begin_comment
comment|/* The number of bytes we fit onto a line on output */
end_comment

begin_define
define|#
directive|define
name|CHUNK
value|21
end_define

begin_comment
comment|/* We cannot output our tekhexords as we see them, we have to glue them    together, this is done in this structure : */
end_comment

begin_struct
struct|struct
name|tekhex_data_list_struct
block|{
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
name|bfd_vma
name|where
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
name|struct
name|tekhex_data_list_struct
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|tekhex_data_list_struct
name|tekhex_data_list_type
typedef|;
end_typedef

begin_define
define|#
directive|define
name|CHUNK_MASK
value|0x1fff
end_define

begin_struct
struct|struct
name|data_struct
block|{
name|char
name|chunk_data
index|[
name|CHUNK_MASK
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|chunk_init
index|[
name|CHUNK_MASK
operator|+
literal|1
index|]
decl_stmt|;
name|bfd_vma
name|vma
decl_stmt|;
name|struct
name|data_struct
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
struct|struct
name|tekhex_data_struct
block|{
name|tekhex_data_list_type
modifier|*
name|head
decl_stmt|;
name|unsigned
name|int
name|type
decl_stmt|;
name|struct
name|tekhex_symbol_struct
modifier|*
name|symbols
decl_stmt|;
name|struct
name|data_struct
modifier|*
name|data
decl_stmt|;
block|}
name|tdata_type
typedef|;
end_typedef

begin_define
define|#
directive|define
name|enda
parameter_list|(
name|x
parameter_list|)
value|(x->vma + x->size)
end_define

begin_function
specifier|static
name|bfd_vma
name|getvalue
parameter_list|(
name|srcp
parameter_list|)
name|char
modifier|*
modifier|*
name|srcp
decl_stmt|;
block|{
name|char
modifier|*
name|src
init|=
operator|*
name|srcp
decl_stmt|;
name|bfd_vma
name|value
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|len
init|=
name|hex_value
argument_list|(
operator|*
name|src
operator|++
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|len
operator|=
literal|16
expr_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
block|{
name|value
operator|=
name|value
operator|<<
literal|4
operator||
name|hex_value
argument_list|(
operator|*
name|src
operator|++
argument_list|)
expr_stmt|;
block|}
operator|*
name|srcp
operator|=
name|src
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|getsym
parameter_list|(
name|dstp
parameter_list|,
name|srcp
parameter_list|)
name|char
modifier|*
name|dstp
decl_stmt|;
name|char
modifier|*
modifier|*
name|srcp
decl_stmt|;
block|{
name|char
modifier|*
name|src
init|=
operator|*
name|srcp
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|len
init|=
name|hex_value
argument_list|(
operator|*
name|src
operator|++
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|len
operator|=
literal|16
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|dstp
index|[
name|i
index|]
operator|=
name|src
index|[
name|i
index|]
expr_stmt|;
name|dstp
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
operator|*
name|srcp
operator|=
name|src
operator|+
name|i
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|data_struct
modifier|*
name|find_chunk
parameter_list|(
name|abfd
parameter_list|,
name|vma
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|bfd_vma
name|vma
decl_stmt|;
block|{
name|struct
name|data_struct
modifier|*
name|d
init|=
name|abfd
operator|->
name|tdata
operator|.
name|tekhex_data
operator|->
name|data
decl_stmt|;
name|vma
operator|&=
operator|~
name|CHUNK_MASK
expr_stmt|;
while|while
condition|(
name|d
operator|&&
operator|(
name|d
operator|->
name|vma
operator|)
operator|!=
name|vma
condition|)
block|{
name|d
operator|=
name|d
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|d
condition|)
block|{
name|char
modifier|*
name|sname
init|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
literal|12
argument_list|)
decl_stmt|;
comment|/* No chunk for this address, so make one up */
name|d
operator|=
operator|(
expr|struct
name|data_struct
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|data_struct
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sname
operator|||
operator|!
name|d
condition|)
return|return
name|NULL
return|;
name|memset
argument_list|(
name|d
operator|->
name|chunk_init
argument_list|,
literal|0
argument_list|,
name|CHUNK_MASK
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|d
operator|->
name|chunk_data
argument_list|,
literal|0
argument_list|,
name|CHUNK_MASK
operator|+
literal|1
argument_list|)
expr_stmt|;
name|d
operator|->
name|next
operator|=
name|abfd
operator|->
name|tdata
operator|.
name|tekhex_data
operator|->
name|data
expr_stmt|;
name|d
operator|->
name|vma
operator|=
name|vma
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|tekhex_data
operator|->
name|data
operator|=
name|d
expr_stmt|;
block|}
return|return
name|d
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|insert_byte
parameter_list|(
name|abfd
parameter_list|,
name|value
parameter_list|,
name|addr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|int
name|value
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
block|{
comment|/* Find the chunk that this byte needs and put it in */
name|struct
name|data_struct
modifier|*
name|d
init|=
name|find_chunk
argument_list|(
name|abfd
argument_list|,
name|addr
argument_list|)
decl_stmt|;
name|d
operator|->
name|chunk_data
index|[
name|addr
operator|&
name|CHUNK_MASK
index|]
operator|=
name|value
expr_stmt|;
name|d
operator|->
name|chunk_init
index|[
name|addr
operator|&
name|CHUNK_MASK
index|]
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The first pass is to find the names of all the sections, and see   how big the data is */
end_comment

begin_function
specifier|static
name|void
name|first_phase
parameter_list|(
name|abfd
parameter_list|,
name|type
parameter_list|,
name|src
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|int
name|type
decl_stmt|;
name|char
modifier|*
name|src
decl_stmt|;
block|{
name|asection
modifier|*
name|section
init|=
name|bfd_abs_section_ptr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
name|sym
index|[
literal|17
index|]
decl_stmt|;
comment|/* A symbol can only be 16chars long */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'6'
case|:
comment|/* Data record - read it and store it */
block|{
name|bfd_vma
name|addr
init|=
name|getvalue
argument_list|(
operator|&
name|src
argument_list|)
decl_stmt|;
while|while
condition|(
operator|*
name|src
condition|)
block|{
name|insert_byte
argument_list|(
name|abfd
argument_list|,
name|HEX
argument_list|(
name|src
argument_list|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|src
operator|+=
literal|2
expr_stmt|;
name|addr
operator|++
expr_stmt|;
block|}
block|}
return|return;
case|case
literal|'3'
case|:
comment|/* Symbol record, read the segment */
name|len
operator|=
name|getsym
argument_list|(
name|sym
argument_list|,
operator|&
name|src
argument_list|)
expr_stmt|;
name|section
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|section
operator|==
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
block|{
name|char
modifier|*
name|n
init|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|len
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* FIXME */
name|memcpy
argument_list|(
name|n
argument_list|,
name|sym
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|section
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|src
condition|)
block|{
switch|switch
condition|(
operator|*
name|src
condition|)
block|{
case|case
literal|'1'
case|:
comment|/* section range */
name|src
operator|++
expr_stmt|;
name|section
operator|->
name|vma
operator|=
name|getvalue
argument_list|(
operator|&
name|src
argument_list|)
expr_stmt|;
name|section
operator|->
name|_raw_size
operator|=
name|getvalue
argument_list|(
operator|&
name|src
argument_list|)
operator|-
name|section
operator|->
name|vma
expr_stmt|;
name|section
operator|->
name|flags
operator|=
name|SEC_HAS_CONTENTS
operator||
name|SEC_LOAD
operator||
name|SEC_ALLOC
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
comment|/* Symbols, add to section */
block|{
name|tekhex_symbol_type
modifier|*
name|new
init|=
operator|(
name|tekhex_symbol_type
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|tekhex_symbol_type
argument_list|)
argument_list|)
decl_stmt|;
name|char
name|type
init|=
operator|(
operator|*
name|src
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|new
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* FIXME */
name|new
operator|->
name|symbol
operator|.
name|the_bfd
operator|=
name|abfd
expr_stmt|;
name|src
operator|++
expr_stmt|;
name|abfd
operator|->
name|symcount
operator|++
expr_stmt|;
name|abfd
operator|->
name|flags
operator||=
name|HAS_SYMS
expr_stmt|;
name|new
operator|->
name|prev
operator|=
name|abfd
operator|->
name|tdata
operator|.
name|tekhex_data
operator|->
name|symbols
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|tekhex_data
operator|->
name|symbols
operator|=
name|new
expr_stmt|;
name|len
operator|=
name|getsym
argument_list|(
name|sym
argument_list|,
operator|&
name|src
argument_list|)
expr_stmt|;
name|new
operator|->
name|symbol
operator|.
name|name
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new
operator|->
name|symbol
operator|.
name|name
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* FIXME */
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|new
operator|->
name|symbol
operator|.
name|name
operator|)
argument_list|,
name|sym
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|new
operator|->
name|symbol
operator|.
name|section
operator|=
name|section
expr_stmt|;
if|if
condition|(
name|type
operator|<=
literal|'4'
condition|)
name|new
operator|->
name|symbol
operator|.
name|flags
operator|=
operator|(
name|BSF_GLOBAL
operator||
name|BSF_EXPORT
operator|)
expr_stmt|;
else|else
name|new
operator|->
name|symbol
operator|.
name|flags
operator|=
name|BSF_LOCAL
expr_stmt|;
name|new
operator|->
name|symbol
operator|.
name|value
operator|=
name|getvalue
argument_list|(
operator|&
name|src
argument_list|)
operator|-
name|section
operator|->
name|vma
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Pass over an tekhex, calling one of the above functions on each    record.  */
end_comment

begin_function_decl
specifier|static
name|void
name|pass_over
parameter_list|(
name|abfd
parameter_list|,
name|func
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
function_decl|void
parameter_list|(
function_decl|*func
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|unsigned
name|int
name|chars_on_line
decl_stmt|;
name|boolean
name|eof
init|=
name|false
decl_stmt|;
comment|/* To the front of the file */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
while|while
condition|(
name|eof
operator|==
name|false
condition|)
block|{
name|char
name|buffer
index|[
name|MAXCHUNK
index|]
decl_stmt|;
name|char
modifier|*
name|src
init|=
name|buffer
decl_stmt|;
name|char
name|type
decl_stmt|;
comment|/* Find first '%' */
name|eof
operator|=
call|(
name|boolean
call|)
argument_list|(
name|bfd_read
argument_list|(
name|src
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|src
operator|!=
literal|'%'
operator|&&
operator|!
name|eof
condition|)
block|{
name|eof
operator|=
call|(
name|boolean
call|)
argument_list|(
name|bfd_read
argument_list|(
name|src
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|eof
condition|)
break|break;
name|src
operator|++
expr_stmt|;
comment|/* Fetch the type and the length and the checksum */
if|if
condition|(
name|bfd_read
argument_list|(
name|src
argument_list|,
literal|1
argument_list|,
literal|5
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|5
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* FIXME */
name|type
operator|=
name|src
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|ISHEX
argument_list|(
name|src
index|[
literal|0
index|]
argument_list|)
operator|||
operator|!
name|ISHEX
argument_list|(
name|src
index|[
literal|1
index|]
argument_list|)
condition|)
break|break;
name|chars_on_line
operator|=
name|HEX
argument_list|(
name|src
argument_list|)
operator|-
literal|5
expr_stmt|;
comment|/* Already read five char */
if|if
condition|(
name|bfd_read
argument_list|(
name|src
argument_list|,
literal|1
argument_list|,
name|chars_on_line
argument_list|,
name|abfd
argument_list|)
operator|!=
name|chars_on_line
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* FIXME */
name|src
index|[
name|chars_on_line
index|]
operator|=
literal|0
expr_stmt|;
comment|/* put a null at the end */
name|func
argument_list|(
name|abfd
argument_list|,
name|type
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_function
specifier|static
name|long
name|tekhex_get_symtab
parameter_list|(
name|abfd
parameter_list|,
name|table
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|table
decl_stmt|;
block|{
name|tekhex_symbol_type
modifier|*
name|p
init|=
name|abfd
operator|->
name|tdata
operator|.
name|tekhex_data
operator|->
name|symbols
decl_stmt|;
name|unsigned
name|int
name|c
init|=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|table
index|[
name|c
index|]
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|table
index|[
operator|--
name|c
index|]
operator|=
operator|&
operator|(
name|p
operator|->
name|symbol
operator|)
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|prev
expr_stmt|;
block|}
return|return
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|tekhex_get_symtab_upper_bound
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
return|return
operator|(
name|abfd
operator|->
name|symcount
operator|+
literal|1
operator|)
operator|*
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|tekhex_asymbol_struct
operator|*
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|tekhex_mkobject
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|tdata_type
modifier|*
name|tdata
init|=
operator|(
name|tdata_type
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|tdata_type
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tdata
condition|)
return|return
name|false
return|;
name|abfd
operator|->
name|tdata
operator|.
name|tekhex_data
operator|=
name|tdata
expr_stmt|;
name|tdata
operator|->
name|type
operator|=
literal|1
expr_stmt|;
name|tdata
operator|->
name|head
operator|=
operator|(
name|tekhex_data_list_type
operator|*
operator|)
name|NULL
expr_stmt|;
name|tdata
operator|->
name|symbols
operator|=
operator|(
expr|struct
name|tekhex_symbol_struct
operator|*
operator|)
name|NULL
expr_stmt|;
name|tdata
operator|->
name|data
operator|=
operator|(
expr|struct
name|data_struct
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/*   Return true if the file looks like it's in TekHex format. Just look   for a percent sign and some hex digits */
end_comment

begin_function
specifier|static
specifier|const
name|bfd_target
modifier|*
name|tekhex_object_p
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|char
name|b
index|[
literal|4
index|]
decl_stmt|;
name|tekhex_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_read
argument_list|(
name|b
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|b
index|[
literal|0
index|]
operator|!=
literal|'%'
operator|||
operator|!
name|ISHEX
argument_list|(
name|b
index|[
literal|1
index|]
argument_list|)
operator|||
operator|!
name|ISHEX
argument_list|(
name|b
index|[
literal|2
index|]
argument_list|)
operator|||
operator|!
name|ISHEX
argument_list|(
name|b
index|[
literal|3
index|]
argument_list|)
condition|)
return|return
operator|(
specifier|const
name|bfd_target
operator|*
operator|)
name|NULL
return|;
name|tekhex_mkobject
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|pass_over
argument_list|(
name|abfd
argument_list|,
name|first_phase
argument_list|)
expr_stmt|;
return|return
name|abfd
operator|->
name|xvec
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|move_section_contents
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|locationp
parameter_list|,
name|offset
parameter_list|,
name|count
parameter_list|,
name|get
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|PTR
name|locationp
decl_stmt|;
name|file_ptr
name|offset
decl_stmt|;
name|bfd_size_type
name|count
decl_stmt|;
name|boolean
name|get
decl_stmt|;
block|{
name|bfd_vma
name|addr
decl_stmt|;
name|char
modifier|*
name|location
init|=
operator|(
name|char
operator|*
operator|)
name|locationp
decl_stmt|;
name|bfd_vma
name|prev_number
init|=
literal|1
decl_stmt|;
comment|/* Nothing can have this as a high bit*/
name|struct
name|data_struct
modifier|*
name|d
init|=
operator|(
expr|struct
name|data_struct
operator|*
operator|)
name|NULL
decl_stmt|;
for|for
control|(
name|addr
operator|=
name|section
operator|->
name|vma
init|;
name|count
operator|!=
literal|0
condition|;
name|count
operator|--
operator|,
name|addr
operator|++
control|)
block|{
name|bfd_vma
name|chunk_number
init|=
name|addr
operator|&
operator|~
name|CHUNK_MASK
decl_stmt|;
comment|/* Get high bits of address */
name|bfd_vma
name|low_bits
init|=
name|addr
operator|&
name|CHUNK_MASK
decl_stmt|;
if|if
condition|(
name|chunk_number
operator|!=
name|prev_number
condition|)
block|{
comment|/* Different chunk, so move pointer */
name|d
operator|=
name|find_chunk
argument_list|(
name|abfd
argument_list|,
name|chunk_number
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|get
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|chunk_init
index|[
name|low_bits
index|]
condition|)
block|{
operator|*
name|location
operator|=
name|d
operator|->
name|chunk_data
index|[
name|low_bits
index|]
expr_stmt|;
block|}
else|else
block|{
operator|*
name|location
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|d
operator|->
name|chunk_data
index|[
name|low_bits
index|]
operator|=
operator|*
name|location
expr_stmt|;
name|d
operator|->
name|chunk_init
index|[
name|low_bits
index|]
operator|=
operator|(
operator|*
name|location
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
name|location
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|boolean
name|tekhex_get_section_contents
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|locationp
parameter_list|,
name|offset
parameter_list|,
name|count
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|PTR
name|locationp
decl_stmt|;
name|file_ptr
name|offset
decl_stmt|;
name|bfd_size_type
name|count
decl_stmt|;
block|{
if|if
condition|(
name|section
operator|->
name|flags
operator|&
operator|(
name|SEC_LOAD
operator||
name|SEC_ALLOC
operator|)
condition|)
block|{
name|move_section_contents
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|locationp
argument_list|,
name|offset
argument_list|,
name|count
argument_list|,
name|true
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
else|else
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|tekhex_set_arch_mach
parameter_list|(
name|abfd
parameter_list|,
name|arch
parameter_list|,
name|machine
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|enum
name|bfd_architecture
name|arch
decl_stmt|;
name|unsigned
name|long
name|machine
decl_stmt|;
block|{
return|return
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|arch
argument_list|,
name|machine
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* we have to save up all the Tekhexords for a splurge before output,     */
end_comment

begin_function
specifier|static
name|boolean
name|tekhex_set_section_contents
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|locationp
parameter_list|,
name|offset
parameter_list|,
name|bytes_to_do
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|sec_ptr
name|section
decl_stmt|;
name|PTR
name|locationp
decl_stmt|;
name|file_ptr
name|offset
decl_stmt|;
name|bfd_size_type
name|bytes_to_do
decl_stmt|;
block|{
if|if
condition|(
name|abfd
operator|->
name|output_has_begun
operator|==
name|false
condition|)
block|{
comment|/* The first time around, allocate enough sections to hold all the chunks */
name|asection
modifier|*
name|s
init|=
name|abfd
operator|->
name|sections
decl_stmt|;
name|bfd_vma
name|vma
decl_stmt|;
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
condition|)
block|{
for|for
control|(
name|vma
operator|=
name|s
operator|->
name|vma
operator|&
operator|~
name|CHUNK_MASK
init|;
name|vma
operator|<
name|s
operator|->
name|vma
operator|+
name|s
operator|->
name|_raw_size
condition|;
name|vma
operator|+=
name|CHUNK_MASK
control|)
name|find_chunk
argument_list|(
name|abfd
argument_list|,
name|vma
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|section
operator|->
name|flags
operator|&
operator|(
name|SEC_LOAD
operator||
name|SEC_ALLOC
operator|)
condition|)
block|{
name|move_section_contents
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|locationp
argument_list|,
name|offset
argument_list|,
name|bytes_to_do
argument_list|,
name|false
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
else|else
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|writevalue
parameter_list|(
name|dst
parameter_list|,
name|value
parameter_list|)
name|char
modifier|*
modifier|*
name|dst
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
block|{
name|char
modifier|*
name|p
init|=
operator|*
name|dst
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|shift
decl_stmt|;
for|for
control|(
name|len
operator|=
literal|8
operator|,
name|shift
operator|=
literal|28
init|;
name|shift
condition|;
name|shift
operator|-=
literal|4
operator|,
name|len
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|value
operator|>>
name|shift
operator|)
operator|&
literal|0xf
condition|)
block|{
operator|*
name|p
operator|++
operator|=
name|len
operator|+
literal|'0'
expr_stmt|;
while|while
condition|(
name|len
condition|)
block|{
operator|*
name|p
operator|++
operator|=
name|digs
index|[
operator|(
name|value
operator|>>
name|shift
operator|)
operator|&
literal|0xf
index|]
expr_stmt|;
name|shift
operator|-=
literal|4
expr_stmt|;
name|len
operator|--
expr_stmt|;
block|}
operator|*
name|dst
operator|=
name|p
expr_stmt|;
return|return;
block|}
block|}
operator|*
name|p
operator|++
operator|=
literal|'1'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'0'
expr_stmt|;
operator|*
name|dst
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|writesym
parameter_list|(
name|dst
parameter_list|,
name|sym
parameter_list|)
name|char
modifier|*
modifier|*
name|dst
decl_stmt|;
name|CONST
name|char
modifier|*
name|sym
decl_stmt|;
block|{
name|char
modifier|*
name|p
init|=
operator|*
name|dst
decl_stmt|;
name|int
name|len
init|=
operator|(
name|sym
condition|?
name|strlen
argument_list|(
name|sym
argument_list|)
else|:
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|len
operator|>=
literal|16
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'0'
expr_stmt|;
name|len
operator|=
literal|16
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'1'
expr_stmt|;
name|sym
operator|=
literal|"$"
expr_stmt|;
name|len
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|*
name|p
operator|++
operator|=
name|digs
index|[
name|len
index|]
expr_stmt|;
block|}
block|}
while|while
condition|(
name|len
operator|--
condition|)
block|{
operator|*
name|p
operator|++
operator|=
operator|*
name|sym
operator|++
expr_stmt|;
block|}
operator|*
name|dst
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|out
parameter_list|(
name|abfd
parameter_list|,
name|type
parameter_list|,
name|start
parameter_list|,
name|end
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|int
name|type
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
block|{
name|int
name|sum
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|char
name|front
index|[
literal|6
index|]
decl_stmt|;
name|bfd_size_type
name|wrlen
decl_stmt|;
name|front
index|[
literal|0
index|]
operator|=
literal|'%'
expr_stmt|;
name|TOHEX
argument_list|(
name|front
operator|+
literal|1
argument_list|,
name|end
operator|-
name|start
operator|+
literal|5
argument_list|)
expr_stmt|;
name|front
index|[
literal|3
index|]
operator|=
name|type
expr_stmt|;
for|for
control|(
name|s
operator|=
name|start
init|;
name|s
operator|<
name|end
condition|;
name|s
operator|++
control|)
block|{
name|sum
operator|+=
name|sum_block
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
index|]
expr_stmt|;
block|}
name|sum
operator|+=
name|sum_block
index|[
operator|(
name|unsigned
name|char
operator|)
name|front
index|[
literal|1
index|]
index|]
expr_stmt|;
comment|/*  length */
name|sum
operator|+=
name|sum_block
index|[
operator|(
name|unsigned
name|char
operator|)
name|front
index|[
literal|2
index|]
index|]
expr_stmt|;
name|sum
operator|+=
name|sum_block
index|[
operator|(
name|unsigned
name|char
operator|)
name|front
index|[
literal|3
index|]
index|]
expr_stmt|;
comment|/* type */
name|TOHEX
argument_list|(
name|front
operator|+
literal|4
argument_list|,
name|sum
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
name|front
argument_list|,
literal|1
argument_list|,
literal|6
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|6
condition|)
name|abort
argument_list|()
expr_stmt|;
name|end
index|[
literal|0
index|]
operator|=
literal|'\n'
expr_stmt|;
name|wrlen
operator|=
name|end
operator|-
name|start
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
name|start
argument_list|,
literal|1
argument_list|,
name|wrlen
argument_list|,
name|abfd
argument_list|)
operator|!=
name|wrlen
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|tekhex_write_object_contents
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|int
name|bytes_written
decl_stmt|;
name|char
name|buffer
index|[
literal|100
index|]
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|p
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|struct
name|data_struct
modifier|*
name|d
decl_stmt|;
name|bytes_written
operator|=
literal|0
expr_stmt|;
comment|/* And the raw data */
for|for
control|(
name|d
operator|=
name|abfd
operator|->
name|tdata
operator|.
name|tekhex_data
operator|->
name|data
init|;
name|d
operator|!=
operator|(
expr|struct
name|data_struct
operator|*
operator|)
name|NULL
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
name|int
name|low
decl_stmt|;
name|CONST
name|int
name|span
init|=
literal|32
decl_stmt|;
name|int
name|addr
decl_stmt|;
comment|/* Write it in blocks of 32 bytes */
for|for
control|(
name|addr
operator|=
literal|0
init|;
name|addr
operator|<
name|CHUNK_MASK
operator|+
literal|1
condition|;
name|addr
operator|+=
name|span
control|)
block|{
name|int
name|need
init|=
literal|0
decl_stmt|;
comment|/* Check to see if necessary */
for|for
control|(
name|low
operator|=
literal|0
init|;
operator|!
name|need
operator|&&
name|low
operator|<
name|span
condition|;
name|low
operator|++
control|)
block|{
if|if
condition|(
name|d
operator|->
name|chunk_init
index|[
name|addr
operator|+
name|low
index|]
condition|)
name|need
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|need
condition|)
block|{
name|char
modifier|*
name|dst
init|=
name|buffer
decl_stmt|;
name|writevalue
argument_list|(
operator|&
name|dst
argument_list|,
name|addr
operator|+
name|d
operator|->
name|vma
argument_list|)
expr_stmt|;
for|for
control|(
name|low
operator|=
literal|0
init|;
name|low
operator|<
name|span
condition|;
name|low
operator|++
control|)
block|{
name|TOHEX
argument_list|(
name|dst
argument_list|,
name|d
operator|->
name|chunk_data
index|[
name|addr
operator|+
name|low
index|]
argument_list|)
expr_stmt|;
name|dst
operator|+=
literal|2
expr_stmt|;
block|}
name|out
argument_list|(
name|abfd
argument_list|,
literal|'6'
argument_list|,
name|buffer
argument_list|,
name|dst
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* write all the section headers for the sections */
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|char
modifier|*
name|dst
init|=
name|buffer
decl_stmt|;
name|writesym
argument_list|(
operator|&
name|dst
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
literal|'1'
expr_stmt|;
name|writevalue
argument_list|(
operator|&
name|dst
argument_list|,
name|s
operator|->
name|vma
argument_list|)
expr_stmt|;
name|writevalue
argument_list|(
operator|&
name|dst
argument_list|,
name|s
operator|->
name|vma
operator|+
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
name|out
argument_list|(
name|abfd
argument_list|,
literal|'3'
argument_list|,
name|buffer
argument_list|,
name|dst
argument_list|)
expr_stmt|;
block|}
comment|/* And the symbols */
for|for
control|(
name|p
operator|=
name|abfd
operator|->
name|outsymbols
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
name|int
name|section_code
init|=
name|bfd_decode_symclass
argument_list|(
operator|*
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|section_code
operator|!=
literal|'?'
condition|)
block|{
comment|/* do not include debug symbols */
name|asymbol
modifier|*
name|s
init|=
operator|*
name|p
decl_stmt|;
name|char
modifier|*
name|dst
init|=
name|buffer
decl_stmt|;
name|writesym
argument_list|(
operator|&
name|dst
argument_list|,
name|s
operator|->
name|section
operator|->
name|name
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|section_code
condition|)
block|{
case|case
literal|'A'
case|:
operator|*
name|dst
operator|++
operator|=
literal|'2'
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
operator|*
name|dst
operator|++
operator|=
literal|'6'
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
case|case
literal|'B'
case|:
case|case
literal|'O'
case|:
operator|*
name|dst
operator|++
operator|=
literal|'4'
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'b'
case|:
case|case
literal|'o'
case|:
operator|*
name|dst
operator|++
operator|=
literal|'8'
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
operator|*
name|dst
operator|++
operator|=
literal|'3'
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
operator|*
name|dst
operator|++
operator|=
literal|'7'
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
case|case
literal|'U'
case|:
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|writesym
argument_list|(
operator|&
name|dst
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
name|writevalue
argument_list|(
operator|&
name|dst
argument_list|,
name|s
operator|->
name|value
operator|+
name|s
operator|->
name|section
operator|->
name|vma
argument_list|)
expr_stmt|;
name|out
argument_list|(
name|abfd
argument_list|,
literal|'3'
argument_list|,
name|buffer
argument_list|,
name|dst
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* And the terminator */
if|if
condition|(
name|bfd_write
argument_list|(
literal|"%0781010\n"
argument_list|,
literal|1
argument_list|,
literal|9
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|9
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tekhex_sizeof_headers
parameter_list|(
name|abfd
parameter_list|,
name|exec
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|boolean
name|exec
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|asymbol
modifier|*
name|tekhex_make_empty_symbol
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|tekhex_symbol_type
modifier|*
name|new
init|=
operator|(
name|tekhex_symbol_type
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tekhex_symbol_struct
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|new
condition|)
return|return
name|NULL
return|;
name|new
operator|->
name|symbol
operator|.
name|the_bfd
operator|=
name|abfd
expr_stmt|;
name|new
operator|->
name|prev
operator|=
operator|(
expr|struct
name|tekhex_symbol_struct
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
operator|&
operator|(
name|new
operator|->
name|symbol
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|tekhex_get_symbol_info
parameter_list|(
name|ignore_abfd
parameter_list|,
name|symbol
parameter_list|,
name|ret
parameter_list|)
name|bfd
modifier|*
name|ignore_abfd
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|symbol_info
modifier|*
name|ret
decl_stmt|;
block|{
name|bfd_symbol_info
argument_list|(
name|symbol
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tekhex_print_symbol
parameter_list|(
name|ignore_abfd
parameter_list|,
name|filep
parameter_list|,
name|symbol
parameter_list|,
name|how
parameter_list|)
name|bfd
modifier|*
name|ignore_abfd
decl_stmt|;
name|PTR
name|filep
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|bfd_print_symbol_type
name|how
decl_stmt|;
block|{
name|FILE
modifier|*
name|file
init|=
operator|(
name|FILE
operator|*
operator|)
name|filep
decl_stmt|;
switch|switch
condition|(
name|how
condition|)
block|{
case|case
name|bfd_print_symbol_name
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|symbol
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_print_symbol_more
case|:
break|break;
case|case
name|bfd_print_symbol_all
case|:
block|{
name|CONST
name|char
modifier|*
name|section_name
init|=
name|symbol
operator|->
name|section
operator|->
name|name
decl_stmt|;
name|bfd_print_symbol_vandf
argument_list|(
operator|(
name|PTR
operator|)
name|file
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %-5s %s"
argument_list|,
name|section_name
argument_list|,
name|symbol
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_define
define|#
directive|define
name|tekhex_close_and_cleanup
value|_bfd_generic_close_and_cleanup
end_define

begin_define
define|#
directive|define
name|tekhex_bfd_free_cached_info
value|_bfd_generic_bfd_free_cached_info
end_define

begin_define
define|#
directive|define
name|tekhex_new_section_hook
value|_bfd_generic_new_section_hook
end_define

begin_define
define|#
directive|define
name|tekhex_bfd_is_local_label_name
value|bfd_generic_is_local_label_name
end_define

begin_define
define|#
directive|define
name|tekhex_get_lineno
value|_bfd_nosymbols_get_lineno
end_define

begin_define
define|#
directive|define
name|tekhex_find_nearest_line
value|_bfd_nosymbols_find_nearest_line
end_define

begin_define
define|#
directive|define
name|tekhex_bfd_make_debug_symbol
value|_bfd_nosymbols_bfd_make_debug_symbol
end_define

begin_define
define|#
directive|define
name|tekhex_read_minisymbols
value|_bfd_generic_read_minisymbols
end_define

begin_define
define|#
directive|define
name|tekhex_minisymbol_to_symbol
value|_bfd_generic_minisymbol_to_symbol
end_define

begin_define
define|#
directive|define
name|tekhex_bfd_get_relocated_section_contents
define|\
value|bfd_generic_get_relocated_section_contents
end_define

begin_define
define|#
directive|define
name|tekhex_bfd_relax_section
value|bfd_generic_relax_section
end_define

begin_define
define|#
directive|define
name|tekhex_bfd_link_hash_table_create
value|_bfd_generic_link_hash_table_create
end_define

begin_define
define|#
directive|define
name|tekhex_bfd_link_add_symbols
value|_bfd_generic_link_add_symbols
end_define

begin_define
define|#
directive|define
name|tekhex_bfd_final_link
value|_bfd_generic_final_link
end_define

begin_define
define|#
directive|define
name|tekhex_bfd_link_split_section
value|_bfd_generic_link_split_section
end_define

begin_define
define|#
directive|define
name|tekhex_get_section_contents_in_window
define|\
value|_bfd_generic_get_section_contents_in_window
end_define

begin_decl_stmt
specifier|const
name|bfd_target
name|tekhex_vec
init|=
block|{
literal|"tekhex"
block|,
comment|/* name */
name|bfd_target_tekhex_flavour
block|,
name|BFD_ENDIAN_UNKNOWN
block|,
comment|/* target byte order */
name|BFD_ENDIAN_UNKNOWN
block|,
comment|/* target headers byte order */
operator|(
name|EXEC_P
operator||
comment|/* object flags */
name|HAS_SYMS
operator||
name|HAS_LINENO
operator||
name|HAS_DEBUG
operator||
name|HAS_RELOC
operator||
name|HAS_LOCALS
operator||
name|WP_TEXT
operator||
name|D_PAGED
operator|)
block|,
operator|(
name|SEC_CODE
operator||
name|SEC_DATA
operator||
name|SEC_ROM
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator|)
block|,
comment|/* section flags */
literal|0
block|,
comment|/* leading underscore */
literal|' '
block|,
comment|/* ar_pad_char */
literal|16
block|,
comment|/* ar_max_namelen */
name|bfd_getb64
block|,
name|bfd_getb_signed_64
block|,
name|bfd_putb64
block|,
name|bfd_getb32
block|,
name|bfd_getb_signed_32
block|,
name|bfd_putb32
block|,
name|bfd_getb16
block|,
name|bfd_getb_signed_16
block|,
name|bfd_putb16
block|,
comment|/* data */
name|bfd_getb64
block|,
name|bfd_getb_signed_64
block|,
name|bfd_putb64
block|,
name|bfd_getb32
block|,
name|bfd_getb_signed_32
block|,
name|bfd_putb32
block|,
name|bfd_getb16
block|,
name|bfd_getb_signed_16
block|,
name|bfd_putb16
block|,
comment|/* hdrs */
block|{
name|_bfd_dummy_target
block|,
name|tekhex_object_p
block|,
comment|/* bfd_check_format */
name|_bfd_dummy_target
block|,
name|_bfd_dummy_target
block|,   }
block|,
block|{
name|bfd_false
block|,
name|tekhex_mkobject
block|,
name|_bfd_generic_mkarchive
block|,
name|bfd_false
block|,   }
block|,
block|{
comment|/* bfd_write_contents */
name|bfd_false
block|,
name|tekhex_write_object_contents
block|,
name|_bfd_write_archive_contents
block|,
name|bfd_false
block|,   }
block|,
name|BFD_JUMP_TABLE_GENERIC
argument_list|(
name|tekhex
argument_list|)
block|,
name|BFD_JUMP_TABLE_COPY
argument_list|(
name|_bfd_generic
argument_list|)
block|,
name|BFD_JUMP_TABLE_CORE
argument_list|(
name|_bfd_nocore
argument_list|)
block|,
name|BFD_JUMP_TABLE_ARCHIVE
argument_list|(
name|_bfd_noarchive
argument_list|)
block|,
name|BFD_JUMP_TABLE_SYMBOLS
argument_list|(
name|tekhex
argument_list|)
block|,
name|BFD_JUMP_TABLE_RELOCS
argument_list|(
name|_bfd_norelocs
argument_list|)
block|,
name|BFD_JUMP_TABLE_WRITE
argument_list|(
name|tekhex
argument_list|)
block|,
name|BFD_JUMP_TABLE_LINK
argument_list|(
name|tekhex
argument_list|)
block|,
name|BFD_JUMP_TABLE_DYNAMIC
argument_list|(
name|_bfd_nodynamic
argument_list|)
block|,
operator|(
name|PTR
operator|)
literal|0
block|}
decl_stmt|;
end_decl_stmt

end_unit

