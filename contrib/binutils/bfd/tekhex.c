begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD backend for Extended Tektronix Hex Format  objects.    Copyright 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001, 2002,    2003, 2004 Free Software Foundation, Inc.    Written by Steve Chamberlain of Cygnus Support<sac@cygnus.com>.     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* SUBSECTION 	Tektronix Hex Format handling     DESCRIPTION  	Tek Hex records can hold symbols and data, but not 	relocations. Their main application is communication with 	devices like PROM programmers and ICE equipment.  	It seems that the sections are described as being really big,         the example I have says that the text section is 0..ffffffff. 	BFD would barf with this, many apps would try to alloc 4GB to 	read in the file.  	Tex Hex may contain many sections, but the data which comes in 	has no tag saying which section it belongs to, so we create 	one section for each block of data, called "blknnnn" which we 	stick all the data into.  	TekHex may come out of 	order and there is no header, so an 	initial scan is required  to discover the minimum and maximum 	addresses used to create the vma and size of the sections we 	create. 	We read in the data into pages of CHUNK_MASK+1 size and read 	them out from that whenever we need to.  	Any number of sections may be created for output, we save them 	up and output them when it's time to close the bfd.  	A TekHex record looks like:   EXAMPLE 	%<block length><type><checksum><stuff><cr>    DESCRIPTION 	Where 	o length 	is the number of bytes in the record not including the % sign. 	o type 	is one of: 	3) symbol record 	6) data record 	8) termination record    The data can come out of order, and may be discontigous. This is a   serial protocol, so big files are unlikely, so we keep a list of 8k chunks.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_typedef
typedef|typedef
struct|struct
block|{
name|bfd_vma
name|low
decl_stmt|;
name|bfd_vma
name|high
decl_stmt|;
block|}
name|addr_range_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|tekhex_symbol_struct
block|{
name|asymbol
name|symbol
decl_stmt|;
name|struct
name|tekhex_symbol_struct
modifier|*
name|prev
decl_stmt|;
block|}
name|tekhex_symbol_type
typedef|;
end_typedef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|digs
index|[]
init|=
literal|"0123456789ABCDEF"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|sum_block
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NOT_HEX
value|20
end_define

begin_define
define|#
directive|define
name|NIBBLE
parameter_list|(
name|x
parameter_list|)
value|hex_value(x)
end_define

begin_define
define|#
directive|define
name|HEX
parameter_list|(
name|buffer
parameter_list|)
value|((NIBBLE ((buffer)[0])<< 4) + NIBBLE ((buffer)[1]))
end_define

begin_define
define|#
directive|define
name|ISHEX
parameter_list|(
name|x
parameter_list|)
value|hex_p(x)
end_define

begin_define
define|#
directive|define
name|TOHEX
parameter_list|(
name|d
parameter_list|,
name|x
parameter_list|)
define|\
value|(d)[1] = digs[(x)& 0xf]; \   (d)[0] = digs[((x)>>4)&0xf];
end_define

begin_comment
comment|/* Here's an example    %3A6C6480004E56FFFC4E717063B0AEFFFC6D0652AEFFFC60F24E5E4E75    %1B3709T_SEGMENT1108FFFFFFFF    %2B3AB9T_SEGMENT7Dgcc_compiled$1087hello$c10    %373829T_SEGMENT80int$t1$r1$$214741080char$t2$r2$0$12710    %373769T_SEGMENT80long$int$t3$r1$$1080unsigned$int$t4$10    %373CA9T_SEGMENT80long$unsigned$in1080short$int$t6$r1$10    %373049T_SEGMENT80long$long$int$t71080short$unsigned$i10    %373A29T_SEGMENT80long$long$unsign1080signed$char$t10$10    %373D69T_SEGMENT80unsigned$char$t11080float$t12$r1$4$010    %373D19T_SEGMENT80double$t13$r1$8$1080long$double$t14$10    %2734D9T_SEGMENT8Bvoid$t15$151035_main10    %2F3CA9T_SEGMENT81$1081$1681$1E81$21487main$F110    %2832F9T_SEGMENT83i$18FFFFFFFC81$1481$214    %07 8 10 10     explanation:    %3A6C6480004E56FFFC4E717063B0AEFFFC6D0652AEFFFC60F24E5E4E75     ^ ^^ ^     ^-data     | || +------ 4 char integer 0x8000     | |+-------- checksum     | +--------- type 6 (data record)     +----------- length 3a chars<---------------------- 3a (58 chars) ------------------->     %1B3709T_SEGMENT1108FFFFFFFF          ^         ^^ ^- 8 character integer 0xffffffff          |         |+-   1 character integer 0          |         +--   type 1 symbol (section definition)          +------------   9 char symbol T_SEGMENT     %2B3AB9T_SEGMENT7Dgcc_compiled$1087hello$c10    %373829T_SEGMENT80int$t1$r1$$214741080char$t2$r2$0$12710    %373769T_SEGMENT80long$int$t3$r1$$1080unsigned$int$t4$10    %373CA9T_SEGMENT80long$unsigned$in1080short$int$t6$r1$10    %373049T_SEGMENT80long$long$int$t71080short$unsigned$i10    %373A29T_SEGMENT80long$long$unsign1080signed$char$t10$10    %373D69T_SEGMENT80unsigned$char$t11080float$t12$r1$4$010    %373D19T_SEGMENT80double$t13$r1$8$1080long$double$t14$10    %2734D9T_SEGMENT8Bvoid$t15$151035_main10    %2F3CA9T_SEGMENT81$1081$1681$1E81$21487main$F110    %2832F9T_SEGMENT83i$18FFFFFFFC81$1481$214    %0781010     Turns into    sac@thepub$ ./objdump -dx -m m68k f     f:     file format tekhex    -----x--- 9/55728 -134219416 Sep 29 15:13 1995 f    architecture: UNKNOWN!, flags 0x00000010:    HAS_SYMS    start address 0x00000000    SECTION 0 [D00000000]	: size 00020000 vma 00000000 align 2**0    ALLOC, LOAD    SECTION 1 [D00008000]	: size 00002001 vma 00008000 align 2**0     SECTION 2 [T_SEGMENT]	: size ffffffff vma 00000000 align 2**0     SYMBOL TABLE:    00000000  g       T_SEGMENT gcc_compiled$    00000000  g       T_SEGMENT hello$c    00000000  g       T_SEGMENT int$t1$r1$$21474    00000000  g       T_SEGMENT char$t2$r2$0$127    00000000  g       T_SEGMENT long$int$t3$r1$$    00000000  g       T_SEGMENT unsigned$int$t4$    00000000  g       T_SEGMENT long$unsigned$in    00000000  g       T_SEGMENT short$int$t6$r1$    00000000  g       T_SEGMENT long$long$int$t7    00000000  g       T_SEGMENT short$unsigned$i    00000000  g       T_SEGMENT long$long$unsign    00000000  g       T_SEGMENT signed$char$t10$    00000000  g       T_SEGMENT unsigned$char$t1    00000000  g       T_SEGMENT float$t12$r1$4$0    00000000  g       T_SEGMENT double$t13$r1$8$    00000000  g       T_SEGMENT long$double$t14$    00000000  g       T_SEGMENT void$t15$15    00000000  g       T_SEGMENT _main    00000000  g       T_SEGMENT $    00000000  g       T_SEGMENT $    00000000  g       T_SEGMENT $    00000010  g       T_SEGMENT $    00000000  g       T_SEGMENT main$F1    fcffffff  g       T_SEGMENT i$1    00000000  g       T_SEGMENT $    00000010  g       T_SEGMENT $     RELOCATION RECORDS FOR [D00000000]: (none)     RELOCATION RECORDS FOR [D00008000]: (none)     RELOCATION RECORDS FOR [T_SEGMENT]: (none)     Disassembly of section D00000000:    ...    00008000 ($+)7ff0 linkw fp,#-4    00008004 ($+)7ff4 nop    00008006 ($+)7ff6 movel #99,d0    00008008 ($+)7ff8 cmpl fp@(-4),d0    0000800c ($+)7ffc blts 00008014 ($+)8004    0000800e ($+)7ffe addql #1,fp@(-4)    00008012 ($+)8002 bras 00008006 ($+)7ff6    00008014 ($+)8004 unlk fp    00008016 ($+)8006 rts    ...  */
end_comment

begin_function
specifier|static
name|void
name|tekhex_init
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
specifier|static
name|bfd_boolean
name|inited
init|=
name|FALSE
decl_stmt|;
name|int
name|val
decl_stmt|;
if|if
condition|(
operator|!
name|inited
condition|)
block|{
name|inited
operator|=
name|TRUE
expr_stmt|;
name|hex_init
argument_list|()
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
name|sum_block
index|[
name|i
operator|+
literal|'0'
index|]
operator|=
name|val
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|'A'
init|;
name|i
operator|<=
literal|'Z'
condition|;
name|i
operator|++
control|)
name|sum_block
index|[
name|i
index|]
operator|=
name|val
operator|++
expr_stmt|;
name|sum_block
index|[
literal|'$'
index|]
operator|=
name|val
operator|++
expr_stmt|;
name|sum_block
index|[
literal|'%'
index|]
operator|=
name|val
operator|++
expr_stmt|;
name|sum_block
index|[
literal|'.'
index|]
operator|=
name|val
operator|++
expr_stmt|;
name|sum_block
index|[
literal|'_'
index|]
operator|=
name|val
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|'a'
init|;
name|i
operator|<=
literal|'z'
condition|;
name|i
operator|++
control|)
name|sum_block
index|[
name|i
index|]
operator|=
name|val
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The maximum number of bytes on a line is FF.  */
end_comment

begin_define
define|#
directive|define
name|MAXCHUNK
value|0xff
end_define

begin_comment
comment|/* The number of bytes we fit onto a line on output.  */
end_comment

begin_define
define|#
directive|define
name|CHUNK
value|21
end_define

begin_comment
comment|/* We cannot output our tekhexords as we see them, we have to glue them    together, this is done in this structure : */
end_comment

begin_struct
struct|struct
name|tekhex_data_list_struct
block|{
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
name|bfd_vma
name|where
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
name|struct
name|tekhex_data_list_struct
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|tekhex_data_list_struct
name|tekhex_data_list_type
typedef|;
end_typedef

begin_define
define|#
directive|define
name|CHUNK_MASK
value|0x1fff
end_define

begin_struct
struct|struct
name|data_struct
block|{
name|char
name|chunk_data
index|[
name|CHUNK_MASK
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|chunk_init
index|[
name|CHUNK_MASK
operator|+
literal|1
index|]
decl_stmt|;
name|bfd_vma
name|vma
decl_stmt|;
name|struct
name|data_struct
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
struct|struct
name|tekhex_data_struct
block|{
name|tekhex_data_list_type
modifier|*
name|head
decl_stmt|;
name|unsigned
name|int
name|type
decl_stmt|;
name|struct
name|tekhex_symbol_struct
modifier|*
name|symbols
decl_stmt|;
name|struct
name|data_struct
modifier|*
name|data
decl_stmt|;
block|}
name|tdata_type
typedef|;
end_typedef

begin_define
define|#
directive|define
name|enda
parameter_list|(
name|x
parameter_list|)
value|(x->vma + x->size)
end_define

begin_function
specifier|static
name|bfd_boolean
name|getvalue
parameter_list|(
name|char
modifier|*
modifier|*
name|srcp
parameter_list|,
name|bfd_vma
modifier|*
name|valuep
parameter_list|)
block|{
name|char
modifier|*
name|src
init|=
operator|*
name|srcp
decl_stmt|;
name|bfd_vma
name|value
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|ISHEX
argument_list|(
operator|*
name|src
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|len
operator|=
name|hex_value
argument_list|(
operator|*
name|src
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|len
operator|=
literal|16
expr_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
block|{
if|if
condition|(
operator|!
name|ISHEX
argument_list|(
operator|*
name|src
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|value
operator|=
name|value
operator|<<
literal|4
operator||
name|hex_value
argument_list|(
operator|*
name|src
operator|++
argument_list|)
expr_stmt|;
block|}
operator|*
name|srcp
operator|=
name|src
expr_stmt|;
operator|*
name|valuep
operator|=
name|value
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|getsym
parameter_list|(
name|char
modifier|*
name|dstp
parameter_list|,
name|char
modifier|*
modifier|*
name|srcp
parameter_list|,
name|unsigned
name|int
modifier|*
name|lenp
parameter_list|)
block|{
name|char
modifier|*
name|src
init|=
operator|*
name|srcp
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|ISHEX
argument_list|(
operator|*
name|src
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|len
operator|=
name|hex_value
argument_list|(
operator|*
name|src
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|len
operator|=
literal|16
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|dstp
index|[
name|i
index|]
operator|=
name|src
index|[
name|i
index|]
expr_stmt|;
name|dstp
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
operator|*
name|srcp
operator|=
name|src
operator|+
name|i
expr_stmt|;
operator|*
name|lenp
operator|=
name|len
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|data_struct
modifier|*
name|find_chunk
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_vma
name|vma
parameter_list|)
block|{
name|struct
name|data_struct
modifier|*
name|d
init|=
name|abfd
operator|->
name|tdata
operator|.
name|tekhex_data
operator|->
name|data
decl_stmt|;
name|vma
operator|&=
operator|~
name|CHUNK_MASK
expr_stmt|;
while|while
condition|(
name|d
operator|&&
operator|(
name|d
operator|->
name|vma
operator|)
operator|!=
name|vma
condition|)
name|d
operator|=
name|d
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|d
condition|)
block|{
comment|/* No chunk for this address, so make one up.  */
name|d
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_size_type
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|data_struct
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|NULL
return|;
name|d
operator|->
name|next
operator|=
name|abfd
operator|->
name|tdata
operator|.
name|tekhex_data
operator|->
name|data
expr_stmt|;
name|d
operator|->
name|vma
operator|=
name|vma
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|tekhex_data
operator|->
name|data
operator|=
name|d
expr_stmt|;
block|}
return|return
name|d
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|insert_byte
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|int
name|value
parameter_list|,
name|bfd_vma
name|addr
parameter_list|)
block|{
comment|/* Find the chunk that this byte needs and put it in.  */
name|struct
name|data_struct
modifier|*
name|d
init|=
name|find_chunk
argument_list|(
name|abfd
argument_list|,
name|addr
argument_list|)
decl_stmt|;
name|d
operator|->
name|chunk_data
index|[
name|addr
operator|&
name|CHUNK_MASK
index|]
operator|=
name|value
expr_stmt|;
name|d
operator|->
name|chunk_init
index|[
name|addr
operator|&
name|CHUNK_MASK
index|]
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The first pass is to find the names of all the sections, and see   how big the data is.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|first_phase
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|int
name|type
parameter_list|,
name|char
modifier|*
name|src
parameter_list|)
block|{
name|asection
modifier|*
name|section
init|=
name|bfd_abs_section_ptr
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
name|char
name|sym
index|[
literal|17
index|]
decl_stmt|;
comment|/* A symbol can only be 16chars long.  */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'6'
case|:
comment|/* Data record - read it and store it.  */
block|{
name|bfd_vma
name|addr
decl_stmt|;
if|if
condition|(
operator|!
name|getvalue
argument_list|(
operator|&
name|src
argument_list|,
operator|&
name|addr
argument_list|)
condition|)
return|return
name|FALSE
return|;
while|while
condition|(
operator|*
name|src
condition|)
block|{
name|insert_byte
argument_list|(
name|abfd
argument_list|,
name|HEX
argument_list|(
name|src
argument_list|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|src
operator|+=
literal|2
expr_stmt|;
name|addr
operator|++
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
case|case
literal|'3'
case|:
comment|/* Symbol record, read the segment.  */
if|if
condition|(
operator|!
name|getsym
argument_list|(
name|sym
argument_list|,
operator|&
name|src
argument_list|,
operator|&
name|len
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|section
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|section
operator|==
name|NULL
condition|)
block|{
name|char
modifier|*
name|n
init|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|len
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
return|return
name|FALSE
return|;
name|memcpy
argument_list|(
name|n
argument_list|,
name|sym
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|section
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|src
condition|)
block|{
switch|switch
condition|(
operator|*
name|src
condition|)
block|{
case|case
literal|'1'
case|:
comment|/* Section range.  */
name|src
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|getvalue
argument_list|(
operator|&
name|src
argument_list|,
operator|&
name|section
operator|->
name|vma
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|getvalue
argument_list|(
operator|&
name|src
argument_list|,
operator|&
name|val
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|section
operator|->
name|size
operator|=
name|val
operator|-
name|section
operator|->
name|vma
expr_stmt|;
name|section
operator|->
name|flags
operator|=
name|SEC_HAS_CONTENTS
operator||
name|SEC_LOAD
operator||
name|SEC_ALLOC
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
comment|/* Symbols, add to section.  */
block|{
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
name|tekhex_symbol_type
argument_list|)
decl_stmt|;
name|tekhex_symbol_type
modifier|*
name|new
init|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
decl_stmt|;
name|char
name|stype
init|=
operator|(
operator|*
name|src
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|new
condition|)
return|return
name|FALSE
return|;
name|new
operator|->
name|symbol
operator|.
name|the_bfd
operator|=
name|abfd
expr_stmt|;
name|src
operator|++
expr_stmt|;
name|abfd
operator|->
name|symcount
operator|++
expr_stmt|;
name|abfd
operator|->
name|flags
operator||=
name|HAS_SYMS
expr_stmt|;
name|new
operator|->
name|prev
operator|=
name|abfd
operator|->
name|tdata
operator|.
name|tekhex_data
operator|->
name|symbols
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|tekhex_data
operator|->
name|symbols
operator|=
name|new
expr_stmt|;
if|if
condition|(
operator|!
name|getsym
argument_list|(
name|sym
argument_list|,
operator|&
name|src
argument_list|,
operator|&
name|len
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|new
operator|->
name|symbol
operator|.
name|name
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new
operator|->
name|symbol
operator|.
name|name
condition|)
return|return
name|FALSE
return|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|new
operator|->
name|symbol
operator|.
name|name
operator|)
argument_list|,
name|sym
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|new
operator|->
name|symbol
operator|.
name|section
operator|=
name|section
expr_stmt|;
if|if
condition|(
name|stype
operator|<=
literal|'4'
condition|)
name|new
operator|->
name|symbol
operator|.
name|flags
operator|=
operator|(
name|BSF_GLOBAL
operator||
name|BSF_EXPORT
operator|)
expr_stmt|;
else|else
name|new
operator|->
name|symbol
operator|.
name|flags
operator|=
name|BSF_LOCAL
expr_stmt|;
if|if
condition|(
operator|!
name|getvalue
argument_list|(
operator|&
name|src
argument_list|,
operator|&
name|val
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|new
operator|->
name|symbol
operator|.
name|value
operator|=
name|val
operator|-
name|section
operator|->
name|vma
expr_stmt|;
block|}
default|default:
return|return
name|FALSE
return|;
block|}
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Pass over a tekhex, calling one of the above functions on each    record.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|pass_over
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_boolean
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
parameter_list|)
block|{
name|unsigned
name|int
name|chars_on_line
decl_stmt|;
name|bfd_boolean
name|eof
init|=
name|FALSE
decl_stmt|;
comment|/* To the front of the file.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
name|eof
condition|)
block|{
name|char
name|buffer
index|[
name|MAXCHUNK
index|]
decl_stmt|;
name|char
modifier|*
name|src
init|=
name|buffer
decl_stmt|;
name|char
name|type
decl_stmt|;
comment|/* Find first '%'.  */
name|eof
operator|=
call|(
name|bfd_boolean
call|)
argument_list|(
name|bfd_bread
argument_list|(
name|src
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|src
operator|!=
literal|'%'
operator|&&
operator|!
name|eof
condition|)
name|eof
operator|=
call|(
name|bfd_boolean
call|)
argument_list|(
name|bfd_bread
argument_list|(
name|src
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|eof
condition|)
break|break;
name|src
operator|++
expr_stmt|;
comment|/* Fetch the type and the length and the checksum.  */
if|if
condition|(
name|bfd_bread
argument_list|(
name|src
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|5
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|5
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* FIXME.  */
name|type
operator|=
name|src
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|ISHEX
argument_list|(
name|src
index|[
literal|0
index|]
argument_list|)
operator|||
operator|!
name|ISHEX
argument_list|(
name|src
index|[
literal|1
index|]
argument_list|)
condition|)
break|break;
comment|/* Already read five char.  */
name|chars_on_line
operator|=
name|HEX
argument_list|(
name|src
argument_list|)
operator|-
literal|5
expr_stmt|;
if|if
condition|(
name|bfd_bread
argument_list|(
name|src
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|chars_on_line
argument_list|,
name|abfd
argument_list|)
operator|!=
name|chars_on_line
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* FIXME.  */
comment|/* Put a null at the end.  */
name|src
index|[
name|chars_on_line
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|func
argument_list|(
name|abfd
argument_list|,
name|type
argument_list|,
name|src
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|tekhex_canonicalize_symtab
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asymbol
modifier|*
modifier|*
name|table
parameter_list|)
block|{
name|tekhex_symbol_type
modifier|*
name|p
init|=
name|abfd
operator|->
name|tdata
operator|.
name|tekhex_data
operator|->
name|symbols
decl_stmt|;
name|unsigned
name|int
name|c
init|=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|table
index|[
name|c
index|]
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|table
index|[
operator|--
name|c
index|]
operator|=
operator|&
operator|(
name|p
operator|->
name|symbol
operator|)
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|prev
expr_stmt|;
block|}
return|return
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|tekhex_get_symtab_upper_bound
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
return|return
operator|(
name|abfd
operator|->
name|symcount
operator|+
literal|1
operator|)
operator|*
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|tekhex_asymbol_struct
operator|*
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|tekhex_mkobject
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|tdata_type
modifier|*
name|tdata
decl_stmt|;
name|tdata
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_size_type
operator|)
sizeof|sizeof
argument_list|(
name|tdata_type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tdata
condition|)
return|return
name|FALSE
return|;
name|abfd
operator|->
name|tdata
operator|.
name|tekhex_data
operator|=
name|tdata
expr_stmt|;
name|tdata
operator|->
name|type
operator|=
literal|1
expr_stmt|;
name|tdata
operator|->
name|head
operator|=
name|NULL
expr_stmt|;
name|tdata
operator|->
name|symbols
operator|=
name|NULL
expr_stmt|;
name|tdata
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if the file looks like it's in TekHex format. Just look    for a percent sign and some hex digits.  */
end_comment

begin_function
specifier|static
specifier|const
name|bfd_target
modifier|*
name|tekhex_object_p
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|char
name|b
index|[
literal|4
index|]
decl_stmt|;
name|tekhex_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bread
argument_list|(
name|b
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|4
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|b
index|[
literal|0
index|]
operator|!=
literal|'%'
operator|||
operator|!
name|ISHEX
argument_list|(
name|b
index|[
literal|1
index|]
argument_list|)
operator|||
operator|!
name|ISHEX
argument_list|(
name|b
index|[
literal|2
index|]
argument_list|)
operator|||
operator|!
name|ISHEX
argument_list|(
name|b
index|[
literal|3
index|]
argument_list|)
condition|)
return|return
name|NULL
return|;
name|tekhex_mkobject
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pass_over
argument_list|(
name|abfd
argument_list|,
name|first_phase
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|abfd
operator|->
name|xvec
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|move_section_contents
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|,
specifier|const
name|void
modifier|*
name|locationp
parameter_list|,
name|file_ptr
name|offset
parameter_list|,
name|bfd_size_type
name|count
parameter_list|,
name|bfd_boolean
name|get
parameter_list|)
block|{
name|bfd_vma
name|addr
decl_stmt|;
name|char
modifier|*
name|location
init|=
operator|(
name|char
operator|*
operator|)
name|locationp
decl_stmt|;
name|bfd_vma
name|prev_number
init|=
literal|1
decl_stmt|;
comment|/* Nothing can have this as a high bit.  */
name|struct
name|data_struct
modifier|*
name|d
init|=
name|NULL
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|offset
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|addr
operator|=
name|section
operator|->
name|vma
init|;
name|count
operator|!=
literal|0
condition|;
name|count
operator|--
operator|,
name|addr
operator|++
control|)
block|{
comment|/* Get high bits of address.  */
name|bfd_vma
name|chunk_number
init|=
name|addr
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
name|CHUNK_MASK
decl_stmt|;
name|bfd_vma
name|low_bits
init|=
name|addr
operator|&
name|CHUNK_MASK
decl_stmt|;
if|if
condition|(
name|chunk_number
operator|!=
name|prev_number
condition|)
comment|/* Different chunk, so move pointer. */
name|d
operator|=
name|find_chunk
argument_list|(
name|abfd
argument_list|,
name|chunk_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|get
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|chunk_init
index|[
name|low_bits
index|]
condition|)
operator|*
name|location
operator|=
name|d
operator|->
name|chunk_data
index|[
name|low_bits
index|]
expr_stmt|;
else|else
operator|*
name|location
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|chunk_data
index|[
name|low_bits
index|]
operator|=
operator|*
name|location
expr_stmt|;
name|d
operator|->
name|chunk_init
index|[
name|low_bits
index|]
operator|=
operator|(
operator|*
name|location
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
name|location
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|tekhex_get_section_contents
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|,
name|void
modifier|*
name|locationp
parameter_list|,
name|file_ptr
name|offset
parameter_list|,
name|bfd_size_type
name|count
parameter_list|)
block|{
if|if
condition|(
name|section
operator|->
name|flags
operator|&
operator|(
name|SEC_LOAD
operator||
name|SEC_ALLOC
operator|)
condition|)
block|{
name|move_section_contents
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|locationp
argument_list|,
name|offset
argument_list|,
name|count
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|tekhex_set_arch_mach
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|enum
name|bfd_architecture
name|arch
parameter_list|,
name|unsigned
name|long
name|machine
parameter_list|)
block|{
return|return
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|arch
argument_list|,
name|machine
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* We have to save up all the Tekhexords for a splurge before output.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|tekhex_set_section_contents
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|sec_ptr
name|section
parameter_list|,
specifier|const
name|void
modifier|*
name|locationp
parameter_list|,
name|file_ptr
name|offset
parameter_list|,
name|bfd_size_type
name|bytes_to_do
parameter_list|)
block|{
if|if
condition|(
operator|!
name|abfd
operator|->
name|output_has_begun
condition|)
block|{
comment|/* The first time around, allocate enough sections to hold all the chunks.  */
name|asection
modifier|*
name|s
init|=
name|abfd
operator|->
name|sections
decl_stmt|;
name|bfd_vma
name|vma
decl_stmt|;
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
condition|)
block|{
for|for
control|(
name|vma
operator|=
name|s
operator|->
name|vma
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
name|CHUNK_MASK
init|;
name|vma
operator|<
name|s
operator|->
name|vma
operator|+
name|s
operator|->
name|size
condition|;
name|vma
operator|+=
name|CHUNK_MASK
control|)
name|find_chunk
argument_list|(
name|abfd
argument_list|,
name|vma
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|section
operator|->
name|flags
operator|&
operator|(
name|SEC_LOAD
operator||
name|SEC_ALLOC
operator|)
condition|)
block|{
name|move_section_contents
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|locationp
argument_list|,
name|offset
argument_list|,
name|bytes_to_do
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|writevalue
parameter_list|(
name|char
modifier|*
modifier|*
name|dst
parameter_list|,
name|bfd_vma
name|value
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
operator|*
name|dst
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|shift
decl_stmt|;
for|for
control|(
name|len
operator|=
literal|8
operator|,
name|shift
operator|=
literal|28
init|;
name|shift
condition|;
name|shift
operator|-=
literal|4
operator|,
name|len
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|value
operator|>>
name|shift
operator|)
operator|&
literal|0xf
condition|)
block|{
operator|*
name|p
operator|++
operator|=
name|len
operator|+
literal|'0'
expr_stmt|;
while|while
condition|(
name|len
condition|)
block|{
operator|*
name|p
operator|++
operator|=
name|digs
index|[
operator|(
name|value
operator|>>
name|shift
operator|)
operator|&
literal|0xf
index|]
expr_stmt|;
name|shift
operator|-=
literal|4
expr_stmt|;
name|len
operator|--
expr_stmt|;
block|}
operator|*
name|dst
operator|=
name|p
expr_stmt|;
return|return;
block|}
block|}
operator|*
name|p
operator|++
operator|=
literal|'1'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'0'
expr_stmt|;
operator|*
name|dst
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|writesym
parameter_list|(
name|char
modifier|*
modifier|*
name|dst
parameter_list|,
specifier|const
name|char
modifier|*
name|sym
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
operator|*
name|dst
decl_stmt|;
name|int
name|len
init|=
operator|(
name|sym
condition|?
name|strlen
argument_list|(
name|sym
argument_list|)
else|:
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|len
operator|>=
literal|16
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'0'
expr_stmt|;
name|len
operator|=
literal|16
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'1'
expr_stmt|;
name|sym
operator|=
literal|"$"
expr_stmt|;
name|len
operator|=
literal|1
expr_stmt|;
block|}
else|else
operator|*
name|p
operator|++
operator|=
name|digs
index|[
name|len
index|]
expr_stmt|;
block|}
while|while
condition|(
name|len
operator|--
condition|)
operator|*
name|p
operator|++
operator|=
operator|*
name|sym
operator|++
expr_stmt|;
operator|*
name|dst
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|out
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|int
name|type
parameter_list|,
name|char
modifier|*
name|start
parameter_list|,
name|char
modifier|*
name|end
parameter_list|)
block|{
name|int
name|sum
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|char
name|front
index|[
literal|6
index|]
decl_stmt|;
name|bfd_size_type
name|wrlen
decl_stmt|;
name|front
index|[
literal|0
index|]
operator|=
literal|'%'
expr_stmt|;
name|TOHEX
argument_list|(
name|front
operator|+
literal|1
argument_list|,
name|end
operator|-
name|start
operator|+
literal|5
argument_list|)
expr_stmt|;
name|front
index|[
literal|3
index|]
operator|=
name|type
expr_stmt|;
for|for
control|(
name|s
operator|=
name|start
init|;
name|s
operator|<
name|end
condition|;
name|s
operator|++
control|)
name|sum
operator|+=
name|sum_block
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
index|]
expr_stmt|;
name|sum
operator|+=
name|sum_block
index|[
operator|(
name|unsigned
name|char
operator|)
name|front
index|[
literal|1
index|]
index|]
expr_stmt|;
comment|/* Length.  */
name|sum
operator|+=
name|sum_block
index|[
operator|(
name|unsigned
name|char
operator|)
name|front
index|[
literal|2
index|]
index|]
expr_stmt|;
name|sum
operator|+=
name|sum_block
index|[
operator|(
name|unsigned
name|char
operator|)
name|front
index|[
literal|3
index|]
index|]
expr_stmt|;
comment|/* Type.  */
name|TOHEX
argument_list|(
name|front
operator|+
literal|4
argument_list|,
name|sum
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
name|front
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|6
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|6
condition|)
name|abort
argument_list|()
expr_stmt|;
name|end
index|[
literal|0
index|]
operator|=
literal|'\n'
expr_stmt|;
name|wrlen
operator|=
name|end
operator|-
name|start
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
name|start
argument_list|,
name|wrlen
argument_list|,
name|abfd
argument_list|)
operator|!=
name|wrlen
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|tekhex_write_object_contents
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|int
name|bytes_written
decl_stmt|;
name|char
name|buffer
index|[
literal|100
index|]
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|p
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|struct
name|data_struct
modifier|*
name|d
decl_stmt|;
name|tekhex_init
argument_list|()
expr_stmt|;
name|bytes_written
operator|=
literal|0
expr_stmt|;
comment|/* And the raw data.  */
for|for
control|(
name|d
operator|=
name|abfd
operator|->
name|tdata
operator|.
name|tekhex_data
operator|->
name|data
init|;
name|d
operator|!=
name|NULL
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
name|int
name|low
decl_stmt|;
specifier|const
name|int
name|span
init|=
literal|32
decl_stmt|;
name|int
name|addr
decl_stmt|;
comment|/* Write it in blocks of 32 bytes.  */
for|for
control|(
name|addr
operator|=
literal|0
init|;
name|addr
operator|<
name|CHUNK_MASK
operator|+
literal|1
condition|;
name|addr
operator|+=
name|span
control|)
block|{
name|int
name|need
init|=
literal|0
decl_stmt|;
comment|/* Check to see if necessary.  */
for|for
control|(
name|low
operator|=
literal|0
init|;
operator|!
name|need
operator|&&
name|low
operator|<
name|span
condition|;
name|low
operator|++
control|)
if|if
condition|(
name|d
operator|->
name|chunk_init
index|[
name|addr
operator|+
name|low
index|]
condition|)
name|need
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|need
condition|)
block|{
name|char
modifier|*
name|dst
init|=
name|buffer
decl_stmt|;
name|writevalue
argument_list|(
operator|&
name|dst
argument_list|,
name|addr
operator|+
name|d
operator|->
name|vma
argument_list|)
expr_stmt|;
for|for
control|(
name|low
operator|=
literal|0
init|;
name|low
operator|<
name|span
condition|;
name|low
operator|++
control|)
block|{
name|TOHEX
argument_list|(
name|dst
argument_list|,
name|d
operator|->
name|chunk_data
index|[
name|addr
operator|+
name|low
index|]
argument_list|)
expr_stmt|;
name|dst
operator|+=
literal|2
expr_stmt|;
block|}
name|out
argument_list|(
name|abfd
argument_list|,
literal|'6'
argument_list|,
name|buffer
argument_list|,
name|dst
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Write all the section headers for the sections.  */
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|char
modifier|*
name|dst
init|=
name|buffer
decl_stmt|;
name|writesym
argument_list|(
operator|&
name|dst
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
literal|'1'
expr_stmt|;
name|writevalue
argument_list|(
operator|&
name|dst
argument_list|,
name|s
operator|->
name|vma
argument_list|)
expr_stmt|;
name|writevalue
argument_list|(
operator|&
name|dst
argument_list|,
name|s
operator|->
name|vma
operator|+
name|s
operator|->
name|size
argument_list|)
expr_stmt|;
name|out
argument_list|(
name|abfd
argument_list|,
literal|'3'
argument_list|,
name|buffer
argument_list|,
name|dst
argument_list|)
expr_stmt|;
block|}
comment|/* And the symbols.  */
if|if
condition|(
name|abfd
operator|->
name|outsymbols
condition|)
block|{
for|for
control|(
name|p
operator|=
name|abfd
operator|->
name|outsymbols
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
name|int
name|section_code
init|=
name|bfd_decode_symclass
argument_list|(
operator|*
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|section_code
operator|!=
literal|'?'
condition|)
block|{
comment|/* Do not include debug symbols.  */
name|asymbol
modifier|*
name|sym
init|=
operator|*
name|p
decl_stmt|;
name|char
modifier|*
name|dst
init|=
name|buffer
decl_stmt|;
name|writesym
argument_list|(
operator|&
name|dst
argument_list|,
name|sym
operator|->
name|section
operator|->
name|name
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|section_code
condition|)
block|{
case|case
literal|'A'
case|:
operator|*
name|dst
operator|++
operator|=
literal|'2'
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
operator|*
name|dst
operator|++
operator|=
literal|'6'
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
case|case
literal|'B'
case|:
case|case
literal|'O'
case|:
operator|*
name|dst
operator|++
operator|=
literal|'4'
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'b'
case|:
case|case
literal|'o'
case|:
operator|*
name|dst
operator|++
operator|=
literal|'8'
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
operator|*
name|dst
operator|++
operator|=
literal|'3'
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
operator|*
name|dst
operator|++
operator|=
literal|'7'
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
case|case
literal|'U'
case|:
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|writesym
argument_list|(
operator|&
name|dst
argument_list|,
name|sym
operator|->
name|name
argument_list|)
expr_stmt|;
name|writevalue
argument_list|(
operator|&
name|dst
argument_list|,
name|sym
operator|->
name|value
operator|+
name|sym
operator|->
name|section
operator|->
name|vma
argument_list|)
expr_stmt|;
name|out
argument_list|(
name|abfd
argument_list|,
literal|'3'
argument_list|,
name|buffer
argument_list|,
name|dst
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* And the terminator.  */
if|if
condition|(
name|bfd_bwrite
argument_list|(
literal|"%0781010\n"
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|9
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|9
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tekhex_sizeof_headers
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd_boolean
name|exec
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|asymbol
modifier|*
name|tekhex_make_empty_symbol
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|tekhex_symbol_struct
argument_list|)
decl_stmt|;
name|tekhex_symbol_type
modifier|*
name|new
init|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|new
condition|)
return|return
name|NULL
return|;
name|new
operator|->
name|symbol
operator|.
name|the_bfd
operator|=
name|abfd
expr_stmt|;
name|new
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
return|return
operator|&
operator|(
name|new
operator|->
name|symbol
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|tekhex_get_symbol_info
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|symbol_info
modifier|*
name|ret
parameter_list|)
block|{
name|bfd_symbol_info
argument_list|(
name|symbol
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tekhex_print_symbol
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|void
modifier|*
name|filep
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|bfd_print_symbol_type
name|how
parameter_list|)
block|{
name|FILE
modifier|*
name|file
init|=
operator|(
name|FILE
operator|*
operator|)
name|filep
decl_stmt|;
switch|switch
condition|(
name|how
condition|)
block|{
case|case
name|bfd_print_symbol_name
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|symbol
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_print_symbol_more
case|:
break|break;
case|case
name|bfd_print_symbol_all
case|:
block|{
specifier|const
name|char
modifier|*
name|section_name
init|=
name|symbol
operator|->
name|section
operator|->
name|name
decl_stmt|;
name|bfd_print_symbol_vandf
argument_list|(
name|abfd
argument_list|,
operator|(
name|void
operator|*
operator|)
name|file
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %-5s %s"
argument_list|,
name|section_name
argument_list|,
name|symbol
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_define
define|#
directive|define
name|tekhex_close_and_cleanup
value|_bfd_generic_close_and_cleanup
end_define

begin_define
define|#
directive|define
name|tekhex_bfd_free_cached_info
value|_bfd_generic_bfd_free_cached_info
end_define

begin_define
define|#
directive|define
name|tekhex_new_section_hook
value|_bfd_generic_new_section_hook
end_define

begin_define
define|#
directive|define
name|tekhex_bfd_is_target_special_symbol
value|((bfd_boolean (*) (bfd *, asymbol *)) bfd_false)
end_define

begin_define
define|#
directive|define
name|tekhex_bfd_is_local_label_name
value|bfd_generic_is_local_label_name
end_define

begin_define
define|#
directive|define
name|tekhex_get_lineno
value|_bfd_nosymbols_get_lineno
end_define

begin_define
define|#
directive|define
name|tekhex_find_nearest_line
value|_bfd_nosymbols_find_nearest_line
end_define

begin_define
define|#
directive|define
name|tekhex_find_inliner_info
value|_bfd_nosymbols_find_inliner_info
end_define

begin_define
define|#
directive|define
name|tekhex_bfd_make_debug_symbol
value|_bfd_nosymbols_bfd_make_debug_symbol
end_define

begin_define
define|#
directive|define
name|tekhex_read_minisymbols
value|_bfd_generic_read_minisymbols
end_define

begin_define
define|#
directive|define
name|tekhex_minisymbol_to_symbol
value|_bfd_generic_minisymbol_to_symbol
end_define

begin_define
define|#
directive|define
name|tekhex_bfd_get_relocated_section_contents
value|bfd_generic_get_relocated_section_contents
end_define

begin_define
define|#
directive|define
name|tekhex_bfd_relax_section
value|bfd_generic_relax_section
end_define

begin_define
define|#
directive|define
name|tekhex_bfd_gc_sections
value|bfd_generic_gc_sections
end_define

begin_define
define|#
directive|define
name|tekhex_bfd_merge_sections
value|bfd_generic_merge_sections
end_define

begin_define
define|#
directive|define
name|tekhex_bfd_is_group_section
value|bfd_generic_is_group_section
end_define

begin_define
define|#
directive|define
name|tekhex_bfd_discard_group
value|bfd_generic_discard_group
end_define

begin_define
define|#
directive|define
name|tekhex_section_already_linked
value|_bfd_generic_section_already_linked
end_define

begin_define
define|#
directive|define
name|tekhex_bfd_link_hash_table_create
value|_bfd_generic_link_hash_table_create
end_define

begin_define
define|#
directive|define
name|tekhex_bfd_link_hash_table_free
value|_bfd_generic_link_hash_table_free
end_define

begin_define
define|#
directive|define
name|tekhex_bfd_link_add_symbols
value|_bfd_generic_link_add_symbols
end_define

begin_define
define|#
directive|define
name|tekhex_bfd_link_just_syms
value|_bfd_generic_link_just_syms
end_define

begin_define
define|#
directive|define
name|tekhex_bfd_final_link
value|_bfd_generic_final_link
end_define

begin_define
define|#
directive|define
name|tekhex_bfd_link_split_section
value|_bfd_generic_link_split_section
end_define

begin_define
define|#
directive|define
name|tekhex_get_section_contents_in_window
value|_bfd_generic_get_section_contents_in_window
end_define

begin_decl_stmt
specifier|const
name|bfd_target
name|tekhex_vec
init|=
block|{
literal|"tekhex"
block|,
comment|/* Name.  */
name|bfd_target_tekhex_flavour
block|,
name|BFD_ENDIAN_UNKNOWN
block|,
comment|/* Target byte order.  */
name|BFD_ENDIAN_UNKNOWN
block|,
comment|/* Target headers byte order.  */
operator|(
name|EXEC_P
operator||
comment|/* Object flags.  */
name|HAS_SYMS
operator||
name|HAS_LINENO
operator||
name|HAS_DEBUG
operator||
name|HAS_RELOC
operator||
name|HAS_LOCALS
operator||
name|WP_TEXT
operator||
name|D_PAGED
operator|)
block|,
operator|(
name|SEC_CODE
operator||
name|SEC_DATA
operator||
name|SEC_ROM
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator|)
block|,
comment|/* Section flags.  */
literal|0
block|,
comment|/* Leading underscore.  */
literal|' '
block|,
comment|/* AR_pad_char.  */
literal|16
block|,
comment|/* AR_max_namelen.  */
name|bfd_getb64
block|,
name|bfd_getb_signed_64
block|,
name|bfd_putb64
block|,
name|bfd_getb32
block|,
name|bfd_getb_signed_32
block|,
name|bfd_putb32
block|,
name|bfd_getb16
block|,
name|bfd_getb_signed_16
block|,
name|bfd_putb16
block|,
comment|/* Data.  */
name|bfd_getb64
block|,
name|bfd_getb_signed_64
block|,
name|bfd_putb64
block|,
name|bfd_getb32
block|,
name|bfd_getb_signed_32
block|,
name|bfd_putb32
block|,
name|bfd_getb16
block|,
name|bfd_getb_signed_16
block|,
name|bfd_putb16
block|,
comment|/* Headers.  */
block|{
name|_bfd_dummy_target
block|,
name|tekhex_object_p
block|,
comment|/* bfd_check_format.  */
name|_bfd_dummy_target
block|,
name|_bfd_dummy_target
block|,   }
block|,
block|{
name|bfd_false
block|,
name|tekhex_mkobject
block|,
name|_bfd_generic_mkarchive
block|,
name|bfd_false
block|,   }
block|,
block|{
comment|/* bfd_write_contents.  */
name|bfd_false
block|,
name|tekhex_write_object_contents
block|,
name|_bfd_write_archive_contents
block|,
name|bfd_false
block|,   }
block|,
name|BFD_JUMP_TABLE_GENERIC
argument_list|(
name|tekhex
argument_list|)
block|,
name|BFD_JUMP_TABLE_COPY
argument_list|(
name|_bfd_generic
argument_list|)
block|,
name|BFD_JUMP_TABLE_CORE
argument_list|(
name|_bfd_nocore
argument_list|)
block|,
name|BFD_JUMP_TABLE_ARCHIVE
argument_list|(
name|_bfd_noarchive
argument_list|)
block|,
name|BFD_JUMP_TABLE_SYMBOLS
argument_list|(
name|tekhex
argument_list|)
block|,
name|BFD_JUMP_TABLE_RELOCS
argument_list|(
name|_bfd_norelocs
argument_list|)
block|,
name|BFD_JUMP_TABLE_WRITE
argument_list|(
name|tekhex
argument_list|)
block|,
name|BFD_JUMP_TABLE_LINK
argument_list|(
name|tekhex
argument_list|)
block|,
name|BFD_JUMP_TABLE_DYNAMIC
argument_list|(
name|_bfd_nodynamic
argument_list|)
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

end_unit

