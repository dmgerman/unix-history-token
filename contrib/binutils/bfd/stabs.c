begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Stabs in sections linking support.    Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,    2006, 2007 Free Software Foundation, Inc.    Written by Ian Lance Taylor, Cygnus Support.     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* This file contains support for linking stabs in sections, as used    on COFF and ELF.  */
end_comment

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"aout/stab_gnu.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_comment
comment|/* Stabs entries use a 12 byte format:      4 byte string table index      1 byte stab type      1 byte stab other field      2 byte stab desc field      4 byte stab value    FIXME: This will have to change for a 64 bit object format.     The stabs symbols are divided into compilation units.  For the    first entry in each unit, the type of 0, the value is the length of    the string table for this unit, and the desc field is the number of    stabs symbols for this unit.  */
end_comment

begin_define
define|#
directive|define
name|STRDXOFF
value|0
end_define

begin_define
define|#
directive|define
name|TYPEOFF
value|4
end_define

begin_define
define|#
directive|define
name|OTHEROFF
value|5
end_define

begin_define
define|#
directive|define
name|DESCOFF
value|6
end_define

begin_define
define|#
directive|define
name|VALOFF
value|8
end_define

begin_define
define|#
directive|define
name|STABSIZE
value|12
end_define

begin_comment
comment|/* A linked list of totals that we have found for a particular header    file.  A total is a unique identifier for a particular BINCL...EINCL    sequence of STABs that can be used to identify duplicate sequences.    It consists of three fields, 'sum_chars' which is the sum of all the    STABS characters; 'num_chars' which is the number of these charactes    and 'symb' which is a buffer of all the symbols in the sequence.  This    buffer is only checked as a last resort.  */
end_comment

begin_struct
struct|struct
name|stab_link_includes_totals
block|{
name|struct
name|stab_link_includes_totals
modifier|*
name|next
decl_stmt|;
name|bfd_vma
name|sum_chars
decl_stmt|;
comment|/* Accumulated sum of STABS characters.  */
name|bfd_vma
name|num_chars
decl_stmt|;
comment|/* Number of STABS characters.  */
specifier|const
name|char
modifier|*
name|symb
decl_stmt|;
comment|/* The STABS characters themselves.  */
block|}
struct|;
end_struct

begin_comment
comment|/* An entry in the header file hash table.  */
end_comment

begin_struct
struct|struct
name|stab_link_includes_entry
block|{
name|struct
name|bfd_hash_entry
name|root
decl_stmt|;
comment|/* List of totals we have found for this file.  */
name|struct
name|stab_link_includes_totals
modifier|*
name|totals
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This structure is used to hold a list of N_BINCL symbols, some of    which might be converted into N_EXCL symbols.  */
end_comment

begin_struct
struct|struct
name|stab_excl_list
block|{
comment|/* The next symbol to convert.  */
name|struct
name|stab_excl_list
modifier|*
name|next
decl_stmt|;
comment|/* The offset to this symbol in the section contents.  */
name|bfd_size_type
name|offset
decl_stmt|;
comment|/* The value to use for the symbol.  */
name|bfd_vma
name|val
decl_stmt|;
comment|/* The type of this symbol (N_BINCL or N_EXCL).  */
name|int
name|type
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This structure is stored with each .stab section.  */
end_comment

begin_struct
struct|struct
name|stab_section_info
block|{
comment|/* This is a linked list of N_BINCL symbols which should be      converted into N_EXCL symbols.  */
name|struct
name|stab_excl_list
modifier|*
name|excls
decl_stmt|;
comment|/* This is used to map input stab offsets within their sections      to output stab offsets, to take into account stabs that have      been deleted.  If it is NULL, the output offsets are the same      as the input offsets, because no stabs have been deleted from      this section.  Otherwise the i'th entry is the number of      bytes of stabs that have been deleted prior to the i'th      stab.  */
name|bfd_size_type
modifier|*
name|cumulative_skips
decl_stmt|;
comment|/* This is an array of string indices.  For each stab symbol, we      store the string index here.  If a stab symbol should not be      included in the final output, the string index is -1.  */
name|bfd_size_type
name|stridxs
index|[
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_escape
end_escape

begin_comment
comment|/* The function to create a new entry in the header file hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|stab_link_includes_newfunc
parameter_list|(
name|struct
name|bfd_hash_entry
modifier|*
name|entry
parameter_list|,
name|struct
name|bfd_hash_table
modifier|*
name|table
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|struct
name|stab_link_includes_entry
modifier|*
name|ret
init|=
operator|(
expr|struct
name|stab_link_includes_entry
operator|*
operator|)
name|entry
decl_stmt|;
comment|/* Allocate the structure if it has not already been allocated by a      subclass.  */
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
name|ret
operator|=
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|stab_link_includes_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* Call the allocation method of the superclass.  */
name|ret
operator|=
operator|(
operator|(
expr|struct
name|stab_link_includes_entry
operator|*
operator|)
name|bfd_hash_newfunc
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
comment|/* Set local fields.  */
name|ret
operator|->
name|totals
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This function is called for each input file from the add_symbols    pass of the linker.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_link_section_stabs
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|stab_info
modifier|*
name|sinfo
parameter_list|,
name|asection
modifier|*
name|stabsec
parameter_list|,
name|asection
modifier|*
name|stabstrsec
parameter_list|,
name|void
modifier|*
modifier|*
name|psecinfo
parameter_list|,
name|bfd_size_type
modifier|*
name|pstring_offset
parameter_list|)
block|{
name|bfd_boolean
name|first
decl_stmt|;
name|bfd_size_type
name|count
decl_stmt|,
name|amt
decl_stmt|;
name|struct
name|stab_section_info
modifier|*
name|secinfo
decl_stmt|;
name|bfd_byte
modifier|*
name|stabbuf
init|=
name|NULL
decl_stmt|;
name|bfd_byte
modifier|*
name|stabstrbuf
init|=
name|NULL
decl_stmt|;
name|bfd_byte
modifier|*
name|sym
decl_stmt|,
modifier|*
name|symend
decl_stmt|;
name|bfd_size_type
name|stroff
decl_stmt|,
name|next_stroff
decl_stmt|,
name|skip
decl_stmt|;
name|bfd_size_type
modifier|*
name|pstridx
decl_stmt|;
if|if
condition|(
name|stabsec
operator|->
name|size
operator|==
literal|0
operator|||
name|stabstrsec
operator|->
name|size
operator|==
literal|0
condition|)
comment|/* This file does not contain stabs debugging information.  */
return|return
name|TRUE
return|;
if|if
condition|(
name|stabsec
operator|->
name|size
operator|%
name|STABSIZE
operator|!=
literal|0
condition|)
comment|/* Something is wrong with the format of these stab symbols.        Don't try to optimize them.  */
return|return
name|TRUE
return|;
if|if
condition|(
operator|(
name|stabstrsec
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|!=
literal|0
condition|)
comment|/* We shouldn't see relocations in the strings, and we aren't        prepared to handle them.  */
return|return
name|TRUE
return|;
if|if
condition|(
name|bfd_is_abs_section
argument_list|(
name|stabsec
operator|->
name|output_section
argument_list|)
operator|||
name|bfd_is_abs_section
argument_list|(
name|stabstrsec
operator|->
name|output_section
argument_list|)
condition|)
comment|/* At least one of the sections is being discarded from the        link, so we should just ignore them.  */
return|return
name|TRUE
return|;
name|first
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|sinfo
operator|->
name|stabstr
operator|==
name|NULL
condition|)
block|{
name|flagword
name|flags
decl_stmt|;
comment|/* Initialize the stabs information we need to keep track of.  */
name|first
operator|=
name|TRUE
expr_stmt|;
name|sinfo
operator|->
name|strings
operator|=
name|_bfd_stringtab_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|sinfo
operator|->
name|strings
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
comment|/* Make sure the first byte is zero.  */
operator|(
name|void
operator|)
name|_bfd_stringtab_add
argument_list|(
name|sinfo
operator|->
name|strings
argument_list|,
literal|""
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_hash_table_init
argument_list|(
operator|&
name|sinfo
operator|->
name|includes
argument_list|,
name|stab_link_includes_newfunc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|stab_link_includes_entry
argument_list|)
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
name|flags
operator|=
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_READONLY
operator||
name|SEC_DEBUGGING
operator||
name|SEC_LINKER_CREATED
operator|)
expr_stmt|;
name|sinfo
operator|->
name|stabstr
operator|=
name|bfd_make_section_anyway_with_flags
argument_list|(
name|abfd
argument_list|,
literal|".stabstr"
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|sinfo
operator|->
name|stabstr
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
block|}
comment|/* Initialize the information we are going to store for this .stab      section.  */
name|count
operator|=
name|stabsec
operator|->
name|size
operator|/
name|STABSIZE
expr_stmt|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|stab_section_info
argument_list|)
expr_stmt|;
name|amt
operator|+=
operator|(
name|count
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|bfd_size_type
argument_list|)
expr_stmt|;
operator|*
name|psecinfo
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|psecinfo
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|secinfo
operator|=
operator|(
expr|struct
name|stab_section_info
operator|*
operator|)
operator|*
name|psecinfo
expr_stmt|;
name|secinfo
operator|->
name|excls
operator|=
name|NULL
expr_stmt|;
name|stabsec
operator|->
name|rawsize
operator|=
name|stabsec
operator|->
name|size
expr_stmt|;
name|secinfo
operator|->
name|cumulative_skips
operator|=
name|NULL
expr_stmt|;
name|memset
argument_list|(
name|secinfo
operator|->
name|stridxs
argument_list|,
literal|0
argument_list|,
operator|(
name|size_t
operator|)
name|count
operator|*
sizeof|sizeof
argument_list|(
name|bfd_size_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read the stabs information from abfd.  */
if|if
condition|(
operator|!
name|bfd_malloc_and_get_section
argument_list|(
name|abfd
argument_list|,
name|stabsec
argument_list|,
operator|&
name|stabbuf
argument_list|)
operator|||
operator|!
name|bfd_malloc_and_get_section
argument_list|(
name|abfd
argument_list|,
name|stabstrsec
argument_list|,
operator|&
name|stabstrbuf
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* Look through the stabs symbols, work out the new string indices,      and identify N_BINCL symbols which can be eliminated.  */
name|stroff
operator|=
literal|0
expr_stmt|;
comment|/* The stabs sections can be split when      -split-by-reloc/-split-by-file is used.  We must keep track of      each stab section's place in the single concatenated string      table.  */
name|next_stroff
operator|=
name|pstring_offset
condition|?
operator|*
name|pstring_offset
else|:
literal|0
expr_stmt|;
name|skip
operator|=
literal|0
expr_stmt|;
name|symend
operator|=
name|stabbuf
operator|+
name|stabsec
operator|->
name|size
expr_stmt|;
for|for
control|(
name|sym
operator|=
name|stabbuf
operator|,
name|pstridx
operator|=
name|secinfo
operator|->
name|stridxs
init|;
name|sym
operator|<
name|symend
condition|;
name|sym
operator|+=
name|STABSIZE
operator|,
operator|++
name|pstridx
control|)
block|{
name|bfd_size_type
name|symstroff
decl_stmt|;
name|int
name|type
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
if|if
condition|(
operator|*
name|pstridx
operator|!=
literal|0
condition|)
comment|/* This symbol has already been handled by an N_BINCL pass.  */
continue|continue;
name|type
operator|=
name|sym
index|[
name|TYPEOFF
index|]
expr_stmt|;
if|if
condition|(
name|type
operator|==
literal|0
condition|)
block|{
comment|/* Special type 0 stabs indicate the offset to the next 	     string table.  We only copy the very first one.  */
name|stroff
operator|=
name|next_stroff
expr_stmt|;
name|next_stroff
operator|+=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|sym
operator|+
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|pstring_offset
condition|)
operator|*
name|pstring_offset
operator|=
name|next_stroff
expr_stmt|;
if|if
condition|(
operator|!
name|first
condition|)
block|{
operator|*
name|pstridx
operator|=
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
expr_stmt|;
operator|++
name|skip
expr_stmt|;
continue|continue;
block|}
name|first
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* Store the string in the hash table, and record the index.  */
name|symstroff
operator|=
name|stroff
operator|+
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|sym
operator|+
name|STRDXOFF
argument_list|)
expr_stmt|;
if|if
condition|(
name|symstroff
operator|>=
name|stabstrsec
operator|->
name|size
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B(%A+0x%lx): Stabs entry has invalid string index."
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|stabsec
argument_list|,
call|(
name|long
call|)
argument_list|(
name|sym
operator|-
name|stabbuf
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|string
operator|=
operator|(
name|char
operator|*
operator|)
name|stabstrbuf
operator|+
name|symstroff
expr_stmt|;
operator|*
name|pstridx
operator|=
name|_bfd_stringtab_add
argument_list|(
name|sinfo
operator|->
name|strings
argument_list|,
name|string
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* An N_BINCL symbol indicates the start of the stabs entries 	 for a header file.  We need to scan ahead to the next N_EINCL 	 symbol, ignoring nesting, adding up all the characters in the 	 symbol names, not including the file numbers in types (the 	 first number after an open parenthesis).  */
if|if
condition|(
name|type
operator|==
operator|(
name|int
operator|)
name|N_BINCL
condition|)
block|{
name|bfd_vma
name|sum_chars
decl_stmt|;
name|bfd_vma
name|num_chars
decl_stmt|;
name|bfd_vma
name|buf_len
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|symb
decl_stmt|;
name|char
modifier|*
name|symb_rover
decl_stmt|;
name|int
name|nest
decl_stmt|;
name|bfd_byte
modifier|*
name|incl_sym
decl_stmt|;
name|struct
name|stab_link_includes_entry
modifier|*
name|incl_entry
decl_stmt|;
name|struct
name|stab_link_includes_totals
modifier|*
name|t
decl_stmt|;
name|struct
name|stab_excl_list
modifier|*
name|ne
decl_stmt|;
name|symb
operator|=
name|symb_rover
operator|=
name|NULL
expr_stmt|;
name|sum_chars
operator|=
name|num_chars
operator|=
literal|0
expr_stmt|;
name|nest
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|incl_sym
operator|=
name|sym
operator|+
name|STABSIZE
init|;
name|incl_sym
operator|<
name|symend
condition|;
name|incl_sym
operator|+=
name|STABSIZE
control|)
block|{
name|int
name|incl_type
decl_stmt|;
name|incl_type
operator|=
name|incl_sym
index|[
name|TYPEOFF
index|]
expr_stmt|;
if|if
condition|(
name|incl_type
operator|==
literal|0
condition|)
break|break;
elseif|else
if|if
condition|(
name|incl_type
operator|==
operator|(
name|int
operator|)
name|N_EXCL
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|incl_type
operator|==
operator|(
name|int
operator|)
name|N_EINCL
condition|)
block|{
if|if
condition|(
name|nest
operator|==
literal|0
condition|)
break|break;
operator|--
name|nest
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|incl_type
operator|==
operator|(
name|int
operator|)
name|N_BINCL
condition|)
operator|++
name|nest
expr_stmt|;
elseif|else
if|if
condition|(
name|nest
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|str
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|stabstrbuf
operator|+
name|stroff
operator|+
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|incl_sym
operator|+
name|STRDXOFF
argument_list|)
operator|)
expr_stmt|;
for|for
control|(
init|;
operator|*
name|str
operator|!=
literal|'\0'
condition|;
name|str
operator|++
control|)
block|{
if|if
condition|(
name|num_chars
operator|>=
name|buf_len
condition|)
block|{
name|buf_len
operator|+=
literal|32
operator|*
literal|1024
expr_stmt|;
name|symb
operator|=
name|bfd_realloc
argument_list|(
name|symb
argument_list|,
name|buf_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|symb
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|symb_rover
operator|=
name|symb
operator|+
name|num_chars
expr_stmt|;
block|}
operator|*
name|symb_rover
operator|++
operator|=
operator|*
name|str
expr_stmt|;
name|sum_chars
operator|+=
operator|*
name|str
expr_stmt|;
name|num_chars
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|'('
condition|)
block|{
comment|/* Skip the file number.  */
operator|++
name|str
expr_stmt|;
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|str
argument_list|)
condition|)
operator|++
name|str
expr_stmt|;
operator|--
name|str
expr_stmt|;
block|}
block|}
block|}
block|}
name|BFD_ASSERT
argument_list|(
name|num_chars
operator|==
call|(
name|bfd_vma
call|)
argument_list|(
name|symb_rover
operator|-
name|symb
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we have already included a header file with the same 	     value, then replaced this one with an N_EXCL symbol.  */
name|incl_entry
operator|=
operator|(
expr|struct
name|stab_link_includes_entry
operator|*
operator|)
name|bfd_hash_lookup
argument_list|(
operator|&
name|sinfo
operator|->
name|includes
argument_list|,
name|string
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|incl_entry
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
for|for
control|(
name|t
operator|=
name|incl_entry
operator|->
name|totals
init|;
name|t
operator|!=
name|NULL
condition|;
name|t
operator|=
name|t
operator|->
name|next
control|)
if|if
condition|(
name|t
operator|->
name|sum_chars
operator|==
name|sum_chars
operator|&&
name|t
operator|->
name|num_chars
operator|==
name|num_chars
operator|&&
name|memcmp
argument_list|(
name|t
operator|->
name|symb
argument_list|,
name|symb
argument_list|,
name|num_chars
argument_list|)
operator|==
literal|0
condition|)
break|break;
comment|/* Record this symbol, so that we can set the value 	     correctly.  */
name|amt
operator|=
sizeof|sizeof
expr|*
name|ne
expr_stmt|;
name|ne
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ne
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|ne
operator|->
name|offset
operator|=
name|sym
operator|-
name|stabbuf
expr_stmt|;
name|ne
operator|->
name|val
operator|=
name|sum_chars
expr_stmt|;
name|ne
operator|->
name|type
operator|=
operator|(
name|int
operator|)
name|N_BINCL
expr_stmt|;
name|ne
operator|->
name|next
operator|=
name|secinfo
operator|->
name|excls
expr_stmt|;
name|secinfo
operator|->
name|excls
operator|=
name|ne
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
block|{
comment|/* This is the first time we have seen this header file 		 with this set of stabs strings.  */
name|t
operator|=
name|bfd_hash_allocate
argument_list|(
operator|&
name|sinfo
operator|->
name|includes
argument_list|,
sizeof|sizeof
expr|*
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|t
operator|->
name|sum_chars
operator|=
name|sum_chars
expr_stmt|;
name|t
operator|->
name|num_chars
operator|=
name|num_chars
expr_stmt|;
name|t
operator|->
name|symb
operator|=
name|bfd_realloc
argument_list|(
name|symb
argument_list|,
name|num_chars
argument_list|)
expr_stmt|;
comment|/* Trim data down.  */
name|t
operator|->
name|next
operator|=
name|incl_entry
operator|->
name|totals
expr_stmt|;
name|incl_entry
operator|->
name|totals
operator|=
name|t
expr_stmt|;
block|}
else|else
block|{
name|bfd_size_type
modifier|*
name|incl_pstridx
decl_stmt|;
comment|/* We have seen this header file before.  Tell the final 		 pass to change the type to N_EXCL.  */
name|ne
operator|->
name|type
operator|=
operator|(
name|int
operator|)
name|N_EXCL
expr_stmt|;
comment|/* Free off superfluous symbols.  */
name|free
argument_list|(
name|symb
argument_list|)
expr_stmt|;
comment|/* Mark the skipped symbols.  */
name|nest
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|incl_sym
operator|=
name|sym
operator|+
name|STABSIZE
operator|,
name|incl_pstridx
operator|=
name|pstridx
operator|+
literal|1
init|;
name|incl_sym
operator|<
name|symend
condition|;
name|incl_sym
operator|+=
name|STABSIZE
operator|,
operator|++
name|incl_pstridx
control|)
block|{
name|int
name|incl_type
decl_stmt|;
name|incl_type
operator|=
name|incl_sym
index|[
name|TYPEOFF
index|]
expr_stmt|;
if|if
condition|(
name|incl_type
operator|==
operator|(
name|int
operator|)
name|N_EINCL
condition|)
block|{
if|if
condition|(
name|nest
operator|==
literal|0
condition|)
block|{
operator|*
name|incl_pstridx
operator|=
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
expr_stmt|;
operator|++
name|skip
expr_stmt|;
break|break;
block|}
operator|--
name|nest
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|incl_type
operator|==
operator|(
name|int
operator|)
name|N_BINCL
condition|)
operator|++
name|nest
expr_stmt|;
elseif|else
if|if
condition|(
name|incl_type
operator|==
operator|(
name|int
operator|)
name|N_EXCL
condition|)
comment|/* Keep existing exclusion marks.  */
continue|continue;
elseif|else
if|if
condition|(
name|nest
operator|==
literal|0
condition|)
block|{
operator|*
name|incl_pstridx
operator|=
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
expr_stmt|;
operator|++
name|skip
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
name|free
argument_list|(
name|stabbuf
argument_list|)
expr_stmt|;
name|stabbuf
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|stabstrbuf
argument_list|)
expr_stmt|;
name|stabstrbuf
operator|=
name|NULL
expr_stmt|;
comment|/* We need to set the section sizes such that the linker will      compute the output section sizes correctly.  We set the .stab      size to not include the entries we don't want.  We set      SEC_EXCLUDE for the .stabstr section, so that it will be dropped      from the link.  We record the size of the strtab in the first      .stabstr section we saw, and make sure we don't set SEC_EXCLUDE      for that section.  */
name|stabsec
operator|->
name|size
operator|=
operator|(
name|count
operator|-
name|skip
operator|)
operator|*
name|STABSIZE
expr_stmt|;
if|if
condition|(
name|stabsec
operator|->
name|size
operator|==
literal|0
condition|)
name|stabsec
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
operator||
name|SEC_KEEP
expr_stmt|;
name|stabstrsec
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
operator||
name|SEC_KEEP
expr_stmt|;
name|sinfo
operator|->
name|stabstr
operator|->
name|size
operator|=
name|_bfd_stringtab_size
argument_list|(
name|sinfo
operator|->
name|strings
argument_list|)
expr_stmt|;
comment|/* Calculate the `cumulative_skips' array now that stabs have been      deleted for this section.  */
if|if
condition|(
name|skip
operator|!=
literal|0
condition|)
block|{
name|bfd_size_type
name|i
decl_stmt|,
name|offset
decl_stmt|;
name|bfd_size_type
modifier|*
name|pskips
decl_stmt|;
name|amt
operator|=
name|count
operator|*
sizeof|sizeof
argument_list|(
name|bfd_size_type
argument_list|)
expr_stmt|;
name|secinfo
operator|->
name|cumulative_skips
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|secinfo
operator|->
name|cumulative_skips
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|pskips
operator|=
name|secinfo
operator|->
name|cumulative_skips
expr_stmt|;
name|pstridx
operator|=
name|secinfo
operator|->
name|stridxs
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|pskips
operator|++
operator|,
name|pstridx
operator|++
control|)
block|{
operator|*
name|pskips
operator|=
name|offset
expr_stmt|;
if|if
condition|(
operator|*
name|pstridx
operator|==
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
condition|)
name|offset
operator|+=
name|STABSIZE
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
name|offset
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
name|error_return
label|:
if|if
condition|(
name|stabbuf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|stabbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|stabstrbuf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|stabstrbuf
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This function is called for each input file before the stab    section is relocated.  It discards stab entries for discarded    functions and variables.  The function returns TRUE iff    any entries have been deleted. */
end_comment

begin_function
name|bfd_boolean
name|_bfd_discard_section_stabs
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|stabsec
parameter_list|,
name|void
modifier|*
name|psecinfo
parameter_list|,
name|bfd_boolean
function_decl|(
modifier|*
name|reloc_symbol_deleted_p
function_decl|)
parameter_list|(
name|bfd_vma
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|cookie
parameter_list|)
block|{
name|bfd_size_type
name|count
decl_stmt|,
name|amt
decl_stmt|;
name|struct
name|stab_section_info
modifier|*
name|secinfo
decl_stmt|;
name|bfd_byte
modifier|*
name|stabbuf
init|=
name|NULL
decl_stmt|;
name|bfd_byte
modifier|*
name|sym
decl_stmt|,
modifier|*
name|symend
decl_stmt|;
name|bfd_size_type
name|skip
decl_stmt|;
name|bfd_size_type
modifier|*
name|pstridx
decl_stmt|;
name|int
name|deleting
decl_stmt|;
if|if
condition|(
name|stabsec
operator|->
name|size
operator|==
literal|0
condition|)
comment|/* This file does not contain stabs debugging information.  */
return|return
name|FALSE
return|;
if|if
condition|(
name|stabsec
operator|->
name|size
operator|%
name|STABSIZE
operator|!=
literal|0
condition|)
comment|/* Something is wrong with the format of these stab symbols.        Don't try to optimize them.  */
return|return
name|FALSE
return|;
if|if
condition|(
operator|(
name|stabsec
operator|->
name|output_section
operator|!=
name|NULL
operator|&&
name|bfd_is_abs_section
argument_list|(
name|stabsec
operator|->
name|output_section
argument_list|)
operator|)
condition|)
comment|/* At least one of the sections is being discarded from the        link, so we should just ignore them.  */
return|return
name|FALSE
return|;
comment|/* We should have initialized our data in _bfd_link_stab_sections.      If there was some bizarre error reading the string sections, though,      we might not have.  Bail rather than asserting.  */
if|if
condition|(
name|psecinfo
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|count
operator|=
name|stabsec
operator|->
name|rawsize
operator|/
name|STABSIZE
expr_stmt|;
name|secinfo
operator|=
operator|(
expr|struct
name|stab_section_info
operator|*
operator|)
name|psecinfo
expr_stmt|;
comment|/* Read the stabs information from abfd.  */
if|if
condition|(
operator|!
name|bfd_malloc_and_get_section
argument_list|(
name|abfd
argument_list|,
name|stabsec
argument_list|,
operator|&
name|stabbuf
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* Look through the stabs symbols and discard any information for      discarded functions.  */
name|skip
operator|=
literal|0
expr_stmt|;
name|deleting
operator|=
operator|-
literal|1
expr_stmt|;
name|symend
operator|=
name|stabbuf
operator|+
name|stabsec
operator|->
name|rawsize
expr_stmt|;
for|for
control|(
name|sym
operator|=
name|stabbuf
operator|,
name|pstridx
operator|=
name|secinfo
operator|->
name|stridxs
init|;
name|sym
operator|<
name|symend
condition|;
name|sym
operator|+=
name|STABSIZE
operator|,
operator|++
name|pstridx
control|)
block|{
name|int
name|type
decl_stmt|;
if|if
condition|(
operator|*
name|pstridx
operator|==
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
condition|)
comment|/* This stab was deleted in a previous pass.  */
continue|continue;
name|type
operator|=
name|sym
index|[
name|TYPEOFF
index|]
expr_stmt|;
if|if
condition|(
name|type
operator|==
operator|(
name|int
operator|)
name|N_FUN
condition|)
block|{
name|int
name|strx
init|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|sym
operator|+
name|STRDXOFF
argument_list|)
decl_stmt|;
if|if
condition|(
name|strx
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|deleting
condition|)
block|{
name|skip
operator|++
expr_stmt|;
operator|*
name|pstridx
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|deleting
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
name|deleting
operator|=
literal|0
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|reloc_symbol_deleted_p
call|)
argument_list|(
name|sym
operator|+
name|VALOFF
operator|-
name|stabbuf
argument_list|,
name|cookie
argument_list|)
condition|)
name|deleting
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|deleting
operator|==
literal|1
condition|)
block|{
operator|*
name|pstridx
operator|=
operator|-
literal|1
expr_stmt|;
name|skip
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|deleting
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* Outside of a function.  Check for deleted variables.  */
if|if
condition|(
name|type
operator|==
operator|(
name|int
operator|)
name|N_STSYM
operator|||
name|type
operator|==
operator|(
name|int
operator|)
name|N_LCSYM
condition|)
if|if
condition|(
call|(
modifier|*
name|reloc_symbol_deleted_p
call|)
argument_list|(
name|sym
operator|+
name|VALOFF
operator|-
name|stabbuf
argument_list|,
name|cookie
argument_list|)
condition|)
block|{
operator|*
name|pstridx
operator|=
operator|-
literal|1
expr_stmt|;
name|skip
operator|++
expr_stmt|;
block|}
comment|/* We should also check for N_GSYM entries which reference a 	     deleted global, but those are less harmful to debuggers 	     and would require parsing the stab strings.  */
block|}
block|}
name|free
argument_list|(
name|stabbuf
argument_list|)
expr_stmt|;
name|stabbuf
operator|=
name|NULL
expr_stmt|;
comment|/* Shrink the stabsec as needed.  */
name|stabsec
operator|->
name|size
operator|-=
name|skip
operator|*
name|STABSIZE
expr_stmt|;
if|if
condition|(
name|stabsec
operator|->
name|size
operator|==
literal|0
condition|)
name|stabsec
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
operator||
name|SEC_KEEP
expr_stmt|;
comment|/* Recalculate the `cumulative_skips' array now that stabs have been      deleted for this section.  */
if|if
condition|(
name|skip
operator|!=
literal|0
condition|)
block|{
name|bfd_size_type
name|i
decl_stmt|,
name|offset
decl_stmt|;
name|bfd_size_type
modifier|*
name|pskips
decl_stmt|;
if|if
condition|(
name|secinfo
operator|->
name|cumulative_skips
operator|==
name|NULL
condition|)
block|{
name|amt
operator|=
name|count
operator|*
sizeof|sizeof
argument_list|(
name|bfd_size_type
argument_list|)
expr_stmt|;
name|secinfo
operator|->
name|cumulative_skips
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|secinfo
operator|->
name|cumulative_skips
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
block|}
name|pskips
operator|=
name|secinfo
operator|->
name|cumulative_skips
expr_stmt|;
name|pstridx
operator|=
name|secinfo
operator|->
name|stridxs
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|pskips
operator|++
operator|,
name|pstridx
operator|++
control|)
block|{
operator|*
name|pskips
operator|=
name|offset
expr_stmt|;
if|if
condition|(
operator|*
name|pstridx
operator|==
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
condition|)
name|offset
operator|+=
name|STABSIZE
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
name|offset
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|skip
operator|>
literal|0
return|;
name|error_return
label|:
if|if
condition|(
name|stabbuf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|stabbuf
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Write out the stab section.  This is called with the relocated    contents.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_write_section_stabs
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|stab_info
modifier|*
name|sinfo
parameter_list|,
name|asection
modifier|*
name|stabsec
parameter_list|,
name|void
modifier|*
modifier|*
name|psecinfo
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|)
block|{
name|struct
name|stab_section_info
modifier|*
name|secinfo
decl_stmt|;
name|struct
name|stab_excl_list
modifier|*
name|e
decl_stmt|;
name|bfd_byte
modifier|*
name|sym
decl_stmt|,
modifier|*
name|tosym
decl_stmt|,
modifier|*
name|symend
decl_stmt|;
name|bfd_size_type
modifier|*
name|pstridx
decl_stmt|;
name|secinfo
operator|=
operator|(
expr|struct
name|stab_section_info
operator|*
operator|)
operator|*
name|psecinfo
expr_stmt|;
if|if
condition|(
name|secinfo
operator|==
name|NULL
condition|)
return|return
name|bfd_set_section_contents
argument_list|(
name|output_bfd
argument_list|,
name|stabsec
operator|->
name|output_section
argument_list|,
name|contents
argument_list|,
name|stabsec
operator|->
name|output_offset
argument_list|,
name|stabsec
operator|->
name|size
argument_list|)
return|;
comment|/* Handle each N_BINCL entry.  */
for|for
control|(
name|e
operator|=
name|secinfo
operator|->
name|excls
init|;
name|e
operator|!=
name|NULL
condition|;
name|e
operator|=
name|e
operator|->
name|next
control|)
block|{
name|bfd_byte
modifier|*
name|excl_sym
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|e
operator|->
name|offset
operator|<
name|stabsec
operator|->
name|rawsize
argument_list|)
expr_stmt|;
name|excl_sym
operator|=
name|contents
operator|+
name|e
operator|->
name|offset
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|e
operator|->
name|val
argument_list|,
name|excl_sym
operator|+
name|VALOFF
argument_list|)
expr_stmt|;
name|excl_sym
index|[
name|TYPEOFF
index|]
operator|=
name|e
operator|->
name|type
expr_stmt|;
block|}
comment|/* Copy over all the stabs symbols, omitting the ones we don't want,      and correcting the string indices for those we do want.  */
name|tosym
operator|=
name|contents
expr_stmt|;
name|symend
operator|=
name|contents
operator|+
name|stabsec
operator|->
name|rawsize
expr_stmt|;
for|for
control|(
name|sym
operator|=
name|contents
operator|,
name|pstridx
operator|=
name|secinfo
operator|->
name|stridxs
init|;
name|sym
operator|<
name|symend
condition|;
name|sym
operator|+=
name|STABSIZE
operator|,
operator|++
name|pstridx
control|)
block|{
if|if
condition|(
operator|*
name|pstridx
operator|!=
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|tosym
operator|!=
name|sym
condition|)
name|memcpy
argument_list|(
name|tosym
argument_list|,
name|sym
argument_list|,
name|STABSIZE
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|*
name|pstridx
argument_list|,
name|tosym
operator|+
name|STRDXOFF
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
index|[
name|TYPEOFF
index|]
operator|==
literal|0
condition|)
block|{
comment|/* This is the header symbol for the stabs section.  We 		 don't really need one, since we have merged all the 		 input stabs sections into one, but we generate one 		 for the benefit of readers which expect to see one.  */
name|BFD_ASSERT
argument_list|(
name|sym
operator|==
name|contents
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|_bfd_stringtab_size
argument_list|(
name|sinfo
operator|->
name|strings
argument_list|)
argument_list|,
name|tosym
operator|+
name|VALOFF
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|output_bfd
argument_list|,
name|stabsec
operator|->
name|output_section
operator|->
name|size
operator|/
name|STABSIZE
operator|-
literal|1
argument_list|,
name|tosym
operator|+
name|DESCOFF
argument_list|)
expr_stmt|;
block|}
name|tosym
operator|+=
name|STABSIZE
expr_stmt|;
block|}
block|}
name|BFD_ASSERT
argument_list|(
call|(
name|bfd_size_type
call|)
argument_list|(
name|tosym
operator|-
name|contents
argument_list|)
operator|==
name|stabsec
operator|->
name|size
argument_list|)
expr_stmt|;
return|return
name|bfd_set_section_contents
argument_list|(
name|output_bfd
argument_list|,
name|stabsec
operator|->
name|output_section
argument_list|,
name|contents
argument_list|,
operator|(
name|file_ptr
operator|)
name|stabsec
operator|->
name|output_offset
argument_list|,
name|stabsec
operator|->
name|size
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Write out the .stabstr section.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_write_stab_strings
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|stab_info
modifier|*
name|sinfo
parameter_list|)
block|{
if|if
condition|(
name|bfd_is_abs_section
argument_list|(
name|sinfo
operator|->
name|stabstr
operator|->
name|output_section
argument_list|)
condition|)
comment|/* The section was discarded from the link.  */
return|return
name|TRUE
return|;
name|BFD_ASSERT
argument_list|(
operator|(
name|sinfo
operator|->
name|stabstr
operator|->
name|output_offset
operator|+
name|_bfd_stringtab_size
argument_list|(
name|sinfo
operator|->
name|strings
argument_list|)
operator|)
operator|<=
name|sinfo
operator|->
name|stabstr
operator|->
name|output_section
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|output_bfd
argument_list|,
call|(
name|file_ptr
call|)
argument_list|(
name|sinfo
operator|->
name|stabstr
operator|->
name|output_section
operator|->
name|filepos
operator|+
name|sinfo
operator|->
name|stabstr
operator|->
name|output_offset
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|_bfd_stringtab_emit
argument_list|(
name|output_bfd
argument_list|,
name|sinfo
operator|->
name|strings
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* We no longer need the stabs information.  */
name|_bfd_stringtab_free
argument_list|(
name|sinfo
operator|->
name|strings
argument_list|)
expr_stmt|;
name|bfd_hash_table_free
argument_list|(
operator|&
name|sinfo
operator|->
name|includes
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Adjust an address in the .stab section.  Given OFFSET within    STABSEC, this returns the new offset in the adjusted stab section,    or -1 if the address refers to a stab which has been removed.  */
end_comment

begin_function
name|bfd_vma
name|_bfd_stab_section_offset
parameter_list|(
name|asection
modifier|*
name|stabsec
parameter_list|,
name|void
modifier|*
name|psecinfo
parameter_list|,
name|bfd_vma
name|offset
parameter_list|)
block|{
name|struct
name|stab_section_info
modifier|*
name|secinfo
decl_stmt|;
name|secinfo
operator|=
operator|(
expr|struct
name|stab_section_info
operator|*
operator|)
name|psecinfo
expr_stmt|;
if|if
condition|(
name|secinfo
operator|==
name|NULL
condition|)
return|return
name|offset
return|;
if|if
condition|(
name|offset
operator|>=
name|stabsec
operator|->
name|rawsize
condition|)
return|return
name|offset
operator|-
name|stabsec
operator|->
name|rawsize
operator|+
name|stabsec
operator|->
name|size
return|;
if|if
condition|(
name|secinfo
operator|->
name|cumulative_skips
condition|)
block|{
name|bfd_vma
name|i
decl_stmt|;
name|i
operator|=
name|offset
operator|/
name|STABSIZE
expr_stmt|;
if|if
condition|(
name|secinfo
operator|->
name|stridxs
index|[
name|i
index|]
operator|==
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
condition|)
return|return
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
return|;
return|return
name|offset
operator|-
name|secinfo
operator|->
name|cumulative_skips
index|[
name|i
index|]
return|;
block|}
return|return
name|offset
return|;
block|}
end_function

end_unit

