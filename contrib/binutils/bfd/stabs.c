begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Stabs in sections linking support.    Copyright 1996, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.    Written by Ian Lance Taylor, Cygnus Support.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file contains support for linking stabs in sections, as used    on COFF and ELF.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"aout/stab_gnu.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_comment
comment|/* Stabs entries use a 12 byte format:      4 byte string table index      1 byte stab type      1 byte stab other field      2 byte stab desc field      4 byte stab value    FIXME: This will have to change for a 64 bit object format.     The stabs symbols are divided into compilation units.  For the    first entry in each unit, the type of 0, the value is the length of    the string table for this unit, and the desc field is the number of    stabs symbols for this unit.  */
end_comment

begin_define
define|#
directive|define
name|STRDXOFF
value|(0)
end_define

begin_define
define|#
directive|define
name|TYPEOFF
value|(4)
end_define

begin_define
define|#
directive|define
name|OTHEROFF
value|(5)
end_define

begin_define
define|#
directive|define
name|DESCOFF
value|(6)
end_define

begin_define
define|#
directive|define
name|VALOFF
value|(8)
end_define

begin_define
define|#
directive|define
name|STABSIZE
value|(12)
end_define

begin_comment
comment|/* A hash table used for header files with N_BINCL entries.  */
end_comment

begin_struct
struct|struct
name|stab_link_includes_table
block|{
name|struct
name|bfd_hash_table
name|root
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A linked list of totals that we have found for a particular header    file.  */
end_comment

begin_struct
struct|struct
name|stab_link_includes_totals
block|{
name|struct
name|stab_link_includes_totals
modifier|*
name|next
decl_stmt|;
name|bfd_vma
name|total
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* An entry in the header file hash table.  */
end_comment

begin_struct
struct|struct
name|stab_link_includes_entry
block|{
name|struct
name|bfd_hash_entry
name|root
decl_stmt|;
comment|/* List of totals we have found for this file.  */
name|struct
name|stab_link_includes_totals
modifier|*
name|totals
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Look up an entry in an the header file hash table.  */
end_comment

begin_define
define|#
directive|define
name|stab_link_includes_lookup
parameter_list|(
name|table
parameter_list|,
name|string
parameter_list|,
name|create
parameter_list|,
name|copy
parameter_list|)
define|\
value|((struct stab_link_includes_entry *) \    bfd_hash_lookup (&(table)->root, (string), (create), (copy)))
end_define

begin_comment
comment|/* This structure is used to hold a list of N_BINCL symbols, some of    which might be converted into N_EXCL symbols.  */
end_comment

begin_struct
struct|struct
name|stab_excl_list
block|{
comment|/* The next symbol to convert.  */
name|struct
name|stab_excl_list
modifier|*
name|next
decl_stmt|;
comment|/* The offset to this symbol in the section contents.  */
name|bfd_size_type
name|offset
decl_stmt|;
comment|/* The value to use for the symbol.  */
name|bfd_vma
name|val
decl_stmt|;
comment|/* The type of this symbol (N_BINCL or N_EXCL).  */
name|int
name|type
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This structure is stored with each .stab section.  */
end_comment

begin_struct
struct|struct
name|stab_section_info
block|{
comment|/* This is a linked list of N_BINCL symbols which should be      converted into N_EXCL symbols.  */
name|struct
name|stab_excl_list
modifier|*
name|excls
decl_stmt|;
comment|/* This is used to map input stab offsets within their sections      to output stab offsets, to take into account stabs that have      been deleted.  If it is NULL, the output offsets are the same      as the input offsets, because no stabs have been deleted from      this section.  Otherwise the i'th entry is the number of      bytes of stabs that have been deleted prior to the i'th      stab.  */
name|bfd_size_type
modifier|*
name|cumulative_skips
decl_stmt|;
comment|/* This is an array of string indices.  For each stab symbol, we      store the string index here.  If a stab symbol should not be      included in the final output, the string index is -1.  */
name|bfd_size_type
name|stridxs
index|[
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This structure is used to keep track of stabs in sections    information while linking.  */
end_comment

begin_struct
struct|struct
name|stab_info
block|{
comment|/* A hash table used to hold stabs strings.  */
name|struct
name|bfd_strtab_hash
modifier|*
name|strings
decl_stmt|;
comment|/* The header file hash table.  */
name|struct
name|stab_link_includes_table
name|includes
decl_stmt|;
comment|/* The first .stabstr section.  */
name|asection
modifier|*
name|stabstr
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|stab_link_includes_newfunc
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|,
expr|struct
name|bfd_hash_table
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* The function to create a new entry in the header file hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|stab_link_includes_newfunc
parameter_list|(
name|entry
parameter_list|,
name|table
parameter_list|,
name|string
parameter_list|)
name|struct
name|bfd_hash_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|bfd_hash_table
modifier|*
name|table
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|struct
name|stab_link_includes_entry
modifier|*
name|ret
init|=
operator|(
expr|struct
name|stab_link_includes_entry
operator|*
operator|)
name|entry
decl_stmt|;
comment|/* Allocate the structure if it has not already been allocated by a      subclass.  */
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|stab_link_includes_entry
operator|*
operator|)
name|NULL
condition|)
name|ret
operator|=
operator|(
operator|(
expr|struct
name|stab_link_includes_entry
operator|*
operator|)
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|stab_link_includes_entry
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|stab_link_includes_entry
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
comment|/* Call the allocation method of the superclass.  */
name|ret
operator|=
operator|(
operator|(
expr|struct
name|stab_link_includes_entry
operator|*
operator|)
name|bfd_hash_newfunc
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
comment|/* Set local fields.  */
name|ret
operator|->
name|totals
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This function is called for each input file from the add_symbols    pass of the linker.  */
end_comment

begin_function
name|boolean
name|_bfd_link_section_stabs
parameter_list|(
name|abfd
parameter_list|,
name|psinfo
parameter_list|,
name|stabsec
parameter_list|,
name|stabstrsec
parameter_list|,
name|psecinfo
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
modifier|*
name|psinfo
decl_stmt|;
name|asection
modifier|*
name|stabsec
decl_stmt|;
name|asection
modifier|*
name|stabstrsec
decl_stmt|;
name|PTR
modifier|*
name|psecinfo
decl_stmt|;
block|{
name|boolean
name|first
decl_stmt|;
name|struct
name|stab_info
modifier|*
name|sinfo
decl_stmt|;
name|bfd_size_type
name|count
decl_stmt|;
name|struct
name|stab_section_info
modifier|*
name|secinfo
decl_stmt|;
name|bfd_byte
modifier|*
name|stabbuf
init|=
name|NULL
decl_stmt|;
name|bfd_byte
modifier|*
name|stabstrbuf
init|=
name|NULL
decl_stmt|;
name|bfd_byte
modifier|*
name|sym
decl_stmt|,
modifier|*
name|symend
decl_stmt|;
name|bfd_size_type
name|stroff
decl_stmt|,
name|next_stroff
decl_stmt|,
name|skip
decl_stmt|;
name|bfd_size_type
modifier|*
name|pstridx
decl_stmt|;
if|if
condition|(
name|stabsec
operator|->
name|_raw_size
operator|==
literal|0
operator|||
name|stabstrsec
operator|->
name|_raw_size
operator|==
literal|0
condition|)
block|{
comment|/* This file does not contain stabs debugging information.  */
return|return
name|true
return|;
block|}
if|if
condition|(
name|stabsec
operator|->
name|_raw_size
operator|%
name|STABSIZE
operator|!=
literal|0
condition|)
block|{
comment|/* Something is wrong with the format of these stab symbols.          Don't try to optimize them.  */
return|return
name|true
return|;
block|}
if|if
condition|(
operator|(
name|stabstrsec
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* We shouldn't see relocations in the strings, and we aren't          prepared to handle them.  */
return|return
name|true
return|;
block|}
if|if
condition|(
operator|(
name|stabsec
operator|->
name|output_section
operator|!=
name|NULL
operator|&&
name|bfd_is_abs_section
argument_list|(
name|stabsec
operator|->
name|output_section
argument_list|)
operator|)
operator|||
operator|(
name|stabstrsec
operator|->
name|output_section
operator|!=
name|NULL
operator|&&
name|bfd_is_abs_section
argument_list|(
name|stabstrsec
operator|->
name|output_section
argument_list|)
operator|)
condition|)
block|{
comment|/* At least one of the sections is being discarded from the          link, so we should just ignore them.  */
return|return
name|true
return|;
block|}
name|first
operator|=
name|false
expr_stmt|;
if|if
condition|(
operator|*
name|psinfo
operator|==
name|NULL
condition|)
block|{
comment|/* Initialize the stabs information we need to keep track of.  */
name|first
operator|=
name|true
expr_stmt|;
operator|*
name|psinfo
operator|=
operator|(
name|PTR
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|stab_info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|psinfo
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|sinfo
operator|=
operator|(
expr|struct
name|stab_info
operator|*
operator|)
operator|*
name|psinfo
expr_stmt|;
name|sinfo
operator|->
name|strings
operator|=
name|_bfd_stringtab_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|sinfo
operator|->
name|strings
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
comment|/* Make sure the first byte is zero.  */
operator|(
name|void
operator|)
name|_bfd_stringtab_add
argument_list|(
name|sinfo
operator|->
name|strings
argument_list|,
literal|""
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_hash_table_init_n
argument_list|(
operator|&
name|sinfo
operator|->
name|includes
operator|.
name|root
argument_list|,
name|stab_link_includes_newfunc
argument_list|,
literal|251
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
name|sinfo
operator|->
name|stabstr
operator|=
name|bfd_make_section_anyway
argument_list|(
name|abfd
argument_list|,
literal|".stabstr"
argument_list|)
expr_stmt|;
name|sinfo
operator|->
name|stabstr
operator|->
name|flags
operator||=
name|SEC_HAS_CONTENTS
operator||
name|SEC_READONLY
operator||
name|SEC_DEBUGGING
expr_stmt|;
block|}
name|sinfo
operator|=
operator|(
expr|struct
name|stab_info
operator|*
operator|)
operator|*
name|psinfo
expr_stmt|;
comment|/* Initialize the information we are going to store for this .stab      section.  */
name|count
operator|=
name|stabsec
operator|->
name|_raw_size
operator|/
name|STABSIZE
expr_stmt|;
operator|*
name|psecinfo
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|stab_section_info
argument_list|)
operator|+
operator|(
name|count
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|bfd_size_type
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|psecinfo
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|secinfo
operator|=
operator|(
expr|struct
name|stab_section_info
operator|*
operator|)
operator|*
name|psecinfo
expr_stmt|;
name|secinfo
operator|->
name|excls
operator|=
name|NULL
expr_stmt|;
name|secinfo
operator|->
name|cumulative_skips
operator|=
name|NULL
expr_stmt|;
name|memset
argument_list|(
name|secinfo
operator|->
name|stridxs
argument_list|,
literal|0
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
name|bfd_size_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read the stabs information from abfd.  */
name|stabbuf
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|stabsec
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
name|stabstrbuf
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|stabstrsec
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|stabbuf
operator|==
name|NULL
operator|||
name|stabstrbuf
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|stabsec
argument_list|,
name|stabbuf
argument_list|,
literal|0
argument_list|,
name|stabsec
operator|->
name|_raw_size
argument_list|)
operator|||
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|stabstrsec
argument_list|,
name|stabstrbuf
argument_list|,
literal|0
argument_list|,
name|stabstrsec
operator|->
name|_raw_size
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* Look through the stabs symbols, work out the new string indices,      and identify N_BINCL symbols which can be eliminated.  */
name|stroff
operator|=
literal|0
expr_stmt|;
name|next_stroff
operator|=
literal|0
expr_stmt|;
name|skip
operator|=
literal|0
expr_stmt|;
name|symend
operator|=
name|stabbuf
operator|+
name|stabsec
operator|->
name|_raw_size
expr_stmt|;
for|for
control|(
name|sym
operator|=
name|stabbuf
operator|,
name|pstridx
operator|=
name|secinfo
operator|->
name|stridxs
init|;
name|sym
operator|<
name|symend
condition|;
name|sym
operator|+=
name|STABSIZE
operator|,
operator|++
name|pstridx
control|)
block|{
name|int
name|type
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
if|if
condition|(
operator|*
name|pstridx
operator|!=
literal|0
condition|)
block|{
comment|/* This symbol has already been handled by an N_BINCL pass.  */
continue|continue;
block|}
name|type
operator|=
name|sym
index|[
name|TYPEOFF
index|]
expr_stmt|;
if|if
condition|(
name|type
operator|==
literal|0
condition|)
block|{
comment|/* Special type 0 stabs indicate the offset to the next              string table.  We only copy the very first one.  */
name|stroff
operator|=
name|next_stroff
expr_stmt|;
name|next_stroff
operator|+=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|sym
operator|+
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|first
condition|)
block|{
operator|*
name|pstridx
operator|=
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
expr_stmt|;
operator|++
name|skip
expr_stmt|;
continue|continue;
block|}
name|first
operator|=
name|false
expr_stmt|;
block|}
comment|/* Store the string in the hash table, and record the index.  */
name|string
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|stabstrbuf
operator|+
name|stroff
operator|+
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|sym
operator|+
name|STRDXOFF
argument_list|)
operator|)
expr_stmt|;
operator|*
name|pstridx
operator|=
name|_bfd_stringtab_add
argument_list|(
name|sinfo
operator|->
name|strings
argument_list|,
name|string
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* An N_BINCL symbol indicates the start of the stabs entries 	 for a header file.  We need to scan ahead to the next N_EINCL 	 symbol, ignoring nesting, adding up all the characters in the 	 symbol names, not including the file numbers in types (the 	 first number after an open parenthesis).  */
if|if
condition|(
name|type
operator|==
name|N_BINCL
condition|)
block|{
name|bfd_vma
name|val
decl_stmt|;
name|int
name|nest
decl_stmt|;
name|bfd_byte
modifier|*
name|incl_sym
decl_stmt|;
name|struct
name|stab_link_includes_entry
modifier|*
name|incl_entry
decl_stmt|;
name|struct
name|stab_link_includes_totals
modifier|*
name|t
decl_stmt|;
name|struct
name|stab_excl_list
modifier|*
name|ne
decl_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
name|nest
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|incl_sym
operator|=
name|sym
operator|+
name|STABSIZE
init|;
name|incl_sym
operator|<
name|symend
condition|;
name|incl_sym
operator|+=
name|STABSIZE
control|)
block|{
name|int
name|incl_type
decl_stmt|;
name|incl_type
operator|=
name|incl_sym
index|[
name|TYPEOFF
index|]
expr_stmt|;
if|if
condition|(
name|incl_type
operator|==
literal|0
condition|)
break|break;
elseif|else
if|if
condition|(
name|incl_type
operator|==
name|N_EINCL
condition|)
block|{
if|if
condition|(
name|nest
operator|==
literal|0
condition|)
break|break;
operator|--
name|nest
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|incl_type
operator|==
name|N_BINCL
condition|)
operator|++
name|nest
expr_stmt|;
elseif|else
if|if
condition|(
name|nest
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|str
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|stabstrbuf
operator|+
name|stroff
operator|+
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|incl_sym
operator|+
name|STRDXOFF
argument_list|)
operator|)
expr_stmt|;
for|for
control|(
init|;
operator|*
name|str
operator|!=
literal|'\0'
condition|;
name|str
operator|++
control|)
block|{
name|val
operator|+=
operator|*
name|str
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|'('
condition|)
block|{
comment|/* Skip the file number.  */
operator|++
name|str
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|str
argument_list|)
condition|)
operator|++
name|str
expr_stmt|;
operator|--
name|str
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* If we have already included a header file with the same 	     value, then replaced this one with an N_EXCL symbol.  */
name|incl_entry
operator|=
name|stab_link_includes_lookup
argument_list|(
operator|&
name|sinfo
operator|->
name|includes
argument_list|,
name|string
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|incl_entry
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
for|for
control|(
name|t
operator|=
name|incl_entry
operator|->
name|totals
init|;
name|t
operator|!=
name|NULL
condition|;
name|t
operator|=
name|t
operator|->
name|next
control|)
if|if
condition|(
name|t
operator|->
name|total
operator|==
name|val
condition|)
break|break;
comment|/* Record this symbol, so that we can set the value              correctly.  */
name|ne
operator|=
operator|(
expr|struct
name|stab_excl_list
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
expr|*
name|ne
argument_list|)
expr_stmt|;
if|if
condition|(
name|ne
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|ne
operator|->
name|offset
operator|=
name|sym
operator|-
name|stabbuf
expr_stmt|;
name|ne
operator|->
name|val
operator|=
name|val
expr_stmt|;
name|ne
operator|->
name|type
operator|=
name|N_BINCL
expr_stmt|;
name|ne
operator|->
name|next
operator|=
name|secinfo
operator|->
name|excls
expr_stmt|;
name|secinfo
operator|->
name|excls
operator|=
name|ne
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
block|{
comment|/* This is the first time we have seen this header file 		 with this set of stabs strings.  */
name|t
operator|=
operator|(
operator|(
expr|struct
name|stab_link_includes_totals
operator|*
operator|)
name|bfd_hash_allocate
argument_list|(
operator|&
name|sinfo
operator|->
name|includes
operator|.
name|root
argument_list|,
sizeof|sizeof
expr|*
name|t
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|t
operator|->
name|total
operator|=
name|val
expr_stmt|;
name|t
operator|->
name|next
operator|=
name|incl_entry
operator|->
name|totals
expr_stmt|;
name|incl_entry
operator|->
name|totals
operator|=
name|t
expr_stmt|;
block|}
else|else
block|{
name|bfd_size_type
modifier|*
name|incl_pstridx
decl_stmt|;
comment|/* We have seen this header file before.  Tell the final 		 pass to change the type to N_EXCL.  */
name|ne
operator|->
name|type
operator|=
name|N_EXCL
expr_stmt|;
comment|/* Mark the skipped symbols.  */
name|nest
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|incl_sym
operator|=
name|sym
operator|+
name|STABSIZE
operator|,
name|incl_pstridx
operator|=
name|pstridx
operator|+
literal|1
init|;
name|incl_sym
operator|<
name|symend
condition|;
name|incl_sym
operator|+=
name|STABSIZE
operator|,
operator|++
name|incl_pstridx
control|)
block|{
name|int
name|incl_type
decl_stmt|;
name|incl_type
operator|=
name|incl_sym
index|[
name|TYPEOFF
index|]
expr_stmt|;
if|if
condition|(
name|incl_type
operator|==
name|N_EINCL
condition|)
block|{
if|if
condition|(
name|nest
operator|==
literal|0
condition|)
block|{
operator|*
name|incl_pstridx
operator|=
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
expr_stmt|;
operator|++
name|skip
expr_stmt|;
break|break;
block|}
operator|--
name|nest
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|incl_type
operator|==
name|N_BINCL
condition|)
operator|++
name|nest
expr_stmt|;
elseif|else
if|if
condition|(
name|nest
operator|==
literal|0
condition|)
block|{
operator|*
name|incl_pstridx
operator|=
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
expr_stmt|;
operator|++
name|skip
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
name|free
argument_list|(
name|stabbuf
argument_list|)
expr_stmt|;
name|stabbuf
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|stabstrbuf
argument_list|)
expr_stmt|;
name|stabstrbuf
operator|=
name|NULL
expr_stmt|;
comment|/* We need to set the section sizes such that the linker will      compute the output section sizes correctly.  We set the .stab      size to not include the entries we don't want.  We set      SEC_EXCLUDE for the .stabstr section, so that it will be dropped      from the link.  We record the size of the strtab in the first      .stabstr section we saw, and make sure we don't set SEC_EXCLUDE      for that section.  */
name|stabsec
operator|->
name|_cooked_size
operator|=
operator|(
name|count
operator|-
name|skip
operator|)
operator|*
name|STABSIZE
expr_stmt|;
if|if
condition|(
name|stabsec
operator|->
name|_cooked_size
operator|==
literal|0
condition|)
name|stabsec
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
name|stabstrsec
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
name|sinfo
operator|->
name|stabstr
operator|->
name|_cooked_size
operator|=
name|_bfd_stringtab_size
argument_list|(
name|sinfo
operator|->
name|strings
argument_list|)
expr_stmt|;
comment|/* Calculate the `cumulative_skips' array now that stabs have been      deleted for this section.  */
if|if
condition|(
name|skip
operator|!=
literal|0
condition|)
block|{
name|bfd_size_type
name|i
decl_stmt|,
name|offset
decl_stmt|;
name|bfd_size_type
modifier|*
name|pskips
decl_stmt|;
name|secinfo
operator|->
name|cumulative_skips
operator|=
operator|(
name|bfd_size_type
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
name|bfd_size_type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|secinfo
operator|->
name|cumulative_skips
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|pskips
operator|=
name|secinfo
operator|->
name|cumulative_skips
expr_stmt|;
name|pstridx
operator|=
name|secinfo
operator|->
name|stridxs
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|pskips
operator|++
operator|,
name|pstridx
operator|++
control|)
block|{
operator|*
name|pskips
operator|=
name|offset
expr_stmt|;
if|if
condition|(
operator|*
name|pstridx
operator|==
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
condition|)
name|offset
operator|+=
name|STABSIZE
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
name|offset
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
name|error_return
label|:
if|if
condition|(
name|stabbuf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|stabbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|stabstrbuf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|stabstrbuf
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Write out the stab section.  This is called with the relocated    contents.  */
end_comment

begin_function
name|boolean
name|_bfd_write_section_stabs
parameter_list|(
name|output_bfd
parameter_list|,
name|psinfo
parameter_list|,
name|stabsec
parameter_list|,
name|psecinfo
parameter_list|,
name|contents
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|PTR
modifier|*
name|psinfo
decl_stmt|;
name|asection
modifier|*
name|stabsec
decl_stmt|;
name|PTR
modifier|*
name|psecinfo
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
block|{
name|struct
name|stab_info
modifier|*
name|sinfo
decl_stmt|;
name|struct
name|stab_section_info
modifier|*
name|secinfo
decl_stmt|;
name|struct
name|stab_excl_list
modifier|*
name|e
decl_stmt|;
name|bfd_byte
modifier|*
name|sym
decl_stmt|,
modifier|*
name|tosym
decl_stmt|,
modifier|*
name|symend
decl_stmt|;
name|bfd_size_type
modifier|*
name|pstridx
decl_stmt|;
name|sinfo
operator|=
operator|(
expr|struct
name|stab_info
operator|*
operator|)
operator|*
name|psinfo
expr_stmt|;
name|secinfo
operator|=
operator|(
expr|struct
name|stab_section_info
operator|*
operator|)
operator|*
name|psecinfo
expr_stmt|;
if|if
condition|(
name|secinfo
operator|==
name|NULL
condition|)
return|return
name|bfd_set_section_contents
argument_list|(
name|output_bfd
argument_list|,
name|stabsec
operator|->
name|output_section
argument_list|,
name|contents
argument_list|,
name|stabsec
operator|->
name|output_offset
argument_list|,
name|stabsec
operator|->
name|_raw_size
argument_list|)
return|;
comment|/* Handle each N_BINCL entry.  */
for|for
control|(
name|e
operator|=
name|secinfo
operator|->
name|excls
init|;
name|e
operator|!=
name|NULL
condition|;
name|e
operator|=
name|e
operator|->
name|next
control|)
block|{
name|bfd_byte
modifier|*
name|excl_sym
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|e
operator|->
name|offset
operator|<
name|stabsec
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
name|excl_sym
operator|=
name|contents
operator|+
name|e
operator|->
name|offset
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|e
operator|->
name|val
argument_list|,
name|excl_sym
operator|+
name|VALOFF
argument_list|)
expr_stmt|;
name|excl_sym
index|[
name|TYPEOFF
index|]
operator|=
name|e
operator|->
name|type
expr_stmt|;
block|}
comment|/* Copy over all the stabs symbols, omitting the ones we don't want,      and correcting the string indices for those we do want.  */
name|tosym
operator|=
name|contents
expr_stmt|;
name|symend
operator|=
name|contents
operator|+
name|stabsec
operator|->
name|_raw_size
expr_stmt|;
for|for
control|(
name|sym
operator|=
name|contents
operator|,
name|pstridx
operator|=
name|secinfo
operator|->
name|stridxs
init|;
name|sym
operator|<
name|symend
condition|;
name|sym
operator|+=
name|STABSIZE
operator|,
operator|++
name|pstridx
control|)
block|{
if|if
condition|(
operator|*
name|pstridx
operator|!=
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|tosym
operator|!=
name|sym
condition|)
name|memcpy
argument_list|(
name|tosym
argument_list|,
name|sym
argument_list|,
name|STABSIZE
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|*
name|pstridx
argument_list|,
name|tosym
operator|+
name|STRDXOFF
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
index|[
name|TYPEOFF
index|]
operator|==
literal|0
condition|)
block|{
comment|/* This is the header symbol for the stabs section.  We                  don't really need one, since we have merged all the                  input stabs sections into one, but we generate one                  for the benefit of readers which expect to see one.  */
name|BFD_ASSERT
argument_list|(
name|sym
operator|==
name|contents
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|_bfd_stringtab_size
argument_list|(
name|sinfo
operator|->
name|strings
argument_list|)
argument_list|,
name|tosym
operator|+
name|VALOFF
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|output_bfd
argument_list|,
name|stabsec
operator|->
name|output_section
operator|->
name|_raw_size
operator|/
name|STABSIZE
operator|-
literal|1
argument_list|,
name|tosym
operator|+
name|DESCOFF
argument_list|)
expr_stmt|;
block|}
name|tosym
operator|+=
name|STABSIZE
expr_stmt|;
block|}
block|}
name|BFD_ASSERT
argument_list|(
call|(
name|bfd_size_type
call|)
argument_list|(
name|tosym
operator|-
name|contents
argument_list|)
operator|==
name|stabsec
operator|->
name|_cooked_size
argument_list|)
expr_stmt|;
return|return
name|bfd_set_section_contents
argument_list|(
name|output_bfd
argument_list|,
name|stabsec
operator|->
name|output_section
argument_list|,
name|contents
argument_list|,
name|stabsec
operator|->
name|output_offset
argument_list|,
name|stabsec
operator|->
name|_cooked_size
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Write out the .stabstr section.  */
end_comment

begin_function
name|boolean
name|_bfd_write_stab_strings
parameter_list|(
name|output_bfd
parameter_list|,
name|psinfo
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|PTR
modifier|*
name|psinfo
decl_stmt|;
block|{
name|struct
name|stab_info
modifier|*
name|sinfo
decl_stmt|;
name|sinfo
operator|=
operator|(
expr|struct
name|stab_info
operator|*
operator|)
operator|*
name|psinfo
expr_stmt|;
if|if
condition|(
name|sinfo
operator|==
name|NULL
condition|)
return|return
name|true
return|;
if|if
condition|(
name|bfd_is_abs_section
argument_list|(
name|sinfo
operator|->
name|stabstr
operator|->
name|output_section
argument_list|)
condition|)
block|{
comment|/* The section was discarded from the link.  */
return|return
name|true
return|;
block|}
name|BFD_ASSERT
argument_list|(
operator|(
name|sinfo
operator|->
name|stabstr
operator|->
name|output_offset
operator|+
name|_bfd_stringtab_size
argument_list|(
name|sinfo
operator|->
name|strings
argument_list|)
operator|)
operator|<=
name|sinfo
operator|->
name|stabstr
operator|->
name|output_section
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|sinfo
operator|->
name|stabstr
operator|->
name|output_section
operator|->
name|filepos
operator|+
name|sinfo
operator|->
name|stabstr
operator|->
name|output_offset
operator|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|_bfd_stringtab_emit
argument_list|(
name|output_bfd
argument_list|,
name|sinfo
operator|->
name|strings
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* We no longer need the stabs information.  */
name|_bfd_stringtab_free
argument_list|(
name|sinfo
operator|->
name|strings
argument_list|)
expr_stmt|;
name|bfd_hash_table_free
argument_list|(
operator|&
name|sinfo
operator|->
name|includes
operator|.
name|root
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Adjust an address in the .stab section.  Given OFFSET within    STABSEC, this returns the new offset in the adjusted stab section,    or -1 if the address refers to a stab which has been removed.  */
end_comment

begin_function
name|bfd_vma
name|_bfd_stab_section_offset
parameter_list|(
name|output_bfd
parameter_list|,
name|psinfo
parameter_list|,
name|stabsec
parameter_list|,
name|psecinfo
parameter_list|,
name|offset
parameter_list|)
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|PTR
modifier|*
name|psinfo
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|stabsec
decl_stmt|;
name|PTR
modifier|*
name|psecinfo
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
block|{
name|struct
name|stab_section_info
modifier|*
name|secinfo
decl_stmt|;
name|secinfo
operator|=
operator|(
expr|struct
name|stab_section_info
operator|*
operator|)
operator|*
name|psecinfo
expr_stmt|;
if|if
condition|(
name|secinfo
operator|==
name|NULL
condition|)
return|return
name|offset
return|;
if|if
condition|(
name|offset
operator|>=
name|stabsec
operator|->
name|_raw_size
condition|)
return|return
name|offset
operator|-
operator|(
name|stabsec
operator|->
name|_cooked_size
operator|-
name|stabsec
operator|->
name|_raw_size
operator|)
return|;
if|if
condition|(
name|secinfo
operator|->
name|cumulative_skips
condition|)
block|{
name|bfd_vma
name|i
decl_stmt|;
name|i
operator|=
name|offset
operator|/
name|STABSIZE
expr_stmt|;
if|if
condition|(
name|secinfo
operator|->
name|stridxs
index|[
name|i
index|]
operator|==
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
condition|)
return|return
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
return|;
return|return
name|offset
operator|-
name|secinfo
operator|->
name|cumulative_skips
index|[
name|i
index|]
return|;
block|}
return|return
name|offset
return|;
block|}
end_function

end_unit

