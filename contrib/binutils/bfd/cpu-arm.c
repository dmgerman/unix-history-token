begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD support for the ARM processor    Copyright 1994, 1997, 1999, 2000, 2002, 2003, 2004, 2005    Free Software Foundation, Inc.    Contributed by Richard Earnshaw (rwe@pegasus.esprit.ec.org)     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_comment
comment|/* This routine is provided two arch_infos and works out which ARM    machine which would be compatible with both and returns a pointer    to its info structure.  */
end_comment

begin_function
specifier|static
specifier|const
name|bfd_arch_info_type
modifier|*
name|compatible
parameter_list|(
specifier|const
name|bfd_arch_info_type
modifier|*
name|a
parameter_list|,
specifier|const
name|bfd_arch_info_type
modifier|*
name|b
parameter_list|)
block|{
comment|/* If a& b are for different architecture we can do nothing.  */
if|if
condition|(
name|a
operator|->
name|arch
operator|!=
name|b
operator|->
name|arch
condition|)
return|return
name|NULL
return|;
comment|/* If a& b are for the same machine then all is well.  */
if|if
condition|(
name|a
operator|->
name|mach
operator|==
name|b
operator|->
name|mach
condition|)
return|return
name|a
return|;
comment|/* Otherwise if either a or b is the 'default' machine      then it can be polymorphed into the other.  */
if|if
condition|(
name|a
operator|->
name|the_default
condition|)
return|return
name|b
return|;
if|if
condition|(
name|b
operator|->
name|the_default
condition|)
return|return
name|a
return|;
comment|/* So far all newer ARM architecture cores are      supersets of previous cores.  */
if|if
condition|(
name|a
operator|->
name|mach
operator|<
name|b
operator|->
name|mach
condition|)
return|return
name|b
return|;
elseif|else
if|if
condition|(
name|a
operator|->
name|mach
operator|>
name|b
operator|->
name|mach
condition|)
return|return
name|a
return|;
comment|/* Never reached!  */
return|return
name|NULL
return|;
block|}
end_function

begin_struct
specifier|static
struct|struct
block|{
name|unsigned
name|int
name|mach
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|processors
index|[]
init|=
block|{
block|{
name|bfd_mach_arm_2
block|,
literal|"arm2"
block|}
block|,
block|{
name|bfd_mach_arm_2a
block|,
literal|"arm250"
block|}
block|,
block|{
name|bfd_mach_arm_2a
block|,
literal|"arm3"
block|}
block|,
block|{
name|bfd_mach_arm_3
block|,
literal|"arm6"
block|}
block|,
block|{
name|bfd_mach_arm_3
block|,
literal|"arm60"
block|}
block|,
block|{
name|bfd_mach_arm_3
block|,
literal|"arm600"
block|}
block|,
block|{
name|bfd_mach_arm_3
block|,
literal|"arm610"
block|}
block|,
block|{
name|bfd_mach_arm_3
block|,
literal|"arm7"
block|}
block|,
block|{
name|bfd_mach_arm_3
block|,
literal|"arm710"
block|}
block|,
block|{
name|bfd_mach_arm_3
block|,
literal|"arm7500"
block|}
block|,
block|{
name|bfd_mach_arm_3
block|,
literal|"arm7d"
block|}
block|,
block|{
name|bfd_mach_arm_3
block|,
literal|"arm7di"
block|}
block|,
block|{
name|bfd_mach_arm_3M
block|,
literal|"arm7dm"
block|}
block|,
block|{
name|bfd_mach_arm_3M
block|,
literal|"arm7dmi"
block|}
block|,
block|{
name|bfd_mach_arm_4T
block|,
literal|"arm7tdmi"
block|}
block|,
block|{
name|bfd_mach_arm_4
block|,
literal|"arm8"
block|}
block|,
block|{
name|bfd_mach_arm_4
block|,
literal|"arm810"
block|}
block|,
block|{
name|bfd_mach_arm_4
block|,
literal|"arm9"
block|}
block|,
block|{
name|bfd_mach_arm_4
block|,
literal|"arm920"
block|}
block|,
block|{
name|bfd_mach_arm_4T
block|,
literal|"arm920t"
block|}
block|,
block|{
name|bfd_mach_arm_4T
block|,
literal|"arm9tdmi"
block|}
block|,
block|{
name|bfd_mach_arm_4
block|,
literal|"sa1"
block|}
block|,
block|{
name|bfd_mach_arm_4
block|,
literal|"strongarm"
block|}
block|,
block|{
name|bfd_mach_arm_4
block|,
literal|"strongarm110"
block|}
block|,
block|{
name|bfd_mach_arm_4
block|,
literal|"strongarm1100"
block|}
block|,
block|{
name|bfd_mach_arm_XScale
block|,
literal|"xscale"
block|}
block|,
block|{
name|bfd_mach_arm_ep9312
block|,
literal|"ep9312"
block|}
block|,
block|{
name|bfd_mach_arm_iWMMXt
block|,
literal|"iwmmxt"
block|}
block|}
struct|;
end_struct

begin_function
specifier|static
name|bfd_boolean
name|scan
parameter_list|(
specifier|const
name|struct
name|bfd_arch_info
modifier|*
name|info
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* First test for an exact match.  */
if|if
condition|(
name|strcasecmp
argument_list|(
name|string
argument_list|,
name|info
operator|->
name|printable_name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
comment|/* Next check for a processor name instead of an Architecture name.  */
for|for
control|(
name|i
operator|=
sizeof|sizeof
argument_list|(
name|processors
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|processors
index|[
literal|0
index|]
argument_list|)
init|;
name|i
operator|--
condition|;
control|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|string
argument_list|,
name|processors
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|!=
operator|-
literal|1
operator|&&
name|info
operator|->
name|mach
operator|==
name|processors
index|[
name|i
index|]
operator|.
name|mach
condition|)
return|return
name|TRUE
return|;
comment|/* Finally check for the default architecture.  */
if|if
condition|(
name|strcasecmp
argument_list|(
name|string
argument_list|,
literal|"arm"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|info
operator|->
name|the_default
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_define
define|#
directive|define
name|N
parameter_list|(
name|number
parameter_list|,
name|print
parameter_list|,
define|default, next)  \ {  32, 32, 8, bfd_arch_arm, number, "arm", print, 4, default, compatible, scan, next }
end_define

begin_decl_stmt
specifier|static
specifier|const
name|bfd_arch_info_type
name|arch_info_struct
index|[]
init|=
block|{
name|N
argument_list|(
name|bfd_mach_arm_2
argument_list|,
literal|"armv2"
argument_list|,
name|FALSE
argument_list|,
operator|&
name|arch_info_struct
index|[
literal|1
index|]
argument_list|)
block|,
name|N
argument_list|(
name|bfd_mach_arm_2a
argument_list|,
literal|"armv2a"
argument_list|,
name|FALSE
argument_list|,
operator|&
name|arch_info_struct
index|[
literal|2
index|]
argument_list|)
block|,
name|N
argument_list|(
name|bfd_mach_arm_3
argument_list|,
literal|"armv3"
argument_list|,
name|FALSE
argument_list|,
operator|&
name|arch_info_struct
index|[
literal|3
index|]
argument_list|)
block|,
name|N
argument_list|(
name|bfd_mach_arm_3M
argument_list|,
literal|"armv3m"
argument_list|,
name|FALSE
argument_list|,
operator|&
name|arch_info_struct
index|[
literal|4
index|]
argument_list|)
block|,
name|N
argument_list|(
name|bfd_mach_arm_4
argument_list|,
literal|"armv4"
argument_list|,
name|FALSE
argument_list|,
operator|&
name|arch_info_struct
index|[
literal|5
index|]
argument_list|)
block|,
name|N
argument_list|(
name|bfd_mach_arm_4T
argument_list|,
literal|"armv4t"
argument_list|,
name|FALSE
argument_list|,
operator|&
name|arch_info_struct
index|[
literal|6
index|]
argument_list|)
block|,
name|N
argument_list|(
name|bfd_mach_arm_5
argument_list|,
literal|"armv5"
argument_list|,
name|FALSE
argument_list|,
operator|&
name|arch_info_struct
index|[
literal|7
index|]
argument_list|)
block|,
name|N
argument_list|(
name|bfd_mach_arm_5T
argument_list|,
literal|"armv5t"
argument_list|,
name|FALSE
argument_list|,
operator|&
name|arch_info_struct
index|[
literal|8
index|]
argument_list|)
block|,
name|N
argument_list|(
name|bfd_mach_arm_5TE
argument_list|,
literal|"armv5te"
argument_list|,
name|FALSE
argument_list|,
operator|&
name|arch_info_struct
index|[
literal|9
index|]
argument_list|)
block|,
name|N
argument_list|(
name|bfd_mach_arm_XScale
argument_list|,
literal|"xscale"
argument_list|,
name|FALSE
argument_list|,
operator|&
name|arch_info_struct
index|[
literal|10
index|]
argument_list|)
block|,
name|N
argument_list|(
name|bfd_mach_arm_ep9312
argument_list|,
literal|"ep9312"
argument_list|,
name|FALSE
argument_list|,
operator|&
name|arch_info_struct
index|[
literal|11
index|]
argument_list|)
block|,
name|N
argument_list|(
argument|bfd_mach_arm_iWMMXt
argument_list|,
literal|"iwmmxt"
argument_list|,
argument|FALSE
argument_list|,
argument|NULL
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|bfd_arch_info_type
name|bfd_arm_arch
init|=
name|N
argument_list|(
literal|0
argument_list|,
literal|"arm"
argument_list|,
name|TRUE
argument_list|,
operator|&
name|arch_info_struct
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Support functions used by both the COFF and ELF versions of the ARM port.  */
end_comment

begin_comment
comment|/* Handle the merging of the 'machine' settings of input file IBFD    and an output file OBFD.  These values actually represent the    different possible ARM architecture variants.    Returns TRUE if they were merged successfully or FALSE otherwise.  */
end_comment

begin_function
name|bfd_boolean
name|bfd_arm_merge_machines
parameter_list|(
name|bfd
modifier|*
name|ibfd
parameter_list|,
name|bfd
modifier|*
name|obfd
parameter_list|)
block|{
name|unsigned
name|int
name|in
init|=
name|bfd_get_mach
argument_list|(
name|ibfd
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|out
init|=
name|bfd_get_mach
argument_list|(
name|obfd
argument_list|)
decl_stmt|;
comment|/* If the output architecture is unknown, we now have a value to set.  */
if|if
condition|(
name|out
operator|==
name|bfd_mach_arm_unknown
condition|)
name|bfd_set_arch_mach
argument_list|(
name|obfd
argument_list|,
name|bfd_arch_arm
argument_list|,
name|in
argument_list|)
expr_stmt|;
comment|/* If the input architecture is unknown,      then so must be the output architecture.  */
elseif|else
if|if
condition|(
name|in
operator|==
name|bfd_mach_arm_unknown
condition|)
comment|/* FIXME: We ought to have some way to        override this on the command line.  */
name|bfd_set_arch_mach
argument_list|(
name|obfd
argument_list|,
name|bfd_arch_arm
argument_list|,
name|bfd_mach_arm_unknown
argument_list|)
expr_stmt|;
comment|/* If they are the same then nothing needs to be done.  */
elseif|else
if|if
condition|(
name|out
operator|==
name|in
condition|)
empty_stmt|;
comment|/* Otherwise the general principle that a earlier architecture can be      linked with a later architecture to produce a binary that will execute      on the later architecture.       We fail however if we attempt to link a Cirrus EP9312 binary with an      Intel XScale binary, since these architecture have co-processors which      will not both be present on the same physical hardware.  */
elseif|else
if|if
condition|(
name|in
operator|==
name|bfd_mach_arm_ep9312
operator|&&
operator|(
name|out
operator|==
name|bfd_mach_arm_XScale
operator|||
name|out
operator|==
name|bfd_mach_arm_iWMMXt
operator|)
condition|)
block|{
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"\ ERROR: %B is compiled for the EP9312, whereas %B is compiled for XScale"
argument_list|)
argument_list|,
name|ibfd
argument_list|,
name|obfd
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
elseif|else
if|if
condition|(
name|out
operator|==
name|bfd_mach_arm_ep9312
operator|&&
operator|(
name|in
operator|==
name|bfd_mach_arm_XScale
operator|||
name|in
operator|==
name|bfd_mach_arm_iWMMXt
operator|)
condition|)
block|{
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"\ ERROR: %B is compiled for the EP9312, whereas %B is compiled for XScale"
argument_list|)
argument_list|,
name|obfd
argument_list|,
name|ibfd
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
elseif|else
if|if
condition|(
name|in
operator|>
name|out
condition|)
name|bfd_set_arch_mach
argument_list|(
name|obfd
argument_list|,
name|bfd_arch_arm
argument_list|,
name|in
argument_list|)
expr_stmt|;
comment|/* else      Nothing to do.  */
return|return
name|TRUE
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
block|{
name|unsigned
name|char
name|namesz
index|[
literal|4
index|]
decl_stmt|;
comment|/* Size of entry's owner string.  */
name|unsigned
name|char
name|descsz
index|[
literal|4
index|]
decl_stmt|;
comment|/* Size of the note descriptor.  */
name|unsigned
name|char
name|type
index|[
literal|4
index|]
decl_stmt|;
comment|/* Interpretation of the descriptor.  */
name|char
name|name
index|[
literal|1
index|]
decl_stmt|;
comment|/* Start of the name+desc data.  */
block|}
name|arm_Note
typedef|;
end_typedef

begin_function
specifier|static
name|bfd_boolean
name|arm_check_note
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_byte
modifier|*
name|buffer
parameter_list|,
name|bfd_size_type
name|buffer_size
parameter_list|,
specifier|const
name|char
modifier|*
name|expected_name
parameter_list|,
name|char
modifier|*
modifier|*
name|description_return
parameter_list|)
block|{
name|unsigned
name|long
name|namesz
decl_stmt|;
name|unsigned
name|long
name|descsz
decl_stmt|;
name|unsigned
name|long
name|type
decl_stmt|;
name|char
modifier|*
name|descr
decl_stmt|;
if|if
condition|(
name|buffer_size
operator|<
name|offsetof
argument_list|(
name|arm_Note
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* We have to extract the values this way to allow for a      host whose endian-ness is different from the target.  */
name|namesz
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|descsz
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|buffer
operator|+
name|offsetof
argument_list|(
name|arm_Note
argument_list|,
name|descsz
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|buffer
operator|+
name|offsetof
argument_list|(
name|arm_Note
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|descr
operator|=
operator|(
name|char
operator|*
operator|)
name|buffer
operator|+
name|offsetof
argument_list|(
name|arm_Note
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Check for buffer overflow.  */
if|if
condition|(
name|namesz
operator|+
name|descsz
operator|+
name|offsetof
argument_list|(
name|arm_Note
argument_list|,
name|name
argument_list|)
operator|>
name|buffer_size
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|expected_name
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|namesz
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
block|}
else|else
block|{
if|if
condition|(
name|namesz
operator|!=
operator|(
operator|(
name|strlen
argument_list|(
name|expected_name
argument_list|)
operator|+
literal|1
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
operator|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|descr
argument_list|,
name|expected_name
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
name|descr
operator|+=
operator|(
name|namesz
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
block|}
comment|/* FIXME: We should probably check the type as well.  */
if|if
condition|(
name|description_return
operator|!=
name|NULL
condition|)
operator|*
name|description_return
operator|=
name|descr
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_define
define|#
directive|define
name|NOTE_ARCH_STRING
value|"arch: "
end_define

begin_function
name|bfd_boolean
name|bfd_arm_update_notes
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|char
modifier|*
name|note_section
parameter_list|)
block|{
name|asection
modifier|*
name|arm_arch_section
decl_stmt|;
name|bfd_size_type
name|buffer_size
decl_stmt|;
name|bfd_byte
modifier|*
name|buffer
decl_stmt|;
name|char
modifier|*
name|arch_string
decl_stmt|;
name|char
modifier|*
name|expected
decl_stmt|;
comment|/* Look for a note section.  If one is present check the architecture      string encoded in it, and set it to the current architecture if it is      different.  */
name|arm_arch_section
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|note_section
argument_list|)
expr_stmt|;
if|if
condition|(
name|arm_arch_section
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
name|buffer_size
operator|=
name|arm_arch_section
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|buffer_size
operator|==
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|bfd_malloc_and_get_section
argument_list|(
name|abfd
argument_list|,
name|arm_arch_section
argument_list|,
operator|&
name|buffer
argument_list|)
condition|)
goto|goto
name|FAIL
goto|;
comment|/* Parse the note.  */
if|if
condition|(
operator|!
name|arm_check_note
argument_list|(
name|abfd
argument_list|,
name|buffer
argument_list|,
name|buffer_size
argument_list|,
name|NOTE_ARCH_STRING
argument_list|,
operator|&
name|arch_string
argument_list|)
condition|)
goto|goto
name|FAIL
goto|;
comment|/* Check the architecture in the note against the architecture of the bfd.  */
switch|switch
condition|(
name|bfd_get_mach
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
default|default:
case|case
name|bfd_mach_arm_unknown
case|:
name|expected
operator|=
literal|"unknown"
expr_stmt|;
break|break;
case|case
name|bfd_mach_arm_2
case|:
name|expected
operator|=
literal|"armv2"
expr_stmt|;
break|break;
case|case
name|bfd_mach_arm_2a
case|:
name|expected
operator|=
literal|"armv2a"
expr_stmt|;
break|break;
case|case
name|bfd_mach_arm_3
case|:
name|expected
operator|=
literal|"armv3"
expr_stmt|;
break|break;
case|case
name|bfd_mach_arm_3M
case|:
name|expected
operator|=
literal|"armv3M"
expr_stmt|;
break|break;
case|case
name|bfd_mach_arm_4
case|:
name|expected
operator|=
literal|"armv4"
expr_stmt|;
break|break;
case|case
name|bfd_mach_arm_4T
case|:
name|expected
operator|=
literal|"armv4t"
expr_stmt|;
break|break;
case|case
name|bfd_mach_arm_5
case|:
name|expected
operator|=
literal|"armv5"
expr_stmt|;
break|break;
case|case
name|bfd_mach_arm_5T
case|:
name|expected
operator|=
literal|"armv5t"
expr_stmt|;
break|break;
case|case
name|bfd_mach_arm_5TE
case|:
name|expected
operator|=
literal|"armv5te"
expr_stmt|;
break|break;
case|case
name|bfd_mach_arm_XScale
case|:
name|expected
operator|=
literal|"XScale"
expr_stmt|;
break|break;
case|case
name|bfd_mach_arm_ep9312
case|:
name|expected
operator|=
literal|"ep9312"
expr_stmt|;
break|break;
case|case
name|bfd_mach_arm_iWMMXt
case|:
name|expected
operator|=
literal|"iWMMXt"
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|arch_string
argument_list|,
name|expected
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buffer
operator|+
operator|(
name|offsetof
argument_list|(
name|arm_Note
argument_list|,
name|name
argument_list|)
operator|+
operator|(
operator|(
name|strlen
argument_list|(
name|NOTE_ARCH_STRING
argument_list|)
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
operator|)
operator|)
argument_list|,
name|expected
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|arm_arch_section
argument_list|,
name|buffer
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|buffer_size
argument_list|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"warning: unable to update contents of %s section in %s"
argument_list|)
argument_list|,
name|note_section
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|FAIL
goto|;
block|}
block|}
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
name|FAIL
label|:
if|if
condition|(
name|buffer
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_struct
specifier|static
struct|struct
block|{
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
name|unsigned
name|int
name|mach
decl_stmt|;
block|}
name|architectures
index|[]
init|=
block|{
block|{
literal|"armv2"
block|,
name|bfd_mach_arm_2
block|}
block|,
block|{
literal|"armv2a"
block|,
name|bfd_mach_arm_2a
block|}
block|,
block|{
literal|"armv3"
block|,
name|bfd_mach_arm_3
block|}
block|,
block|{
literal|"armv3M"
block|,
name|bfd_mach_arm_3M
block|}
block|,
block|{
literal|"armv4"
block|,
name|bfd_mach_arm_4
block|}
block|,
block|{
literal|"armv4t"
block|,
name|bfd_mach_arm_4T
block|}
block|,
block|{
literal|"armv5"
block|,
name|bfd_mach_arm_5
block|}
block|,
block|{
literal|"armv5t"
block|,
name|bfd_mach_arm_5T
block|}
block|,
block|{
literal|"armv5te"
block|,
name|bfd_mach_arm_5TE
block|}
block|,
block|{
literal|"XScale"
block|,
name|bfd_mach_arm_XScale
block|}
block|,
block|{
literal|"ep9312"
block|,
name|bfd_mach_arm_ep9312
block|}
block|,
block|{
literal|"iWMMXt"
block|,
name|bfd_mach_arm_iWMMXt
block|}
block|}
struct|;
end_struct

begin_comment
comment|/* Extract the machine number stored in a note section.  */
end_comment

begin_function
name|unsigned
name|int
name|bfd_arm_get_mach_from_notes
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|char
modifier|*
name|note_section
parameter_list|)
block|{
name|asection
modifier|*
name|arm_arch_section
decl_stmt|;
name|bfd_size_type
name|buffer_size
decl_stmt|;
name|bfd_byte
modifier|*
name|buffer
decl_stmt|;
name|char
modifier|*
name|arch_string
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Look for a note section.  If one is present check the architecture      string encoded in it, and set it to the current architecture if it is      different.  */
name|arm_arch_section
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|note_section
argument_list|)
expr_stmt|;
if|if
condition|(
name|arm_arch_section
operator|==
name|NULL
condition|)
return|return
name|bfd_mach_arm_unknown
return|;
name|buffer_size
operator|=
name|arm_arch_section
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|buffer_size
operator|==
literal|0
condition|)
return|return
name|bfd_mach_arm_unknown
return|;
if|if
condition|(
operator|!
name|bfd_malloc_and_get_section
argument_list|(
name|abfd
argument_list|,
name|arm_arch_section
argument_list|,
operator|&
name|buffer
argument_list|)
condition|)
goto|goto
name|FAIL
goto|;
comment|/* Parse the note.  */
if|if
condition|(
operator|!
name|arm_check_note
argument_list|(
name|abfd
argument_list|,
name|buffer
argument_list|,
name|buffer_size
argument_list|,
name|NOTE_ARCH_STRING
argument_list|,
operator|&
name|arch_string
argument_list|)
condition|)
goto|goto
name|FAIL
goto|;
comment|/* Interpret the architecture string.  */
for|for
control|(
name|i
operator|=
name|ARRAY_SIZE
argument_list|(
name|architectures
argument_list|)
init|;
name|i
operator|--
condition|;
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|arch_string
argument_list|,
name|architectures
index|[
name|i
index|]
operator|.
name|string
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
name|architectures
index|[
name|i
index|]
operator|.
name|mach
return|;
block|}
name|FAIL
label|:
if|if
condition|(
name|buffer
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
name|bfd_mach_arm_unknown
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|bfd_is_arm_mapping_symbol_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
comment|/* The ARM compiler outputs several obsolete forms.  Recognize them      in addition to the standard $a, $t and $d.  */
return|return
operator|(
name|name
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|name
index|[
literal|0
index|]
operator|==
literal|'$'
operator|)
operator|&&
operator|(
operator|(
name|name
index|[
literal|1
index|]
operator|==
literal|'a'
operator|)
operator|||
operator|(
name|name
index|[
literal|1
index|]
operator|==
literal|'t'
operator|)
operator|||
operator|(
name|name
index|[
literal|1
index|]
operator|==
literal|'d'
operator|)
operator|||
operator|(
name|name
index|[
literal|1
index|]
operator|==
literal|'m'
operator|)
operator|||
operator|(
name|name
index|[
literal|1
index|]
operator|==
literal|'f'
operator|)
operator|||
operator|(
name|name
index|[
literal|1
index|]
operator|==
literal|'p'
operator|)
operator|)
operator|&&
operator|(
name|name
index|[
literal|2
index|]
operator|==
literal|0
operator|||
name|name
index|[
literal|2
index|]
operator|==
literal|'.'
operator|)
return|;
block|}
end_function

end_unit

