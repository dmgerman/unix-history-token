begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* .eh_frame section optimization.    Copyright 2001, 2002, 2003, 2004, 2005, 2006, 2007    Free Software Foundation, Inc.    Written by Jakub Jelinek<jakub@redhat.com>.     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf/dwarf2.h"
end_include

begin_define
define|#
directive|define
name|EH_FRAME_HDR_SIZE
value|8
end_define

begin_struct
struct|struct
name|cie
block|{
name|unsigned
name|int
name|length
decl_stmt|;
name|unsigned
name|int
name|hash
decl_stmt|;
name|unsigned
name|char
name|version
decl_stmt|;
name|unsigned
name|char
name|local_personality
decl_stmt|;
name|char
name|augmentation
index|[
literal|20
index|]
decl_stmt|;
name|bfd_vma
name|code_align
decl_stmt|;
name|bfd_signed_vma
name|data_align
decl_stmt|;
name|bfd_vma
name|ra_column
decl_stmt|;
name|bfd_vma
name|augmentation_size
decl_stmt|;
union|union
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
block|}
name|personality
union|;
name|asection
modifier|*
name|output_sec
decl_stmt|;
name|struct
name|eh_cie_fde
modifier|*
name|cie_inf
decl_stmt|;
name|unsigned
name|char
name|per_encoding
decl_stmt|;
name|unsigned
name|char
name|lsda_encoding
decl_stmt|;
name|unsigned
name|char
name|fde_encoding
decl_stmt|;
name|unsigned
name|char
name|initial_insn_length
decl_stmt|;
name|unsigned
name|char
name|make_relative
decl_stmt|;
name|unsigned
name|char
name|make_lsda_relative
decl_stmt|;
name|unsigned
name|char
name|initial_instructions
index|[
literal|50
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* If *ITER hasn't reached END yet, read the next byte into *RESULT and    move onto the next byte.  Return true on success.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bfd_boolean
name|read_byte
parameter_list|(
name|bfd_byte
modifier|*
modifier|*
name|iter
parameter_list|,
name|bfd_byte
modifier|*
name|end
parameter_list|,
name|unsigned
name|char
modifier|*
name|result
parameter_list|)
block|{
if|if
condition|(
operator|*
name|iter
operator|>=
name|end
condition|)
return|return
name|FALSE
return|;
operator|*
name|result
operator|=
operator|*
operator|(
operator|(
operator|*
name|iter
operator|)
operator|++
operator|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Move *ITER over LENGTH bytes, or up to END, whichever is closer.    Return true it was possible to move LENGTH bytes.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bfd_boolean
name|skip_bytes
parameter_list|(
name|bfd_byte
modifier|*
modifier|*
name|iter
parameter_list|,
name|bfd_byte
modifier|*
name|end
parameter_list|,
name|bfd_size_type
name|length
parameter_list|)
block|{
if|if
condition|(
call|(
name|bfd_size_type
call|)
argument_list|(
name|end
operator|-
operator|*
name|iter
argument_list|)
operator|<
name|length
condition|)
block|{
operator|*
name|iter
operator|=
name|end
expr_stmt|;
return|return
name|FALSE
return|;
block|}
operator|*
name|iter
operator|+=
name|length
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Move *ITER over an leb128, stopping at END.  Return true if the end    of the leb128 was found.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|skip_leb128
parameter_list|(
name|bfd_byte
modifier|*
modifier|*
name|iter
parameter_list|,
name|bfd_byte
modifier|*
name|end
parameter_list|)
block|{
name|unsigned
name|char
name|byte
decl_stmt|;
do|do
if|if
condition|(
operator|!
name|read_byte
argument_list|(
name|iter
argument_list|,
name|end
argument_list|,
operator|&
name|byte
argument_list|)
condition|)
return|return
name|FALSE
return|;
do|while
condition|(
name|byte
operator|&
literal|0x80
condition|)
do|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Like skip_leb128, but treat the leb128 as an unsigned value and    store it in *VALUE.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|read_uleb128
parameter_list|(
name|bfd_byte
modifier|*
modifier|*
name|iter
parameter_list|,
name|bfd_byte
modifier|*
name|end
parameter_list|,
name|bfd_vma
modifier|*
name|value
parameter_list|)
block|{
name|bfd_byte
modifier|*
name|start
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|start
operator|=
operator|*
name|iter
expr_stmt|;
if|if
condition|(
operator|!
name|skip_leb128
argument_list|(
name|iter
argument_list|,
name|end
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|p
operator|=
operator|*
name|iter
expr_stmt|;
operator|*
name|value
operator|=
operator|*
operator|--
name|p
expr_stmt|;
while|while
condition|(
name|p
operator|>
name|start
condition|)
operator|*
name|value
operator|=
operator|(
operator|*
name|value
operator|<<
literal|7
operator|)
operator||
operator|(
operator|*
operator|--
name|p
operator|&
literal|0x7f
operator|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Like read_uleb128, but for signed values.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|read_sleb128
parameter_list|(
name|bfd_byte
modifier|*
modifier|*
name|iter
parameter_list|,
name|bfd_byte
modifier|*
name|end
parameter_list|,
name|bfd_signed_vma
modifier|*
name|value
parameter_list|)
block|{
name|bfd_byte
modifier|*
name|start
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|start
operator|=
operator|*
name|iter
expr_stmt|;
if|if
condition|(
operator|!
name|skip_leb128
argument_list|(
name|iter
argument_list|,
name|end
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|p
operator|=
operator|*
name|iter
expr_stmt|;
operator|*
name|value
operator|=
operator|(
operator|(
operator|*
operator|--
name|p
operator|&
literal|0x7f
operator|)
operator|^
literal|0x40
operator|)
operator|-
literal|0x40
expr_stmt|;
while|while
condition|(
name|p
operator|>
name|start
condition|)
operator|*
name|value
operator|=
operator|(
operator|*
name|value
operator|<<
literal|7
operator|)
operator||
operator|(
operator|*
operator|--
name|p
operator|&
literal|0x7f
operator|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return 0 if either encoding is variable width, or not yet known to bfd.  */
end_comment

begin_function
specifier|static
name|int
name|get_DW_EH_PE_width
parameter_list|(
name|int
name|encoding
parameter_list|,
name|int
name|ptr_size
parameter_list|)
block|{
comment|/* DW_EH_PE_ values of 0x60 and 0x70 weren't defined at the time .eh_frame      was added to bfd.  */
if|if
condition|(
operator|(
name|encoding
operator|&
literal|0x60
operator|)
operator|==
literal|0x60
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|encoding
operator|&
literal|7
condition|)
block|{
case|case
name|DW_EH_PE_udata2
case|:
return|return
literal|2
return|;
case|case
name|DW_EH_PE_udata4
case|:
return|return
literal|4
return|;
case|case
name|DW_EH_PE_udata8
case|:
return|return
literal|8
return|;
case|case
name|DW_EH_PE_absptr
case|:
return|return
name|ptr_size
return|;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|get_DW_EH_PE_signed
parameter_list|(
name|encoding
parameter_list|)
value|(((encoding)& DW_EH_PE_signed) != 0)
end_define

begin_comment
comment|/* Read a width sized value from memory.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|read_value
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_byte
modifier|*
name|buf
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|is_signed
parameter_list|)
block|{
name|bfd_vma
name|value
decl_stmt|;
switch|switch
condition|(
name|width
condition|)
block|{
case|case
literal|2
case|:
if|if
condition|(
name|is_signed
condition|)
name|value
operator|=
name|bfd_get_signed_16
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|)
expr_stmt|;
else|else
name|value
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
if|if
condition|(
name|is_signed
condition|)
name|value
operator|=
name|bfd_get_signed_32
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|)
expr_stmt|;
else|else
name|value
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
if|if
condition|(
name|is_signed
condition|)
name|value
operator|=
name|bfd_get_signed_64
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|)
expr_stmt|;
else|else
name|value
operator|=
name|bfd_get_64
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
default|default:
name|BFD_FAIL
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* Store a width sized value to memory.  */
end_comment

begin_function
specifier|static
name|void
name|write_value
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_byte
modifier|*
name|buf
parameter_list|,
name|bfd_vma
name|value
parameter_list|,
name|int
name|width
parameter_list|)
block|{
switch|switch
condition|(
name|width
condition|)
block|{
case|case
literal|2
case|:
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|value
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|value
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|bfd_put_64
argument_list|(
name|abfd
argument_list|,
name|value
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
default|default:
name|BFD_FAIL
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return one if C1 and C2 CIEs can be merged.  */
end_comment

begin_function
specifier|static
name|int
name|cie_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|e1
parameter_list|,
specifier|const
name|void
modifier|*
name|e2
parameter_list|)
block|{
specifier|const
name|struct
name|cie
modifier|*
name|c1
init|=
name|e1
decl_stmt|;
specifier|const
name|struct
name|cie
modifier|*
name|c2
init|=
name|e2
decl_stmt|;
if|if
condition|(
name|c1
operator|->
name|hash
operator|==
name|c2
operator|->
name|hash
operator|&&
name|c1
operator|->
name|length
operator|==
name|c2
operator|->
name|length
operator|&&
name|c1
operator|->
name|version
operator|==
name|c2
operator|->
name|version
operator|&&
name|c1
operator|->
name|local_personality
operator|==
name|c2
operator|->
name|local_personality
operator|&&
name|strcmp
argument_list|(
name|c1
operator|->
name|augmentation
argument_list|,
name|c2
operator|->
name|augmentation
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|c1
operator|->
name|augmentation
argument_list|,
literal|"eh"
argument_list|)
operator|!=
literal|0
operator|&&
name|c1
operator|->
name|code_align
operator|==
name|c2
operator|->
name|code_align
operator|&&
name|c1
operator|->
name|data_align
operator|==
name|c2
operator|->
name|data_align
operator|&&
name|c1
operator|->
name|ra_column
operator|==
name|c2
operator|->
name|ra_column
operator|&&
name|c1
operator|->
name|augmentation_size
operator|==
name|c2
operator|->
name|augmentation_size
operator|&&
name|memcmp
argument_list|(
operator|&
name|c1
operator|->
name|personality
argument_list|,
operator|&
name|c2
operator|->
name|personality
argument_list|,
sizeof|sizeof
argument_list|(
name|c1
operator|->
name|personality
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
name|c1
operator|->
name|output_sec
operator|==
name|c2
operator|->
name|output_sec
operator|&&
name|c1
operator|->
name|per_encoding
operator|==
name|c2
operator|->
name|per_encoding
operator|&&
name|c1
operator|->
name|lsda_encoding
operator|==
name|c2
operator|->
name|lsda_encoding
operator|&&
name|c1
operator|->
name|fde_encoding
operator|==
name|c2
operator|->
name|fde_encoding
operator|&&
name|c1
operator|->
name|initial_insn_length
operator|==
name|c2
operator|->
name|initial_insn_length
operator|&&
name|memcmp
argument_list|(
name|c1
operator|->
name|initial_instructions
argument_list|,
name|c2
operator|->
name|initial_instructions
argument_list|,
name|c1
operator|->
name|initial_insn_length
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|hashval_t
name|cie_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|e
parameter_list|)
block|{
specifier|const
name|struct
name|cie
modifier|*
name|c
init|=
name|e
decl_stmt|;
return|return
name|c
operator|->
name|hash
return|;
block|}
end_function

begin_function
specifier|static
name|hashval_t
name|cie_compute_hash
parameter_list|(
name|struct
name|cie
modifier|*
name|c
parameter_list|)
block|{
name|hashval_t
name|h
init|=
literal|0
decl_stmt|;
name|h
operator|=
name|iterative_hash_object
argument_list|(
name|c
operator|->
name|length
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|h
operator|=
name|iterative_hash_object
argument_list|(
name|c
operator|->
name|version
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|h
operator|=
name|iterative_hash
argument_list|(
name|c
operator|->
name|augmentation
argument_list|,
name|strlen
argument_list|(
name|c
operator|->
name|augmentation
argument_list|)
operator|+
literal|1
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|h
operator|=
name|iterative_hash_object
argument_list|(
name|c
operator|->
name|code_align
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|h
operator|=
name|iterative_hash_object
argument_list|(
name|c
operator|->
name|data_align
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|h
operator|=
name|iterative_hash_object
argument_list|(
name|c
operator|->
name|ra_column
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|h
operator|=
name|iterative_hash_object
argument_list|(
name|c
operator|->
name|augmentation_size
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|h
operator|=
name|iterative_hash_object
argument_list|(
name|c
operator|->
name|personality
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|h
operator|=
name|iterative_hash_object
argument_list|(
name|c
operator|->
name|output_sec
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|h
operator|=
name|iterative_hash_object
argument_list|(
name|c
operator|->
name|per_encoding
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|h
operator|=
name|iterative_hash_object
argument_list|(
name|c
operator|->
name|lsda_encoding
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|h
operator|=
name|iterative_hash_object
argument_list|(
name|c
operator|->
name|fde_encoding
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|h
operator|=
name|iterative_hash_object
argument_list|(
name|c
operator|->
name|initial_insn_length
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|h
operator|=
name|iterative_hash
argument_list|(
name|c
operator|->
name|initial_instructions
argument_list|,
name|c
operator|->
name|initial_insn_length
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|c
operator|->
name|hash
operator|=
name|h
expr_stmt|;
return|return
name|h
return|;
block|}
end_function

begin_comment
comment|/* Return the number of extra bytes that we'll be inserting into    ENTRY's augmentation string.  */
end_comment

begin_function
specifier|static
name|INLINE
name|unsigned
name|int
name|extra_augmentation_string_bytes
parameter_list|(
name|struct
name|eh_cie_fde
modifier|*
name|entry
parameter_list|)
block|{
name|unsigned
name|int
name|size
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|entry
operator|->
name|cie
condition|)
block|{
if|if
condition|(
name|entry
operator|->
name|add_augmentation_size
condition|)
name|size
operator|++
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|add_fde_encoding
condition|)
name|size
operator|++
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/* Likewise ENTRY's augmentation data.  */
end_comment

begin_function
specifier|static
name|INLINE
name|unsigned
name|int
name|extra_augmentation_data_bytes
parameter_list|(
name|struct
name|eh_cie_fde
modifier|*
name|entry
parameter_list|)
block|{
name|unsigned
name|int
name|size
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|entry
operator|->
name|cie
condition|)
block|{
if|if
condition|(
name|entry
operator|->
name|add_augmentation_size
condition|)
name|size
operator|++
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|add_fde_encoding
condition|)
name|size
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|entry
operator|->
name|cie_inf
operator|->
name|add_augmentation_size
condition|)
name|size
operator|++
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/* Return the size that ENTRY will have in the output.  ALIGNMENT is the    required alignment of ENTRY in bytes.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|size_of_output_cie_fde
parameter_list|(
name|struct
name|eh_cie_fde
modifier|*
name|entry
parameter_list|,
name|unsigned
name|int
name|alignment
parameter_list|)
block|{
if|if
condition|(
name|entry
operator|->
name|removed
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|entry
operator|->
name|size
operator|==
literal|4
condition|)
return|return
literal|4
return|;
return|return
operator|(
name|entry
operator|->
name|size
operator|+
name|extra_augmentation_string_bytes
argument_list|(
name|entry
argument_list|)
operator|+
name|extra_augmentation_data_bytes
argument_list|(
name|entry
argument_list|)
operator|+
name|alignment
operator|-
literal|1
operator|)
operator|&
operator|-
name|alignment
return|;
block|}
end_function

begin_comment
comment|/* Assume that the bytes between *ITER and END are CFA instructions.    Try to move *ITER past the first instruction and return true on    success.  ENCODED_PTR_WIDTH gives the width of pointer entries.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|skip_cfa_op
parameter_list|(
name|bfd_byte
modifier|*
modifier|*
name|iter
parameter_list|,
name|bfd_byte
modifier|*
name|end
parameter_list|,
name|unsigned
name|int
name|encoded_ptr_width
parameter_list|)
block|{
name|bfd_byte
name|op
decl_stmt|;
name|bfd_vma
name|length
decl_stmt|;
if|if
condition|(
operator|!
name|read_byte
argument_list|(
name|iter
argument_list|,
name|end
argument_list|,
operator|&
name|op
argument_list|)
condition|)
return|return
name|FALSE
return|;
switch|switch
condition|(
name|op
operator|&
literal|0xc0
condition|?
name|op
operator|&
literal|0xc0
else|:
name|op
condition|)
block|{
case|case
name|DW_CFA_nop
case|:
case|case
name|DW_CFA_advance_loc
case|:
case|case
name|DW_CFA_restore
case|:
case|case
name|DW_CFA_remember_state
case|:
case|case
name|DW_CFA_restore_state
case|:
case|case
name|DW_CFA_GNU_window_save
case|:
comment|/* No arguments.  */
return|return
name|TRUE
return|;
case|case
name|DW_CFA_offset
case|:
case|case
name|DW_CFA_restore_extended
case|:
case|case
name|DW_CFA_undefined
case|:
case|case
name|DW_CFA_same_value
case|:
case|case
name|DW_CFA_def_cfa_register
case|:
case|case
name|DW_CFA_def_cfa_offset
case|:
case|case
name|DW_CFA_def_cfa_offset_sf
case|:
case|case
name|DW_CFA_GNU_args_size
case|:
comment|/* One leb128 argument.  */
return|return
name|skip_leb128
argument_list|(
name|iter
argument_list|,
name|end
argument_list|)
return|;
case|case
name|DW_CFA_val_offset
case|:
case|case
name|DW_CFA_val_offset_sf
case|:
case|case
name|DW_CFA_offset_extended
case|:
case|case
name|DW_CFA_register
case|:
case|case
name|DW_CFA_def_cfa
case|:
case|case
name|DW_CFA_offset_extended_sf
case|:
case|case
name|DW_CFA_GNU_negative_offset_extended
case|:
case|case
name|DW_CFA_def_cfa_sf
case|:
comment|/* Two leb128 arguments.  */
return|return
operator|(
name|skip_leb128
argument_list|(
name|iter
argument_list|,
name|end
argument_list|)
operator|&&
name|skip_leb128
argument_list|(
name|iter
argument_list|,
name|end
argument_list|)
operator|)
return|;
case|case
name|DW_CFA_def_cfa_expression
case|:
comment|/* A variable-length argument.  */
return|return
operator|(
name|read_uleb128
argument_list|(
name|iter
argument_list|,
name|end
argument_list|,
operator|&
name|length
argument_list|)
operator|&&
name|skip_bytes
argument_list|(
name|iter
argument_list|,
name|end
argument_list|,
name|length
argument_list|)
operator|)
return|;
case|case
name|DW_CFA_expression
case|:
case|case
name|DW_CFA_val_expression
case|:
comment|/* A leb128 followed by a variable-length argument.  */
return|return
operator|(
name|skip_leb128
argument_list|(
name|iter
argument_list|,
name|end
argument_list|)
operator|&&
name|read_uleb128
argument_list|(
name|iter
argument_list|,
name|end
argument_list|,
operator|&
name|length
argument_list|)
operator|&&
name|skip_bytes
argument_list|(
name|iter
argument_list|,
name|end
argument_list|,
name|length
argument_list|)
operator|)
return|;
case|case
name|DW_CFA_set_loc
case|:
return|return
name|skip_bytes
argument_list|(
name|iter
argument_list|,
name|end
argument_list|,
name|encoded_ptr_width
argument_list|)
return|;
case|case
name|DW_CFA_advance_loc1
case|:
return|return
name|skip_bytes
argument_list|(
name|iter
argument_list|,
name|end
argument_list|,
literal|1
argument_list|)
return|;
case|case
name|DW_CFA_advance_loc2
case|:
return|return
name|skip_bytes
argument_list|(
name|iter
argument_list|,
name|end
argument_list|,
literal|2
argument_list|)
return|;
case|case
name|DW_CFA_advance_loc4
case|:
return|return
name|skip_bytes
argument_list|(
name|iter
argument_list|,
name|end
argument_list|,
literal|4
argument_list|)
return|;
case|case
name|DW_CFA_MIPS_advance_loc8
case|:
return|return
name|skip_bytes
argument_list|(
name|iter
argument_list|,
name|end
argument_list|,
literal|8
argument_list|)
return|;
default|default:
return|return
name|FALSE
return|;
block|}
block|}
end_function

begin_comment
comment|/* Try to interpret the bytes between BUF and END as CFA instructions.    If every byte makes sense, return a pointer to the first DW_CFA_nop    padding byte, or END if there is no padding.  Return null otherwise.    ENCODED_PTR_WIDTH is as for skip_cfa_op.  */
end_comment

begin_function
specifier|static
name|bfd_byte
modifier|*
name|skip_non_nops
parameter_list|(
name|bfd_byte
modifier|*
name|buf
parameter_list|,
name|bfd_byte
modifier|*
name|end
parameter_list|,
name|unsigned
name|int
name|encoded_ptr_width
parameter_list|,
name|unsigned
name|int
modifier|*
name|set_loc_count
parameter_list|)
block|{
name|bfd_byte
modifier|*
name|last
decl_stmt|;
name|last
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|buf
operator|<
name|end
condition|)
if|if
condition|(
operator|*
name|buf
operator|==
name|DW_CFA_nop
condition|)
name|buf
operator|++
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|*
name|buf
operator|==
name|DW_CFA_set_loc
condition|)
operator|++
operator|*
name|set_loc_count
expr_stmt|;
if|if
condition|(
operator|!
name|skip_cfa_op
argument_list|(
operator|&
name|buf
argument_list|,
name|end
argument_list|,
name|encoded_ptr_width
argument_list|)
condition|)
return|return
literal|0
return|;
name|last
operator|=
name|buf
expr_stmt|;
block|}
return|return
name|last
return|;
block|}
end_function

begin_comment
comment|/* This function is called for each input file before the .eh_frame    section is relocated.  It discards duplicate CIEs and FDEs for discarded    functions.  The function returns TRUE iff any entries have been    deleted.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_elf_discard_section_eh_frame
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|bfd_boolean
function_decl|(
modifier|*
name|reloc_symbol_deleted_p
function_decl|)
parameter_list|(
name|bfd_vma
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|struct
name|elf_reloc_cookie
modifier|*
name|cookie
parameter_list|)
block|{
define|#
directive|define
name|REQUIRE
parameter_list|(
name|COND
parameter_list|)
define|\
value|do							\     if (!(COND))					\       goto free_no_table;				\   while (0)
name|bfd_byte
modifier|*
name|ehbuf
init|=
name|NULL
decl_stmt|,
modifier|*
name|buf
decl_stmt|;
name|bfd_byte
modifier|*
name|last_fde
decl_stmt|;
name|struct
name|eh_cie_fde
modifier|*
name|ent
decl_stmt|,
modifier|*
name|this_inf
decl_stmt|;
name|unsigned
name|int
name|hdr_length
decl_stmt|,
name|hdr_id
decl_stmt|;
struct|struct
name|extended_cie
block|{
name|struct
name|cie
name|cie
decl_stmt|;
name|unsigned
name|int
name|offset
decl_stmt|;
name|unsigned
name|int
name|usage_count
decl_stmt|;
name|unsigned
name|int
name|entry
decl_stmt|;
block|}
modifier|*
name|ecies
init|=
name|NULL
struct|,
modifier|*
name|ecie
struct|;
name|unsigned
name|int
name|ecie_count
init|=
literal|0
decl_stmt|,
name|ecie_alloced
init|=
literal|0
decl_stmt|;
name|struct
name|cie
modifier|*
name|cie
decl_stmt|;
name|struct
name|elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|struct
name|eh_frame_hdr_info
modifier|*
name|hdr_info
decl_stmt|;
name|struct
name|eh_frame_sec_info
modifier|*
name|sec_info
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|offset
decl_stmt|;
name|unsigned
name|int
name|ptr_size
decl_stmt|;
name|unsigned
name|int
name|entry_alloced
decl_stmt|;
if|if
condition|(
name|sec
operator|->
name|size
operator|==
literal|0
condition|)
block|{
comment|/* This file does not contain .eh_frame information.  */
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|bfd_is_abs_section
argument_list|(
name|sec
operator|->
name|output_section
argument_list|)
condition|)
block|{
comment|/* At least one of the sections is being discarded from the 	 link, so we should just ignore them.  */
return|return
name|FALSE
return|;
block|}
name|htab
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|hdr_info
operator|=
operator|&
name|htab
operator|->
name|eh_info
expr_stmt|;
if|if
condition|(
name|hdr_info
operator|->
name|cies
operator|==
name|NULL
operator|&&
operator|!
name|info
operator|->
name|relocatable
condition|)
name|hdr_info
operator|->
name|cies
operator|=
name|htab_try_create
argument_list|(
literal|1
argument_list|,
name|cie_hash
argument_list|,
name|cie_eq
argument_list|,
name|free
argument_list|)
expr_stmt|;
comment|/* Read the frame unwind information from abfd.  */
name|REQUIRE
argument_list|(
name|bfd_malloc_and_get_section
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
operator|&
name|ehbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|size
operator|>=
literal|4
operator|&&
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|ehbuf
argument_list|)
operator|==
literal|0
operator|&&
name|cookie
operator|->
name|rel
operator|==
name|cookie
operator|->
name|relend
condition|)
block|{
comment|/* Empty .eh_frame section.  */
name|free
argument_list|(
name|ehbuf
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* If .eh_frame section size doesn't fit into int, we cannot handle      it (it would need to use 64-bit .eh_frame format anyway).  */
name|REQUIRE
argument_list|(
name|sec
operator|->
name|size
operator|==
operator|(
name|unsigned
name|int
operator|)
name|sec
operator|->
name|size
argument_list|)
expr_stmt|;
name|ptr_size
operator|=
operator|(
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_backend_eh_frame_address_size
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|ptr_size
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|buf
operator|=
name|ehbuf
expr_stmt|;
name|sec_info
operator|=
name|bfd_zmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|eh_frame_sec_info
argument_list|)
operator|+
literal|99
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|eh_cie_fde
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|sec_info
argument_list|)
expr_stmt|;
name|entry_alloced
operator|=
literal|100
expr_stmt|;
define|#
directive|define
name|ENSURE_NO_RELOCS
parameter_list|(
name|buf
parameter_list|)
define|\
value|REQUIRE (!(cookie->rel< cookie->relend		\&& (cookie->rel->r_offset			\< (bfd_size_type) ((buf) - ehbuf))	\&& cookie->rel->r_info != 0))
define|#
directive|define
name|SKIP_RELOCS
parameter_list|(
name|buf
parameter_list|)
define|\
value|while (cookie->rel< cookie->relend			\&& (cookie->rel->r_offset			\< (bfd_size_type) ((buf) - ehbuf)))	\     cookie->rel++
define|#
directive|define
name|GET_RELOC
parameter_list|(
name|buf
parameter_list|)
define|\
value|((cookie->rel< cookie->relend			\&& (cookie->rel->r_offset				\ 	== (bfd_size_type) ((buf) - ehbuf)))		\    ? cookie->rel : NULL)
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
modifier|*
name|aug
decl_stmt|;
name|bfd_byte
modifier|*
name|start
decl_stmt|,
modifier|*
name|end
decl_stmt|,
modifier|*
name|insns
decl_stmt|,
modifier|*
name|insns_end
decl_stmt|;
name|bfd_size_type
name|length
decl_stmt|;
name|unsigned
name|int
name|set_loc_count
decl_stmt|;
if|if
condition|(
name|sec_info
operator|->
name|count
operator|==
name|entry_alloced
condition|)
block|{
name|sec_info
operator|=
name|bfd_realloc
argument_list|(
name|sec_info
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|eh_frame_sec_info
argument_list|)
operator|+
operator|(
operator|(
name|entry_alloced
operator|+
literal|99
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|eh_cie_fde
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|sec_info
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sec_info
operator|->
name|entry
index|[
name|entry_alloced
index|]
argument_list|,
literal|0
argument_list|,
literal|100
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|eh_cie_fde
argument_list|)
argument_list|)
expr_stmt|;
name|entry_alloced
operator|+=
literal|100
expr_stmt|;
block|}
name|this_inf
operator|=
name|sec_info
operator|->
name|entry
operator|+
name|sec_info
operator|->
name|count
expr_stmt|;
name|last_fde
operator|=
name|buf
expr_stmt|;
if|if
condition|(
call|(
name|bfd_size_type
call|)
argument_list|(
name|buf
operator|-
name|ehbuf
argument_list|)
operator|==
name|sec
operator|->
name|size
condition|)
break|break;
comment|/* Read the length of the entry.  */
name|REQUIRE
argument_list|(
name|skip_bytes
argument_list|(
operator|&
name|buf
argument_list|,
name|ehbuf
operator|+
name|sec
operator|->
name|size
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|hdr_length
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|buf
operator|-
literal|4
argument_list|)
expr_stmt|;
comment|/* 64-bit .eh_frame is not supported.  */
name|REQUIRE
argument_list|(
name|hdr_length
operator|!=
literal|0xffffffff
argument_list|)
expr_stmt|;
comment|/* The CIE/FDE must be fully contained in this input section.  */
name|REQUIRE
argument_list|(
call|(
name|bfd_size_type
call|)
argument_list|(
name|buf
operator|-
name|ehbuf
argument_list|)
operator|+
name|hdr_length
operator|<=
name|sec
operator|->
name|size
argument_list|)
expr_stmt|;
name|end
operator|=
name|buf
operator|+
name|hdr_length
expr_stmt|;
name|this_inf
operator|->
name|offset
operator|=
name|last_fde
operator|-
name|ehbuf
expr_stmt|;
name|this_inf
operator|->
name|size
operator|=
literal|4
operator|+
name|hdr_length
expr_stmt|;
if|if
condition|(
name|hdr_length
operator|==
literal|0
condition|)
block|{
comment|/* A zero-length CIE should only be found at the end of 	     the section.  */
name|REQUIRE
argument_list|(
call|(
name|bfd_size_type
call|)
argument_list|(
name|buf
operator|-
name|ehbuf
argument_list|)
operator|==
name|sec
operator|->
name|size
argument_list|)
expr_stmt|;
name|ENSURE_NO_RELOCS
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|sec_info
operator|->
name|count
operator|++
expr_stmt|;
break|break;
block|}
name|REQUIRE
argument_list|(
name|skip_bytes
argument_list|(
operator|&
name|buf
argument_list|,
name|end
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|hdr_id
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|buf
operator|-
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr_id
operator|==
literal|0
condition|)
block|{
name|unsigned
name|int
name|initial_insn_length
decl_stmt|;
comment|/* CIE  */
name|this_inf
operator|->
name|cie
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ecie_count
operator|==
name|ecie_alloced
condition|)
block|{
name|ecies
operator|=
name|bfd_realloc
argument_list|(
name|ecies
argument_list|,
operator|(
name|ecie_alloced
operator|+
literal|20
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|ecies
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|ecies
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ecies
index|[
name|ecie_alloced
index|]
argument_list|,
literal|0
argument_list|,
literal|20
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|ecies
argument_list|)
argument_list|)
expr_stmt|;
name|ecie_alloced
operator|+=
literal|20
expr_stmt|;
block|}
name|cie
operator|=
operator|&
name|ecies
index|[
name|ecie_count
index|]
operator|.
name|cie
expr_stmt|;
name|ecies
index|[
name|ecie_count
index|]
operator|.
name|offset
operator|=
name|this_inf
operator|->
name|offset
expr_stmt|;
name|ecies
index|[
name|ecie_count
operator|++
index|]
operator|.
name|entry
operator|=
name|sec_info
operator|->
name|count
expr_stmt|;
name|cie
operator|->
name|length
operator|=
name|hdr_length
expr_stmt|;
name|start
operator|=
name|buf
expr_stmt|;
name|REQUIRE
argument_list|(
name|read_byte
argument_list|(
operator|&
name|buf
argument_list|,
name|end
argument_list|,
operator|&
name|cie
operator|->
name|version
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Cannot handle unknown versions.  */
name|REQUIRE
argument_list|(
name|cie
operator|->
name|version
operator|==
literal|1
operator|||
name|cie
operator|->
name|version
operator|==
literal|3
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
name|cie
operator|->
name|augmentation
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|cie
operator|->
name|augmentation
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|strchr
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
literal|'\0'
argument_list|)
operator|+
literal|1
expr_stmt|;
name|ENSURE_NO_RELOCS
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'e'
operator|&&
name|buf
index|[
literal|1
index|]
operator|==
literal|'h'
condition|)
block|{
comment|/* GCC< 3.0 .eh_frame CIE */
comment|/* We cannot merge "eh" CIEs because __EXCEPTION_TABLE__ 		 is private to each CIE, so we don't need it for anything. 		 Just skip it.  */
name|REQUIRE
argument_list|(
name|skip_bytes
argument_list|(
operator|&
name|buf
argument_list|,
name|end
argument_list|,
name|ptr_size
argument_list|)
argument_list|)
expr_stmt|;
name|SKIP_RELOCS
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|REQUIRE
argument_list|(
name|read_uleb128
argument_list|(
operator|&
name|buf
argument_list|,
name|end
argument_list|,
operator|&
name|cie
operator|->
name|code_align
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|read_sleb128
argument_list|(
operator|&
name|buf
argument_list|,
name|end
argument_list|,
operator|&
name|cie
operator|->
name|data_align
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cie
operator|->
name|version
operator|==
literal|1
condition|)
block|{
name|REQUIRE
argument_list|(
name|buf
operator|<
name|end
argument_list|)
expr_stmt|;
name|cie
operator|->
name|ra_column
operator|=
operator|*
name|buf
operator|++
expr_stmt|;
block|}
else|else
name|REQUIRE
argument_list|(
name|read_uleb128
argument_list|(
operator|&
name|buf
argument_list|,
name|end
argument_list|,
operator|&
name|cie
operator|->
name|ra_column
argument_list|)
argument_list|)
expr_stmt|;
name|ENSURE_NO_RELOCS
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|cie
operator|->
name|lsda_encoding
operator|=
name|DW_EH_PE_omit
expr_stmt|;
name|cie
operator|->
name|fde_encoding
operator|=
name|DW_EH_PE_omit
expr_stmt|;
name|cie
operator|->
name|per_encoding
operator|=
name|DW_EH_PE_omit
expr_stmt|;
name|aug
operator|=
name|cie
operator|->
name|augmentation
expr_stmt|;
if|if
condition|(
name|aug
index|[
literal|0
index|]
operator|!=
literal|'e'
operator|||
name|aug
index|[
literal|1
index|]
operator|!=
literal|'h'
condition|)
block|{
if|if
condition|(
operator|*
name|aug
operator|==
literal|'z'
condition|)
block|{
name|aug
operator|++
expr_stmt|;
name|REQUIRE
argument_list|(
name|read_uleb128
argument_list|(
operator|&
name|buf
argument_list|,
name|end
argument_list|,
operator|&
name|cie
operator|->
name|augmentation_size
argument_list|)
argument_list|)
expr_stmt|;
name|ENSURE_NO_RELOCS
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|aug
operator|!=
literal|'\0'
condition|)
switch|switch
condition|(
operator|*
name|aug
operator|++
condition|)
block|{
case|case
literal|'L'
case|:
name|REQUIRE
argument_list|(
name|read_byte
argument_list|(
operator|&
name|buf
argument_list|,
name|end
argument_list|,
operator|&
name|cie
operator|->
name|lsda_encoding
argument_list|)
argument_list|)
expr_stmt|;
name|ENSURE_NO_RELOCS
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|get_DW_EH_PE_width
argument_list|(
name|cie
operator|->
name|lsda_encoding
argument_list|,
name|ptr_size
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|REQUIRE
argument_list|(
name|read_byte
argument_list|(
operator|&
name|buf
argument_list|,
name|end
argument_list|,
operator|&
name|cie
operator|->
name|fde_encoding
argument_list|)
argument_list|)
expr_stmt|;
name|ENSURE_NO_RELOCS
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|get_DW_EH_PE_width
argument_list|(
name|cie
operator|->
name|fde_encoding
argument_list|,
name|ptr_size
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
break|break;
case|case
literal|'P'
case|:
block|{
name|int
name|per_width
decl_stmt|;
name|REQUIRE
argument_list|(
name|read_byte
argument_list|(
operator|&
name|buf
argument_list|,
name|end
argument_list|,
operator|&
name|cie
operator|->
name|per_encoding
argument_list|)
argument_list|)
expr_stmt|;
name|per_width
operator|=
name|get_DW_EH_PE_width
argument_list|(
name|cie
operator|->
name|per_encoding
argument_list|,
name|ptr_size
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|per_width
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cie
operator|->
name|per_encoding
operator|&
literal|0xf0
operator|)
operator|==
name|DW_EH_PE_aligned
condition|)
block|{
name|length
operator|=
operator|-
operator|(
name|buf
operator|-
name|ehbuf
operator|)
operator|&
operator|(
name|per_width
operator|-
literal|1
operator|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|skip_bytes
argument_list|(
operator|&
name|buf
argument_list|,
name|end
argument_list|,
name|length
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ENSURE_NO_RELOCS
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* Ensure we have a reloc here.  */
if|if
condition|(
name|GET_RELOC
argument_list|(
name|buf
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
ifdef|#
directive|ifdef
name|BFD64
if|if
condition|(
name|ptr_size
operator|==
literal|8
condition|)
name|r_symndx
operator|=
name|ELF64_R_SYM
argument_list|(
name|cookie
operator|->
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|cookie
operator|->
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|>=
name|cookie
operator|->
name|locsymcount
operator|||
name|ELF_ST_BIND
argument_list|(
name|cookie
operator|->
name|locsyms
index|[
name|r_symndx
index|]
operator|.
name|st_info
argument_list|)
operator|!=
name|STB_LOCAL
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|r_symndx
operator|-=
name|cookie
operator|->
name|extsymoff
expr_stmt|;
name|h
operator|=
name|cookie
operator|->
name|sym_hashes
index|[
name|r_symndx
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|cie
operator|->
name|personality
operator|.
name|h
operator|=
name|h
expr_stmt|;
block|}
else|else
block|{
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|asection
modifier|*
name|sym_sec
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
name|sym
operator|=
operator|&
name|cookie
operator|->
name|locsyms
index|[
name|r_symndx
index|]
expr_stmt|;
name|sym_sec
operator|=
operator|(
name|bfd_section_from_elf_index
argument_list|(
name|abfd
argument_list|,
name|sym
operator|->
name|st_shndx
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|sym_sec
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|sym_sec
operator|->
name|kept_section
operator|!=
name|NULL
condition|)
name|sym_sec
operator|=
name|sym_sec
operator|->
name|kept_section
expr_stmt|;
if|if
condition|(
name|sym_sec
operator|->
name|output_section
operator|!=
name|NULL
condition|)
block|{
name|val
operator|=
operator|(
name|sym
operator|->
name|st_value
operator|+
name|sym_sec
operator|->
name|output_offset
operator|+
name|sym_sec
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
name|cie
operator|->
name|personality
operator|.
name|val
operator|=
name|val
expr_stmt|;
name|cie
operator|->
name|local_personality
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* Cope with MIPS-style composite relocations.  */
do|do
name|cookie
operator|->
name|rel
operator|++
expr_stmt|;
do|while
condition|(
name|GET_RELOC
argument_list|(
name|buf
argument_list|)
operator|!=
name|NULL
condition|)
do|;
block|}
name|REQUIRE
argument_list|(
name|skip_bytes
argument_list|(
operator|&
name|buf
argument_list|,
name|end
argument_list|,
name|per_width
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|cie
operator|->
name|local_personality
operator|||
name|cie
operator|->
name|personality
operator|.
name|h
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|/* Unrecognized augmentation. Better bail out.  */
goto|goto
name|free_no_table
goto|;
block|}
block|}
comment|/* For shared libraries, try to get rid of as many RELATIVE relocs 	     as possible.  */
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_backend_can_make_relative_eh_frame
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|sec
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|cie
operator|->
name|fde_encoding
operator|&
literal|0xf0
operator|)
operator|==
name|DW_EH_PE_absptr
condition|)
name|cie
operator|->
name|make_relative
operator|=
literal|1
expr_stmt|;
comment|/* If the CIE doesn't already have an 'R' entry, it's fairly 		 easy to add one, provided that there's no aligned data 		 after the augmentation string.  */
elseif|else
if|if
condition|(
name|cie
operator|->
name|fde_encoding
operator|==
name|DW_EH_PE_omit
operator|&&
operator|(
name|cie
operator|->
name|per_encoding
operator|&
literal|0xf0
operator|)
operator|!=
name|DW_EH_PE_aligned
condition|)
block|{
if|if
condition|(
operator|*
name|cie
operator|->
name|augmentation
operator|==
literal|0
condition|)
name|this_inf
operator|->
name|add_augmentation_size
operator|=
literal|1
expr_stmt|;
name|this_inf
operator|->
name|add_fde_encoding
operator|=
literal|1
expr_stmt|;
name|cie
operator|->
name|make_relative
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_backend_can_make_lsda_relative_eh_frame
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|sec
argument_list|)
operator|)
operator|&&
operator|(
name|cie
operator|->
name|lsda_encoding
operator|&
literal|0xf0
operator|)
operator|==
name|DW_EH_PE_absptr
condition|)
name|cie
operator|->
name|make_lsda_relative
operator|=
literal|1
expr_stmt|;
comment|/* If FDE encoding was not specified, it defaults to 	     DW_EH_absptr.  */
if|if
condition|(
name|cie
operator|->
name|fde_encoding
operator|==
name|DW_EH_PE_omit
condition|)
name|cie
operator|->
name|fde_encoding
operator|=
name|DW_EH_PE_absptr
expr_stmt|;
name|initial_insn_length
operator|=
name|end
operator|-
name|buf
expr_stmt|;
if|if
condition|(
name|initial_insn_length
operator|<=
sizeof|sizeof
argument_list|(
name|cie
operator|->
name|initial_instructions
argument_list|)
condition|)
block|{
name|cie
operator|->
name|initial_insn_length
operator|=
name|initial_insn_length
expr_stmt|;
name|memcpy
argument_list|(
name|cie
operator|->
name|initial_instructions
argument_list|,
name|buf
argument_list|,
name|initial_insn_length
argument_list|)
expr_stmt|;
block|}
name|insns
operator|=
name|buf
expr_stmt|;
name|buf
operator|+=
name|initial_insn_length
expr_stmt|;
name|ENSURE_NO_RELOCS
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Find the corresponding CIE.  */
name|unsigned
name|int
name|cie_offset
init|=
name|this_inf
operator|->
name|offset
operator|+
literal|4
operator|-
name|hdr_id
decl_stmt|;
for|for
control|(
name|ecie
operator|=
name|ecies
init|;
name|ecie
operator|<
name|ecies
operator|+
name|ecie_count
condition|;
operator|++
name|ecie
control|)
if|if
condition|(
name|cie_offset
operator|==
name|ecie
operator|->
name|offset
condition|)
break|break;
comment|/* Ensure this FDE references one of the CIEs in this input 	     section.  */
name|REQUIRE
argument_list|(
name|ecie
operator|!=
name|ecies
operator|+
name|ecie_count
argument_list|)
expr_stmt|;
name|cie
operator|=
operator|&
name|ecie
operator|->
name|cie
expr_stmt|;
name|ENSURE_NO_RELOCS
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|GET_RELOC
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|reloc_symbol_deleted_p
call|)
argument_list|(
name|buf
operator|-
name|ehbuf
argument_list|,
name|cookie
argument_list|)
condition|)
comment|/* This is a FDE against a discarded section.  It should 	       be deleted.  */
name|this_inf
operator|->
name|removed
operator|=
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
operator|(
operator|(
operator|(
name|cie
operator|->
name|fde_encoding
operator|&
literal|0xf0
operator|)
operator|==
name|DW_EH_PE_absptr
operator|&&
name|cie
operator|->
name|make_relative
operator|==
literal|0
operator|)
operator|||
operator|(
name|cie
operator|->
name|fde_encoding
operator|&
literal|0xf0
operator|)
operator|==
name|DW_EH_PE_aligned
operator|)
condition|)
block|{
comment|/* If a shared library uses absolute pointers 		     which we cannot turn into PC relative, 		     don't create the binary search table, 		     since it is affected by runtime relocations.  */
name|hdr_info
operator|->
name|table
operator|=
name|FALSE
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|einfo
call|)
argument_list|(
name|_
argument_list|(
literal|"%P: fde encoding in %B(%A) prevents .eh_frame_hdr"
literal|" table being created.\n"
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
block|}
name|ecie
operator|->
name|usage_count
operator|++
expr_stmt|;
name|hdr_info
operator|->
name|fde_count
operator|++
expr_stmt|;
name|this_inf
operator|->
name|cie_inf
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|ecie
operator|-
name|ecies
operator|)
expr_stmt|;
block|}
comment|/* Skip the initial location and address range.  */
name|start
operator|=
name|buf
expr_stmt|;
name|length
operator|=
name|get_DW_EH_PE_width
argument_list|(
name|cie
operator|->
name|fde_encoding
argument_list|,
name|ptr_size
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|skip_bytes
argument_list|(
operator|&
name|buf
argument_list|,
name|end
argument_list|,
literal|2
operator|*
name|length
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Skip the augmentation size, if present.  */
if|if
condition|(
name|cie
operator|->
name|augmentation
index|[
literal|0
index|]
operator|==
literal|'z'
condition|)
name|REQUIRE
argument_list|(
name|read_uleb128
argument_list|(
operator|&
name|buf
argument_list|,
name|end
argument_list|,
operator|&
name|length
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|length
operator|=
literal|0
expr_stmt|;
comment|/* Of the supported augmentation characters above, only 'L' 	     adds augmentation data to the FDE.  This code would need to 	     be adjusted if any future augmentations do the same thing.  */
if|if
condition|(
name|cie
operator|->
name|lsda_encoding
operator|!=
name|DW_EH_PE_omit
condition|)
block|{
name|this_inf
operator|->
name|lsda_offset
operator|=
name|buf
operator|-
name|start
expr_stmt|;
comment|/* If there's no 'z' augmentation, we don't know where the 		 CFA insns begin.  Assume no padding.  */
if|if
condition|(
name|cie
operator|->
name|augmentation
index|[
literal|0
index|]
operator|!=
literal|'z'
condition|)
name|length
operator|=
name|end
operator|-
name|buf
expr_stmt|;
block|}
comment|/* Skip over the augmentation data.  */
name|REQUIRE
argument_list|(
name|skip_bytes
argument_list|(
operator|&
name|buf
argument_list|,
name|end
argument_list|,
name|length
argument_list|)
argument_list|)
expr_stmt|;
name|insns
operator|=
name|buf
expr_stmt|;
name|buf
operator|=
name|last_fde
operator|+
literal|4
operator|+
name|hdr_length
expr_stmt|;
name|SKIP_RELOCS
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
comment|/* Try to interpret the CFA instructions and find the first 	 padding nop.  Shrink this_inf's size so that it doesn't 	 include the padding.  */
name|length
operator|=
name|get_DW_EH_PE_width
argument_list|(
name|cie
operator|->
name|fde_encoding
argument_list|,
name|ptr_size
argument_list|)
expr_stmt|;
name|set_loc_count
operator|=
literal|0
expr_stmt|;
name|insns_end
operator|=
name|skip_non_nops
argument_list|(
name|insns
argument_list|,
name|end
argument_list|,
name|length
argument_list|,
operator|&
name|set_loc_count
argument_list|)
expr_stmt|;
comment|/* If we don't understand the CFA instructions, we can't know 	 what needs to be adjusted there.  */
if|if
condition|(
name|insns_end
operator|==
name|NULL
comment|/* For the time being we don't support DW_CFA_set_loc in 	     CIE instructions.  */
operator|||
operator|(
name|set_loc_count
operator|&&
name|this_inf
operator|->
name|cie
operator|)
condition|)
goto|goto
name|free_no_table
goto|;
name|this_inf
operator|->
name|size
operator|-=
name|end
operator|-
name|insns_end
expr_stmt|;
if|if
condition|(
name|insns_end
operator|!=
name|end
operator|&&
name|this_inf
operator|->
name|cie
condition|)
block|{
name|cie
operator|->
name|initial_insn_length
operator|-=
name|end
operator|-
name|insns_end
expr_stmt|;
name|cie
operator|->
name|length
operator|-=
name|end
operator|-
name|insns_end
expr_stmt|;
block|}
if|if
condition|(
name|set_loc_count
operator|&&
operator|(
operator|(
name|cie
operator|->
name|fde_encoding
operator|&
literal|0xf0
operator|)
operator|==
name|DW_EH_PE_pcrel
operator|||
name|cie
operator|->
name|make_relative
operator|)
condition|)
block|{
name|unsigned
name|int
name|cnt
decl_stmt|;
name|bfd_byte
modifier|*
name|p
decl_stmt|;
name|this_inf
operator|->
name|set_loc
operator|=
name|bfd_malloc
argument_list|(
operator|(
name|set_loc_count
operator|+
literal|1
operator|)
operator|*
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|this_inf
operator|->
name|set_loc
argument_list|)
expr_stmt|;
name|this_inf
operator|->
name|set_loc
index|[
literal|0
index|]
operator|=
name|set_loc_count
expr_stmt|;
name|p
operator|=
name|insns
expr_stmt|;
name|cnt
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|end
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
name|DW_CFA_set_loc
condition|)
name|this_inf
operator|->
name|set_loc
index|[
operator|++
name|cnt
index|]
operator|=
name|p
operator|+
literal|1
operator|-
name|start
expr_stmt|;
name|REQUIRE
argument_list|(
name|skip_cfa_op
argument_list|(
operator|&
name|p
argument_list|,
name|end
argument_list|,
name|length
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|this_inf
operator|->
name|fde_encoding
operator|=
name|cie
operator|->
name|fde_encoding
expr_stmt|;
name|this_inf
operator|->
name|lsda_encoding
operator|=
name|cie
operator|->
name|lsda_encoding
expr_stmt|;
name|sec_info
operator|->
name|count
operator|++
expr_stmt|;
block|}
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|sec_info
operator|=
name|sec_info
expr_stmt|;
name|sec
operator|->
name|sec_info_type
operator|=
name|ELF_INFO_TYPE_EH_FRAME
expr_stmt|;
comment|/* Look at all CIEs in this section and determine which can be      removed as unused, which can be merged with previous duplicate      CIEs and which need to be kept.  */
for|for
control|(
name|ecie
operator|=
name|ecies
init|;
name|ecie
operator|<
name|ecies
operator|+
name|ecie_count
condition|;
operator|++
name|ecie
control|)
block|{
if|if
condition|(
name|ecie
operator|->
name|usage_count
operator|==
literal|0
condition|)
block|{
name|sec_info
operator|->
name|entry
index|[
name|ecie
operator|->
name|entry
index|]
operator|.
name|removed
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
name|ecie
operator|->
name|cie
operator|.
name|output_sec
operator|=
name|sec
operator|->
name|output_section
expr_stmt|;
name|ecie
operator|->
name|cie
operator|.
name|cie_inf
operator|=
name|sec_info
operator|->
name|entry
operator|+
name|ecie
operator|->
name|entry
expr_stmt|;
name|cie_compute_hash
argument_list|(
operator|&
name|ecie
operator|->
name|cie
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr_info
operator|->
name|cies
operator|!=
name|NULL
condition|)
block|{
name|void
modifier|*
modifier|*
name|loc
init|=
name|htab_find_slot_with_hash
argument_list|(
name|hdr_info
operator|->
name|cies
argument_list|,
operator|&
name|ecie
operator|->
name|cie
argument_list|,
name|ecie
operator|->
name|cie
operator|.
name|hash
argument_list|,
name|INSERT
argument_list|)
decl_stmt|;
if|if
condition|(
name|loc
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|loc
operator|!=
name|HTAB_EMPTY_ENTRY
condition|)
block|{
name|sec_info
operator|->
name|entry
index|[
name|ecie
operator|->
name|entry
index|]
operator|.
name|removed
operator|=
literal|1
expr_stmt|;
name|ecie
operator|->
name|cie
operator|.
name|cie_inf
operator|=
operator|(
operator|(
expr|struct
name|cie
operator|*
operator|)
operator|*
name|loc
operator|)
operator|->
name|cie_inf
expr_stmt|;
continue|continue;
block|}
operator|*
name|loc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cie
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|loc
operator|==
name|NULL
condition|)
operator|*
name|loc
operator|=
name|HTAB_DELETED_ENTRY
expr_stmt|;
else|else
name|memcpy
argument_list|(
operator|*
name|loc
argument_list|,
operator|&
name|ecie
operator|->
name|cie
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cie
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|ecie
operator|->
name|cie
operator|.
name|cie_inf
operator|->
name|make_relative
operator|=
name|ecie
operator|->
name|cie
operator|.
name|make_relative
expr_stmt|;
name|ecie
operator|->
name|cie
operator|.
name|cie_inf
operator|->
name|make_lsda_relative
operator|=
name|ecie
operator|->
name|cie
operator|.
name|make_lsda_relative
expr_stmt|;
name|ecie
operator|->
name|cie
operator|.
name|cie_inf
operator|->
name|per_encoding_relative
operator|=
operator|(
name|ecie
operator|->
name|cie
operator|.
name|per_encoding
operator|&
literal|0x70
operator|)
operator|==
name|DW_EH_PE_pcrel
expr_stmt|;
block|}
comment|/* Ok, now we can assign new offsets.  */
name|offset
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ent
operator|=
name|sec_info
operator|->
name|entry
init|;
name|ent
operator|<
name|sec_info
operator|->
name|entry
operator|+
name|sec_info
operator|->
name|count
condition|;
operator|++
name|ent
control|)
if|if
condition|(
operator|!
name|ent
operator|->
name|removed
condition|)
block|{
if|if
condition|(
operator|!
name|ent
operator|->
name|cie
condition|)
block|{
name|ecie
operator|=
name|ecies
operator|+
operator|(
name|unsigned
name|long
operator|)
name|ent
operator|->
name|cie_inf
expr_stmt|;
name|ent
operator|->
name|cie_inf
operator|=
name|ecie
operator|->
name|cie
operator|.
name|cie_inf
expr_stmt|;
block|}
name|ent
operator|->
name|new_offset
operator|=
name|offset
expr_stmt|;
name|offset
operator|+=
name|size_of_output_cie_fde
argument_list|(
name|ent
argument_list|,
name|ptr_size
argument_list|)
expr_stmt|;
block|}
comment|/* Resize the sec as needed.  */
name|sec
operator|->
name|rawsize
operator|=
name|sec
operator|->
name|size
expr_stmt|;
name|sec
operator|->
name|size
operator|=
name|offset
expr_stmt|;
name|free
argument_list|(
name|ehbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecies
condition|)
name|free
argument_list|(
name|ecies
argument_list|)
expr_stmt|;
return|return
name|offset
operator|!=
name|sec
operator|->
name|rawsize
return|;
name|free_no_table
label|:
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|einfo
call|)
argument_list|(
name|_
argument_list|(
literal|"%P: error in %B(%A); no .eh_frame_hdr table will be created.\n"
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|ehbuf
condition|)
name|free
argument_list|(
name|ehbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec_info
condition|)
name|free
argument_list|(
name|sec_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecies
condition|)
name|free
argument_list|(
name|ecies
argument_list|)
expr_stmt|;
name|hdr_info
operator|->
name|table
operator|=
name|FALSE
expr_stmt|;
return|return
name|FALSE
return|;
undef|#
directive|undef
name|REQUIRE
block|}
end_function

begin_comment
comment|/* This function is called for .eh_frame_hdr section after    _bfd_elf_discard_section_eh_frame has been called on all .eh_frame    input sections.  It finalizes the size of .eh_frame_hdr section.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_elf_discard_section_eh_frame_hdr
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|struct
name|eh_frame_hdr_info
modifier|*
name|hdr_info
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|htab
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|hdr_info
operator|=
operator|&
name|htab
operator|->
name|eh_info
expr_stmt|;
if|if
condition|(
name|hdr_info
operator|->
name|cies
operator|!=
name|NULL
condition|)
block|{
name|htab_delete
argument_list|(
name|hdr_info
operator|->
name|cies
argument_list|)
expr_stmt|;
name|hdr_info
operator|->
name|cies
operator|=
name|NULL
expr_stmt|;
block|}
name|sec
operator|=
name|hdr_info
operator|->
name|hdr_sec
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|sec
operator|->
name|size
operator|=
name|EH_FRAME_HDR_SIZE
expr_stmt|;
if|if
condition|(
name|hdr_info
operator|->
name|table
condition|)
name|sec
operator|->
name|size
operator|+=
literal|4
operator|+
name|hdr_info
operator|->
name|fde_count
operator|*
literal|8
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|eh_frame_hdr
operator|=
name|sec
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* This function is called from size_dynamic_sections.    It needs to decide whether .eh_frame_hdr should be output or not,    because when the dynamic symbol table has been sized it is too late    to strip sections.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_elf_maybe_strip_eh_frame_hdr
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|asection
modifier|*
name|o
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|struct
name|eh_frame_hdr_info
modifier|*
name|hdr_info
decl_stmt|;
name|htab
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|hdr_info
operator|=
operator|&
name|htab
operator|->
name|eh_info
expr_stmt|;
if|if
condition|(
name|hdr_info
operator|->
name|hdr_sec
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|bfd_is_abs_section
argument_list|(
name|hdr_info
operator|->
name|hdr_sec
operator|->
name|output_section
argument_list|)
condition|)
block|{
name|hdr_info
operator|->
name|hdr_sec
operator|=
name|NULL
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|abfd
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|eh_frame_hdr
condition|)
for|for
control|(
name|abfd
operator|=
name|info
operator|->
name|input_bfds
init|;
name|abfd
operator|!=
name|NULL
condition|;
name|abfd
operator|=
name|abfd
operator|->
name|link_next
control|)
block|{
comment|/* Count only sections which have at least a single CIE or FDE. 	   There cannot be any CIE or FDE<= 8 bytes.  */
name|o
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".eh_frame"
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|&&
name|o
operator|->
name|size
operator|>
literal|8
operator|&&
operator|!
name|bfd_is_abs_section
argument_list|(
name|o
operator|->
name|output_section
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|abfd
operator|==
name|NULL
condition|)
block|{
name|hdr_info
operator|->
name|hdr_sec
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
name|hdr_info
operator|->
name|hdr_sec
operator|=
name|NULL
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|hdr_info
operator|->
name|table
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Adjust an address in the .eh_frame section.  Given OFFSET within    SEC, this returns the new offset in the adjusted .eh_frame section,    or -1 if the address refers to a CIE/FDE which has been removed    or to offset with dynamic relocation which is no longer needed.  */
end_comment

begin_function
name|bfd_vma
name|_bfd_elf_eh_frame_section_offset
parameter_list|(
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|bfd_vma
name|offset
parameter_list|)
block|{
name|struct
name|eh_frame_sec_info
modifier|*
name|sec_info
decl_stmt|;
name|struct
name|elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|struct
name|eh_frame_hdr_info
modifier|*
name|hdr_info
decl_stmt|;
name|unsigned
name|int
name|lo
decl_stmt|,
name|hi
decl_stmt|,
name|mid
decl_stmt|;
if|if
condition|(
name|sec
operator|->
name|sec_info_type
operator|!=
name|ELF_INFO_TYPE_EH_FRAME
condition|)
return|return
name|offset
return|;
name|sec_info
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|sec_info
expr_stmt|;
if|if
condition|(
name|offset
operator|>=
name|sec
operator|->
name|rawsize
condition|)
return|return
name|offset
operator|-
name|sec
operator|->
name|rawsize
operator|+
name|sec
operator|->
name|size
return|;
name|htab
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|hdr_info
operator|=
operator|&
name|htab
operator|->
name|eh_info
expr_stmt|;
if|if
condition|(
name|hdr_info
operator|->
name|offsets_adjusted
condition|)
name|offset
operator|+=
name|sec
operator|->
name|output_offset
expr_stmt|;
name|lo
operator|=
literal|0
expr_stmt|;
name|hi
operator|=
name|sec_info
operator|->
name|count
expr_stmt|;
name|mid
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|lo
operator|<
name|hi
condition|)
block|{
name|mid
operator|=
operator|(
name|lo
operator|+
name|hi
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|offset
operator|<
name|sec_info
operator|->
name|entry
index|[
name|mid
index|]
operator|.
name|offset
condition|)
name|hi
operator|=
name|mid
expr_stmt|;
elseif|else
if|if
condition|(
name|offset
operator|>=
name|sec_info
operator|->
name|entry
index|[
name|mid
index|]
operator|.
name|offset
operator|+
name|sec_info
operator|->
name|entry
index|[
name|mid
index|]
operator|.
name|size
condition|)
name|lo
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
else|else
break|break;
block|}
name|BFD_ASSERT
argument_list|(
name|lo
operator|<
name|hi
argument_list|)
expr_stmt|;
comment|/* FDE or CIE was removed.  */
if|if
condition|(
name|sec_info
operator|->
name|entry
index|[
name|mid
index|]
operator|.
name|removed
condition|)
return|return
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
return|;
comment|/* If converting to DW_EH_PE_pcrel, there will be no need for run-time      relocation against FDE's initial_location field.  */
if|if
condition|(
operator|!
name|sec_info
operator|->
name|entry
index|[
name|mid
index|]
operator|.
name|cie
operator|&&
name|sec_info
operator|->
name|entry
index|[
name|mid
index|]
operator|.
name|cie_inf
operator|->
name|make_relative
operator|&&
name|offset
operator|==
name|sec_info
operator|->
name|entry
index|[
name|mid
index|]
operator|.
name|offset
operator|+
literal|8
condition|)
return|return
operator|(
name|bfd_vma
operator|)
operator|-
literal|2
return|;
comment|/* If converting LSDA pointers to DW_EH_PE_pcrel, there will be no need      for run-time relocation against LSDA field.  */
if|if
condition|(
operator|!
name|sec_info
operator|->
name|entry
index|[
name|mid
index|]
operator|.
name|cie
operator|&&
name|sec_info
operator|->
name|entry
index|[
name|mid
index|]
operator|.
name|cie_inf
operator|->
name|make_lsda_relative
operator|&&
operator|(
name|offset
operator|==
operator|(
name|sec_info
operator|->
name|entry
index|[
name|mid
index|]
operator|.
name|offset
operator|+
literal|8
operator|+
name|sec_info
operator|->
name|entry
index|[
name|mid
index|]
operator|.
name|lsda_offset
operator|)
operator|)
operator|&&
operator|(
name|sec_info
operator|->
name|entry
index|[
name|mid
index|]
operator|.
name|cie_inf
operator|->
name|need_lsda_relative
operator|||
operator|!
name|hdr_info
operator|->
name|offsets_adjusted
operator|)
condition|)
block|{
name|sec_info
operator|->
name|entry
index|[
name|mid
index|]
operator|.
name|cie_inf
operator|->
name|need_lsda_relative
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|bfd_vma
operator|)
operator|-
literal|2
return|;
block|}
comment|/* If converting to DW_EH_PE_pcrel, there will be no need for run-time      relocation against DW_CFA_set_loc's arguments.  */
if|if
condition|(
name|sec_info
operator|->
name|entry
index|[
name|mid
index|]
operator|.
name|set_loc
operator|&&
operator|(
name|sec_info
operator|->
name|entry
index|[
name|mid
index|]
operator|.
name|cie
condition|?
name|sec_info
operator|->
name|entry
index|[
name|mid
index|]
operator|.
name|make_relative
else|:
name|sec_info
operator|->
name|entry
index|[
name|mid
index|]
operator|.
name|cie_inf
operator|->
name|make_relative
operator|)
operator|&&
operator|(
name|offset
operator|>=
name|sec_info
operator|->
name|entry
index|[
name|mid
index|]
operator|.
name|offset
operator|+
literal|8
operator|+
name|sec_info
operator|->
name|entry
index|[
name|mid
index|]
operator|.
name|set_loc
index|[
literal|1
index|]
operator|)
condition|)
block|{
name|unsigned
name|int
name|cnt
decl_stmt|;
for|for
control|(
name|cnt
operator|=
literal|1
init|;
name|cnt
operator|<=
name|sec_info
operator|->
name|entry
index|[
name|mid
index|]
operator|.
name|set_loc
index|[
literal|0
index|]
condition|;
name|cnt
operator|++
control|)
if|if
condition|(
name|offset
operator|==
name|sec_info
operator|->
name|entry
index|[
name|mid
index|]
operator|.
name|offset
operator|+
literal|8
operator|+
name|sec_info
operator|->
name|entry
index|[
name|mid
index|]
operator|.
name|set_loc
index|[
name|cnt
index|]
condition|)
return|return
operator|(
name|bfd_vma
operator|)
operator|-
literal|2
return|;
block|}
if|if
condition|(
name|hdr_info
operator|->
name|offsets_adjusted
condition|)
name|offset
operator|-=
name|sec
operator|->
name|output_offset
expr_stmt|;
comment|/* Any new augmentation bytes go before the first relocation.  */
return|return
operator|(
name|offset
operator|+
name|sec_info
operator|->
name|entry
index|[
name|mid
index|]
operator|.
name|new_offset
operator|-
name|sec_info
operator|->
name|entry
index|[
name|mid
index|]
operator|.
name|offset
operator|+
name|extra_augmentation_string_bytes
argument_list|(
name|sec_info
operator|->
name|entry
operator|+
name|mid
argument_list|)
operator|+
name|extra_augmentation_data_bytes
argument_list|(
name|sec_info
operator|->
name|entry
operator|+
name|mid
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Write out .eh_frame section.  This is called with the relocated    contents.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_elf_write_section_eh_frame
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|)
block|{
name|struct
name|eh_frame_sec_info
modifier|*
name|sec_info
decl_stmt|;
name|struct
name|elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|struct
name|eh_frame_hdr_info
modifier|*
name|hdr_info
decl_stmt|;
name|unsigned
name|int
name|ptr_size
decl_stmt|;
name|struct
name|eh_cie_fde
modifier|*
name|ent
decl_stmt|;
if|if
condition|(
name|sec
operator|->
name|sec_info_type
operator|!=
name|ELF_INFO_TYPE_EH_FRAME
condition|)
return|return
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|sec
operator|->
name|output_section
argument_list|,
name|contents
argument_list|,
name|sec
operator|->
name|output_offset
argument_list|,
name|sec
operator|->
name|size
argument_list|)
return|;
name|ptr_size
operator|=
operator|(
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_backend_eh_frame_address_size
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|ptr_size
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|sec_info
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|sec_info
expr_stmt|;
name|htab
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|hdr_info
operator|=
operator|&
name|htab
operator|->
name|eh_info
expr_stmt|;
comment|/* First convert all offsets to output section offsets, so that a      CIE offset is valid if the CIE is used by a FDE from some other      section.  This can happen when duplicate CIEs are deleted in      _bfd_elf_discard_section_eh_frame.  We do all sections here because      this function might not be called on sections in the same order as      _bfd_elf_discard_section_eh_frame.  */
if|if
condition|(
operator|!
name|hdr_info
operator|->
name|offsets_adjusted
condition|)
block|{
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|asection
modifier|*
name|eh
decl_stmt|;
name|struct
name|eh_frame_sec_info
modifier|*
name|eh_inf
decl_stmt|;
for|for
control|(
name|ibfd
operator|=
name|info
operator|->
name|input_bfds
init|;
name|ibfd
operator|!=
name|NULL
condition|;
name|ibfd
operator|=
name|ibfd
operator|->
name|link_next
control|)
block|{
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|ibfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
operator|||
operator|(
name|ibfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
condition|)
continue|continue;
name|eh
operator|=
name|bfd_get_section_by_name
argument_list|(
name|ibfd
argument_list|,
literal|".eh_frame"
argument_list|)
expr_stmt|;
if|if
condition|(
name|eh
operator|==
name|NULL
operator|||
name|eh
operator|->
name|sec_info_type
operator|!=
name|ELF_INFO_TYPE_EH_FRAME
condition|)
continue|continue;
name|eh_inf
operator|=
name|elf_section_data
argument_list|(
name|eh
argument_list|)
operator|->
name|sec_info
expr_stmt|;
for|for
control|(
name|ent
operator|=
name|eh_inf
operator|->
name|entry
init|;
name|ent
operator|<
name|eh_inf
operator|->
name|entry
operator|+
name|eh_inf
operator|->
name|count
condition|;
operator|++
name|ent
control|)
block|{
name|ent
operator|->
name|offset
operator|+=
name|eh
operator|->
name|output_offset
expr_stmt|;
name|ent
operator|->
name|new_offset
operator|+=
name|eh
operator|->
name|output_offset
expr_stmt|;
block|}
block|}
name|hdr_info
operator|->
name|offsets_adjusted
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|hdr_info
operator|->
name|table
operator|&&
name|hdr_info
operator|->
name|array
operator|==
name|NULL
condition|)
name|hdr_info
operator|->
name|array
operator|=
name|bfd_malloc
argument_list|(
name|hdr_info
operator|->
name|fde_count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|hdr_info
operator|->
name|array
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr_info
operator|->
name|array
operator|==
name|NULL
condition|)
name|hdr_info
operator|=
name|NULL
expr_stmt|;
comment|/* The new offsets can be bigger or smaller than the original offsets.      We therefore need to make two passes over the section: one backward      pass to move entries up and one forward pass to move entries down.      The two passes won't interfere with each other because entries are      not reordered  */
for|for
control|(
name|ent
operator|=
name|sec_info
operator|->
name|entry
operator|+
name|sec_info
operator|->
name|count
init|;
name|ent
operator|--
operator|!=
name|sec_info
operator|->
name|entry
condition|;
control|)
if|if
condition|(
operator|!
name|ent
operator|->
name|removed
operator|&&
name|ent
operator|->
name|new_offset
operator|>
name|ent
operator|->
name|offset
condition|)
name|memmove
argument_list|(
name|contents
operator|+
name|ent
operator|->
name|new_offset
operator|-
name|sec
operator|->
name|output_offset
argument_list|,
name|contents
operator|+
name|ent
operator|->
name|offset
operator|-
name|sec
operator|->
name|output_offset
argument_list|,
name|ent
operator|->
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|ent
operator|=
name|sec_info
operator|->
name|entry
init|;
name|ent
operator|<
name|sec_info
operator|->
name|entry
operator|+
name|sec_info
operator|->
name|count
condition|;
operator|++
name|ent
control|)
if|if
condition|(
operator|!
name|ent
operator|->
name|removed
operator|&&
name|ent
operator|->
name|new_offset
operator|<
name|ent
operator|->
name|offset
condition|)
name|memmove
argument_list|(
name|contents
operator|+
name|ent
operator|->
name|new_offset
operator|-
name|sec
operator|->
name|output_offset
argument_list|,
name|contents
operator|+
name|ent
operator|->
name|offset
operator|-
name|sec
operator|->
name|output_offset
argument_list|,
name|ent
operator|->
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|ent
operator|=
name|sec_info
operator|->
name|entry
init|;
name|ent
operator|<
name|sec_info
operator|->
name|entry
operator|+
name|sec_info
operator|->
name|count
condition|;
operator|++
name|ent
control|)
block|{
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|unsigned
name|int
name|new_size
decl_stmt|;
if|if
condition|(
name|ent
operator|->
name|removed
condition|)
continue|continue;
if|if
condition|(
name|ent
operator|->
name|size
operator|==
literal|4
condition|)
block|{
comment|/* Any terminating FDE must be at the end of the section.  */
name|BFD_ASSERT
argument_list|(
name|ent
operator|==
name|sec_info
operator|->
name|entry
operator|+
name|sec_info
operator|->
name|count
operator|-
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|buf
operator|=
name|contents
operator|+
name|ent
operator|->
name|new_offset
operator|-
name|sec
operator|->
name|output_offset
expr_stmt|;
name|end
operator|=
name|buf
operator|+
name|ent
operator|->
name|size
expr_stmt|;
name|new_size
operator|=
name|size_of_output_cie_fde
argument_list|(
name|ent
argument_list|,
name|ptr_size
argument_list|)
expr_stmt|;
comment|/* Update the size.  It may be shrinked.  */
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|new_size
operator|-
literal|4
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* Filling the extra bytes with DW_CFA_nops.  */
if|if
condition|(
name|new_size
operator|!=
name|ent
operator|->
name|size
condition|)
name|memset
argument_list|(
name|end
argument_list|,
literal|0
argument_list|,
name|new_size
operator|-
name|ent
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ent
operator|->
name|cie
condition|)
block|{
comment|/* CIE */
if|if
condition|(
name|ent
operator|->
name|make_relative
operator|||
name|ent
operator|->
name|need_lsda_relative
operator|||
name|ent
operator|->
name|per_encoding_relative
condition|)
block|{
name|char
modifier|*
name|aug
decl_stmt|;
name|unsigned
name|int
name|action
decl_stmt|,
name|extra_string
decl_stmt|,
name|extra_data
decl_stmt|;
name|unsigned
name|int
name|per_width
decl_stmt|,
name|per_encoding
decl_stmt|;
comment|/* Need to find 'R' or 'L' augmentation's argument and modify 		 DW_EH_PE_* value.  */
name|action
operator|=
operator|(
operator|(
name|ent
operator|->
name|make_relative
condition|?
literal|1
else|:
literal|0
operator|)
operator||
operator|(
name|ent
operator|->
name|need_lsda_relative
condition|?
literal|2
else|:
literal|0
operator|)
operator||
operator|(
name|ent
operator|->
name|per_encoding_relative
condition|?
literal|4
else|:
literal|0
operator|)
operator|)
expr_stmt|;
name|extra_string
operator|=
name|extra_augmentation_string_bytes
argument_list|(
name|ent
argument_list|)
expr_stmt|;
name|extra_data
operator|=
name|extra_augmentation_data_bytes
argument_list|(
name|ent
argument_list|)
expr_stmt|;
comment|/* Skip length, id and version.  */
name|buf
operator|+=
literal|9
expr_stmt|;
name|aug
operator|=
operator|(
name|char
operator|*
operator|)
name|buf
expr_stmt|;
name|buf
operator|+=
name|strlen
argument_list|(
name|aug
argument_list|)
operator|+
literal|1
expr_stmt|;
name|skip_leb128
argument_list|(
operator|&
name|buf
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|skip_leb128
argument_list|(
operator|&
name|buf
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|skip_leb128
argument_list|(
operator|&
name|buf
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|aug
operator|==
literal|'z'
condition|)
block|{
comment|/* The uleb128 will always be a single byte for the kind 		     of augmentation strings that we're prepared to handle.  */
operator|*
name|buf
operator|++
operator|+=
name|extra_data
expr_stmt|;
name|aug
operator|++
expr_stmt|;
block|}
comment|/* Make room for the new augmentation string and data bytes.  */
name|memmove
argument_list|(
name|buf
operator|+
name|extra_string
operator|+
name|extra_data
argument_list|,
name|buf
argument_list|,
name|end
operator|-
name|buf
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|aug
operator|+
name|extra_string
argument_list|,
name|aug
argument_list|,
name|buf
operator|-
operator|(
name|bfd_byte
operator|*
operator|)
name|aug
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|extra_string
expr_stmt|;
name|end
operator|+=
name|extra_string
operator|+
name|extra_data
expr_stmt|;
if|if
condition|(
name|ent
operator|->
name|add_augmentation_size
condition|)
block|{
operator|*
name|aug
operator|++
operator|=
literal|'z'
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|extra_data
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ent
operator|->
name|add_fde_encoding
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|action
operator|&
literal|1
argument_list|)
expr_stmt|;
operator|*
name|aug
operator|++
operator|=
literal|'R'
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|DW_EH_PE_pcrel
expr_stmt|;
name|action
operator|&=
operator|~
literal|1
expr_stmt|;
block|}
while|while
condition|(
name|action
condition|)
switch|switch
condition|(
operator|*
name|aug
operator|++
condition|)
block|{
case|case
literal|'L'
case|:
if|if
condition|(
name|action
operator|&
literal|2
condition|)
block|{
name|BFD_ASSERT
argument_list|(
operator|*
name|buf
operator|==
name|ent
operator|->
name|lsda_encoding
argument_list|)
expr_stmt|;
operator|*
name|buf
operator||=
name|DW_EH_PE_pcrel
expr_stmt|;
name|action
operator|&=
operator|~
literal|2
expr_stmt|;
block|}
name|buf
operator|++
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|per_encoding
operator|=
operator|*
name|buf
operator|++
expr_stmt|;
name|per_width
operator|=
name|get_DW_EH_PE_width
argument_list|(
name|per_encoding
argument_list|,
name|ptr_size
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|per_width
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
operator|(
operator|(
name|per_encoding
operator|&
literal|0x70
operator|)
operator|==
name|DW_EH_PE_pcrel
operator|)
operator|==
name|ent
operator|->
name|per_encoding_relative
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|per_encoding
operator|&
literal|0xf0
operator|)
operator|==
name|DW_EH_PE_aligned
condition|)
name|buf
operator|=
operator|(
name|contents
operator|+
operator|(
operator|(
name|buf
operator|-
name|contents
operator|+
name|per_width
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
operator|(
name|bfd_size_type
operator|)
name|per_width
operator|-
literal|1
operator|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|action
operator|&
literal|4
condition|)
block|{
name|bfd_vma
name|val
decl_stmt|;
name|val
operator|=
name|read_value
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|,
name|per_width
argument_list|,
name|get_DW_EH_PE_signed
argument_list|(
name|per_encoding
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|+=
operator|(
name|bfd_vma
operator|)
name|ent
operator|->
name|offset
operator|-
name|ent
operator|->
name|new_offset
expr_stmt|;
name|val
operator|-=
name|extra_string
operator|+
name|extra_data
expr_stmt|;
name|write_value
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|,
name|val
argument_list|,
name|per_width
argument_list|)
expr_stmt|;
name|action
operator|&=
operator|~
literal|4
expr_stmt|;
block|}
name|buf
operator|+=
name|per_width
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
if|if
condition|(
name|action
operator|&
literal|1
condition|)
block|{
name|BFD_ASSERT
argument_list|(
operator|*
name|buf
operator|==
name|ent
operator|->
name|fde_encoding
argument_list|)
expr_stmt|;
operator|*
name|buf
operator||=
name|DW_EH_PE_pcrel
expr_stmt|;
name|action
operator|&=
operator|~
literal|1
expr_stmt|;
block|}
name|buf
operator|++
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
break|break;
default|default:
name|BFD_FAIL
argument_list|()
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* FDE */
name|bfd_vma
name|value
decl_stmt|,
name|address
decl_stmt|;
name|unsigned
name|int
name|width
decl_stmt|;
name|bfd_byte
modifier|*
name|start
decl_stmt|;
comment|/* Skip length.  */
name|buf
operator|+=
literal|4
expr_stmt|;
name|value
operator|=
name|ent
operator|->
name|new_offset
operator|+
literal|4
operator|-
name|ent
operator|->
name|cie_inf
operator|->
name|new_offset
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|value
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|+=
literal|4
expr_stmt|;
name|width
operator|=
name|get_DW_EH_PE_width
argument_list|(
name|ent
operator|->
name|fde_encoding
argument_list|,
name|ptr_size
argument_list|)
expr_stmt|;
name|value
operator|=
name|read_value
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|,
name|width
argument_list|,
name|get_DW_EH_PE_signed
argument_list|(
name|ent
operator|->
name|fde_encoding
argument_list|)
argument_list|)
expr_stmt|;
name|address
operator|=
name|value
expr_stmt|;
if|if
condition|(
name|value
condition|)
block|{
switch|switch
condition|(
name|ent
operator|->
name|fde_encoding
operator|&
literal|0xf0
condition|)
block|{
case|case
name|DW_EH_PE_indirect
case|:
case|case
name|DW_EH_PE_textrel
case|:
name|BFD_ASSERT
argument_list|(
name|hdr_info
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_EH_PE_datarel
case|:
block|{
name|asection
modifier|*
name|got
init|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".got"
argument_list|)
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|got
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|address
operator|+=
name|got
operator|->
name|vma
expr_stmt|;
block|}
break|break;
case|case
name|DW_EH_PE_pcrel
case|:
name|value
operator|+=
operator|(
name|bfd_vma
operator|)
name|ent
operator|->
name|offset
operator|-
name|ent
operator|->
name|new_offset
expr_stmt|;
name|address
operator|+=
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|ent
operator|->
name|offset
operator|+
literal|8
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ent
operator|->
name|cie_inf
operator|->
name|make_relative
condition|)
name|value
operator|-=
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|ent
operator|->
name|new_offset
operator|+
literal|8
expr_stmt|;
name|write_value
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|,
name|value
argument_list|,
name|width
argument_list|)
expr_stmt|;
block|}
name|start
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|hdr_info
condition|)
block|{
name|hdr_info
operator|->
name|array
index|[
name|hdr_info
operator|->
name|array_count
index|]
operator|.
name|initial_loc
operator|=
name|address
expr_stmt|;
name|hdr_info
operator|->
name|array
index|[
name|hdr_info
operator|->
name|array_count
operator|++
index|]
operator|.
name|fde
operator|=
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|ent
operator|->
name|new_offset
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ent
operator|->
name|lsda_encoding
operator|&
literal|0xf0
operator|)
operator|==
name|DW_EH_PE_pcrel
operator|||
name|ent
operator|->
name|cie_inf
operator|->
name|need_lsda_relative
condition|)
block|{
name|buf
operator|+=
name|ent
operator|->
name|lsda_offset
expr_stmt|;
name|width
operator|=
name|get_DW_EH_PE_width
argument_list|(
name|ent
operator|->
name|lsda_encoding
argument_list|,
name|ptr_size
argument_list|)
expr_stmt|;
name|value
operator|=
name|read_value
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|,
name|width
argument_list|,
name|get_DW_EH_PE_signed
argument_list|(
name|ent
operator|->
name|lsda_encoding
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
block|{
if|if
condition|(
operator|(
name|ent
operator|->
name|lsda_encoding
operator|&
literal|0xf0
operator|)
operator|==
name|DW_EH_PE_pcrel
condition|)
name|value
operator|+=
operator|(
name|bfd_vma
operator|)
name|ent
operator|->
name|offset
operator|-
name|ent
operator|->
name|new_offset
expr_stmt|;
elseif|else
if|if
condition|(
name|ent
operator|->
name|cie_inf
operator|->
name|need_lsda_relative
condition|)
name|value
operator|-=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|ent
operator|->
name|new_offset
operator|+
literal|8
operator|+
name|ent
operator|->
name|lsda_offset
operator|)
expr_stmt|;
name|write_value
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|,
name|value
argument_list|,
name|width
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ent
operator|->
name|cie_inf
operator|->
name|add_augmentation_size
condition|)
block|{
comment|/* Skip the PC and length and insert a zero byte for the 		 augmentation size.  */
name|buf
operator|+=
name|width
operator|*
literal|2
expr_stmt|;
name|memmove
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
name|buf
argument_list|,
name|end
operator|-
name|buf
argument_list|)
expr_stmt|;
operator|*
name|buf
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ent
operator|->
name|set_loc
condition|)
block|{
comment|/* Adjust DW_CFA_set_loc.  */
name|unsigned
name|int
name|cnt
decl_stmt|,
name|width
decl_stmt|;
name|bfd_vma
name|new_offset
decl_stmt|;
name|width
operator|=
name|get_DW_EH_PE_width
argument_list|(
name|ent
operator|->
name|fde_encoding
argument_list|,
name|ptr_size
argument_list|)
expr_stmt|;
name|new_offset
operator|=
name|ent
operator|->
name|new_offset
operator|+
literal|8
operator|+
name|extra_augmentation_string_bytes
argument_list|(
name|ent
argument_list|)
operator|+
name|extra_augmentation_data_bytes
argument_list|(
name|ent
argument_list|)
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|1
init|;
name|cnt
operator|<=
name|ent
operator|->
name|set_loc
index|[
literal|0
index|]
condition|;
name|cnt
operator|++
control|)
block|{
name|bfd_vma
name|value
decl_stmt|;
name|buf
operator|=
name|start
operator|+
name|ent
operator|->
name|set_loc
index|[
name|cnt
index|]
expr_stmt|;
name|value
operator|=
name|read_value
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|,
name|width
argument_list|,
name|get_DW_EH_PE_signed
argument_list|(
name|ent
operator|->
name|fde_encoding
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|value
condition|)
continue|continue;
if|if
condition|(
operator|(
name|ent
operator|->
name|fde_encoding
operator|&
literal|0xf0
operator|)
operator|==
name|DW_EH_PE_pcrel
condition|)
name|value
operator|+=
name|ent
operator|->
name|offset
operator|+
literal|8
operator|-
name|new_offset
expr_stmt|;
if|if
condition|(
name|ent
operator|->
name|cie_inf
operator|->
name|make_relative
condition|)
name|value
operator|-=
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|new_offset
operator|+
name|ent
operator|->
name|set_loc
index|[
name|cnt
index|]
expr_stmt|;
name|write_value
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|,
name|value
argument_list|,
name|width
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* We don't align the section to its section alignment since the      runtime library only expects all CIE/FDE records aligned at      the pointer size. _bfd_elf_discard_section_eh_frame should      have padded CIE/FDE records to multiple of pointer size with      size_of_output_cie_fde.  */
if|if
condition|(
operator|(
name|sec
operator|->
name|size
operator|%
name|ptr_size
operator|)
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|sec
operator|->
name|output_section
argument_list|,
name|contents
argument_list|,
operator|(
name|file_ptr
operator|)
name|sec
operator|->
name|output_offset
argument_list|,
name|sec
operator|->
name|size
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Helper function used to sort .eh_frame_hdr search table by increasing    VMA of FDE initial location.  */
end_comment

begin_function
specifier|static
name|int
name|vma_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
specifier|const
name|struct
name|eh_frame_array_ent
modifier|*
name|p
init|=
name|a
decl_stmt|;
specifier|const
name|struct
name|eh_frame_array_ent
modifier|*
name|q
init|=
name|b
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|initial_loc
operator|>
name|q
operator|->
name|initial_loc
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|p
operator|->
name|initial_loc
operator|<
name|q
operator|->
name|initial_loc
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Write out .eh_frame_hdr section.  This must be called after    _bfd_elf_write_section_eh_frame has been called on all input    .eh_frame sections.    .eh_frame_hdr format:    ubyte version		(currently 1)    ubyte eh_frame_ptr_enc  	(DW_EH_PE_* encoding of pointer to start of 				 .eh_frame section)    ubyte fde_count_enc		(DW_EH_PE_* encoding of total FDE count 				 number (or DW_EH_PE_omit if there is no 				 binary search table computed))    ubyte table_enc		(DW_EH_PE_* encoding of binary search table, 				 or DW_EH_PE_omit if not present. 				 DW_EH_PE_datarel is using address of 				 .eh_frame_hdr section start as base)    [encoded] eh_frame_ptr	(pointer to start of .eh_frame section)    optionally followed by:    [encoded] fde_count		(total number of FDEs in .eh_frame section)    fde_count x [encoded] initial_loc, fde 				(array of encoded pairs containing 				 FDE initial_location field and FDE address, 				 sorted by increasing initial_loc).  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_elf_write_section_eh_frame_hdr
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|struct
name|eh_frame_hdr_info
modifier|*
name|hdr_info
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|asection
modifier|*
name|eh_frame_sec
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
name|bfd_boolean
name|retval
decl_stmt|;
name|bfd_vma
name|encoded_eh_frame
decl_stmt|;
name|htab
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|hdr_info
operator|=
operator|&
name|htab
operator|->
name|eh_info
expr_stmt|;
name|sec
operator|=
name|hdr_info
operator|->
name|hdr_sec
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
name|size
operator|=
name|EH_FRAME_HDR_SIZE
expr_stmt|;
if|if
condition|(
name|hdr_info
operator|->
name|array
operator|&&
name|hdr_info
operator|->
name|array_count
operator|==
name|hdr_info
operator|->
name|fde_count
condition|)
name|size
operator|+=
literal|4
operator|+
name|hdr_info
operator|->
name|fde_count
operator|*
literal|8
expr_stmt|;
name|contents
operator|=
name|bfd_malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|eh_frame_sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".eh_frame"
argument_list|)
expr_stmt|;
if|if
condition|(
name|eh_frame_sec
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|memset
argument_list|(
name|contents
argument_list|,
literal|0
argument_list|,
name|EH_FRAME_HDR_SIZE
argument_list|)
expr_stmt|;
name|contents
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Version.  */
name|contents
index|[
literal|1
index|]
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_backend_encode_eh_address
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|eh_frame_sec
argument_list|,
literal|0
argument_list|,
name|sec
argument_list|,
literal|4
argument_list|,
operator|&
name|encoded_eh_frame
argument_list|)
expr_stmt|;
comment|/* .eh_frame offset.  */
if|if
condition|(
name|hdr_info
operator|->
name|array
operator|&&
name|hdr_info
operator|->
name|array_count
operator|==
name|hdr_info
operator|->
name|fde_count
condition|)
block|{
name|contents
index|[
literal|2
index|]
operator|=
name|DW_EH_PE_udata4
expr_stmt|;
comment|/* FDE count encoding.  */
name|contents
index|[
literal|3
index|]
operator|=
name|DW_EH_PE_datarel
operator||
name|DW_EH_PE_sdata4
expr_stmt|;
comment|/* Search table enc.  */
block|}
else|else
block|{
name|contents
index|[
literal|2
index|]
operator|=
name|DW_EH_PE_omit
expr_stmt|;
name|contents
index|[
literal|3
index|]
operator|=
name|DW_EH_PE_omit
expr_stmt|;
block|}
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|encoded_eh_frame
argument_list|,
name|contents
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
index|[
literal|2
index|]
operator|!=
name|DW_EH_PE_omit
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|hdr_info
operator|->
name|fde_count
argument_list|,
name|contents
operator|+
name|EH_FRAME_HDR_SIZE
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|hdr_info
operator|->
name|array
argument_list|,
name|hdr_info
operator|->
name|fde_count
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hdr_info
operator|->
name|array
argument_list|)
argument_list|,
name|vma_compare
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hdr_info
operator|->
name|fde_count
condition|;
name|i
operator|++
control|)
block|{
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|hdr_info
operator|->
name|array
index|[
name|i
index|]
operator|.
name|initial_loc
operator|-
name|sec
operator|->
name|output_section
operator|->
name|vma
argument_list|,
name|contents
operator|+
name|EH_FRAME_HDR_SIZE
operator|+
name|i
operator|*
literal|8
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|hdr_info
operator|->
name|array
index|[
name|i
index|]
operator|.
name|fde
operator|-
name|sec
operator|->
name|output_section
operator|->
name|vma
argument_list|,
name|contents
operator|+
name|EH_FRAME_HDR_SIZE
operator|+
name|i
operator|*
literal|8
operator|+
literal|8
argument_list|)
expr_stmt|;
block|}
block|}
name|retval
operator|=
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|sec
operator|->
name|output_section
argument_list|,
name|contents
argument_list|,
operator|(
name|file_ptr
operator|)
name|sec
operator|->
name|output_offset
argument_list|,
name|sec
operator|->
name|size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Return the width of FDE addresses.  This is the default implementation.  */
end_comment

begin_function
name|unsigned
name|int
name|_bfd_elf_eh_frame_address_size
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_ident
index|[
name|EI_CLASS
index|]
operator|==
name|ELFCLASS64
condition|?
literal|8
else|:
literal|4
return|;
block|}
end_function

begin_comment
comment|/* Decide whether we can use a PC-relative encoding within the given    EH frame section.  This is the default implementation.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_elf_can_make_relative
parameter_list|(
name|bfd
modifier|*
name|input_bfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|eh_frame_section
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Select an encoding for the given address.  Preference is given to    PC-relative addressing modes.  */
end_comment

begin_function
name|bfd_byte
name|_bfd_elf_encode_eh_address
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|osec
parameter_list|,
name|bfd_vma
name|offset
parameter_list|,
name|asection
modifier|*
name|loc_sec
parameter_list|,
name|bfd_vma
name|loc_offset
parameter_list|,
name|bfd_vma
modifier|*
name|encoded
parameter_list|)
block|{
operator|*
name|encoded
operator|=
name|osec
operator|->
name|vma
operator|+
name|offset
operator|-
operator|(
name|loc_sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|loc_sec
operator|->
name|output_offset
operator|+
name|loc_offset
operator|)
expr_stmt|;
return|return
name|DW_EH_PE_pcrel
operator||
name|DW_EH_PE_sdata4
return|;
block|}
end_function

end_unit

