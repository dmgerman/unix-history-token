begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* .eh_frame section optimization.    Copyright 2001, 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.    Written by Jakub Jelinek<jakub@redhat.com>.     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf/dwarf2.h"
end_include

begin_define
define|#
directive|define
name|EH_FRAME_HDR_SIZE
value|8
end_define

begin_comment
comment|/* If *ITER hasn't reached END yet, read the next byte into *RESULT and    move onto the next byte.  Return true on success.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bfd_boolean
name|read_byte
parameter_list|(
name|bfd_byte
modifier|*
modifier|*
name|iter
parameter_list|,
name|bfd_byte
modifier|*
name|end
parameter_list|,
name|unsigned
name|char
modifier|*
name|result
parameter_list|)
block|{
if|if
condition|(
operator|*
name|iter
operator|>=
name|end
condition|)
return|return
name|FALSE
return|;
operator|*
name|result
operator|=
operator|*
operator|(
operator|(
operator|*
name|iter
operator|)
operator|++
operator|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Move *ITER over LENGTH bytes, or up to END, whichever is closer.    Return true it was possible to move LENGTH bytes.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bfd_boolean
name|skip_bytes
parameter_list|(
name|bfd_byte
modifier|*
modifier|*
name|iter
parameter_list|,
name|bfd_byte
modifier|*
name|end
parameter_list|,
name|bfd_size_type
name|length
parameter_list|)
block|{
if|if
condition|(
call|(
name|bfd_size_type
call|)
argument_list|(
name|end
operator|-
operator|*
name|iter
argument_list|)
operator|<
name|length
condition|)
block|{
operator|*
name|iter
operator|=
name|end
expr_stmt|;
return|return
name|FALSE
return|;
block|}
operator|*
name|iter
operator|+=
name|length
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Move *ITER over an leb128, stopping at END.  Return true if the end    of the leb128 was found.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|skip_leb128
parameter_list|(
name|bfd_byte
modifier|*
modifier|*
name|iter
parameter_list|,
name|bfd_byte
modifier|*
name|end
parameter_list|)
block|{
name|unsigned
name|char
name|byte
decl_stmt|;
do|do
if|if
condition|(
operator|!
name|read_byte
argument_list|(
name|iter
argument_list|,
name|end
argument_list|,
operator|&
name|byte
argument_list|)
condition|)
return|return
name|FALSE
return|;
do|while
condition|(
name|byte
operator|&
literal|0x80
condition|)
do|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Like skip_leb128, but treat the leb128 as an unsigned value and    store it in *VALUE.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|read_uleb128
parameter_list|(
name|bfd_byte
modifier|*
modifier|*
name|iter
parameter_list|,
name|bfd_byte
modifier|*
name|end
parameter_list|,
name|bfd_vma
modifier|*
name|value
parameter_list|)
block|{
name|bfd_byte
modifier|*
name|start
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|start
operator|=
operator|*
name|iter
expr_stmt|;
if|if
condition|(
operator|!
name|skip_leb128
argument_list|(
name|iter
argument_list|,
name|end
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|p
operator|=
operator|*
name|iter
expr_stmt|;
operator|*
name|value
operator|=
operator|*
operator|--
name|p
expr_stmt|;
while|while
condition|(
name|p
operator|>
name|start
condition|)
operator|*
name|value
operator|=
operator|(
operator|*
name|value
operator|<<
literal|7
operator|)
operator||
operator|(
operator|*
operator|--
name|p
operator|&
literal|0x7f
operator|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Like read_uleb128, but for signed values.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|read_sleb128
parameter_list|(
name|bfd_byte
modifier|*
modifier|*
name|iter
parameter_list|,
name|bfd_byte
modifier|*
name|end
parameter_list|,
name|bfd_signed_vma
modifier|*
name|value
parameter_list|)
block|{
name|bfd_byte
modifier|*
name|start
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|start
operator|=
operator|*
name|iter
expr_stmt|;
if|if
condition|(
operator|!
name|skip_leb128
argument_list|(
name|iter
argument_list|,
name|end
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|p
operator|=
operator|*
name|iter
expr_stmt|;
operator|*
name|value
operator|=
operator|(
operator|(
operator|*
operator|--
name|p
operator|&
literal|0x7f
operator|)
operator|^
literal|0x40
operator|)
operator|-
literal|0x40
expr_stmt|;
while|while
condition|(
name|p
operator|>
name|start
condition|)
operator|*
name|value
operator|=
operator|(
operator|*
name|value
operator|<<
literal|7
operator|)
operator||
operator|(
operator|*
operator|--
name|p
operator|&
literal|0x7f
operator|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return 0 if either encoding is variable width, or not yet known to bfd.  */
end_comment

begin_function
specifier|static
name|int
name|get_DW_EH_PE_width
parameter_list|(
name|int
name|encoding
parameter_list|,
name|int
name|ptr_size
parameter_list|)
block|{
comment|/* DW_EH_PE_ values of 0x60 and 0x70 weren't defined at the time .eh_frame      was added to bfd.  */
if|if
condition|(
operator|(
name|encoding
operator|&
literal|0x60
operator|)
operator|==
literal|0x60
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|encoding
operator|&
literal|7
condition|)
block|{
case|case
name|DW_EH_PE_udata2
case|:
return|return
literal|2
return|;
case|case
name|DW_EH_PE_udata4
case|:
return|return
literal|4
return|;
case|case
name|DW_EH_PE_udata8
case|:
return|return
literal|8
return|;
case|case
name|DW_EH_PE_absptr
case|:
return|return
name|ptr_size
return|;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|get_DW_EH_PE_signed
parameter_list|(
name|encoding
parameter_list|)
value|(((encoding)& DW_EH_PE_signed) != 0)
end_define

begin_comment
comment|/* Read a width sized value from memory.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|read_value
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_byte
modifier|*
name|buf
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|is_signed
parameter_list|)
block|{
name|bfd_vma
name|value
decl_stmt|;
switch|switch
condition|(
name|width
condition|)
block|{
case|case
literal|2
case|:
if|if
condition|(
name|is_signed
condition|)
name|value
operator|=
name|bfd_get_signed_16
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|)
expr_stmt|;
else|else
name|value
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
if|if
condition|(
name|is_signed
condition|)
name|value
operator|=
name|bfd_get_signed_32
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|)
expr_stmt|;
else|else
name|value
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
if|if
condition|(
name|is_signed
condition|)
name|value
operator|=
name|bfd_get_signed_64
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|)
expr_stmt|;
else|else
name|value
operator|=
name|bfd_get_64
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
default|default:
name|BFD_FAIL
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* Store a width sized value to memory.  */
end_comment

begin_function
specifier|static
name|void
name|write_value
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_byte
modifier|*
name|buf
parameter_list|,
name|bfd_vma
name|value
parameter_list|,
name|int
name|width
parameter_list|)
block|{
switch|switch
condition|(
name|width
condition|)
block|{
case|case
literal|2
case|:
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|value
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|value
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|bfd_put_64
argument_list|(
name|abfd
argument_list|,
name|value
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
default|default:
name|BFD_FAIL
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return zero if C1 and C2 CIEs can be merged.  */
end_comment

begin_function
specifier|static
name|int
name|cie_compare
parameter_list|(
name|struct
name|cie
modifier|*
name|c1
parameter_list|,
name|struct
name|cie
modifier|*
name|c2
parameter_list|)
block|{
if|if
condition|(
name|c1
operator|->
name|hdr
operator|.
name|length
operator|==
name|c2
operator|->
name|hdr
operator|.
name|length
operator|&&
name|c1
operator|->
name|version
operator|==
name|c2
operator|->
name|version
operator|&&
name|strcmp
argument_list|(
name|c1
operator|->
name|augmentation
argument_list|,
name|c2
operator|->
name|augmentation
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|c1
operator|->
name|augmentation
argument_list|,
literal|"eh"
argument_list|)
operator|!=
literal|0
operator|&&
name|c1
operator|->
name|code_align
operator|==
name|c2
operator|->
name|code_align
operator|&&
name|c1
operator|->
name|data_align
operator|==
name|c2
operator|->
name|data_align
operator|&&
name|c1
operator|->
name|ra_column
operator|==
name|c2
operator|->
name|ra_column
operator|&&
name|c1
operator|->
name|augmentation_size
operator|==
name|c2
operator|->
name|augmentation_size
operator|&&
name|c1
operator|->
name|personality
operator|==
name|c2
operator|->
name|personality
operator|&&
name|c1
operator|->
name|per_encoding
operator|==
name|c2
operator|->
name|per_encoding
operator|&&
name|c1
operator|->
name|lsda_encoding
operator|==
name|c2
operator|->
name|lsda_encoding
operator|&&
name|c1
operator|->
name|fde_encoding
operator|==
name|c2
operator|->
name|fde_encoding
operator|&&
name|c1
operator|->
name|initial_insn_length
operator|==
name|c2
operator|->
name|initial_insn_length
operator|&&
name|memcmp
argument_list|(
name|c1
operator|->
name|initial_instructions
argument_list|,
name|c2
operator|->
name|initial_instructions
argument_list|,
name|c1
operator|->
name|initial_insn_length
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return the number of extra bytes that we'll be inserting into    ENTRY's augmentation string.  */
end_comment

begin_function
specifier|static
name|INLINE
name|unsigned
name|int
name|extra_augmentation_string_bytes
parameter_list|(
name|struct
name|eh_cie_fde
modifier|*
name|entry
parameter_list|)
block|{
name|unsigned
name|int
name|size
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|entry
operator|->
name|cie
condition|)
block|{
if|if
condition|(
name|entry
operator|->
name|add_augmentation_size
condition|)
name|size
operator|++
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|add_fde_encoding
condition|)
name|size
operator|++
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/* Likewise ENTRY's augmentation data.  */
end_comment

begin_function
specifier|static
name|INLINE
name|unsigned
name|int
name|extra_augmentation_data_bytes
parameter_list|(
name|struct
name|eh_cie_fde
modifier|*
name|entry
parameter_list|)
block|{
name|unsigned
name|int
name|size
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|entry
operator|->
name|cie
condition|)
block|{
if|if
condition|(
name|entry
operator|->
name|add_augmentation_size
condition|)
name|size
operator|++
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|add_fde_encoding
condition|)
name|size
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|entry
operator|->
name|cie_inf
operator|->
name|add_augmentation_size
condition|)
name|size
operator|++
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/* Return the size that ENTRY will have in the output.  ALIGNMENT is the    required alignment of ENTRY in bytes.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|size_of_output_cie_fde
parameter_list|(
name|struct
name|eh_cie_fde
modifier|*
name|entry
parameter_list|,
name|unsigned
name|int
name|alignment
parameter_list|)
block|{
if|if
condition|(
name|entry
operator|->
name|removed
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|entry
operator|->
name|size
operator|==
literal|4
condition|)
return|return
literal|4
return|;
return|return
operator|(
name|entry
operator|->
name|size
operator|+
name|extra_augmentation_string_bytes
argument_list|(
name|entry
argument_list|)
operator|+
name|extra_augmentation_data_bytes
argument_list|(
name|entry
argument_list|)
operator|+
name|alignment
operator|-
literal|1
operator|)
operator|&
operator|-
name|alignment
return|;
block|}
end_function

begin_comment
comment|/* Assume that the bytes between *ITER and END are CFA instructions.    Try to move *ITER past the first instruction and return true on    success.  ENCODED_PTR_WIDTH gives the width of pointer entries.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|skip_cfa_op
parameter_list|(
name|bfd_byte
modifier|*
modifier|*
name|iter
parameter_list|,
name|bfd_byte
modifier|*
name|end
parameter_list|,
name|unsigned
name|int
name|encoded_ptr_width
parameter_list|)
block|{
name|bfd_byte
name|op
decl_stmt|;
name|bfd_vma
name|length
decl_stmt|;
if|if
condition|(
operator|!
name|read_byte
argument_list|(
name|iter
argument_list|,
name|end
argument_list|,
operator|&
name|op
argument_list|)
condition|)
return|return
name|FALSE
return|;
switch|switch
condition|(
name|op
operator|&
literal|0x80
condition|?
name|op
operator|&
literal|0xc0
else|:
name|op
condition|)
block|{
case|case
name|DW_CFA_nop
case|:
case|case
name|DW_CFA_advance_loc
case|:
case|case
name|DW_CFA_restore
case|:
comment|/* No arguments.  */
return|return
name|TRUE
return|;
case|case
name|DW_CFA_offset
case|:
case|case
name|DW_CFA_restore_extended
case|:
case|case
name|DW_CFA_undefined
case|:
case|case
name|DW_CFA_same_value
case|:
case|case
name|DW_CFA_def_cfa_register
case|:
case|case
name|DW_CFA_def_cfa_offset
case|:
case|case
name|DW_CFA_def_cfa_offset_sf
case|:
case|case
name|DW_CFA_GNU_args_size
case|:
comment|/* One leb128 argument.  */
return|return
name|skip_leb128
argument_list|(
name|iter
argument_list|,
name|end
argument_list|)
return|;
case|case
name|DW_CFA_offset_extended
case|:
case|case
name|DW_CFA_register
case|:
case|case
name|DW_CFA_def_cfa
case|:
case|case
name|DW_CFA_offset_extended_sf
case|:
case|case
name|DW_CFA_GNU_negative_offset_extended
case|:
case|case
name|DW_CFA_def_cfa_sf
case|:
comment|/* Two leb128 arguments.  */
return|return
operator|(
name|skip_leb128
argument_list|(
name|iter
argument_list|,
name|end
argument_list|)
operator|&&
name|skip_leb128
argument_list|(
name|iter
argument_list|,
name|end
argument_list|)
operator|)
return|;
case|case
name|DW_CFA_def_cfa_expression
case|:
comment|/* A variable-length argument.  */
return|return
operator|(
name|read_uleb128
argument_list|(
name|iter
argument_list|,
name|end
argument_list|,
operator|&
name|length
argument_list|)
operator|&&
name|skip_bytes
argument_list|(
name|iter
argument_list|,
name|end
argument_list|,
name|length
argument_list|)
operator|)
return|;
case|case
name|DW_CFA_expression
case|:
comment|/* A leb128 followed by a variable-length argument.  */
return|return
operator|(
name|skip_leb128
argument_list|(
name|iter
argument_list|,
name|end
argument_list|)
operator|&&
name|read_uleb128
argument_list|(
name|iter
argument_list|,
name|end
argument_list|,
operator|&
name|length
argument_list|)
operator|&&
name|skip_bytes
argument_list|(
name|iter
argument_list|,
name|end
argument_list|,
name|length
argument_list|)
operator|)
return|;
case|case
name|DW_CFA_set_loc
case|:
return|return
name|skip_bytes
argument_list|(
name|iter
argument_list|,
name|end
argument_list|,
name|encoded_ptr_width
argument_list|)
return|;
case|case
name|DW_CFA_advance_loc1
case|:
return|return
name|skip_bytes
argument_list|(
name|iter
argument_list|,
name|end
argument_list|,
literal|1
argument_list|)
return|;
case|case
name|DW_CFA_advance_loc2
case|:
return|return
name|skip_bytes
argument_list|(
name|iter
argument_list|,
name|end
argument_list|,
literal|2
argument_list|)
return|;
case|case
name|DW_CFA_advance_loc4
case|:
return|return
name|skip_bytes
argument_list|(
name|iter
argument_list|,
name|end
argument_list|,
literal|4
argument_list|)
return|;
case|case
name|DW_CFA_MIPS_advance_loc8
case|:
return|return
name|skip_bytes
argument_list|(
name|iter
argument_list|,
name|end
argument_list|,
literal|8
argument_list|)
return|;
default|default:
return|return
name|FALSE
return|;
block|}
block|}
end_function

begin_comment
comment|/* Try to interpret the bytes between BUF and END as CFA instructions.    If every byte makes sense, return a pointer to the first DW_CFA_nop    padding byte, or END if there is no padding.  Return null otherwise.    ENCODED_PTR_WIDTH is as for skip_cfa_op.  */
end_comment

begin_function
specifier|static
name|bfd_byte
modifier|*
name|skip_non_nops
parameter_list|(
name|bfd_byte
modifier|*
name|buf
parameter_list|,
name|bfd_byte
modifier|*
name|end
parameter_list|,
name|unsigned
name|int
name|encoded_ptr_width
parameter_list|)
block|{
name|bfd_byte
modifier|*
name|last
decl_stmt|;
name|last
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|buf
operator|<
name|end
condition|)
if|if
condition|(
operator|*
name|buf
operator|==
name|DW_CFA_nop
condition|)
name|buf
operator|++
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|skip_cfa_op
argument_list|(
operator|&
name|buf
argument_list|,
name|end
argument_list|,
name|encoded_ptr_width
argument_list|)
condition|)
return|return
literal|0
return|;
name|last
operator|=
name|buf
expr_stmt|;
block|}
return|return
name|last
return|;
block|}
end_function

begin_comment
comment|/* This function is called for each input file before the .eh_frame    section is relocated.  It discards duplicate CIEs and FDEs for discarded    functions.  The function returns TRUE iff any entries have been    deleted.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_elf_discard_section_eh_frame
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|bfd_boolean
function_decl|(
modifier|*
name|reloc_symbol_deleted_p
function_decl|)
parameter_list|(
name|bfd_vma
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|struct
name|elf_reloc_cookie
modifier|*
name|cookie
parameter_list|)
block|{
define|#
directive|define
name|REQUIRE
parameter_list|(
name|COND
parameter_list|)
define|\
value|do							\     if (!(COND))					\       goto free_no_table;				\   while (0)
name|bfd_byte
modifier|*
name|ehbuf
init|=
name|NULL
decl_stmt|,
modifier|*
name|buf
decl_stmt|;
name|bfd_byte
modifier|*
name|last_cie
decl_stmt|,
modifier|*
name|last_fde
decl_stmt|;
name|struct
name|eh_cie_fde
modifier|*
name|ent
decl_stmt|,
modifier|*
name|last_cie_inf
decl_stmt|,
modifier|*
name|this_inf
decl_stmt|;
name|struct
name|cie_header
name|hdr
decl_stmt|;
name|struct
name|cie
name|cie
decl_stmt|;
name|struct
name|elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|struct
name|eh_frame_hdr_info
modifier|*
name|hdr_info
decl_stmt|;
name|struct
name|eh_frame_sec_info
modifier|*
name|sec_info
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|cie_usage_count
decl_stmt|,
name|offset
decl_stmt|;
name|unsigned
name|int
name|ptr_size
decl_stmt|;
if|if
condition|(
name|sec
operator|->
name|size
operator|==
literal|0
condition|)
block|{
comment|/* This file does not contain .eh_frame information.  */
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|(
name|sec
operator|->
name|output_section
operator|!=
name|NULL
operator|&&
name|bfd_is_abs_section
argument_list|(
name|sec
operator|->
name|output_section
argument_list|)
operator|)
condition|)
block|{
comment|/* At least one of the sections is being discarded from the 	 link, so we should just ignore them.  */
return|return
name|FALSE
return|;
block|}
name|htab
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|hdr_info
operator|=
operator|&
name|htab
operator|->
name|eh_info
expr_stmt|;
comment|/* Read the frame unwind information from abfd.  */
name|REQUIRE
argument_list|(
name|bfd_malloc_and_get_section
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
operator|&
name|ehbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|size
operator|>=
literal|4
operator|&&
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|ehbuf
argument_list|)
operator|==
literal|0
operator|&&
name|cookie
operator|->
name|rel
operator|==
name|cookie
operator|->
name|relend
condition|)
block|{
comment|/* Empty .eh_frame section.  */
name|free
argument_list|(
name|ehbuf
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* If .eh_frame section size doesn't fit into int, we cannot handle      it (it would need to use 64-bit .eh_frame format anyway).  */
name|REQUIRE
argument_list|(
name|sec
operator|->
name|size
operator|==
operator|(
name|unsigned
name|int
operator|)
name|sec
operator|->
name|size
argument_list|)
expr_stmt|;
name|ptr_size
operator|=
operator|(
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_backend_eh_frame_address_size
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|ptr_size
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|buf
operator|=
name|ehbuf
expr_stmt|;
name|last_cie
operator|=
name|NULL
expr_stmt|;
name|last_cie_inf
operator|=
name|NULL
expr_stmt|;
name|memset
argument_list|(
operator|&
name|cie
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cie
argument_list|)
argument_list|)
expr_stmt|;
name|cie_usage_count
operator|=
literal|0
expr_stmt|;
name|sec_info
operator|=
name|bfd_zmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|eh_frame_sec_info
argument_list|)
operator|+
literal|99
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|eh_cie_fde
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|sec_info
argument_list|)
expr_stmt|;
name|sec_info
operator|->
name|alloced
operator|=
literal|100
expr_stmt|;
define|#
directive|define
name|ENSURE_NO_RELOCS
parameter_list|(
name|buf
parameter_list|)
define|\
value|REQUIRE (!(cookie->rel< cookie->relend		\&& (cookie->rel->r_offset			\< (bfd_size_type) ((buf) - ehbuf))	\&& cookie->rel->r_info != 0))
define|#
directive|define
name|SKIP_RELOCS
parameter_list|(
name|buf
parameter_list|)
define|\
value|while (cookie->rel< cookie->relend			\&& (cookie->rel->r_offset			\< (bfd_size_type) ((buf) - ehbuf)))	\     cookie->rel++
define|#
directive|define
name|GET_RELOC
parameter_list|(
name|buf
parameter_list|)
define|\
value|((cookie->rel< cookie->relend			\&& (cookie->rel->r_offset				\ 	== (bfd_size_type) ((buf) - ehbuf)))		\    ? cookie->rel : NULL)
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
modifier|*
name|aug
decl_stmt|;
name|bfd_byte
modifier|*
name|start
decl_stmt|,
modifier|*
name|end
decl_stmt|,
modifier|*
name|insns
decl_stmt|;
name|bfd_size_type
name|length
decl_stmt|;
if|if
condition|(
name|sec_info
operator|->
name|count
operator|==
name|sec_info
operator|->
name|alloced
condition|)
block|{
name|struct
name|eh_cie_fde
modifier|*
name|old_entry
init|=
name|sec_info
operator|->
name|entry
decl_stmt|;
name|sec_info
operator|=
name|bfd_realloc
argument_list|(
name|sec_info
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|eh_frame_sec_info
argument_list|)
operator|+
operator|(
operator|(
name|sec_info
operator|->
name|alloced
operator|+
literal|99
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|eh_cie_fde
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|sec_info
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sec_info
operator|->
name|entry
index|[
name|sec_info
operator|->
name|alloced
index|]
argument_list|,
literal|0
argument_list|,
literal|100
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|eh_cie_fde
argument_list|)
argument_list|)
expr_stmt|;
name|sec_info
operator|->
name|alloced
operator|+=
literal|100
expr_stmt|;
comment|/* Now fix any pointers into the array.  */
if|if
condition|(
name|last_cie_inf
operator|>=
name|old_entry
operator|&&
name|last_cie_inf
operator|<
name|old_entry
operator|+
name|sec_info
operator|->
name|count
condition|)
name|last_cie_inf
operator|=
name|sec_info
operator|->
name|entry
operator|+
operator|(
name|last_cie_inf
operator|-
name|old_entry
operator|)
expr_stmt|;
block|}
name|this_inf
operator|=
name|sec_info
operator|->
name|entry
operator|+
name|sec_info
operator|->
name|count
expr_stmt|;
name|last_fde
operator|=
name|buf
expr_stmt|;
comment|/* If we are at the end of the section, we still need to decide 	 on whether to output or discard last encountered CIE (if any).  */
if|if
condition|(
call|(
name|bfd_size_type
call|)
argument_list|(
name|buf
operator|-
name|ehbuf
argument_list|)
operator|==
name|sec
operator|->
name|size
condition|)
block|{
name|hdr
operator|.
name|length
operator|=
literal|0
expr_stmt|;
name|hdr
operator|.
name|id
operator|=
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
expr_stmt|;
name|end
operator|=
name|buf
expr_stmt|;
block|}
else|else
block|{
comment|/* Read the length of the entry.  */
name|REQUIRE
argument_list|(
name|skip_bytes
argument_list|(
operator|&
name|buf
argument_list|,
name|ehbuf
operator|+
name|sec
operator|->
name|size
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|length
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|buf
operator|-
literal|4
argument_list|)
expr_stmt|;
comment|/* 64-bit .eh_frame is not supported.  */
name|REQUIRE
argument_list|(
name|hdr
operator|.
name|length
operator|!=
literal|0xffffffff
argument_list|)
expr_stmt|;
comment|/* The CIE/FDE must be fully contained in this input section.  */
name|REQUIRE
argument_list|(
call|(
name|bfd_size_type
call|)
argument_list|(
name|buf
operator|-
name|ehbuf
argument_list|)
operator|+
name|hdr
operator|.
name|length
operator|<=
name|sec
operator|->
name|size
argument_list|)
expr_stmt|;
name|end
operator|=
name|buf
operator|+
name|hdr
operator|.
name|length
expr_stmt|;
name|this_inf
operator|->
name|offset
operator|=
name|last_fde
operator|-
name|ehbuf
expr_stmt|;
name|this_inf
operator|->
name|size
operator|=
literal|4
operator|+
name|hdr
operator|.
name|length
expr_stmt|;
if|if
condition|(
name|hdr
operator|.
name|length
operator|==
literal|0
condition|)
block|{
comment|/* A zero-length CIE should only be found at the end of 		 the section.  */
name|REQUIRE
argument_list|(
call|(
name|bfd_size_type
call|)
argument_list|(
name|buf
operator|-
name|ehbuf
argument_list|)
operator|==
name|sec
operator|->
name|size
argument_list|)
expr_stmt|;
name|ENSURE_NO_RELOCS
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|sec_info
operator|->
name|count
operator|++
expr_stmt|;
comment|/* Now just finish last encountered CIE processing and break 		 the loop.  */
name|hdr
operator|.
name|id
operator|=
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|REQUIRE
argument_list|(
name|skip_bytes
argument_list|(
operator|&
name|buf
argument_list|,
name|end
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|id
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|buf
operator|-
literal|4
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|hdr
operator|.
name|id
operator|!=
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hdr
operator|.
name|id
operator|==
literal|0
operator|||
name|hdr
operator|.
name|id
operator|==
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
condition|)
block|{
name|unsigned
name|int
name|initial_insn_length
decl_stmt|;
comment|/* CIE  */
if|if
condition|(
name|last_cie
operator|!=
name|NULL
condition|)
block|{
comment|/* Now check if this CIE is identical to the last CIE, 		 in which case we can remove it provided we adjust 		 all FDEs.  Also, it can be removed if we have removed 		 all FDEs using it.  */
if|if
condition|(
operator|(
operator|!
name|info
operator|->
name|relocatable
operator|&&
name|hdr_info
operator|->
name|last_cie_sec
operator|&&
operator|(
name|sec
operator|->
name|output_section
operator|==
name|hdr_info
operator|->
name|last_cie_sec
operator|->
name|output_section
operator|)
operator|&&
name|cie_compare
argument_list|(
operator|&
name|cie
argument_list|,
operator|&
name|hdr_info
operator|->
name|last_cie
argument_list|)
operator|==
literal|0
operator|)
operator|||
name|cie_usage_count
operator|==
literal|0
condition|)
name|last_cie_inf
operator|->
name|removed
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|hdr_info
operator|->
name|last_cie
operator|=
name|cie
expr_stmt|;
name|hdr_info
operator|->
name|last_cie_sec
operator|=
name|sec
expr_stmt|;
name|last_cie_inf
operator|->
name|make_relative
operator|=
name|cie
operator|.
name|make_relative
expr_stmt|;
name|last_cie_inf
operator|->
name|make_lsda_relative
operator|=
name|cie
operator|.
name|make_lsda_relative
expr_stmt|;
name|last_cie_inf
operator|->
name|per_encoding_relative
operator|=
operator|(
name|cie
operator|.
name|per_encoding
operator|&
literal|0x70
operator|)
operator|==
name|DW_EH_PE_pcrel
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hdr
operator|.
name|id
operator|==
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
condition|)
break|break;
name|last_cie_inf
operator|=
name|this_inf
expr_stmt|;
name|this_inf
operator|->
name|cie
operator|=
literal|1
expr_stmt|;
name|cie_usage_count
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
name|cie
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cie
argument_list|)
argument_list|)
expr_stmt|;
name|cie
operator|.
name|hdr
operator|=
name|hdr
expr_stmt|;
name|REQUIRE
argument_list|(
name|read_byte
argument_list|(
operator|&
name|buf
argument_list|,
name|end
argument_list|,
operator|&
name|cie
operator|.
name|version
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Cannot handle unknown versions.  */
name|REQUIRE
argument_list|(
name|cie
operator|.
name|version
operator|==
literal|1
operator|||
name|cie
operator|.
name|version
operator|==
literal|3
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
name|cie
operator|.
name|augmentation
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|cie
operator|.
name|augmentation
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|strchr
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
literal|'\0'
argument_list|)
operator|+
literal|1
expr_stmt|;
name|ENSURE_NO_RELOCS
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'e'
operator|&&
name|buf
index|[
literal|1
index|]
operator|==
literal|'h'
condition|)
block|{
comment|/* GCC< 3.0 .eh_frame CIE */
comment|/* We cannot merge "eh" CIEs because __EXCEPTION_TABLE__ 		 is private to each CIE, so we don't need it for anything. 		 Just skip it.  */
name|REQUIRE
argument_list|(
name|skip_bytes
argument_list|(
operator|&
name|buf
argument_list|,
name|end
argument_list|,
name|ptr_size
argument_list|)
argument_list|)
expr_stmt|;
name|SKIP_RELOCS
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|REQUIRE
argument_list|(
name|read_uleb128
argument_list|(
operator|&
name|buf
argument_list|,
name|end
argument_list|,
operator|&
name|cie
operator|.
name|code_align
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|read_sleb128
argument_list|(
operator|&
name|buf
argument_list|,
name|end
argument_list|,
operator|&
name|cie
operator|.
name|data_align
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cie
operator|.
name|version
operator|==
literal|1
condition|)
block|{
name|REQUIRE
argument_list|(
name|buf
operator|<
name|end
argument_list|)
expr_stmt|;
name|cie
operator|.
name|ra_column
operator|=
operator|*
name|buf
operator|++
expr_stmt|;
block|}
else|else
name|REQUIRE
argument_list|(
name|read_uleb128
argument_list|(
operator|&
name|buf
argument_list|,
name|end
argument_list|,
operator|&
name|cie
operator|.
name|ra_column
argument_list|)
argument_list|)
expr_stmt|;
name|ENSURE_NO_RELOCS
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|cie
operator|.
name|lsda_encoding
operator|=
name|DW_EH_PE_omit
expr_stmt|;
name|cie
operator|.
name|fde_encoding
operator|=
name|DW_EH_PE_omit
expr_stmt|;
name|cie
operator|.
name|per_encoding
operator|=
name|DW_EH_PE_omit
expr_stmt|;
name|aug
operator|=
name|cie
operator|.
name|augmentation
expr_stmt|;
if|if
condition|(
name|aug
index|[
literal|0
index|]
operator|!=
literal|'e'
operator|||
name|aug
index|[
literal|1
index|]
operator|!=
literal|'h'
condition|)
block|{
if|if
condition|(
operator|*
name|aug
operator|==
literal|'z'
condition|)
block|{
name|aug
operator|++
expr_stmt|;
name|REQUIRE
argument_list|(
name|read_uleb128
argument_list|(
operator|&
name|buf
argument_list|,
name|end
argument_list|,
operator|&
name|cie
operator|.
name|augmentation_size
argument_list|)
argument_list|)
expr_stmt|;
name|ENSURE_NO_RELOCS
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|aug
operator|!=
literal|'\0'
condition|)
switch|switch
condition|(
operator|*
name|aug
operator|++
condition|)
block|{
case|case
literal|'L'
case|:
name|REQUIRE
argument_list|(
name|read_byte
argument_list|(
operator|&
name|buf
argument_list|,
name|end
argument_list|,
operator|&
name|cie
operator|.
name|lsda_encoding
argument_list|)
argument_list|)
expr_stmt|;
name|ENSURE_NO_RELOCS
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|get_DW_EH_PE_width
argument_list|(
name|cie
operator|.
name|lsda_encoding
argument_list|,
name|ptr_size
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|REQUIRE
argument_list|(
name|read_byte
argument_list|(
operator|&
name|buf
argument_list|,
name|end
argument_list|,
operator|&
name|cie
operator|.
name|fde_encoding
argument_list|)
argument_list|)
expr_stmt|;
name|ENSURE_NO_RELOCS
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|get_DW_EH_PE_width
argument_list|(
name|cie
operator|.
name|fde_encoding
argument_list|,
name|ptr_size
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
break|break;
case|case
literal|'P'
case|:
block|{
name|int
name|per_width
decl_stmt|;
name|REQUIRE
argument_list|(
name|read_byte
argument_list|(
operator|&
name|buf
argument_list|,
name|end
argument_list|,
operator|&
name|cie
operator|.
name|per_encoding
argument_list|)
argument_list|)
expr_stmt|;
name|per_width
operator|=
name|get_DW_EH_PE_width
argument_list|(
name|cie
operator|.
name|per_encoding
argument_list|,
name|ptr_size
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|per_width
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cie
operator|.
name|per_encoding
operator|&
literal|0xf0
operator|)
operator|==
name|DW_EH_PE_aligned
condition|)
block|{
name|length
operator|=
operator|-
operator|(
name|buf
operator|-
name|ehbuf
operator|)
operator|&
operator|(
name|per_width
operator|-
literal|1
operator|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|skip_bytes
argument_list|(
operator|&
name|buf
argument_list|,
name|end
argument_list|,
name|length
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ENSURE_NO_RELOCS
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* Ensure we have a reloc here, against 			 a global symbol.  */
if|if
condition|(
name|GET_RELOC
argument_list|(
name|buf
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
ifdef|#
directive|ifdef
name|BFD64
if|if
condition|(
name|ptr_size
operator|==
literal|8
condition|)
name|r_symndx
operator|=
name|ELF64_R_SYM
argument_list|(
name|cookie
operator|->
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|cookie
operator|->
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|>=
name|cookie
operator|->
name|locsymcount
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|r_symndx
operator|-=
name|cookie
operator|->
name|extsymoff
expr_stmt|;
name|h
operator|=
name|cookie
operator|->
name|sym_hashes
index|[
name|r_symndx
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|cie
operator|.
name|personality
operator|=
name|h
expr_stmt|;
block|}
comment|/* Cope with MIPS-style composite relocations.  */
do|do
name|cookie
operator|->
name|rel
operator|++
expr_stmt|;
do|while
condition|(
name|GET_RELOC
argument_list|(
name|buf
argument_list|)
operator|!=
name|NULL
condition|)
do|;
block|}
name|REQUIRE
argument_list|(
name|skip_bytes
argument_list|(
operator|&
name|buf
argument_list|,
name|end
argument_list|,
name|per_width
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|/* Unrecognized augmentation. Better bail out.  */
goto|goto
name|free_no_table
goto|;
block|}
block|}
comment|/* For shared libraries, try to get rid of as many RELATIVE relocs 	     as possible.  */
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_backend_can_make_relative_eh_frame
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|sec
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|cie
operator|.
name|fde_encoding
operator|&
literal|0xf0
operator|)
operator|==
name|DW_EH_PE_absptr
condition|)
name|cie
operator|.
name|make_relative
operator|=
literal|1
expr_stmt|;
comment|/* If the CIE doesn't already have an 'R' entry, it's fairly 		 easy to add one, provided that there's no aligned data 		 after the augmentation string.  */
elseif|else
if|if
condition|(
name|cie
operator|.
name|fde_encoding
operator|==
name|DW_EH_PE_omit
operator|&&
operator|(
name|cie
operator|.
name|per_encoding
operator|&
literal|0xf0
operator|)
operator|!=
name|DW_EH_PE_aligned
condition|)
block|{
if|if
condition|(
operator|*
name|cie
operator|.
name|augmentation
operator|==
literal|0
condition|)
name|this_inf
operator|->
name|add_augmentation_size
operator|=
literal|1
expr_stmt|;
name|this_inf
operator|->
name|add_fde_encoding
operator|=
literal|1
expr_stmt|;
name|cie
operator|.
name|make_relative
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_backend_can_make_lsda_relative_eh_frame
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|sec
argument_list|)
operator|)
operator|&&
operator|(
name|cie
operator|.
name|lsda_encoding
operator|&
literal|0xf0
operator|)
operator|==
name|DW_EH_PE_absptr
condition|)
name|cie
operator|.
name|make_lsda_relative
operator|=
literal|1
expr_stmt|;
comment|/* If FDE encoding was not specified, it defaults to 	     DW_EH_absptr.  */
if|if
condition|(
name|cie
operator|.
name|fde_encoding
operator|==
name|DW_EH_PE_omit
condition|)
name|cie
operator|.
name|fde_encoding
operator|=
name|DW_EH_PE_absptr
expr_stmt|;
name|initial_insn_length
operator|=
name|end
operator|-
name|buf
expr_stmt|;
if|if
condition|(
name|initial_insn_length
operator|<=
literal|50
condition|)
block|{
name|cie
operator|.
name|initial_insn_length
operator|=
name|initial_insn_length
expr_stmt|;
name|memcpy
argument_list|(
name|cie
operator|.
name|initial_instructions
argument_list|,
name|buf
argument_list|,
name|initial_insn_length
argument_list|)
expr_stmt|;
block|}
name|insns
operator|=
name|buf
expr_stmt|;
name|buf
operator|+=
name|initial_insn_length
expr_stmt|;
name|ENSURE_NO_RELOCS
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|last_cie
operator|=
name|last_fde
expr_stmt|;
block|}
else|else
block|{
comment|/* Ensure this FDE uses the last CIE encountered.  */
name|REQUIRE
argument_list|(
name|last_cie
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|hdr
operator|.
name|id
operator|==
call|(
name|unsigned
name|int
call|)
argument_list|(
name|buf
operator|-
literal|4
operator|-
name|last_cie
argument_list|)
argument_list|)
expr_stmt|;
name|ENSURE_NO_RELOCS
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|GET_RELOC
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|reloc_symbol_deleted_p
call|)
argument_list|(
name|buf
operator|-
name|ehbuf
argument_list|,
name|cookie
argument_list|)
condition|)
comment|/* This is a FDE against a discarded section.  It should 	       be deleted.  */
name|this_inf
operator|->
name|removed
operator|=
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
operator|(
operator|(
operator|(
name|cie
operator|.
name|fde_encoding
operator|&
literal|0xf0
operator|)
operator|==
name|DW_EH_PE_absptr
operator|&&
name|cie
operator|.
name|make_relative
operator|==
literal|0
operator|)
operator|||
operator|(
name|cie
operator|.
name|fde_encoding
operator|&
literal|0xf0
operator|)
operator|==
name|DW_EH_PE_aligned
operator|)
condition|)
block|{
comment|/* If a shared library uses absolute pointers 		     which we cannot turn into PC relative, 		     don't create the binary search table, 		     since it is affected by runtime relocations.  */
name|hdr_info
operator|->
name|table
operator|=
name|FALSE
expr_stmt|;
block|}
name|cie_usage_count
operator|++
expr_stmt|;
name|hdr_info
operator|->
name|fde_count
operator|++
expr_stmt|;
block|}
comment|/* Skip the initial location and address range.  */
name|start
operator|=
name|buf
expr_stmt|;
name|length
operator|=
name|get_DW_EH_PE_width
argument_list|(
name|cie
operator|.
name|fde_encoding
argument_list|,
name|ptr_size
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|skip_bytes
argument_list|(
operator|&
name|buf
argument_list|,
name|end
argument_list|,
literal|2
operator|*
name|length
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Skip the augmentation size, if present.  */
if|if
condition|(
name|cie
operator|.
name|augmentation
index|[
literal|0
index|]
operator|==
literal|'z'
condition|)
name|REQUIRE
argument_list|(
name|read_uleb128
argument_list|(
operator|&
name|buf
argument_list|,
name|end
argument_list|,
operator|&
name|length
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|length
operator|=
literal|0
expr_stmt|;
comment|/* Of the supported augmentation characters above, only 'L' 	     adds augmentation data to the FDE.  This code would need to 	     be adjusted if any future augmentations do the same thing.  */
if|if
condition|(
name|cie
operator|.
name|lsda_encoding
operator|!=
name|DW_EH_PE_omit
condition|)
block|{
name|this_inf
operator|->
name|lsda_offset
operator|=
name|buf
operator|-
name|start
expr_stmt|;
comment|/* If there's no 'z' augmentation, we don't know where the 		 CFA insns begin.  Assume no padding.  */
if|if
condition|(
name|cie
operator|.
name|augmentation
index|[
literal|0
index|]
operator|!=
literal|'z'
condition|)
name|length
operator|=
name|end
operator|-
name|buf
expr_stmt|;
block|}
comment|/* Skip over the augmentation data.  */
name|REQUIRE
argument_list|(
name|skip_bytes
argument_list|(
operator|&
name|buf
argument_list|,
name|end
argument_list|,
name|length
argument_list|)
argument_list|)
expr_stmt|;
name|insns
operator|=
name|buf
expr_stmt|;
name|buf
operator|=
name|last_fde
operator|+
literal|4
operator|+
name|hdr
operator|.
name|length
expr_stmt|;
name|SKIP_RELOCS
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
comment|/* Try to interpret the CFA instructions and find the first 	 padding nop.  Shrink this_inf's size so that it doesn't 	 including the padding.  */
name|length
operator|=
name|get_DW_EH_PE_width
argument_list|(
name|cie
operator|.
name|fde_encoding
argument_list|,
name|ptr_size
argument_list|)
expr_stmt|;
name|insns
operator|=
name|skip_non_nops
argument_list|(
name|insns
argument_list|,
name|end
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|insns
operator|!=
literal|0
condition|)
name|this_inf
operator|->
name|size
operator|-=
name|end
operator|-
name|insns
expr_stmt|;
name|this_inf
operator|->
name|fde_encoding
operator|=
name|cie
operator|.
name|fde_encoding
expr_stmt|;
name|this_inf
operator|->
name|lsda_encoding
operator|=
name|cie
operator|.
name|lsda_encoding
expr_stmt|;
name|sec_info
operator|->
name|count
operator|++
expr_stmt|;
block|}
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|sec_info
operator|=
name|sec_info
expr_stmt|;
name|sec
operator|->
name|sec_info_type
operator|=
name|ELF_INFO_TYPE_EH_FRAME
expr_stmt|;
comment|/* Ok, now we can assign new offsets.  */
name|offset
operator|=
literal|0
expr_stmt|;
name|last_cie_inf
operator|=
name|hdr_info
operator|->
name|last_cie_inf
expr_stmt|;
for|for
control|(
name|ent
operator|=
name|sec_info
operator|->
name|entry
init|;
name|ent
operator|<
name|sec_info
operator|->
name|entry
operator|+
name|sec_info
operator|->
name|count
condition|;
operator|++
name|ent
control|)
if|if
condition|(
operator|!
name|ent
operator|->
name|removed
condition|)
block|{
if|if
condition|(
name|ent
operator|->
name|cie
condition|)
name|last_cie_inf
operator|=
name|ent
expr_stmt|;
else|else
name|ent
operator|->
name|cie_inf
operator|=
name|last_cie_inf
expr_stmt|;
name|ent
operator|->
name|new_offset
operator|=
name|offset
expr_stmt|;
name|offset
operator|+=
name|size_of_output_cie_fde
argument_list|(
name|ent
argument_list|,
name|ptr_size
argument_list|)
expr_stmt|;
block|}
name|hdr_info
operator|->
name|last_cie_inf
operator|=
name|last_cie_inf
expr_stmt|;
comment|/* Resize the sec as needed.  */
name|sec
operator|->
name|rawsize
operator|=
name|sec
operator|->
name|size
expr_stmt|;
name|sec
operator|->
name|size
operator|=
name|offset
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|size
operator|==
literal|0
condition|)
name|sec
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
name|free
argument_list|(
name|ehbuf
argument_list|)
expr_stmt|;
return|return
name|offset
operator|!=
name|sec
operator|->
name|rawsize
return|;
name|free_no_table
label|:
if|if
condition|(
name|ehbuf
condition|)
name|free
argument_list|(
name|ehbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec_info
condition|)
name|free
argument_list|(
name|sec_info
argument_list|)
expr_stmt|;
name|hdr_info
operator|->
name|table
operator|=
name|FALSE
expr_stmt|;
name|hdr_info
operator|->
name|last_cie
operator|.
name|hdr
operator|.
name|length
operator|=
literal|0
expr_stmt|;
return|return
name|FALSE
return|;
undef|#
directive|undef
name|REQUIRE
block|}
end_function

begin_comment
comment|/* This function is called for .eh_frame_hdr section after    _bfd_elf_discard_section_eh_frame has been called on all .eh_frame    input sections.  It finalizes the size of .eh_frame_hdr section.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_elf_discard_section_eh_frame_hdr
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|struct
name|eh_frame_hdr_info
modifier|*
name|hdr_info
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|htab
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|hdr_info
operator|=
operator|&
name|htab
operator|->
name|eh_info
expr_stmt|;
name|sec
operator|=
name|hdr_info
operator|->
name|hdr_sec
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|sec
operator|->
name|size
operator|=
name|EH_FRAME_HDR_SIZE
expr_stmt|;
if|if
condition|(
name|hdr_info
operator|->
name|table
condition|)
name|sec
operator|->
name|size
operator|+=
literal|4
operator|+
name|hdr_info
operator|->
name|fde_count
operator|*
literal|8
expr_stmt|;
comment|/* Request program headers to be recalculated.  */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|program_header_size
operator|=
literal|0
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|eh_frame_hdr
operator|=
name|sec
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* This function is called from size_dynamic_sections.    It needs to decide whether .eh_frame_hdr should be output or not,    because when the dynamic symbol table has been sized it is too late    to strip sections.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_elf_maybe_strip_eh_frame_hdr
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|asection
modifier|*
name|o
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|struct
name|eh_frame_hdr_info
modifier|*
name|hdr_info
decl_stmt|;
name|htab
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|hdr_info
operator|=
operator|&
name|htab
operator|->
name|eh_info
expr_stmt|;
if|if
condition|(
name|hdr_info
operator|->
name|hdr_sec
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|bfd_is_abs_section
argument_list|(
name|hdr_info
operator|->
name|hdr_sec
operator|->
name|output_section
argument_list|)
condition|)
block|{
name|hdr_info
operator|->
name|hdr_sec
operator|=
name|NULL
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|abfd
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|eh_frame_hdr
condition|)
for|for
control|(
name|abfd
operator|=
name|info
operator|->
name|input_bfds
init|;
name|abfd
operator|!=
name|NULL
condition|;
name|abfd
operator|=
name|abfd
operator|->
name|link_next
control|)
block|{
comment|/* Count only sections which have at least a single CIE or FDE. 	   There cannot be any CIE or FDE<= 8 bytes.  */
name|o
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".eh_frame"
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|&&
name|o
operator|->
name|size
operator|>
literal|8
operator|&&
operator|!
name|bfd_is_abs_section
argument_list|(
name|o
operator|->
name|output_section
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|abfd
operator|==
name|NULL
condition|)
block|{
name|hdr_info
operator|->
name|hdr_sec
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
name|hdr_info
operator|->
name|hdr_sec
operator|=
name|NULL
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|hdr_info
operator|->
name|table
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Adjust an address in the .eh_frame section.  Given OFFSET within    SEC, this returns the new offset in the adjusted .eh_frame section,    or -1 if the address refers to a CIE/FDE which has been removed    or to offset with dynamic relocation which is no longer needed.  */
end_comment

begin_function
name|bfd_vma
name|_bfd_elf_eh_frame_section_offset
parameter_list|(
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|bfd_vma
name|offset
parameter_list|)
block|{
name|struct
name|eh_frame_sec_info
modifier|*
name|sec_info
decl_stmt|;
name|struct
name|elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|struct
name|eh_frame_hdr_info
modifier|*
name|hdr_info
decl_stmt|;
name|unsigned
name|int
name|lo
decl_stmt|,
name|hi
decl_stmt|,
name|mid
decl_stmt|;
if|if
condition|(
name|sec
operator|->
name|sec_info_type
operator|!=
name|ELF_INFO_TYPE_EH_FRAME
condition|)
return|return
name|offset
return|;
name|sec_info
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|sec_info
expr_stmt|;
if|if
condition|(
name|offset
operator|>=
name|sec
operator|->
name|rawsize
condition|)
return|return
name|offset
operator|-
name|sec
operator|->
name|rawsize
operator|+
name|sec
operator|->
name|size
return|;
name|htab
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|hdr_info
operator|=
operator|&
name|htab
operator|->
name|eh_info
expr_stmt|;
if|if
condition|(
name|hdr_info
operator|->
name|offsets_adjusted
condition|)
name|offset
operator|+=
name|sec
operator|->
name|output_offset
expr_stmt|;
name|lo
operator|=
literal|0
expr_stmt|;
name|hi
operator|=
name|sec_info
operator|->
name|count
expr_stmt|;
name|mid
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|lo
operator|<
name|hi
condition|)
block|{
name|mid
operator|=
operator|(
name|lo
operator|+
name|hi
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|offset
operator|<
name|sec_info
operator|->
name|entry
index|[
name|mid
index|]
operator|.
name|offset
condition|)
name|hi
operator|=
name|mid
expr_stmt|;
elseif|else
if|if
condition|(
name|offset
operator|>=
name|sec_info
operator|->
name|entry
index|[
name|mid
index|]
operator|.
name|offset
operator|+
name|sec_info
operator|->
name|entry
index|[
name|mid
index|]
operator|.
name|size
condition|)
name|lo
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
else|else
break|break;
block|}
name|BFD_ASSERT
argument_list|(
name|lo
operator|<
name|hi
argument_list|)
expr_stmt|;
comment|/* FDE or CIE was removed.  */
if|if
condition|(
name|sec_info
operator|->
name|entry
index|[
name|mid
index|]
operator|.
name|removed
condition|)
return|return
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
return|;
comment|/* If converting to DW_EH_PE_pcrel, there will be no need for run-time      relocation against FDE's initial_location field.  */
if|if
condition|(
operator|!
name|sec_info
operator|->
name|entry
index|[
name|mid
index|]
operator|.
name|cie
operator|&&
name|sec_info
operator|->
name|entry
index|[
name|mid
index|]
operator|.
name|cie_inf
operator|->
name|make_relative
operator|&&
name|offset
operator|==
name|sec_info
operator|->
name|entry
index|[
name|mid
index|]
operator|.
name|offset
operator|+
literal|8
condition|)
return|return
operator|(
name|bfd_vma
operator|)
operator|-
literal|2
return|;
comment|/* If converting LSDA pointers to DW_EH_PE_pcrel, there will be no need      for run-time relocation against LSDA field.  */
if|if
condition|(
operator|!
name|sec_info
operator|->
name|entry
index|[
name|mid
index|]
operator|.
name|cie
operator|&&
name|sec_info
operator|->
name|entry
index|[
name|mid
index|]
operator|.
name|cie_inf
operator|->
name|make_lsda_relative
operator|&&
operator|(
name|offset
operator|==
operator|(
name|sec_info
operator|->
name|entry
index|[
name|mid
index|]
operator|.
name|offset
operator|+
literal|8
operator|+
name|sec_info
operator|->
name|entry
index|[
name|mid
index|]
operator|.
name|lsda_offset
operator|)
operator|)
operator|&&
operator|(
name|sec_info
operator|->
name|entry
index|[
name|mid
index|]
operator|.
name|cie_inf
operator|->
name|need_lsda_relative
operator|||
operator|!
name|hdr_info
operator|->
name|offsets_adjusted
operator|)
condition|)
block|{
name|sec_info
operator|->
name|entry
index|[
name|mid
index|]
operator|.
name|cie_inf
operator|->
name|need_lsda_relative
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|bfd_vma
operator|)
operator|-
literal|2
return|;
block|}
if|if
condition|(
name|hdr_info
operator|->
name|offsets_adjusted
condition|)
name|offset
operator|-=
name|sec
operator|->
name|output_offset
expr_stmt|;
comment|/* Any new augmentation bytes go before the first relocation.  */
return|return
operator|(
name|offset
operator|+
name|sec_info
operator|->
name|entry
index|[
name|mid
index|]
operator|.
name|new_offset
operator|-
name|sec_info
operator|->
name|entry
index|[
name|mid
index|]
operator|.
name|offset
operator|+
name|extra_augmentation_string_bytes
argument_list|(
name|sec_info
operator|->
name|entry
operator|+
name|mid
argument_list|)
operator|+
name|extra_augmentation_data_bytes
argument_list|(
name|sec_info
operator|->
name|entry
operator|+
name|mid
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Write out .eh_frame section.  This is called with the relocated    contents.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_elf_write_section_eh_frame
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|)
block|{
name|struct
name|eh_frame_sec_info
modifier|*
name|sec_info
decl_stmt|;
name|struct
name|elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|struct
name|eh_frame_hdr_info
modifier|*
name|hdr_info
decl_stmt|;
name|unsigned
name|int
name|ptr_size
decl_stmt|;
name|struct
name|eh_cie_fde
modifier|*
name|ent
decl_stmt|;
if|if
condition|(
name|sec
operator|->
name|sec_info_type
operator|!=
name|ELF_INFO_TYPE_EH_FRAME
condition|)
return|return
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|sec
operator|->
name|output_section
argument_list|,
name|contents
argument_list|,
name|sec
operator|->
name|output_offset
argument_list|,
name|sec
operator|->
name|size
argument_list|)
return|;
name|ptr_size
operator|=
operator|(
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_backend_eh_frame_address_size
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|ptr_size
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|sec_info
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|sec_info
expr_stmt|;
name|htab
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|hdr_info
operator|=
operator|&
name|htab
operator|->
name|eh_info
expr_stmt|;
comment|/* First convert all offsets to output section offsets, so that a      CIE offset is valid if the CIE is used by a FDE from some other      section.  This can happen when duplicate CIEs are deleted in      _bfd_elf_discard_section_eh_frame.  We do all sections here because      this function might not be called on sections in the same order as      _bfd_elf_discard_section_eh_frame.  */
if|if
condition|(
operator|!
name|hdr_info
operator|->
name|offsets_adjusted
condition|)
block|{
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|asection
modifier|*
name|eh
decl_stmt|;
name|struct
name|eh_frame_sec_info
modifier|*
name|eh_inf
decl_stmt|;
for|for
control|(
name|ibfd
operator|=
name|info
operator|->
name|input_bfds
init|;
name|ibfd
operator|!=
name|NULL
condition|;
name|ibfd
operator|=
name|ibfd
operator|->
name|link_next
control|)
block|{
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|ibfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
operator|||
operator|(
name|ibfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
condition|)
continue|continue;
name|eh
operator|=
name|bfd_get_section_by_name
argument_list|(
name|ibfd
argument_list|,
literal|".eh_frame"
argument_list|)
expr_stmt|;
if|if
condition|(
name|eh
operator|==
name|NULL
operator|||
name|eh
operator|->
name|sec_info_type
operator|!=
name|ELF_INFO_TYPE_EH_FRAME
condition|)
continue|continue;
name|eh_inf
operator|=
name|elf_section_data
argument_list|(
name|eh
argument_list|)
operator|->
name|sec_info
expr_stmt|;
for|for
control|(
name|ent
operator|=
name|eh_inf
operator|->
name|entry
init|;
name|ent
operator|<
name|eh_inf
operator|->
name|entry
operator|+
name|eh_inf
operator|->
name|count
condition|;
operator|++
name|ent
control|)
block|{
name|ent
operator|->
name|offset
operator|+=
name|eh
operator|->
name|output_offset
expr_stmt|;
name|ent
operator|->
name|new_offset
operator|+=
name|eh
operator|->
name|output_offset
expr_stmt|;
block|}
block|}
name|hdr_info
operator|->
name|offsets_adjusted
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|hdr_info
operator|->
name|table
operator|&&
name|hdr_info
operator|->
name|array
operator|==
name|NULL
condition|)
name|hdr_info
operator|->
name|array
operator|=
name|bfd_malloc
argument_list|(
name|hdr_info
operator|->
name|fde_count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|hdr_info
operator|->
name|array
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr_info
operator|->
name|array
operator|==
name|NULL
condition|)
name|hdr_info
operator|=
name|NULL
expr_stmt|;
comment|/* The new offsets can be bigger or smaller than the original offsets.      We therefore need to make two passes over the section: one backward      pass to move entries up and one forward pass to move entries down.      The two passes won't interfere with each other because entries are      not reordered  */
for|for
control|(
name|ent
operator|=
name|sec_info
operator|->
name|entry
operator|+
name|sec_info
operator|->
name|count
init|;
name|ent
operator|--
operator|!=
name|sec_info
operator|->
name|entry
condition|;
control|)
if|if
condition|(
operator|!
name|ent
operator|->
name|removed
operator|&&
name|ent
operator|->
name|new_offset
operator|>
name|ent
operator|->
name|offset
condition|)
name|memmove
argument_list|(
name|contents
operator|+
name|ent
operator|->
name|new_offset
operator|-
name|sec
operator|->
name|output_offset
argument_list|,
name|contents
operator|+
name|ent
operator|->
name|offset
operator|-
name|sec
operator|->
name|output_offset
argument_list|,
name|ent
operator|->
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|ent
operator|=
name|sec_info
operator|->
name|entry
init|;
name|ent
operator|<
name|sec_info
operator|->
name|entry
operator|+
name|sec_info
operator|->
name|count
condition|;
operator|++
name|ent
control|)
if|if
condition|(
operator|!
name|ent
operator|->
name|removed
operator|&&
name|ent
operator|->
name|new_offset
operator|<
name|ent
operator|->
name|offset
condition|)
name|memmove
argument_list|(
name|contents
operator|+
name|ent
operator|->
name|new_offset
operator|-
name|sec
operator|->
name|output_offset
argument_list|,
name|contents
operator|+
name|ent
operator|->
name|offset
operator|-
name|sec
operator|->
name|output_offset
argument_list|,
name|ent
operator|->
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|ent
operator|=
name|sec_info
operator|->
name|entry
init|;
name|ent
operator|<
name|sec_info
operator|->
name|entry
operator|+
name|sec_info
operator|->
name|count
condition|;
operator|++
name|ent
control|)
block|{
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|unsigned
name|int
name|new_size
decl_stmt|;
if|if
condition|(
name|ent
operator|->
name|removed
condition|)
continue|continue;
if|if
condition|(
name|ent
operator|->
name|size
operator|==
literal|4
condition|)
block|{
comment|/* Any terminating FDE must be at the end of the section.  */
name|BFD_ASSERT
argument_list|(
name|ent
operator|==
name|sec_info
operator|->
name|entry
operator|+
name|sec_info
operator|->
name|count
operator|-
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|buf
operator|=
name|contents
operator|+
name|ent
operator|->
name|new_offset
operator|-
name|sec
operator|->
name|output_offset
expr_stmt|;
name|end
operator|=
name|buf
operator|+
name|ent
operator|->
name|size
expr_stmt|;
name|new_size
operator|=
name|size_of_output_cie_fde
argument_list|(
name|ent
argument_list|,
name|ptr_size
argument_list|)
expr_stmt|;
comment|/* Update the size.  It may be shrinked.  */
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|new_size
operator|-
literal|4
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* Filling the extra bytes with DW_CFA_nops.  */
if|if
condition|(
name|new_size
operator|!=
name|ent
operator|->
name|size
condition|)
name|memset
argument_list|(
name|end
argument_list|,
literal|0
argument_list|,
name|new_size
operator|-
name|ent
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ent
operator|->
name|cie
condition|)
block|{
comment|/* CIE */
if|if
condition|(
name|ent
operator|->
name|make_relative
operator|||
name|ent
operator|->
name|need_lsda_relative
operator|||
name|ent
operator|->
name|per_encoding_relative
condition|)
block|{
name|char
modifier|*
name|aug
decl_stmt|;
name|unsigned
name|int
name|action
decl_stmt|,
name|extra_string
decl_stmt|,
name|extra_data
decl_stmt|;
name|unsigned
name|int
name|per_width
decl_stmt|,
name|per_encoding
decl_stmt|;
comment|/* Need to find 'R' or 'L' augmentation's argument and modify 		 DW_EH_PE_* value.  */
name|action
operator|=
operator|(
operator|(
name|ent
operator|->
name|make_relative
condition|?
literal|1
else|:
literal|0
operator|)
operator||
operator|(
name|ent
operator|->
name|need_lsda_relative
condition|?
literal|2
else|:
literal|0
operator|)
operator||
operator|(
name|ent
operator|->
name|per_encoding_relative
condition|?
literal|4
else|:
literal|0
operator|)
operator|)
expr_stmt|;
name|extra_string
operator|=
name|extra_augmentation_string_bytes
argument_list|(
name|ent
argument_list|)
expr_stmt|;
name|extra_data
operator|=
name|extra_augmentation_data_bytes
argument_list|(
name|ent
argument_list|)
expr_stmt|;
comment|/* Skip length, id and version.  */
name|buf
operator|+=
literal|9
expr_stmt|;
name|aug
operator|=
operator|(
name|char
operator|*
operator|)
name|buf
expr_stmt|;
name|buf
operator|+=
name|strlen
argument_list|(
name|aug
argument_list|)
operator|+
literal|1
expr_stmt|;
name|skip_leb128
argument_list|(
operator|&
name|buf
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|skip_leb128
argument_list|(
operator|&
name|buf
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|skip_leb128
argument_list|(
operator|&
name|buf
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|aug
operator|==
literal|'z'
condition|)
block|{
comment|/* The uleb128 will always be a single byte for the kind 		     of augmentation strings that we're prepared to handle.  */
operator|*
name|buf
operator|++
operator|+=
name|extra_data
expr_stmt|;
name|aug
operator|++
expr_stmt|;
block|}
comment|/* Make room for the new augmentation string and data bytes.  */
name|memmove
argument_list|(
name|buf
operator|+
name|extra_string
operator|+
name|extra_data
argument_list|,
name|buf
argument_list|,
name|end
operator|-
name|buf
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|aug
operator|+
name|extra_string
argument_list|,
name|aug
argument_list|,
name|buf
operator|-
operator|(
name|bfd_byte
operator|*
operator|)
name|aug
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|extra_string
expr_stmt|;
name|end
operator|+=
name|extra_string
operator|+
name|extra_data
expr_stmt|;
if|if
condition|(
name|ent
operator|->
name|add_augmentation_size
condition|)
block|{
operator|*
name|aug
operator|++
operator|=
literal|'z'
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|extra_data
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ent
operator|->
name|add_fde_encoding
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|action
operator|&
literal|1
argument_list|)
expr_stmt|;
operator|*
name|aug
operator|++
operator|=
literal|'R'
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|DW_EH_PE_pcrel
expr_stmt|;
name|action
operator|&=
operator|~
literal|1
expr_stmt|;
block|}
while|while
condition|(
name|action
condition|)
switch|switch
condition|(
operator|*
name|aug
operator|++
condition|)
block|{
case|case
literal|'L'
case|:
if|if
condition|(
name|action
operator|&
literal|2
condition|)
block|{
name|BFD_ASSERT
argument_list|(
operator|*
name|buf
operator|==
name|ent
operator|->
name|lsda_encoding
argument_list|)
expr_stmt|;
operator|*
name|buf
operator||=
name|DW_EH_PE_pcrel
expr_stmt|;
name|action
operator|&=
operator|~
literal|2
expr_stmt|;
block|}
name|buf
operator|++
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|per_encoding
operator|=
operator|*
name|buf
operator|++
expr_stmt|;
name|per_width
operator|=
name|get_DW_EH_PE_width
argument_list|(
name|per_encoding
argument_list|,
name|ptr_size
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|per_width
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
operator|(
operator|(
name|per_encoding
operator|&
literal|0x70
operator|)
operator|==
name|DW_EH_PE_pcrel
operator|)
operator|==
name|ent
operator|->
name|per_encoding_relative
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|per_encoding
operator|&
literal|0xf0
operator|)
operator|==
name|DW_EH_PE_aligned
condition|)
name|buf
operator|=
operator|(
name|contents
operator|+
operator|(
operator|(
name|buf
operator|-
name|contents
operator|+
name|per_width
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
operator|(
name|bfd_size_type
operator|)
name|per_width
operator|-
literal|1
operator|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|action
operator|&
literal|4
condition|)
block|{
name|bfd_vma
name|val
decl_stmt|;
name|val
operator|=
name|read_value
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|,
name|per_width
argument_list|,
name|get_DW_EH_PE_signed
argument_list|(
name|per_encoding
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|+=
name|ent
operator|->
name|offset
operator|-
name|ent
operator|->
name|new_offset
expr_stmt|;
name|val
operator|-=
name|extra_string
operator|+
name|extra_data
expr_stmt|;
name|write_value
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|,
name|val
argument_list|,
name|per_width
argument_list|)
expr_stmt|;
name|action
operator|&=
operator|~
literal|4
expr_stmt|;
block|}
name|buf
operator|+=
name|per_width
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
if|if
condition|(
name|action
operator|&
literal|1
condition|)
block|{
name|BFD_ASSERT
argument_list|(
operator|*
name|buf
operator|==
name|ent
operator|->
name|fde_encoding
argument_list|)
expr_stmt|;
operator|*
name|buf
operator||=
name|DW_EH_PE_pcrel
expr_stmt|;
name|action
operator|&=
operator|~
literal|1
expr_stmt|;
block|}
name|buf
operator|++
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
break|break;
default|default:
name|BFD_FAIL
argument_list|()
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* FDE */
name|bfd_vma
name|value
decl_stmt|,
name|address
decl_stmt|;
name|unsigned
name|int
name|width
decl_stmt|;
comment|/* Skip length.  */
name|buf
operator|+=
literal|4
expr_stmt|;
name|value
operator|=
name|ent
operator|->
name|new_offset
operator|+
literal|4
operator|-
name|ent
operator|->
name|cie_inf
operator|->
name|new_offset
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|value
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|+=
literal|4
expr_stmt|;
name|width
operator|=
name|get_DW_EH_PE_width
argument_list|(
name|ent
operator|->
name|fde_encoding
argument_list|,
name|ptr_size
argument_list|)
expr_stmt|;
name|value
operator|=
name|read_value
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|,
name|width
argument_list|,
name|get_DW_EH_PE_signed
argument_list|(
name|ent
operator|->
name|fde_encoding
argument_list|)
argument_list|)
expr_stmt|;
name|address
operator|=
name|value
expr_stmt|;
if|if
condition|(
name|value
condition|)
block|{
switch|switch
condition|(
name|ent
operator|->
name|fde_encoding
operator|&
literal|0xf0
condition|)
block|{
case|case
name|DW_EH_PE_indirect
case|:
case|case
name|DW_EH_PE_textrel
case|:
name|BFD_ASSERT
argument_list|(
name|hdr_info
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_EH_PE_datarel
case|:
block|{
name|asection
modifier|*
name|got
init|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".got"
argument_list|)
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|got
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|address
operator|+=
name|got
operator|->
name|vma
expr_stmt|;
block|}
break|break;
case|case
name|DW_EH_PE_pcrel
case|:
name|value
operator|+=
name|ent
operator|->
name|offset
operator|-
name|ent
operator|->
name|new_offset
expr_stmt|;
name|address
operator|+=
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|ent
operator|->
name|offset
operator|+
literal|8
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ent
operator|->
name|cie_inf
operator|->
name|make_relative
condition|)
name|value
operator|-=
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|ent
operator|->
name|new_offset
operator|+
literal|8
expr_stmt|;
name|write_value
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|,
name|value
argument_list|,
name|width
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hdr_info
condition|)
block|{
name|hdr_info
operator|->
name|array
index|[
name|hdr_info
operator|->
name|array_count
index|]
operator|.
name|initial_loc
operator|=
name|address
expr_stmt|;
name|hdr_info
operator|->
name|array
index|[
name|hdr_info
operator|->
name|array_count
operator|++
index|]
operator|.
name|fde
operator|=
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|ent
operator|->
name|new_offset
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ent
operator|->
name|lsda_encoding
operator|&
literal|0xf0
operator|)
operator|==
name|DW_EH_PE_pcrel
operator|||
name|ent
operator|->
name|cie_inf
operator|->
name|need_lsda_relative
condition|)
block|{
name|buf
operator|+=
name|ent
operator|->
name|lsda_offset
expr_stmt|;
name|width
operator|=
name|get_DW_EH_PE_width
argument_list|(
name|ent
operator|->
name|lsda_encoding
argument_list|,
name|ptr_size
argument_list|)
expr_stmt|;
name|value
operator|=
name|read_value
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|,
name|width
argument_list|,
name|get_DW_EH_PE_signed
argument_list|(
name|ent
operator|->
name|lsda_encoding
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
block|{
if|if
condition|(
operator|(
name|ent
operator|->
name|lsda_encoding
operator|&
literal|0xf0
operator|)
operator|==
name|DW_EH_PE_pcrel
condition|)
name|value
operator|+=
name|ent
operator|->
name|offset
operator|-
name|ent
operator|->
name|new_offset
expr_stmt|;
elseif|else
if|if
condition|(
name|ent
operator|->
name|cie_inf
operator|->
name|need_lsda_relative
condition|)
name|value
operator|-=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|ent
operator|->
name|new_offset
operator|+
literal|8
operator|+
name|ent
operator|->
name|lsda_offset
operator|)
expr_stmt|;
name|write_value
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|,
name|value
argument_list|,
name|width
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ent
operator|->
name|cie_inf
operator|->
name|add_augmentation_size
condition|)
block|{
comment|/* Skip the PC and length and insert a zero byte for the 		 augmentation size.  */
name|buf
operator|+=
name|width
operator|*
literal|2
expr_stmt|;
name|memmove
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
name|buf
argument_list|,
name|end
operator|-
name|buf
argument_list|)
expr_stmt|;
operator|*
name|buf
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
comment|/* We don't align the section to its section alignment since the      runtime library only expects all CIE/FDE records aligned at      the pointer size. _bfd_elf_discard_section_eh_frame should       have padded CIE/FDE records to multiple of pointer size with      size_of_output_cie_fde.  */
if|if
condition|(
operator|(
name|sec
operator|->
name|size
operator|%
name|ptr_size
operator|)
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|sec
operator|->
name|output_section
argument_list|,
name|contents
argument_list|,
operator|(
name|file_ptr
operator|)
name|sec
operator|->
name|output_offset
argument_list|,
name|sec
operator|->
name|size
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Helper function used to sort .eh_frame_hdr search table by increasing    VMA of FDE initial location.  */
end_comment

begin_function
specifier|static
name|int
name|vma_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
specifier|const
name|struct
name|eh_frame_array_ent
modifier|*
name|p
init|=
name|a
decl_stmt|;
specifier|const
name|struct
name|eh_frame_array_ent
modifier|*
name|q
init|=
name|b
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|initial_loc
operator|>
name|q
operator|->
name|initial_loc
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|p
operator|->
name|initial_loc
operator|<
name|q
operator|->
name|initial_loc
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Write out .eh_frame_hdr section.  This must be called after    _bfd_elf_write_section_eh_frame has been called on all input    .eh_frame sections.    .eh_frame_hdr format:    ubyte version		(currently 1)    ubyte eh_frame_ptr_enc  	(DW_EH_PE_* encoding of pointer to start of 				 .eh_frame section)    ubyte fde_count_enc		(DW_EH_PE_* encoding of total FDE count 				 number (or DW_EH_PE_omit if there is no 				 binary search table computed))    ubyte table_enc		(DW_EH_PE_* encoding of binary search table, 				 or DW_EH_PE_omit if not present. 				 DW_EH_PE_datarel is using address of 				 .eh_frame_hdr section start as base)    [encoded] eh_frame_ptr	(pointer to start of .eh_frame section)    optionally followed by:    [encoded] fde_count		(total number of FDEs in .eh_frame section)    fde_count x [encoded] initial_loc, fde 				(array of encoded pairs containing 				 FDE initial_location field and FDE address, 				 sorted by increasing initial_loc).  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_elf_write_section_eh_frame_hdr
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|struct
name|eh_frame_hdr_info
modifier|*
name|hdr_info
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|asection
modifier|*
name|eh_frame_sec
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
name|bfd_boolean
name|retval
decl_stmt|;
name|bfd_vma
name|encoded_eh_frame
decl_stmt|;
name|htab
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|hdr_info
operator|=
operator|&
name|htab
operator|->
name|eh_info
expr_stmt|;
name|sec
operator|=
name|hdr_info
operator|->
name|hdr_sec
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
name|size
operator|=
name|EH_FRAME_HDR_SIZE
expr_stmt|;
if|if
condition|(
name|hdr_info
operator|->
name|array
operator|&&
name|hdr_info
operator|->
name|array_count
operator|==
name|hdr_info
operator|->
name|fde_count
condition|)
name|size
operator|+=
literal|4
operator|+
name|hdr_info
operator|->
name|fde_count
operator|*
literal|8
expr_stmt|;
name|contents
operator|=
name|bfd_malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|eh_frame_sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".eh_frame"
argument_list|)
expr_stmt|;
if|if
condition|(
name|eh_frame_sec
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|memset
argument_list|(
name|contents
argument_list|,
literal|0
argument_list|,
name|EH_FRAME_HDR_SIZE
argument_list|)
expr_stmt|;
name|contents
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Version.  */
name|contents
index|[
literal|1
index|]
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_backend_encode_eh_address
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|eh_frame_sec
argument_list|,
literal|0
argument_list|,
name|sec
argument_list|,
literal|4
argument_list|,
operator|&
name|encoded_eh_frame
argument_list|)
expr_stmt|;
comment|/* .eh_frame offset.  */
if|if
condition|(
name|hdr_info
operator|->
name|array
operator|&&
name|hdr_info
operator|->
name|array_count
operator|==
name|hdr_info
operator|->
name|fde_count
condition|)
block|{
name|contents
index|[
literal|2
index|]
operator|=
name|DW_EH_PE_udata4
expr_stmt|;
comment|/* FDE count encoding.  */
name|contents
index|[
literal|3
index|]
operator|=
name|DW_EH_PE_datarel
operator||
name|DW_EH_PE_sdata4
expr_stmt|;
comment|/* Search table enc.  */
block|}
else|else
block|{
name|contents
index|[
literal|2
index|]
operator|=
name|DW_EH_PE_omit
expr_stmt|;
name|contents
index|[
literal|3
index|]
operator|=
name|DW_EH_PE_omit
expr_stmt|;
block|}
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|encoded_eh_frame
argument_list|,
name|contents
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
index|[
literal|2
index|]
operator|!=
name|DW_EH_PE_omit
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|hdr_info
operator|->
name|fde_count
argument_list|,
name|contents
operator|+
name|EH_FRAME_HDR_SIZE
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|hdr_info
operator|->
name|array
argument_list|,
name|hdr_info
operator|->
name|fde_count
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hdr_info
operator|->
name|array
argument_list|)
argument_list|,
name|vma_compare
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hdr_info
operator|->
name|fde_count
condition|;
name|i
operator|++
control|)
block|{
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|hdr_info
operator|->
name|array
index|[
name|i
index|]
operator|.
name|initial_loc
operator|-
name|sec
operator|->
name|output_section
operator|->
name|vma
argument_list|,
name|contents
operator|+
name|EH_FRAME_HDR_SIZE
operator|+
name|i
operator|*
literal|8
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|hdr_info
operator|->
name|array
index|[
name|i
index|]
operator|.
name|fde
operator|-
name|sec
operator|->
name|output_section
operator|->
name|vma
argument_list|,
name|contents
operator|+
name|EH_FRAME_HDR_SIZE
operator|+
name|i
operator|*
literal|8
operator|+
literal|8
argument_list|)
expr_stmt|;
block|}
block|}
name|retval
operator|=
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|sec
operator|->
name|output_section
argument_list|,
name|contents
argument_list|,
operator|(
name|file_ptr
operator|)
name|sec
operator|->
name|output_offset
argument_list|,
name|sec
operator|->
name|size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Return the width of FDE addresses.  This is the default implementation.  */
end_comment

begin_function
name|unsigned
name|int
name|_bfd_elf_eh_frame_address_size
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_ident
index|[
name|EI_CLASS
index|]
operator|==
name|ELFCLASS64
condition|?
literal|8
else|:
literal|4
return|;
block|}
end_function

begin_comment
comment|/* Decide whether we can use a PC-relative encoding within the given    EH frame section.  This is the default implementation.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_elf_can_make_relative
parameter_list|(
name|bfd
modifier|*
name|input_bfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|eh_frame_section
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Select an encoding for the given address.  Preference is given to    PC-relative addressing modes.  */
end_comment

begin_function
name|bfd_byte
name|_bfd_elf_encode_eh_address
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|osec
parameter_list|,
name|bfd_vma
name|offset
parameter_list|,
name|asection
modifier|*
name|loc_sec
parameter_list|,
name|bfd_vma
name|loc_offset
parameter_list|,
name|bfd_vma
modifier|*
name|encoded
parameter_list|)
block|{
operator|*
name|encoded
operator|=
name|osec
operator|->
name|vma
operator|+
name|offset
operator|-
operator|(
name|loc_sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|loc_sec
operator|->
name|output_offset
operator|+
name|loc_offset
operator|)
expr_stmt|;
return|return
name|DW_EH_PE_pcrel
operator||
name|DW_EH_PE_sdata4
return|;
block|}
end_function

end_unit

