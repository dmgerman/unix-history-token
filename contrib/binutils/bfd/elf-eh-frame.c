begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* .eh_frame section optimization.    Copyright 2001, 2002 Free Software Foundation, Inc.    Written by Jakub Jelinek<jakub@redhat.com>.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf/dwarf2.h"
end_include

begin_define
define|#
directive|define
name|EH_FRAME_HDR_SIZE
value|8
end_define

begin_struct
struct|struct
name|cie_header
block|{
name|unsigned
name|int
name|length
decl_stmt|;
name|unsigned
name|int
name|id
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|cie
block|{
name|struct
name|cie_header
name|hdr
decl_stmt|;
name|unsigned
name|char
name|version
decl_stmt|;
name|unsigned
name|char
name|augmentation
index|[
literal|20
index|]
decl_stmt|;
name|unsigned
name|int
name|code_align
decl_stmt|;
name|int
name|data_align
decl_stmt|;
name|unsigned
name|int
name|ra_column
decl_stmt|;
name|unsigned
name|int
name|augmentation_size
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|personality
decl_stmt|;
name|unsigned
name|char
name|per_encoding
decl_stmt|;
name|unsigned
name|char
name|lsda_encoding
decl_stmt|;
name|unsigned
name|char
name|fde_encoding
decl_stmt|;
name|unsigned
name|char
name|initial_insn_length
decl_stmt|;
name|unsigned
name|char
name|make_relative
decl_stmt|;
name|unsigned
name|char
name|make_lsda_relative
decl_stmt|;
name|unsigned
name|char
name|initial_instructions
index|[
literal|50
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|eh_cie_fde
block|{
name|unsigned
name|int
name|offset
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|unsigned
name|int
name|new_offset
decl_stmt|;
name|unsigned
name|char
name|fde_encoding
decl_stmt|;
name|unsigned
name|char
name|lsda_encoding
decl_stmt|;
name|unsigned
name|char
name|lsda_offset
decl_stmt|;
name|unsigned
name|char
name|cie
range|:
literal|1
decl_stmt|;
name|unsigned
name|char
name|removed
range|:
literal|1
decl_stmt|;
name|unsigned
name|char
name|make_relative
range|:
literal|1
decl_stmt|;
name|unsigned
name|char
name|make_lsda_relative
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|eh_frame_sec_info
block|{
name|unsigned
name|int
name|count
decl_stmt|;
name|unsigned
name|int
name|alloced
decl_stmt|;
name|struct
name|eh_cie_fde
name|entry
index|[
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|eh_frame_array_ent
block|{
name|bfd_vma
name|initial_loc
decl_stmt|;
name|bfd_vma
name|fde
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|eh_frame_hdr_info
block|{
name|struct
name|cie
name|last_cie
decl_stmt|;
name|asection
modifier|*
name|last_cie_sec
decl_stmt|;
name|unsigned
name|int
name|last_cie_offset
decl_stmt|;
name|unsigned
name|int
name|fde_count
decl_stmt|,
name|array_count
decl_stmt|;
name|struct
name|eh_frame_array_ent
modifier|*
name|array
decl_stmt|;
comment|/* TRUE if .eh_frame_hdr should contain the sorted search table.      We build it if we successfully read all .eh_frame input sections      and recognize them.  */
name|boolean
name|table
decl_stmt|;
name|boolean
name|strip
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|bfd_vma
name|read_unsigned_leb128
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|char
operator|*
operator|,
name|unsigned
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_signed_vma
name|read_signed_leb128
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|char
operator|*
operator|,
name|unsigned
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_DW_EH_PE_width
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|read_value
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_value
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|bfd_vma
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cie_compare
name|PARAMS
argument_list|(
operator|(
expr|struct
name|cie
operator|*
operator|,
expr|struct
name|cie
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|vma_compare
name|PARAMS
argument_list|(
operator|(
specifier|const
name|PTR
name|a
operator|,
specifier|const
name|PTR
name|b
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Helper function for reading uleb128 encoded data.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|read_unsigned_leb128
parameter_list|(
name|abfd
parameter_list|,
name|buf
parameter_list|,
name|bytes_read_ptr
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|int
modifier|*
name|bytes_read_ptr
decl_stmt|;
block|{
name|bfd_vma
name|result
decl_stmt|;
name|unsigned
name|int
name|num_read
decl_stmt|;
name|int
name|shift
decl_stmt|;
name|unsigned
name|char
name|byte
decl_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
name|shift
operator|=
literal|0
expr_stmt|;
name|num_read
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|byte
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|++
expr_stmt|;
name|num_read
operator|++
expr_stmt|;
name|result
operator||=
operator|(
operator|(
operator|(
name|bfd_vma
operator|)
name|byte
operator|&
literal|0x7f
operator|)
operator|<<
name|shift
operator|)
expr_stmt|;
name|shift
operator|+=
literal|7
expr_stmt|;
block|}
do|while
condition|(
name|byte
operator|&
literal|0x80
condition|)
do|;
operator|*
name|bytes_read_ptr
operator|=
name|num_read
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Helper function for reading sleb128 encoded data.  */
end_comment

begin_function
specifier|static
name|bfd_signed_vma
name|read_signed_leb128
parameter_list|(
name|abfd
parameter_list|,
name|buf
parameter_list|,
name|bytes_read_ptr
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|int
modifier|*
name|bytes_read_ptr
decl_stmt|;
block|{
name|bfd_vma
name|result
decl_stmt|;
name|int
name|shift
decl_stmt|;
name|int
name|num_read
decl_stmt|;
name|unsigned
name|char
name|byte
decl_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
name|shift
operator|=
literal|0
expr_stmt|;
name|num_read
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|byte
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|++
expr_stmt|;
name|num_read
operator|++
expr_stmt|;
name|result
operator||=
operator|(
operator|(
operator|(
name|bfd_vma
operator|)
name|byte
operator|&
literal|0x7f
operator|)
operator|<<
name|shift
operator|)
expr_stmt|;
name|shift
operator|+=
literal|7
expr_stmt|;
block|}
do|while
condition|(
name|byte
operator|&
literal|0x80
condition|)
do|;
if|if
condition|(
name|byte
operator|&
literal|0x40
condition|)
name|result
operator||=
operator|(
operator|(
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|)
operator|<<
operator|(
name|shift
operator|-
literal|7
operator|)
operator|)
operator|<<
literal|7
expr_stmt|;
operator|*
name|bytes_read_ptr
operator|=
name|num_read
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_define
define|#
directive|define
name|read_uleb128
parameter_list|(
name|VAR
parameter_list|,
name|BUF
parameter_list|)
define|\
value|do								\   {								\     (VAR) = read_unsigned_leb128 (abfd, buf,&leb128_tmp);	\     (BUF) += leb128_tmp;					\   }								\ while (0)
end_define

begin_define
define|#
directive|define
name|read_sleb128
parameter_list|(
name|VAR
parameter_list|,
name|BUF
parameter_list|)
define|\
value|do								\   {								\     (VAR) = read_signed_leb128 (abfd, buf,&leb128_tmp);	\     (BUF) += leb128_tmp;					\   }								\ while (0)
end_define

begin_comment
comment|/* Return 0 if either encoding is variable width, or not yet known to bfd.  */
end_comment

begin_function
specifier|static
name|int
name|get_DW_EH_PE_width
parameter_list|(
name|encoding
parameter_list|,
name|ptr_size
parameter_list|)
name|int
name|encoding
decl_stmt|,
name|ptr_size
decl_stmt|;
block|{
comment|/* DW_EH_PE_ values of 0x60 and 0x70 weren't defined at the time .eh_frame      was added to bfd.  */
if|if
condition|(
operator|(
name|encoding
operator|&
literal|0x60
operator|)
operator|==
literal|0x60
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|encoding
operator|&
literal|7
condition|)
block|{
case|case
name|DW_EH_PE_udata2
case|:
return|return
literal|2
return|;
case|case
name|DW_EH_PE_udata4
case|:
return|return
literal|4
return|;
case|case
name|DW_EH_PE_udata8
case|:
return|return
literal|8
return|;
case|case
name|DW_EH_PE_absptr
case|:
return|return
name|ptr_size
return|;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Read a width sized value from memory.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|read_value
parameter_list|(
name|abfd
parameter_list|,
name|buf
parameter_list|,
name|width
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|bfd_byte
modifier|*
name|buf
decl_stmt|;
name|int
name|width
decl_stmt|;
block|{
name|bfd_vma
name|value
decl_stmt|;
switch|switch
condition|(
name|width
condition|)
block|{
case|case
literal|2
case|:
name|value
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|value
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|value
operator|=
name|bfd_get_64
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
default|default:
name|BFD_FAIL
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* Store a width sized value to memory.  */
end_comment

begin_function
specifier|static
name|void
name|write_value
parameter_list|(
name|abfd
parameter_list|,
name|buf
parameter_list|,
name|value
parameter_list|,
name|width
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|bfd_byte
modifier|*
name|buf
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
name|int
name|width
decl_stmt|;
block|{
switch|switch
condition|(
name|width
condition|)
block|{
case|case
literal|2
case|:
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|value
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|value
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|bfd_put_64
argument_list|(
name|abfd
argument_list|,
name|value
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
default|default:
name|BFD_FAIL
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return zero if C1 and C2 CIEs can be merged.  */
end_comment

begin_function
specifier|static
name|int
name|cie_compare
parameter_list|(
name|c1
parameter_list|,
name|c2
parameter_list|)
name|struct
name|cie
modifier|*
name|c1
decl_stmt|,
decl|*
name|c2
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|c1
operator|->
name|hdr
operator|.
name|length
operator|==
name|c2
operator|->
name|hdr
operator|.
name|length
operator|&&
name|c1
operator|->
name|version
operator|==
name|c2
operator|->
name|version
operator|&&
name|strcmp
argument_list|(
name|c1
operator|->
name|augmentation
argument_list|,
name|c2
operator|->
name|augmentation
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|c1
operator|->
name|augmentation
argument_list|,
literal|"eh"
argument_list|)
operator|!=
literal|0
operator|&&
name|c1
operator|->
name|code_align
operator|==
name|c2
operator|->
name|code_align
operator|&&
name|c1
operator|->
name|data_align
operator|==
name|c2
operator|->
name|data_align
operator|&&
name|c1
operator|->
name|ra_column
operator|==
name|c2
operator|->
name|ra_column
operator|&&
name|c1
operator|->
name|augmentation_size
operator|==
name|c2
operator|->
name|augmentation_size
operator|&&
name|c1
operator|->
name|personality
operator|==
name|c2
operator|->
name|personality
operator|&&
name|c1
operator|->
name|per_encoding
operator|==
name|c2
operator|->
name|per_encoding
operator|&&
name|c1
operator|->
name|lsda_encoding
operator|==
name|c2
operator|->
name|lsda_encoding
operator|&&
name|c1
operator|->
name|fde_encoding
operator|==
name|c2
operator|->
name|fde_encoding
operator|&&
operator|(
name|c1
operator|->
name|initial_insn_length
operator|==
name|c2
operator|->
name|initial_insn_length
operator|)
operator|&&
name|memcmp
argument_list|(
name|c1
operator|->
name|initial_instructions
argument_list|,
name|c2
operator|->
name|initial_instructions
argument_list|,
name|c1
operator|->
name|initial_insn_length
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/* This function is called for each input file before the .eh_frame    section is relocated.  It discards duplicate CIEs and FDEs for discarded    functions.  The function returns true iff any entries have been    deleted.  */
end_comment

begin_decl_stmt
name|boolean
name|_bfd_elf_discard_section_eh_frame
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|sec
argument_list|,
name|ehdrsec
argument_list|,
name|reloc_symbol_deleted_p
argument_list|,
name|cookie
argument_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|asection
modifier|*
name|sec
decl_stmt|,
modifier|*
name|ehdrsec
decl_stmt|;
end_decl_stmt

begin_function_decl
name|boolean
function_decl|(
modifier|*
name|reloc_symbol_deleted_p
function_decl|)
parameter_list|(
name|bfd_vma
parameter_list|,
name|PTR
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|elf_reloc_cookie
modifier|*
name|cookie
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|bfd_byte
modifier|*
name|ehbuf
init|=
name|NULL
decl_stmt|,
modifier|*
name|buf
decl_stmt|;
name|bfd_byte
modifier|*
name|last_cie
decl_stmt|,
modifier|*
name|last_fde
decl_stmt|;
name|struct
name|cie_header
name|hdr
decl_stmt|;
name|struct
name|cie
name|cie
decl_stmt|;
name|struct
name|eh_frame_hdr_info
modifier|*
name|hdr_info
decl_stmt|;
name|struct
name|eh_frame_sec_info
modifier|*
name|sec_info
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|leb128_tmp
decl_stmt|;
name|unsigned
name|int
name|cie_usage_count
decl_stmt|,
name|last_cie_ndx
decl_stmt|,
name|i
decl_stmt|,
name|offset
decl_stmt|;
name|unsigned
name|int
name|make_relative
decl_stmt|,
name|make_lsda_relative
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|bfd_size_type
name|new_size
decl_stmt|;
name|unsigned
name|int
name|ptr_size
decl_stmt|;
if|if
condition|(
name|sec
operator|->
name|_raw_size
operator|==
literal|0
condition|)
block|{
comment|/* This file does not contain .eh_frame information.  */
return|return
name|false
return|;
block|}
if|if
condition|(
operator|(
name|sec
operator|->
name|output_section
operator|!=
name|NULL
operator|&&
name|bfd_is_abs_section
argument_list|(
name|sec
operator|->
name|output_section
argument_list|)
operator|)
condition|)
block|{
comment|/* At least one of the sections is being discarded from the          link, so we should just ignore them.  */
return|return
name|false
return|;
block|}
name|BFD_ASSERT
argument_list|(
name|elf_section_data
argument_list|(
name|ehdrsec
argument_list|)
operator|->
name|sec_info_type
operator|==
name|ELF_INFO_TYPE_EH_FRAME_HDR
argument_list|)
expr_stmt|;
name|hdr_info
operator|=
operator|(
expr|struct
name|eh_frame_hdr_info
operator|*
operator|)
name|elf_section_data
argument_list|(
name|ehdrsec
argument_list|)
operator|->
name|sec_info
expr_stmt|;
comment|/* Read the frame unwind information from abfd.  */
name|ehbuf
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|sec
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ehbuf
operator|==
name|NULL
condition|)
goto|goto
name|free_no_table
goto|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|ehbuf
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|sec
operator|->
name|_raw_size
argument_list|)
condition|)
goto|goto
name|free_no_table
goto|;
if|if
condition|(
name|sec
operator|->
name|_raw_size
operator|>=
literal|4
operator|&&
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|ehbuf
argument_list|)
operator|==
literal|0
operator|&&
name|cookie
operator|->
name|rel
operator|==
name|cookie
operator|->
name|relend
condition|)
block|{
comment|/* Empty .eh_frame section.  */
name|free
argument_list|(
name|ehbuf
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* If .eh_frame section size doesn't fit into int, we cannot handle      it (it would need to use 64-bit .eh_frame format anyway).  */
if|if
condition|(
name|sec
operator|->
name|_raw_size
operator|!=
operator|(
name|unsigned
name|int
operator|)
name|sec
operator|->
name|_raw_size
condition|)
goto|goto
name|free_no_table
goto|;
name|ptr_size
operator|=
operator|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_ident
index|[
name|EI_CLASS
index|]
operator|==
name|ELFCLASS64
operator|)
condition|?
literal|8
else|:
literal|4
expr_stmt|;
name|buf
operator|=
name|ehbuf
expr_stmt|;
name|last_cie
operator|=
name|NULL
expr_stmt|;
name|last_cie_ndx
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
name|cie
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cie
argument_list|)
argument_list|)
expr_stmt|;
name|cie_usage_count
operator|=
literal|0
expr_stmt|;
name|new_size
operator|=
name|sec
operator|->
name|_raw_size
expr_stmt|;
name|make_relative
operator|=
name|hdr_info
operator|->
name|last_cie
operator|.
name|make_relative
expr_stmt|;
name|make_lsda_relative
operator|=
name|hdr_info
operator|->
name|last_cie
operator|.
name|make_lsda_relative
expr_stmt|;
name|sec_info
operator|=
name|bfd_zmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|eh_frame_sec_info
argument_list|)
operator|+
literal|99
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|eh_cie_fde
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec_info
operator|==
name|NULL
condition|)
goto|goto
name|free_no_table
goto|;
name|sec_info
operator|->
name|alloced
operator|=
literal|100
expr_stmt|;
define|#
directive|define
name|ENSURE_NO_RELOCS
parameter_list|(
name|buf
parameter_list|)
define|\
value|if (cookie->rel< cookie->relend			\&& (cookie->rel->r_offset				\< (bfd_size_type) ((buf) - ehbuf)))		\     goto free_no_table
define|#
directive|define
name|SKIP_RELOCS
parameter_list|(
name|buf
parameter_list|)
define|\
value|while (cookie->rel< cookie->relend			\&& (cookie->rel->r_offset			\< (bfd_size_type) ((buf) - ehbuf)))	\     cookie->rel++
define|#
directive|define
name|GET_RELOC
parameter_list|(
name|buf
parameter_list|)
define|\
value|((cookie->rel< cookie->relend			\&& (cookie->rel->r_offset				\         == (bfd_size_type) ((buf) - ehbuf)))		\    ? cookie->rel : NULL)
for|for
control|(
init|;
condition|;
control|)
block|{
name|unsigned
name|char
modifier|*
name|aug
decl_stmt|;
if|if
condition|(
name|sec_info
operator|->
name|count
operator|==
name|sec_info
operator|->
name|alloced
condition|)
block|{
name|sec_info
operator|=
name|bfd_realloc
argument_list|(
name|sec_info
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|eh_frame_sec_info
argument_list|)
operator|+
operator|(
name|sec_info
operator|->
name|alloced
operator|+
literal|99
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|eh_cie_fde
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec_info
operator|==
name|NULL
condition|)
goto|goto
name|free_no_table
goto|;
name|memset
argument_list|(
operator|&
name|sec_info
operator|->
name|entry
index|[
name|sec_info
operator|->
name|alloced
index|]
argument_list|,
literal|0
argument_list|,
literal|100
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|eh_cie_fde
argument_list|)
argument_list|)
expr_stmt|;
name|sec_info
operator|->
name|alloced
operator|+=
literal|100
expr_stmt|;
block|}
name|last_fde
operator|=
name|buf
expr_stmt|;
comment|/* If we are at the end of the section, we still need to decide 	 on whether to output or discard last encountered CIE (if any).  */
if|if
condition|(
call|(
name|bfd_size_type
call|)
argument_list|(
name|buf
operator|-
name|ehbuf
argument_list|)
operator|==
name|sec
operator|->
name|_raw_size
condition|)
name|hdr
operator|.
name|id
operator|=
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
call|(
name|bfd_size_type
call|)
argument_list|(
name|buf
operator|+
literal|4
operator|-
name|ehbuf
argument_list|)
operator|>
name|sec
operator|->
name|_raw_size
condition|)
comment|/* No space for CIE/FDE header length.  */
goto|goto
name|free_no_table
goto|;
name|hdr
operator|.
name|length
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr
operator|.
name|length
operator|==
literal|0xffffffff
condition|)
comment|/* 64-bit .eh_frame is not supported.  */
goto|goto
name|free_no_table
goto|;
name|buf
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
operator|(
name|buf
operator|-
name|ehbuf
operator|)
operator|+
name|hdr
operator|.
name|length
operator|>
name|sec
operator|->
name|_raw_size
condition|)
comment|/* CIE/FDE not contained fully in this .eh_frame input section.  */
goto|goto
name|free_no_table
goto|;
name|sec_info
operator|->
name|entry
index|[
name|sec_info
operator|->
name|count
index|]
operator|.
name|offset
operator|=
name|last_fde
operator|-
name|ehbuf
expr_stmt|;
name|sec_info
operator|->
name|entry
index|[
name|sec_info
operator|->
name|count
index|]
operator|.
name|size
operator|=
literal|4
operator|+
name|hdr
operator|.
name|length
expr_stmt|;
if|if
condition|(
name|hdr
operator|.
name|length
operator|==
literal|0
condition|)
block|{
comment|/* CIE with length 0 must be only the last in the section.  */
if|if
condition|(
call|(
name|bfd_size_type
call|)
argument_list|(
name|buf
operator|-
name|ehbuf
argument_list|)
operator|<
name|sec
operator|->
name|_raw_size
condition|)
goto|goto
name|free_no_table
goto|;
name|ENSURE_NO_RELOCS
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|sec_info
operator|->
name|count
operator|++
expr_stmt|;
comment|/* Now just finish last encountered CIE processing and break 		 the loop.  */
name|hdr
operator|.
name|id
operator|=
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|hdr
operator|.
name|id
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|hdr
operator|.
name|id
operator|==
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
condition|)
goto|goto
name|free_no_table
goto|;
block|}
block|}
if|if
condition|(
name|hdr
operator|.
name|id
operator|==
literal|0
operator|||
name|hdr
operator|.
name|id
operator|==
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
condition|)
block|{
name|unsigned
name|int
name|initial_insn_length
decl_stmt|;
comment|/* CIE  */
if|if
condition|(
name|last_cie
operator|!=
name|NULL
condition|)
block|{
comment|/* Now check if this CIE is identical to last CIE, in which case 		 we can remove it, provided we adjust all FDEs. 		 Also, it can be removed if we have removed all FDEs using 		 that. */
if|if
condition|(
name|cie_compare
argument_list|(
operator|&
name|cie
argument_list|,
operator|&
name|hdr_info
operator|->
name|last_cie
argument_list|)
operator|==
literal|0
operator|||
name|cie_usage_count
operator|==
literal|0
condition|)
block|{
name|new_size
operator|-=
name|cie
operator|.
name|hdr
operator|.
name|length
operator|+
literal|4
expr_stmt|;
name|sec_info
operator|->
name|entry
index|[
name|last_cie_ndx
index|]
operator|.
name|removed
operator|=
literal|1
expr_stmt|;
name|sec_info
operator|->
name|entry
index|[
name|last_cie_ndx
index|]
operator|.
name|sec
operator|=
name|hdr_info
operator|->
name|last_cie_sec
expr_stmt|;
name|sec_info
operator|->
name|entry
index|[
name|last_cie_ndx
index|]
operator|.
name|new_offset
operator|=
name|hdr_info
operator|->
name|last_cie_offset
expr_stmt|;
block|}
else|else
block|{
name|hdr_info
operator|->
name|last_cie
operator|=
name|cie
expr_stmt|;
name|hdr_info
operator|->
name|last_cie_sec
operator|=
name|sec
expr_stmt|;
name|hdr_info
operator|->
name|last_cie_offset
operator|=
name|last_cie
operator|-
name|ehbuf
expr_stmt|;
name|sec_info
operator|->
name|entry
index|[
name|last_cie_ndx
index|]
operator|.
name|make_relative
operator|=
name|cie
operator|.
name|make_relative
expr_stmt|;
name|sec_info
operator|->
name|entry
index|[
name|last_cie_ndx
index|]
operator|.
name|make_lsda_relative
operator|=
name|cie
operator|.
name|make_lsda_relative
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hdr
operator|.
name|id
operator|==
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
condition|)
break|break;
name|last_cie_ndx
operator|=
name|sec_info
operator|->
name|count
expr_stmt|;
name|sec_info
operator|->
name|entry
index|[
name|sec_info
operator|->
name|count
index|]
operator|.
name|cie
operator|=
literal|1
expr_stmt|;
name|cie_usage_count
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
name|cie
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cie
argument_list|)
argument_list|)
expr_stmt|;
name|cie
operator|.
name|hdr
operator|=
name|hdr
expr_stmt|;
name|cie
operator|.
name|version
operator|=
operator|*
name|buf
operator|++
expr_stmt|;
comment|/* Cannot handle unknown versions.  */
if|if
condition|(
name|cie
operator|.
name|version
operator|!=
literal|1
condition|)
goto|goto
name|free_no_table
goto|;
if|if
condition|(
name|strlen
argument_list|(
name|buf
argument_list|)
operator|>
sizeof|sizeof
argument_list|(
name|cie
operator|.
name|augmentation
argument_list|)
operator|-
literal|1
condition|)
goto|goto
name|free_no_table
goto|;
name|strcpy
argument_list|(
name|cie
operator|.
name|augmentation
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|=
name|strchr
argument_list|(
name|buf
argument_list|,
literal|'\0'
argument_list|)
operator|+
literal|1
expr_stmt|;
name|ENSURE_NO_RELOCS
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'e'
operator|&&
name|buf
index|[
literal|1
index|]
operator|==
literal|'h'
condition|)
block|{
comment|/* GCC< 3.0 .eh_frame CIE */
comment|/* We cannot merge "eh" CIEs because __EXCEPTION_TABLE__ 		 is private to each CIE, so we don't need it for anything. 		 Just skip it.  */
name|buf
operator|+=
name|ptr_size
expr_stmt|;
name|SKIP_RELOCS
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|read_uleb128
argument_list|(
name|cie
operator|.
name|code_align
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|read_sleb128
argument_list|(
name|cie
operator|.
name|data_align
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|read_uleb128
argument_list|(
name|cie
operator|.
name|ra_column
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|ENSURE_NO_RELOCS
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|cie
operator|.
name|lsda_encoding
operator|=
name|DW_EH_PE_omit
expr_stmt|;
name|cie
operator|.
name|fde_encoding
operator|=
name|DW_EH_PE_omit
expr_stmt|;
name|cie
operator|.
name|per_encoding
operator|=
name|DW_EH_PE_omit
expr_stmt|;
name|aug
operator|=
name|cie
operator|.
name|augmentation
expr_stmt|;
if|if
condition|(
name|aug
index|[
literal|0
index|]
operator|!=
literal|'e'
operator|||
name|aug
index|[
literal|1
index|]
operator|!=
literal|'h'
condition|)
block|{
if|if
condition|(
operator|*
name|aug
operator|==
literal|'z'
condition|)
block|{
name|aug
operator|++
expr_stmt|;
name|read_uleb128
argument_list|(
name|cie
operator|.
name|augmentation_size
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|ENSURE_NO_RELOCS
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|aug
operator|!=
literal|'\0'
condition|)
switch|switch
condition|(
operator|*
name|aug
operator|++
condition|)
block|{
case|case
literal|'L'
case|:
name|cie
operator|.
name|lsda_encoding
operator|=
operator|*
name|buf
operator|++
expr_stmt|;
name|ENSURE_NO_RELOCS
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_DW_EH_PE_width
argument_list|(
name|cie
operator|.
name|lsda_encoding
argument_list|,
name|ptr_size
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|free_no_table
goto|;
break|break;
case|case
literal|'R'
case|:
name|cie
operator|.
name|fde_encoding
operator|=
operator|*
name|buf
operator|++
expr_stmt|;
name|ENSURE_NO_RELOCS
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_DW_EH_PE_width
argument_list|(
name|cie
operator|.
name|fde_encoding
argument_list|,
name|ptr_size
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|free_no_table
goto|;
break|break;
case|case
literal|'P'
case|:
block|{
name|int
name|per_width
decl_stmt|;
name|cie
operator|.
name|per_encoding
operator|=
operator|*
name|buf
operator|++
expr_stmt|;
name|per_width
operator|=
name|get_DW_EH_PE_width
argument_list|(
name|cie
operator|.
name|per_encoding
argument_list|,
name|ptr_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|per_width
operator|==
literal|0
condition|)
goto|goto
name|free_no_table
goto|;
if|if
condition|(
operator|(
name|cie
operator|.
name|per_encoding
operator|&
literal|0xf0
operator|)
operator|==
name|DW_EH_PE_aligned
condition|)
name|buf
operator|=
operator|(
name|ehbuf
operator|+
operator|(
operator|(
name|buf
operator|-
name|ehbuf
operator|+
name|per_width
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
operator|(
name|bfd_size_type
operator|)
name|per_width
operator|-
literal|1
operator|)
operator|)
operator|)
expr_stmt|;
name|ENSURE_NO_RELOCS
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|rel
operator|=
name|GET_RELOC
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* Ensure we have a reloc here, against 			 a global symbol.  */
if|if
condition|(
name|rel
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
ifdef|#
directive|ifdef
name|BFD64
if|if
condition|(
name|ptr_size
operator|==
literal|8
condition|)
name|r_symndx
operator|=
name|ELF64_R_SYM
argument_list|(
name|cookie
operator|->
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|cookie
operator|->
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|>=
name|cookie
operator|->
name|locsymcount
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|r_symndx
operator|-=
name|cookie
operator|->
name|extsymoff
expr_stmt|;
name|h
operator|=
name|cookie
operator|->
name|sym_hashes
index|[
name|r_symndx
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|cie
operator|.
name|personality
operator|=
name|h
expr_stmt|;
block|}
name|cookie
operator|->
name|rel
operator|++
expr_stmt|;
block|}
name|buf
operator|+=
name|per_width
expr_stmt|;
block|}
break|break;
default|default:
comment|/* Unrecognized augmentation. Better bail out.  */
goto|goto
name|free_no_table
goto|;
block|}
block|}
comment|/* For shared libraries, try to get rid of as many RELATIVE relocs 	     as possible. 	     FIXME: For this to work, ELF backends need to perform the 	     relocation if omitting dynamic relocs, not skip it.  */
if|if
condition|(
literal|0
operator|&&
name|info
operator|->
name|shared
operator|&&
operator|(
name|cie
operator|.
name|fde_encoding
operator|&
literal|0xf0
operator|)
operator|==
name|DW_EH_PE_absptr
condition|)
name|cie
operator|.
name|make_relative
operator|=
literal|1
expr_stmt|;
if|if
condition|(
literal|0
operator|&&
name|info
operator|->
name|shared
operator|&&
operator|(
name|cie
operator|.
name|lsda_encoding
operator|&
literal|0xf0
operator|)
operator|==
name|DW_EH_PE_absptr
condition|)
name|cie
operator|.
name|make_lsda_relative
operator|=
literal|1
expr_stmt|;
comment|/* If FDE encoding was not specified, it defaults to 	     DW_EH_absptr.  */
if|if
condition|(
name|cie
operator|.
name|fde_encoding
operator|==
name|DW_EH_PE_omit
condition|)
name|cie
operator|.
name|fde_encoding
operator|=
name|DW_EH_PE_absptr
expr_stmt|;
name|initial_insn_length
operator|=
name|cie
operator|.
name|hdr
operator|.
name|length
operator|-
operator|(
name|buf
operator|-
name|last_fde
operator|-
literal|4
operator|)
expr_stmt|;
if|if
condition|(
name|initial_insn_length
operator|<=
literal|50
condition|)
block|{
name|cie
operator|.
name|initial_insn_length
operator|=
name|initial_insn_length
expr_stmt|;
name|memcpy
argument_list|(
name|cie
operator|.
name|initial_instructions
argument_list|,
name|buf
argument_list|,
name|initial_insn_length
argument_list|)
expr_stmt|;
block|}
name|buf
operator|+=
name|initial_insn_length
expr_stmt|;
name|ENSURE_NO_RELOCS
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|last_cie
operator|=
name|last_fde
expr_stmt|;
block|}
else|else
block|{
comment|/* Ensure this FDE uses the last CIE encountered.  */
if|if
condition|(
name|last_cie
operator|==
name|NULL
operator|||
name|hdr
operator|.
name|id
operator|!=
call|(
name|unsigned
name|int
call|)
argument_list|(
name|buf
operator|-
literal|4
operator|-
name|last_cie
argument_list|)
condition|)
goto|goto
name|free_no_table
goto|;
name|ENSURE_NO_RELOCS
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|rel
operator|=
name|GET_RELOC
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|rel
operator|==
name|NULL
condition|)
comment|/* This should not happen.  */
goto|goto
name|free_no_table
goto|;
if|if
condition|(
call|(
modifier|*
name|reloc_symbol_deleted_p
call|)
argument_list|(
name|buf
operator|-
name|ehbuf
argument_list|,
name|cookie
argument_list|)
condition|)
block|{
name|cookie
operator|->
name|rel
operator|=
name|rel
expr_stmt|;
comment|/* This is a FDE against discarded section, it should 		 be deleted.  */
name|new_size
operator|-=
name|hdr
operator|.
name|length
operator|+
literal|4
expr_stmt|;
name|sec_info
operator|->
name|entry
index|[
name|sec_info
operator|->
name|count
index|]
operator|.
name|removed
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|cie_usage_count
operator|++
expr_stmt|;
name|hdr_info
operator|->
name|fde_count
operator|++
expr_stmt|;
block|}
name|cookie
operator|->
name|rel
operator|=
name|rel
expr_stmt|;
if|if
condition|(
name|cie
operator|.
name|lsda_encoding
operator|!=
name|DW_EH_PE_omit
condition|)
block|{
name|unsigned
name|int
name|dummy
decl_stmt|;
name|aug
operator|=
name|buf
expr_stmt|;
name|buf
operator|+=
literal|2
operator|*
name|get_DW_EH_PE_width
argument_list|(
name|cie
operator|.
name|fde_encoding
argument_list|,
name|ptr_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|cie
operator|.
name|augmentation
index|[
literal|0
index|]
operator|==
literal|'z'
condition|)
name|read_uleb128
argument_list|(
name|dummy
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* If some new augmentation data is added before LSDA 		 in FDE augmentation area, this need to be adjusted.  */
name|sec_info
operator|->
name|entry
index|[
name|sec_info
operator|->
name|count
index|]
operator|.
name|lsda_offset
operator|=
operator|(
name|buf
operator|-
name|aug
operator|)
expr_stmt|;
block|}
name|buf
operator|=
name|last_fde
operator|+
literal|4
operator|+
name|hdr
operator|.
name|length
expr_stmt|;
name|SKIP_RELOCS
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|sec_info
operator|->
name|entry
index|[
name|sec_info
operator|->
name|count
index|]
operator|.
name|fde_encoding
operator|=
name|cie
operator|.
name|fde_encoding
expr_stmt|;
name|sec_info
operator|->
name|entry
index|[
name|sec_info
operator|->
name|count
index|]
operator|.
name|lsda_encoding
operator|=
name|cie
operator|.
name|lsda_encoding
expr_stmt|;
name|sec_info
operator|->
name|count
operator|++
expr_stmt|;
block|}
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|sec_info
operator|=
name|sec_info
expr_stmt|;
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|sec_info_type
operator|=
name|ELF_INFO_TYPE_EH_FRAME
expr_stmt|;
comment|/* Ok, now we can assign new offsets.  */
name|offset
operator|=
literal|0
expr_stmt|;
name|last_cie_ndx
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sec_info
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|sec_info
operator|->
name|entry
index|[
name|i
index|]
operator|.
name|removed
condition|)
block|{
name|sec_info
operator|->
name|entry
index|[
name|i
index|]
operator|.
name|new_offset
operator|=
name|offset
expr_stmt|;
name|offset
operator|+=
name|sec_info
operator|->
name|entry
index|[
name|i
index|]
operator|.
name|size
expr_stmt|;
if|if
condition|(
name|sec_info
operator|->
name|entry
index|[
name|i
index|]
operator|.
name|cie
condition|)
block|{
name|last_cie_ndx
operator|=
name|i
expr_stmt|;
name|make_relative
operator|=
name|sec_info
operator|->
name|entry
index|[
name|i
index|]
operator|.
name|make_relative
expr_stmt|;
name|make_lsda_relative
operator|=
name|sec_info
operator|->
name|entry
index|[
name|i
index|]
operator|.
name|make_lsda_relative
expr_stmt|;
block|}
else|else
block|{
name|sec_info
operator|->
name|entry
index|[
name|i
index|]
operator|.
name|make_relative
operator|=
name|make_relative
expr_stmt|;
name|sec_info
operator|->
name|entry
index|[
name|i
index|]
operator|.
name|make_lsda_relative
operator|=
name|make_lsda_relative
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sec_info
operator|->
name|entry
index|[
name|i
index|]
operator|.
name|cie
operator|&&
name|sec_info
operator|->
name|entry
index|[
name|i
index|]
operator|.
name|sec
operator|==
name|sec
condition|)
block|{
comment|/* Need to adjust new_offset too.  */
name|BFD_ASSERT
argument_list|(
name|sec_info
operator|->
name|entry
index|[
name|last_cie_ndx
index|]
operator|.
name|offset
operator|==
name|sec_info
operator|->
name|entry
index|[
name|i
index|]
operator|.
name|new_offset
argument_list|)
expr_stmt|;
name|sec_info
operator|->
name|entry
index|[
name|i
index|]
operator|.
name|new_offset
operator|=
name|sec_info
operator|->
name|entry
index|[
name|last_cie_ndx
index|]
operator|.
name|new_offset
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hdr_info
operator|->
name|last_cie_sec
operator|==
name|sec
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|sec_info
operator|->
name|entry
index|[
name|last_cie_ndx
index|]
operator|.
name|offset
operator|==
name|hdr_info
operator|->
name|last_cie_offset
argument_list|)
expr_stmt|;
name|hdr_info
operator|->
name|last_cie_offset
operator|=
name|sec_info
operator|->
name|entry
index|[
name|last_cie_ndx
index|]
operator|.
name|new_offset
expr_stmt|;
block|}
comment|/* FIXME: Currently it is not possible to shrink sections to zero size at      this point, so build a fake minimal CIE.  */
if|if
condition|(
name|new_size
operator|==
literal|0
condition|)
name|new_size
operator|=
literal|16
expr_stmt|;
comment|/* Shrink the sec as needed.  */
name|sec
operator|->
name|_cooked_size
operator|=
name|new_size
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|_cooked_size
operator|==
literal|0
condition|)
name|sec
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
name|free
argument_list|(
name|ehbuf
argument_list|)
expr_stmt|;
return|return
name|new_size
operator|!=
name|sec
operator|->
name|_raw_size
return|;
name|free_no_table
label|:
if|if
condition|(
name|ehbuf
condition|)
name|free
argument_list|(
name|ehbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec_info
condition|)
name|free
argument_list|(
name|sec_info
argument_list|)
expr_stmt|;
name|hdr_info
operator|->
name|table
operator|=
name|false
expr_stmt|;
name|hdr_info
operator|->
name|last_cie
operator|.
name|hdr
operator|.
name|length
operator|=
literal|0
expr_stmt|;
return|return
name|false
return|;
block|}
end_block

begin_comment
comment|/* This function is called for .eh_frame_hdr section after    _bfd_elf_discard_section_eh_frame has been called on all .eh_frame    input sections.  It finalizes the size of .eh_frame_hdr section.  */
end_comment

begin_function
name|boolean
name|_bfd_elf_discard_section_eh_frame_hdr
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|sec
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
block|{
name|struct
name|eh_frame_hdr_info
modifier|*
name|hdr_info
decl_stmt|;
name|unsigned
name|int
name|ptr_size
decl_stmt|;
name|ptr_size
operator|=
operator|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_ident
index|[
name|EI_CLASS
index|]
operator|==
name|ELFCLASS64
operator|)
condition|?
literal|8
else|:
literal|4
expr_stmt|;
if|if
condition|(
operator|(
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|sec_info_type
operator|!=
name|ELF_INFO_TYPE_EH_FRAME_HDR
operator|)
operator|||
operator|!
name|info
operator|->
name|eh_frame_hdr
condition|)
block|{
name|_bfd_strip_section_from_output
argument_list|(
name|info
argument_list|,
name|sec
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|hdr_info
operator|=
operator|(
expr|struct
name|eh_frame_hdr_info
operator|*
operator|)
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|sec_info
expr_stmt|;
if|if
condition|(
name|hdr_info
operator|->
name|strip
condition|)
return|return
name|false
return|;
name|sec
operator|->
name|_cooked_size
operator|=
name|EH_FRAME_HDR_SIZE
expr_stmt|;
if|if
condition|(
name|hdr_info
operator|->
name|table
condition|)
name|sec
operator|->
name|_cooked_size
operator|+=
literal|4
operator|+
name|hdr_info
operator|->
name|fde_count
operator|*
literal|8
expr_stmt|;
comment|/* Request program headers to be recalculated.  */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|program_header_size
operator|=
literal|0
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|eh_frame_hdr
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* This function is called from size_dynamic_sections.    It needs to decide whether .eh_frame_hdr should be output or not,    because later on it is too late for calling _bfd_strip_section_from_output,    since dynamic symbol table has been sized.  */
end_comment

begin_function
name|boolean
name|_bfd_elf_maybe_strip_eh_frame_hdr
parameter_list|(
name|info
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|asection
modifier|*
name|sec
decl_stmt|,
modifier|*
name|o
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|eh_frame_hdr_info
modifier|*
name|hdr_info
decl_stmt|;
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
argument_list|,
literal|".eh_frame_hdr"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
return|return
name|true
return|;
name|hdr_info
operator|=
name|bfd_zmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|eh_frame_hdr_info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr_info
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|sec_info
operator|=
name|hdr_info
expr_stmt|;
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|sec_info_type
operator|=
name|ELF_INFO_TYPE_EH_FRAME_HDR
expr_stmt|;
name|abfd
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|eh_frame_hdr
condition|)
for|for
control|(
name|abfd
operator|=
name|info
operator|->
name|input_bfds
init|;
name|abfd
operator|!=
name|NULL
condition|;
name|abfd
operator|=
name|abfd
operator|->
name|link_next
control|)
block|{
comment|/* Count only sections which have at least a single CIE or FDE. 	   There cannot be any CIE or FDE<= 8 bytes.  */
name|o
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".eh_frame"
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|&&
name|o
operator|->
name|_raw_size
operator|>
literal|8
condition|)
break|break;
block|}
if|if
condition|(
name|abfd
operator|==
name|NULL
condition|)
block|{
name|_bfd_strip_section_from_output
argument_list|(
name|info
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|hdr_info
operator|->
name|strip
operator|=
name|true
expr_stmt|;
block|}
else|else
name|hdr_info
operator|->
name|table
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Adjust an address in the .eh_frame section.  Given OFFSET within    SEC, this returns the new offset in the adjusted .eh_frame section,    or -1 if the address refers to a CIE/FDE which has been removed    or to offset with dynamic relocation which is no longer needed.  */
end_comment

begin_function
name|bfd_vma
name|_bfd_elf_eh_frame_section_offset
parameter_list|(
name|output_bfd
parameter_list|,
name|sec
parameter_list|,
name|offset
parameter_list|)
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
block|{
name|struct
name|eh_frame_sec_info
modifier|*
name|sec_info
decl_stmt|;
name|unsigned
name|int
name|lo
decl_stmt|,
name|hi
decl_stmt|,
name|mid
decl_stmt|;
if|if
condition|(
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|sec_info_type
operator|!=
name|ELF_INFO_TYPE_EH_FRAME
condition|)
return|return
name|offset
return|;
name|sec_info
operator|=
operator|(
expr|struct
name|eh_frame_sec_info
operator|*
operator|)
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|sec_info
expr_stmt|;
if|if
condition|(
name|offset
operator|>=
name|sec
operator|->
name|_raw_size
condition|)
return|return
name|offset
operator|-
operator|(
name|sec
operator|->
name|_cooked_size
operator|-
name|sec
operator|->
name|_raw_size
operator|)
return|;
name|lo
operator|=
literal|0
expr_stmt|;
name|hi
operator|=
name|sec_info
operator|->
name|count
expr_stmt|;
name|mid
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|lo
operator|<
name|hi
condition|)
block|{
name|mid
operator|=
operator|(
name|lo
operator|+
name|hi
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|offset
operator|<
name|sec_info
operator|->
name|entry
index|[
name|mid
index|]
operator|.
name|offset
condition|)
name|hi
operator|=
name|mid
expr_stmt|;
elseif|else
if|if
condition|(
name|offset
operator|>=
name|sec_info
operator|->
name|entry
index|[
name|mid
index|]
operator|.
name|offset
operator|+
name|sec_info
operator|->
name|entry
index|[
name|mid
index|]
operator|.
name|size
condition|)
name|lo
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
else|else
break|break;
block|}
name|BFD_ASSERT
argument_list|(
name|lo
operator|<
name|hi
argument_list|)
expr_stmt|;
comment|/* FDE or CIE was removed.  */
if|if
condition|(
name|sec_info
operator|->
name|entry
index|[
name|mid
index|]
operator|.
name|removed
condition|)
return|return
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
return|;
comment|/* If converting to DW_EH_PE_pcrel, there will be no need for run-time      relocation against FDE's initial_location field.  */
if|if
condition|(
name|sec_info
operator|->
name|entry
index|[
name|mid
index|]
operator|.
name|make_relative
operator|&&
operator|!
name|sec_info
operator|->
name|entry
index|[
name|mid
index|]
operator|.
name|cie
operator|&&
name|offset
operator|==
name|sec_info
operator|->
name|entry
index|[
name|mid
index|]
operator|.
name|offset
operator|+
literal|8
condition|)
return|return
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
return|;
comment|/* If converting LSDA pointers to DW_EH_PE_pcrel, there will be no need      for run-time relocation against LSDA field.  */
if|if
condition|(
name|sec_info
operator|->
name|entry
index|[
name|mid
index|]
operator|.
name|make_lsda_relative
operator|&&
operator|!
name|sec_info
operator|->
name|entry
index|[
name|mid
index|]
operator|.
name|cie
operator|&&
operator|(
name|offset
operator|==
operator|(
name|sec_info
operator|->
name|entry
index|[
name|mid
index|]
operator|.
name|offset
operator|+
literal|8
operator|+
name|sec_info
operator|->
name|entry
index|[
name|mid
index|]
operator|.
name|lsda_offset
operator|)
operator|)
condition|)
return|return
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
return|;
return|return
operator|(
name|offset
operator|+
name|sec_info
operator|->
name|entry
index|[
name|mid
index|]
operator|.
name|new_offset
operator|-
name|sec_info
operator|->
name|entry
index|[
name|mid
index|]
operator|.
name|offset
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Write out .eh_frame section.  This is called with the relocated    contents.  */
end_comment

begin_function
name|boolean
name|_bfd_elf_write_section_eh_frame
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|ehdrsec
parameter_list|,
name|contents
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|,
decl|*
name|ehdrsec
decl_stmt|;
end_function

begin_decl_stmt
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|eh_frame_sec_info
modifier|*
name|sec_info
decl_stmt|;
name|struct
name|eh_frame_hdr_info
modifier|*
name|hdr_info
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|bfd_byte
modifier|*
name|p
decl_stmt|,
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|int
name|leb128_tmp
decl_stmt|;
name|unsigned
name|int
name|cie_offset
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|ptr_size
decl_stmt|;
name|ptr_size
operator|=
operator|(
name|elf_elfheader
argument_list|(
name|sec
operator|->
name|owner
argument_list|)
operator|->
name|e_ident
index|[
name|EI_CLASS
index|]
operator|==
name|ELFCLASS64
operator|)
condition|?
literal|8
else|:
literal|4
expr_stmt|;
if|if
condition|(
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|sec_info_type
operator|!=
name|ELF_INFO_TYPE_EH_FRAME
condition|)
return|return
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|sec
operator|->
name|output_section
argument_list|,
name|contents
argument_list|,
operator|(
name|file_ptr
operator|)
name|sec
operator|->
name|output_offset
argument_list|,
name|sec
operator|->
name|_raw_size
argument_list|)
return|;
name|sec_info
operator|=
operator|(
expr|struct
name|eh_frame_sec_info
operator|*
operator|)
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|sec_info
expr_stmt|;
name|hdr_info
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ehdrsec
operator|&&
operator|(
name|elf_section_data
argument_list|(
name|ehdrsec
argument_list|)
operator|->
name|sec_info_type
operator|==
name|ELF_INFO_TYPE_EH_FRAME_HDR
operator|)
condition|)
block|{
name|hdr_info
operator|=
operator|(
expr|struct
name|eh_frame_hdr_info
operator|*
operator|)
name|elf_section_data
argument_list|(
name|ehdrsec
argument_list|)
operator|->
name|sec_info
expr_stmt|;
if|if
condition|(
name|hdr_info
operator|->
name|table
operator|&&
name|hdr_info
operator|->
name|array
operator|==
name|NULL
condition|)
name|hdr_info
operator|->
name|array
operator|=
name|bfd_malloc
argument_list|(
name|hdr_info
operator|->
name|fde_count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|hdr_info
operator|->
name|array
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr_info
operator|->
name|array
operator|==
name|NULL
condition|)
name|hdr_info
operator|=
name|NULL
expr_stmt|;
block|}
name|p
operator|=
name|contents
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sec_info
operator|->
name|count
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|sec_info
operator|->
name|entry
index|[
name|i
index|]
operator|.
name|removed
condition|)
block|{
if|if
condition|(
name|sec_info
operator|->
name|entry
index|[
name|i
index|]
operator|.
name|cie
condition|)
block|{
comment|/* If CIE is removed due to no remaining FDEs referencing it 		 and there were no CIEs kept before it, sec_info->entry[i].sec 		 will be zero.  */
if|if
condition|(
name|sec_info
operator|->
name|entry
index|[
name|i
index|]
operator|.
name|sec
operator|==
name|NULL
condition|)
name|cie_offset
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|cie_offset
operator|=
name|sec_info
operator|->
name|entry
index|[
name|i
index|]
operator|.
name|new_offset
expr_stmt|;
name|cie_offset
operator|+=
operator|(
name|sec_info
operator|->
name|entry
index|[
name|i
index|]
operator|.
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec_info
operator|->
name|entry
index|[
name|i
index|]
operator|.
name|sec
operator|->
name|output_offset
operator|-
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|-
name|sec
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
block|}
continue|continue;
block|}
if|if
condition|(
name|sec_info
operator|->
name|entry
index|[
name|i
index|]
operator|.
name|cie
condition|)
block|{
comment|/* CIE */
name|cie_offset
operator|=
name|sec_info
operator|->
name|entry
index|[
name|i
index|]
operator|.
name|new_offset
expr_stmt|;
if|if
condition|(
name|sec_info
operator|->
name|entry
index|[
name|i
index|]
operator|.
name|make_relative
operator|||
name|sec_info
operator|->
name|entry
index|[
name|i
index|]
operator|.
name|make_lsda_relative
condition|)
block|{
name|unsigned
name|char
modifier|*
name|aug
decl_stmt|;
name|unsigned
name|int
name|action
decl_stmt|;
name|unsigned
name|int
name|dummy
decl_stmt|,
name|per_width
decl_stmt|,
name|per_encoding
decl_stmt|;
comment|/* Need to find 'R' or 'L' augmentation's argument and modify 		 DW_EH_PE_* value.  */
name|action
operator|=
operator|(
name|sec_info
operator|->
name|entry
index|[
name|i
index|]
operator|.
name|make_relative
condition|?
literal|1
else|:
literal|0
operator|)
operator||
operator|(
name|sec_info
operator|->
name|entry
index|[
name|i
index|]
operator|.
name|make_lsda_relative
condition|?
literal|2
else|:
literal|0
operator|)
expr_stmt|;
name|buf
operator|=
name|contents
operator|+
name|sec_info
operator|->
name|entry
index|[
name|i
index|]
operator|.
name|offset
expr_stmt|;
comment|/* Skip length, id and version.  */
name|buf
operator|+=
literal|9
expr_stmt|;
name|aug
operator|=
name|buf
expr_stmt|;
name|buf
operator|=
name|strchr
argument_list|(
name|buf
argument_list|,
literal|'\0'
argument_list|)
operator|+
literal|1
expr_stmt|;
name|read_uleb128
argument_list|(
name|dummy
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|read_sleb128
argument_list|(
name|dummy
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|read_uleb128
argument_list|(
name|dummy
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|aug
operator|==
literal|'z'
condition|)
block|{
name|read_uleb128
argument_list|(
name|dummy
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|aug
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|action
condition|)
switch|switch
condition|(
operator|*
name|aug
operator|++
condition|)
block|{
case|case
literal|'L'
case|:
if|if
condition|(
name|action
operator|&
literal|2
condition|)
block|{
name|BFD_ASSERT
argument_list|(
operator|*
name|buf
operator|==
name|sec_info
operator|->
name|entry
index|[
name|i
index|]
operator|.
name|lsda_encoding
argument_list|)
expr_stmt|;
operator|*
name|buf
operator||=
name|DW_EH_PE_pcrel
expr_stmt|;
name|action
operator|&=
operator|~
literal|2
expr_stmt|;
block|}
name|buf
operator|++
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|per_encoding
operator|=
operator|*
name|buf
operator|++
expr_stmt|;
name|per_width
operator|=
name|get_DW_EH_PE_width
argument_list|(
name|per_encoding
argument_list|,
name|ptr_size
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|per_width
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|per_encoding
operator|&
literal|0xf0
operator|)
operator|==
name|DW_EH_PE_aligned
condition|)
name|buf
operator|=
operator|(
name|contents
operator|+
operator|(
operator|(
name|buf
operator|-
name|contents
operator|+
name|per_width
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
operator|(
name|bfd_size_type
operator|)
name|per_width
operator|-
literal|1
operator|)
operator|)
operator|)
expr_stmt|;
name|buf
operator|+=
name|per_width
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
if|if
condition|(
name|action
operator|&
literal|1
condition|)
block|{
name|BFD_ASSERT
argument_list|(
operator|*
name|buf
operator|==
name|sec_info
operator|->
name|entry
index|[
name|i
index|]
operator|.
name|fde_encoding
argument_list|)
expr_stmt|;
operator|*
name|buf
operator||=
name|DW_EH_PE_pcrel
expr_stmt|;
name|action
operator|&=
operator|~
literal|1
expr_stmt|;
block|}
name|buf
operator|++
expr_stmt|;
break|break;
default|default:
name|BFD_FAIL
argument_list|()
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* FDE */
name|bfd_vma
name|value
init|=
literal|0
decl_stmt|,
name|address
decl_stmt|;
name|unsigned
name|int
name|width
decl_stmt|;
name|buf
operator|=
name|contents
operator|+
name|sec_info
operator|->
name|entry
index|[
name|i
index|]
operator|.
name|offset
expr_stmt|;
comment|/* Skip length.  */
name|buf
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|sec_info
operator|->
name|entry
index|[
name|i
index|]
operator|.
name|new_offset
operator|+
literal|4
operator|-
name|cie_offset
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|+=
literal|4
expr_stmt|;
name|width
operator|=
name|get_DW_EH_PE_width
argument_list|(
name|sec_info
operator|->
name|entry
index|[
name|i
index|]
operator|.
name|fde_encoding
argument_list|,
name|ptr_size
argument_list|)
expr_stmt|;
name|address
operator|=
name|value
operator|=
name|read_value
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|,
name|width
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
block|{
switch|switch
condition|(
name|sec_info
operator|->
name|entry
index|[
name|i
index|]
operator|.
name|fde_encoding
operator|&
literal|0xf0
condition|)
block|{
case|case
name|DW_EH_PE_indirect
case|:
case|case
name|DW_EH_PE_textrel
case|:
name|BFD_ASSERT
argument_list|(
name|hdr_info
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_EH_PE_datarel
case|:
block|{
name|asection
modifier|*
name|got
init|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".got"
argument_list|)
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|got
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|address
operator|+=
name|got
operator|->
name|vma
expr_stmt|;
block|}
break|break;
case|case
name|DW_EH_PE_pcrel
case|:
name|value
operator|+=
operator|(
name|sec_info
operator|->
name|entry
index|[
name|i
index|]
operator|.
name|offset
operator|-
name|sec_info
operator|->
name|entry
index|[
name|i
index|]
operator|.
name|new_offset
operator|)
expr_stmt|;
name|address
operator|+=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|sec_info
operator|->
name|entry
index|[
name|i
index|]
operator|.
name|offset
operator|+
literal|8
operator|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|sec_info
operator|->
name|entry
index|[
name|i
index|]
operator|.
name|make_relative
condition|)
name|value
operator|-=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|sec_info
operator|->
name|entry
index|[
name|i
index|]
operator|.
name|new_offset
operator|+
literal|8
operator|)
expr_stmt|;
name|write_value
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|,
name|value
argument_list|,
name|width
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hdr_info
condition|)
block|{
name|hdr_info
operator|->
name|array
index|[
name|hdr_info
operator|->
name|array_count
index|]
operator|.
name|initial_loc
operator|=
name|address
expr_stmt|;
name|hdr_info
operator|->
name|array
index|[
name|hdr_info
operator|->
name|array_count
operator|++
index|]
operator|.
name|fde
operator|=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|sec_info
operator|->
name|entry
index|[
name|i
index|]
operator|.
name|new_offset
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sec_info
operator|->
name|entry
index|[
name|i
index|]
operator|.
name|lsda_encoding
operator|&
literal|0xf0
operator|)
operator|==
name|DW_EH_PE_pcrel
operator|||
name|sec_info
operator|->
name|entry
index|[
name|i
index|]
operator|.
name|make_lsda_relative
condition|)
block|{
name|buf
operator|+=
name|sec_info
operator|->
name|entry
index|[
name|i
index|]
operator|.
name|lsda_offset
expr_stmt|;
name|width
operator|=
name|get_DW_EH_PE_width
argument_list|(
name|sec_info
operator|->
name|entry
index|[
name|i
index|]
operator|.
name|lsda_encoding
argument_list|,
name|ptr_size
argument_list|)
expr_stmt|;
name|value
operator|=
name|read_value
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|,
name|width
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
block|{
if|if
condition|(
operator|(
name|sec_info
operator|->
name|entry
index|[
name|i
index|]
operator|.
name|lsda_encoding
operator|&
literal|0xf0
operator|)
operator|==
name|DW_EH_PE_pcrel
condition|)
name|value
operator|+=
operator|(
name|sec_info
operator|->
name|entry
index|[
name|i
index|]
operator|.
name|offset
operator|-
name|sec_info
operator|->
name|entry
index|[
name|i
index|]
operator|.
name|new_offset
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sec_info
operator|->
name|entry
index|[
name|i
index|]
operator|.
name|make_lsda_relative
condition|)
name|value
operator|-=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|sec_info
operator|->
name|entry
index|[
name|i
index|]
operator|.
name|new_offset
operator|+
literal|8
operator|+
name|sec_info
operator|->
name|entry
index|[
name|i
index|]
operator|.
name|lsda_offset
operator|)
expr_stmt|;
name|write_value
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|,
name|value
argument_list|,
name|width
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|BFD_ASSERT
argument_list|(
name|p
operator|==
name|contents
operator|+
name|sec_info
operator|->
name|entry
index|[
name|i
index|]
operator|.
name|new_offset
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|p
argument_list|,
name|contents
operator|+
name|sec_info
operator|->
name|entry
index|[
name|i
index|]
operator|.
name|offset
argument_list|,
name|sec_info
operator|->
name|entry
index|[
name|i
index|]
operator|.
name|size
argument_list|)
expr_stmt|;
name|p
operator|+=
name|sec_info
operator|->
name|entry
index|[
name|i
index|]
operator|.
name|size
expr_stmt|;
block|}
comment|/* FIXME: Once _bfd_elf_discard_section_eh_frame will be able to      shrink sections to zero size, this won't be needed any more.  */
if|if
condition|(
name|p
operator|==
name|contents
operator|&&
name|sec
operator|->
name|_cooked_size
operator|==
literal|16
condition|)
block|{
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
literal|12
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* Fake CIE length */
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|,
name|p
operator|+
literal|4
argument_list|)
expr_stmt|;
comment|/* Fake CIE id */
name|p
index|[
literal|8
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Fake CIE version */
name|memset
argument_list|(
name|p
operator|+
literal|9
argument_list|,
literal|0
argument_list|,
literal|7
argument_list|)
expr_stmt|;
comment|/* Fake CIE augmentation, 3xleb128 					   and 3xDW_CFA_nop as pad  */
name|p
operator|+=
literal|16
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
call|(
name|bfd_size_type
call|)
argument_list|(
name|p
operator|-
name|contents
argument_list|)
operator|==
name|sec
operator|->
name|_cooked_size
argument_list|)
expr_stmt|;
return|return
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|sec
operator|->
name|output_section
argument_list|,
name|contents
argument_list|,
operator|(
name|file_ptr
operator|)
name|sec
operator|->
name|output_offset
argument_list|,
name|sec
operator|->
name|_cooked_size
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/* Helper function used to sort .eh_frame_hdr search table by increasing    VMA of FDE initial location.  */
end_comment

begin_function
specifier|static
name|int
name|vma_compare
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
specifier|const
name|PTR
name|a
decl_stmt|;
specifier|const
name|PTR
name|b
decl_stmt|;
block|{
name|struct
name|eh_frame_array_ent
modifier|*
name|p
init|=
operator|(
expr|struct
name|eh_frame_array_ent
operator|*
operator|)
name|a
decl_stmt|;
name|struct
name|eh_frame_array_ent
modifier|*
name|q
init|=
operator|(
expr|struct
name|eh_frame_array_ent
operator|*
operator|)
name|b
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|initial_loc
operator|>
name|q
operator|->
name|initial_loc
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|p
operator|->
name|initial_loc
operator|<
name|q
operator|->
name|initial_loc
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Write out .eh_frame_hdr section.  This must be called after    _bfd_elf_write_section_eh_frame has been called on all input    .eh_frame sections.    .eh_frame_hdr format:    ubyte version		(currently 1)    ubyte eh_frame_ptr_enc  	(DW_EH_PE_* encoding of pointer to start of 				 .eh_frame section)    ubyte fde_count_enc		(DW_EH_PE_* encoding of total FDE count 				 number (or DW_EH_PE_omit if there is no 				 binary search table computed))    ubyte table_enc		(DW_EH_PE_* encoding of binary search table, 				 or DW_EH_PE_omit if not present. 				 DW_EH_PE_datarel is using address of 				 .eh_frame_hdr section start as base)    [encoded] eh_frame_ptr	(pointer to start of .eh_frame section)    optionally followed by:    [encoded] fde_count		(total number of FDEs in .eh_frame section)    fde_count x [encoded] initial_loc, fde 				(array of encoded pairs containing 				 FDE initial_location field and FDE address, 				 sorted by increasing initial_loc)  */
end_comment

begin_function
name|boolean
name|_bfd_elf_write_section_eh_frame_hdr
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
block|{
name|struct
name|eh_frame_hdr_info
modifier|*
name|hdr_info
decl_stmt|;
name|unsigned
name|int
name|ptr_size
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|asection
modifier|*
name|eh_frame_sec
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
name|ptr_size
operator|=
operator|(
name|elf_elfheader
argument_list|(
name|sec
operator|->
name|owner
argument_list|)
operator|->
name|e_ident
index|[
name|EI_CLASS
index|]
operator|==
name|ELFCLASS64
operator|)
condition|?
literal|8
else|:
literal|4
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|sec_info_type
operator|==
name|ELF_INFO_TYPE_EH_FRAME_HDR
argument_list|)
expr_stmt|;
name|hdr_info
operator|=
operator|(
expr|struct
name|eh_frame_hdr_info
operator|*
operator|)
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|sec_info
expr_stmt|;
if|if
condition|(
name|hdr_info
operator|->
name|strip
condition|)
return|return
name|true
return|;
name|size
operator|=
name|EH_FRAME_HDR_SIZE
expr_stmt|;
if|if
condition|(
name|hdr_info
operator|->
name|array
operator|&&
name|hdr_info
operator|->
name|array_count
operator|==
name|hdr_info
operator|->
name|fde_count
condition|)
name|size
operator|+=
literal|4
operator|+
name|hdr_info
operator|->
name|fde_count
operator|*
literal|8
expr_stmt|;
name|contents
operator|=
name|bfd_malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|eh_frame_sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".eh_frame"
argument_list|)
expr_stmt|;
if|if
condition|(
name|eh_frame_sec
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|memset
argument_list|(
name|contents
argument_list|,
literal|0
argument_list|,
name|EH_FRAME_HDR_SIZE
argument_list|)
expr_stmt|;
name|contents
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Version  */
name|contents
index|[
literal|1
index|]
operator|=
name|DW_EH_PE_pcrel
operator||
name|DW_EH_PE_sdata4
expr_stmt|;
comment|/* .eh_frame offset  */
if|if
condition|(
name|hdr_info
operator|->
name|array
operator|&&
name|hdr_info
operator|->
name|array_count
operator|==
name|hdr_info
operator|->
name|fde_count
condition|)
block|{
name|contents
index|[
literal|2
index|]
operator|=
name|DW_EH_PE_udata4
expr_stmt|;
comment|/* FDE count encoding  */
name|contents
index|[
literal|3
index|]
operator|=
name|DW_EH_PE_datarel
operator||
name|DW_EH_PE_sdata4
expr_stmt|;
comment|/* search table enc  */
block|}
else|else
block|{
name|contents
index|[
literal|2
index|]
operator|=
name|DW_EH_PE_omit
expr_stmt|;
name|contents
index|[
literal|3
index|]
operator|=
name|DW_EH_PE_omit
expr_stmt|;
block|}
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|eh_frame_sec
operator|->
name|vma
operator|-
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|-
literal|4
argument_list|,
name|contents
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
index|[
literal|2
index|]
operator|!=
name|DW_EH_PE_omit
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|hdr_info
operator|->
name|fde_count
argument_list|,
name|contents
operator|+
name|EH_FRAME_HDR_SIZE
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|hdr_info
operator|->
name|array
argument_list|,
name|hdr_info
operator|->
name|fde_count
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hdr_info
operator|->
name|array
argument_list|)
argument_list|,
name|vma_compare
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hdr_info
operator|->
name|fde_count
condition|;
name|i
operator|++
control|)
block|{
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|hdr_info
operator|->
name|array
index|[
name|i
index|]
operator|.
name|initial_loc
operator|-
name|sec
operator|->
name|output_section
operator|->
name|vma
argument_list|,
name|contents
operator|+
name|EH_FRAME_HDR_SIZE
operator|+
name|i
operator|*
literal|8
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|hdr_info
operator|->
name|array
index|[
name|i
index|]
operator|.
name|fde
operator|-
name|sec
operator|->
name|output_section
operator|->
name|vma
argument_list|,
name|contents
operator|+
name|EH_FRAME_HDR_SIZE
operator|+
name|i
operator|*
literal|8
operator|+
literal|8
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|sec
operator|->
name|output_section
argument_list|,
name|contents
argument_list|,
operator|(
name|file_ptr
operator|)
name|sec
operator|->
name|output_offset
argument_list|,
name|sec
operator|->
name|_cooked_size
argument_list|)
return|;
block|}
end_function

end_unit

