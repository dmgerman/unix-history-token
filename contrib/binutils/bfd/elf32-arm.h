begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* 32-bit ELF support for ARM    Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004    Free Software Foundation, Inc.     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|USE_REL
end_ifndef

begin_define
define|#
directive|define
name|USE_REL
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
name|unsigned
name|long
name|int
name|insn32
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|short
name|int
name|insn16
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf32_arm_set_private_flags
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|flagword
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf32_arm_copy_private_bfd_data
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf32_arm_merge_private_bfd_data
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf32_arm_print_private_bfd_data
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|elf32_arm_get_symbol_type
name|PARAMS
argument_list|(
operator|(
name|Elf_Internal_Sym
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bfd_link_hash_table
modifier|*
name|elf32_arm_link_hash_table_create
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|elf32_arm_final_link_relocate
name|PARAMS
argument_list|(
operator|(
name|reloc_howto_type
operator|*
operator|,
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
name|bfd_vma
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|asection
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|insn32
name|insert_thumb_branch
name|PARAMS
argument_list|(
operator|(
name|insn32
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|elf_link_hash_entry
modifier|*
name|find_thumb_glue
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|elf_link_hash_entry
modifier|*
name|find_arm_glue
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|elf32_arm_post_process_headers
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|elf32_arm_to_thumb_stub
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_vma
operator|,
name|bfd_signed_vma
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|elf32_thumb_to_arm_stub
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_vma
operator|,
name|bfd_signed_vma
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf32_arm_relocate_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|,
name|asection
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asection
modifier|*
name|elf32_arm_gc_mark_hook
name|PARAMS
argument_list|(
operator|(
name|asection
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf32_arm_gc_sweep_hook
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|asection
operator|*
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf32_arm_check_relocs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|asection
operator|*
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf32_arm_find_nearest_line
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|asymbol
operator|*
operator|*
operator|,
name|bfd_vma
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|unsigned
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf32_arm_adjust_dynamic_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf32_arm_size_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf32_arm_finish_dynamic_symbol
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf32_arm_finish_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|elf32_arm_link_hash_newfunc
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|,
expr|struct
name|bfd_hash_table
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|USE_REL
end_if

begin_decl_stmt
specifier|static
name|void
name|arm_add_to_rel
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|reloc_howto_type
operator|*
operator|,
name|bfd_signed_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|bfd_boolean
name|allocate_dynrelocs
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
name|h
operator|,
name|PTR
name|inf
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|create_got_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|dynobj
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf32_arm_create_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|dynobj
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|elf_reloc_type_class
name|elf32_arm_reloc_type_class
name|PARAMS
argument_list|(
operator|(
specifier|const
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf32_arm_object_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|ELFARM_NABI_C_INCLUDED
end_ifndef

begin_decl_stmt
specifier|static
name|void
name|record_arm_to_thumb_glue
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|record_thumb_to_arm_glue
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd_boolean
name|bfd_elf32_arm_allocate_interworking_sections
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd_boolean
name|bfd_elf32_arm_get_bfd_for_interworking
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd_boolean
name|bfd_elf32_arm_process_before_allocation
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|INTERWORK_FLAG
parameter_list|(
name|abfd
parameter_list|)
value|(elf_elfheader (abfd)->e_flags& EF_ARM_INTERWORK)
end_define

begin_comment
comment|/* The linker script knows the section names for placement.    The entry_names are used to do simple name mangling on the stubs.    Given a function name, and its type, the stub can be found. The    name can be changed. The only requirement is the %s be present.  */
end_comment

begin_define
define|#
directive|define
name|THUMB2ARM_GLUE_SECTION_NAME
value|".glue_7t"
end_define

begin_define
define|#
directive|define
name|THUMB2ARM_GLUE_ENTRY_NAME
value|"__%s_from_thumb"
end_define

begin_define
define|#
directive|define
name|ARM2THUMB_GLUE_SECTION_NAME
value|".glue_7"
end_define

begin_define
define|#
directive|define
name|ARM2THUMB_GLUE_ENTRY_NAME
value|"__%s_from_arm"
end_define

begin_comment
comment|/* The name of the dynamic interpreter.  This is put in the .interp    section.  */
end_comment

begin_define
define|#
directive|define
name|ELF_DYNAMIC_INTERPRETER
value|"/usr/lib/ld.so.1"
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|FOUR_WORD_PLT
end_ifdef

begin_comment
comment|/* The size in bytes of the special first entry in the procedure    linkage table.  */
end_comment

begin_define
define|#
directive|define
name|PLT_HEADER_SIZE
value|16
end_define

begin_comment
comment|/* The size in bytes of an entry in the procedure linkage table.  */
end_comment

begin_define
define|#
directive|define
name|PLT_ENTRY_SIZE
value|16
end_define

begin_comment
comment|/* The first entry in a procedure linkage table looks like    this.  It is set up so that any shared library function that is    called before the relocation has been set up calls the dynamic    linker first.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|bfd_vma
name|elf32_arm_plt0_entry
index|[
name|PLT_HEADER_SIZE
operator|/
literal|4
index|]
init|=
block|{
literal|0xe52de004
block|,
comment|/* str   lr, [sp, #-4]! */
literal|0xe59fe010
block|,
comment|/* ldr   lr, [pc, #16]  */
literal|0xe08fe00e
block|,
comment|/* add   lr, pc, lr     */
literal|0xe5bef008
block|,
comment|/* ldr   pc, [lr, #8]!  */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Subsequent entries in a procedure linkage table look like    this.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|bfd_vma
name|elf32_arm_plt_entry
index|[
name|PLT_ENTRY_SIZE
operator|/
literal|4
index|]
init|=
block|{
literal|0xe28fc600
block|,
comment|/* add   ip, pc, #NN	*/
literal|0xe28cca00
block|,
comment|/* add	 ip, ip, #NN	*/
literal|0xe5bcf000
block|,
comment|/* ldr	 pc, [ip, #NN]! */
literal|0x00000000
block|,
comment|/* unused		*/
block|}
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* The size in bytes of the special first entry in the procedure    linkage table.  */
end_comment

begin_define
define|#
directive|define
name|PLT_HEADER_SIZE
value|20
end_define

begin_comment
comment|/* The size in bytes of an entry in the procedure linkage table.  */
end_comment

begin_define
define|#
directive|define
name|PLT_ENTRY_SIZE
value|12
end_define

begin_comment
comment|/* The first entry in a procedure linkage table looks like    this.  It is set up so that any shared library function that is    called before the relocation has been set up calls the dynamic    linker first.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|bfd_vma
name|elf32_arm_plt0_entry
index|[
name|PLT_HEADER_SIZE
operator|/
literal|4
index|]
init|=
block|{
literal|0xe52de004
block|,
comment|/* str   lr, [sp, #-4]! */
literal|0xe59fe004
block|,
comment|/* ldr   lr, [pc, #4]   */
literal|0xe08fe00e
block|,
comment|/* add   lr, pc, lr     */
literal|0xe5bef008
block|,
comment|/* ldr   pc, [lr, #8]!  */
literal|0x00000000
block|,
comment|/*&GOT[0] - .          */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Subsequent entries in a procedure linkage table look like    this.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|bfd_vma
name|elf32_arm_plt_entry
index|[
name|PLT_ENTRY_SIZE
operator|/
literal|4
index|]
init|=
block|{
literal|0xe28fc600
block|,
comment|/* add   ip, pc, #0xNN00000 */
literal|0xe28cca00
block|,
comment|/* add	 ip, ip, #0xNN000   */
literal|0xe5bcf000
block|,
comment|/* ldr	 pc, [ip, #0xNNN]!  */
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The ARM linker needs to keep track of the number of relocs that it    decides to copy in check_relocs for each symbol.  This is so that    it can discard PC relative relocs if it doesn't need them when    linking with -Bsymbolic.  We store the information in a field    extending the regular ELF linker hash table.  */
end_comment

begin_comment
comment|/* This structure keeps track of the number of PC relative relocs we    have copied for a given symbol.  */
end_comment

begin_struct
struct|struct
name|elf32_arm_relocs_copied
block|{
comment|/* Next section.  */
name|struct
name|elf32_arm_relocs_copied
modifier|*
name|next
decl_stmt|;
comment|/* A section in dynobj.  */
name|asection
modifier|*
name|section
decl_stmt|;
comment|/* Number of relocs copied in this section.  */
name|bfd_size_type
name|count
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Arm ELF linker hash entry.  */
end_comment

begin_struct
struct|struct
name|elf32_arm_link_hash_entry
block|{
name|struct
name|elf_link_hash_entry
name|root
decl_stmt|;
comment|/* Number of PC relative relocs copied for this symbol.  */
name|struct
name|elf32_arm_relocs_copied
modifier|*
name|relocs_copied
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Traverse an arm ELF linker hash table.  */
end_comment

begin_define
define|#
directive|define
name|elf32_arm_link_hash_traverse
parameter_list|(
name|table
parameter_list|,
name|func
parameter_list|,
name|info
parameter_list|)
define|\
value|(elf_link_hash_traverse						\    (&(table)->root,							\     (bfd_boolean (*) PARAMS ((struct elf_link_hash_entry *, PTR))) (func), \     (info)))
end_define

begin_comment
comment|/* Get the ARM elf linker hash table from a link_info structure.  */
end_comment

begin_define
define|#
directive|define
name|elf32_arm_hash_table
parameter_list|(
name|info
parameter_list|)
define|\
value|((struct elf32_arm_link_hash_table *) ((info)->hash))
end_define

begin_comment
comment|/* ARM ELF linker hash table.  */
end_comment

begin_struct
struct|struct
name|elf32_arm_link_hash_table
block|{
comment|/* The main hash table.  */
name|struct
name|elf_link_hash_table
name|root
decl_stmt|;
comment|/* The size in bytes of the section containing the Thumb-to-ARM glue.  */
name|bfd_size_type
name|thumb_glue_size
decl_stmt|;
comment|/* The size in bytes of the section containing the ARM-to-Thumb glue.  */
name|bfd_size_type
name|arm_glue_size
decl_stmt|;
comment|/* An arbitrary input BFD chosen to hold the glue sections.  */
name|bfd
modifier|*
name|bfd_of_glue_owner
decl_stmt|;
comment|/* A boolean indicating whether knowledge of the ARM's pipeline        length should be applied by the linker.  */
name|int
name|no_pipeline_knowledge
decl_stmt|;
comment|/* Short-cuts to get to dynamic linker sections.  */
name|asection
modifier|*
name|sgot
decl_stmt|;
name|asection
modifier|*
name|sgotplt
decl_stmt|;
name|asection
modifier|*
name|srelgot
decl_stmt|;
name|asection
modifier|*
name|splt
decl_stmt|;
name|asection
modifier|*
name|srelplt
decl_stmt|;
name|asection
modifier|*
name|sdynbss
decl_stmt|;
name|asection
modifier|*
name|srelbss
decl_stmt|;
comment|/* Small local sym to section mapping cache.  */
name|struct
name|sym_sec_cache
name|sym_sec
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Create an entry in an ARM ELF linker hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|elf32_arm_link_hash_newfunc
parameter_list|(
name|entry
parameter_list|,
name|table
parameter_list|,
name|string
parameter_list|)
name|struct
name|bfd_hash_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|bfd_hash_table
modifier|*
name|table
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|struct
name|elf32_arm_link_hash_entry
modifier|*
name|ret
init|=
operator|(
expr|struct
name|elf32_arm_link_hash_entry
operator|*
operator|)
name|entry
decl_stmt|;
comment|/* Allocate the structure if it has not already been allocated by a      subclass.  */
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|elf32_arm_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
name|ret
operator|=
operator|(
operator|(
expr|struct
name|elf32_arm_link_hash_entry
operator|*
operator|)
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|elf32_arm_link_hash_entry
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|elf32_arm_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
comment|/* Call the allocation method of the superclass.  */
name|ret
operator|=
operator|(
operator|(
expr|struct
name|elf32_arm_link_hash_entry
operator|*
operator|)
name|_bfd_elf_link_hash_newfunc
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
operator|(
expr|struct
name|elf32_arm_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
name|ret
operator|->
name|relocs_copied
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Create .got, .gotplt, and .rel.got sections in DYNOBJ, and set up    shortcuts to them in our hash table.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|create_got_section
parameter_list|(
name|dynobj
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|struct
name|elf32_arm_link_hash_table
modifier|*
name|htab
decl_stmt|;
if|if
condition|(
operator|!
name|_bfd_elf_create_got_section
argument_list|(
name|dynobj
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|htab
operator|=
name|elf32_arm_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|htab
operator|->
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
name|htab
operator|->
name|sgotplt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got.plt"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|htab
operator|->
name|sgot
operator|||
operator|!
name|htab
operator|->
name|sgotplt
condition|)
name|abort
argument_list|()
expr_stmt|;
name|htab
operator|->
name|srelgot
operator|=
name|bfd_make_section
argument_list|(
name|dynobj
argument_list|,
literal|".rel.got"
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|srelgot
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|dynobj
argument_list|,
name|htab
operator|->
name|srelgot
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_READONLY
operator|)
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|htab
operator|->
name|srelgot
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Create .plt, .rel.plt, .got, .got.plt, .rel.got, .dynbss, and    .rel.bss sections in DYNOBJ, and set up shortcuts to them in our    hash table.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_arm_create_dynamic_sections
parameter_list|(
name|dynobj
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|struct
name|elf32_arm_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|htab
operator|=
name|elf32_arm_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|htab
operator|->
name|sgot
operator|&&
operator|!
name|create_got_section
argument_list|(
name|dynobj
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|_bfd_elf_create_dynamic_sections
argument_list|(
name|dynobj
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|htab
operator|->
name|splt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
name|htab
operator|->
name|srelplt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rel.plt"
argument_list|)
expr_stmt|;
name|htab
operator|->
name|sdynbss
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynbss"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
name|htab
operator|->
name|srelbss
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rel.bss"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|htab
operator|->
name|splt
operator|||
operator|!
name|htab
operator|->
name|srelplt
operator|||
operator|!
name|htab
operator|->
name|sdynbss
operator|||
operator|(
operator|!
name|info
operator|->
name|shared
operator|&&
operator|!
name|htab
operator|->
name|srelbss
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Copy the extra info we tack onto an elf_link_hash_entry.  */
end_comment

begin_function
specifier|static
name|void
name|elf32_arm_copy_indirect_symbol
parameter_list|(
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|dir
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|ind
parameter_list|)
block|{
name|struct
name|elf32_arm_link_hash_entry
modifier|*
name|edir
decl_stmt|,
modifier|*
name|eind
decl_stmt|;
name|edir
operator|=
operator|(
expr|struct
name|elf32_arm_link_hash_entry
operator|*
operator|)
name|dir
expr_stmt|;
name|eind
operator|=
operator|(
expr|struct
name|elf32_arm_link_hash_entry
operator|*
operator|)
name|ind
expr_stmt|;
if|if
condition|(
name|eind
operator|->
name|relocs_copied
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|edir
operator|->
name|relocs_copied
operator|!=
name|NULL
condition|)
block|{
name|struct
name|elf32_arm_relocs_copied
modifier|*
modifier|*
name|pp
decl_stmt|;
name|struct
name|elf32_arm_relocs_copied
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|ind
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Add reloc counts against the weak sym to the strong sym 	     list.  Merge any entries against the same section.  */
for|for
control|(
name|pp
operator|=
operator|&
name|eind
operator|->
name|relocs_copied
init|;
operator|(
name|p
operator|=
operator|*
name|pp
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
name|struct
name|elf32_arm_relocs_copied
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|q
operator|=
name|edir
operator|->
name|relocs_copied
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|next
control|)
if|if
condition|(
name|q
operator|->
name|section
operator|==
name|p
operator|->
name|section
condition|)
block|{
name|q
operator|->
name|count
operator|+=
name|p
operator|->
name|count
expr_stmt|;
operator|*
name|pp
operator|=
name|p
operator|->
name|next
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
name|pp
operator|=
operator|&
name|p
operator|->
name|next
expr_stmt|;
block|}
operator|*
name|pp
operator|=
name|edir
operator|->
name|relocs_copied
expr_stmt|;
block|}
name|edir
operator|->
name|relocs_copied
operator|=
name|eind
operator|->
name|relocs_copied
expr_stmt|;
name|eind
operator|->
name|relocs_copied
operator|=
name|NULL
expr_stmt|;
block|}
name|_bfd_elf_link_hash_copy_indirect
argument_list|(
name|bed
argument_list|,
name|dir
argument_list|,
name|ind
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create an ARM elf linker hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_link_hash_table
modifier|*
name|elf32_arm_link_hash_table_create
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|elf32_arm_link_hash_table
modifier|*
name|ret
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|elf32_arm_link_hash_table
argument_list|)
decl_stmt|;
name|ret
operator|=
operator|(
expr|struct
name|elf32_arm_link_hash_table
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|elf32_arm_link_hash_table
operator|*
operator|)
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|_bfd_elf_link_hash_table_init
argument_list|(
operator|&
name|ret
operator|->
name|root
argument_list|,
name|abfd
argument_list|,
name|elf32_arm_link_hash_newfunc
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ret
operator|->
name|sgot
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|sgotplt
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|srelgot
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|splt
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|srelplt
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|sdynbss
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|srelbss
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|thumb_glue_size
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|arm_glue_size
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|bfd_of_glue_owner
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|no_pipeline_knowledge
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|sym_sec
operator|.
name|abfd
operator|=
name|NULL
expr_stmt|;
return|return
operator|&
name|ret
operator|->
name|root
operator|.
name|root
return|;
block|}
end_function

begin_comment
comment|/* Locate the Thumb encoded calling stub for NAME.  */
end_comment

begin_function
specifier|static
name|struct
name|elf_link_hash_entry
modifier|*
name|find_thumb_glue
parameter_list|(
name|link_info
parameter_list|,
name|name
parameter_list|,
name|input_bfd
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|link_info
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
block|{
name|char
modifier|*
name|tmp_name
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|hash
decl_stmt|;
name|struct
name|elf32_arm_link_hash_table
modifier|*
name|hash_table
decl_stmt|;
comment|/* We need a pointer to the armelf specific hash table.  */
name|hash_table
operator|=
name|elf32_arm_hash_table
argument_list|(
name|link_info
argument_list|)
expr_stmt|;
name|tmp_name
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_malloc
argument_list|(
operator|(
name|bfd_size_type
operator|)
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|THUMB2ARM_GLUE_ENTRY_NAME
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|tmp_name
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tmp_name
argument_list|,
name|THUMB2ARM_GLUE_ENTRY_NAME
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|hash
operator|=
name|elf_link_hash_lookup
argument_list|(
operator|&
operator|(
name|hash_table
operator|)
operator|->
name|root
argument_list|,
name|tmp_name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash
operator|==
name|NULL
condition|)
comment|/* xgettext:c-format */
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: unable to find THUMB glue '%s' for `%s'"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|tmp_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp_name
argument_list|)
expr_stmt|;
return|return
name|hash
return|;
block|}
end_function

begin_comment
comment|/* Locate the ARM encoded calling stub for NAME.  */
end_comment

begin_function
specifier|static
name|struct
name|elf_link_hash_entry
modifier|*
name|find_arm_glue
parameter_list|(
name|link_info
parameter_list|,
name|name
parameter_list|,
name|input_bfd
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|link_info
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
block|{
name|char
modifier|*
name|tmp_name
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|myh
decl_stmt|;
name|struct
name|elf32_arm_link_hash_table
modifier|*
name|hash_table
decl_stmt|;
comment|/* We need a pointer to the elfarm specific hash table.  */
name|hash_table
operator|=
name|elf32_arm_hash_table
argument_list|(
name|link_info
argument_list|)
expr_stmt|;
name|tmp_name
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_malloc
argument_list|(
operator|(
name|bfd_size_type
operator|)
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|ARM2THUMB_GLUE_ENTRY_NAME
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|tmp_name
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tmp_name
argument_list|,
name|ARM2THUMB_GLUE_ENTRY_NAME
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|myh
operator|=
name|elf_link_hash_lookup
argument_list|(
operator|&
operator|(
name|hash_table
operator|)
operator|->
name|root
argument_list|,
name|tmp_name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|myh
operator|==
name|NULL
condition|)
comment|/* xgettext:c-format */
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: unable to find ARM glue '%s' for `%s'"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|tmp_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp_name
argument_list|)
expr_stmt|;
return|return
name|myh
return|;
block|}
end_function

begin_comment
comment|/* ARM->Thumb glue:     .arm    __func_from_arm:    ldr r12, __func_addr    bx  r12    __func_addr:    .word func    @ behave as if you saw a ARM_32 reloc.  */
end_comment

begin_define
define|#
directive|define
name|ARM2THUMB_GLUE_SIZE
value|12
end_define

begin_decl_stmt
specifier|static
specifier|const
name|insn32
name|a2t1_ldr_insn
init|=
literal|0xe59fc000
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|insn32
name|a2t2_bx_r12_insn
init|=
literal|0xe12fff1c
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|insn32
name|a2t3_func_addr_insn
init|=
literal|0x00000001
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Thumb->ARM:                          Thumb->(non-interworking aware) ARM     .thumb                               .thumb    .align 2                             .align 2    __func_from_thumb:              __func_from_thumb:    bx pc                                push {r6, lr}    nop                                  ldr  r6, __func_addr    .arm                                         mov  lr, pc    __func_change_to_arm:                        bx   r6    b func                       .arm    __func_back_to_thumb:    ldmia r13! {r6, lr}    bx    lr    __func_addr:    .word        func  */
end_comment

begin_define
define|#
directive|define
name|THUMB2ARM_GLUE_SIZE
value|8
end_define

begin_decl_stmt
specifier|static
specifier|const
name|insn16
name|t2a1_bx_pc_insn
init|=
literal|0x4778
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|insn16
name|t2a2_noop_insn
init|=
literal|0x46c0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|insn32
name|t2a3_b_insn
init|=
literal|0xea000000
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|ELFARM_NABI_C_INCLUDED
end_ifndef

begin_function
name|bfd_boolean
name|bfd_elf32_arm_allocate_interworking_sections
parameter_list|(
name|info
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_byte
modifier|*
name|foo
decl_stmt|;
name|struct
name|elf32_arm_link_hash_table
modifier|*
name|globals
decl_stmt|;
name|globals
operator|=
name|elf32_arm_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|globals
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|globals
operator|->
name|arm_glue_size
operator|!=
literal|0
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|globals
operator|->
name|bfd_of_glue_owner
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|globals
operator|->
name|bfd_of_glue_owner
argument_list|,
name|ARM2THUMB_GLUE_SECTION_NAME
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|foo
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|globals
operator|->
name|bfd_of_glue_owner
argument_list|,
name|globals
operator|->
name|arm_glue_size
argument_list|)
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|=
name|s
operator|->
name|_cooked_size
operator|=
name|globals
operator|->
name|arm_glue_size
expr_stmt|;
name|s
operator|->
name|contents
operator|=
name|foo
expr_stmt|;
block|}
if|if
condition|(
name|globals
operator|->
name|thumb_glue_size
operator|!=
literal|0
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|globals
operator|->
name|bfd_of_glue_owner
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|globals
operator|->
name|bfd_of_glue_owner
argument_list|,
name|THUMB2ARM_GLUE_SECTION_NAME
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|foo
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|globals
operator|->
name|bfd_of_glue_owner
argument_list|,
name|globals
operator|->
name|thumb_glue_size
argument_list|)
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|=
name|s
operator|->
name|_cooked_size
operator|=
name|globals
operator|->
name|thumb_glue_size
expr_stmt|;
name|s
operator|->
name|contents
operator|=
name|foo
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|record_arm_to_thumb_glue
parameter_list|(
name|link_info
parameter_list|,
name|h
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|link_info
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|tmp_name
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|myh
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|bh
decl_stmt|;
name|struct
name|elf32_arm_link_hash_table
modifier|*
name|globals
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
name|globals
operator|=
name|elf32_arm_hash_table
argument_list|(
name|link_info
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|globals
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|globals
operator|->
name|bfd_of_glue_owner
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|globals
operator|->
name|bfd_of_glue_owner
argument_list|,
name|ARM2THUMB_GLUE_SECTION_NAME
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|tmp_name
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_malloc
argument_list|(
operator|(
name|bfd_size_type
operator|)
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|ARM2THUMB_GLUE_ENTRY_NAME
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|tmp_name
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tmp_name
argument_list|,
name|ARM2THUMB_GLUE_ENTRY_NAME
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|myh
operator|=
name|elf_link_hash_lookup
argument_list|(
operator|&
operator|(
name|globals
operator|)
operator|->
name|root
argument_list|,
name|tmp_name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|myh
operator|!=
name|NULL
condition|)
block|{
comment|/* We've already seen this guy.  */
name|free
argument_list|(
name|tmp_name
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* The only trick here is using hash_table->arm_glue_size as the value. Even      though the section isn't allocated yet, this is where we will be putting      it.  */
name|bh
operator|=
name|NULL
expr_stmt|;
name|val
operator|=
name|globals
operator|->
name|arm_glue_size
operator|+
literal|1
expr_stmt|;
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|link_info
argument_list|,
name|globals
operator|->
name|bfd_of_glue_owner
argument_list|,
name|tmp_name
argument_list|,
name|BSF_GLOBAL
argument_list|,
name|s
argument_list|,
name|val
argument_list|,
name|NULL
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
operator|&
name|bh
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp_name
argument_list|)
expr_stmt|;
name|globals
operator|->
name|arm_glue_size
operator|+=
name|ARM2THUMB_GLUE_SIZE
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|record_thumb_to_arm_glue
parameter_list|(
name|link_info
parameter_list|,
name|h
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|link_info
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|tmp_name
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|myh
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|bh
decl_stmt|;
name|struct
name|elf32_arm_link_hash_table
modifier|*
name|hash_table
decl_stmt|;
name|char
name|bind
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
name|hash_table
operator|=
name|elf32_arm_hash_table
argument_list|(
name|link_info
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|hash_table
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|hash_table
operator|->
name|bfd_of_glue_owner
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|hash_table
operator|->
name|bfd_of_glue_owner
argument_list|,
name|THUMB2ARM_GLUE_SECTION_NAME
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|tmp_name
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_malloc
argument_list|(
operator|(
name|bfd_size_type
operator|)
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|THUMB2ARM_GLUE_ENTRY_NAME
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|tmp_name
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tmp_name
argument_list|,
name|THUMB2ARM_GLUE_ENTRY_NAME
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|myh
operator|=
name|elf_link_hash_lookup
argument_list|(
operator|&
operator|(
name|hash_table
operator|)
operator|->
name|root
argument_list|,
name|tmp_name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|myh
operator|!=
name|NULL
condition|)
block|{
comment|/* We've already seen this guy.  */
name|free
argument_list|(
name|tmp_name
argument_list|)
expr_stmt|;
return|return;
block|}
name|bh
operator|=
name|NULL
expr_stmt|;
name|val
operator|=
name|hash_table
operator|->
name|thumb_glue_size
operator|+
literal|1
expr_stmt|;
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|link_info
argument_list|,
name|hash_table
operator|->
name|bfd_of_glue_owner
argument_list|,
name|tmp_name
argument_list|,
name|BSF_GLOBAL
argument_list|,
name|s
argument_list|,
name|val
argument_list|,
name|NULL
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
operator|&
name|bh
argument_list|)
expr_stmt|;
comment|/* If we mark it 'Thumb', the disassembler will do a better job.  */
name|myh
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|bh
expr_stmt|;
name|bind
operator|=
name|ELF_ST_BIND
argument_list|(
name|myh
operator|->
name|type
argument_list|)
expr_stmt|;
name|myh
operator|->
name|type
operator|=
name|ELF_ST_INFO
argument_list|(
name|bind
argument_list|,
name|STT_ARM_TFUNC
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp_name
argument_list|)
expr_stmt|;
define|#
directive|define
name|CHANGE_TO_ARM
value|"__%s_change_to_arm"
define|#
directive|define
name|BACK_FROM_ARM
value|"__%s_back_from_arm"
comment|/* Allocate another symbol to mark where we switch to Arm mode.  */
name|tmp_name
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_malloc
argument_list|(
operator|(
name|bfd_size_type
operator|)
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|CHANGE_TO_ARM
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|tmp_name
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tmp_name
argument_list|,
name|CHANGE_TO_ARM
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|bh
operator|=
name|NULL
expr_stmt|;
name|val
operator|=
name|hash_table
operator|->
name|thumb_glue_size
operator|+
literal|4
operator|,
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|link_info
argument_list|,
name|hash_table
operator|->
name|bfd_of_glue_owner
argument_list|,
name|tmp_name
argument_list|,
name|BSF_LOCAL
argument_list|,
name|s
argument_list|,
name|val
argument_list|,
name|NULL
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
operator|&
name|bh
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp_name
argument_list|)
expr_stmt|;
name|hash_table
operator|->
name|thumb_glue_size
operator|+=
name|THUMB2ARM_GLUE_SIZE
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Add the glue sections to ABFD.  This function is called from the    linker scripts in ld/emultempl/{armelf}.em.  */
end_comment

begin_function
name|bfd_boolean
name|bfd_elf32_arm_add_glue_sections_to_bfd
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|flagword
name|flags
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
comment|/* If we are only performing a partial      link do not bother adding the glue.  */
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
return|return
name|TRUE
return|;
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|ARM2THUMB_GLUE_SECTION_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
block|{
comment|/* Note: we do not include the flag SEC_LINKER_CREATED, as this 	 will prevent elf_link_input_bfd() from processing the contents 	 of this section.  */
name|flags
operator|=
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_CODE
operator||
name|SEC_READONLY
expr_stmt|;
name|sec
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
name|ARM2THUMB_GLUE_SECTION_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|flags
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Set the gc mark to prevent the section from being removed by garbage 	 collection, despite the fact that no relocs refer to this section.  */
name|sec
operator|->
name|gc_mark
operator|=
literal|1
expr_stmt|;
block|}
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|THUMB2ARM_GLUE_SECTION_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
block|{
name|flags
operator|=
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_CODE
operator||
name|SEC_READONLY
expr_stmt|;
name|sec
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
name|THUMB2ARM_GLUE_SECTION_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|flags
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|sec
operator|->
name|gc_mark
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Select a BFD to be used to hold the sections used by the glue code.    This function is called from the linker scripts in ld/emultempl/    {armelf/pe}.em  */
end_comment

begin_function
name|bfd_boolean
name|bfd_elf32_arm_get_bfd_for_interworking
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|struct
name|elf32_arm_link_hash_table
modifier|*
name|globals
decl_stmt|;
comment|/* If we are only performing a partial link      do not bother getting a bfd to hold the glue.  */
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
return|return
name|TRUE
return|;
name|globals
operator|=
name|elf32_arm_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|globals
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|globals
operator|->
name|bfd_of_glue_owner
operator|!=
name|NULL
condition|)
return|return
name|TRUE
return|;
comment|/* Save the bfd for later use.  */
name|globals
operator|->
name|bfd_of_glue_owner
operator|=
name|abfd
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|bfd_elf32_arm_process_before_allocation
parameter_list|(
name|abfd
parameter_list|,
name|link_info
parameter_list|,
name|no_pipeline_knowledge
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|link_info
decl_stmt|;
name|int
name|no_pipeline_knowledge
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|,
modifier|*
name|irelend
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
init|=
name|NULL
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|elf32_arm_link_hash_table
modifier|*
name|globals
decl_stmt|;
comment|/* If we are only performing a partial link do not bother      to construct any glue.  */
if|if
condition|(
name|link_info
operator|->
name|relocatable
condition|)
return|return
name|TRUE
return|;
comment|/* Here we have a bfd that is to be included on the link.  We have a hook      to do reloc rummaging, before section sizes are nailed down.  */
name|globals
operator|=
name|elf32_arm_hash_table
argument_list|(
name|link_info
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|globals
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|globals
operator|->
name|bfd_of_glue_owner
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|globals
operator|->
name|no_pipeline_knowledge
operator|=
name|no_pipeline_knowledge
expr_stmt|;
comment|/* Rummage around all the relocs and map the glue vectors.  */
name|sec
operator|=
name|abfd
operator|->
name|sections
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
for|for
control|(
init|;
name|sec
operator|!=
name|NULL
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
block|{
if|if
condition|(
name|sec
operator|->
name|reloc_count
operator|==
literal|0
condition|)
continue|continue;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
comment|/* Load the relocs.  */
name|internal_relocs
operator|=
name|_bfd_elf_link_read_relocs
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
operator|(
name|PTR
operator|)
name|NULL
argument_list|,
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|irelend
operator|=
name|internal_relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|irel
operator|=
name|internal_relocs
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
control|)
block|{
name|long
name|r_type
decl_stmt|;
name|unsigned
name|long
name|r_index
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|r_index
operator|=
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
expr_stmt|;
comment|/* These are the only relocation types we care about.  */
if|if
condition|(
name|r_type
operator|!=
name|R_ARM_PC24
operator|&&
name|r_type
operator|!=
name|R_ARM_THM_PC22
condition|)
continue|continue;
comment|/* Get the section contents if we haven't done so already.  */
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
block|{
comment|/* Get cached copy if it exists.  */
if|if
condition|(
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|NULL
condition|)
name|contents
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
expr_stmt|;
else|else
block|{
comment|/* Go get them off disk.  */
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|sec
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|contents
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|sec
operator|->
name|_raw_size
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
block|}
comment|/* If the relocation is not against a symbol it cannot concern us.  */
name|h
operator|=
name|NULL
expr_stmt|;
comment|/* We don't care about local symbols.  */
if|if
condition|(
name|r_index
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
continue|continue;
comment|/* This is an external symbol.  */
name|r_index
operator|-=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
index|[
name|r_index
index|]
expr_stmt|;
comment|/* If the relocation is against a static symbol it must be within 	     the current section and so cannot be a cross ARM/Thumb relocation.  */
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
continue|continue;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_ARM_PC24
case|:
comment|/* This one is a call from arm code.  We need to look up 	         the target of the call.  If it is a thumb target, we 	         insert glue.  */
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|h
operator|->
name|type
argument_list|)
operator|==
name|STT_ARM_TFUNC
condition|)
name|record_arm_to_thumb_glue
argument_list|(
name|link_info
argument_list|,
name|h
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_ARM_THM_PC22
case|:
comment|/* This one is a call from thumb code.  We look 	         up the target of the call.  If it is not a thumb                  target, we insert glue.  */
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|h
operator|->
name|type
argument_list|)
operator|!=
name|STT_ARM_TFUNC
condition|)
name|record_thumb_to_arm_glue
argument_list|(
name|link_info
argument_list|,
name|h
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|contents
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|contents
condition|)
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
name|contents
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|!=
name|internal_relocs
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
name|internal_relocs
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|TRUE
return|;
name|error_return
label|:
if|if
condition|(
name|contents
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|contents
condition|)
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|!=
name|internal_relocs
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The thumb form of a long branch is a bit finicky, because the offset    encoding is split over two fields, each in it's own instruction. They    can occur in any order. So given a thumb form of long branch, and an    offset, insert the offset into the thumb branch and return finished    instruction.     It takes two thumb instructions to encode the target address. Each has    11 bits to invest. The upper 11 bits are stored in one (identified by    H-0.. see below), the lower 11 bits are stored in the other (identified    by H-1).     Combine together and shifted left by 1 (it's a half word address) and    there you have it.     Op: 1111 = F,    H-0, upper address-0 = 000    Op: 1111 = F,    H-1, lower address-0 = 800     They can be ordered either way, but the arm tools I've seen always put    the lower one first. It probably doesn't matter. krk@cygnus.com     XXX:  Actually the order does matter.  The second instruction (H-1)    moves the computed address into the PC, so it must be the second one    in the sequence.  The problem, however is that whilst little endian code    stores the instructions in HI then LOW order, big endian code does the    reverse.  nickc@cygnus.com.  */
end_comment

begin_define
define|#
directive|define
name|LOW_HI_ORDER
value|0xF800F000
end_define

begin_define
define|#
directive|define
name|HI_LOW_ORDER
value|0xF000F800
end_define

begin_function
specifier|static
name|insn32
name|insert_thumb_branch
parameter_list|(
name|br_insn
parameter_list|,
name|rel_off
parameter_list|)
name|insn32
name|br_insn
decl_stmt|;
name|int
name|rel_off
decl_stmt|;
block|{
name|unsigned
name|int
name|low_bits
decl_stmt|;
name|unsigned
name|int
name|high_bits
decl_stmt|;
name|BFD_ASSERT
argument_list|(
operator|(
name|rel_off
operator|&
literal|1
operator|)
operator|!=
literal|1
argument_list|)
expr_stmt|;
name|rel_off
operator|>>=
literal|1
expr_stmt|;
comment|/* Half word aligned address.  */
name|low_bits
operator|=
name|rel_off
operator|&
literal|0x000007FF
expr_stmt|;
comment|/* The bottom 11 bits.  */
name|high_bits
operator|=
operator|(
name|rel_off
operator|>>
literal|11
operator|)
operator|&
literal|0x000007FF
expr_stmt|;
comment|/* The top 11 bits.  */
if|if
condition|(
operator|(
name|br_insn
operator|&
name|LOW_HI_ORDER
operator|)
operator|==
name|LOW_HI_ORDER
condition|)
name|br_insn
operator|=
name|LOW_HI_ORDER
operator||
operator|(
name|low_bits
operator|<<
literal|16
operator|)
operator||
name|high_bits
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|br_insn
operator|&
name|HI_LOW_ORDER
operator|)
operator|==
name|HI_LOW_ORDER
condition|)
name|br_insn
operator|=
name|HI_LOW_ORDER
operator||
operator|(
name|high_bits
operator|<<
literal|16
operator|)
operator||
name|low_bits
expr_stmt|;
else|else
comment|/* FIXME: abort is probably not the right call. krk@cygnus.com  */
name|abort
argument_list|()
expr_stmt|;
comment|/* error - not a valid branch instruction form.  */
return|return
name|br_insn
return|;
block|}
end_function

begin_comment
comment|/* Thumb code calling an ARM function.  */
end_comment

begin_function
specifier|static
name|int
name|elf32_thumb_to_arm_stub
parameter_list|(
name|info
parameter_list|,
name|name
parameter_list|,
name|input_bfd
parameter_list|,
name|output_bfd
parameter_list|,
name|input_section
parameter_list|,
name|hit_data
parameter_list|,
name|sym_sec
parameter_list|,
name|offset
parameter_list|,
name|addend
parameter_list|,
name|val
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd_byte
modifier|*
name|hit_data
decl_stmt|;
name|asection
modifier|*
name|sym_sec
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
name|bfd_signed_vma
name|addend
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
block|{
name|asection
modifier|*
name|s
init|=
literal|0
decl_stmt|;
name|bfd_vma
name|my_offset
decl_stmt|;
name|unsigned
name|long
name|int
name|tmp
decl_stmt|;
name|long
name|int
name|ret_offset
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|myh
decl_stmt|;
name|struct
name|elf32_arm_link_hash_table
modifier|*
name|globals
decl_stmt|;
name|myh
operator|=
name|find_thumb_glue
argument_list|(
name|info
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|myh
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|globals
operator|=
name|elf32_arm_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|globals
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|globals
operator|->
name|bfd_of_glue_owner
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|my_offset
operator|=
name|myh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|globals
operator|->
name|bfd_of_glue_owner
argument_list|,
name|THUMB2ARM_GLUE_SECTION_NAME
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|->
name|contents
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|->
name|output_section
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|my_offset
operator|&
literal|0x01
operator|)
operator|==
literal|0x01
condition|)
block|{
if|if
condition|(
name|sym_sec
operator|!=
name|NULL
operator|&&
name|sym_sec
operator|->
name|owner
operator|!=
name|NULL
operator|&&
operator|!
name|INTERWORK_FLAG
argument_list|(
name|sym_sec
operator|->
name|owner
argument_list|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s(%s): warning: interworking not enabled."
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|sym_sec
operator|->
name|owner
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"  first occurrence: %s: thumb call to arm"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
operator|--
name|my_offset
expr_stmt|;
name|myh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|my_offset
expr_stmt|;
name|bfd_put_16
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|t2a1_bx_pc_insn
argument_list|,
name|s
operator|->
name|contents
operator|+
name|my_offset
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|t2a2_noop_insn
argument_list|,
name|s
operator|->
name|contents
operator|+
name|my_offset
operator|+
literal|2
argument_list|)
expr_stmt|;
name|ret_offset
operator|=
comment|/* Address of destination of the stub.  */
operator|(
operator|(
name|bfd_signed_vma
operator|)
name|val
operator|)
operator|-
operator|(
call|(
name|bfd_signed_vma
call|)
comment|/* Offset from the start of the current section to the start of the stubs.  */
argument_list|(
name|s
operator|->
name|output_offset
comment|/* Offset of the start of this stub from the start of the stubs.  */
operator|+
name|my_offset
comment|/* Address of the start of the current section.  */
operator|+
name|s
operator|->
name|output_section
operator|->
name|vma
argument_list|)
comment|/* The branch instruction is 4 bytes into the stub.  */
operator|+
literal|4
comment|/* ARM branches work from the pc of the instruction + 8.  */
operator|+
literal|8
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|t2a3_b_insn
operator||
operator|(
operator|(
name|ret_offset
operator|>>
literal|2
operator|)
operator|&
literal|0x00FFFFFF
operator|)
argument_list|,
name|s
operator|->
name|contents
operator|+
name|my_offset
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
name|my_offset
operator|<=
name|globals
operator|->
name|thumb_glue_size
argument_list|)
expr_stmt|;
comment|/* Now go back and fix up the original BL insn to point to here.  */
name|ret_offset
operator|=
comment|/* Address of where the stub is located.  */
operator|(
name|s
operator|->
name|output_section
operator|->
name|vma
operator|+
name|s
operator|->
name|output_offset
operator|+
name|my_offset
operator|)
comment|/* Address of where the BL is located.  */
operator|-
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|offset
operator|)
comment|/* Addend in the relocation.  */
operator|-
name|addend
comment|/* Biassing for PC-relative addressing.  */
operator|-
literal|8
expr_stmt|;
name|tmp
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
operator|-
name|input_section
operator|->
name|vma
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|insert_thumb_branch
argument_list|(
name|tmp
argument_list|,
name|ret_offset
argument_list|)
argument_list|,
name|hit_data
operator|-
name|input_section
operator|->
name|vma
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Arm code calling a Thumb function.  */
end_comment

begin_function
specifier|static
name|int
name|elf32_arm_to_thumb_stub
parameter_list|(
name|info
parameter_list|,
name|name
parameter_list|,
name|input_bfd
parameter_list|,
name|output_bfd
parameter_list|,
name|input_section
parameter_list|,
name|hit_data
parameter_list|,
name|sym_sec
parameter_list|,
name|offset
parameter_list|,
name|addend
parameter_list|,
name|val
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd_byte
modifier|*
name|hit_data
decl_stmt|;
name|asection
modifier|*
name|sym_sec
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
name|bfd_signed_vma
name|addend
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
block|{
name|unsigned
name|long
name|int
name|tmp
decl_stmt|;
name|bfd_vma
name|my_offset
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|long
name|int
name|ret_offset
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|myh
decl_stmt|;
name|struct
name|elf32_arm_link_hash_table
modifier|*
name|globals
decl_stmt|;
name|myh
operator|=
name|find_arm_glue
argument_list|(
name|info
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|myh
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|globals
operator|=
name|elf32_arm_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|globals
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|globals
operator|->
name|bfd_of_glue_owner
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|my_offset
operator|=
name|myh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|globals
operator|->
name|bfd_of_glue_owner
argument_list|,
name|ARM2THUMB_GLUE_SECTION_NAME
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|->
name|contents
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|->
name|output_section
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|my_offset
operator|&
literal|0x01
operator|)
operator|==
literal|0x01
condition|)
block|{
if|if
condition|(
name|sym_sec
operator|!=
name|NULL
operator|&&
name|sym_sec
operator|->
name|owner
operator|!=
name|NULL
operator|&&
operator|!
name|INTERWORK_FLAG
argument_list|(
name|sym_sec
operator|->
name|owner
argument_list|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s(%s): warning: interworking not enabled."
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|sym_sec
operator|->
name|owner
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"  first occurrence: %s: arm call to thumb"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|--
name|my_offset
expr_stmt|;
name|myh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|my_offset
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|a2t1_ldr_insn
argument_list|,
name|s
operator|->
name|contents
operator|+
name|my_offset
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|a2t2_bx_r12_insn
argument_list|,
name|s
operator|->
name|contents
operator|+
name|my_offset
operator|+
literal|4
argument_list|)
expr_stmt|;
comment|/* It's a thumb address.  Add the low order bit.  */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|val
operator||
name|a2t3_func_addr_insn
argument_list|,
name|s
operator|->
name|contents
operator|+
name|my_offset
operator|+
literal|8
argument_list|)
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
name|my_offset
operator|<=
name|globals
operator|->
name|arm_glue_size
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|tmp
operator|&
literal|0xFF000000
expr_stmt|;
comment|/* Somehow these are both 4 too far, so subtract 8.  */
name|ret_offset
operator|=
operator|(
name|s
operator|->
name|output_offset
operator|+
name|my_offset
operator|+
name|s
operator|->
name|output_section
operator|->
name|vma
operator|-
operator|(
name|input_section
operator|->
name|output_offset
operator|+
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|offset
operator|+
name|addend
operator|)
operator|-
literal|8
operator|)
expr_stmt|;
name|tmp
operator|=
name|tmp
operator||
operator|(
operator|(
name|ret_offset
operator|>>
literal|2
operator|)
operator|&
literal|0x00FFFFFF
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|tmp
argument_list|,
name|hit_data
operator|-
name|input_section
operator|->
name|vma
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Perform a relocation as part of a final link.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|elf32_arm_final_link_relocate
parameter_list|(
name|howto
parameter_list|,
name|input_bfd
parameter_list|,
name|output_bfd
parameter_list|,
name|input_section
parameter_list|,
name|contents
parameter_list|,
name|rel
parameter_list|,
name|value
parameter_list|,
name|info
parameter_list|,
name|sym_sec
parameter_list|,
name|sym_name
parameter_list|,
name|sym_flags
parameter_list|,
name|h
parameter_list|)
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|asection
modifier|*
name|sym_sec
decl_stmt|;
specifier|const
name|char
modifier|*
name|sym_name
decl_stmt|;
name|int
name|sym_flags
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
block|{
name|unsigned
name|long
name|r_type
init|=
name|howto
operator|->
name|type
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|bfd_byte
modifier|*
name|hit_data
init|=
name|contents
operator|+
name|rel
operator|->
name|r_offset
decl_stmt|;
name|bfd
modifier|*
name|dynobj
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|bfd_vma
modifier|*
name|local_got_offsets
decl_stmt|;
name|asection
modifier|*
name|sgot
init|=
name|NULL
decl_stmt|;
name|asection
modifier|*
name|splt
init|=
name|NULL
decl_stmt|;
name|asection
modifier|*
name|sreloc
init|=
name|NULL
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|;
name|bfd_signed_vma
name|signed_addend
decl_stmt|;
name|struct
name|elf32_arm_link_hash_table
modifier|*
name|globals
decl_stmt|;
comment|/* If the start address has been set, then set the EF_ARM_HASENTRY      flag.  Setting this more than once is redundant, but the cost is      not too high, and it keeps the code simple.       The test is done  here, rather than somewhere else, because the      start address is only set just before the final link commences.       Note - if the user deliberately sets a start address of 0, the      flag will not be set.  */
if|if
condition|(
name|bfd_get_start_address
argument_list|(
name|output_bfd
argument_list|)
operator|!=
literal|0
condition|)
name|elf_elfheader
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|e_flags
operator||=
name|EF_ARM_HASENTRY
expr_stmt|;
name|globals
operator|=
name|elf32_arm_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
if|if
condition|(
name|dynobj
condition|)
block|{
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
name|splt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
block|}
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|local_got_offsets
operator|=
name|elf_local_got_offsets
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|#
directive|if
name|USE_REL
name|addend
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
argument_list|)
operator|&
name|howto
operator|->
name|src_mask
expr_stmt|;
if|if
condition|(
name|addend
operator|&
operator|(
operator|(
name|howto
operator|->
name|src_mask
operator|+
literal|1
operator|)
operator|>>
literal|1
operator|)
condition|)
block|{
name|signed_addend
operator|=
operator|-
literal|1
expr_stmt|;
name|signed_addend
operator|&=
operator|~
name|howto
operator|->
name|src_mask
expr_stmt|;
name|signed_addend
operator||=
name|addend
expr_stmt|;
block|}
else|else
name|signed_addend
operator|=
name|addend
expr_stmt|;
else|#
directive|else
name|addend
operator|=
name|signed_addend
operator|=
name|rel
operator|->
name|r_addend
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_ARM_NONE
case|:
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_ARM_PC24
case|:
case|case
name|R_ARM_ABS32
case|:
case|case
name|R_ARM_REL32
case|:
ifndef|#
directive|ifndef
name|OLD_ARM_ABI
case|case
name|R_ARM_XPC25
case|:
endif|#
directive|endif
case|case
name|R_ARM_PLT32
case|:
comment|/* r_symndx will be zero only for relocs against symbols 	 from removed linkonce sections, or sections discarded by 	 a linker script.  */
if|if
condition|(
name|r_symndx
operator|==
literal|0
condition|)
return|return
name|bfd_reloc_ok
return|;
comment|/* Handle relocations which should use the PLT entry.  ABS32/REL32 	 will use the symbol's value, which may point to a PLT entry, but we 	 don't need to handle that here.  If we created a PLT entry, all 	 branches in this object should go to it.  */
if|if
condition|(
operator|(
name|r_type
operator|!=
name|R_ARM_ABS32
operator|&&
name|r_type
operator|!=
name|R_ARM_REL32
operator|)
operator|&&
name|h
operator|!=
name|NULL
operator|&&
name|splt
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|plt
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
comment|/* If we've created a .plt section, and assigned a PLT entry to 	     this function, it should not be known to bind locally.  If 	     it were, we would have cleared the PLT entry.  */
name|BFD_ASSERT
argument_list|(
operator|!
name|SYMBOL_CALLS_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
argument_list|)
expr_stmt|;
name|value
operator|=
operator|(
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|splt
operator|->
name|output_offset
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|)
expr_stmt|;
return|return
name|_bfd_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|value
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
return|;
block|}
comment|/* When generating a shared object, these relocations are copied 	 into the output file to be resolved at run time.  */
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|&&
operator|(
name|r_type
operator|!=
name|R_ARM_REL32
operator|||
operator|!
name|SYMBOL_CALLS_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
operator|)
operator|&&
operator|(
name|h
operator|==
name|NULL
operator|||
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_DEFAULT
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefweak
operator|)
operator|&&
name|r_type
operator|!=
name|R_ARM_PC24
operator|&&
name|r_type
operator|!=
name|R_ARM_PLT32
condition|)
block|{
name|Elf_Internal_Rela
name|outrel
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|bfd_boolean
name|skip
decl_stmt|,
name|relocate
decl_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
operator|(
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|elf_elfheader
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|e_shstrndx
argument_list|,
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|rel_hdr
operator|.
name|sh_name
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|bfd_reloc_notsupported
return|;
name|BFD_ASSERT
argument_list|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".rel"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
argument_list|,
name|name
operator|+
literal|4
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|sreloc
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sreloc
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
name|skip
operator|=
name|FALSE
expr_stmt|;
name|relocate
operator|=
name|FALSE
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|=
name|_bfd_elf_section_offset
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|outrel
operator|.
name|r_offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
name|skip
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|outrel
operator|.
name|r_offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|2
condition|)
name|skip
operator|=
name|TRUE
operator|,
name|relocate
operator|=
name|TRUE
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|+=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
if|if
condition|(
name|skip
condition|)
name|memset
argument_list|(
operator|&
name|outrel
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|outrel
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|&&
operator|(
operator|!
name|info
operator|->
name|shared
operator|||
operator|!
name|info
operator|->
name|symbolic
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
condition|)
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* This symbol is local, or marked to become local.  */
name|relocate
operator|=
name|TRUE
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_ARM_RELATIVE
argument_list|)
expr_stmt|;
block|}
name|loc
operator|=
name|sreloc
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
name|sreloc
operator|->
name|reloc_count
operator|++
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloc_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
comment|/* If this reloc is against an external symbol, we do not want to 	     fiddle with the addend.  Otherwise, we need to include the symbol 	     value so that it becomes an addend for the dynamic reloc.  */
if|if
condition|(
operator|!
name|relocate
condition|)
return|return
name|bfd_reloc_ok
return|;
return|return
name|_bfd_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|value
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
return|;
block|}
else|else
switch|switch
condition|(
name|r_type
condition|)
block|{
ifndef|#
directive|ifndef
name|OLD_ARM_ABI
case|case
name|R_ARM_XPC25
case|:
comment|/* Arm BLX instruction.  */
endif|#
directive|endif
case|case
name|R_ARM_PC24
case|:
comment|/* Arm B/BL instruction */
case|case
name|R_ARM_PLT32
case|:
ifndef|#
directive|ifndef
name|OLD_ARM_ABI
if|if
condition|(
name|r_type
operator|==
name|R_ARM_XPC25
condition|)
block|{
comment|/* Check for Arm calling Arm function.  */
comment|/* FIXME: Should we translate the instruction into a BL 		 instruction instead ?  */
if|if
condition|(
name|sym_flags
operator|!=
name|STT_ARM_TFUNC
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"\ %s: Warning: Arm BLX instruction targets Arm function '%s'."
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|h
condition|?
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
else|:
literal|"(local)"
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
comment|/* Check for Arm calling Thumb function.  */
if|if
condition|(
name|sym_flags
operator|==
name|STT_ARM_TFUNC
condition|)
block|{
name|elf32_arm_to_thumb_stub
argument_list|(
name|info
argument_list|,
name|sym_name
argument_list|,
name|input_bfd
argument_list|,
name|output_bfd
argument_list|,
name|input_section
argument_list|,
name|hit_data
argument_list|,
name|sym_sec
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|signed_addend
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|bfd_get_target
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
literal|"elf32-littlearm-oabi"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|bfd_get_target
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
literal|"elf32-bigarm-oabi"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* The old way of doing things.  Trearing the addend as a 		 byte sized field and adding in the pipeline offset.  */
name|value
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|value
operator|-=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|value
operator|+=
name|addend
expr_stmt|;
if|if
condition|(
operator|!
name|globals
operator|->
name|no_pipeline_knowledge
condition|)
name|value
operator|-=
literal|8
expr_stmt|;
block|}
else|else
block|{
comment|/* The ARM ELF ABI says that this reloc is computed as: S - P + A 		 where: 		  S is the address of the symbol in the relocation. 		  P is address of the instruction being relocated. 		  A is the addend (extracted from the instruction) in bytes.  		 S is held in 'value'. 		 P is the base address of the section containing the instruction 		   plus the offset of the reloc into that section, ie: 		     (input_section->output_section->vma + 		      input_section->output_offset + 		      rel->r_offset). 		 A is the addend, converted into bytes, ie: 		     (signed_addend * 4)  		 Note: None of these operations have knowledge of the pipeline 		 size of the processor, thus it is up to the assembler to encode 		 this information into the addend.  */
name|value
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|value
operator|-=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|value
operator|+=
operator|(
name|signed_addend
operator|<<
name|howto
operator|->
name|size
operator|)
expr_stmt|;
comment|/* Previous versions of this code also used to add in the pipeline 		 offset here.  This is wrong because the linker is not supposed 		 to know about such things, and one day it might change.  In order 		 to support old binaries that need the old behaviour however, so 		 we attempt to detect which ABI was used to create the reloc.  */
if|if
condition|(
operator|!
name|globals
operator|->
name|no_pipeline_knowledge
condition|)
block|{
name|Elf_Internal_Ehdr
modifier|*
name|i_ehdrp
decl_stmt|;
comment|/* Elf file header, internal form */
name|i_ehdrp
operator|=
name|elf_elfheader
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|i_ehdrp
operator|->
name|e_ident
index|[
name|EI_OSABI
index|]
operator|==
literal|0
condition|)
name|value
operator|-=
literal|8
expr_stmt|;
block|}
block|}
name|signed_addend
operator|=
name|value
expr_stmt|;
name|signed_addend
operator|>>=
name|howto
operator|->
name|rightshift
expr_stmt|;
comment|/* It is not an error for an undefined weak reference to be 	     out of range.  Any program that branches to such a symbol 	     is going to crash anyway, so there is no point worrying 	     about getting the destination exactly right.  */
if|if
condition|(
operator|!
name|h
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefweak
condition|)
block|{
comment|/* Perform a signed range check.  */
if|if
condition|(
name|signed_addend
operator|>
operator|(
call|(
name|bfd_signed_vma
call|)
argument_list|(
name|howto
operator|->
name|dst_mask
operator|>>
literal|1
argument_list|)
operator|)
operator|||
name|signed_addend
operator|<
operator|-
operator|(
call|(
name|bfd_signed_vma
call|)
argument_list|(
operator|(
name|howto
operator|->
name|dst_mask
operator|+
literal|1
operator|)
operator|>>
literal|1
argument_list|)
operator|)
condition|)
return|return
name|bfd_reloc_overflow
return|;
block|}
ifndef|#
directive|ifndef
name|OLD_ARM_ABI
comment|/* If necessary set the H bit in the BLX instruction.  */
if|if
condition|(
name|r_type
operator|==
name|R_ARM_XPC25
operator|&&
operator|(
operator|(
name|value
operator|&
literal|2
operator|)
operator|==
literal|2
operator|)
condition|)
name|value
operator|=
operator|(
name|signed_addend
operator|&
name|howto
operator|->
name|dst_mask
operator|)
operator||
operator|(
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
argument_list|)
operator|&
operator|(
operator|~
name|howto
operator|->
name|dst_mask
operator|)
operator|)
operator||
operator|(
literal|1
operator|<<
literal|24
operator|)
expr_stmt|;
else|else
endif|#
directive|endif
name|value
operator|=
operator|(
name|signed_addend
operator|&
name|howto
operator|->
name|dst_mask
operator|)
operator||
operator|(
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
argument_list|)
operator|&
operator|(
operator|~
name|howto
operator|->
name|dst_mask
operator|)
operator|)
expr_stmt|;
break|break;
case|case
name|R_ARM_ABS32
case|:
name|value
operator|+=
name|addend
expr_stmt|;
if|if
condition|(
name|sym_flags
operator|==
name|STT_ARM_TFUNC
condition|)
name|value
operator||=
literal|1
expr_stmt|;
break|break;
case|case
name|R_ARM_REL32
case|:
name|value
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|rel
operator|->
name|r_offset
operator|)
expr_stmt|;
name|value
operator|+=
name|addend
expr_stmt|;
break|break;
block|}
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|value
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_ARM_ABS8
case|:
name|value
operator|+=
name|addend
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|value
operator|>
literal|0x7f
operator|||
operator|(
name|long
operator|)
name|value
operator|<
operator|-
literal|0x80
condition|)
return|return
name|bfd_reloc_overflow
return|;
name|bfd_put_8
argument_list|(
name|input_bfd
argument_list|,
name|value
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_ARM_ABS16
case|:
name|value
operator|+=
name|addend
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|value
operator|>
literal|0x7fff
operator|||
operator|(
name|long
operator|)
name|value
operator|<
operator|-
literal|0x8000
condition|)
return|return
name|bfd_reloc_overflow
return|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|value
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_ARM_ABS12
case|:
comment|/* Support ldr and str instruction for the arm */
comment|/* Also thumb b (unconditional branch).  ??? Really?  */
name|value
operator|+=
name|addend
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|value
operator|>
literal|0x7ff
operator|||
operator|(
name|long
operator|)
name|value
operator|<
operator|-
literal|0x800
condition|)
return|return
name|bfd_reloc_overflow
return|;
name|value
operator||=
operator|(
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
argument_list|)
operator|&
literal|0xfffff000
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|value
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_ARM_THM_ABS5
case|:
comment|/* Support ldr and str instructions for the thumb.  */
if|#
directive|if
name|USE_REL
comment|/* Need to refetch addend.  */
name|addend
operator|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
argument_list|)
operator|&
name|howto
operator|->
name|src_mask
expr_stmt|;
comment|/* ??? Need to determine shift amount from operand size.  */
name|addend
operator|>>=
name|howto
operator|->
name|rightshift
expr_stmt|;
endif|#
directive|endif
name|value
operator|+=
name|addend
expr_stmt|;
comment|/* ??? Isn't value unsigned?  */
if|if
condition|(
operator|(
name|long
operator|)
name|value
operator|>
literal|0x1f
operator|||
operator|(
name|long
operator|)
name|value
operator|<
operator|-
literal|0x10
condition|)
return|return
name|bfd_reloc_overflow
return|;
comment|/* ??? Value needs to be properly shifted into place first.  */
name|value
operator||=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
argument_list|)
operator|&
literal|0xf83f
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|value
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
ifndef|#
directive|ifndef
name|OLD_ARM_ABI
case|case
name|R_ARM_THM_XPC22
case|:
endif|#
directive|endif
case|case
name|R_ARM_THM_PC22
case|:
comment|/* Thumb BL (branch long instruction).  */
block|{
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_boolean
name|overflow
init|=
name|FALSE
decl_stmt|;
name|bfd_vma
name|upper_insn
init|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
argument_list|)
decl_stmt|;
name|bfd_vma
name|lower_insn
init|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
operator|+
literal|2
argument_list|)
decl_stmt|;
name|bfd_signed_vma
name|reloc_signed_max
init|=
operator|(
operator|(
literal|1
operator|<<
operator|(
name|howto
operator|->
name|bitsize
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
operator|>>
name|howto
operator|->
name|rightshift
decl_stmt|;
name|bfd_signed_vma
name|reloc_signed_min
init|=
operator|~
name|reloc_signed_max
decl_stmt|;
name|bfd_vma
name|check
decl_stmt|;
name|bfd_signed_vma
name|signed_check
decl_stmt|;
if|#
directive|if
name|USE_REL
comment|/* Need to refetch the addend and squish the two 11 bit pieces 	   together.  */
block|{
name|bfd_vma
name|upper
init|=
name|upper_insn
operator|&
literal|0x7ff
decl_stmt|;
name|bfd_vma
name|lower
init|=
name|lower_insn
operator|&
literal|0x7ff
decl_stmt|;
name|upper
operator|=
operator|(
name|upper
operator|^
literal|0x400
operator|)
operator|-
literal|0x400
expr_stmt|;
comment|/* Sign extend.  */
name|addend
operator|=
operator|(
name|upper
operator|<<
literal|12
operator|)
operator||
operator|(
name|lower
operator|<<
literal|1
operator|)
expr_stmt|;
name|signed_addend
operator|=
name|addend
expr_stmt|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OLD_ARM_ABI
if|if
condition|(
name|r_type
operator|==
name|R_ARM_THM_XPC22
condition|)
block|{
comment|/* Check for Thumb to Thumb call.  */
comment|/* FIXME: Should we translate the instruction into a BL 	       instruction instead ?  */
if|if
condition|(
name|sym_flags
operator|==
name|STT_ARM_TFUNC
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"\ %s: Warning: Thumb BLX instruction targets thumb function '%s'."
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|h
condition|?
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
else|:
literal|"(local)"
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
comment|/* If it is not a call to Thumb, assume call to Arm. 	       If it is a call relative to a section name, then it is not a 	       function call at all, but rather a long jump.  */
if|if
condition|(
name|sym_flags
operator|!=
name|STT_ARM_TFUNC
operator|&&
name|sym_flags
operator|!=
name|STT_SECTION
condition|)
block|{
if|if
condition|(
name|elf32_thumb_to_arm_stub
argument_list|(
name|info
argument_list|,
name|sym_name
argument_list|,
name|input_bfd
argument_list|,
name|output_bfd
argument_list|,
name|input_section
argument_list|,
name|hit_data
argument_list|,
name|sym_sec
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|signed_addend
argument_list|,
name|value
argument_list|)
condition|)
return|return
name|bfd_reloc_ok
return|;
else|else
return|return
name|bfd_reloc_dangerous
return|;
block|}
block|}
name|relocation
operator|=
name|value
operator|+
name|signed_addend
expr_stmt|;
name|relocation
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|rel
operator|->
name|r_offset
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|globals
operator|->
name|no_pipeline_knowledge
condition|)
block|{
name|Elf_Internal_Ehdr
modifier|*
name|i_ehdrp
decl_stmt|;
comment|/* Elf file header, internal form.  */
name|i_ehdrp
operator|=
name|elf_elfheader
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
comment|/* Previous versions of this code also used to add in the pipline 	       offset here.  This is wrong because the linker is not supposed 	       to know about such things, and one day it might change.  In order 	       to support old binaries that need the old behaviour however, so 	       we attempt to detect which ABI was used to create the reloc.  */
if|if
condition|(
name|strcmp
argument_list|(
name|bfd_get_target
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
literal|"elf32-littlearm-oabi"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|bfd_get_target
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
literal|"elf32-bigarm-oabi"
argument_list|)
operator|==
literal|0
operator|||
name|i_ehdrp
operator|->
name|e_ident
index|[
name|EI_OSABI
index|]
operator|==
literal|0
condition|)
name|relocation
operator|+=
literal|4
expr_stmt|;
block|}
name|check
operator|=
name|relocation
operator|>>
name|howto
operator|->
name|rightshift
expr_stmt|;
comment|/* If this is a signed value, the rightshift just dropped 	   leading 1 bits (assuming twos complement).  */
if|if
condition|(
operator|(
name|bfd_signed_vma
operator|)
name|relocation
operator|>=
literal|0
condition|)
name|signed_check
operator|=
name|check
expr_stmt|;
else|else
name|signed_check
operator|=
name|check
operator||
operator|~
operator|(
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|>>
name|howto
operator|->
name|rightshift
operator|)
expr_stmt|;
comment|/* Assumes two's complement.  */
if|if
condition|(
name|signed_check
operator|>
name|reloc_signed_max
operator|||
name|signed_check
operator|<
name|reloc_signed_min
condition|)
name|overflow
operator|=
name|TRUE
expr_stmt|;
ifndef|#
directive|ifndef
name|OLD_ARM_ABI
if|if
condition|(
name|r_type
operator|==
name|R_ARM_THM_XPC22
operator|&&
operator|(
operator|(
name|lower_insn
operator|&
literal|0x1800
operator|)
operator|==
literal|0x0800
operator|)
condition|)
comment|/* For a BLX instruction, make sure that the relocation is rounded up 	     to a word boundary.  This follows the semantics of the instruction 	     which specifies that bit 1 of the target address will come from bit 	     1 of the base address.  */
name|relocation
operator|=
operator|(
name|relocation
operator|+
literal|2
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
endif|#
directive|endif
comment|/* Put RELOCATION back into the insn.  */
name|upper_insn
operator|=
operator|(
name|upper_insn
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
literal|0x7ff
operator|)
operator||
operator|(
operator|(
name|relocation
operator|>>
literal|12
operator|)
operator|&
literal|0x7ff
operator|)
expr_stmt|;
name|lower_insn
operator|=
operator|(
name|lower_insn
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
literal|0x7ff
operator|)
operator||
operator|(
operator|(
name|relocation
operator|>>
literal|1
operator|)
operator|&
literal|0x7ff
operator|)
expr_stmt|;
comment|/* Put the relocated value back in the object file:  */
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|upper_insn
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|lower_insn
argument_list|,
name|hit_data
operator|+
literal|2
argument_list|)
expr_stmt|;
return|return
operator|(
name|overflow
condition|?
name|bfd_reloc_overflow
else|:
name|bfd_reloc_ok
operator|)
return|;
block|}
break|break;
case|case
name|R_ARM_THM_PC11
case|:
comment|/* Thumb B (branch) instruction).  */
block|{
name|bfd_signed_vma
name|relocation
decl_stmt|;
name|bfd_signed_vma
name|reloc_signed_max
init|=
operator|(
literal|1
operator|<<
operator|(
name|howto
operator|->
name|bitsize
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
decl_stmt|;
name|bfd_signed_vma
name|reloc_signed_min
init|=
operator|~
name|reloc_signed_max
decl_stmt|;
name|bfd_signed_vma
name|signed_check
decl_stmt|;
if|#
directive|if
name|USE_REL
comment|/* Need to refetch addend.  */
name|addend
operator|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
argument_list|)
operator|&
name|howto
operator|->
name|src_mask
expr_stmt|;
if|if
condition|(
name|addend
operator|&
operator|(
operator|(
name|howto
operator|->
name|src_mask
operator|+
literal|1
operator|)
operator|>>
literal|1
operator|)
condition|)
block|{
name|signed_addend
operator|=
operator|-
literal|1
expr_stmt|;
name|signed_addend
operator|&=
operator|~
name|howto
operator|->
name|src_mask
expr_stmt|;
name|signed_addend
operator||=
name|addend
expr_stmt|;
block|}
else|else
name|signed_addend
operator|=
name|addend
expr_stmt|;
comment|/* The value in the insn has been right shifted.  We need to 	   undo this, so that we can perform the address calculation 	   in terms of bytes.  */
name|signed_addend
operator|<<=
name|howto
operator|->
name|rightshift
expr_stmt|;
endif|#
directive|endif
name|relocation
operator|=
name|value
operator|+
name|signed_addend
expr_stmt|;
name|relocation
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|rel
operator|->
name|r_offset
operator|)
expr_stmt|;
name|relocation
operator|>>=
name|howto
operator|->
name|rightshift
expr_stmt|;
name|signed_check
operator|=
name|relocation
expr_stmt|;
name|relocation
operator|&=
name|howto
operator|->
name|dst_mask
expr_stmt|;
name|relocation
operator||=
operator|(
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
argument_list|)
operator|&
operator|(
operator|~
name|howto
operator|->
name|dst_mask
operator|)
operator|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|relocation
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
comment|/* Assumes two's complement.  */
if|if
condition|(
name|signed_check
operator|>
name|reloc_signed_max
operator|||
name|signed_check
operator|<
name|reloc_signed_min
condition|)
return|return
name|bfd_reloc_overflow
return|;
return|return
name|bfd_reloc_ok
return|;
block|}
case|case
name|R_ARM_GNU_VTINHERIT
case|:
case|case
name|R_ARM_GNU_VTENTRY
case|:
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_ARM_COPY
case|:
return|return
name|bfd_reloc_notsupported
return|;
case|case
name|R_ARM_GLOB_DAT
case|:
return|return
name|bfd_reloc_notsupported
return|;
case|case
name|R_ARM_JUMP_SLOT
case|:
return|return
name|bfd_reloc_notsupported
return|;
case|case
name|R_ARM_RELATIVE
case|:
return|return
name|bfd_reloc_notsupported
return|;
case|case
name|R_ARM_GOTOFF
case|:
comment|/* Relocation is relative to the start of the          global offset table.  */
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sgot
operator|==
name|NULL
condition|)
return|return
name|bfd_reloc_notsupported
return|;
comment|/* If we are addressing a Thumb function, we need to adjust the 	 address by one, so that attempts to call the function pointer will 	 correctly interpret it as Thumb code.  */
if|if
condition|(
name|sym_flags
operator|==
name|STT_ARM_TFUNC
condition|)
name|value
operator|+=
literal|1
expr_stmt|;
comment|/* Note that sgot->output_offset is not involved in this          calculation.  We always want the start of .got.  If we          define _GLOBAL_OFFSET_TABLE in a different way, as is          permitted by the ABI, we might have to change this          calculation.  */
name|value
operator|-=
name|sgot
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
return|return
name|_bfd_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|value
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
return|;
case|case
name|R_ARM_GOTPC
case|:
comment|/* Use global offset table as symbol value.  */
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sgot
operator|==
name|NULL
condition|)
return|return
name|bfd_reloc_notsupported
return|;
name|value
operator|=
name|sgot
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
return|return
name|_bfd_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|value
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
return|;
case|case
name|R_ARM_GOT32
case|:
comment|/* Relocation is to the entry for this symbol in the          global offset table.  */
if|if
condition|(
name|sgot
operator|==
name|NULL
condition|)
return|return
name|bfd_reloc_notsupported
return|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|bfd_vma
name|off
decl_stmt|;
name|bfd_boolean
name|dyn
decl_stmt|;
name|off
operator|=
name|h
operator|->
name|got
operator|.
name|offset
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|off
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|dyn
operator|=
name|globals
operator|->
name|root
operator|.
name|dynamic_sections_created
expr_stmt|;
if|if
condition|(
operator|!
name|WILL_CALL_FINISH_DYNAMIC_SYMBOL
argument_list|(
name|dyn
argument_list|,
name|info
operator|->
name|shared
argument_list|,
name|h
argument_list|)
operator|||
operator|(
name|info
operator|->
name|shared
operator|&&
name|SYMBOL_REFERENCES_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
operator|)
operator|||
operator|(
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|)
condition|)
block|{
comment|/* This is actually a static link, or it is a -Bsymbolic link 		 and the symbol is defined locally.  We must initialize this 		 entry in the global offset table.  Since the offset must 		 always be a multiple of 4, we use the least significant bit 		 to record whether we have initialized it already.  		 When doing a dynamic link, we create a .rel.got relocation 		 entry to initialize the value.  This is done in the 		 finish_dynamic_symbol routine.  */
if|if
condition|(
operator|(
name|off
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|off
operator|&=
operator|~
literal|1
expr_stmt|;
else|else
block|{
comment|/* If we are addressing a Thumb function, we need to 		     adjust the address by one, so that attempts to 		     call the function pointer will correctly 		     interpret it as Thumb code.  */
if|if
condition|(
name|sym_flags
operator|==
name|STT_ARM_TFUNC
condition|)
name|value
operator||=
literal|1
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|value
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|off
argument_list|)
expr_stmt|;
name|h
operator|->
name|got
operator|.
name|offset
operator||=
literal|1
expr_stmt|;
block|}
block|}
name|value
operator|=
name|sgot
operator|->
name|output_offset
operator|+
name|off
expr_stmt|;
block|}
else|else
block|{
name|bfd_vma
name|off
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|local_got_offsets
operator|!=
name|NULL
operator|&&
name|local_got_offsets
index|[
name|r_symndx
index|]
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|off
operator|=
name|local_got_offsets
index|[
name|r_symndx
index|]
expr_stmt|;
comment|/* The offset must always be a multiple of 4.  We use the 	     least significant bit to record whether we have already 	     generated the necessary reloc.  */
if|if
condition|(
operator|(
name|off
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|off
operator|&=
operator|~
literal|1
expr_stmt|;
else|else
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|value
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|off
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
name|asection
modifier|*
name|srelgot
decl_stmt|;
name|Elf_Internal_Rela
name|outrel
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|srelgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rel.got"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|srelgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|=
operator|(
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
name|off
operator|)
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_ARM_RELATIVE
argument_list|)
expr_stmt|;
name|loc
operator|=
name|srelgot
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
name|srelgot
operator|->
name|reloc_count
operator|++
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloc_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
name|local_got_offsets
index|[
name|r_symndx
index|]
operator||=
literal|1
expr_stmt|;
block|}
name|value
operator|=
name|sgot
operator|->
name|output_offset
operator|+
name|off
expr_stmt|;
block|}
return|return
name|_bfd_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|value
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
return|;
case|case
name|R_ARM_SBREL32
case|:
return|return
name|bfd_reloc_notsupported
return|;
case|case
name|R_ARM_AMP_VCALL9
case|:
return|return
name|bfd_reloc_notsupported
return|;
case|case
name|R_ARM_RSBREL32
case|:
return|return
name|bfd_reloc_notsupported
return|;
case|case
name|R_ARM_THM_RPC22
case|:
return|return
name|bfd_reloc_notsupported
return|;
case|case
name|R_ARM_RREL32
case|:
return|return
name|bfd_reloc_notsupported
return|;
case|case
name|R_ARM_RABS32
case|:
return|return
name|bfd_reloc_notsupported
return|;
case|case
name|R_ARM_RPC24
case|:
return|return
name|bfd_reloc_notsupported
return|;
case|case
name|R_ARM_RBASE
case|:
return|return
name|bfd_reloc_notsupported
return|;
default|default:
return|return
name|bfd_reloc_notsupported
return|;
block|}
block|}
end_function

begin_if
if|#
directive|if
name|USE_REL
end_if

begin_comment
comment|/* Add INCREMENT to the reloc (of type HOWTO) at ADDRESS.  */
end_comment

begin_function
specifier|static
name|void
name|arm_add_to_rel
parameter_list|(
name|abfd
parameter_list|,
name|address
parameter_list|,
name|howto
parameter_list|,
name|increment
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|bfd_byte
modifier|*
name|address
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|bfd_signed_vma
name|increment
decl_stmt|;
block|{
name|bfd_signed_vma
name|addend
decl_stmt|;
if|if
condition|(
name|howto
operator|->
name|type
operator|==
name|R_ARM_THM_PC22
condition|)
block|{
name|int
name|upper_insn
decl_stmt|,
name|lower_insn
decl_stmt|;
name|int
name|upper
decl_stmt|,
name|lower
decl_stmt|;
name|upper_insn
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|address
argument_list|)
expr_stmt|;
name|lower_insn
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|address
operator|+
literal|2
argument_list|)
expr_stmt|;
name|upper
operator|=
name|upper_insn
operator|&
literal|0x7ff
expr_stmt|;
name|lower
operator|=
name|lower_insn
operator|&
literal|0x7ff
expr_stmt|;
name|addend
operator|=
operator|(
name|upper
operator|<<
literal|12
operator|)
operator||
operator|(
name|lower
operator|<<
literal|1
operator|)
expr_stmt|;
name|addend
operator|+=
name|increment
expr_stmt|;
name|addend
operator|>>=
literal|1
expr_stmt|;
name|upper_insn
operator|=
operator|(
name|upper_insn
operator|&
literal|0xf800
operator|)
operator||
operator|(
operator|(
name|addend
operator|>>
literal|11
operator|)
operator|&
literal|0x7ff
operator|)
expr_stmt|;
name|lower_insn
operator|=
operator|(
name|lower_insn
operator|&
literal|0xf800
operator|)
operator||
operator|(
name|addend
operator|&
literal|0x7ff
operator|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|upper_insn
argument_list|,
name|address
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|lower_insn
argument_list|,
name|address
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bfd_vma
name|contents
decl_stmt|;
name|contents
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|address
argument_list|)
expr_stmt|;
comment|/* Get the (signed) value from the instruction.  */
name|addend
operator|=
name|contents
operator|&
name|howto
operator|->
name|src_mask
expr_stmt|;
if|if
condition|(
name|addend
operator|&
operator|(
operator|(
name|howto
operator|->
name|src_mask
operator|+
literal|1
operator|)
operator|>>
literal|1
operator|)
condition|)
block|{
name|bfd_signed_vma
name|mask
decl_stmt|;
name|mask
operator|=
operator|-
literal|1
expr_stmt|;
name|mask
operator|&=
operator|~
name|howto
operator|->
name|src_mask
expr_stmt|;
name|addend
operator||=
name|mask
expr_stmt|;
block|}
comment|/* Add in the increment, (which is a byte value).  */
switch|switch
condition|(
name|howto
operator|->
name|type
condition|)
block|{
default|default:
name|addend
operator|+=
name|increment
expr_stmt|;
break|break;
case|case
name|R_ARM_PC24
case|:
name|addend
operator|<<=
name|howto
operator|->
name|size
expr_stmt|;
name|addend
operator|+=
name|increment
expr_stmt|;
comment|/* Should we check for overflow here ?  */
comment|/* Drop any undesired bits.  */
name|addend
operator|>>=
name|howto
operator|->
name|rightshift
expr_stmt|;
break|break;
block|}
name|contents
operator|=
operator|(
name|contents
operator|&
operator|~
name|howto
operator|->
name|dst_mask
operator|)
operator||
operator|(
name|addend
operator|&
name|howto
operator|->
name|dst_mask
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|contents
argument_list|,
name|address
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_REL */
end_comment

begin_comment
comment|/* Relocate an ARM ELF section.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_arm_relocate_section
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|contents
parameter_list|,
name|relocs
parameter_list|,
name|local_syms
parameter_list|,
name|local_sections
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|local_syms
decl_stmt|;
name|asection
modifier|*
modifier|*
name|local_sections
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relend
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|#
directive|if
operator|!
name|USE_REL
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
return|return
name|TRUE
return|;
endif|#
directive|endif
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|rel
operator|=
name|relocs
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|input_section
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|int
name|r_type
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_reloc_status_type
name|r
decl_stmt|;
name|arelent
name|bfd_reloc
decl_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_ARM_GNU_VTENTRY
operator|||
name|r_type
operator|==
name|R_ARM_GNU_VTINHERIT
condition|)
continue|continue;
name|elf32_arm_info_to_howto
argument_list|(
name|input_bfd
argument_list|,
operator|&
name|bfd_reloc
argument_list|,
name|rel
argument_list|)
expr_stmt|;
name|howto
operator|=
name|bfd_reloc
operator|.
name|howto
expr_stmt|;
if|#
directive|if
name|USE_REL
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
block|{
comment|/* This is a relocatable link.  We don't have to change 	     anything, unless the reloc is against a section symbol, 	     in which case we have to adjust according to where the 	     section symbol winds up in the output section.  */
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_SECTION
condition|)
block|{
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|arm_add_to_rel
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|,
name|howto
argument_list|,
call|(
name|bfd_signed_vma
call|)
argument_list|(
name|sec
operator|->
name|output_offset
operator|+
name|sym
operator|->
name|st_value
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
continue|continue;
block|}
endif|#
directive|endif
comment|/* This is a final link.  */
name|h
operator|=
name|NULL
expr_stmt|;
name|sym
operator|=
name|NULL
expr_stmt|;
name|sec
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
if|#
directive|if
name|USE_REL
name|relocation
operator|=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|sym
operator|->
name|st_value
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_MERGE
operator|)
operator|&&
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_SECTION
condition|)
block|{
name|asection
modifier|*
name|msec
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|,
name|value
decl_stmt|;
if|if
condition|(
name|howto
operator|->
name|rightshift
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s(%s+0x%lx): %s relocation against SEC_MERGE section"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|bfd_get_section_name
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|rel
operator|->
name|r_offset
argument_list|,
name|howto
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|value
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
comment|/* Get the (signed) value from the instruction.  */
name|addend
operator|=
name|value
operator|&
name|howto
operator|->
name|src_mask
expr_stmt|;
if|if
condition|(
name|addend
operator|&
operator|(
operator|(
name|howto
operator|->
name|src_mask
operator|+
literal|1
operator|)
operator|>>
literal|1
operator|)
condition|)
block|{
name|bfd_signed_vma
name|mask
decl_stmt|;
name|mask
operator|=
operator|-
literal|1
expr_stmt|;
name|mask
operator|&=
operator|~
name|howto
operator|->
name|src_mask
expr_stmt|;
name|addend
operator||=
name|mask
expr_stmt|;
block|}
name|msec
operator|=
name|sec
expr_stmt|;
name|addend
operator|=
name|_bfd_elf_rel_local_sym
argument_list|(
name|output_bfd
argument_list|,
name|sym
argument_list|,
operator|&
name|msec
argument_list|,
name|addend
argument_list|)
operator|-
name|relocation
expr_stmt|;
name|addend
operator|+=
name|msec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|msec
operator|->
name|output_offset
expr_stmt|;
name|value
operator|=
operator|(
name|value
operator|&
operator|~
name|howto
operator|->
name|dst_mask
operator|)
operator||
operator|(
name|addend
operator|&
name|howto
operator|->
name|dst_mask
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|value
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|relocation
operator|=
name|_bfd_elf_rela_local_sym
argument_list|(
name|output_bfd
argument_list|,
name|sym
argument_list|,
operator|&
name|sec
argument_list|,
name|rel
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|bfd_boolean
name|warned
decl_stmt|;
name|bfd_boolean
name|unresolved_reloc
decl_stmt|;
name|RELOC_FOR_GLOBAL_SYMBOL
argument_list|(
name|info
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
argument_list|,
name|r_symndx
argument_list|,
name|symtab_hdr
argument_list|,
name|sym_hashes
argument_list|,
name|h
argument_list|,
name|sec
argument_list|,
name|relocation
argument_list|,
name|unresolved_reloc
argument_list|,
name|warned
argument_list|)
expr_stmt|;
if|if
condition|(
name|unresolved_reloc
operator|||
name|relocation
operator|!=
literal|0
condition|)
block|{
comment|/* In these cases, we don't need the relocation value. 	         We check specially because in some obscure cases 	         sec->output_section will be NULL.  */
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_ARM_PC24
case|:
case|case
name|R_ARM_ABS32
case|:
case|case
name|R_ARM_THM_PC22
case|:
case|case
name|R_ARM_PLT32
case|:
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
operator|(
operator|(
operator|!
name|info
operator|->
name|symbolic
operator|&&
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|)
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
operator|&&
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_DEFAULT
operator|&&
operator|(
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
comment|/* DWARF will emit R_ARM_ABS32 relocations in its 			     sections against symbols defined externally 			     in shared libraries.  We can't do anything 			     with them here.  */
operator|||
operator|(
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_DEBUGGING
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|)
operator|)
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|R_ARM_GOTPC
case|:
name|relocation
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|R_ARM_GOT32
case|:
if|if
condition|(
operator|(
name|WILL_CALL_FINISH_DYNAMIC_SYMBOL
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
argument_list|,
name|info
operator|->
name|shared
argument_list|,
name|h
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|info
operator|->
name|shared
operator|||
operator|(
operator|!
name|info
operator|->
name|symbolic
operator|&&
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|)
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|unresolved_reloc
condition|)
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"%s: warning: unresolvable relocation %d against symbol `%s' from %s section"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|r_type
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|bfd_get_section_name
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
else|else
block|{
name|name
operator|=
operator|(
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_link
argument_list|,
name|sym
operator|->
name|st_name
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
operator|||
operator|*
name|name
operator|==
literal|'\0'
condition|)
name|name
operator|=
name|bfd_section_name
argument_list|(
name|input_bfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
block|}
name|r
operator|=
name|elf32_arm_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|output_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
argument_list|,
name|relocation
argument_list|,
name|info
argument_list|,
name|sec
argument_list|,
name|name
argument_list|,
operator|(
name|h
condition|?
name|ELF_ST_TYPE
argument_list|(
name|h
operator|->
name|type
argument_list|)
else|:
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|)
argument_list|,
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|bfd_reloc_ok
condition|)
block|{
specifier|const
name|char
modifier|*
name|msg
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
literal|0
decl_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|bfd_reloc_overflow
case|:
comment|/* If the overflowing reloc was to an undefined symbol, 		 we have already printed one error message and there 		 is no point complaining again.  */
if|if
condition|(
operator|(
operator|!
name|h
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefined
operator|)
operator|&&
operator|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|info
argument_list|,
name|name
argument_list|,
name|howto
operator|->
name|name
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
operator|)
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|bfd_reloc_undefined
case|:
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|info
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|TRUE
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|bfd_reloc_outofrange
case|:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: out of range error"
argument_list|)
expr_stmt|;
goto|goto
name|common_error
goto|;
case|case
name|bfd_reloc_notsupported
case|:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: unsupported relocation error"
argument_list|)
expr_stmt|;
goto|goto
name|common_error
goto|;
case|case
name|bfd_reloc_dangerous
case|:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: dangerous error"
argument_list|)
expr_stmt|;
goto|goto
name|common_error
goto|;
default|default:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: unknown error"
argument_list|)
expr_stmt|;
comment|/* fall through */
name|common_error
label|:
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|warning
call|)
argument_list|(
name|info
argument_list|,
name|msg
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
break|break;
block|}
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Set the right machine number.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_arm_object_p
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|unsigned
name|int
name|mach
decl_stmt|;
name|mach
operator|=
name|bfd_arm_get_mach_from_notes
argument_list|(
name|abfd
argument_list|,
name|ARM_NOTE_SECTION
argument_list|)
expr_stmt|;
if|if
condition|(
name|mach
operator|!=
name|bfd_mach_arm_unknown
condition|)
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_arm
argument_list|,
name|mach
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_ARM_MAVERICK_FLOAT
condition|)
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_arm
argument_list|,
name|bfd_mach_arm_ep9312
argument_list|)
expr_stmt|;
else|else
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_arm
argument_list|,
name|mach
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Function to keep ARM specific flags in the ELF header.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_arm_set_private_flags
parameter_list|(
name|abfd
parameter_list|,
name|flags
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
block|{
if|if
condition|(
name|elf_flags_init
argument_list|(
name|abfd
argument_list|)
operator|&&
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|!=
name|flags
condition|)
block|{
if|if
condition|(
name|EF_ARM_EABI_VERSION
argument_list|(
name|flags
argument_list|)
operator|==
name|EF_ARM_EABI_UNKNOWN
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|EF_ARM_INTERWORK
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"\ Warning: Not setting interworking flag of %s since it has already been specified as non-interworking"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"\ Warning: Clearing the interworking flag of %s due to outside request"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|=
name|flags
expr_stmt|;
name|elf_flags_init
argument_list|(
name|abfd
argument_list|)
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Copy backend specific data from one object module to another.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_arm_copy_private_bfd_data
parameter_list|(
name|ibfd
parameter_list|,
name|obfd
parameter_list|)
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|bfd
modifier|*
name|obfd
decl_stmt|;
block|{
name|flagword
name|in_flags
decl_stmt|;
name|flagword
name|out_flags
decl_stmt|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|ibfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
operator|||
name|bfd_get_flavour
argument_list|(
name|obfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
return|return
name|TRUE
return|;
name|in_flags
operator|=
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
name|out_flags
operator|=
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
if|if
condition|(
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
operator|&&
name|EF_ARM_EABI_VERSION
argument_list|(
name|out_flags
argument_list|)
operator|==
name|EF_ARM_EABI_UNKNOWN
operator|&&
name|in_flags
operator|!=
name|out_flags
condition|)
block|{
comment|/* Cannot mix APCS26 and APCS32 code.  */
if|if
condition|(
operator|(
name|in_flags
operator|&
name|EF_ARM_APCS_26
operator|)
operator|!=
operator|(
name|out_flags
operator|&
name|EF_ARM_APCS_26
operator|)
condition|)
return|return
name|FALSE
return|;
comment|/* Cannot mix float APCS and non-float APCS code.  */
if|if
condition|(
operator|(
name|in_flags
operator|&
name|EF_ARM_APCS_FLOAT
operator|)
operator|!=
operator|(
name|out_flags
operator|&
name|EF_ARM_APCS_FLOAT
operator|)
condition|)
return|return
name|FALSE
return|;
comment|/* If the src and dest have different interworking flags          then turn off the interworking bit.  */
if|if
condition|(
operator|(
name|in_flags
operator|&
name|EF_ARM_INTERWORK
operator|)
operator|!=
operator|(
name|out_flags
operator|&
name|EF_ARM_INTERWORK
operator|)
condition|)
block|{
if|if
condition|(
name|out_flags
operator|&
name|EF_ARM_INTERWORK
condition|)
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"\ Warning: Clearing the interworking flag of %s because non-interworking code in %s has been linked with it"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
name|in_flags
operator|&=
operator|~
name|EF_ARM_INTERWORK
expr_stmt|;
block|}
comment|/* Likewise for PIC, though don't warn for this case.  */
if|if
condition|(
operator|(
name|in_flags
operator|&
name|EF_ARM_PIC
operator|)
operator|!=
operator|(
name|out_flags
operator|&
name|EF_ARM_PIC
operator|)
condition|)
name|in_flags
operator|&=
operator|~
name|EF_ARM_PIC
expr_stmt|;
block|}
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|=
name|in_flags
expr_stmt|;
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Merge backend specific data from an object file to the output    object file when linking.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_arm_merge_private_bfd_data
parameter_list|(
name|ibfd
parameter_list|,
name|obfd
parameter_list|)
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|bfd
modifier|*
name|obfd
decl_stmt|;
block|{
name|flagword
name|out_flags
decl_stmt|;
name|flagword
name|in_flags
decl_stmt|;
name|bfd_boolean
name|flags_compatible
init|=
name|TRUE
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
comment|/* Check if we have the same endianess.  */
if|if
condition|(
operator|!
name|_bfd_generic_verify_endian_match
argument_list|(
name|ibfd
argument_list|,
name|obfd
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|ibfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
operator|||
name|bfd_get_flavour
argument_list|(
name|obfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
return|return
name|TRUE
return|;
comment|/* The input BFD must have had its flags initialised.  */
comment|/* The following seems bogus to me -- The flags are initialized in      the assembler but I don't think an elf_flags_init field is      written into the object.  */
comment|/* BFD_ASSERT (elf_flags_init (ibfd)); */
name|in_flags
operator|=
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
name|out_flags
operator|=
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
if|if
condition|(
operator|!
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
condition|)
block|{
comment|/* If the input is the default architecture and had the default 	 flags then do not bother setting the flags for the output 	 architecture, instead allow future merges to do this.  If no 	 future merges ever set these flags then they will retain their          uninitialised values, which surprise surprise, correspond          to the default values.  */
if|if
condition|(
name|bfd_get_arch_info
argument_list|(
name|ibfd
argument_list|)
operator|->
name|the_default
operator|&&
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
operator|->
name|e_flags
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
operator|=
name|TRUE
expr_stmt|;
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|=
name|in_flags
expr_stmt|;
if|if
condition|(
name|bfd_get_arch
argument_list|(
name|obfd
argument_list|)
operator|==
name|bfd_get_arch
argument_list|(
name|ibfd
argument_list|)
operator|&&
name|bfd_get_arch_info
argument_list|(
name|obfd
argument_list|)
operator|->
name|the_default
condition|)
return|return
name|bfd_set_arch_mach
argument_list|(
name|obfd
argument_list|,
name|bfd_get_arch
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|bfd_get_mach
argument_list|(
name|ibfd
argument_list|)
argument_list|)
return|;
return|return
name|TRUE
return|;
block|}
comment|/* Determine what should happen if the input ARM architecture      does not match the output ARM architecture.  */
if|if
condition|(
operator|!
name|bfd_arm_merge_machines
argument_list|(
name|ibfd
argument_list|,
name|obfd
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Identical flags must be compatible.  */
if|if
condition|(
name|in_flags
operator|==
name|out_flags
condition|)
return|return
name|TRUE
return|;
comment|/* Check to see if the input BFD actually contains any sections.  If      not, its flags may not have been initialised either, but it      cannot actually cause any incompatibility.  Do not short-circuit      dynamic objects; their section list may be emptied by     elf_link_add_object_symbols.      Also check to see if there are no code sections in the input.     In this case there is no need to check for code specific flags.     XXX - do we need to worry about floating-point format compatability     in data sections ?  */
if|if
condition|(
operator|!
operator|(
name|ibfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
condition|)
block|{
name|bfd_boolean
name|null_input_bfd
init|=
name|TRUE
decl_stmt|;
name|bfd_boolean
name|only_data_sections
init|=
name|TRUE
decl_stmt|;
for|for
control|(
name|sec
operator|=
name|ibfd
operator|->
name|sections
init|;
name|sec
operator|!=
name|NULL
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
block|{
comment|/* Ignore synthetic glue sections.  */
if|if
condition|(
name|strcmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
literal|".glue_7"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
literal|".glue_7t"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|bfd_get_section_flags
argument_list|(
name|ibfd
argument_list|,
name|sec
argument_list|)
operator|&
operator|(
name|SEC_LOAD
operator||
name|SEC_CODE
operator||
name|SEC_HAS_CONTENTS
operator|)
operator|)
operator|==
operator|(
name|SEC_LOAD
operator||
name|SEC_CODE
operator||
name|SEC_HAS_CONTENTS
operator|)
condition|)
name|only_data_sections
operator|=
name|FALSE
expr_stmt|;
name|null_input_bfd
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|null_input_bfd
operator|||
name|only_data_sections
condition|)
return|return
name|TRUE
return|;
block|}
comment|/* Complain about various flag mismatches.  */
if|if
condition|(
name|EF_ARM_EABI_VERSION
argument_list|(
name|in_flags
argument_list|)
operator|!=
name|EF_ARM_EABI_VERSION
argument_list|(
name|out_flags
argument_list|)
condition|)
block|{
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"\ ERROR: %s is compiled for EABI version %d, whereas %s is compiled for version %d"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|,
operator|(
name|in_flags
operator|&
name|EF_ARM_EABIMASK
operator|)
operator|>>
literal|24
argument_list|,
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|,
operator|(
name|out_flags
operator|&
name|EF_ARM_EABIMASK
operator|)
operator|>>
literal|24
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Not sure what needs to be checked for EABI versions>= 1.  */
if|if
condition|(
name|EF_ARM_EABI_VERSION
argument_list|(
name|in_flags
argument_list|)
operator|==
name|EF_ARM_EABI_UNKNOWN
condition|)
block|{
if|if
condition|(
operator|(
name|in_flags
operator|&
name|EF_ARM_APCS_26
operator|)
operator|!=
operator|(
name|out_flags
operator|&
name|EF_ARM_APCS_26
operator|)
condition|)
block|{
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"\ ERROR: %s is compiled for APCS-%d, whereas target %s uses APCS-%d"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|in_flags
operator|&
name|EF_ARM_APCS_26
condition|?
literal|26
else|:
literal|32
argument_list|,
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|,
name|out_flags
operator|&
name|EF_ARM_APCS_26
condition|?
literal|26
else|:
literal|32
argument_list|)
expr_stmt|;
name|flags_compatible
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|in_flags
operator|&
name|EF_ARM_APCS_FLOAT
operator|)
operator|!=
operator|(
name|out_flags
operator|&
name|EF_ARM_APCS_FLOAT
operator|)
condition|)
block|{
if|if
condition|(
name|in_flags
operator|&
name|EF_ARM_APCS_FLOAT
condition|)
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"\ ERROR: %s passes floats in float registers, whereas %s passes them in integer registers"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"\ ERROR: %s passes floats in integer registers, whereas %s passes them in float registers"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
name|flags_compatible
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|in_flags
operator|&
name|EF_ARM_VFP_FLOAT
operator|)
operator|!=
operator|(
name|out_flags
operator|&
name|EF_ARM_VFP_FLOAT
operator|)
condition|)
block|{
if|if
condition|(
name|in_flags
operator|&
name|EF_ARM_VFP_FLOAT
condition|)
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"\ ERROR: %s uses VFP instructions, whereas %s does not"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"\ ERROR: %s uses FPA instructions, whereas %s does not"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
name|flags_compatible
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|in_flags
operator|&
name|EF_ARM_MAVERICK_FLOAT
operator|)
operator|!=
operator|(
name|out_flags
operator|&
name|EF_ARM_MAVERICK_FLOAT
operator|)
condition|)
block|{
if|if
condition|(
name|in_flags
operator|&
name|EF_ARM_MAVERICK_FLOAT
condition|)
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"\ ERROR: %s uses Maverick instructions, whereas %s does not"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"\ ERROR: %s does not use Maverick instructions, whereas %s does"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
name|flags_compatible
operator|=
name|FALSE
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|EF_ARM_SOFT_FLOAT
if|if
condition|(
operator|(
name|in_flags
operator|&
name|EF_ARM_SOFT_FLOAT
operator|)
operator|!=
operator|(
name|out_flags
operator|&
name|EF_ARM_SOFT_FLOAT
operator|)
condition|)
block|{
comment|/* We can allow interworking between code that is VFP format 	     layout, and uses either soft float or integer regs for 	     passing floating point arguments and results.  We already 	     know that the APCS_FLOAT flags match; similarly for VFP 	     flags.  */
if|if
condition|(
operator|(
name|in_flags
operator|&
name|EF_ARM_APCS_FLOAT
operator|)
operator|!=
literal|0
operator|||
operator|(
name|in_flags
operator|&
name|EF_ARM_VFP_FLOAT
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|in_flags
operator|&
name|EF_ARM_SOFT_FLOAT
condition|)
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"\ ERROR: %s uses software FP, whereas %s uses hardware FP"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"\ ERROR: %s uses hardware FP, whereas %s uses software FP"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
name|flags_compatible
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* Interworking mismatch is only a warning.  */
if|if
condition|(
operator|(
name|in_flags
operator|&
name|EF_ARM_INTERWORK
operator|)
operator|!=
operator|(
name|out_flags
operator|&
name|EF_ARM_INTERWORK
operator|)
condition|)
block|{
if|if
condition|(
name|in_flags
operator|&
name|EF_ARM_INTERWORK
condition|)
block|{
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"\ Warning: %s supports interworking, whereas %s does not"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"\ Warning: %s does not support interworking, whereas %s does"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|flags_compatible
return|;
block|}
end_function

begin_comment
comment|/* Display the flags field.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_arm_print_private_bfd_data
parameter_list|(
name|abfd
parameter_list|,
name|ptr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|ptr
decl_stmt|;
block|{
name|FILE
modifier|*
name|file
init|=
operator|(
name|FILE
operator|*
operator|)
name|ptr
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|abfd
operator|!=
name|NULL
operator|&&
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Print normal ELF private data.  */
name|_bfd_elf_print_private_bfd_data
argument_list|(
name|abfd
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|flags
operator|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
comment|/* Ignore init flag - it may not be set, despite the flags field      containing valid data.  */
comment|/* xgettext:c-format */
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"private flags = %lx:"
argument_list|)
argument_list|,
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|EF_ARM_EABI_VERSION
argument_list|(
name|flags
argument_list|)
condition|)
block|{
case|case
name|EF_ARM_EABI_UNKNOWN
case|:
comment|/* The following flag bits are GNU extensions and not part of the 	 official ARM ELF extended ABI.  Hence they are only decoded if 	 the EABI version is not set.  */
if|if
condition|(
name|flags
operator|&
name|EF_ARM_INTERWORK
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [interworking enabled]"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|EF_ARM_APCS_26
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" [APCS-26]"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" [APCS-32]"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|EF_ARM_VFP_FLOAT
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [VFP float format]"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|EF_ARM_MAVERICK_FLOAT
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [Maverick float format]"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [FPA float format]"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|EF_ARM_APCS_FLOAT
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [floats passed in float registers]"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|EF_ARM_PIC
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [position independent]"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|EF_ARM_NEW_ABI
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [new ABI]"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|EF_ARM_OLD_ABI
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [old ABI]"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|EF_ARM_SOFT_FLOAT
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [software FP]"
argument_list|)
argument_list|)
expr_stmt|;
name|flags
operator|&=
operator|~
operator|(
name|EF_ARM_INTERWORK
operator||
name|EF_ARM_APCS_26
operator||
name|EF_ARM_APCS_FLOAT
operator||
name|EF_ARM_PIC
operator||
name|EF_ARM_NEW_ABI
operator||
name|EF_ARM_OLD_ABI
operator||
name|EF_ARM_SOFT_FLOAT
operator||
name|EF_ARM_VFP_FLOAT
operator||
name|EF_ARM_MAVERICK_FLOAT
operator|)
expr_stmt|;
break|break;
case|case
name|EF_ARM_EABI_VER1
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [Version1 EABI]"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|EF_ARM_SYMSARESORTED
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [sorted symbol table]"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [unsorted symbol table]"
argument_list|)
argument_list|)
expr_stmt|;
name|flags
operator|&=
operator|~
name|EF_ARM_SYMSARESORTED
expr_stmt|;
break|break;
case|case
name|EF_ARM_EABI_VER2
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [Version2 EABI]"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|EF_ARM_SYMSARESORTED
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [sorted symbol table]"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [unsorted symbol table]"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|EF_ARM_DYNSYMSUSESEGIDX
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [dynamic symbols use segment index]"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|EF_ARM_MAPSYMSFIRST
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [mapping symbols precede others]"
argument_list|)
argument_list|)
expr_stmt|;
name|flags
operator|&=
operator|~
operator|(
name|EF_ARM_SYMSARESORTED
operator||
name|EF_ARM_DYNSYMSUSESEGIDX
operator||
name|EF_ARM_MAPSYMSFIRST
operator|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"<EABI version unrecognised>"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|flags
operator|&=
operator|~
name|EF_ARM_EABIMASK
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|EF_ARM_RELEXEC
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [relocatable executable]"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|EF_ARM_HASENTRY
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [has entry point]"
argument_list|)
argument_list|)
expr_stmt|;
name|flags
operator|&=
operator|~
operator|(
name|EF_ARM_RELEXEC
operator||
name|EF_ARM_HASENTRY
operator|)
expr_stmt|;
if|if
condition|(
name|flags
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"<Unrecognised flag bits set>"
argument_list|)
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|elf32_arm_get_symbol_type
parameter_list|(
name|elf_sym
parameter_list|,
name|type
parameter_list|)
name|Elf_Internal_Sym
modifier|*
name|elf_sym
decl_stmt|;
name|int
name|type
decl_stmt|;
block|{
switch|switch
condition|(
name|ELF_ST_TYPE
argument_list|(
name|elf_sym
operator|->
name|st_info
argument_list|)
condition|)
block|{
case|case
name|STT_ARM_TFUNC
case|:
return|return
name|ELF_ST_TYPE
argument_list|(
name|elf_sym
operator|->
name|st_info
argument_list|)
return|;
case|case
name|STT_ARM_16BIT
case|:
comment|/* If the symbol is not an object, return the STT_ARM_16BIT flag. 	 This allows us to distinguish between data used by Thumb instructions 	 and non-data (which is probably code) inside Thumb regions of an 	 executable.  */
if|if
condition|(
name|type
operator|!=
name|STT_OBJECT
condition|)
return|return
name|ELF_ST_TYPE
argument_list|(
name|elf_sym
operator|->
name|st_info
argument_list|)
return|;
break|break;
default|default:
break|break;
block|}
return|return
name|type
return|;
block|}
end_function

begin_function
specifier|static
name|asection
modifier|*
name|elf32_arm_gc_mark_hook
parameter_list|(
name|sec
parameter_list|,
name|info
parameter_list|,
name|rel
parameter_list|,
name|h
parameter_list|,
name|sym
parameter_list|)
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
block|{
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_ARM_GNU_VTINHERIT
case|:
case|case
name|R_ARM_GNU_VTENTRY
case|:
break|break;
default|default:
switch|switch
condition|(
name|h
operator|->
name|root
operator|.
name|type
condition|)
block|{
case|case
name|bfd_link_hash_defined
case|:
case|case
name|bfd_link_hash_defweak
case|:
return|return
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
return|;
case|case
name|bfd_link_hash_common
case|:
return|return
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
return|;
default|default:
break|break;
block|}
block|}
block|}
else|else
return|return
name|bfd_section_from_elf_index
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|sym
operator|->
name|st_shndx
argument_list|)
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Update the got entry reference counts for the section being removed.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_arm_gc_sweep_hook
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|sec
parameter_list|,
name|relocs
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|sec
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|bfd_signed_vma
modifier|*
name|local_got_refcounts
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|,
modifier|*
name|relend
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|local_dynrel
operator|=
name|NULL
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|local_got_refcounts
operator|=
name|elf_local_got_refcounts
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
switch|switch
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_ARM_GOT32
case|:
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|>=
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|refcount
operator|>
literal|0
condition|)
name|h
operator|->
name|got
operator|.
name|refcount
operator|-=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|local_got_refcounts
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|local_got_refcounts
index|[
name|r_symndx
index|]
operator|>
literal|0
condition|)
name|local_got_refcounts
index|[
name|r_symndx
index|]
operator|-=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|R_ARM_ABS32
case|:
case|case
name|R_ARM_REL32
case|:
case|case
name|R_ARM_PC24
case|:
case|case
name|R_ARM_PLT32
case|:
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|>=
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|struct
name|elf32_arm_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|struct
name|elf32_arm_relocs_copied
modifier|*
modifier|*
name|pp
decl_stmt|;
name|struct
name|elf32_arm_relocs_copied
modifier|*
name|p
decl_stmt|;
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|refcount
operator|>
literal|0
condition|)
name|h
operator|->
name|plt
operator|.
name|refcount
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|==
name|R_ARM_ABS32
operator|||
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|==
name|R_ARM_REL32
condition|)
block|{
name|eh
operator|=
operator|(
expr|struct
name|elf32_arm_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
for|for
control|(
name|pp
operator|=
operator|&
name|eh
operator|->
name|relocs_copied
init|;
operator|(
name|p
operator|=
operator|*
name|pp
operator|)
operator|!=
name|NULL
condition|;
name|pp
operator|=
operator|&
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|section
operator|==
name|sec
condition|)
block|{
name|p
operator|->
name|count
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|count
operator|==
literal|0
condition|)
operator|*
name|pp
operator|=
name|p
operator|->
name|next
expr_stmt|;
break|break;
block|}
block|}
block|}
break|break;
default|default:
break|break;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Look through the relocs for a section during the first phase.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_arm_check_relocs
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|sec
parameter_list|,
name|relocs
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes_end
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel_end
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|sreloc
decl_stmt|;
name|bfd_vma
modifier|*
name|local_got_offsets
decl_stmt|;
name|struct
name|elf32_arm_link_hash_table
modifier|*
name|htab
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
return|return
name|TRUE
return|;
name|htab
operator|=
name|elf32_arm_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|sreloc
operator|=
name|NULL
expr_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|local_got_offsets
operator|=
name|elf_local_got_offsets
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|sym_hashes_end
operator|=
name|sym_hashes
operator|+
name|symtab_hdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf32_External_Sym
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|elf_bad_symtab
argument_list|(
name|abfd
argument_list|)
condition|)
name|sym_hashes_end
operator|-=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|rel_end
operator|=
name|relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|rel_end
condition|;
name|rel
operator|++
control|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
name|h
operator|=
name|NULL
expr_stmt|;
else|else
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
switch|switch
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_ARM_GOT32
case|:
comment|/* This symbol requires a global offset table entry.  */
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|h
operator|->
name|got
operator|.
name|refcount
operator|++
expr_stmt|;
block|}
else|else
block|{
name|bfd_signed_vma
modifier|*
name|local_got_refcounts
decl_stmt|;
comment|/* This is a global offset table entry for a local symbol.  */
name|local_got_refcounts
operator|=
name|elf_local_got_refcounts
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_got_refcounts
operator|==
name|NULL
condition|)
block|{
name|bfd_size_type
name|size
decl_stmt|;
name|size
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|size
operator|*=
operator|(
sizeof|sizeof
argument_list|(
name|bfd_signed_vma
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|)
expr_stmt|;
name|local_got_refcounts
operator|=
operator|(
operator|(
name|bfd_signed_vma
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|local_got_refcounts
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|elf_local_got_refcounts
argument_list|(
name|abfd
argument_list|)
operator|=
name|local_got_refcounts
expr_stmt|;
block|}
name|local_got_refcounts
index|[
name|r_symndx
index|]
operator|+=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|R_ARM_GOTOFF
case|:
case|case
name|R_ARM_GOTPC
case|:
if|if
condition|(
name|htab
operator|->
name|sgot
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|htab
operator|->
name|root
operator|.
name|dynobj
operator|==
name|NULL
condition|)
name|htab
operator|->
name|root
operator|.
name|dynobj
operator|=
name|abfd
expr_stmt|;
if|if
condition|(
operator|!
name|create_got_section
argument_list|(
name|htab
operator|->
name|root
operator|.
name|dynobj
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
break|break;
case|case
name|R_ARM_ABS32
case|:
case|case
name|R_ARM_REL32
case|:
case|case
name|R_ARM_PC24
case|:
case|case
name|R_ARM_PLT32
case|:
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
comment|/* If this reloc is in a read-only section, we might 		   need a copy reloc.  We can't check reliably at this 		   stage whether the section is read-only, as input 		   sections have not yet been mapped to output sections. 		   Tentatively set the flag for now, and correct in 		   adjust_dynamic_symbol.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_NON_GOT_REF
expr_stmt|;
comment|/* We may need a .plt entry if the function this reloc 		   refers to is in a different object.  We can't tell for 		   sure yet, because something later might force the 		   symbol local.  */
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|==
name|R_ARM_PC24
operator|||
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|==
name|R_ARM_PLT32
condition|)
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_NEEDS_PLT
expr_stmt|;
comment|/* If we create a PLT entry, this relocation will reference 		   it, even if it's an ABS32 relocation.  */
name|h
operator|->
name|plt
operator|.
name|refcount
operator|+=
literal|1
expr_stmt|;
block|}
comment|/* If we are creating a shared library, and this is a reloc                against a global symbol, or a non PC relative reloc                against a local symbol, then we need to copy the reloc                into the shared library.  However, if we are linking with                -Bsymbolic, we do not need to copy a reloc against a                global symbol which is defined in an object we are                including in the link (i.e., DEF_REGULAR is set).  At                this point we have not seen all the input files, so it is                possible that DEF_REGULAR is not set now but will be set                later (it is never cleared).  We account for that                possibility below by storing information in the                relocs_copied field of the hash table entry.  */
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|!=
name|R_ARM_PC24
operator|&&
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|!=
name|R_ARM_PLT32
operator|&&
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|!=
name|R_ARM_REL32
operator|)
operator|||
operator|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
operator|!
name|info
operator|->
name|symbolic
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
operator|)
operator|)
condition|)
block|{
name|struct
name|elf32_arm_relocs_copied
modifier|*
name|p
decl_stmt|,
modifier|*
modifier|*
name|head
decl_stmt|;
comment|/* When creating a shared object, we must copy these                    reloc types into the output file.  We create a reloc                    section in dynobj and make room for this reloc.  */
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
operator|(
name|bfd_elf_string_from_elf_section
argument_list|(
name|abfd
argument_list|,
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_shstrndx
argument_list|,
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|rel_hdr
operator|.
name|sh_name
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|BFD_ASSERT
argument_list|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".rel"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|,
name|name
operator|+
literal|4
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|sreloc
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
block|{
name|flagword
name|flags
decl_stmt|;
name|sreloc
operator|=
name|bfd_make_section
argument_list|(
name|dynobj
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|flags
operator|=
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_READONLY
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
name|flags
operator||=
name|SEC_ALLOC
operator||
name|SEC_LOAD
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|dynobj
argument_list|,
name|sreloc
argument_list|,
name|flags
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|sreloc
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|sreloc
operator|=
name|sreloc
expr_stmt|;
block|}
comment|/* If this is a global symbol, we count the number of 		   relocations we need for this symbol.  */
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|head
operator|=
operator|&
operator|(
operator|(
expr|struct
name|elf32_arm_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|relocs_copied
expr_stmt|;
block|}
else|else
block|{
comment|/* Track dynamic relocs needed for local syms too. 		       We really need local syms available to do this 		       easily.  Oh well.  */
name|asection
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|bfd_section_from_r_symndx
argument_list|(
name|abfd
argument_list|,
operator|&
name|htab
operator|->
name|sym_sec
argument_list|,
name|sec
argument_list|,
name|r_symndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|head
operator|=
operator|(
operator|(
expr|struct
name|elf32_arm_relocs_copied
operator|*
operator|*
operator|)
operator|&
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|local_dynrel
operator|)
expr_stmt|;
block|}
name|p
operator|=
operator|*
name|head
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|p
operator|->
name|section
operator|!=
name|sec
condition|)
block|{
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
expr|*
name|p
decl_stmt|;
name|p
operator|=
name|bfd_alloc
argument_list|(
name|htab
operator|->
name|root
operator|.
name|dynobj
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|p
operator|->
name|next
operator|=
operator|*
name|head
expr_stmt|;
operator|*
name|head
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|section
operator|=
name|sec
expr_stmt|;
name|p
operator|->
name|count
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|==
name|R_ARM_ABS32
operator|||
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|==
name|R_ARM_REL32
condition|)
name|p
operator|->
name|count
operator|+=
literal|1
expr_stmt|;
block|}
break|break;
comment|/* This relocation describes the C++ object vtable hierarchy.            Reconstruct it for later use during GC.  */
case|case
name|R_ARM_GNU_VTINHERIT
case|:
if|if
condition|(
operator|!
name|bfd_elf_gc_record_vtinherit
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|h
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
comment|/* This relocation describes which C++ vtable entries are actually            used.  Record for later use during GC.  */
case|case
name|R_ARM_GNU_VTENTRY
case|:
if|if
condition|(
operator|!
name|bfd_elf_gc_record_vtentry
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|h
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Find the nearest line to a particular section and offset, for error    reporting.   This code is a duplicate of the code in elf.c, except    that it also accepts STT_ARM_TFUNC as a symbol that names a function.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_arm_find_nearest_line
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|symbols
parameter_list|,
name|offset
parameter_list|,
name|filename_ptr
parameter_list|,
name|functionname_ptr
parameter_list|,
name|line_ptr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|filename_ptr
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|functionname_ptr
decl_stmt|;
name|unsigned
name|int
modifier|*
name|line_ptr
decl_stmt|;
block|{
name|bfd_boolean
name|found
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|asymbol
modifier|*
name|func
decl_stmt|;
name|bfd_vma
name|low_func
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|_bfd_dwarf2_find_nearest_line
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|symbols
argument_list|,
name|offset
argument_list|,
name|filename_ptr
argument_list|,
name|functionname_ptr
argument_list|,
name|line_ptr
argument_list|,
literal|0
argument_list|,
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|dwarf2_find_line_info
argument_list|)
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
operator|!
name|_bfd_stab_section_find_nearest_line
argument_list|(
name|abfd
argument_list|,
name|symbols
argument_list|,
name|section
argument_list|,
name|offset
argument_list|,
operator|&
name|found
argument_list|,
name|filename_ptr
argument_list|,
name|functionname_ptr
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|line_info
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|found
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|symbols
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|filename
operator|=
name|NULL
expr_stmt|;
name|func
operator|=
name|NULL
expr_stmt|;
name|low_func
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|symbols
init|;
operator|*
name|p
operator|!=
name|NULL
condition|;
name|p
operator|++
control|)
block|{
name|elf_symbol_type
modifier|*
name|q
decl_stmt|;
name|q
operator|=
operator|(
name|elf_symbol_type
operator|*
operator|)
operator|*
name|p
expr_stmt|;
if|if
condition|(
name|bfd_get_section
argument_list|(
operator|&
name|q
operator|->
name|symbol
argument_list|)
operator|!=
name|section
condition|)
continue|continue;
switch|switch
condition|(
name|ELF_ST_TYPE
argument_list|(
name|q
operator|->
name|internal_elf_sym
operator|.
name|st_info
argument_list|)
condition|)
block|{
default|default:
break|break;
case|case
name|STT_FILE
case|:
name|filename
operator|=
name|bfd_asymbol_name
argument_list|(
operator|&
name|q
operator|->
name|symbol
argument_list|)
expr_stmt|;
break|break;
case|case
name|STT_NOTYPE
case|:
case|case
name|STT_FUNC
case|:
case|case
name|STT_ARM_TFUNC
case|:
if|if
condition|(
name|q
operator|->
name|symbol
operator|.
name|section
operator|==
name|section
operator|&&
name|q
operator|->
name|symbol
operator|.
name|value
operator|>=
name|low_func
operator|&&
name|q
operator|->
name|symbol
operator|.
name|value
operator|<=
name|offset
condition|)
block|{
name|func
operator|=
operator|(
name|asymbol
operator|*
operator|)
name|q
expr_stmt|;
name|low_func
operator|=
name|q
operator|->
name|symbol
operator|.
name|value
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|func
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
operator|*
name|filename_ptr
operator|=
name|filename
expr_stmt|;
operator|*
name|functionname_ptr
operator|=
name|bfd_asymbol_name
argument_list|(
name|func
argument_list|)
expr_stmt|;
operator|*
name|line_ptr
operator|=
literal|0
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Adjust a symbol defined by a dynamic object and referenced by a    regular object.  The current definition is in some section of the    dynamic object, but we're not including those sections.  We have to    change the definition to something the rest of the link can    understand.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_arm_adjust_dynamic_symbol
parameter_list|(
name|info
parameter_list|,
name|h
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|unsigned
name|int
name|power_of_two
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
comment|/* Make sure we know what is going on here.  */
name|BFD_ASSERT
argument_list|(
name|dynobj
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_NEEDS_PLT
operator|)
operator|||
name|h
operator|->
name|weakdef
operator|!=
name|NULL
operator|||
operator|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_REF_REGULAR
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* If this is a function, put it in the procedure linkage table.  We      will fill in the contents of the procedure linkage table later,      when we know the address of the .got section.  */
if|if
condition|(
name|h
operator|->
name|type
operator|==
name|STT_FUNC
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_NEEDS_PLT
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|refcount
operator|<=
literal|0
operator|||
name|SYMBOL_CALLS_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
operator|||
operator|(
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|!=
name|STV_DEFAULT
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|)
condition|)
block|{
comment|/* This case can occur if we saw a PLT32 reloc in an input 	     file, but the symbol was never referred to by a dynamic 	     object, or if all references were garbage collected.  In 	     such a case, we don't actually need to build a procedure 	     linkage table, and we can just do a PC24 reloc instead.  */
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_HASH_NEEDS_PLT
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
else|else
comment|/* It's possible that we incorrectly decided a .plt reloc was        needed for an R_ARM_PC24 reloc to a non-function sym in        check_relocs.  We can't decide accurately between function and        non-function syms in check-relocs;  Objects loaded later in        the link may change h->type.  So fix it now.  */
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* If this is a weak symbol, and there is a real definition, the      processor independent code will have arranged for us to see the      real definition first, and we can just use the same value.  */
if|if
condition|(
name|h
operator|->
name|weakdef
operator|!=
name|NULL
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
argument_list|)
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* This is a reference to a symbol defined by a dynamic object which      is not a function.  */
comment|/* If we are creating a shared library, we must presume that the      only references to the symbol are via the global offset table.      For such cases we need not do anything here; the relocations will      be handled correctly by relocate_section.  */
if|if
condition|(
name|info
operator|->
name|shared
condition|)
return|return
name|TRUE
return|;
comment|/* We must allocate the symbol in our .dynbss section, which will      become part of the .bss section of the executable.  There will be      an entry for this symbol in the .dynsym section.  The dynamic      object will contain position independent code, so all references      from the dynamic object to this symbol will go through the global      offset table.  The dynamic linker will use the .dynsym entry to      determine the address it must put in the global offset table, so      both the dynamic object and the regular object will refer to the      same memory location for the variable.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynbss"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* We must generate a R_ARM_COPY reloc to tell the dynamic linker to      copy the initial value out of the dynamic object and into the      runtime process image.  We need to remember the offset into the      .rel.bss section we are going to use.  */
if|if
condition|(
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
name|asection
modifier|*
name|srel
decl_stmt|;
name|srel
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rel.bss"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|srel
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|srel
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_NEEDS_COPY
expr_stmt|;
block|}
comment|/* We need to figure out the alignment required for this symbol.  I      have no idea how ELF linkers handle this.  */
name|power_of_two
operator|=
name|bfd_log2
argument_list|(
name|h
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|power_of_two
operator|>
literal|3
condition|)
name|power_of_two
operator|=
literal|3
expr_stmt|;
comment|/* Apply the required alignment.  */
name|s
operator|->
name|_raw_size
operator|=
name|BFD_ALIGN
argument_list|(
name|s
operator|->
name|_raw_size
argument_list|,
call|(
name|bfd_size_type
call|)
argument_list|(
literal|1
operator|<<
name|power_of_two
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|power_of_two
operator|>
name|bfd_get_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|,
name|power_of_two
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Define the symbol as being at this point in the section.  */
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|s
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
comment|/* Increment the section size to make room for the symbol.  */
name|s
operator|->
name|_raw_size
operator|+=
name|h
operator|->
name|size
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Allocate space in .plt, .got and associated reloc sections for    dynamic relocs.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|allocate_dynrelocs
parameter_list|(
name|h
parameter_list|,
name|inf
parameter_list|)
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|PTR
name|inf
decl_stmt|;
block|{
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|elf32_arm_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|struct
name|elf32_arm_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|struct
name|elf32_arm_relocs_copied
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
comment|/* When warning symbols are created, they **replace** the "real"        entry in the hash table, thus we never get to see the real        symbol in a hash traversal.  So look at it now.  */
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|info
operator|=
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|)
name|inf
expr_stmt|;
name|htab
operator|=
name|elf32_arm_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|root
operator|.
name|dynamic_sections_created
operator|&&
name|h
operator|->
name|plt
operator|.
name|refcount
operator|>
literal|0
condition|)
block|{
comment|/* Make sure this symbol is output as a dynamic symbol. 	 Undefined weak syms won't yet be marked as dynamic.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_FORCED_LOCAL
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|info
operator|->
name|shared
operator|||
name|WILL_CALL_FINISH_DYNAMIC_SYMBOL
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
name|h
argument_list|)
condition|)
block|{
name|asection
modifier|*
name|s
init|=
name|htab
operator|->
name|splt
decl_stmt|;
comment|/* If this is the first .plt entry, make room for the special 	     first entry.  */
if|if
condition|(
name|s
operator|->
name|_raw_size
operator|==
literal|0
condition|)
name|s
operator|->
name|_raw_size
operator|+=
name|PLT_HEADER_SIZE
expr_stmt|;
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
comment|/* If this symbol is not defined in a regular file, and we are 	     not generating a shared library, then set the symbol to this 	     location in the .plt.  This is required to make function 	     pointers compare as equal between the normal executable and 	     the shared library.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
condition|)
block|{
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|s
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|h
operator|->
name|plt
operator|.
name|offset
expr_stmt|;
block|}
comment|/* Make room for this entry.  */
name|s
operator|->
name|_raw_size
operator|+=
name|PLT_ENTRY_SIZE
expr_stmt|;
comment|/* We also need to make an entry in the .got.plt section, which 	     will be placed in the .got section by the linker script.  */
name|htab
operator|->
name|sgotplt
operator|->
name|_raw_size
operator|+=
literal|4
expr_stmt|;
comment|/* We also need to make an entry in the .rel.plt section.  */
name|htab
operator|->
name|srelplt
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_HASH_NEEDS_PLT
expr_stmt|;
block|}
block|}
else|else
block|{
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_HASH_NEEDS_PLT
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|refcount
operator|>
literal|0
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_boolean
name|dyn
decl_stmt|;
comment|/* Make sure this symbol is output as a dynamic symbol. 	 Undefined weak syms won't yet be marked as dynamic.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_FORCED_LOCAL
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
name|s
operator|=
name|htab
operator|->
name|sgot
expr_stmt|;
name|h
operator|->
name|got
operator|.
name|offset
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|+=
literal|4
expr_stmt|;
name|dyn
operator|=
name|htab
operator|->
name|root
operator|.
name|dynamic_sections_created
expr_stmt|;
if|if
condition|(
operator|(
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_DEFAULT
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefweak
operator|)
operator|&&
operator|(
name|info
operator|->
name|shared
operator|||
name|WILL_CALL_FINISH_DYNAMIC_SYMBOL
argument_list|(
name|dyn
argument_list|,
literal|0
argument_list|,
name|h
argument_list|)
operator|)
condition|)
name|htab
operator|->
name|srelgot
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
expr_stmt|;
block|}
else|else
name|h
operator|->
name|got
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|elf32_arm_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
if|if
condition|(
name|eh
operator|->
name|relocs_copied
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
comment|/* In the shared -Bsymbolic case, discard space allocated for      dynamic pc-relative relocs against symbols which turn out to be      defined in regular objects.  For the normal shared case, discard      space for pc-relative relocs that have become local due to symbol      visibility changes.  */
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
comment|/* Discard relocs on undefined weak syms with non-default          visibility.  */
if|if
condition|(
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|!=
name|STV_DEFAULT
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
name|eh
operator|->
name|relocs_copied
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* For the non-shared case, discard space for relocs against 	 symbols which turn out to need copy relocs or are not 	 dynamic.  */
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_NON_GOT_REF
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|htab
operator|->
name|root
operator|.
name|dynamic_sections_created
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* Make sure this symbol is output as a dynamic symbol. 	     Undefined weak syms won't yet be marked as dynamic.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_FORCED_LOCAL
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* If that succeeded, we know we'll be keeping all the 	     relocs.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
condition|)
goto|goto
name|keep
goto|;
block|}
name|eh
operator|->
name|relocs_copied
operator|=
name|NULL
expr_stmt|;
name|keep
label|:
empty_stmt|;
block|}
comment|/* Finally, allocate space.  */
for|for
control|(
name|p
operator|=
name|eh
operator|->
name|relocs_copied
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|asection
modifier|*
name|sreloc
init|=
name|elf_section_data
argument_list|(
name|p
operator|->
name|section
argument_list|)
operator|->
name|sreloc
decl_stmt|;
name|sreloc
operator|->
name|_raw_size
operator|+=
name|p
operator|->
name|count
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Set the sizes of the dynamic sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_arm_size_dynamic_sections
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_boolean
name|plt
decl_stmt|;
name|bfd_boolean
name|relocs
decl_stmt|;
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|struct
name|elf32_arm_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|htab
operator|=
name|elf32_arm_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|dynobj
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
comment|/* Set the contents of the .interp section to the interpreter.  */
if|if
condition|(
name|info
operator|->
name|executable
condition|)
block|{
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".interp"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|=
sizeof|sizeof
name|ELF_DYNAMIC_INTERPRETER
expr_stmt|;
name|s
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ELF_DYNAMIC_INTERPRETER
expr_stmt|;
block|}
block|}
comment|/* Set up .got offsets for local syms, and space for local dynamic      relocs.  */
for|for
control|(
name|ibfd
operator|=
name|info
operator|->
name|input_bfds
init|;
name|ibfd
operator|!=
name|NULL
condition|;
name|ibfd
operator|=
name|ibfd
operator|->
name|link_next
control|)
block|{
name|bfd_signed_vma
modifier|*
name|local_got
decl_stmt|;
name|bfd_signed_vma
modifier|*
name|end_local_got
decl_stmt|;
name|char
modifier|*
name|local_tls_type
decl_stmt|;
name|bfd_size_type
name|locsymcount
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|asection
modifier|*
name|srel
decl_stmt|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|ibfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
continue|continue;
for|for
control|(
name|s
operator|=
name|ibfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|struct
name|elf32_arm_relocs_copied
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
operator|*
operator|(
operator|(
expr|struct
name|elf32_arm_relocs_copied
operator|*
operator|*
operator|)
operator|&
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|local_dynrel
operator|)
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|bfd_is_abs_section
argument_list|(
name|p
operator|->
name|section
argument_list|)
operator|&&
name|bfd_is_abs_section
argument_list|(
name|p
operator|->
name|section
operator|->
name|output_section
argument_list|)
condition|)
block|{
comment|/* Input section has been discarded, either because 		     it is a copy of a linkonce section or due to 		     linker script /DISCARD/, so we'll be discarding 		     the relocs too.  */
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|count
operator|!=
literal|0
condition|)
block|{
name|srel
operator|=
name|elf_section_data
argument_list|(
name|p
operator|->
name|section
argument_list|)
operator|->
name|sreloc
expr_stmt|;
name|srel
operator|->
name|_raw_size
operator|+=
name|p
operator|->
name|count
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|section
operator|->
name|output_section
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|!=
literal|0
condition|)
name|info
operator|->
name|flags
operator||=
name|DF_TEXTREL
expr_stmt|;
block|}
block|}
block|}
name|local_got
operator|=
name|elf_local_got_refcounts
argument_list|(
name|ibfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|local_got
condition|)
continue|continue;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|locsymcount
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|end_local_got
operator|=
name|local_got
operator|+
name|locsymcount
expr_stmt|;
name|s
operator|=
name|htab
operator|->
name|sgot
expr_stmt|;
name|srel
operator|=
name|htab
operator|->
name|srelgot
expr_stmt|;
for|for
control|(
init|;
name|local_got
operator|<
name|end_local_got
condition|;
operator|++
name|local_got
operator|,
operator|++
name|local_tls_type
control|)
block|{
if|if
condition|(
operator|*
name|local_got
operator|>
literal|0
condition|)
block|{
operator|*
name|local_got
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
name|srel
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|local_got
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
block|}
block|}
comment|/* Allocate global sym .plt and .got entries, and space for global      sym dynamic relocs.  */
name|elf_link_hash_traverse
argument_list|(
operator|&
name|htab
operator|->
name|root
argument_list|,
name|allocate_dynrelocs
argument_list|,
operator|(
name|PTR
operator|)
name|info
argument_list|)
expr_stmt|;
comment|/* The check_relocs and adjust_dynamic_symbol entry points have      determined the sizes of the various dynamic sections.  Allocate      memory for them.  */
name|plt
operator|=
name|FALSE
expr_stmt|;
name|relocs
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|s
operator|=
name|dynobj
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bfd_boolean
name|strip
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LINKER_CREATED
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* It's OK to base decisions on the section name, because none 	 of the dynobj section names depend upon the input files.  */
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|strip
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".plt"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|_raw_size
operator|==
literal|0
condition|)
block|{
comment|/* Strip this section if we don't need it; see the                  comment below.  */
name|strip
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* Remember whether there is a PLT.  */
name|plt
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".rel"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|_raw_size
operator|==
literal|0
condition|)
block|{
comment|/* If we don't need this section, strip it from the 		 output file.  This is mostly to handle .rel.bss and 		 .rel.plt.  We must create both sections in 		 create_dynamic_sections, because they must be created 		 before the linker maps input sections to output 		 sections.  The linker does that before 		 adjust_dynamic_symbol is called, and it is that 		 function which decides whether anything needs to go 		 into these sections.  */
name|strip
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* Remember whether there are any reloc sections other                  than .rel.plt.  */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".rel.plt"
argument_list|)
operator|!=
literal|0
condition|)
name|relocs
operator|=
name|TRUE
expr_stmt|;
comment|/* We use the reloc_count field as a counter if we need 		 to copy relocs into the output file.  */
name|s
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".got"
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* It's not one of our sections, so don't allocate space.  */
continue|continue;
block|}
if|if
condition|(
name|strip
condition|)
block|{
name|_bfd_strip_section_from_output
argument_list|(
name|info
argument_list|,
name|s
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Allocate memory for the section contents.  */
name|s
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|dynobj
argument_list|,
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|contents
operator|==
name|NULL
operator|&&
name|s
operator|->
name|_raw_size
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
comment|/* Add some entries to the .dynamic section.  We fill in the 	 values later, in elf32_arm_finish_dynamic_sections, but we 	 must add the entries now so that we get the correct size for 	 the .dynamic section.  The DT_DEBUG entry is filled in by the 	 dynamic linker and used by the debugger.  */
define|#
directive|define
name|add_dynamic_entry
parameter_list|(
name|TAG
parameter_list|,
name|VAL
parameter_list|)
define|\
value|_bfd_elf_add_dynamic_entry (info, TAG, VAL)
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_DEBUG
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|plt
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PLTGOT
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PLTRELSZ
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PLTREL
argument_list|,
name|DT_REL
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_JMPREL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|relocs
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_REL
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELSZ
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELENT
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|(
name|info
operator|->
name|flags
operator|&
name|DF_TEXTREL
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_TEXTREL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|info
operator|->
name|flags
operator||=
name|DF_TEXTREL
expr_stmt|;
block|}
block|}
undef|#
directive|undef
name|add_synamic_entry
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Finish up dynamic symbol handling.  We set the contents of various    dynamic sections here.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_arm_finish_dynamic_symbol
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|h
parameter_list|,
name|sym
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
name|asection
modifier|*
name|splt
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
name|asection
modifier|*
name|srel
decl_stmt|;
name|bfd_vma
name|plt_index
decl_stmt|;
name|bfd_vma
name|got_offset
decl_stmt|;
name|Elf_Internal_Rela
name|rel
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|bfd_vma
name|got_displacement
decl_stmt|;
comment|/* This symbol has an entry in the procedure linkage table.  Set 	 it up.  */
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|splt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got.plt"
argument_list|)
expr_stmt|;
name|srel
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rel.plt"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|splt
operator|!=
name|NULL
operator|&&
name|sgot
operator|!=
name|NULL
operator|&&
name|srel
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Get the index in the procedure linkage table which 	 corresponds to this symbol.  This is the index of this symbol 	 in all the symbols for which we are making plt entries.  The 	 first entry in the procedure linkage table is reserved.  */
name|plt_index
operator|=
operator|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|-
name|PLT_HEADER_SIZE
operator|)
operator|/
name|PLT_ENTRY_SIZE
expr_stmt|;
comment|/* Get the offset into the .got table of the entry that 	 corresponds to this function.  Each .got entry is 4 bytes. 	 The first three are reserved.  */
name|got_offset
operator|=
operator|(
name|plt_index
operator|+
literal|3
operator|)
operator|*
literal|4
expr_stmt|;
comment|/* Calculate the displacement between the PLT slot and the 	 entry in the GOT.  */
name|got_displacement
operator|=
operator|(
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
name|got_offset
operator|-
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|-
name|splt
operator|->
name|output_offset
operator|-
name|h
operator|->
name|plt
operator|.
name|offset
operator|-
literal|8
operator|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
operator|(
name|got_displacement
operator|&
literal|0xf0000000
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* Fill in the entry in the procedure linkage table.  */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|elf32_arm_plt_entry
index|[
literal|0
index|]
operator||
operator|(
operator|(
name|got_displacement
operator|&
literal|0x0ff00000
operator|)
operator|>>
literal|20
operator|)
argument_list|,
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
literal|0
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|elf32_arm_plt_entry
index|[
literal|1
index|]
operator||
operator|(
operator|(
name|got_displacement
operator|&
literal|0x000ff000
operator|)
operator|>>
literal|12
operator|)
argument_list|,
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|elf32_arm_plt_entry
index|[
literal|2
index|]
operator||
operator|(
name|got_displacement
operator|&
literal|0x00000fff
operator|)
argument_list|,
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
literal|8
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FOUR_WORD_PLT
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|elf32_arm_plt_entry
index|[
literal|3
index|]
argument_list|,
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
literal|12
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Fill in the entry in the global offset table.  */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|splt
operator|->
name|output_offset
operator|)
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|got_offset
argument_list|)
expr_stmt|;
comment|/* Fill in the entry in the .rel.plt section.  */
name|rel
operator|.
name|r_offset
operator|=
operator|(
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
name|got_offset
operator|)
expr_stmt|;
name|rel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_ARM_JUMP_SLOT
argument_list|)
expr_stmt|;
name|loc
operator|=
name|srel
operator|->
name|contents
operator|+
name|plt_index
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloc_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Mark the symbol as undefined, rather than as defined in 	     the .plt section.  Leave the value alone.  */
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_UNDEF
expr_stmt|;
comment|/* If the symbol is weak, we do need to clear the value. 	     Otherwise, the PLT entry would provide a definition for 	     the symbol even if the symbol wasn't defined anywhere, 	     and so the symbol would never be NULL.  */
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_REF_REGULAR_NONWEAK
operator|)
operator|==
literal|0
condition|)
name|sym
operator|->
name|st_value
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
name|asection
modifier|*
name|sgot
decl_stmt|;
name|asection
modifier|*
name|srel
decl_stmt|;
name|Elf_Internal_Rela
name|rel
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
comment|/* This symbol has an entry in the global offset table.  Set it 	 up.  */
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
name|srel
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rel.got"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
operator|&&
name|srel
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|rel
operator|.
name|r_offset
operator|=
operator|(
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
operator|(
name|h
operator|->
name|got
operator|.
name|offset
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
literal|1
operator|)
operator|)
expr_stmt|;
comment|/* If this is a static link, or it is a -Bsymbolic link and the 	 symbol is defined locally or was forced to be local because 	 of a version file, we just want to emit a RELATIVE reloc. 	 The entry in the global offset table will already have been 	 initialized in the relocate_section function.  */
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
name|SYMBOL_REFERENCES_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
block|{
name|BFD_ASSERT
argument_list|(
operator|(
name|h
operator|->
name|got
operator|.
name|offset
operator|&
literal|1
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|rel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_ARM_RELATIVE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|BFD_ASSERT
argument_list|(
operator|(
name|h
operator|->
name|got
operator|.
name|offset
operator|&
literal|1
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|h
operator|->
name|got
operator|.
name|offset
argument_list|)
expr_stmt|;
name|rel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_ARM_GLOB_DAT
argument_list|)
expr_stmt|;
block|}
name|loc
operator|=
name|srel
operator|->
name|contents
operator|+
name|srel
operator|->
name|reloc_count
operator|++
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloc_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_NEEDS_COPY
operator|)
operator|!=
literal|0
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|Elf_Internal_Rela
name|rel
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
comment|/* This symbol needs a copy reloc.  Set it up.  */
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
argument_list|,
literal|".rel.bss"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|rel
operator|.
name|r_offset
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|rel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_ARM_COPY
argument_list|)
expr_stmt|;
name|loc
operator|=
name|s
operator|->
name|contents
operator|+
name|s
operator|->
name|reloc_count
operator|++
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloc_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
comment|/* Mark _DYNAMIC and _GLOBAL_OFFSET_TABLE_ as absolute.  */
if|if
condition|(
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_DYNAMIC"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|)
operator|==
literal|0
condition|)
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_ABS
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Finish up the dynamic sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_arm_finish_dynamic_sections
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
name|asection
modifier|*
name|sdyn
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got.plt"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|sdyn
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
name|asection
modifier|*
name|splt
decl_stmt|;
name|Elf32_External_Dyn
modifier|*
name|dyncon
decl_stmt|,
modifier|*
name|dynconend
decl_stmt|;
name|splt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|splt
operator|!=
name|NULL
operator|&&
name|sdyn
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dyncon
operator|=
operator|(
name|Elf32_External_Dyn
operator|*
operator|)
name|sdyn
operator|->
name|contents
expr_stmt|;
name|dynconend
operator|=
operator|(
name|Elf32_External_Dyn
operator|*
operator|)
operator|(
name|sdyn
operator|->
name|contents
operator|+
name|sdyn
operator|->
name|_raw_size
operator|)
expr_stmt|;
for|for
control|(
init|;
name|dyncon
operator|<
name|dynconend
condition|;
name|dyncon
operator|++
control|)
block|{
name|Elf_Internal_Dyn
name|dyn
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_elf32_swap_dyn_in
argument_list|(
name|dynobj
argument_list|,
name|dyncon
argument_list|,
operator|&
name|dyn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dyn
operator|.
name|d_tag
condition|)
block|{
default|default:
break|break;
case|case
name|DT_PLTGOT
case|:
name|name
operator|=
literal|".got"
expr_stmt|;
goto|goto
name|get_vma
goto|;
case|case
name|DT_JMPREL
case|:
name|name
operator|=
literal|".rel.plt"
expr_stmt|;
name|get_vma
label|:
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|s
operator|->
name|vma
expr_stmt|;
name|bfd_elf32_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_PLTRELSZ
case|:
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
literal|".rel.plt"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|_cooked_size
operator|!=
literal|0
condition|)
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|s
operator|->
name|_cooked_size
expr_stmt|;
else|else
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
name|bfd_elf32_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_RELSZ
case|:
comment|/* My reading of the SVR4 ABI indicates that the 		 procedure linkage table relocs (DT_JMPREL) should be 		 included in the overall relocs (DT_REL).  This is 		 what Solaris does.  However, UnixWare can not handle 		 that case.  Therefore, we override the DT_RELSZ entry 		 here to make it not include the JMPREL relocs.  Since 		 the linker script arranges for .rel.plt to follow all 		 other relocation sections, we don't have to worry 		 about changing the DT_REL entry.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
literal|".rel.plt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|_cooked_size
operator|!=
literal|0
condition|)
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|-=
name|s
operator|->
name|_cooked_size
expr_stmt|;
else|else
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|-=
name|s
operator|->
name|_raw_size
expr_stmt|;
block|}
name|bfd_elf32_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
break|break;
comment|/* Set the bottom bit of DT_INIT/FINI if the 		 corresponding function is Thumb.  */
case|case
name|DT_INIT
case|:
name|name
operator|=
name|info
operator|->
name|init_function
expr_stmt|;
goto|goto
name|get_sym
goto|;
case|case
name|DT_FINI
case|:
name|name
operator|=
name|info
operator|->
name|fini_function
expr_stmt|;
name|get_sym
label|:
comment|/* If it wasn't set by elf_bfd_final_link 		 then there is nothing to adjust.  */
if|if
condition|(
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|!=
literal|0
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|eh
operator|=
name|elf_link_hash_lookup
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|eh
operator|!=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|NULL
operator|&&
name|ELF_ST_TYPE
argument_list|(
name|eh
operator|->
name|type
argument_list|)
operator|==
name|STT_ARM_TFUNC
condition|)
block|{
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator||=
literal|1
expr_stmt|;
name|bfd_elf32_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
comment|/* Fill in the first entry in the procedure linkage table.  */
if|if
condition|(
name|splt
operator|->
name|_raw_size
operator|>
literal|0
condition|)
block|{
name|bfd_vma
name|got_displacement
decl_stmt|;
comment|/* Calculate the displacement between the PLT slot and&GOT[0].  */
name|got_displacement
operator|=
operator|(
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|-
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|-
name|splt
operator|->
name|output_offset
operator|-
literal|16
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|elf32_arm_plt0_entry
index|[
literal|0
index|]
argument_list|,
name|splt
operator|->
name|contents
operator|+
literal|0
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|elf32_arm_plt0_entry
index|[
literal|1
index|]
argument_list|,
name|splt
operator|->
name|contents
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|elf32_arm_plt0_entry
index|[
literal|2
index|]
argument_list|,
name|splt
operator|->
name|contents
operator|+
literal|8
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|elf32_arm_plt0_entry
index|[
literal|3
index|]
argument_list|,
name|splt
operator|->
name|contents
operator|+
literal|12
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FOUR_WORD_PLT
comment|/* The displacement value goes in the otherwise-unused last word of 	     the second entry.  */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|got_displacement
argument_list|,
name|splt
operator|->
name|contents
operator|+
literal|28
argument_list|)
expr_stmt|;
else|#
directive|else
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|got_displacement
argument_list|,
name|splt
operator|->
name|contents
operator|+
literal|16
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* UnixWare sets the entsize of .plt to 4, although that doesn't 	 really seem like the right value.  */
name|elf_section_data
argument_list|(
name|splt
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
operator|=
literal|4
expr_stmt|;
block|}
comment|/* Fill in the first three entries in the global offset table.  */
if|if
condition|(
name|sgot
operator|->
name|_raw_size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|sdyn
operator|==
name|NULL
condition|)
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|sgot
operator|->
name|contents
argument_list|)
expr_stmt|;
else|else
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|sdyn
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sdyn
operator|->
name|output_offset
argument_list|,
name|sgot
operator|->
name|contents
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|sgot
operator|->
name|contents
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|sgot
operator|->
name|contents
operator|+
literal|8
argument_list|)
expr_stmt|;
block|}
name|elf_section_data
argument_list|(
name|sgot
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
operator|=
literal|4
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|elf32_arm_post_process_headers
parameter_list|(
name|abfd
parameter_list|,
name|link_info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|link_info
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|Elf_Internal_Ehdr
modifier|*
name|i_ehdrp
decl_stmt|;
comment|/* ELF file header, internal form.  */
name|i_ehdrp
operator|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|i_ehdrp
operator|->
name|e_ident
index|[
name|EI_OSABI
index|]
operator|=
name|ARM_ELF_OS_ABI_VERSION
expr_stmt|;
name|i_ehdrp
operator|->
name|e_ident
index|[
name|EI_ABIVERSION
index|]
operator|=
name|ARM_ELF_ABI_VERSION
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|enum
name|elf_reloc_type_class
name|elf32_arm_reloc_type_class
parameter_list|(
name|rela
parameter_list|)
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rela
decl_stmt|;
block|{
switch|switch
condition|(
operator|(
name|int
operator|)
name|ELF32_R_TYPE
argument_list|(
name|rela
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_ARM_RELATIVE
case|:
return|return
name|reloc_class_relative
return|;
case|case
name|R_ARM_JUMP_SLOT
case|:
return|return
name|reloc_class_plt
return|;
case|case
name|R_ARM_COPY
case|:
return|return
name|reloc_class_copy
return|;
default|default:
return|return
name|reloc_class_normal
return|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf32_arm_section_flags
name|PARAMS
argument_list|(
operator|(
name|flagword
operator|*
operator|,
name|Elf_Internal_Shdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|elf32_arm_final_write_processing
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd_boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set the right machine number for an Arm ELF file.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_arm_section_flags
parameter_list|(
name|flags
parameter_list|,
name|hdr
parameter_list|)
name|flagword
modifier|*
name|flags
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
block|{
if|if
condition|(
name|hdr
operator|->
name|sh_type
operator|==
name|SHT_NOTE
condition|)
operator|*
name|flags
operator||=
name|SEC_LINK_ONCE
operator||
name|SEC_LINK_DUPLICATES_SAME_CONTENTS
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|void
name|elf32_arm_final_write_processing
parameter_list|(
name|abfd
parameter_list|,
name|linker
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|bfd_boolean
name|linker
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|bfd_arm_update_notes
argument_list|(
name|abfd
argument_list|,
name|ARM_NOTE_SECTION
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|ELF_ARCH
value|bfd_arch_arm
end_define

begin_define
define|#
directive|define
name|ELF_MACHINE_CODE
value|EM_ARM
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__QNXTARGET__
end_ifdef

begin_define
define|#
directive|define
name|ELF_MAXPAGESIZE
value|0x1000
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ELF_MAXPAGESIZE
value|0x8000
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|bfd_elf32_bfd_copy_private_bfd_data
value|elf32_arm_copy_private_bfd_data
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_merge_private_bfd_data
value|elf32_arm_merge_private_bfd_data
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_set_private_flags
value|elf32_arm_set_private_flags
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_print_private_bfd_data
value|elf32_arm_print_private_bfd_data
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_link_hash_table_create
value|elf32_arm_link_hash_table_create
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_reloc_type_lookup
value|elf32_arm_reloc_type_lookup
end_define

begin_define
define|#
directive|define
name|bfd_elf32_find_nearest_line
value|elf32_arm_find_nearest_line
end_define

begin_define
define|#
directive|define
name|elf_backend_get_symbol_type
value|elf32_arm_get_symbol_type
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_mark_hook
value|elf32_arm_gc_mark_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_sweep_hook
value|elf32_arm_gc_sweep_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_check_relocs
value|elf32_arm_check_relocs
end_define

begin_define
define|#
directive|define
name|elf_backend_relocate_section
value|elf32_arm_relocate_section
end_define

begin_define
define|#
directive|define
name|elf_backend_adjust_dynamic_symbol
value|elf32_arm_adjust_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_create_dynamic_sections
value|elf32_arm_create_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_symbol
value|elf32_arm_finish_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_sections
value|elf32_arm_finish_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_size_dynamic_sections
value|elf32_arm_size_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_post_process_headers
value|elf32_arm_post_process_headers
end_define

begin_define
define|#
directive|define
name|elf_backend_reloc_type_class
value|elf32_arm_reloc_type_class
end_define

begin_define
define|#
directive|define
name|elf_backend_object_p
value|elf32_arm_object_p
end_define

begin_define
define|#
directive|define
name|elf_backend_section_flags
value|elf32_arm_section_flags
end_define

begin_define
define|#
directive|define
name|elf_backend_final_write_processing
value|elf32_arm_final_write_processing
end_define

begin_define
define|#
directive|define
name|elf_backend_copy_indirect_symbol
value|elf32_arm_copy_indirect_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_can_refcount
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_can_gc_sections
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_plt_readonly
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_want_got_plt
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_want_plt_sym
value|0
end_define

begin_if
if|#
directive|if
operator|!
name|USE_REL
end_if

begin_define
define|#
directive|define
name|elf_backend_rela_normal
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|elf_backend_got_header_size
value|12
end_define

begin_include
include|#
directive|include
file|"elf32-target.h"
end_include

end_unit

