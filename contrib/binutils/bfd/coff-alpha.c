begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD back-end for ALPHA Extended-Coff files.    Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001    Free Software Foundation, Inc.    Modified from coff-mips.c by Steve Chamberlain<sac@cygnus.com> and    Ian Lance Taylor<ian@cygnus.com>.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"coff/internal.h"
end_include

begin_include
include|#
directive|include
file|"coff/sym.h"
end_include

begin_include
include|#
directive|include
file|"coff/symconst.h"
end_include

begin_include
include|#
directive|include
file|"coff/ecoff.h"
end_include

begin_include
include|#
directive|include
file|"coff/alpha.h"
end_include

begin_include
include|#
directive|include
file|"aout/ar.h"
end_include

begin_include
include|#
directive|include
file|"libcoff.h"
end_include

begin_include
include|#
directive|include
file|"libecoff.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* Prototypes for static functions.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|bfd_target
modifier|*
name|alpha_ecoff_object_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|alpha_ecoff_bad_format_hook
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|PTR
name|filehdr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|PTR
name|alpha_ecoff_mkobject_hook
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
name|filehdr
operator|,
name|PTR
name|aouthdr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|alpha_ecoff_swap_reloc_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
expr|struct
name|internal_reloc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|alpha_ecoff_swap_reloc_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
expr|struct
name|internal_reloc
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|alpha_adjust_reloc_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
expr|struct
name|internal_reloc
operator|*
operator|,
name|arelent
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|alpha_adjust_reloc_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|arelent
operator|*
operator|,
expr|struct
name|internal_reloc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
modifier|*
name|alpha_bfd_reloc_type_lookup
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd_reloc_code_real_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_byte
modifier|*
name|alpha_ecoff_get_relocated_section_contents
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|bfd_link_order
operator|*
operator|,
name|bfd_byte
operator|*
name|data
operator|,
name|boolean
name|relocateable
operator|,
name|asymbol
operator|*
operator|*
name|symbols
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|alpha_convert_external_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd
operator|*
operator|,
expr|struct
name|external_reloc
operator|*
operator|,
expr|struct
name|ecoff_link_hash_entry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|alpha_relocate_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|alpha_adjust_headers
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|internal_filehdr
operator|*
operator|,
expr|struct
name|internal_aouthdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|PTR
name|alpha_ecoff_read_ar_hdr
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd
modifier|*
name|alpha_ecoff_get_elt_at_filepos
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|file_ptr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd
modifier|*
name|alpha_ecoff_openr_next_archived_file
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd
modifier|*
name|alpha_ecoff_get_elt_at_index
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|symindex
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* ECOFF has COFF sections, but the debugging information is stored in    a completely different format.  ECOFF targets use some of the    swapping routines from coffswap.h, and some of the generic COFF    routines in coffgen.c, but, unlike the real COFF targets, do not    use coffcode.h itself.     Get the generic COFF swapping routines, except for the reloc,    symbol, and lineno ones.  Give them ecoff names.  Define some    accessor macros for the large sizes used for Alpha ECOFF.  */
end_comment

begin_define
define|#
directive|define
name|GET_FILEHDR_SYMPTR
value|bfd_h_get_64
end_define

begin_define
define|#
directive|define
name|PUT_FILEHDR_SYMPTR
value|bfd_h_put_64
end_define

begin_define
define|#
directive|define
name|GET_AOUTHDR_TSIZE
value|bfd_h_get_64
end_define

begin_define
define|#
directive|define
name|PUT_AOUTHDR_TSIZE
value|bfd_h_put_64
end_define

begin_define
define|#
directive|define
name|GET_AOUTHDR_DSIZE
value|bfd_h_get_64
end_define

begin_define
define|#
directive|define
name|PUT_AOUTHDR_DSIZE
value|bfd_h_put_64
end_define

begin_define
define|#
directive|define
name|GET_AOUTHDR_BSIZE
value|bfd_h_get_64
end_define

begin_define
define|#
directive|define
name|PUT_AOUTHDR_BSIZE
value|bfd_h_put_64
end_define

begin_define
define|#
directive|define
name|GET_AOUTHDR_ENTRY
value|bfd_h_get_64
end_define

begin_define
define|#
directive|define
name|PUT_AOUTHDR_ENTRY
value|bfd_h_put_64
end_define

begin_define
define|#
directive|define
name|GET_AOUTHDR_TEXT_START
value|bfd_h_get_64
end_define

begin_define
define|#
directive|define
name|PUT_AOUTHDR_TEXT_START
value|bfd_h_put_64
end_define

begin_define
define|#
directive|define
name|GET_AOUTHDR_DATA_START
value|bfd_h_get_64
end_define

begin_define
define|#
directive|define
name|PUT_AOUTHDR_DATA_START
value|bfd_h_put_64
end_define

begin_define
define|#
directive|define
name|GET_SCNHDR_PADDR
value|bfd_h_get_64
end_define

begin_define
define|#
directive|define
name|PUT_SCNHDR_PADDR
value|bfd_h_put_64
end_define

begin_define
define|#
directive|define
name|GET_SCNHDR_VADDR
value|bfd_h_get_64
end_define

begin_define
define|#
directive|define
name|PUT_SCNHDR_VADDR
value|bfd_h_put_64
end_define

begin_define
define|#
directive|define
name|GET_SCNHDR_SIZE
value|bfd_h_get_64
end_define

begin_define
define|#
directive|define
name|PUT_SCNHDR_SIZE
value|bfd_h_put_64
end_define

begin_define
define|#
directive|define
name|GET_SCNHDR_SCNPTR
value|bfd_h_get_64
end_define

begin_define
define|#
directive|define
name|PUT_SCNHDR_SCNPTR
value|bfd_h_put_64
end_define

begin_define
define|#
directive|define
name|GET_SCNHDR_RELPTR
value|bfd_h_get_64
end_define

begin_define
define|#
directive|define
name|PUT_SCNHDR_RELPTR
value|bfd_h_put_64
end_define

begin_define
define|#
directive|define
name|GET_SCNHDR_LNNOPTR
value|bfd_h_get_64
end_define

begin_define
define|#
directive|define
name|PUT_SCNHDR_LNNOPTR
value|bfd_h_put_64
end_define

begin_define
define|#
directive|define
name|ALPHAECOFF
end_define

begin_define
define|#
directive|define
name|NO_COFF_RELOCS
end_define

begin_define
define|#
directive|define
name|NO_COFF_SYMBOLS
end_define

begin_define
define|#
directive|define
name|NO_COFF_LINENOS
end_define

begin_define
define|#
directive|define
name|coff_swap_filehdr_in
value|alpha_ecoff_swap_filehdr_in
end_define

begin_define
define|#
directive|define
name|coff_swap_filehdr_out
value|alpha_ecoff_swap_filehdr_out
end_define

begin_define
define|#
directive|define
name|coff_swap_aouthdr_in
value|alpha_ecoff_swap_aouthdr_in
end_define

begin_define
define|#
directive|define
name|coff_swap_aouthdr_out
value|alpha_ecoff_swap_aouthdr_out
end_define

begin_define
define|#
directive|define
name|coff_swap_scnhdr_in
value|alpha_ecoff_swap_scnhdr_in
end_define

begin_define
define|#
directive|define
name|coff_swap_scnhdr_out
value|alpha_ecoff_swap_scnhdr_out
end_define

begin_include
include|#
directive|include
file|"coffswap.h"
end_include

begin_comment
comment|/* Get the ECOFF swapping routines.  */
end_comment

begin_define
define|#
directive|define
name|ECOFF_64
end_define

begin_include
include|#
directive|include
file|"ecoffswap.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* How to process the various reloc types.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|reloc_nil
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|bfd_reloc_status_type
name|reloc_nil
parameter_list|(
name|abfd
parameter_list|,
name|reloc
parameter_list|,
name|sym
parameter_list|,
name|data
parameter_list|,
name|sec
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|arelent
modifier|*
name|reloc
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asymbol
modifier|*
name|sym
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|PTR
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|sec
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_comment
comment|/* In case we're on a 32-bit machine, construct a 64-bit "-1" value    from smaller values.  Start with zero, widen, *then* decrement.  */
end_comment

begin_define
define|#
directive|define
name|MINUS_ONE
value|(((bfd_vma)0) - 1)
end_define

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|alpha_howto_table
index|[]
init|=
block|{
comment|/* Reloc type 0 is ignored by itself.  However, it appears after a      GPDISP reloc to identify the location where the low order 16 bits      of the gp register are loaded.  */
name|HOWTO
argument_list|(
name|ALPHA_R_IGNORE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|reloc_nil
argument_list|,
comment|/* special_function */
literal|"IGNORE"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 32 bit reference to a symbol.  */
name|HOWTO
argument_list|(
name|ALPHA_R_REFLONG
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"REFLONG"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 64 bit reference to a symbol.  */
name|HOWTO
argument_list|(
name|ALPHA_R_REFQUAD
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"REFQUAD"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
name|MINUS_ONE
argument_list|,
comment|/* src_mask */
name|MINUS_ONE
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 32 bit GP relative offset.  This is just like REFLONG except      that when the value is used the value of the gp register will be      added in.  */
name|HOWTO
argument_list|(
name|ALPHA_R_GPREL32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"GPREL32"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used for an instruction that refers to memory off the GP      register.  The offset is 16 bits of the 32 bit instruction.  This      reloc always seems to be against the .lita section.  */
name|HOWTO
argument_list|(
name|ALPHA_R_LITERAL
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"LITERAL"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* This reloc only appears immediately following a LITERAL reloc.      It identifies a use of the literal.  It seems that the linker can      use this to eliminate a portion of the .lita section.  The symbol      index is special: 1 means the literal address is in the base      register of a memory format instruction; 2 means the literal      address is in the byte offset register of a byte-manipulation      instruction; 3 means the literal address is in the target      register of a jsr instruction.  This does not actually do any      relocation.  */
name|HOWTO
argument_list|(
name|ALPHA_R_LITUSE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|reloc_nil
argument_list|,
comment|/* special_function */
literal|"LITUSE"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Load the gp register.  This is always used for a ldah instruction      which loads the upper 16 bits of the gp register.  The next reloc      will be an IGNORE reloc which identifies the location of the lda      instruction which loads the lower 16 bits.  The symbol index of      the GPDISP instruction appears to actually be the number of bytes      between the ldah and lda instructions.  This gives two different      ways to determine where the lda instruction is; I don't know why      both are used.  The value to use for the relocation is the      difference between the GP value and the current location; the      load will always be done against a register holding the current      address.  */
name|HOWTO
argument_list|(
name|ALPHA_R_GPDISP
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|reloc_nil
argument_list|,
comment|/* special_function */
literal|"GPDISP"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 21 bit branch.  The native assembler generates these for      branches within the text segment, and also fills in the PC      relative offset in the instruction.  */
name|HOWTO
argument_list|(
name|ALPHA_R_BRADDR
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|21
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"BRADDR"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0x1fffff
argument_list|,
comment|/* src_mask */
literal|0x1fffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A hint for a jump to a register.  */
name|HOWTO
argument_list|(
name|ALPHA_R_HINT
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|14
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"HINT"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0x3fff
argument_list|,
comment|/* src_mask */
literal|0x3fff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16 bit PC relative offset.  */
name|HOWTO
argument_list|(
name|ALPHA_R_SREL16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"SREL16"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 32 bit PC relative offset.  */
name|HOWTO
argument_list|(
name|ALPHA_R_SREL32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"SREL32"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 64 bit PC relative offset.  */
name|HOWTO
argument_list|(
name|ALPHA_R_SREL64
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"SREL64"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
name|MINUS_ONE
argument_list|,
comment|/* src_mask */
name|MINUS_ONE
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Push a value on the reloc evaluation stack.  */
name|HOWTO
argument_list|(
name|ALPHA_R_OP_PUSH
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"OP_PUSH"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Store the value from the stack at the given address.  Store it in      a bitfield of size r_size starting at bit position r_offset.  */
name|HOWTO
argument_list|(
name|ALPHA_R_OP_STORE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"OP_STORE"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
name|MINUS_ONE
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Subtract the reloc address from the value on the top of the      relocation stack.  */
name|HOWTO
argument_list|(
name|ALPHA_R_OP_PSUB
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"OP_PSUB"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Shift the value on the top of the relocation stack right by the      given value.  */
name|HOWTO
argument_list|(
name|ALPHA_R_OP_PRSHIFT
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"OP_PRSHIFT"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Adjust the GP value for a new range in the object file.  */
name|HOWTO
argument_list|(
argument|ALPHA_R_GPVALUE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
argument|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
argument|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"GPVALUE"
argument_list|,
comment|/* name */
argument|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
argument|false
argument_list|)
comment|/* pcrel_offset */
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Recognize an Alpha ECOFF file.  */
end_comment

begin_function
specifier|static
specifier|const
name|bfd_target
modifier|*
name|alpha_ecoff_object_p
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
specifier|static
specifier|const
name|bfd_target
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
name|coff_object_p
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|NULL
condition|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
comment|/* Alpha ECOFF has a .pdata section.  The lnnoptr field of the 	 .pdata section is the number of entries it contains.  Each 	 entry takes up 8 bytes.  The number of entries is required 	 since the section is aligned to a 16 byte boundary.  When we 	 link .pdata sections together, we do not want to include the 	 alignment bytes.  We handle this on input by faking the size 	 of the .pdata section to remove the unwanted alignment bytes. 	 On output we will set the lnnoptr field and force the 	 alignment.  */
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|_PDATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
block|{
name|bfd_size_type
name|size
decl_stmt|;
name|size
operator|=
name|sec
operator|->
name|line_filepos
operator|*
literal|8
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|size
operator|==
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|||
name|size
operator|+
literal|8
operator|==
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_size
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|size
argument_list|)
condition|)
return|return
name|NULL
return|;
block|}
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* See whether the magic number matches.  */
end_comment

begin_function
specifier|static
name|boolean
name|alpha_ecoff_bad_format_hook
parameter_list|(
name|abfd
parameter_list|,
name|filehdr
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|PTR
name|filehdr
decl_stmt|;
block|{
name|struct
name|internal_filehdr
modifier|*
name|internal_f
init|=
operator|(
expr|struct
name|internal_filehdr
operator|*
operator|)
name|filehdr
decl_stmt|;
if|if
condition|(
name|ALPHA_ECOFF_BADMAG
argument_list|(
operator|*
name|internal_f
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* This is a hook called by coff_real_object_p to create any backend    specific information.  */
end_comment

begin_function
specifier|static
name|PTR
name|alpha_ecoff_mkobject_hook
parameter_list|(
name|abfd
parameter_list|,
name|filehdr
parameter_list|,
name|aouthdr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|filehdr
decl_stmt|;
name|PTR
name|aouthdr
decl_stmt|;
block|{
name|PTR
name|ecoff
decl_stmt|;
name|ecoff
operator|=
name|_bfd_ecoff_mkobject_hook
argument_list|(
name|abfd
argument_list|,
name|filehdr
argument_list|,
name|aouthdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecoff
operator|!=
name|NULL
condition|)
block|{
name|struct
name|internal_filehdr
modifier|*
name|internal_f
init|=
operator|(
expr|struct
name|internal_filehdr
operator|*
operator|)
name|filehdr
decl_stmt|;
comment|/* Set additional BFD flags according to the object type from the 	 machine specific file header flags.  */
switch|switch
condition|(
name|internal_f
operator|->
name|f_flags
operator|&
name|F_ALPHA_OBJECT_TYPE_MASK
condition|)
block|{
case|case
name|F_ALPHA_SHARABLE
case|:
name|abfd
operator|->
name|flags
operator||=
name|DYNAMIC
expr_stmt|;
break|break;
case|case
name|F_ALPHA_CALL_SHARED
case|:
comment|/* Always executable if using shared libraries as the run time 	     loader might resolve undefined references.  */
name|abfd
operator|->
name|flags
operator||=
operator|(
name|DYNAMIC
operator||
name|EXEC_P
operator|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|ecoff
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Reloc handling.  */
end_comment

begin_comment
comment|/* Swap a reloc in.  */
end_comment

begin_function
specifier|static
name|void
name|alpha_ecoff_swap_reloc_in
parameter_list|(
name|abfd
parameter_list|,
name|ext_ptr
parameter_list|,
name|intern
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|ext_ptr
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|intern
decl_stmt|;
block|{
specifier|const
name|RELOC
modifier|*
name|ext
init|=
operator|(
name|RELOC
operator|*
operator|)
name|ext_ptr
decl_stmt|;
name|intern
operator|->
name|r_vaddr
operator|=
name|bfd_h_get_64
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|r_vaddr
argument_list|)
expr_stmt|;
name|intern
operator|->
name|r_symndx
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|r_symndx
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|bfd_header_little_endian
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|intern
operator|->
name|r_type
operator|=
operator|(
operator|(
name|ext
operator|->
name|r_bits
index|[
literal|0
index|]
operator|&
name|RELOC_BITS0_TYPE_LITTLE
operator|)
operator|>>
name|RELOC_BITS0_TYPE_SH_LITTLE
operator|)
expr_stmt|;
name|intern
operator|->
name|r_extern
operator|=
operator|(
name|ext
operator|->
name|r_bits
index|[
literal|1
index|]
operator|&
name|RELOC_BITS1_EXTERN_LITTLE
operator|)
operator|!=
literal|0
expr_stmt|;
name|intern
operator|->
name|r_offset
operator|=
operator|(
operator|(
name|ext
operator|->
name|r_bits
index|[
literal|1
index|]
operator|&
name|RELOC_BITS1_OFFSET_LITTLE
operator|)
operator|>>
name|RELOC_BITS1_OFFSET_SH_LITTLE
operator|)
expr_stmt|;
comment|/* Ignored the reserved bits.  */
name|intern
operator|->
name|r_size
operator|=
operator|(
operator|(
name|ext
operator|->
name|r_bits
index|[
literal|3
index|]
operator|&
name|RELOC_BITS3_SIZE_LITTLE
operator|)
operator|>>
name|RELOC_BITS3_SIZE_SH_LITTLE
operator|)
expr_stmt|;
if|if
condition|(
name|intern
operator|->
name|r_type
operator|==
name|ALPHA_R_LITUSE
operator|||
name|intern
operator|->
name|r_type
operator|==
name|ALPHA_R_GPDISP
condition|)
block|{
comment|/* Handle the LITUSE and GPDISP relocs specially.  Its symndx 	 value is not actually a symbol index, but is instead a 	 special code.  We put the code in the r_size field, and 	 clobber the symndx.  */
if|if
condition|(
name|intern
operator|->
name|r_size
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|intern
operator|->
name|r_size
operator|=
name|intern
operator|->
name|r_symndx
expr_stmt|;
name|intern
operator|->
name|r_symndx
operator|=
name|RELOC_SECTION_NONE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|intern
operator|->
name|r_type
operator|==
name|ALPHA_R_IGNORE
condition|)
block|{
comment|/* The IGNORE reloc generally follows a GPDISP reloc, and is 	 against the .lita section.  The section is irrelevant.  */
if|if
condition|(
operator|!
name|intern
operator|->
name|r_extern
operator|&&
name|intern
operator|->
name|r_symndx
operator|==
name|RELOC_SECTION_ABS
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|intern
operator|->
name|r_extern
operator|&&
name|intern
operator|->
name|r_symndx
operator|==
name|RELOC_SECTION_LITA
condition|)
name|intern
operator|->
name|r_symndx
operator|=
name|RELOC_SECTION_ABS
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Swap a reloc out.  */
end_comment

begin_function
specifier|static
name|void
name|alpha_ecoff_swap_reloc_out
parameter_list|(
name|abfd
parameter_list|,
name|intern
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|struct
name|internal_reloc
modifier|*
name|intern
decl_stmt|;
name|PTR
name|dst
decl_stmt|;
block|{
name|RELOC
modifier|*
name|ext
init|=
operator|(
name|RELOC
operator|*
operator|)
name|dst
decl_stmt|;
name|long
name|symndx
decl_stmt|;
name|unsigned
name|char
name|size
decl_stmt|;
comment|/* Undo the hackery done in swap_reloc_in.  */
if|if
condition|(
name|intern
operator|->
name|r_type
operator|==
name|ALPHA_R_LITUSE
operator|||
name|intern
operator|->
name|r_type
operator|==
name|ALPHA_R_GPDISP
condition|)
block|{
name|symndx
operator|=
name|intern
operator|->
name|r_size
expr_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|intern
operator|->
name|r_type
operator|==
name|ALPHA_R_IGNORE
operator|&&
operator|!
name|intern
operator|->
name|r_extern
operator|&&
name|intern
operator|->
name|r_symndx
operator|==
name|RELOC_SECTION_ABS
condition|)
block|{
name|symndx
operator|=
name|RELOC_SECTION_LITA
expr_stmt|;
name|size
operator|=
name|intern
operator|->
name|r_size
expr_stmt|;
block|}
else|else
block|{
name|symndx
operator|=
name|intern
operator|->
name|r_symndx
expr_stmt|;
name|size
operator|=
name|intern
operator|->
name|r_size
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
name|intern
operator|->
name|r_extern
operator|||
operator|(
name|intern
operator|->
name|r_symndx
operator|>=
literal|0
operator|&&
name|intern
operator|->
name|r_symndx
operator|<=
literal|14
operator|)
argument_list|)
expr_stmt|;
name|bfd_h_put_64
argument_list|(
name|abfd
argument_list|,
name|intern
operator|->
name|r_vaddr
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|r_vaddr
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|symndx
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|r_symndx
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|bfd_header_little_endian
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|ext
operator|->
name|r_bits
index|[
literal|0
index|]
operator|=
operator|(
operator|(
name|intern
operator|->
name|r_type
operator|<<
name|RELOC_BITS0_TYPE_SH_LITTLE
operator|)
operator|&
name|RELOC_BITS0_TYPE_LITTLE
operator|)
expr_stmt|;
name|ext
operator|->
name|r_bits
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|intern
operator|->
name|r_extern
condition|?
name|RELOC_BITS1_EXTERN_LITTLE
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|intern
operator|->
name|r_offset
operator|<<
name|RELOC_BITS1_OFFSET_SH_LITTLE
operator|)
operator|&
name|RELOC_BITS1_OFFSET_LITTLE
operator|)
operator|)
expr_stmt|;
name|ext
operator|->
name|r_bits
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|ext
operator|->
name|r_bits
index|[
literal|3
index|]
operator|=
operator|(
operator|(
name|size
operator|<<
name|RELOC_BITS3_SIZE_SH_LITTLE
operator|)
operator|&
name|RELOC_BITS3_SIZE_LITTLE
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish canonicalizing a reloc.  Part of this is generic to all    ECOFF targets, and that part is in ecoff.c.  The rest is done in    this backend routine.  It must fill in the howto field.  */
end_comment

begin_function
specifier|static
name|void
name|alpha_adjust_reloc_in
parameter_list|(
name|abfd
parameter_list|,
name|intern
parameter_list|,
name|rptr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|struct
name|internal_reloc
modifier|*
name|intern
decl_stmt|;
name|arelent
modifier|*
name|rptr
decl_stmt|;
block|{
if|if
condition|(
name|intern
operator|->
name|r_type
operator|>
name|ALPHA_R_GPVALUE
condition|)
name|abort
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|intern
operator|->
name|r_type
condition|)
block|{
case|case
name|ALPHA_R_BRADDR
case|:
case|case
name|ALPHA_R_SREL16
case|:
case|case
name|ALPHA_R_SREL32
case|:
case|case
name|ALPHA_R_SREL64
case|:
comment|/* This relocs appear to be fully resolved when they are against          internal symbols.  Against external symbols, BRADDR at least          appears to be resolved against the next instruction.  */
if|if
condition|(
operator|!
name|intern
operator|->
name|r_extern
condition|)
name|rptr
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
else|else
name|rptr
operator|->
name|addend
operator|=
operator|-
operator|(
name|intern
operator|->
name|r_vaddr
operator|+
literal|4
operator|)
expr_stmt|;
break|break;
case|case
name|ALPHA_R_GPREL32
case|:
case|case
name|ALPHA_R_LITERAL
case|:
comment|/* Copy the gp value for this object file into the addend, to 	 ensure that we are not confused by the linker.  */
if|if
condition|(
operator|!
name|intern
operator|->
name|r_extern
condition|)
name|rptr
operator|->
name|addend
operator|+=
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|gp
expr_stmt|;
break|break;
case|case
name|ALPHA_R_LITUSE
case|:
case|case
name|ALPHA_R_GPDISP
case|:
comment|/* The LITUSE and GPDISP relocs do not use a symbol, or an 	 addend, but they do use a special code.  Put this code in the 	 addend field.  */
name|rptr
operator|->
name|addend
operator|=
name|intern
operator|->
name|r_size
expr_stmt|;
break|break;
case|case
name|ALPHA_R_OP_STORE
case|:
comment|/* The STORE reloc needs the size and offset fields.  We store 	 them in the addend.  */
name|BFD_ASSERT
argument_list|(
name|intern
operator|->
name|r_offset
operator|<=
literal|256
operator|&&
name|intern
operator|->
name|r_size
operator|<=
literal|256
argument_list|)
expr_stmt|;
name|rptr
operator|->
name|addend
operator|=
operator|(
name|intern
operator|->
name|r_offset
operator|<<
literal|8
operator|)
operator|+
name|intern
operator|->
name|r_size
expr_stmt|;
break|break;
case|case
name|ALPHA_R_OP_PUSH
case|:
case|case
name|ALPHA_R_OP_PSUB
case|:
case|case
name|ALPHA_R_OP_PRSHIFT
case|:
comment|/* The PUSH, PSUB and PRSHIFT relocs do not actually use an 	 address.  I believe that the address supplied is really an 	 addend.  */
name|rptr
operator|->
name|addend
operator|=
name|intern
operator|->
name|r_vaddr
expr_stmt|;
break|break;
case|case
name|ALPHA_R_GPVALUE
case|:
comment|/* Set the addend field to the new GP value.  */
name|rptr
operator|->
name|addend
operator|=
name|intern
operator|->
name|r_symndx
operator|+
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|gp
expr_stmt|;
break|break;
case|case
name|ALPHA_R_IGNORE
case|:
comment|/* If the type is ALPHA_R_IGNORE, make sure this is a reference 	 to the absolute section so that the reloc is ignored.  For 	 some reason the address of this reloc type is not adjusted by 	 the section vma.  We record the gp value for this object file 	 here, for convenience when doing the GPDISP relocation.  */
name|rptr
operator|->
name|sym_ptr_ptr
operator|=
name|bfd_abs_section_ptr
operator|->
name|symbol_ptr_ptr
expr_stmt|;
name|rptr
operator|->
name|address
operator|=
name|intern
operator|->
name|r_vaddr
expr_stmt|;
name|rptr
operator|->
name|addend
operator|=
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|gp
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|rptr
operator|->
name|howto
operator|=
operator|&
name|alpha_howto_table
index|[
name|intern
operator|->
name|r_type
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* When writing out a reloc we need to pull some values back out of    the addend field into the reloc.  This is roughly the reverse of    alpha_adjust_reloc_in, except that there are several changes we do    not need to undo.  */
end_comment

begin_function
specifier|static
name|void
name|alpha_adjust_reloc_out
parameter_list|(
name|abfd
parameter_list|,
name|rel
parameter_list|,
name|intern
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|arelent
modifier|*
name|rel
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|intern
decl_stmt|;
block|{
switch|switch
condition|(
name|intern
operator|->
name|r_type
condition|)
block|{
case|case
name|ALPHA_R_LITUSE
case|:
case|case
name|ALPHA_R_GPDISP
case|:
name|intern
operator|->
name|r_size
operator|=
name|rel
operator|->
name|addend
expr_stmt|;
break|break;
case|case
name|ALPHA_R_OP_STORE
case|:
name|intern
operator|->
name|r_size
operator|=
name|rel
operator|->
name|addend
operator|&
literal|0xff
expr_stmt|;
name|intern
operator|->
name|r_offset
operator|=
operator|(
name|rel
operator|->
name|addend
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
break|break;
case|case
name|ALPHA_R_OP_PUSH
case|:
case|case
name|ALPHA_R_OP_PSUB
case|:
case|case
name|ALPHA_R_OP_PRSHIFT
case|:
name|intern
operator|->
name|r_vaddr
operator|=
name|rel
operator|->
name|addend
expr_stmt|;
break|break;
case|case
name|ALPHA_R_IGNORE
case|:
name|intern
operator|->
name|r_vaddr
operator|=
name|rel
operator|->
name|address
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* The size of the stack for the relocation evaluator.  */
end_comment

begin_define
define|#
directive|define
name|RELOC_STACKSIZE
value|(10)
end_define

begin_comment
comment|/* Alpha ECOFF relocs have a built in expression evaluator as well as    other interdependencies.  Rather than use a bunch of special    functions and global variables, we use a single routine to do all    the relocation for a section.  I haven't yet worked out how the    assembler is going to handle this.  */
end_comment

begin_function
specifier|static
name|bfd_byte
modifier|*
name|alpha_ecoff_get_relocated_section_contents
parameter_list|(
name|abfd
parameter_list|,
name|link_info
parameter_list|,
name|link_order
parameter_list|,
name|data
parameter_list|,
name|relocateable
parameter_list|,
name|symbols
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|link_info
decl_stmt|;
name|struct
name|bfd_link_order
modifier|*
name|link_order
decl_stmt|;
name|bfd_byte
modifier|*
name|data
decl_stmt|;
name|boolean
name|relocateable
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
block|{
name|bfd
modifier|*
name|input_bfd
init|=
name|link_order
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
operator|->
name|owner
decl_stmt|;
name|asection
modifier|*
name|input_section
init|=
name|link_order
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
decl_stmt|;
name|long
name|reloc_size
init|=
name|bfd_get_reloc_upper_bound
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|reloc_vector
init|=
name|NULL
decl_stmt|;
name|long
name|reloc_count
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
init|=
name|relocateable
condition|?
name|abfd
else|:
operator|(
name|bfd
operator|*
operator|)
name|NULL
decl_stmt|;
name|bfd_vma
name|gp
decl_stmt|;
name|boolean
name|gp_undefined
decl_stmt|;
name|bfd_vma
name|stack
index|[
name|RELOC_STACKSIZE
index|]
decl_stmt|;
name|int
name|tos
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|reloc_size
operator|<
literal|0
condition|)
goto|goto
name|error_return
goto|;
name|reloc_vector
operator|=
operator|(
name|arelent
operator|*
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|reloc_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc_vector
operator|==
name|NULL
operator|&&
name|reloc_size
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|data
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|input_section
operator|->
name|_raw_size
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* The section size is not going to change.  */
name|input_section
operator|->
name|_cooked_size
operator|=
name|input_section
operator|->
name|_raw_size
expr_stmt|;
name|input_section
operator|->
name|reloc_done
operator|=
name|true
expr_stmt|;
name|reloc_count
operator|=
name|bfd_canonicalize_reloc
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|reloc_vector
argument_list|,
name|symbols
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc_count
operator|<
literal|0
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|reloc_count
operator|==
literal|0
condition|)
goto|goto
name|successful_return
goto|;
comment|/* Get the GP value for the output BFD.  */
name|gp_undefined
operator|=
name|false
expr_stmt|;
name|gp
operator|=
name|_bfd_get_gp_value
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|gp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|relocateable
operator|!=
name|false
condition|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_vma
name|lo
decl_stmt|;
comment|/* Make up a value.  */
name|lo
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|sec
operator|=
name|abfd
operator|->
name|sections
init|;
name|sec
operator|!=
name|NULL
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
block|{
if|if
condition|(
name|sec
operator|->
name|vma
operator|<
name|lo
operator|&&
operator|(
name|strcmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
literal|".sbss"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
literal|".sdata"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
literal|".lit4"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
literal|".lit8"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
literal|".lita"
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|lo
operator|=
name|sec
operator|->
name|vma
expr_stmt|;
block|}
name|gp
operator|=
name|lo
operator|+
literal|0x8000
expr_stmt|;
name|_bfd_set_gp_value
argument_list|(
name|abfd
argument_list|,
name|gp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|link_info
operator|->
name|hash
argument_list|,
literal|"_gp"
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|)
name|NULL
operator|||
name|h
operator|->
name|type
operator|!=
name|bfd_link_hash_defined
condition|)
name|gp_undefined
operator|=
name|true
expr_stmt|;
else|else
block|{
name|gp
operator|=
operator|(
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|_bfd_set_gp_value
argument_list|(
name|abfd
argument_list|,
name|gp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
init|;
operator|*
name|reloc_vector
operator|!=
operator|(
name|arelent
operator|*
operator|)
name|NULL
condition|;
name|reloc_vector
operator|++
control|)
block|{
name|arelent
modifier|*
name|rel
decl_stmt|;
name|bfd_reloc_status_type
name|r
decl_stmt|;
name|char
modifier|*
name|err
decl_stmt|;
name|rel
operator|=
operator|*
name|reloc_vector
expr_stmt|;
name|r
operator|=
name|bfd_reloc_ok
expr_stmt|;
switch|switch
condition|(
name|rel
operator|->
name|howto
operator|->
name|type
condition|)
block|{
case|case
name|ALPHA_R_IGNORE
case|:
name|rel
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
break|break;
case|case
name|ALPHA_R_REFLONG
case|:
case|case
name|ALPHA_R_REFQUAD
case|:
case|case
name|ALPHA_R_BRADDR
case|:
case|case
name|ALPHA_R_HINT
case|:
case|case
name|ALPHA_R_SREL16
case|:
case|case
name|ALPHA_R_SREL32
case|:
case|case
name|ALPHA_R_SREL64
case|:
if|if
condition|(
name|relocateable
operator|&&
operator|(
operator|(
operator|*
name|rel
operator|->
name|sym_ptr_ptr
operator|)
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|==
literal|0
condition|)
block|{
name|rel
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
break|break;
block|}
name|r
operator|=
name|bfd_perform_relocation
argument_list|(
name|input_bfd
argument_list|,
name|rel
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
operator|&
name|err
argument_list|)
expr_stmt|;
break|break;
case|case
name|ALPHA_R_GPREL32
case|:
comment|/* This relocation is used in a switch table.  It is a 32 	     bit offset from the current GP value.  We must adjust it 	     by the different between the original GP value and the 	     current GP value.  The original GP value is stored in the 	     addend.  We adjust the addend and let 	     bfd_perform_relocation finish the job.  */
name|rel
operator|->
name|addend
operator|-=
name|gp
expr_stmt|;
name|r
operator|=
name|bfd_perform_relocation
argument_list|(
name|input_bfd
argument_list|,
name|rel
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
operator|&
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|bfd_reloc_ok
operator|&&
name|gp_undefined
condition|)
block|{
name|r
operator|=
name|bfd_reloc_dangerous
expr_stmt|;
name|err
operator|=
operator|(
name|char
operator|*
operator|)
name|_
argument_list|(
literal|"GP relative relocation used when GP not defined"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ALPHA_R_LITERAL
case|:
comment|/* This is a reference to a literal value, generally 	     (always?) in the .lita section.  This is a 16 bit GP 	     relative relocation.  Sometimes the subsequent reloc is a 	     LITUSE reloc, which indicates how this reloc is used. 	     This sometimes permits rewriting the two instructions 	     referred to by the LITERAL and the LITUSE into different 	     instructions which do not refer to .lita.  This can save 	     a memory reference, and permits removing a value from 	     .lita thus saving GP relative space.  	     We do not these optimizations.  To do them we would need 	     to arrange to link the .lita section first, so that by 	     the time we got here we would know the final values to 	     use.  This would not be particularly difficult, but it is 	     not currently implemented.  */
block|{
name|unsigned
name|long
name|insn
decl_stmt|;
comment|/* I believe that the LITERAL reloc will only apply to a 	       ldq or ldl instruction, so check my assumption.  */
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|data
operator|+
name|rel
operator|->
name|address
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
operator|(
operator|(
name|insn
operator|>>
literal|26
operator|)
operator|&
literal|0x3f
operator|)
operator|==
literal|0x29
operator|||
operator|(
operator|(
name|insn
operator|>>
literal|26
operator|)
operator|&
literal|0x3f
operator|)
operator|==
literal|0x28
argument_list|)
expr_stmt|;
name|rel
operator|->
name|addend
operator|-=
name|gp
expr_stmt|;
name|r
operator|=
name|bfd_perform_relocation
argument_list|(
name|input_bfd
argument_list|,
name|rel
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
operator|&
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|bfd_reloc_ok
operator|&&
name|gp_undefined
condition|)
block|{
name|r
operator|=
name|bfd_reloc_dangerous
expr_stmt|;
name|err
operator|=
operator|(
name|char
operator|*
operator|)
name|_
argument_list|(
literal|"GP relative relocation used when GP not defined"
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|ALPHA_R_LITUSE
case|:
comment|/* See ALPHA_R_LITERAL above for the uses of this reloc.  It 	     does not cause anything to happen, itself.  */
name|rel
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
break|break;
case|case
name|ALPHA_R_GPDISP
case|:
comment|/* This marks the ldah of an ldah/lda pair which loads the 	     gp register with the difference of the gp value and the 	     current location.  The second of the pair is r_size bytes 	     ahead; it used to be marked with an ALPHA_R_IGNORE reloc, 	     but that no longer happens in OSF/1 3.2.  */
block|{
name|unsigned
name|long
name|insn1
decl_stmt|,
name|insn2
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|;
comment|/* Get the two instructions.  */
name|insn1
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|data
operator|+
name|rel
operator|->
name|address
argument_list|)
expr_stmt|;
name|insn2
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|data
operator|+
name|rel
operator|->
name|address
operator|+
name|rel
operator|->
name|addend
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
operator|(
operator|(
name|insn1
operator|>>
literal|26
operator|)
operator|&
literal|0x3f
operator|)
operator|==
literal|0x09
argument_list|)
expr_stmt|;
comment|/* ldah */
name|BFD_ASSERT
argument_list|(
operator|(
operator|(
name|insn2
operator|>>
literal|26
operator|)
operator|&
literal|0x3f
operator|)
operator|==
literal|0x08
argument_list|)
expr_stmt|;
comment|/* lda */
comment|/* Get the existing addend.  We must account for the sign 	       extension done by lda and ldah.  */
name|addend
operator|=
operator|(
operator|(
name|insn1
operator|&
literal|0xffff
operator|)
operator|<<
literal|16
operator|)
operator|+
operator|(
name|insn2
operator|&
literal|0xffff
operator|)
expr_stmt|;
if|if
condition|(
name|insn1
operator|&
literal|0x8000
condition|)
block|{
name|addend
operator|-=
literal|0x80000000
expr_stmt|;
name|addend
operator|-=
literal|0x80000000
expr_stmt|;
block|}
if|if
condition|(
name|insn2
operator|&
literal|0x8000
condition|)
name|addend
operator|-=
literal|0x10000
expr_stmt|;
comment|/* The existing addend includes the different between the 	       gp of the input BFD and the address in the input BFD. 	       Subtract this out.  */
name|addend
operator|-=
operator|(
name|ecoff_data
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|gp
operator|-
operator|(
name|input_section
operator|->
name|vma
operator|+
name|rel
operator|->
name|address
operator|)
operator|)
expr_stmt|;
comment|/* Now add in the final gp value, and subtract out the 	       final address.  */
name|addend
operator|+=
operator|(
name|gp
operator|-
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|rel
operator|->
name|address
operator|)
operator|)
expr_stmt|;
comment|/* Change the instructions, accounting for the sign 	       extension, and write them out.  */
if|if
condition|(
name|addend
operator|&
literal|0x8000
condition|)
name|addend
operator|+=
literal|0x10000
expr_stmt|;
name|insn1
operator|=
operator|(
name|insn1
operator|&
literal|0xffff0000
operator|)
operator||
operator|(
operator|(
name|addend
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|insn2
operator|=
operator|(
name|insn2
operator|&
literal|0xffff0000
operator|)
operator||
operator|(
name|addend
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|insn1
argument_list|,
name|data
operator|+
name|rel
operator|->
name|address
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|insn2
argument_list|,
name|data
operator|+
name|rel
operator|->
name|address
operator|+
name|rel
operator|->
name|addend
argument_list|)
expr_stmt|;
name|rel
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
block|}
break|break;
case|case
name|ALPHA_R_OP_PUSH
case|:
comment|/* Push a value on the reloc evaluation stack.  */
block|{
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
if|if
condition|(
name|relocateable
condition|)
block|{
name|rel
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
break|break;
block|}
comment|/* Figure out the relocation of this symbol.  */
name|symbol
operator|=
operator|*
name|rel
operator|->
name|sym_ptr_ptr
expr_stmt|;
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
name|r
operator|=
name|bfd_reloc_undefined
expr_stmt|;
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
else|else
name|relocation
operator|=
name|symbol
operator|->
name|value
expr_stmt|;
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
name|relocation
operator|+=
name|rel
operator|->
name|addend
expr_stmt|;
if|if
condition|(
name|tos
operator|>=
name|RELOC_STACKSIZE
condition|)
name|abort
argument_list|()
expr_stmt|;
name|stack
index|[
name|tos
operator|++
index|]
operator|=
name|relocation
expr_stmt|;
block|}
break|break;
case|case
name|ALPHA_R_OP_STORE
case|:
comment|/* Store a value from the reloc stack into a bitfield.  */
block|{
name|bfd_vma
name|val
decl_stmt|;
name|int
name|offset
decl_stmt|,
name|size
decl_stmt|;
if|if
condition|(
name|relocateable
condition|)
block|{
name|rel
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|tos
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* The offset and size for this reloc are encoded into the 	       addend field by alpha_adjust_reloc_in.  */
name|offset
operator|=
operator|(
name|rel
operator|->
name|addend
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|size
operator|=
name|rel
operator|->
name|addend
operator|&
literal|0xff
expr_stmt|;
name|val
operator|=
name|bfd_get_64
argument_list|(
name|abfd
argument_list|,
name|data
operator|+
name|rel
operator|->
name|address
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
operator|(
operator|(
operator|(
literal|1
operator|<<
name|size
operator|)
operator|-
literal|1
operator|)
operator|<<
name|offset
operator|)
expr_stmt|;
name|val
operator||=
operator|(
name|stack
index|[
operator|--
name|tos
index|]
operator|&
operator|(
operator|(
literal|1
operator|<<
name|size
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
name|offset
expr_stmt|;
name|bfd_put_64
argument_list|(
name|abfd
argument_list|,
name|val
argument_list|,
name|data
operator|+
name|rel
operator|->
name|address
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ALPHA_R_OP_PSUB
case|:
comment|/* Subtract a value from the top of the stack.  */
block|{
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
if|if
condition|(
name|relocateable
condition|)
block|{
name|rel
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
break|break;
block|}
comment|/* Figure out the relocation of this symbol.  */
name|symbol
operator|=
operator|*
name|rel
operator|->
name|sym_ptr_ptr
expr_stmt|;
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
name|r
operator|=
name|bfd_reloc_undefined
expr_stmt|;
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
else|else
name|relocation
operator|=
name|symbol
operator|->
name|value
expr_stmt|;
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
name|relocation
operator|+=
name|rel
operator|->
name|addend
expr_stmt|;
if|if
condition|(
name|tos
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|stack
index|[
name|tos
operator|-
literal|1
index|]
operator|-=
name|relocation
expr_stmt|;
block|}
break|break;
case|case
name|ALPHA_R_OP_PRSHIFT
case|:
comment|/* Shift the value on the top of the stack.  */
block|{
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
if|if
condition|(
name|relocateable
condition|)
block|{
name|rel
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
break|break;
block|}
comment|/* Figure out the relocation of this symbol.  */
name|symbol
operator|=
operator|*
name|rel
operator|->
name|sym_ptr_ptr
expr_stmt|;
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
name|r
operator|=
name|bfd_reloc_undefined
expr_stmt|;
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
else|else
name|relocation
operator|=
name|symbol
operator|->
name|value
expr_stmt|;
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
name|relocation
operator|+=
name|rel
operator|->
name|addend
expr_stmt|;
if|if
condition|(
name|tos
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|stack
index|[
name|tos
operator|-
literal|1
index|]
operator|>>=
name|relocation
expr_stmt|;
block|}
break|break;
case|case
name|ALPHA_R_GPVALUE
case|:
comment|/* I really don't know if this does the right thing.  */
name|gp
operator|=
name|rel
operator|->
name|addend
expr_stmt|;
name|gp_undefined
operator|=
name|false
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|relocateable
condition|)
block|{
name|asection
modifier|*
name|os
init|=
name|input_section
operator|->
name|output_section
decl_stmt|;
comment|/* A partial link, so keep the relocs.  */
name|os
operator|->
name|orelocation
index|[
name|os
operator|->
name|reloc_count
index|]
operator|=
name|rel
expr_stmt|;
name|os
operator|->
name|reloc_count
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|!=
name|bfd_reloc_ok
condition|)
block|{
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|bfd_reloc_undefined
case|:
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|link_info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|link_info
argument_list|,
name|bfd_asymbol_name
argument_list|(
operator|*
name|rel
operator|->
name|sym_ptr_ptr
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|address
argument_list|,
name|true
argument_list|)
operator|)
condition|)
goto|goto
name|error_return
goto|;
break|break;
case|case
name|bfd_reloc_dangerous
case|:
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|link_info
operator|->
name|callbacks
operator|->
name|reloc_dangerous
call|)
argument_list|(
name|link_info
argument_list|,
name|err
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|address
argument_list|)
operator|)
condition|)
goto|goto
name|error_return
goto|;
break|break;
case|case
name|bfd_reloc_overflow
case|:
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|link_info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|link_info
argument_list|,
name|bfd_asymbol_name
argument_list|(
operator|*
name|rel
operator|->
name|sym_ptr_ptr
argument_list|)
argument_list|,
name|rel
operator|->
name|howto
operator|->
name|name
argument_list|,
name|rel
operator|->
name|addend
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|address
argument_list|)
operator|)
condition|)
goto|goto
name|error_return
goto|;
break|break;
case|case
name|bfd_reloc_outofrange
case|:
default|default:
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|tos
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|successful_return
label|:
if|if
condition|(
name|reloc_vector
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|reloc_vector
argument_list|)
expr_stmt|;
return|return
name|data
return|;
name|error_return
label|:
if|if
condition|(
name|reloc_vector
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|reloc_vector
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Get the howto structure for a generic reloc type.  */
end_comment

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|alpha_bfd_reloc_type_lookup
parameter_list|(
name|abfd
parameter_list|,
name|code
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
block|{
name|int
name|alpha_type
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|BFD_RELOC_32
case|:
name|alpha_type
operator|=
name|ALPHA_R_REFLONG
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_64
case|:
case|case
name|BFD_RELOC_CTOR
case|:
name|alpha_type
operator|=
name|ALPHA_R_REFQUAD
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_GPREL32
case|:
name|alpha_type
operator|=
name|ALPHA_R_GPREL32
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ALPHA_LITERAL
case|:
name|alpha_type
operator|=
name|ALPHA_R_LITERAL
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ALPHA_LITUSE
case|:
name|alpha_type
operator|=
name|ALPHA_R_LITUSE
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ALPHA_GPDISP_HI16
case|:
name|alpha_type
operator|=
name|ALPHA_R_GPDISP
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ALPHA_GPDISP_LO16
case|:
name|alpha_type
operator|=
name|ALPHA_R_IGNORE
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_23_PCREL_S2
case|:
name|alpha_type
operator|=
name|ALPHA_R_BRADDR
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ALPHA_HINT
case|:
name|alpha_type
operator|=
name|ALPHA_R_HINT
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_16_PCREL
case|:
name|alpha_type
operator|=
name|ALPHA_R_SREL16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32_PCREL
case|:
name|alpha_type
operator|=
name|ALPHA_R_SREL32
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_64_PCREL
case|:
name|alpha_type
operator|=
name|ALPHA_R_SREL64
expr_stmt|;
break|break;
if|#
directive|if
literal|0
block|case ???:       alpha_type = ALPHA_R_OP_PUSH;       break;     case ???:       alpha_type = ALPHA_R_OP_STORE;       break;     case ???:       alpha_type = ALPHA_R_OP_PSUB;       break;     case ???:       alpha_type = ALPHA_R_OP_PRSHIFT;       break;     case ???:       alpha_type = ALPHA_R_GPVALUE;       break;
endif|#
directive|endif
default|default:
return|return
operator|(
name|reloc_howto_type
operator|*
operator|)
name|NULL
return|;
block|}
return|return
operator|&
name|alpha_howto_table
index|[
name|alpha_type
index|]
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A helper routine for alpha_relocate_section which converts an    external reloc when generating relocateable output.  Returns the    relocation amount.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|alpha_convert_external_reloc
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|input_bfd
parameter_list|,
name|ext_rel
parameter_list|,
name|h
parameter_list|)
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|struct
name|external_reloc
modifier|*
name|ext_rel
decl_stmt|;
name|struct
name|ecoff_link_hash_entry
modifier|*
name|h
decl_stmt|;
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|info
operator|->
name|relocateable
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
block|{
name|asection
modifier|*
name|hsec
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* This symbol is defined in the output.  Convert the reloc from 	 being against the symbol to being against the section.  */
comment|/* Clear the r_extern bit.  */
name|ext_rel
operator|->
name|r_bits
index|[
literal|1
index|]
operator|&=
operator|~
name|RELOC_BITS1_EXTERN_LITTLE
expr_stmt|;
comment|/* Compute a new r_symndx value.  */
name|hsec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|output_bfd
argument_list|,
name|hsec
operator|->
name|output_section
argument_list|)
expr_stmt|;
name|r_symndx
operator|=
operator|-
literal|1
expr_stmt|;
switch|switch
condition|(
name|name
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'A'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"*ABS*"
argument_list|)
operator|==
literal|0
condition|)
name|r_symndx
operator|=
name|RELOC_SECTION_ABS
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".bss"
argument_list|)
operator|==
literal|0
condition|)
name|r_symndx
operator|=
name|RELOC_SECTION_BSS
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".data"
argument_list|)
operator|==
literal|0
condition|)
name|r_symndx
operator|=
name|RELOC_SECTION_DATA
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".fini"
argument_list|)
operator|==
literal|0
condition|)
name|r_symndx
operator|=
name|RELOC_SECTION_FINI
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".init"
argument_list|)
operator|==
literal|0
condition|)
name|r_symndx
operator|=
name|RELOC_SECTION_INIT
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".lita"
argument_list|)
operator|==
literal|0
condition|)
name|r_symndx
operator|=
name|RELOC_SECTION_LITA
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".lit8"
argument_list|)
operator|==
literal|0
condition|)
name|r_symndx
operator|=
name|RELOC_SECTION_LIT8
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".lit4"
argument_list|)
operator|==
literal|0
condition|)
name|r_symndx
operator|=
name|RELOC_SECTION_LIT4
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".pdata"
argument_list|)
operator|==
literal|0
condition|)
name|r_symndx
operator|=
name|RELOC_SECTION_PDATA
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".rdata"
argument_list|)
operator|==
literal|0
condition|)
name|r_symndx
operator|=
name|RELOC_SECTION_RDATA
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".rconst"
argument_list|)
operator|==
literal|0
condition|)
name|r_symndx
operator|=
name|RELOC_SECTION_RCONST
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sdata"
argument_list|)
operator|==
literal|0
condition|)
name|r_symndx
operator|=
name|RELOC_SECTION_SDATA
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sbss"
argument_list|)
operator|==
literal|0
condition|)
name|r_symndx
operator|=
name|RELOC_SECTION_SBSS
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".text"
argument_list|)
operator|==
literal|0
condition|)
name|r_symndx
operator|=
name|RELOC_SECTION_TEXT
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".xdata"
argument_list|)
operator|==
literal|0
condition|)
name|r_symndx
operator|=
name|RELOC_SECTION_XDATA
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|r_symndx
operator|==
operator|-
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Add the section VMA and the symbol value.  */
name|relocation
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|hsec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|hsec
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Change the symndx value to the right one for 	 the output BFD.  */
name|r_symndx
operator|=
name|h
operator|->
name|indx
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* Caller must give an error.  */
name|r_symndx
operator|=
literal|0
expr_stmt|;
block|}
name|relocation
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Write out the new r_symndx value.  */
name|bfd_h_put_32
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|r_symndx
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext_rel
operator|->
name|r_symndx
argument_list|)
expr_stmt|;
return|return
name|relocation
return|;
block|}
end_function

begin_comment
comment|/* Relocate a section while linking an Alpha ECOFF file.  This is    quite similar to get_relocated_section_contents.  Perhaps they    could be combined somehow.  */
end_comment

begin_function
specifier|static
name|boolean
name|alpha_relocate_section
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|contents
parameter_list|,
name|external_relocs
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|PTR
name|external_relocs
decl_stmt|;
block|{
name|asection
modifier|*
modifier|*
name|symndx_to_section
decl_stmt|,
modifier|*
name|lita_sec
decl_stmt|;
name|struct
name|ecoff_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|bfd_vma
name|gp
decl_stmt|;
name|boolean
name|gp_undefined
decl_stmt|;
name|bfd_vma
name|stack
index|[
name|RELOC_STACKSIZE
index|]
decl_stmt|;
name|int
name|tos
init|=
literal|0
decl_stmt|;
name|struct
name|external_reloc
modifier|*
name|ext_rel
decl_stmt|;
name|struct
name|external_reloc
modifier|*
name|ext_rel_end
decl_stmt|;
comment|/* We keep a table mapping the symndx found in an internal reloc to      the appropriate section.  This is faster than looking up the      section by name each time.  */
name|symndx_to_section
operator|=
name|ecoff_data
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symndx_to_section
expr_stmt|;
if|if
condition|(
name|symndx_to_section
operator|==
operator|(
name|asection
operator|*
operator|*
operator|)
name|NULL
condition|)
block|{
name|symndx_to_section
operator|=
operator|(
operator|(
name|asection
operator|*
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|NUM_RELOC_SECTIONS
operator|*
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
operator|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|symndx_to_section
condition|)
return|return
name|false
return|;
name|symndx_to_section
index|[
name|RELOC_SECTION_NONE
index|]
operator|=
name|NULL
expr_stmt|;
name|symndx_to_section
index|[
name|RELOC_SECTION_TEXT
index|]
operator|=
name|bfd_get_section_by_name
argument_list|(
name|input_bfd
argument_list|,
literal|".text"
argument_list|)
expr_stmt|;
name|symndx_to_section
index|[
name|RELOC_SECTION_RDATA
index|]
operator|=
name|bfd_get_section_by_name
argument_list|(
name|input_bfd
argument_list|,
literal|".rdata"
argument_list|)
expr_stmt|;
name|symndx_to_section
index|[
name|RELOC_SECTION_DATA
index|]
operator|=
name|bfd_get_section_by_name
argument_list|(
name|input_bfd
argument_list|,
literal|".data"
argument_list|)
expr_stmt|;
name|symndx_to_section
index|[
name|RELOC_SECTION_SDATA
index|]
operator|=
name|bfd_get_section_by_name
argument_list|(
name|input_bfd
argument_list|,
literal|".sdata"
argument_list|)
expr_stmt|;
name|symndx_to_section
index|[
name|RELOC_SECTION_SBSS
index|]
operator|=
name|bfd_get_section_by_name
argument_list|(
name|input_bfd
argument_list|,
literal|".sbss"
argument_list|)
expr_stmt|;
name|symndx_to_section
index|[
name|RELOC_SECTION_BSS
index|]
operator|=
name|bfd_get_section_by_name
argument_list|(
name|input_bfd
argument_list|,
literal|".bss"
argument_list|)
expr_stmt|;
name|symndx_to_section
index|[
name|RELOC_SECTION_INIT
index|]
operator|=
name|bfd_get_section_by_name
argument_list|(
name|input_bfd
argument_list|,
literal|".init"
argument_list|)
expr_stmt|;
name|symndx_to_section
index|[
name|RELOC_SECTION_LIT8
index|]
operator|=
name|bfd_get_section_by_name
argument_list|(
name|input_bfd
argument_list|,
literal|".lit8"
argument_list|)
expr_stmt|;
name|symndx_to_section
index|[
name|RELOC_SECTION_LIT4
index|]
operator|=
name|bfd_get_section_by_name
argument_list|(
name|input_bfd
argument_list|,
literal|".lit4"
argument_list|)
expr_stmt|;
name|symndx_to_section
index|[
name|RELOC_SECTION_XDATA
index|]
operator|=
name|bfd_get_section_by_name
argument_list|(
name|input_bfd
argument_list|,
literal|".xdata"
argument_list|)
expr_stmt|;
name|symndx_to_section
index|[
name|RELOC_SECTION_PDATA
index|]
operator|=
name|bfd_get_section_by_name
argument_list|(
name|input_bfd
argument_list|,
literal|".pdata"
argument_list|)
expr_stmt|;
name|symndx_to_section
index|[
name|RELOC_SECTION_FINI
index|]
operator|=
name|bfd_get_section_by_name
argument_list|(
name|input_bfd
argument_list|,
literal|".fini"
argument_list|)
expr_stmt|;
name|symndx_to_section
index|[
name|RELOC_SECTION_LITA
index|]
operator|=
name|bfd_get_section_by_name
argument_list|(
name|input_bfd
argument_list|,
literal|".lita"
argument_list|)
expr_stmt|;
name|symndx_to_section
index|[
name|RELOC_SECTION_ABS
index|]
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
name|symndx_to_section
index|[
name|RELOC_SECTION_RCONST
index|]
operator|=
name|bfd_get_section_by_name
argument_list|(
name|input_bfd
argument_list|,
literal|".rconst"
argument_list|)
expr_stmt|;
name|ecoff_data
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symndx_to_section
operator|=
name|symndx_to_section
expr_stmt|;
block|}
name|sym_hashes
operator|=
name|ecoff_data
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|sym_hashes
expr_stmt|;
comment|/* On the Alpha, the .lita section must be addressable by the global      pointer.  To support large programs, we need to allow multiple      global pointers.  This works as long as each input .lita section      is<64KB big.  This implies that when producing relocatable      output, the .lita section is limited to 64KB. .  */
name|lita_sec
operator|=
name|symndx_to_section
index|[
name|RELOC_SECTION_LITA
index|]
expr_stmt|;
name|gp
operator|=
name|_bfd_get_gp_value
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|relocateable
operator|&&
name|lita_sec
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ecoff_section_tdata
modifier|*
name|lita_sec_data
decl_stmt|;
comment|/* Make sure we have a section data structure to which we can 	 hang on to the gp value we pick for the section.  */
name|lita_sec_data
operator|=
name|ecoff_section_data
argument_list|(
name|input_bfd
argument_list|,
name|lita_sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|lita_sec_data
operator|==
name|NULL
condition|)
block|{
name|lita_sec_data
operator|=
operator|(
operator|(
expr|struct
name|ecoff_section_tdata
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|input_bfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ecoff_section_tdata
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|ecoff_section_data
argument_list|(
name|input_bfd
argument_list|,
name|lita_sec
argument_list|)
operator|=
name|lita_sec_data
expr_stmt|;
block|}
if|if
condition|(
name|lita_sec_data
operator|->
name|gp
operator|!=
literal|0
condition|)
block|{
comment|/* If we already assigned a gp to this section, we better 	     stick with that value.  */
name|gp
operator|=
name|lita_sec_data
operator|->
name|gp
expr_stmt|;
block|}
else|else
block|{
name|bfd_vma
name|lita_vma
decl_stmt|;
name|bfd_size_type
name|lita_size
decl_stmt|;
name|lita_vma
operator|=
name|lita_sec
operator|->
name|output_offset
operator|+
name|lita_sec
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|lita_size
operator|=
name|lita_sec
operator|->
name|_cooked_size
expr_stmt|;
if|if
condition|(
name|lita_size
operator|==
literal|0
condition|)
name|lita_size
operator|=
name|lita_sec
operator|->
name|_raw_size
expr_stmt|;
if|if
condition|(
name|gp
operator|==
literal|0
operator|||
name|lita_vma
operator|<
name|gp
operator|-
literal|0x8000
operator|||
name|lita_vma
operator|+
name|lita_size
operator|>=
name|gp
operator|+
literal|0x8000
condition|)
block|{
comment|/* Either gp hasn't been set at all or the current gp 		 cannot address this .lita section.  In both cases we 		 reset the gp to point into the "middle" of the 		 current input .lita section.  */
if|if
condition|(
name|gp
operator|&&
operator|!
name|ecoff_data
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|issued_multiple_gp_warning
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|warning
call|)
argument_list|(
name|info
argument_list|,
name|_
argument_list|(
literal|"using multiple gp values"
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|output_bfd
argument_list|,
operator|(
name|asection
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
expr_stmt|;
name|ecoff_data
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|issued_multiple_gp_warning
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|lita_vma
operator|<
name|gp
operator|-
literal|0x8000
condition|)
name|gp
operator|=
name|lita_vma
operator|+
name|lita_size
operator|-
literal|0x8000
expr_stmt|;
else|else
name|gp
operator|=
name|lita_vma
operator|+
literal|0x8000
expr_stmt|;
block|}
name|lita_sec_data
operator|->
name|gp
operator|=
name|gp
expr_stmt|;
block|}
name|_bfd_set_gp_value
argument_list|(
name|output_bfd
argument_list|,
name|gp
argument_list|)
expr_stmt|;
block|}
name|gp_undefined
operator|=
operator|(
name|gp
operator|==
literal|0
operator|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|bfd_header_little_endian
argument_list|(
name|output_bfd
argument_list|)
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|bfd_header_little_endian
argument_list|(
name|input_bfd
argument_list|)
argument_list|)
expr_stmt|;
name|ext_rel
operator|=
operator|(
expr|struct
name|external_reloc
operator|*
operator|)
name|external_relocs
expr_stmt|;
name|ext_rel_end
operator|=
name|ext_rel
operator|+
name|input_section
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|ext_rel
operator|<
name|ext_rel_end
condition|;
name|ext_rel
operator|++
control|)
block|{
name|bfd_vma
name|r_vaddr
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|int
name|r_type
decl_stmt|;
name|int
name|r_extern
decl_stmt|;
name|int
name|r_offset
decl_stmt|;
name|int
name|r_size
decl_stmt|;
name|boolean
name|relocatep
decl_stmt|;
name|boolean
name|adjust_addrp
decl_stmt|;
name|boolean
name|gp_usedp
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|;
name|r_vaddr
operator|=
name|bfd_h_get_64
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext_rel
operator|->
name|r_vaddr
argument_list|)
expr_stmt|;
name|r_symndx
operator|=
name|bfd_h_get_32
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext_rel
operator|->
name|r_symndx
argument_list|)
expr_stmt|;
name|r_type
operator|=
operator|(
operator|(
name|ext_rel
operator|->
name|r_bits
index|[
literal|0
index|]
operator|&
name|RELOC_BITS0_TYPE_LITTLE
operator|)
operator|>>
name|RELOC_BITS0_TYPE_SH_LITTLE
operator|)
expr_stmt|;
name|r_extern
operator|=
operator|(
name|ext_rel
operator|->
name|r_bits
index|[
literal|1
index|]
operator|&
name|RELOC_BITS1_EXTERN_LITTLE
operator|)
operator|!=
literal|0
expr_stmt|;
name|r_offset
operator|=
operator|(
operator|(
name|ext_rel
operator|->
name|r_bits
index|[
literal|1
index|]
operator|&
name|RELOC_BITS1_OFFSET_LITTLE
operator|)
operator|>>
name|RELOC_BITS1_OFFSET_SH_LITTLE
operator|)
expr_stmt|;
comment|/* Ignored the reserved bits.  */
name|r_size
operator|=
operator|(
operator|(
name|ext_rel
operator|->
name|r_bits
index|[
literal|3
index|]
operator|&
name|RELOC_BITS3_SIZE_LITTLE
operator|)
operator|>>
name|RELOC_BITS3_SIZE_SH_LITTLE
operator|)
expr_stmt|;
name|relocatep
operator|=
name|false
expr_stmt|;
name|adjust_addrp
operator|=
name|true
expr_stmt|;
name|gp_usedp
operator|=
name|false
expr_stmt|;
name|addend
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|ALPHA_R_IGNORE
case|:
comment|/* This reloc appears after a GPDISP reloc.  On earlier 	     versions of OSF/1, It marked the position of the second 	     instruction to be altered by the GPDISP reloc, but it is 	     not otherwise used for anything.  For some reason, the 	     address of the relocation does not appear to include the 	     section VMA, unlike the other relocation types.  */
if|if
condition|(
name|info
operator|->
name|relocateable
condition|)
name|bfd_h_put_64
argument_list|(
name|input_bfd
argument_list|,
name|input_section
operator|->
name|output_offset
operator|+
name|r_vaddr
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext_rel
operator|->
name|r_vaddr
argument_list|)
expr_stmt|;
name|adjust_addrp
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|ALPHA_R_REFLONG
case|:
case|case
name|ALPHA_R_REFQUAD
case|:
case|case
name|ALPHA_R_HINT
case|:
name|relocatep
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|ALPHA_R_BRADDR
case|:
case|case
name|ALPHA_R_SREL16
case|:
case|case
name|ALPHA_R_SREL32
case|:
case|case
name|ALPHA_R_SREL64
case|:
if|if
condition|(
name|r_extern
condition|)
name|addend
operator|+=
operator|-
operator|(
name|r_vaddr
operator|+
literal|4
operator|)
expr_stmt|;
name|relocatep
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|ALPHA_R_GPREL32
case|:
comment|/* This relocation is used in a switch table.  It is a 32 	     bit offset from the current GP value.  We must adjust it 	     by the different between the original GP value and the 	     current GP value.  */
name|relocatep
operator|=
name|true
expr_stmt|;
name|addend
operator|=
name|ecoff_data
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|gp
operator|-
name|gp
expr_stmt|;
name|gp_usedp
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|ALPHA_R_LITERAL
case|:
comment|/* This is a reference to a literal value, generally 	     (always?) in the .lita section.  This is a 16 bit GP 	     relative relocation.  Sometimes the subsequent reloc is a 	     LITUSE reloc, which indicates how this reloc is used. 	     This sometimes permits rewriting the two instructions 	     referred to by the LITERAL and the LITUSE into different 	     instructions which do not refer to .lita.  This can save 	     a memory reference, and permits removing a value from 	     .lita thus saving GP relative space.  	     We do not these optimizations.  To do them we would need 	     to arrange to link the .lita section first, so that by 	     the time we got here we would know the final values to 	     use.  This would not be particularly difficult, but it is 	     not currently implemented.  */
comment|/* I believe that the LITERAL reloc will only apply to a ldq 	     or ldl instruction, so check my assumption.  */
block|{
name|unsigned
name|long
name|insn
decl_stmt|;
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
operator|(
operator|(
name|insn
operator|>>
literal|26
operator|)
operator|&
literal|0x3f
operator|)
operator|==
literal|0x29
operator|||
operator|(
operator|(
name|insn
operator|>>
literal|26
operator|)
operator|&
literal|0x3f
operator|)
operator|==
literal|0x28
argument_list|)
expr_stmt|;
block|}
name|relocatep
operator|=
name|true
expr_stmt|;
name|addend
operator|=
name|ecoff_data
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|gp
operator|-
name|gp
expr_stmt|;
name|gp_usedp
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|ALPHA_R_LITUSE
case|:
comment|/* See ALPHA_R_LITERAL above for the uses of this reloc.  It 	     does not cause anything to happen, itself.  */
break|break;
case|case
name|ALPHA_R_GPDISP
case|:
comment|/* This marks the ldah of an ldah/lda pair which loads the 	     gp register with the difference of the gp value and the 	     current location.  The second of the pair is r_symndx 	     bytes ahead.  It used to be marked with an ALPHA_R_IGNORE 	     reloc, but OSF/1 3.2 no longer does that.  */
block|{
name|unsigned
name|long
name|insn1
decl_stmt|,
name|insn2
decl_stmt|;
comment|/* Get the two instructions.  */
name|insn1
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
argument_list|)
expr_stmt|;
name|insn2
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|contents
operator|+
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
operator|+
name|r_symndx
operator|)
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
operator|(
operator|(
name|insn1
operator|>>
literal|26
operator|)
operator|&
literal|0x3f
operator|)
operator|==
literal|0x09
argument_list|)
expr_stmt|;
comment|/* ldah */
name|BFD_ASSERT
argument_list|(
operator|(
operator|(
name|insn2
operator|>>
literal|26
operator|)
operator|&
literal|0x3f
operator|)
operator|==
literal|0x08
argument_list|)
expr_stmt|;
comment|/* lda */
comment|/* Get the existing addend.  We must account for the sign 	       extension done by lda and ldah.  */
name|addend
operator|=
operator|(
operator|(
name|insn1
operator|&
literal|0xffff
operator|)
operator|<<
literal|16
operator|)
operator|+
operator|(
name|insn2
operator|&
literal|0xffff
operator|)
expr_stmt|;
if|if
condition|(
name|insn1
operator|&
literal|0x8000
condition|)
block|{
comment|/* This is addend -= 0x100000000 without causing an 		   integer overflow on a 32 bit host.  */
name|addend
operator|-=
literal|0x80000000
expr_stmt|;
name|addend
operator|-=
literal|0x80000000
expr_stmt|;
block|}
if|if
condition|(
name|insn2
operator|&
literal|0x8000
condition|)
name|addend
operator|-=
literal|0x10000
expr_stmt|;
comment|/* The existing addend includes the difference between the 	       gp of the input BFD and the address in the input BFD. 	       We want to change this to the difference between the 	       final GP and the final address.  */
name|addend
operator|+=
operator|(
name|gp
operator|-
name|ecoff_data
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|gp
operator|+
name|input_section
operator|->
name|vma
operator|-
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
operator|)
expr_stmt|;
comment|/* Change the instructions, accounting for the sign 	       extension, and write them out.  */
if|if
condition|(
name|addend
operator|&
literal|0x8000
condition|)
name|addend
operator|+=
literal|0x10000
expr_stmt|;
name|insn1
operator|=
operator|(
name|insn1
operator|&
literal|0xffff0000
operator|)
operator||
operator|(
operator|(
name|addend
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|insn2
operator|=
operator|(
name|insn2
operator|&
literal|0xffff0000
operator|)
operator||
operator|(
name|addend
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|insn1
argument_list|,
name|contents
operator|+
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|insn2
argument_list|,
name|contents
operator|+
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
operator|+
name|r_symndx
argument_list|)
expr_stmt|;
name|gp_usedp
operator|=
name|true
expr_stmt|;
block|}
break|break;
case|case
name|ALPHA_R_OP_PUSH
case|:
case|case
name|ALPHA_R_OP_PSUB
case|:
case|case
name|ALPHA_R_OP_PRSHIFT
case|:
comment|/* Manipulate values on the reloc evaluation stack.  The 	     r_vaddr field is not an address in input_section, it is 	     the current value (including any addend) of the object 	     being used.  */
if|if
condition|(
operator|!
name|r_extern
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|symndx_to_section
index|[
name|r_symndx
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|==
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|addend
operator|=
name|s
operator|->
name|output_section
operator|->
name|vma
operator|+
name|s
operator|->
name|output_offset
operator|-
name|s
operator|->
name|vma
expr_stmt|;
block|}
else|else
block|{
name|struct
name|ecoff_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
index|]
expr_stmt|;
if|if
condition|(
name|h
operator|==
operator|(
expr|struct
name|ecoff_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|relocateable
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
name|addend
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
else|else
block|{
comment|/* Note that we pass the address as 0, since we 			 do not have a meaningful number for the 			 location within the section that is being 			 relocated.  */
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|true
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
name|addend
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defined
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
operator|&&
name|h
operator|->
name|indx
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* This symbol is not being written out.  Pass 			 the address as 0, as with undefined_symbol, 			 above.  */
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|unattached_reloc
call|)
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
block|}
name|addend
operator|=
name|alpha_convert_external_reloc
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|input_bfd
argument_list|,
name|ext_rel
argument_list|,
name|h
argument_list|)
expr_stmt|;
block|}
block|}
name|addend
operator|+=
name|r_vaddr
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|relocateable
condition|)
block|{
comment|/* Adjust r_vaddr by the addend.  */
name|bfd_h_put_64
argument_list|(
name|input_bfd
argument_list|,
name|addend
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext_rel
operator|->
name|r_vaddr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|ALPHA_R_OP_PUSH
case|:
if|if
condition|(
name|tos
operator|>=
name|RELOC_STACKSIZE
condition|)
name|abort
argument_list|()
expr_stmt|;
name|stack
index|[
name|tos
operator|++
index|]
operator|=
name|addend
expr_stmt|;
break|break;
case|case
name|ALPHA_R_OP_PSUB
case|:
if|if
condition|(
name|tos
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|stack
index|[
name|tos
operator|-
literal|1
index|]
operator|-=
name|addend
expr_stmt|;
break|break;
case|case
name|ALPHA_R_OP_PRSHIFT
case|:
if|if
condition|(
name|tos
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|stack
index|[
name|tos
operator|-
literal|1
index|]
operator|>>=
name|addend
expr_stmt|;
break|break;
block|}
block|}
name|adjust_addrp
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|ALPHA_R_OP_STORE
case|:
comment|/* Store a value from the reloc stack into a bitfield.  If 	     we are generating relocateable output, all we do is 	     adjust the address of the reloc.  */
if|if
condition|(
operator|!
name|info
operator|->
name|relocateable
condition|)
block|{
name|bfd_vma
name|mask
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
if|if
condition|(
name|tos
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Get the relocation mask.  The separate steps and the 		 casts to bfd_vma are attempts to avoid a bug in the 		 Alpha OSF 1.3 C compiler.  See reloc.c for more 		 details.  */
name|mask
operator|=
literal|1
expr_stmt|;
name|mask
operator|<<=
operator|(
name|bfd_vma
operator|)
name|r_size
expr_stmt|;
name|mask
operator|-=
literal|1
expr_stmt|;
comment|/* FIXME: I don't know what kind of overflow checking, 		 if any, should be done here.  */
name|val
operator|=
name|bfd_get_64
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
name|mask
operator|<<
operator|(
name|bfd_vma
operator|)
name|r_offset
expr_stmt|;
name|val
operator||=
operator|(
name|stack
index|[
operator|--
name|tos
index|]
operator|&
name|mask
operator|)
operator|<<
operator|(
name|bfd_vma
operator|)
name|r_offset
expr_stmt|;
name|bfd_put_64
argument_list|(
name|input_bfd
argument_list|,
name|val
argument_list|,
name|contents
operator|+
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ALPHA_R_GPVALUE
case|:
comment|/* I really don't know if this does the right thing.  */
name|gp
operator|=
name|ecoff_data
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|gp
operator|+
name|r_symndx
expr_stmt|;
name|gp_undefined
operator|=
name|false
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|relocatep
condition|)
block|{
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|struct
name|ecoff_link_hash_entry
modifier|*
name|h
init|=
name|NULL
decl_stmt|;
name|asection
modifier|*
name|s
init|=
name|NULL
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_reloc_status_type
name|r
decl_stmt|;
comment|/* Perform a relocation.  */
name|howto
operator|=
operator|&
name|alpha_howto_table
index|[
name|r_type
index|]
expr_stmt|;
if|if
condition|(
name|r_extern
condition|)
block|{
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
index|]
expr_stmt|;
comment|/* If h is NULL, that means that there is a reloc 		 against an external symbol which we thought was just 		 a debugging symbol.  This should not happen.  */
if|if
condition|(
name|h
operator|==
operator|(
expr|struct
name|ecoff_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|r_symndx
operator|>=
name|NUM_RELOC_SECTIONS
condition|)
name|s
operator|=
name|NULL
expr_stmt|;
else|else
name|s
operator|=
name|symndx_to_section
index|[
name|r_symndx
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|==
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|relocateable
condition|)
block|{
comment|/* We are generating relocateable output, and must 		 convert the existing reloc.  */
if|if
condition|(
name|r_extern
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defined
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
operator|&&
name|h
operator|->
name|indx
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* This symbol is not being written out.  */
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|unattached_reloc
call|)
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
block|}
name|relocation
operator|=
name|alpha_convert_external_reloc
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|input_bfd
argument_list|,
name|ext_rel
argument_list|,
name|h
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This is a relocation against a section.  Adjust 		     the value by the amount the section moved.  */
name|relocation
operator|=
operator|(
name|s
operator|->
name|output_section
operator|->
name|vma
operator|+
name|s
operator|->
name|output_offset
operator|-
name|s
operator|->
name|vma
operator|)
expr_stmt|;
block|}
comment|/* If this is PC relative, the existing object file 		 appears to already have the reloc worked out.  We 		 must subtract out the old value and add in the new 		 one.  */
if|if
condition|(
name|howto
operator|->
name|pc_relative
condition|)
name|relocation
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|-
name|input_section
operator|->
name|vma
operator|)
expr_stmt|;
comment|/* Put in any addend.  */
name|relocation
operator|+=
name|addend
expr_stmt|;
comment|/* Adjust the contents.  */
name|r
operator|=
name|_bfd_relocate_contents
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|relocation
argument_list|,
operator|(
name|contents
operator|+
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We are producing a final executable.  */
if|if
condition|(
name|r_extern
condition|)
block|{
comment|/* This is a reloc against a symbol.  */
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
block|{
name|asection
modifier|*
name|hsec
decl_stmt|;
name|hsec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|relocation
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|hsec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|hsec
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
argument_list|,
name|true
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
name|relocation
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* This is a reloc against a section.  */
name|relocation
operator|=
operator|(
name|s
operator|->
name|output_section
operator|->
name|vma
operator|+
name|s
operator|->
name|output_offset
operator|-
name|s
operator|->
name|vma
operator|)
expr_stmt|;
comment|/* Adjust a PC relative relocation by removing the 		     reference to the original source section.  */
if|if
condition|(
name|howto
operator|->
name|pc_relative
condition|)
name|relocation
operator|+=
name|input_section
operator|->
name|vma
expr_stmt|;
block|}
name|r
operator|=
name|_bfd_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
argument_list|,
name|relocation
argument_list|,
name|addend
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|!=
name|bfd_reloc_ok
condition|)
block|{
switch|switch
condition|(
name|r
condition|)
block|{
default|default:
case|case
name|bfd_reloc_outofrange
case|:
name|abort
argument_list|()
expr_stmt|;
case|case
name|bfd_reloc_overflow
case|:
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|r_extern
condition|)
name|name
operator|=
name|sym_hashes
index|[
name|r_symndx
index|]
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
else|else
name|name
operator|=
name|bfd_section_name
argument_list|(
name|input_bfd
argument_list|,
name|symndx_to_section
index|[
name|r_symndx
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|info
argument_list|,
name|name
argument_list|,
name|alpha_howto_table
index|[
name|r_type
index|]
operator|.
name|name
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
block|}
break|break;
block|}
block|}
block|}
if|if
condition|(
name|info
operator|->
name|relocateable
operator|&&
name|adjust_addrp
condition|)
block|{
comment|/* Change the address of the relocation.  */
name|bfd_h_put_64
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|-
name|input_section
operator|->
name|vma
operator|+
name|r_vaddr
operator|)
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext_rel
operator|->
name|r_vaddr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gp_usedp
operator|&&
name|gp_undefined
condition|)
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_dangerous
call|)
argument_list|(
name|info
argument_list|,
name|_
argument_list|(
literal|"GP relative relocation when GP not defined"
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
comment|/* Only give the error once per link.  */
name|gp
operator|=
literal|4
expr_stmt|;
name|_bfd_set_gp_value
argument_list|(
name|output_bfd
argument_list|,
name|gp
argument_list|)
expr_stmt|;
name|gp_undefined
operator|=
name|false
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tos
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Do final adjustments to the filehdr and the aouthdr.  This routine    sets the dynamic bits in the file header.  */
end_comment

begin_function
specifier|static
name|boolean
name|alpha_adjust_headers
parameter_list|(
name|abfd
parameter_list|,
name|fhdr
parameter_list|,
name|ahdr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|internal_filehdr
modifier|*
name|fhdr
decl_stmt|;
name|struct
name|internal_aouthdr
modifier|*
name|ahdr
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
operator|(
name|DYNAMIC
operator||
name|EXEC_P
operator|)
operator|)
operator|==
operator|(
name|DYNAMIC
operator||
name|EXEC_P
operator|)
condition|)
name|fhdr
operator|->
name|f_flags
operator||=
name|F_ALPHA_CALL_SHARED
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
condition|)
name|fhdr
operator|->
name|f_flags
operator||=
name|F_ALPHA_SHARABLE
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Archive handling.  In OSF/1 (or Digital Unix) v3.2, Digital    introduced archive packing, in which the elements in an archive are    optionally compressed using a simple dictionary scheme.  We know    how to read such archives, but we don't write them.  */
end_comment

begin_define
define|#
directive|define
name|alpha_ecoff_slurp_armap
value|_bfd_ecoff_slurp_armap
end_define

begin_define
define|#
directive|define
name|alpha_ecoff_slurp_extended_name_table
define|\
value|_bfd_ecoff_slurp_extended_name_table
end_define

begin_define
define|#
directive|define
name|alpha_ecoff_construct_extended_name_table
define|\
value|_bfd_ecoff_construct_extended_name_table
end_define

begin_define
define|#
directive|define
name|alpha_ecoff_truncate_arname
value|_bfd_ecoff_truncate_arname
end_define

begin_define
define|#
directive|define
name|alpha_ecoff_write_armap
value|_bfd_ecoff_write_armap
end_define

begin_define
define|#
directive|define
name|alpha_ecoff_generic_stat_arch_elt
value|_bfd_ecoff_generic_stat_arch_elt
end_define

begin_define
define|#
directive|define
name|alpha_ecoff_update_armap_timestamp
value|_bfd_ecoff_update_armap_timestamp
end_define

begin_comment
comment|/* A compressed file uses this instead of ARFMAG.  */
end_comment

begin_define
define|#
directive|define
name|ARFZMAG
value|"Z\012"
end_define

begin_comment
comment|/* Read an archive header.  This is like the standard routine, but it    also accepts ARFZMAG.  */
end_comment

begin_function
specifier|static
name|PTR
name|alpha_ecoff_read_ar_hdr
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|areltdata
modifier|*
name|ret
decl_stmt|;
name|struct
name|ar_hdr
modifier|*
name|h
decl_stmt|;
name|ret
operator|=
operator|(
expr|struct
name|areltdata
operator|*
operator|)
name|_bfd_generic_read_ar_hdr_mag
argument_list|(
name|abfd
argument_list|,
name|ARFZMAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|h
operator|=
operator|(
expr|struct
name|ar_hdr
operator|*
operator|)
name|ret
operator|->
name|arch_header
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|h
operator|->
name|ar_fmag
argument_list|,
name|ARFZMAG
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|bfd_byte
name|ab
index|[
literal|8
index|]
decl_stmt|;
comment|/* This is a compressed file.  We must set the size correctly.          The size is the eight bytes after the dummy file header.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|FILHSZ
argument_list|,
name|SEEK_CUR
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_read
argument_list|(
name|ab
argument_list|,
literal|1
argument_list|,
literal|8
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|8
operator|||
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|-
operator|(
name|FILHSZ
operator|+
literal|8
operator|)
argument_list|,
name|SEEK_CUR
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|NULL
return|;
name|ret
operator|->
name|parsed_size
operator|=
name|bfd_h_get_64
argument_list|(
name|abfd
argument_list|,
name|ab
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|PTR
operator|)
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Get an archive element at a specified file position.  This is where    we uncompress the archive element if necessary.  */
end_comment

begin_function
specifier|static
name|bfd
modifier|*
name|alpha_ecoff_get_elt_at_filepos
parameter_list|(
name|archive
parameter_list|,
name|filepos
parameter_list|)
name|bfd
modifier|*
name|archive
decl_stmt|;
name|file_ptr
name|filepos
decl_stmt|;
block|{
name|bfd
modifier|*
name|nbfd
init|=
name|NULL
decl_stmt|;
name|struct
name|areltdata
modifier|*
name|tdata
decl_stmt|;
name|struct
name|ar_hdr
modifier|*
name|hdr
decl_stmt|;
name|bfd_byte
name|ab
index|[
literal|8
index|]
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
name|bfd_byte
modifier|*
name|buf
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|struct
name|bfd_in_memory
modifier|*
name|bim
decl_stmt|;
name|nbfd
operator|=
name|_bfd_get_elt_at_filepos
argument_list|(
name|archive
argument_list|,
name|filepos
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbfd
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|(
name|nbfd
operator|->
name|flags
operator|&
name|BFD_IN_MEMORY
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* We have already expanded this BFD.  */
return|return
name|nbfd
return|;
block|}
name|tdata
operator|=
operator|(
expr|struct
name|areltdata
operator|*
operator|)
name|nbfd
operator|->
name|arelt_data
expr_stmt|;
name|hdr
operator|=
operator|(
expr|struct
name|ar_hdr
operator|*
operator|)
name|tdata
operator|->
name|arch_header
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|hdr
operator|->
name|ar_fmag
argument_list|,
name|ARFZMAG
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|nbfd
return|;
comment|/* We must uncompress this element.  We do this by copying it into a      memory buffer, and making bfd_read and bfd_seek use that buffer.      This can use a lot of memory, but it's simpler than getting a      temporary file, making that work with the file descriptor caching      code, and making sure that it is deleted at all appropriate      times.  It can be changed if it ever becomes important.  */
comment|/* The compressed file starts with a dummy ECOFF file header.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|nbfd
argument_list|,
name|FILHSZ
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
comment|/* The next eight bytes are the real file size.  */
if|if
condition|(
name|bfd_read
argument_list|(
name|ab
argument_list|,
literal|1
argument_list|,
literal|8
argument_list|,
name|nbfd
argument_list|)
operator|!=
literal|8
condition|)
goto|goto
name|error_return
goto|;
name|size
operator|=
name|bfd_h_get_64
argument_list|(
name|nbfd
argument_list|,
name|ab
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|buf
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|bfd_size_type
name|left
decl_stmt|;
name|bfd_byte
name|dict
index|[
literal|4096
index|]
decl_stmt|;
name|unsigned
name|int
name|h
decl_stmt|;
name|bfd_byte
name|b
decl_stmt|;
name|buf
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|nbfd
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|p
operator|=
name|buf
expr_stmt|;
name|left
operator|=
name|size
expr_stmt|;
comment|/* I don't know what the next eight bytes are for.  */
if|if
condition|(
name|bfd_read
argument_list|(
name|ab
argument_list|,
literal|1
argument_list|,
literal|8
argument_list|,
name|nbfd
argument_list|)
operator|!=
literal|8
condition|)
goto|goto
name|error_return
goto|;
comment|/* This is the uncompression algorithm.  It's a simple 	 dictionary based scheme in which each character is predicted 	 by a hash of the previous three characters.  A control byte 	 indicates whether the character is predicted or whether it 	 appears in the input stream; each control byte manages the 	 next eight bytes in the output stream.  */
name|memset
argument_list|(
name|dict
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|dict
argument_list|)
expr_stmt|;
name|h
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|bfd_read
argument_list|(
operator|&
name|b
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|nbfd
argument_list|)
operator|==
literal|1
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
operator|,
name|b
operator|>>=
literal|1
control|)
block|{
name|bfd_byte
name|n
decl_stmt|;
if|if
condition|(
operator|(
name|b
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
name|n
operator|=
name|dict
index|[
name|h
index|]
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|bfd_read
argument_list|(
operator|&
name|n
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|nbfd
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
name|dict
index|[
name|h
index|]
operator|=
name|n
expr_stmt|;
block|}
operator|*
name|p
operator|++
operator|=
name|n
expr_stmt|;
operator|--
name|left
expr_stmt|;
if|if
condition|(
name|left
operator|==
literal|0
condition|)
break|break;
name|h
operator|<<=
literal|4
expr_stmt|;
name|h
operator|^=
name|n
expr_stmt|;
name|h
operator|&=
sizeof|sizeof
name|dict
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|left
operator|==
literal|0
condition|)
break|break;
block|}
block|}
comment|/* Now the uncompressed file contents are in buf.  */
name|bim
operator|=
operator|(
operator|(
expr|struct
name|bfd_in_memory
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|nbfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bfd_in_memory
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|bim
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|bim
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|bim
operator|->
name|buffer
operator|=
name|buf
expr_stmt|;
name|nbfd
operator|->
name|mtime_set
operator|=
name|true
expr_stmt|;
name|nbfd
operator|->
name|mtime
operator|=
name|strtol
argument_list|(
name|hdr
operator|->
name|ar_date
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|nbfd
operator|->
name|flags
operator||=
name|BFD_IN_MEMORY
expr_stmt|;
name|nbfd
operator|->
name|iostream
operator|=
operator|(
name|PTR
operator|)
name|bim
expr_stmt|;
name|BFD_ASSERT
argument_list|(
operator|!
name|nbfd
operator|->
name|cacheable
argument_list|)
expr_stmt|;
return|return
name|nbfd
return|;
name|error_return
label|:
if|if
condition|(
name|nbfd
operator|!=
name|NULL
condition|)
name|bfd_close
argument_list|(
name|nbfd
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Open the next archived file.  */
end_comment

begin_function
specifier|static
name|bfd
modifier|*
name|alpha_ecoff_openr_next_archived_file
parameter_list|(
name|archive
parameter_list|,
name|last_file
parameter_list|)
name|bfd
modifier|*
name|archive
decl_stmt|;
name|bfd
modifier|*
name|last_file
decl_stmt|;
block|{
name|file_ptr
name|filestart
decl_stmt|;
if|if
condition|(
name|last_file
operator|==
name|NULL
condition|)
name|filestart
operator|=
name|bfd_ardata
argument_list|(
name|archive
argument_list|)
operator|->
name|first_file_filepos
expr_stmt|;
else|else
block|{
name|struct
name|areltdata
modifier|*
name|t
decl_stmt|;
name|struct
name|ar_hdr
modifier|*
name|h
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
comment|/* We can't use arelt_size here, because that uses parsed_size,          which is the uncompressed size.  We need the compressed size.  */
name|t
operator|=
operator|(
expr|struct
name|areltdata
operator|*
operator|)
name|last_file
operator|->
name|arelt_data
expr_stmt|;
name|h
operator|=
operator|(
expr|struct
name|ar_hdr
operator|*
operator|)
name|t
operator|->
name|arch_header
expr_stmt|;
name|size
operator|=
name|strtol
argument_list|(
name|h
operator|->
name|ar_size
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* Pad to an even boundary... 	 Note that last_file->origin can be odd in the case of 	 BSD-4.4-style element with a long odd size.  */
name|filestart
operator|=
name|last_file
operator|->
name|origin
operator|+
name|size
expr_stmt|;
name|filestart
operator|+=
name|filestart
operator|%
literal|2
expr_stmt|;
block|}
return|return
name|alpha_ecoff_get_elt_at_filepos
argument_list|(
name|archive
argument_list|,
name|filestart
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Open the archive file given an index into the armap.  */
end_comment

begin_function
specifier|static
name|bfd
modifier|*
name|alpha_ecoff_get_elt_at_index
parameter_list|(
name|abfd
parameter_list|,
name|index
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|symindex
name|index
decl_stmt|;
block|{
name|carsym
modifier|*
name|entry
decl_stmt|;
name|entry
operator|=
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symdefs
operator|+
name|index
expr_stmt|;
return|return
name|alpha_ecoff_get_elt_at_filepos
argument_list|(
name|abfd
argument_list|,
name|entry
operator|->
name|file_offset
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This is the ECOFF backend structure.  The backend field of the    target vector points to this.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ecoff_backend_data
name|alpha_ecoff_backend_data
init|=
block|{
comment|/* COFF backend structure.  */
block|{
operator|(
name|void
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
expr|,
name|PTR
expr|,
name|int
expr|,
name|int
expr|,
name|int
expr|,
name|int
expr|,
name|PTR
operator|)
argument_list|)
operator|)
name|bfd_void
block|,
comment|/* aux_in */
operator|(
name|void
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
expr|,
name|PTR
expr|,
name|PTR
operator|)
argument_list|)
operator|)
name|bfd_void
block|,
comment|/* sym_in */
operator|(
name|void
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
expr|,
name|PTR
expr|,
name|PTR
operator|)
argument_list|)
operator|)
name|bfd_void
block|,
comment|/* lineno_in */
operator|(
name|unsigned
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
expr|,
name|PTR
expr|,
name|int
expr|,
name|int
expr|,
name|int
expr|,
name|int
expr|,
name|PTR
operator|)
argument_list|)
operator|)
name|bfd_void
block|,
comment|/*aux_out*/
operator|(
name|unsigned
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
expr|,
name|PTR
expr|,
name|PTR
operator|)
argument_list|)
operator|)
name|bfd_void
block|,
comment|/* sym_out */
operator|(
name|unsigned
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
expr|,
name|PTR
expr|,
name|PTR
operator|)
argument_list|)
operator|)
name|bfd_void
block|,
comment|/* lineno_out */
operator|(
name|unsigned
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
expr|,
name|PTR
expr|,
name|PTR
operator|)
argument_list|)
operator|)
name|bfd_void
block|,
comment|/* reloc_out */
name|alpha_ecoff_swap_filehdr_out
block|,
name|alpha_ecoff_swap_aouthdr_out
block|,
name|alpha_ecoff_swap_scnhdr_out
block|,
name|FILHSZ
block|,
name|AOUTSZ
block|,
name|SCNHSZ
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FILNMLEN
block|,
name|true
block|,
name|false
block|,
literal|4
block|,
name|false
block|,
literal|2
block|,
name|alpha_ecoff_swap_filehdr_in
block|,
name|alpha_ecoff_swap_aouthdr_in
block|,
name|alpha_ecoff_swap_scnhdr_in
block|,
name|NULL
block|,
name|alpha_ecoff_bad_format_hook
block|,
name|_bfd_ecoff_set_arch_mach_hook
block|,
name|alpha_ecoff_mkobject_hook
block|,
name|_bfd_ecoff_styp_to_sec_flags
block|,
name|_bfd_ecoff_set_alignment_hook
block|,
name|_bfd_ecoff_slurp_symbol_table
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Supported architecture.  */
name|bfd_arch_alpha
block|,
comment|/* Initial portion of armap string.  */
literal|"________64"
block|,
comment|/* The page boundary used to align sections in a demand-paged      executable file.  E.g., 0x1000.  */
literal|0x2000
block|,
comment|/* True if the .rdata section is part of the text segment, as on the      Alpha.  False if .rdata is part of the data segment, as on the      MIPS.  */
name|true
block|,
comment|/* Bitsize of constructor entries.  */
literal|64
block|,
comment|/* Reloc to use for constructor entries.  */
operator|&
name|alpha_howto_table
index|[
name|ALPHA_R_REFQUAD
index|]
block|,
block|{
comment|/* Symbol table magic number.  */
name|magicSym2
block|,
comment|/* Alignment of debugging information.  E.g., 4.  */
literal|8
block|,
comment|/* Sizes of external symbolic information.  */
sizeof|sizeof
argument_list|(
expr|struct
name|hdr_ext
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|dnr_ext
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|pdr_ext
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|sym_ext
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|opt_ext
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|fdr_ext
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|rfd_ext
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ext_ext
argument_list|)
block|,
comment|/* Functions to swap in external symbolic data.  */
name|ecoff_swap_hdr_in
block|,
name|ecoff_swap_dnr_in
block|,
name|ecoff_swap_pdr_in
block|,
name|ecoff_swap_sym_in
block|,
name|ecoff_swap_opt_in
block|,
name|ecoff_swap_fdr_in
block|,
name|ecoff_swap_rfd_in
block|,
name|ecoff_swap_ext_in
block|,
name|_bfd_ecoff_swap_tir_in
block|,
name|_bfd_ecoff_swap_rndx_in
block|,
comment|/* Functions to swap out external symbolic data.  */
name|ecoff_swap_hdr_out
block|,
name|ecoff_swap_dnr_out
block|,
name|ecoff_swap_pdr_out
block|,
name|ecoff_swap_sym_out
block|,
name|ecoff_swap_opt_out
block|,
name|ecoff_swap_fdr_out
block|,
name|ecoff_swap_rfd_out
block|,
name|ecoff_swap_ext_out
block|,
name|_bfd_ecoff_swap_tir_out
block|,
name|_bfd_ecoff_swap_rndx_out
block|,
comment|/* Function to read in symbolic data.  */
name|_bfd_ecoff_slurp_symbolic_info
block|}
block|,
comment|/* External reloc size.  */
name|RELSZ
block|,
comment|/* Reloc swapping functions.  */
name|alpha_ecoff_swap_reloc_in
block|,
name|alpha_ecoff_swap_reloc_out
block|,
comment|/* Backend reloc tweaking.  */
name|alpha_adjust_reloc_in
block|,
name|alpha_adjust_reloc_out
block|,
comment|/* Relocate section contents while linking.  */
name|alpha_relocate_section
block|,
comment|/* Do final adjustments to filehdr and aouthdr.  */
name|alpha_adjust_headers
block|,
comment|/* Read an element from an archive at a given file position.  */
name|alpha_ecoff_get_elt_at_filepos
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Looking up a reloc type is Alpha specific.  */
end_comment

begin_define
define|#
directive|define
name|_bfd_ecoff_bfd_reloc_type_lookup
value|alpha_bfd_reloc_type_lookup
end_define

begin_comment
comment|/* So is getting relocated section contents.  */
end_comment

begin_define
define|#
directive|define
name|_bfd_ecoff_bfd_get_relocated_section_contents
define|\
value|alpha_ecoff_get_relocated_section_contents
end_define

begin_comment
comment|/* Handling file windows is generic.  */
end_comment

begin_define
define|#
directive|define
name|_bfd_ecoff_get_section_contents_in_window
define|\
value|_bfd_generic_get_section_contents_in_window
end_define

begin_comment
comment|/* Relaxing sections is generic.  */
end_comment

begin_define
define|#
directive|define
name|_bfd_ecoff_bfd_relax_section
value|bfd_generic_relax_section
end_define

begin_define
define|#
directive|define
name|_bfd_ecoff_bfd_gc_sections
value|bfd_generic_gc_sections
end_define

begin_decl_stmt
specifier|const
name|bfd_target
name|ecoffalpha_little_vec
init|=
block|{
literal|"ecoff-littlealpha"
block|,
comment|/* name */
name|bfd_target_ecoff_flavour
block|,
name|BFD_ENDIAN_LITTLE
block|,
comment|/* data byte order is little */
name|BFD_ENDIAN_LITTLE
block|,
comment|/* header byte order is little */
operator|(
name|HAS_RELOC
operator||
name|EXEC_P
operator||
comment|/* object flags */
name|HAS_LINENO
operator||
name|HAS_DEBUG
operator||
name|HAS_SYMS
operator||
name|HAS_LOCALS
operator||
name|DYNAMIC
operator||
name|WP_TEXT
operator||
name|D_PAGED
operator|)
block|,
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator||
name|SEC_CODE
operator||
name|SEC_DATA
operator|)
block|,
literal|0
block|,
comment|/* leading underscore */
literal|' '
block|,
comment|/* ar_pad_char */
literal|15
block|,
comment|/* ar_max_namelen */
name|bfd_getl64
block|,
name|bfd_getl_signed_64
block|,
name|bfd_putl64
block|,
name|bfd_getl32
block|,
name|bfd_getl_signed_32
block|,
name|bfd_putl32
block|,
name|bfd_getl16
block|,
name|bfd_getl_signed_16
block|,
name|bfd_putl16
block|,
comment|/* data */
name|bfd_getl64
block|,
name|bfd_getl_signed_64
block|,
name|bfd_putl64
block|,
name|bfd_getl32
block|,
name|bfd_getl_signed_32
block|,
name|bfd_putl32
block|,
name|bfd_getl16
block|,
name|bfd_getl_signed_16
block|,
name|bfd_putl16
block|,
comment|/* hdrs */
block|{
name|_bfd_dummy_target
block|,
name|alpha_ecoff_object_p
block|,
comment|/* bfd_check_format */
name|_bfd_ecoff_archive_p
block|,
name|_bfd_dummy_target
block|}
block|,
block|{
name|bfd_false
block|,
name|_bfd_ecoff_mkobject
block|,
comment|/* bfd_set_format */
name|_bfd_generic_mkarchive
block|,
name|bfd_false
block|}
block|,
block|{
name|bfd_false
block|,
name|_bfd_ecoff_write_object_contents
block|,
comment|/* bfd_write_contents */
name|_bfd_write_archive_contents
block|,
name|bfd_false
block|}
block|,
name|BFD_JUMP_TABLE_GENERIC
argument_list|(
name|_bfd_ecoff
argument_list|)
block|,
name|BFD_JUMP_TABLE_COPY
argument_list|(
name|_bfd_ecoff
argument_list|)
block|,
name|BFD_JUMP_TABLE_CORE
argument_list|(
name|_bfd_nocore
argument_list|)
block|,
name|BFD_JUMP_TABLE_ARCHIVE
argument_list|(
name|alpha_ecoff
argument_list|)
block|,
name|BFD_JUMP_TABLE_SYMBOLS
argument_list|(
name|_bfd_ecoff
argument_list|)
block|,
name|BFD_JUMP_TABLE_RELOCS
argument_list|(
name|_bfd_ecoff
argument_list|)
block|,
name|BFD_JUMP_TABLE_WRITE
argument_list|(
name|_bfd_ecoff
argument_list|)
block|,
name|BFD_JUMP_TABLE_LINK
argument_list|(
name|_bfd_ecoff
argument_list|)
block|,
name|BFD_JUMP_TABLE_DYNAMIC
argument_list|(
name|_bfd_nodynamic
argument_list|)
block|,
name|NULL
block|,
operator|(
name|PTR
operator|)
operator|&
name|alpha_ecoff_backend_data
block|}
decl_stmt|;
end_decl_stmt

end_unit

