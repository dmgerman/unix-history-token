begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD back end for traditional Unix core files (U-area and raw sections)    Copyright 1988, 89, 91, 92, 93, 94, 95, 96, 98, 99, 2000    Free Software Foundation, Inc.    Written by John Gilmore of Cygnus Support.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"libaout.h"
end_include

begin_comment
comment|/* BFD a.out internal data structures */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_comment
comment|/* After a.out.h  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TRAD_HEADER
end_ifdef

begin_include
include|#
directive|include
include|TRAD_HEADER
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|trad_core_struct
block|{
name|asection
modifier|*
name|data_section
decl_stmt|;
name|asection
modifier|*
name|stack_section
decl_stmt|;
name|asection
modifier|*
name|reg_section
decl_stmt|;
name|struct
name|user
name|u
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|core_upage
parameter_list|(
name|bfd
parameter_list|)
value|(&((bfd)->tdata.trad_core_data->u))
end_define

begin_define
define|#
directive|define
name|core_datasec
parameter_list|(
name|bfd
parameter_list|)
value|((bfd)->tdata.trad_core_data->data_section)
end_define

begin_define
define|#
directive|define
name|core_stacksec
parameter_list|(
name|bfd
parameter_list|)
value|((bfd)->tdata.trad_core_data->stack_section)
end_define

begin_define
define|#
directive|define
name|core_regsec
parameter_list|(
name|bfd
parameter_list|)
value|((bfd)->tdata.trad_core_data->reg_section)
end_define

begin_comment
comment|/* forward declarations */
end_comment

begin_decl_stmt
specifier|const
name|bfd_target
modifier|*
name|trad_unix_core_file_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|trad_unix_core_file_failing_command
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|trad_unix_core_file_failing_signal
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|trad_unix_core_file_matches_executable_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|core_bfd
operator|,
name|bfd
operator|*
name|exec_bfd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|swap_abort
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Handle 4.2-style (and perhaps also sysV-style) core dump file.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|const
name|bfd_target
modifier|*
name|trad_unix_core_file_p
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|int
name|val
decl_stmt|;
name|struct
name|user
name|u
decl_stmt|;
name|struct
name|trad_core_struct
modifier|*
name|rawptr
decl_stmt|;
ifdef|#
directive|ifdef
name|TRAD_CORE_USER_OFFSET
comment|/* If defined, this macro is the file position of the user struct.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|TRAD_CORE_USER_OFFSET
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
name|val
operator|=
name|bfd_read
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|u
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
name|u
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
sizeof|sizeof
name|u
condition|)
block|{
comment|/* Too small to be a core file */
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Sanity check perhaps??? */
if|if
condition|(
name|u
operator|.
name|u_dsize
operator|>
literal|0x1000000
condition|)
comment|/* Remember, it's in pages... */
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|u
operator|.
name|u_ssize
operator|>
literal|0x1000000
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Check that the size claimed is no greater than the file size.  */
block|{
name|FILE
modifier|*
name|stream
init|=
name|bfd_cache_lookup
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
if|if
condition|(
name|stream
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|stream
argument_list|)
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|NBPG
operator|*
operator|(
name|UPAGES
operator|+
name|u
operator|.
name|u_dsize
ifdef|#
directive|ifdef
name|TRAD_CORE_DSIZE_INCLUDES_TSIZE
operator|-
name|u
operator|.
name|u_tsize
endif|#
directive|endif
operator|+
name|u
operator|.
name|u_ssize
operator|)
argument_list|)
operator|>
operator|(
name|unsigned
name|long
operator|)
name|statbuf
operator|.
name|st_size
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
ifndef|#
directive|ifndef
name|TRAD_CORE_ALLOW_ANY_EXTRA_SIZE
if|if
condition|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|NBPG
operator|*
operator|(
name|UPAGES
operator|+
name|u
operator|.
name|u_dsize
operator|+
name|u
operator|.
name|u_ssize
operator|)
ifdef|#
directive|ifdef
name|TRAD_CORE_EXTRA_SIZE_ALLOWED
comment|/* Some systems write the file too big.  */
operator|+
name|TRAD_CORE_EXTRA_SIZE_ALLOWED
endif|#
directive|endif
argument_list|)
operator|<
operator|(
name|unsigned
name|long
operator|)
name|statbuf
operator|.
name|st_size
condition|)
block|{
comment|/* The file is too big.  Maybe it's not a core file 	   or we otherwise have bad values for u_dsize and u_ssize).  */
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
block|}
comment|/* OK, we believe you.  You're a core file (sure, sure).  */
comment|/* Allocate both the upage and the struct core_data at once, so      a single free() will free them both.  */
name|rawptr
operator|=
operator|(
expr|struct
name|trad_core_struct
operator|*
operator|)
name|bfd_zmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|trad_core_struct
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rawptr
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|abfd
operator|->
name|tdata
operator|.
name|trad_core_data
operator|=
name|rawptr
expr_stmt|;
name|rawptr
operator|->
name|u
operator|=
name|u
expr_stmt|;
comment|/*Copy the uarea into the tdata part of the bfd */
comment|/* Create the sections.  This is raunchy, but bfd_close wants to free      them separately.  */
name|core_stacksec
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
name|asection
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|asection
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|core_stacksec
argument_list|(
name|abfd
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|core_datasec
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
name|asection
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|asection
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|core_datasec
argument_list|(
name|abfd
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|core_regsec
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
name|asection
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|asection
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|core_regsec
argument_list|(
name|abfd
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|core_stacksec
argument_list|(
name|abfd
argument_list|)
operator|->
name|name
operator|=
literal|".stack"
expr_stmt|;
name|core_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|name
operator|=
literal|".data"
expr_stmt|;
name|core_regsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|name
operator|=
literal|".reg"
expr_stmt|;
name|core_stacksec
argument_list|(
name|abfd
argument_list|)
operator|->
name|flags
operator|=
name|SEC_ALLOC
operator|+
name|SEC_LOAD
operator|+
name|SEC_HAS_CONTENTS
expr_stmt|;
name|core_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|flags
operator|=
name|SEC_ALLOC
operator|+
name|SEC_LOAD
operator|+
name|SEC_HAS_CONTENTS
expr_stmt|;
name|core_regsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|flags
operator|=
name|SEC_HAS_CONTENTS
expr_stmt|;
name|core_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
operator|=
name|NBPG
operator|*
name|u
operator|.
name|u_dsize
ifdef|#
directive|ifdef
name|TRAD_CORE_DSIZE_INCLUDES_TSIZE
operator|-
name|NBPG
operator|*
name|u
operator|.
name|u_tsize
endif|#
directive|endif
expr_stmt|;
name|core_stacksec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
operator|=
name|NBPG
operator|*
name|u
operator|.
name|u_ssize
expr_stmt|;
name|core_regsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
operator|=
name|NBPG
operator|*
name|UPAGES
expr_stmt|;
comment|/* Larger than sizeof struct u */
comment|/* What a hack... we'd like to steal it from the exec file,      since the upage does not seem to provide it.  FIXME.  */
ifdef|#
directive|ifdef
name|HOST_DATA_START_ADDR
name|core_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|=
name|HOST_DATA_START_ADDR
expr_stmt|;
else|#
directive|else
name|core_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|=
name|HOST_TEXT_START_ADDR
operator|+
operator|(
name|NBPG
operator|*
name|u
operator|.
name|u_tsize
operator|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HOST_STACK_START_ADDR
name|core_stacksec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|=
name|HOST_STACK_START_ADDR
expr_stmt|;
else|#
directive|else
name|core_stacksec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|=
name|HOST_STACK_END_ADDR
operator|-
operator|(
name|NBPG
operator|*
name|u
operator|.
name|u_ssize
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* This is tricky.  As the "register section", we give them the entire      upage and stack.  u.u_ar0 points to where "register 0" is stored.      There are two tricks with this, though.  One is that the rest of the      registers might be at positive or negative (or both) displacements      from *u_ar0.  The other is that u_ar0 is sometimes an absolute address      in kernel memory, and on other systems it is an offset from the beginning      of the `struct user'.            As a practical matter, we don't know where the registers actually are,      so we have to pass the whole area to GDB.  We encode the value of u_ar0      by setting the .regs section up so that its virtual memory address      0 is at the place pointed to by u_ar0 (by setting the vma of the start      of the section to -u_ar0).  GDB uses this info to locate the regs,      using minor trickery to get around the offset-or-absolute-addr problem. */
name|core_regsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|=
operator|-
operator|(
name|bfd_vma
operator|)
name|u
operator|.
name|u_ar0
expr_stmt|;
name|core_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|filepos
operator|=
name|NBPG
operator|*
name|UPAGES
expr_stmt|;
name|core_stacksec
argument_list|(
name|abfd
argument_list|)
operator|->
name|filepos
operator|=
operator|(
name|NBPG
operator|*
name|UPAGES
operator|)
operator|+
name|NBPG
operator|*
name|u
operator|.
name|u_dsize
ifdef|#
directive|ifdef
name|TRAD_CORE_DSIZE_INCLUDES_TSIZE
operator|-
name|NBPG
operator|*
name|u
operator|.
name|u_tsize
endif|#
directive|endif
expr_stmt|;
name|core_regsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|filepos
operator|=
literal|0
expr_stmt|;
comment|/* Register segment is the upage */
comment|/* Align to word at least */
name|core_stacksec
argument_list|(
name|abfd
argument_list|)
operator|->
name|alignment_power
operator|=
literal|2
expr_stmt|;
name|core_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|alignment_power
operator|=
literal|2
expr_stmt|;
name|core_regsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|alignment_power
operator|=
literal|2
expr_stmt|;
name|abfd
operator|->
name|sections
operator|=
name|core_stacksec
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|core_stacksec
argument_list|(
name|abfd
argument_list|)
operator|->
name|next
operator|=
name|core_datasec
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|core_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|next
operator|=
name|core_regsec
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|section_count
operator|=
literal|3
expr_stmt|;
return|return
name|abfd
operator|->
name|xvec
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|trad_unix_core_file_failing_command
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|NO_CORE_COMMAND
name|char
modifier|*
name|com
init|=
name|abfd
operator|->
name|tdata
operator|.
name|trad_core_data
operator|->
name|u
operator|.
name|u_comm
decl_stmt|;
if|if
condition|(
operator|*
name|com
condition|)
return|return
name|com
return|;
else|else
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|trad_unix_core_file_failing_signal
parameter_list|(
name|ignore_abfd
parameter_list|)
name|bfd
modifier|*
name|ignore_abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|TRAD_UNIX_CORE_FILE_FAILING_SIGNAL
return|return
name|TRAD_UNIX_CORE_FILE_FAILING_SIGNAL
argument_list|(
name|ignore_abfd
argument_list|)
return|;
else|#
directive|else
return|return
operator|-
literal|1
return|;
comment|/* FIXME, where is it? */
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|boolean
name|trad_unix_core_file_matches_executable_p
parameter_list|(
name|core_bfd
parameter_list|,
name|exec_bfd
parameter_list|)
name|bfd
modifier|*
name|core_bfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd
modifier|*
name|exec_bfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|true
return|;
comment|/* FIXME, We have no way of telling at this point */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If somebody calls any byte-swapping routines, shoot them.  */
end_comment

begin_function
specifier|static
name|void
name|swap_abort
parameter_list|()
block|{
name|abort
argument_list|()
expr_stmt|;
comment|/* This way doesn't require any declaration for ANSI to fuck up */
block|}
end_function

begin_define
define|#
directive|define
name|NO_GET
value|((bfd_vma (*) PARAMS ((   const bfd_byte *))) swap_abort )
end_define

begin_define
define|#
directive|define
name|NO_PUT
value|((void    (*) PARAMS ((bfd_vma, bfd_byte *))) swap_abort )
end_define

begin_define
define|#
directive|define
name|NO_SIGNED_GET
define|\
value|((bfd_signed_vma (*) PARAMS ((const bfd_byte *))) swap_abort )
end_define

begin_decl_stmt
specifier|const
name|bfd_target
name|trad_core_vec
init|=
block|{
literal|"trad-core"
block|,
name|bfd_target_unknown_flavour
block|,
name|BFD_ENDIAN_UNKNOWN
block|,
comment|/* target byte order */
name|BFD_ENDIAN_UNKNOWN
block|,
comment|/* target headers byte order */
operator|(
name|HAS_RELOC
operator||
name|EXEC_P
operator||
comment|/* object flags */
name|HAS_LINENO
operator||
name|HAS_DEBUG
operator||
name|HAS_SYMS
operator||
name|HAS_LOCALS
operator||
name|WP_TEXT
operator||
name|D_PAGED
operator|)
block|,
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator|)
block|,
comment|/* section flags */
literal|0
block|,
comment|/* symbol prefix */
literal|' '
block|,
comment|/* ar_pad_char */
literal|16
block|,
comment|/* ar_max_namelen */
name|NO_GET
block|,
name|NO_SIGNED_GET
block|,
name|NO_PUT
block|,
comment|/* 64 bit data */
name|NO_GET
block|,
name|NO_SIGNED_GET
block|,
name|NO_PUT
block|,
comment|/* 32 bit data */
name|NO_GET
block|,
name|NO_SIGNED_GET
block|,
name|NO_PUT
block|,
comment|/* 16 bit data */
name|NO_GET
block|,
name|NO_SIGNED_GET
block|,
name|NO_PUT
block|,
comment|/* 64 bit hdrs */
name|NO_GET
block|,
name|NO_SIGNED_GET
block|,
name|NO_PUT
block|,
comment|/* 32 bit hdrs */
name|NO_GET
block|,
name|NO_SIGNED_GET
block|,
name|NO_PUT
block|,
comment|/* 16 bit hdrs */
block|{
comment|/* bfd_check_format */
name|_bfd_dummy_target
block|,
comment|/* unknown format */
name|_bfd_dummy_target
block|,
comment|/* object file */
name|_bfd_dummy_target
block|,
comment|/* archive */
name|trad_unix_core_file_p
comment|/* a core file */
block|}
block|,
block|{
comment|/* bfd_set_format */
name|bfd_false
block|,
name|bfd_false
block|,
name|bfd_false
block|,
name|bfd_false
block|}
block|,
block|{
comment|/* bfd_write_contents */
name|bfd_false
block|,
name|bfd_false
block|,
name|bfd_false
block|,
name|bfd_false
block|}
block|,
name|BFD_JUMP_TABLE_GENERIC
argument_list|(
name|_bfd_generic
argument_list|)
block|,
name|BFD_JUMP_TABLE_COPY
argument_list|(
name|_bfd_generic
argument_list|)
block|,
name|BFD_JUMP_TABLE_CORE
argument_list|(
name|trad_unix
argument_list|)
block|,
name|BFD_JUMP_TABLE_ARCHIVE
argument_list|(
name|_bfd_noarchive
argument_list|)
block|,
name|BFD_JUMP_TABLE_SYMBOLS
argument_list|(
name|_bfd_nosymbols
argument_list|)
block|,
name|BFD_JUMP_TABLE_RELOCS
argument_list|(
name|_bfd_norelocs
argument_list|)
block|,
name|BFD_JUMP_TABLE_WRITE
argument_list|(
name|_bfd_generic
argument_list|)
block|,
name|BFD_JUMP_TABLE_LINK
argument_list|(
name|_bfd_nolink
argument_list|)
block|,
name|BFD_JUMP_TABLE_DYNAMIC
argument_list|(
name|_bfd_nodynamic
argument_list|)
block|,
name|NULL
block|,
operator|(
name|PTR
operator|)
literal|0
comment|/* backend_data */
block|}
decl_stmt|;
end_decl_stmt

end_unit

