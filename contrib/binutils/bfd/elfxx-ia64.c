begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* IA-64 support for 64-bit ELF    Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004    Free Software Foundation, Inc.    Contributed by David Mosberger-Tang<davidm@hpl.hp.com>     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"opcode/ia64.h"
end_include

begin_include
include|#
directive|include
file|"elf/ia64.h"
end_include

begin_include
include|#
directive|include
file|"objalloc.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_comment
comment|/* THE RULES for all the stuff the linker creates --    GOT		Entries created in response to LTOFF or LTOFF_FPTR  		relocations.  Dynamic relocs created for dynamic  		symbols in an application; REL relocs for locals  		in a shared library.    FPTR		The canonical function descriptor.  Created for local  		symbols in applications.  Descriptors for dynamic symbols  		and local symbols in shared libraries are created by  		ld.so.  Thus there are no dynamic relocs against these  		objects.  The FPTR relocs for such _are_ passed through  		to the dynamic relocation tables.    FULL_PLT	Created for a PCREL21B relocation against a dynamic symbol.  		Requires the creation of a PLTOFF entry.  This does not  		require any dynamic relocations.    PLTOFF	Created by PLTOFF relocations.  For local symbols, this  		is an alternate function descriptor, and in shared libraries  		requires two REL relocations.  Note that this cannot be  		transformed into an FPTR relocation, since it must be in  		range of the GP.  For dynamic symbols, this is a function  		descriptor for a MIN_PLT entry, and requires one IPLT reloc.    MIN_PLT	Created by PLTOFF entries against dynamic symbols.  This  		does not require dynamic relocations.  */
end_comment

begin_define
define|#
directive|define
name|NELEMS
parameter_list|(
name|a
parameter_list|)
value|((int) (sizeof (a) / sizeof ((a)[0])))
end_define

begin_typedef
typedef|typedef
name|struct
name|bfd_hash_entry
modifier|*
argument_list|(
operator|*
name|new_hash_entry_func
argument_list|)
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|,
expr|struct
name|bfd_hash_table
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
typedef|;
end_typedef

begin_comment
comment|/* In dynamically (linker-) created sections, we generally need to keep track    of the place a symbol or expression got allocated to. This is done via hash    tables that store entries of the following type.  */
end_comment

begin_struct
struct|struct
name|elfNN_ia64_dyn_sym_info
block|{
comment|/* The addend for which this entry is relevant.  */
name|bfd_vma
name|addend
decl_stmt|;
comment|/* Next addend in the list.  */
name|struct
name|elfNN_ia64_dyn_sym_info
modifier|*
name|next
decl_stmt|;
name|bfd_vma
name|got_offset
decl_stmt|;
name|bfd_vma
name|fptr_offset
decl_stmt|;
name|bfd_vma
name|pltoff_offset
decl_stmt|;
name|bfd_vma
name|plt_offset
decl_stmt|;
name|bfd_vma
name|plt2_offset
decl_stmt|;
name|bfd_vma
name|tprel_offset
decl_stmt|;
name|bfd_vma
name|dtpmod_offset
decl_stmt|;
name|bfd_vma
name|dtprel_offset
decl_stmt|;
comment|/* The symbol table entry, if any, that this was derived from.  */
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
comment|/* Used to count non-got, non-plt relocations for delayed sizing      of relocation sections.  */
struct|struct
name|elfNN_ia64_dyn_reloc_entry
block|{
name|struct
name|elfNN_ia64_dyn_reloc_entry
modifier|*
name|next
decl_stmt|;
name|asection
modifier|*
name|srel
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|count
decl_stmt|;
comment|/* Is this reloc against readonly section? */
name|bfd_boolean
name|reltext
decl_stmt|;
block|}
modifier|*
name|reloc_entries
struct|;
comment|/* TRUE when the section contents have been updated.  */
name|unsigned
name|got_done
range|:
literal|1
decl_stmt|;
name|unsigned
name|fptr_done
range|:
literal|1
decl_stmt|;
name|unsigned
name|pltoff_done
range|:
literal|1
decl_stmt|;
name|unsigned
name|tprel_done
range|:
literal|1
decl_stmt|;
name|unsigned
name|dtpmod_done
range|:
literal|1
decl_stmt|;
name|unsigned
name|dtprel_done
range|:
literal|1
decl_stmt|;
comment|/* TRUE for the different kinds of linker data we want created.  */
name|unsigned
name|want_got
range|:
literal|1
decl_stmt|;
name|unsigned
name|want_gotx
range|:
literal|1
decl_stmt|;
name|unsigned
name|want_fptr
range|:
literal|1
decl_stmt|;
name|unsigned
name|want_ltoff_fptr
range|:
literal|1
decl_stmt|;
name|unsigned
name|want_plt
range|:
literal|1
decl_stmt|;
name|unsigned
name|want_plt2
range|:
literal|1
decl_stmt|;
name|unsigned
name|want_pltoff
range|:
literal|1
decl_stmt|;
name|unsigned
name|want_tprel
range|:
literal|1
decl_stmt|;
name|unsigned
name|want_dtpmod
range|:
literal|1
decl_stmt|;
name|unsigned
name|want_dtprel
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|elfNN_ia64_local_hash_entry
block|{
name|int
name|id
decl_stmt|;
name|unsigned
name|int
name|r_sym
decl_stmt|;
name|struct
name|elfNN_ia64_dyn_sym_info
modifier|*
name|info
decl_stmt|;
comment|/* TRUE if this hash entry's addends was translated for      SHF_MERGE optimization.  */
name|unsigned
name|sec_merge_done
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|elfNN_ia64_link_hash_entry
block|{
name|struct
name|elf_link_hash_entry
name|root
decl_stmt|;
name|struct
name|elfNN_ia64_dyn_sym_info
modifier|*
name|info
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|elfNN_ia64_link_hash_table
block|{
comment|/* The main hash table.  */
name|struct
name|elf_link_hash_table
name|root
decl_stmt|;
name|asection
modifier|*
name|got_sec
decl_stmt|;
comment|/* the linkage table section (or NULL) */
name|asection
modifier|*
name|rel_got_sec
decl_stmt|;
comment|/* dynamic relocation section for same */
name|asection
modifier|*
name|fptr_sec
decl_stmt|;
comment|/* function descriptor table (or NULL) */
name|asection
modifier|*
name|rel_fptr_sec
decl_stmt|;
comment|/* dynamic relocation section for same */
name|asection
modifier|*
name|plt_sec
decl_stmt|;
comment|/* the primary plt section (or NULL) */
name|asection
modifier|*
name|pltoff_sec
decl_stmt|;
comment|/* private descriptors for plt (or NULL) */
name|asection
modifier|*
name|rel_pltoff_sec
decl_stmt|;
comment|/* dynamic relocation section for same */
name|bfd_size_type
name|minplt_entries
decl_stmt|;
comment|/* number of minplt entries */
name|unsigned
name|reltext
range|:
literal|1
decl_stmt|;
comment|/* are there relocs against readonly sections? */
name|unsigned
name|self_dtpmod_done
range|:
literal|1
decl_stmt|;
comment|/* has self DTPMOD entry been finished? */
name|bfd_vma
name|self_dtpmod_offset
decl_stmt|;
comment|/* .got offset to self DTPMOD entry */
name|htab_t
name|loc_hash_table
decl_stmt|;
name|void
modifier|*
name|loc_hash_memory
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|elfNN_ia64_allocate_data
block|{
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd_size_type
name|ofs
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|elfNN_ia64_hash_table
parameter_list|(
name|p
parameter_list|)
define|\
value|((struct elfNN_ia64_link_hash_table *) ((p)->hash))
end_define

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|elfNN_ia64_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|arelent
operator|*
name|reloc
operator|,
name|asymbol
operator|*
name|sym
operator|,
name|PTR
name|data
operator|,
name|asection
operator|*
name|input_section
operator|,
name|bfd
operator|*
name|output_bfd
operator|,
name|char
operator|*
operator|*
name|error_message
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
modifier|*
name|lookup_howto
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
name|rtype
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
modifier|*
name|elfNN_ia64_reloc_type_lookup
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|bfd_reloc_code_real_type
name|bfd_code
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|elfNN_ia64_info_to_howto
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|arelent
operator|*
name|bfd_reloc
operator|,
name|Elf_Internal_Rela
operator|*
name|elf_reloc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elfNN_ia64_relax_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|asection
operator|*
name|sec
operator|,
expr|struct
name|bfd_link_info
operator|*
name|link_info
operator|,
name|bfd_boolean
operator|*
name|again
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|elfNN_ia64_relax_ldxmov
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|bfd_byte
operator|*
name|contents
operator|,
name|bfd_vma
name|off
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|is_unwind_section_name
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elfNN_ia64_section_from_shdr
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf_Internal_Shdr
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elfNN_ia64_section_flags
name|PARAMS
argument_list|(
operator|(
name|flagword
operator|*
operator|,
name|Elf_Internal_Shdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elfNN_ia64_fake_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|Elf_Internal_Shdr
operator|*
name|hdr
operator|,
name|asection
operator|*
name|sec
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|elfNN_ia64_final_write_processing
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|bfd_boolean
name|linker
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elfNN_ia64_add_symbol_hook
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|,
name|Elf_Internal_Sym
operator|*
name|sym
operator|,
specifier|const
name|char
operator|*
operator|*
name|namep
operator|,
name|flagword
operator|*
name|flagsp
operator|,
name|asection
operator|*
operator|*
name|secp
operator|,
name|bfd_vma
operator|*
name|valp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|elfNN_ia64_additional_program_headers
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elfNN_ia64_modify_segment_map
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elfNN_ia64_is_local_label_name
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
specifier|const
name|char
operator|*
name|name
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elfNN_ia64_dynamic_symbol_p
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
name|h
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|elfNN_ia64_new_elf_hash_entry
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
name|entry
operator|,
expr|struct
name|bfd_hash_table
operator|*
name|table
operator|,
specifier|const
name|char
operator|*
name|string
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|elfNN_ia64_hash_copy_indirect
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|elf_backend_data
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|elfNN_ia64_hash_hide_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|bfd_boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|hashval_t
name|elfNN_ia64_local_htab_hash
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|elfNN_ia64_local_htab_eq
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
name|ptr1
operator|,
specifier|const
name|void
operator|*
name|ptr2
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bfd_link_hash_table
modifier|*
name|elfNN_ia64_hash_table_create
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|elfNN_ia64_hash_table_free
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_hash_table
operator|*
name|hash
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elfNN_ia64_global_dyn_sym_thunk
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|elfNN_ia64_local_dyn_sym_thunk
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|elfNN_ia64_dyn_sym_traverse
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elfNN_ia64_link_hash_table
operator|*
name|ia64_info
operator|,
name|bfd_boolean
argument_list|(
operator|*
name|func
argument_list|)
argument_list|(
expr|struct
name|elfNN_ia64_dyn_sym_info
operator|*
argument_list|,
name|PTR
argument_list|)
operator|,
name|PTR
name|info
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elfNN_ia64_create_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|elfNN_ia64_local_hash_entry
modifier|*
name|get_local_sym_hash
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elfNN_ia64_link_hash_table
operator|*
name|ia64_info
operator|,
name|bfd
operator|*
name|abfd
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
name|rel
operator|,
name|bfd_boolean
name|create
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|elfNN_ia64_dyn_sym_info
modifier|*
name|get_dyn_sym_info
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elfNN_ia64_link_hash_table
operator|*
name|ia64_info
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
name|h
operator|,
name|bfd
operator|*
name|abfd
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
name|rel
operator|,
name|bfd_boolean
name|create
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asection
modifier|*
name|get_got
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|,
expr|struct
name|elfNN_ia64_link_hash_table
operator|*
name|ia64_info
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asection
modifier|*
name|get_fptr
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|,
expr|struct
name|elfNN_ia64_link_hash_table
operator|*
name|ia64_info
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asection
modifier|*
name|get_pltoff
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|,
expr|struct
name|elfNN_ia64_link_hash_table
operator|*
name|ia64_info
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asection
modifier|*
name|get_reloc_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
expr|struct
name|elfNN_ia64_link_hash_table
operator|*
name|ia64_info
operator|,
name|asection
operator|*
name|sec
operator|,
name|bfd_boolean
name|create
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elfNN_ia64_check_relocs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|,
name|asection
operator|*
name|sec
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
name|relocs
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elfNN_ia64_adjust_dynamic_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
name|info
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
name|h
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|global_sym_index
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
name|h
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|allocate_fptr
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elfNN_ia64_dyn_sym_info
operator|*
name|dyn_i
operator|,
name|PTR
name|data
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|allocate_global_data_got
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elfNN_ia64_dyn_sym_info
operator|*
name|dyn_i
operator|,
name|PTR
name|data
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|allocate_global_fptr_got
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elfNN_ia64_dyn_sym_info
operator|*
name|dyn_i
operator|,
name|PTR
name|data
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|allocate_local_got
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elfNN_ia64_dyn_sym_info
operator|*
name|dyn_i
operator|,
name|PTR
name|data
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|allocate_pltoff_entries
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elfNN_ia64_dyn_sym_info
operator|*
name|dyn_i
operator|,
name|PTR
name|data
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|allocate_plt_entries
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elfNN_ia64_dyn_sym_info
operator|*
name|dyn_i
operator|,
name|PTR
name|data
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|allocate_plt2_entries
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elfNN_ia64_dyn_sym_info
operator|*
name|dyn_i
operator|,
name|PTR
name|data
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|allocate_dynrel_entries
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elfNN_ia64_dyn_sym_info
operator|*
name|dyn_i
operator|,
name|PTR
name|data
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elfNN_ia64_size_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|output_bfd
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|elfNN_ia64_install_value
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|bfd_byte
operator|*
name|hit_addr
operator|,
name|bfd_vma
name|val
operator|,
name|unsigned
name|int
name|r_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|elfNN_ia64_install_dyn_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|,
name|asection
operator|*
name|sec
operator|,
name|asection
operator|*
name|srel
operator|,
name|bfd_vma
name|offset
operator|,
name|unsigned
name|int
name|type
operator|,
name|long
name|dynindx
operator|,
name|bfd_vma
name|addend
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|set_got_entry
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|,
expr|struct
name|elfNN_ia64_dyn_sym_info
operator|*
name|dyn_i
operator|,
name|long
name|dynindx
operator|,
name|bfd_vma
name|addend
operator|,
name|bfd_vma
name|value
operator|,
name|unsigned
name|int
name|dyn_r_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|set_fptr_entry
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|,
expr|struct
name|elfNN_ia64_dyn_sym_info
operator|*
name|dyn_i
operator|,
name|bfd_vma
name|value
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|set_pltoff_entry
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|,
expr|struct
name|elfNN_ia64_dyn_sym_info
operator|*
name|dyn_i
operator|,
name|bfd_vma
name|value
operator|,
name|bfd_boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|elfNN_ia64_tprel_base
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
name|info
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|elfNN_ia64_dtprel_base
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
name|info
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|elfNN_ia64_unwind_entry_compare
name|PARAMS
argument_list|(
operator|(
specifier|const
name|PTR
operator|,
specifier|const
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elfNN_ia64_choose_gp
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elfNN_ia64_final_link
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elfNN_ia64_relocate_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|output_bfd
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|,
name|bfd
operator|*
name|input_bfd
operator|,
name|asection
operator|*
name|input_section
operator|,
name|bfd_byte
operator|*
name|contents
operator|,
name|Elf_Internal_Rela
operator|*
name|relocs
operator|,
name|Elf_Internal_Sym
operator|*
name|local_syms
operator|,
name|asection
operator|*
operator|*
name|local_sections
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elfNN_ia64_finish_dynamic_symbol
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|output_bfd
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
name|h
operator|,
name|Elf_Internal_Sym
operator|*
name|sym
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elfNN_ia64_finish_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elfNN_ia64_set_private_flags
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|flagword
name|flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elfNN_ia64_merge_private_bfd_data
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|ibfd
operator|,
name|bfd
operator|*
name|obfd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elfNN_ia64_print_private_bfd_data
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|PTR
name|ptr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|elf_reloc_type_class
name|elfNN_ia64_reloc_type_class
name|PARAMS
argument_list|(
operator|(
specifier|const
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elfNN_ia64_hpux_vec
name|PARAMS
argument_list|(
operator|(
specifier|const
name|bfd_target
operator|*
name|vec
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|elfNN_hpux_post_process_headers
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd_boolean
name|elfNN_hpux_backend_section_from_bfd_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|asection
operator|*
name|sec
operator|,
name|int
operator|*
name|retval
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* ia64-specific relocation.  */
end_comment

begin_comment
comment|/* Perform a relocation.  Not much to do here as all the hard work is    done in elfNN_ia64_final_link_relocate.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|elfNN_ia64_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc
parameter_list|,
name|sym
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|arelent
modifier|*
name|reloc
decl_stmt|;
name|asymbol
modifier|*
name|sym
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|PTR
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
block|{
if|if
condition|(
name|output_bfd
condition|)
block|{
name|reloc
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
if|if
condition|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_DEBUGGING
condition|)
return|return
name|bfd_reloc_continue
return|;
operator|*
name|error_message
operator|=
literal|"Unsupported call to elfNN_ia64_reloc"
expr_stmt|;
return|return
name|bfd_reloc_notsupported
return|;
block|}
end_function

begin_define
define|#
directive|define
name|IA64_HOWTO
parameter_list|(
name|TYPE
parameter_list|,
name|NAME
parameter_list|,
name|SIZE
parameter_list|,
name|PCREL
parameter_list|,
name|IN
parameter_list|)
define|\
value|HOWTO (TYPE, 0, SIZE, 0, PCREL, 0, complain_overflow_signed,	\ 	 elfNN_ia64_reloc, NAME, FALSE, 0, -1, IN)
end_define

begin_comment
comment|/* This table has to be sorted according to increasing number of the    TYPE field.  */
end_comment

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|ia64_howto_table
index|[]
init|=
block|{
name|IA64_HOWTO
argument_list|(
name|R_IA64_NONE
argument_list|,
literal|"NONE"
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_IMM14
argument_list|,
literal|"IMM14"
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_IMM22
argument_list|,
literal|"IMM22"
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_IMM64
argument_list|,
literal|"IMM64"
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_DIR32MSB
argument_list|,
literal|"DIR32MSB"
argument_list|,
literal|2
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_DIR32LSB
argument_list|,
literal|"DIR32LSB"
argument_list|,
literal|2
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_DIR64MSB
argument_list|,
literal|"DIR64MSB"
argument_list|,
literal|4
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_DIR64LSB
argument_list|,
literal|"DIR64LSB"
argument_list|,
literal|4
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_GPREL22
argument_list|,
literal|"GPREL22"
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_GPREL64I
argument_list|,
literal|"GPREL64I"
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_GPREL32MSB
argument_list|,
literal|"GPREL32MSB"
argument_list|,
literal|2
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_GPREL32LSB
argument_list|,
literal|"GPREL32LSB"
argument_list|,
literal|2
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_GPREL64MSB
argument_list|,
literal|"GPREL64MSB"
argument_list|,
literal|4
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_GPREL64LSB
argument_list|,
literal|"GPREL64LSB"
argument_list|,
literal|4
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_LTOFF22
argument_list|,
literal|"LTOFF22"
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_LTOFF64I
argument_list|,
literal|"LTOFF64I"
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_PLTOFF22
argument_list|,
literal|"PLTOFF22"
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_PLTOFF64I
argument_list|,
literal|"PLTOFF64I"
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_PLTOFF64MSB
argument_list|,
literal|"PLTOFF64MSB"
argument_list|,
literal|4
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_PLTOFF64LSB
argument_list|,
literal|"PLTOFF64LSB"
argument_list|,
literal|4
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_FPTR64I
argument_list|,
literal|"FPTR64I"
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_FPTR32MSB
argument_list|,
literal|"FPTR32MSB"
argument_list|,
literal|2
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_FPTR32LSB
argument_list|,
literal|"FPTR32LSB"
argument_list|,
literal|2
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_FPTR64MSB
argument_list|,
literal|"FPTR64MSB"
argument_list|,
literal|4
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_FPTR64LSB
argument_list|,
literal|"FPTR64LSB"
argument_list|,
literal|4
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_PCREL60B
argument_list|,
literal|"PCREL60B"
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_PCREL21B
argument_list|,
literal|"PCREL21B"
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_PCREL21M
argument_list|,
literal|"PCREL21M"
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_PCREL21F
argument_list|,
literal|"PCREL21F"
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_PCREL32MSB
argument_list|,
literal|"PCREL32MSB"
argument_list|,
literal|2
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_PCREL32LSB
argument_list|,
literal|"PCREL32LSB"
argument_list|,
literal|2
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_PCREL64MSB
argument_list|,
literal|"PCREL64MSB"
argument_list|,
literal|4
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_PCREL64LSB
argument_list|,
literal|"PCREL64LSB"
argument_list|,
literal|4
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_LTOFF_FPTR22
argument_list|,
literal|"LTOFF_FPTR22"
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_LTOFF_FPTR64I
argument_list|,
literal|"LTOFF_FPTR64I"
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_LTOFF_FPTR32MSB
argument_list|,
literal|"LTOFF_FPTR32MSB"
argument_list|,
literal|2
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_LTOFF_FPTR32LSB
argument_list|,
literal|"LTOFF_FPTR32LSB"
argument_list|,
literal|2
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_LTOFF_FPTR64MSB
argument_list|,
literal|"LTOFF_FPTR64MSB"
argument_list|,
literal|4
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_LTOFF_FPTR64LSB
argument_list|,
literal|"LTOFF_FPTR64LSB"
argument_list|,
literal|4
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_SEGREL32MSB
argument_list|,
literal|"SEGREL32MSB"
argument_list|,
literal|2
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_SEGREL32LSB
argument_list|,
literal|"SEGREL32LSB"
argument_list|,
literal|2
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_SEGREL64MSB
argument_list|,
literal|"SEGREL64MSB"
argument_list|,
literal|4
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_SEGREL64LSB
argument_list|,
literal|"SEGREL64LSB"
argument_list|,
literal|4
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_SECREL32MSB
argument_list|,
literal|"SECREL32MSB"
argument_list|,
literal|2
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_SECREL32LSB
argument_list|,
literal|"SECREL32LSB"
argument_list|,
literal|2
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_SECREL64MSB
argument_list|,
literal|"SECREL64MSB"
argument_list|,
literal|4
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_SECREL64LSB
argument_list|,
literal|"SECREL64LSB"
argument_list|,
literal|4
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_REL32MSB
argument_list|,
literal|"REL32MSB"
argument_list|,
literal|2
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_REL32LSB
argument_list|,
literal|"REL32LSB"
argument_list|,
literal|2
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_REL64MSB
argument_list|,
literal|"REL64MSB"
argument_list|,
literal|4
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_REL64LSB
argument_list|,
literal|"REL64LSB"
argument_list|,
literal|4
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_LTV32MSB
argument_list|,
literal|"LTV32MSB"
argument_list|,
literal|2
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_LTV32LSB
argument_list|,
literal|"LTV32LSB"
argument_list|,
literal|2
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_LTV64MSB
argument_list|,
literal|"LTV64MSB"
argument_list|,
literal|4
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_LTV64LSB
argument_list|,
literal|"LTV64LSB"
argument_list|,
literal|4
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_PCREL21BI
argument_list|,
literal|"PCREL21BI"
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_PCREL22
argument_list|,
literal|"PCREL22"
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_PCREL64I
argument_list|,
literal|"PCREL64I"
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_IPLTMSB
argument_list|,
literal|"IPLTMSB"
argument_list|,
literal|4
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_IPLTLSB
argument_list|,
literal|"IPLTLSB"
argument_list|,
literal|4
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_COPY
argument_list|,
literal|"COPY"
argument_list|,
literal|4
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_LTOFF22X
argument_list|,
literal|"LTOFF22X"
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_LDXMOV
argument_list|,
literal|"LDXMOV"
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_TPREL14
argument_list|,
literal|"TPREL14"
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_TPREL22
argument_list|,
literal|"TPREL22"
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_TPREL64I
argument_list|,
literal|"TPREL64I"
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_TPREL64MSB
argument_list|,
literal|"TPREL64MSB"
argument_list|,
literal|4
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_TPREL64LSB
argument_list|,
literal|"TPREL64LSB"
argument_list|,
literal|4
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_LTOFF_TPREL22
argument_list|,
literal|"LTOFF_TPREL22"
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_DTPMOD64MSB
argument_list|,
literal|"TPREL64MSB"
argument_list|,
literal|4
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_DTPMOD64LSB
argument_list|,
literal|"TPREL64LSB"
argument_list|,
literal|4
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_LTOFF_DTPMOD22
argument_list|,
literal|"LTOFF_DTPMOD22"
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_DTPREL14
argument_list|,
literal|"DTPREL14"
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_DTPREL22
argument_list|,
literal|"DTPREL22"
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_DTPREL64I
argument_list|,
literal|"DTPREL64I"
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_DTPREL32MSB
argument_list|,
literal|"DTPREL32MSB"
argument_list|,
literal|2
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_DTPREL32LSB
argument_list|,
literal|"DTPREL32LSB"
argument_list|,
literal|2
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_DTPREL64MSB
argument_list|,
literal|"DTPREL64MSB"
argument_list|,
literal|4
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_DTPREL64LSB
argument_list|,
literal|"DTPREL64LSB"
argument_list|,
literal|4
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_LTOFF_DTPREL22
argument_list|,
literal|"LTOFF_DTPREL22"
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
block|,   }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|elf_code_to_howto_index
index|[
name|R_IA64_MAX_RELOC_CODE
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Given a BFD reloc type, return the matching HOWTO structure.  */
end_comment

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|lookup_howto
parameter_list|(
name|rtype
parameter_list|)
name|unsigned
name|int
name|rtype
decl_stmt|;
block|{
specifier|static
name|int
name|inited
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|inited
condition|)
block|{
name|inited
operator|=
literal|1
expr_stmt|;
name|memset
argument_list|(
name|elf_code_to_howto_index
argument_list|,
literal|0xff
argument_list|,
sizeof|sizeof
argument_list|(
name|elf_code_to_howto_index
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NELEMS
argument_list|(
name|ia64_howto_table
argument_list|)
condition|;
operator|++
name|i
control|)
name|elf_code_to_howto_index
index|[
name|ia64_howto_table
index|[
name|i
index|]
operator|.
name|type
index|]
operator|=
name|i
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
name|rtype
operator|<=
name|R_IA64_MAX_RELOC_CODE
argument_list|)
expr_stmt|;
name|i
operator|=
name|elf_code_to_howto_index
index|[
name|rtype
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|NELEMS
argument_list|(
name|ia64_howto_table
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|ia64_howto_table
operator|+
name|i
return|;
block|}
end_function

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|elfNN_ia64_reloc_type_lookup
parameter_list|(
name|abfd
parameter_list|,
name|bfd_code
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd_reloc_code_real_type
name|bfd_code
decl_stmt|;
block|{
name|unsigned
name|int
name|rtype
decl_stmt|;
switch|switch
condition|(
name|bfd_code
condition|)
block|{
case|case
name|BFD_RELOC_NONE
case|:
name|rtype
operator|=
name|R_IA64_NONE
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_IMM14
case|:
name|rtype
operator|=
name|R_IA64_IMM14
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_IMM22
case|:
name|rtype
operator|=
name|R_IA64_IMM22
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_IMM64
case|:
name|rtype
operator|=
name|R_IA64_IMM64
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR32MSB
case|:
name|rtype
operator|=
name|R_IA64_DIR32MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR32LSB
case|:
name|rtype
operator|=
name|R_IA64_DIR32LSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR64MSB
case|:
name|rtype
operator|=
name|R_IA64_DIR64MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR64LSB
case|:
name|rtype
operator|=
name|R_IA64_DIR64LSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_GPREL22
case|:
name|rtype
operator|=
name|R_IA64_GPREL22
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_GPREL64I
case|:
name|rtype
operator|=
name|R_IA64_GPREL64I
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_GPREL32MSB
case|:
name|rtype
operator|=
name|R_IA64_GPREL32MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_GPREL32LSB
case|:
name|rtype
operator|=
name|R_IA64_GPREL32LSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_GPREL64MSB
case|:
name|rtype
operator|=
name|R_IA64_GPREL64MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_GPREL64LSB
case|:
name|rtype
operator|=
name|R_IA64_GPREL64LSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_LTOFF22
case|:
name|rtype
operator|=
name|R_IA64_LTOFF22
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_LTOFF64I
case|:
name|rtype
operator|=
name|R_IA64_LTOFF64I
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_PLTOFF22
case|:
name|rtype
operator|=
name|R_IA64_PLTOFF22
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_PLTOFF64I
case|:
name|rtype
operator|=
name|R_IA64_PLTOFF64I
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_PLTOFF64MSB
case|:
name|rtype
operator|=
name|R_IA64_PLTOFF64MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_PLTOFF64LSB
case|:
name|rtype
operator|=
name|R_IA64_PLTOFF64LSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_FPTR64I
case|:
name|rtype
operator|=
name|R_IA64_FPTR64I
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_FPTR32MSB
case|:
name|rtype
operator|=
name|R_IA64_FPTR32MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_FPTR32LSB
case|:
name|rtype
operator|=
name|R_IA64_FPTR32LSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_FPTR64MSB
case|:
name|rtype
operator|=
name|R_IA64_FPTR64MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_FPTR64LSB
case|:
name|rtype
operator|=
name|R_IA64_FPTR64LSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_PCREL21B
case|:
name|rtype
operator|=
name|R_IA64_PCREL21B
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_PCREL21BI
case|:
name|rtype
operator|=
name|R_IA64_PCREL21BI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_PCREL21M
case|:
name|rtype
operator|=
name|R_IA64_PCREL21M
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_PCREL21F
case|:
name|rtype
operator|=
name|R_IA64_PCREL21F
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_PCREL22
case|:
name|rtype
operator|=
name|R_IA64_PCREL22
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_PCREL60B
case|:
name|rtype
operator|=
name|R_IA64_PCREL60B
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_PCREL64I
case|:
name|rtype
operator|=
name|R_IA64_PCREL64I
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_PCREL32MSB
case|:
name|rtype
operator|=
name|R_IA64_PCREL32MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_PCREL32LSB
case|:
name|rtype
operator|=
name|R_IA64_PCREL32LSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_PCREL64MSB
case|:
name|rtype
operator|=
name|R_IA64_PCREL64MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_PCREL64LSB
case|:
name|rtype
operator|=
name|R_IA64_PCREL64LSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_LTOFF_FPTR22
case|:
name|rtype
operator|=
name|R_IA64_LTOFF_FPTR22
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_LTOFF_FPTR64I
case|:
name|rtype
operator|=
name|R_IA64_LTOFF_FPTR64I
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_LTOFF_FPTR32MSB
case|:
name|rtype
operator|=
name|R_IA64_LTOFF_FPTR32MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_LTOFF_FPTR32LSB
case|:
name|rtype
operator|=
name|R_IA64_LTOFF_FPTR32LSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_LTOFF_FPTR64MSB
case|:
name|rtype
operator|=
name|R_IA64_LTOFF_FPTR64MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_LTOFF_FPTR64LSB
case|:
name|rtype
operator|=
name|R_IA64_LTOFF_FPTR64LSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_SEGREL32MSB
case|:
name|rtype
operator|=
name|R_IA64_SEGREL32MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_SEGREL32LSB
case|:
name|rtype
operator|=
name|R_IA64_SEGREL32LSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_SEGREL64MSB
case|:
name|rtype
operator|=
name|R_IA64_SEGREL64MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_SEGREL64LSB
case|:
name|rtype
operator|=
name|R_IA64_SEGREL64LSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_SECREL32MSB
case|:
name|rtype
operator|=
name|R_IA64_SECREL32MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_SECREL32LSB
case|:
name|rtype
operator|=
name|R_IA64_SECREL32LSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_SECREL64MSB
case|:
name|rtype
operator|=
name|R_IA64_SECREL64MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_SECREL64LSB
case|:
name|rtype
operator|=
name|R_IA64_SECREL64LSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_REL32MSB
case|:
name|rtype
operator|=
name|R_IA64_REL32MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_REL32LSB
case|:
name|rtype
operator|=
name|R_IA64_REL32LSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_REL64MSB
case|:
name|rtype
operator|=
name|R_IA64_REL64MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_REL64LSB
case|:
name|rtype
operator|=
name|R_IA64_REL64LSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_LTV32MSB
case|:
name|rtype
operator|=
name|R_IA64_LTV32MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_LTV32LSB
case|:
name|rtype
operator|=
name|R_IA64_LTV32LSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_LTV64MSB
case|:
name|rtype
operator|=
name|R_IA64_LTV64MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_LTV64LSB
case|:
name|rtype
operator|=
name|R_IA64_LTV64LSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_IPLTMSB
case|:
name|rtype
operator|=
name|R_IA64_IPLTMSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_IPLTLSB
case|:
name|rtype
operator|=
name|R_IA64_IPLTLSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_COPY
case|:
name|rtype
operator|=
name|R_IA64_COPY
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_LTOFF22X
case|:
name|rtype
operator|=
name|R_IA64_LTOFF22X
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_LDXMOV
case|:
name|rtype
operator|=
name|R_IA64_LDXMOV
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_TPREL14
case|:
name|rtype
operator|=
name|R_IA64_TPREL14
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_TPREL22
case|:
name|rtype
operator|=
name|R_IA64_TPREL22
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_TPREL64I
case|:
name|rtype
operator|=
name|R_IA64_TPREL64I
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_TPREL64MSB
case|:
name|rtype
operator|=
name|R_IA64_TPREL64MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_TPREL64LSB
case|:
name|rtype
operator|=
name|R_IA64_TPREL64LSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_LTOFF_TPREL22
case|:
name|rtype
operator|=
name|R_IA64_LTOFF_TPREL22
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DTPMOD64MSB
case|:
name|rtype
operator|=
name|R_IA64_DTPMOD64MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DTPMOD64LSB
case|:
name|rtype
operator|=
name|R_IA64_DTPMOD64LSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_LTOFF_DTPMOD22
case|:
name|rtype
operator|=
name|R_IA64_LTOFF_DTPMOD22
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DTPREL14
case|:
name|rtype
operator|=
name|R_IA64_DTPREL14
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DTPREL22
case|:
name|rtype
operator|=
name|R_IA64_DTPREL22
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DTPREL64I
case|:
name|rtype
operator|=
name|R_IA64_DTPREL64I
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DTPREL32MSB
case|:
name|rtype
operator|=
name|R_IA64_DTPREL32MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DTPREL32LSB
case|:
name|rtype
operator|=
name|R_IA64_DTPREL32LSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DTPREL64MSB
case|:
name|rtype
operator|=
name|R_IA64_DTPREL64MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DTPREL64LSB
case|:
name|rtype
operator|=
name|R_IA64_DTPREL64LSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_LTOFF_DTPREL22
case|:
name|rtype
operator|=
name|R_IA64_LTOFF_DTPREL22
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
return|return
name|lookup_howto
argument_list|(
name|rtype
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given a ELF reloc, return the matching HOWTO structure.  */
end_comment

begin_function
specifier|static
name|void
name|elfNN_ia64_info_to_howto
parameter_list|(
name|abfd
parameter_list|,
name|bfd_reloc
parameter_list|,
name|elf_reloc
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|arelent
modifier|*
name|bfd_reloc
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|elf_reloc
decl_stmt|;
block|{
name|bfd_reloc
operator|->
name|howto
operator|=
name|lookup_howto
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|ELFNN_R_TYPE
argument_list|(
name|elf_reloc
operator|->
name|r_info
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|PLT_HEADER_SIZE
value|(3 * 16)
end_define

begin_define
define|#
directive|define
name|PLT_MIN_ENTRY_SIZE
value|(1 * 16)
end_define

begin_define
define|#
directive|define
name|PLT_FULL_ENTRY_SIZE
value|(2 * 16)
end_define

begin_define
define|#
directive|define
name|PLT_RESERVED_WORDS
value|3
end_define

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
name|plt_header
index|[
name|PLT_HEADER_SIZE
index|]
init|=
block|{
literal|0x0b
block|,
literal|0x10
block|,
literal|0x00
block|,
literal|0x1c
block|,
literal|0x00
block|,
literal|0x21
block|,
comment|/*   [MMI]       mov r2=r14;;       */
literal|0xe0
block|,
literal|0x00
block|,
literal|0x08
block|,
literal|0x00
block|,
literal|0x48
block|,
literal|0x00
block|,
comment|/*               addl r14=0,r2      */
literal|0x00
block|,
literal|0x00
block|,
literal|0x04
block|,
literal|0x00
block|,
comment|/*               nop.i 0x0;;        */
literal|0x0b
block|,
literal|0x80
block|,
literal|0x20
block|,
literal|0x1c
block|,
literal|0x18
block|,
literal|0x14
block|,
comment|/*   [MMI]       ld8 r16=[r14],8;;  */
literal|0x10
block|,
literal|0x41
block|,
literal|0x38
block|,
literal|0x30
block|,
literal|0x28
block|,
literal|0x00
block|,
comment|/*               ld8 r17=[r14],8    */
literal|0x00
block|,
literal|0x00
block|,
literal|0x04
block|,
literal|0x00
block|,
comment|/*               nop.i 0x0;;        */
literal|0x11
block|,
literal|0x08
block|,
literal|0x00
block|,
literal|0x1c
block|,
literal|0x18
block|,
literal|0x10
block|,
comment|/*   [MIB]       ld8 r1=[r14]       */
literal|0x60
block|,
literal|0x88
block|,
literal|0x04
block|,
literal|0x80
block|,
literal|0x03
block|,
literal|0x00
block|,
comment|/*               mov b6=r17         */
literal|0x60
block|,
literal|0x00
block|,
literal|0x80
block|,
literal|0x00
comment|/*               br.few b6;;        */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
name|plt_min_entry
index|[
name|PLT_MIN_ENTRY_SIZE
index|]
init|=
block|{
literal|0x11
block|,
literal|0x78
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x24
block|,
comment|/*   [MIB]       mov r15=0          */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x02
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*               nop.i 0x0          */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x40
comment|/*               br.few 0<PLT0>;;  */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
name|plt_full_entry
index|[
name|PLT_FULL_ENTRY_SIZE
index|]
init|=
block|{
literal|0x0b
block|,
literal|0x78
block|,
literal|0x00
block|,
literal|0x02
block|,
literal|0x00
block|,
literal|0x24
block|,
comment|/*   [MMI]       addl r15=0,r1;;    */
literal|0x00
block|,
literal|0x41
block|,
literal|0x3c
block|,
literal|0x70
block|,
literal|0x29
block|,
literal|0xc0
block|,
comment|/*               ld8.acq r16=[r15],8*/
literal|0x01
block|,
literal|0x08
block|,
literal|0x00
block|,
literal|0x84
block|,
comment|/*               mov r14=r1;;       */
literal|0x11
block|,
literal|0x08
block|,
literal|0x00
block|,
literal|0x1e
block|,
literal|0x18
block|,
literal|0x10
block|,
comment|/*   [MIB]       ld8 r1=[r15]       */
literal|0x60
block|,
literal|0x80
block|,
literal|0x04
block|,
literal|0x80
block|,
literal|0x03
block|,
literal|0x00
block|,
comment|/*               mov b6=r16         */
literal|0x60
block|,
literal|0x00
block|,
literal|0x80
block|,
literal|0x00
comment|/*               br.few b6;;        */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ELF_DYNAMIC_INTERPRETER
value|"/usr/lib/ld.so.1"
end_define

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
name|oor_brl
index|[
literal|16
index|]
init|=
block|{
literal|0x05
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x00
block|,
comment|/*  [MLX]        nop.m 0            */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*               brl.sptk.few tgt;; */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0xc0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
name|oor_ip
index|[
literal|48
index|]
init|=
block|{
literal|0x04
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x00
block|,
comment|/*  [MLX]        nop.m 0            */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0xe0
block|,
comment|/*               movl r15=0         */
literal|0x01
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x60
block|,
literal|0x03
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x00
block|,
comment|/*  [MII]        nop.m 0            */
literal|0x00
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0x60
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*               mov r16=ip;;       */
literal|0xf2
block|,
literal|0x80
block|,
literal|0x00
block|,
literal|0x80
block|,
comment|/*               add r16=r15,r16;;  */
literal|0x11
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x00
block|,
comment|/*  [MIB]        nop.m 0            */
literal|0x60
block|,
literal|0x80
block|,
literal|0x04
block|,
literal|0x80
block|,
literal|0x03
block|,
literal|0x00
block|,
comment|/*               mov b6=r16         */
literal|0x60
block|,
literal|0x00
block|,
literal|0x80
block|,
literal|0x00
comment|/*               br b6;;            */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|oor_branch_size
init|=
sizeof|sizeof
argument_list|(
name|oor_brl
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|bfd_elfNN_ia64_after_parse
parameter_list|(
name|int
name|itanium
parameter_list|)
block|{
name|oor_branch_size
operator|=
name|itanium
condition|?
sizeof|sizeof
argument_list|(
name|oor_ip
argument_list|)
else|:
sizeof|sizeof
argument_list|(
name|oor_brl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elfNN_ia64_relax_brl
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|bfd_vma
name|off
parameter_list|)
block|{
name|int
name|template
decl_stmt|;
name|bfd_byte
modifier|*
name|hit_addr
decl_stmt|;
name|bfd_vma
name|t0
decl_stmt|,
name|t1
decl_stmt|,
name|i0
decl_stmt|,
name|i1
decl_stmt|,
name|i2
decl_stmt|;
name|hit_addr
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
operator|(
name|contents
operator|+
name|off
operator|)
expr_stmt|;
name|hit_addr
operator|-=
operator|(
name|long
operator|)
name|hit_addr
operator|&
literal|0x3
expr_stmt|;
name|t0
operator|=
name|bfd_get_64
argument_list|(
name|abfd
argument_list|,
name|hit_addr
argument_list|)
expr_stmt|;
name|t1
operator|=
name|bfd_get_64
argument_list|(
name|abfd
argument_list|,
name|hit_addr
operator|+
literal|8
argument_list|)
expr_stmt|;
comment|/* Keep the instruction in slot 0. */
name|i0
operator|=
operator|(
name|t0
operator|>>
literal|5
operator|)
operator|&
literal|0x1ffffffffffLL
expr_stmt|;
comment|/* Use nop.b for slot 1. */
name|i1
operator|=
literal|0x4000000000LL
expr_stmt|;
comment|/* For slot 2, turn brl into br by masking out bit 40.  */
name|i2
operator|=
operator|(
name|t1
operator|>>
literal|23
operator|)
operator|&
literal|0x0ffffffffffLL
expr_stmt|;
comment|/* Turn a MLX bundle into a MBB bundle with the same stop-bit      variety.  */
name|template
operator|=
literal|0x12
expr_stmt|;
if|if
condition|(
operator|(
name|t0
operator|&
literal|0x1fLL
operator|)
operator|==
literal|5
condition|)
name|template
operator|+=
literal|1
expr_stmt|;
name|t0
operator|=
operator|(
name|i1
operator|<<
literal|46
operator|)
operator||
operator|(
name|i0
operator|<<
literal|5
operator|)
operator||
name|template
expr_stmt|;
name|t1
operator|=
operator|(
name|i2
operator|<<
literal|23
operator|)
operator||
operator|(
name|i1
operator|>>
literal|18
operator|)
expr_stmt|;
name|bfd_put_64
argument_list|(
name|abfd
argument_list|,
name|t0
argument_list|,
name|hit_addr
argument_list|)
expr_stmt|;
name|bfd_put_64
argument_list|(
name|abfd
argument_list|,
name|t1
argument_list|,
name|hit_addr
operator|+
literal|8
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* These functions do relaxation for IA-64 ELF.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elfNN_ia64_relax_section
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|link_info
parameter_list|,
name|again
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|link_info
decl_stmt|;
name|bfd_boolean
modifier|*
name|again
decl_stmt|;
block|{
struct|struct
name|one_fixup
block|{
name|struct
name|one_fixup
modifier|*
name|next
decl_stmt|;
name|asection
modifier|*
name|tsec
decl_stmt|;
name|bfd_vma
name|toff
decl_stmt|;
name|bfd_vma
name|trampoff
decl_stmt|;
block|}
struct|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|,
modifier|*
name|irelend
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymbuf
init|=
name|NULL
decl_stmt|;
name|struct
name|elfNN_ia64_link_hash_table
modifier|*
name|ia64_info
decl_stmt|;
name|struct
name|one_fixup
modifier|*
name|fixups
init|=
name|NULL
decl_stmt|;
name|bfd_boolean
name|changed_contents
init|=
name|FALSE
decl_stmt|;
name|bfd_boolean
name|changed_relocs
init|=
name|FALSE
decl_stmt|;
name|bfd_boolean
name|changed_got
init|=
name|FALSE
decl_stmt|;
name|bfd_vma
name|gp
init|=
literal|0
decl_stmt|;
comment|/* Assume we're not going to change any sizes, and we'll only need      one pass.  */
operator|*
name|again
operator|=
name|FALSE
expr_stmt|;
comment|/* Don't even try to relax for non-ELF outputs.  */
if|if
condition|(
operator|!
name|is_elf_hash_table
argument_list|(
name|link_info
operator|->
name|hash
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Nothing to do if there are no relocations or there is no need for      the relax finalize pass.  */
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
operator|||
name|sec
operator|->
name|reloc_count
operator|==
literal|0
operator|||
operator|(
operator|!
name|link_info
operator|->
name|need_relax_finalize
operator|&&
name|sec
operator|->
name|need_finalize_relax
operator|==
literal|0
operator|)
condition|)
return|return
name|TRUE
return|;
comment|/* If this is the first time we have been called for this section,      initialize the cooked size.  */
if|if
condition|(
name|sec
operator|->
name|_cooked_size
operator|==
literal|0
condition|)
name|sec
operator|->
name|_cooked_size
operator|=
name|sec
operator|->
name|_raw_size
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
comment|/* Load the relocations for this section.  */
name|internal_relocs
operator|=
operator|(
name|_bfd_elf_link_read_relocs
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
operator|(
name|PTR
operator|)
name|NULL
argument_list|,
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
name|NULL
argument_list|,
name|link_info
operator|->
name|keep_memory
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|ia64_info
operator|=
name|elfNN_ia64_hash_table
argument_list|(
name|link_info
argument_list|)
expr_stmt|;
name|irelend
operator|=
name|internal_relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
comment|/* Get the section contents.  */
if|if
condition|(
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|NULL
condition|)
name|contents
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
expr_stmt|;
else|else
block|{
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|sec
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|contents
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|sec
operator|->
name|_raw_size
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
for|for
control|(
name|irel
operator|=
name|internal_relocs
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
control|)
block|{
name|unsigned
name|long
name|r_type
init|=
name|ELFNN_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
decl_stmt|;
name|bfd_vma
name|symaddr
decl_stmt|,
name|reladdr
decl_stmt|,
name|trampoff
decl_stmt|,
name|toff
decl_stmt|,
name|roff
decl_stmt|;
name|asection
modifier|*
name|tsec
decl_stmt|;
name|struct
name|one_fixup
modifier|*
name|f
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|bfd_boolean
name|is_branch
decl_stmt|;
name|struct
name|elfNN_ia64_dyn_sym_info
modifier|*
name|dyn_i
decl_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_IA64_PCREL21B
case|:
case|case
name|R_IA64_PCREL21BI
case|:
case|case
name|R_IA64_PCREL21M
case|:
case|case
name|R_IA64_PCREL21F
case|:
comment|/* In the finalize pass, all br relaxations are done. We can 	     skip it. */
if|if
condition|(
operator|!
name|link_info
operator|->
name|need_relax_finalize
condition|)
continue|continue;
name|is_branch
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|R_IA64_PCREL60B
case|:
comment|/* We can't optimize brl to br before the finalize pass since 	     br relaxations will increase the code size. Defer it to 	     the finalize pass.  */
if|if
condition|(
name|link_info
operator|->
name|need_relax_finalize
condition|)
block|{
name|sec
operator|->
name|need_finalize_relax
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
name|is_branch
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|R_IA64_LTOFF22X
case|:
case|case
name|R_IA64_LDXMOV
case|:
comment|/* We can't relax ldx/mov before the finalize pass since 	     br relaxations will increase the code size. Defer it to 	     the finalize pass.  */
if|if
condition|(
name|link_info
operator|->
name|need_relax_finalize
condition|)
block|{
name|sec
operator|->
name|need_finalize_relax
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
name|is_branch
operator|=
name|FALSE
expr_stmt|;
break|break;
default|default:
continue|continue;
block|}
comment|/* Get the value of the symbol referred to by the reloc.  */
if|if
condition|(
name|ELFNN_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
comment|/* A local symbol.  */
name|Elf_Internal_Sym
modifier|*
name|isym
decl_stmt|;
comment|/* Read this BFD's local symbols.  */
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
block|{
name|isymbuf
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
name|isymbuf
operator|=
name|bfd_elf_get_elf_syms
argument_list|(
name|abfd
argument_list|,
name|symtab_hdr
argument_list|,
name|symtab_hdr
operator|->
name|sh_info
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
literal|0
condition|)
goto|goto
name|error_return
goto|;
block|}
name|isym
operator|=
name|isymbuf
operator|+
name|ELFNN_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_UNDEF
condition|)
continue|continue;
comment|/* We can't do anything with undefined symbols.  */
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_ABS
condition|)
name|tsec
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_COMMON
condition|)
name|tsec
operator|=
name|bfd_com_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_IA_64_ANSI_COMMON
condition|)
name|tsec
operator|=
name|bfd_com_section_ptr
expr_stmt|;
else|else
name|tsec
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|abfd
argument_list|,
name|isym
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
name|toff
operator|=
name|isym
operator|->
name|st_value
expr_stmt|;
name|dyn_i
operator|=
name|get_dyn_sym_info
argument_list|(
name|ia64_info
argument_list|,
name|NULL
argument_list|,
name|abfd
argument_list|,
name|irel
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|long
name|indx
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|indx
operator|=
name|ELFNN_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|-
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|h
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
index|[
name|indx
index|]
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|h
operator|!=
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|dyn_i
operator|=
name|get_dyn_sym_info
argument_list|(
name|ia64_info
argument_list|,
name|h
argument_list|,
name|abfd
argument_list|,
name|irel
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* For branches to dynamic symbols, we're interested instead 	     in a branch to the PLT entry.  */
if|if
condition|(
name|is_branch
operator|&&
name|dyn_i
operator|&&
name|dyn_i
operator|->
name|want_plt2
condition|)
block|{
comment|/* Internal branches shouldn't be sent to the PLT. 		 Leave this for now and we'll give an error later.  */
if|if
condition|(
name|r_type
operator|!=
name|R_IA64_PCREL21B
condition|)
continue|continue;
name|tsec
operator|=
name|ia64_info
operator|->
name|plt_sec
expr_stmt|;
name|toff
operator|=
name|dyn_i
operator|->
name|plt2_offset
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|irel
operator|->
name|r_addend
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Can't do anything else with dynamic symbols.  */
elseif|else
if|if
condition|(
name|elfNN_ia64_dynamic_symbol_p
argument_list|(
name|h
argument_list|,
name|link_info
argument_list|,
name|r_type
argument_list|)
condition|)
continue|continue;
else|else
block|{
comment|/* We can't do anything with undefined symbols.  */
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
continue|continue;
name|tsec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|toff
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tsec
operator|->
name|sec_info_type
operator|==
name|ELF_INFO_TYPE_MERGE
condition|)
name|toff
operator|=
name|_bfd_merged_section_offset
argument_list|(
name|abfd
argument_list|,
operator|&
name|tsec
argument_list|,
name|elf_section_data
argument_list|(
name|tsec
argument_list|)
operator|->
name|sec_info
argument_list|,
name|toff
operator|+
name|irel
operator|->
name|r_addend
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
expr_stmt|;
else|else
name|toff
operator|+=
name|irel
operator|->
name|r_addend
expr_stmt|;
name|symaddr
operator|=
name|tsec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|tsec
operator|->
name|output_offset
operator|+
name|toff
expr_stmt|;
name|roff
operator|=
name|irel
operator|->
name|r_offset
expr_stmt|;
if|if
condition|(
name|is_branch
condition|)
block|{
name|bfd_signed_vma
name|offset
decl_stmt|;
name|reladdr
operator|=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|roff
operator|)
operator|&
operator|(
name|bfd_vma
operator|)
operator|-
literal|4
expr_stmt|;
comment|/* If the branch is in range, no need to do anything.  */
if|if
condition|(
call|(
name|bfd_signed_vma
call|)
argument_list|(
name|symaddr
operator|-
name|reladdr
argument_list|)
operator|>=
operator|-
literal|0x1000000
operator|&&
call|(
name|bfd_signed_vma
call|)
argument_list|(
name|symaddr
operator|-
name|reladdr
argument_list|)
operator|<=
literal|0x0FFFFF0
condition|)
block|{
comment|/* If the 60-bit branch is in 21-bit range, optimize it. */
if|if
condition|(
name|r_type
operator|==
name|R_IA64_PCREL60B
condition|)
block|{
name|elfNN_ia64_relax_brl
argument_list|(
name|abfd
argument_list|,
name|contents
argument_list|,
name|roff
argument_list|)
expr_stmt|;
name|irel
operator|->
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|ELF64_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
name|R_IA64_PCREL21B
argument_list|)
expr_stmt|;
comment|/* If the original relocation offset points to slot 		     1, change it to slot 2.  */
if|if
condition|(
operator|(
name|irel
operator|->
name|r_offset
operator|&
literal|3
operator|)
operator|==
literal|1
condition|)
name|irel
operator|->
name|r_offset
operator|+=
literal|1
expr_stmt|;
block|}
continue|continue;
block|}
elseif|else
if|if
condition|(
name|r_type
operator|==
name|R_IA64_PCREL60B
condition|)
continue|continue;
comment|/* If the branch and target are in the same section, you've 	     got one honking big section and we can't help you.  You'll 	     get an error message later.  */
if|if
condition|(
name|tsec
operator|==
name|sec
condition|)
continue|continue;
comment|/* Look for an existing fixup to this address.  */
for|for
control|(
name|f
operator|=
name|fixups
init|;
name|f
condition|;
name|f
operator|=
name|f
operator|->
name|next
control|)
if|if
condition|(
name|f
operator|->
name|tsec
operator|==
name|tsec
operator|&&
name|f
operator|->
name|toff
operator|==
name|toff
condition|)
break|break;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
comment|/* Two alternatives: If it's a branch to a PLT entry, we can 		 make a copy of the FULL_PLT entry.  Otherwise, we'll have 		 to use a `brl' insn to get where we're going.  */
name|size_t
name|size
decl_stmt|;
if|if
condition|(
name|tsec
operator|==
name|ia64_info
operator|->
name|plt_sec
condition|)
name|size
operator|=
sizeof|sizeof
argument_list|(
name|plt_full_entry
argument_list|)
expr_stmt|;
else|else
name|size
operator|=
name|oor_branch_size
expr_stmt|;
comment|/* Resize the current section to make room for the new branch. */
name|trampoff
operator|=
operator|(
name|sec
operator|->
name|_cooked_size
operator|+
literal|15
operator|)
operator|&
operator|(
name|bfd_vma
operator|)
operator|-
literal|16
expr_stmt|;
comment|/* If trampoline is out of range, there is nothing we 		 can do.  */
name|offset
operator|=
name|trampoff
operator|-
operator|(
name|roff
operator|&
operator|(
name|bfd_vma
operator|)
operator|-
literal|4
operator|)
expr_stmt|;
if|if
condition|(
name|offset
operator|<
operator|-
literal|0x1000000
operator|||
name|offset
operator|>
literal|0x0FFFFF0
condition|)
continue|continue;
name|amt
operator|=
name|trampoff
operator|+
name|size
expr_stmt|;
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_realloc
argument_list|(
name|contents
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|sec
operator|->
name|_cooked_size
operator|=
name|amt
expr_stmt|;
if|if
condition|(
name|tsec
operator|==
name|ia64_info
operator|->
name|plt_sec
condition|)
block|{
name|memcpy
argument_list|(
name|contents
operator|+
name|trampoff
argument_list|,
name|plt_full_entry
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* Hijack the old relocation for use as the PLTOFF reloc.  */
name|irel
operator|->
name|r_info
operator|=
name|ELFNN_R_INFO
argument_list|(
name|ELFNN_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
name|R_IA64_PLTOFF22
argument_list|)
expr_stmt|;
name|irel
operator|->
name|r_offset
operator|=
name|trampoff
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|size
operator|==
sizeof|sizeof
argument_list|(
name|oor_ip
argument_list|)
condition|)
block|{
name|memcpy
argument_list|(
name|contents
operator|+
name|trampoff
argument_list|,
name|oor_ip
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|irel
operator|->
name|r_info
operator|=
name|ELFNN_R_INFO
argument_list|(
name|ELFNN_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
name|R_IA64_PCREL64I
argument_list|)
expr_stmt|;
name|irel
operator|->
name|r_addend
operator|-=
literal|16
expr_stmt|;
name|irel
operator|->
name|r_offset
operator|=
name|trampoff
operator|+
literal|2
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|contents
operator|+
name|trampoff
argument_list|,
name|oor_brl
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|irel
operator|->
name|r_info
operator|=
name|ELFNN_R_INFO
argument_list|(
name|ELFNN_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
name|R_IA64_PCREL60B
argument_list|)
expr_stmt|;
name|irel
operator|->
name|r_offset
operator|=
name|trampoff
operator|+
literal|2
expr_stmt|;
block|}
block|}
comment|/* Record the fixup so we don't do it again this section.  */
name|f
operator|=
operator|(
expr|struct
name|one_fixup
operator|*
operator|)
name|bfd_malloc
argument_list|(
operator|(
name|bfd_size_type
operator|)
sizeof|sizeof
argument_list|(
operator|*
name|f
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|->
name|next
operator|=
name|fixups
expr_stmt|;
name|f
operator|->
name|tsec
operator|=
name|tsec
expr_stmt|;
name|f
operator|->
name|toff
operator|=
name|toff
expr_stmt|;
name|f
operator|->
name|trampoff
operator|=
name|trampoff
expr_stmt|;
name|fixups
operator|=
name|f
expr_stmt|;
block|}
else|else
block|{
comment|/* If trampoline is out of range, there is nothing we 		 can do.  */
name|offset
operator|=
name|f
operator|->
name|trampoff
operator|-
operator|(
name|roff
operator|&
operator|(
name|bfd_vma
operator|)
operator|-
literal|4
operator|)
expr_stmt|;
if|if
condition|(
name|offset
operator|<
operator|-
literal|0x1000000
operator|||
name|offset
operator|>
literal|0x0FFFFF0
condition|)
continue|continue;
comment|/* Nop out the reloc, since we're finalizing things here.  */
name|irel
operator|->
name|r_info
operator|=
name|ELFNN_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_IA64_NONE
argument_list|)
expr_stmt|;
block|}
comment|/* Fix up the existing branch to hit the trampoline.  */
if|if
condition|(
name|elfNN_ia64_install_value
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|roff
argument_list|,
name|offset
argument_list|,
name|r_type
argument_list|)
operator|!=
name|bfd_reloc_ok
condition|)
goto|goto
name|error_return
goto|;
name|changed_contents
operator|=
name|TRUE
expr_stmt|;
name|changed_relocs
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* Fetch the gp.  */
if|if
condition|(
name|gp
operator|==
literal|0
condition|)
block|{
name|bfd
modifier|*
name|obfd
init|=
name|sec
operator|->
name|output_section
operator|->
name|owner
decl_stmt|;
name|gp
operator|=
name|_bfd_get_gp_value
argument_list|(
name|obfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|gp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|elfNN_ia64_choose_gp
argument_list|(
name|obfd
argument_list|,
name|link_info
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
name|gp
operator|=
name|_bfd_get_gp_value
argument_list|(
name|obfd
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If the data is out of range, do nothing.  */
if|if
condition|(
call|(
name|bfd_signed_vma
call|)
argument_list|(
name|symaddr
operator|-
name|gp
argument_list|)
operator|>=
literal|0x200000
operator|||
call|(
name|bfd_signed_vma
call|)
argument_list|(
name|symaddr
operator|-
name|gp
argument_list|)
operator|<
operator|-
literal|0x200000
condition|)
continue|continue;
if|if
condition|(
name|r_type
operator|==
name|R_IA64_LTOFF22X
condition|)
block|{
name|irel
operator|->
name|r_info
operator|=
name|ELFNN_R_INFO
argument_list|(
name|ELFNN_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
name|R_IA64_GPREL22
argument_list|)
expr_stmt|;
name|changed_relocs
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|dyn_i
operator|->
name|want_gotx
condition|)
block|{
name|dyn_i
operator|->
name|want_gotx
operator|=
literal|0
expr_stmt|;
name|changed_got
operator||=
operator|!
name|dyn_i
operator|->
name|want_got
expr_stmt|;
block|}
block|}
else|else
block|{
name|elfNN_ia64_relax_ldxmov
argument_list|(
name|abfd
argument_list|,
name|contents
argument_list|,
name|roff
argument_list|)
expr_stmt|;
name|irel
operator|->
name|r_info
operator|=
name|ELFNN_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_IA64_NONE
argument_list|)
expr_stmt|;
name|changed_contents
operator|=
name|TRUE
expr_stmt|;
name|changed_relocs
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
comment|/* ??? If we created fixups, this may push the code segment large      enough that the data segment moves, which will change the GP.      Reset the GP so that we re-calculate next round.  We need to      do this at the _beginning_ of the next round; now will not do.  */
comment|/* Clean up and go home.  */
while|while
condition|(
name|fixups
condition|)
block|{
name|struct
name|one_fixup
modifier|*
name|f
init|=
name|fixups
decl_stmt|;
name|fixups
operator|=
name|fixups
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isymbuf
operator|!=
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
condition|)
block|{
if|if
condition|(
operator|!
name|link_info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|isymbuf
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Cache the symbols for elf_link_input_bfd.  */
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
expr_stmt|;
block|}
block|}
if|if
condition|(
name|contents
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|contents
condition|)
block|{
if|if
condition|(
operator|!
name|changed_contents
operator|&&
operator|!
name|link_info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Cache the section contents for elf_link_input_bfd.  */
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
block|}
block|}
if|if
condition|(
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|!=
name|internal_relocs
condition|)
block|{
if|if
condition|(
operator|!
name|changed_relocs
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
else|else
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|=
name|internal_relocs
expr_stmt|;
block|}
if|if
condition|(
name|changed_got
condition|)
block|{
name|struct
name|elfNN_ia64_allocate_data
name|data
decl_stmt|;
name|data
operator|.
name|info
operator|=
name|link_info
expr_stmt|;
name|data
operator|.
name|ofs
operator|=
literal|0
expr_stmt|;
name|ia64_info
operator|->
name|self_dtpmod_offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
name|elfNN_ia64_dyn_sym_traverse
argument_list|(
name|ia64_info
argument_list|,
name|allocate_global_data_got
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
name|elfNN_ia64_dyn_sym_traverse
argument_list|(
name|ia64_info
argument_list|,
name|allocate_global_fptr_got
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
name|elfNN_ia64_dyn_sym_traverse
argument_list|(
name|ia64_info
argument_list|,
name|allocate_local_got
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
name|ia64_info
operator|->
name|got_sec
operator|->
name|_raw_size
operator|=
name|data
operator|.
name|ofs
expr_stmt|;
name|ia64_info
operator|->
name|got_sec
operator|->
name|_cooked_size
operator|=
name|data
operator|.
name|ofs
expr_stmt|;
comment|/* ??? Resize .rela.got too.  */
block|}
if|if
condition|(
operator|!
name|link_info
operator|->
name|need_relax_finalize
condition|)
name|sec
operator|->
name|need_finalize_relax
operator|=
literal|0
expr_stmt|;
operator|*
name|again
operator|=
name|changed_contents
operator|||
name|changed_relocs
expr_stmt|;
return|return
name|TRUE
return|;
name|error_return
label|:
if|if
condition|(
name|isymbuf
operator|!=
name|NULL
operator|&&
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
operator|!=
name|symtab_hdr
operator|->
name|contents
condition|)
name|free
argument_list|(
name|isymbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|contents
condition|)
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|!=
name|internal_relocs
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|elfNN_ia64_relax_ldxmov
parameter_list|(
name|abfd
parameter_list|,
name|contents
parameter_list|,
name|off
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|bfd_vma
name|off
decl_stmt|;
block|{
name|int
name|shift
decl_stmt|,
name|r1
decl_stmt|,
name|r3
decl_stmt|;
name|bfd_vma
name|dword
decl_stmt|,
name|insn
decl_stmt|;
switch|switch
condition|(
operator|(
name|int
operator|)
name|off
operator|&
literal|0x3
condition|)
block|{
case|case
literal|0
case|:
name|shift
operator|=
literal|5
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|shift
operator|=
literal|14
expr_stmt|;
name|off
operator|+=
literal|3
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|shift
operator|=
literal|23
expr_stmt|;
name|off
operator|+=
literal|6
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|dword
operator|=
name|bfd_get_64
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|off
argument_list|)
expr_stmt|;
name|insn
operator|=
operator|(
name|dword
operator|>>
name|shift
operator|)
operator|&
literal|0x1ffffffffffLL
expr_stmt|;
name|r1
operator|=
operator|(
name|insn
operator|>>
literal|6
operator|)
operator|&
literal|127
expr_stmt|;
name|r3
operator|=
operator|(
name|insn
operator|>>
literal|20
operator|)
operator|&
literal|127
expr_stmt|;
if|if
condition|(
name|r1
operator|==
name|r3
condition|)
name|insn
operator|=
literal|0x8000000
expr_stmt|;
comment|/* nop */
else|else
name|insn
operator|=
operator|(
name|insn
operator|&
literal|0x7f01fff
operator|)
operator||
literal|0x10800000000LL
expr_stmt|;
comment|/* (qp) mov r1 = r3 */
name|dword
operator|&=
operator|~
operator|(
literal|0x1ffffffffffLL
operator|<<
name|shift
operator|)
expr_stmt|;
name|dword
operator||=
operator|(
name|insn
operator|<<
name|shift
operator|)
expr_stmt|;
name|bfd_put_64
argument_list|(
name|abfd
argument_list|,
name|dword
argument_list|,
name|contents
operator|+
name|off
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return TRUE if NAME is an unwind table section name.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bfd_boolean
name|is_unwind_section_name
parameter_list|(
name|abfd
parameter_list|,
name|name
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|size_t
name|len1
decl_stmt|,
name|len2
decl_stmt|,
name|len3
decl_stmt|;
if|if
condition|(
name|elfNN_ia64_hpux_vec
argument_list|(
name|abfd
operator|->
name|xvec
argument_list|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|ELF_STRING_ia64_unwind_hdr
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|len1
operator|=
sizeof|sizeof
argument_list|(
name|ELF_STRING_ia64_unwind
argument_list|)
operator|-
literal|1
expr_stmt|;
name|len2
operator|=
sizeof|sizeof
argument_list|(
name|ELF_STRING_ia64_unwind_info
argument_list|)
operator|-
literal|1
expr_stmt|;
name|len3
operator|=
sizeof|sizeof
argument_list|(
name|ELF_STRING_ia64_unwind_once
argument_list|)
operator|-
literal|1
expr_stmt|;
return|return
operator|(
operator|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|ELF_STRING_ia64_unwind
argument_list|,
name|len1
argument_list|)
operator|==
literal|0
operator|&&
name|strncmp
argument_list|(
name|name
argument_list|,
name|ELF_STRING_ia64_unwind_info
argument_list|,
name|len2
argument_list|)
operator|!=
literal|0
operator|)
operator|||
name|strncmp
argument_list|(
name|name
argument_list|,
name|ELF_STRING_ia64_unwind_once
argument_list|,
name|len3
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Handle an IA-64 specific section when reading an object file.  This    is called when elfcode.h finds a section with an unknown type.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elfNN_ia64_section_from_shdr
parameter_list|(
name|abfd
parameter_list|,
name|hdr
parameter_list|,
name|name
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|asection
modifier|*
name|newsect
decl_stmt|;
comment|/* There ought to be a place to keep ELF backend specific flags, but      at the moment there isn't one.  We just keep track of the      sections by their name, instead.  Fortunately, the ABI gives      suggested names for all the MIPS specific sections, so we will      probably get away with this.  */
switch|switch
condition|(
name|hdr
operator|->
name|sh_type
condition|)
block|{
case|case
name|SHT_IA_64_UNWIND
case|:
case|case
name|SHT_IA_64_HP_OPT_ANOT
case|:
break|break;
case|case
name|SHT_IA_64_EXT
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|ELF_STRING_ia64_archext
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
break|break;
default|default:
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|_bfd_elf_make_section_from_shdr
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|newsect
operator|=
name|hdr
operator|->
name|bfd_section
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Convert IA-64 specific section flags to bfd internal section flags.  */
end_comment

begin_comment
comment|/* ??? There is no bfd internal flag equivalent to the SHF_IA_64_NORECOV    flag.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elfNN_ia64_section_flags
parameter_list|(
name|flags
parameter_list|,
name|hdr
parameter_list|)
name|flagword
modifier|*
name|flags
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
block|{
if|if
condition|(
name|hdr
operator|->
name|sh_flags
operator|&
name|SHF_IA_64_SHORT
condition|)
operator|*
name|flags
operator||=
name|SEC_SMALL_DATA
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Set the correct type for an IA-64 ELF section.  We do this by the    section name, which is a hack, but ought to work.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elfNN_ia64_fake_sections
parameter_list|(
name|abfd
parameter_list|,
name|hdr
parameter_list|,
name|sec
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
block|{
specifier|register
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_unwind_section_name
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
condition|)
block|{
comment|/* We don't have the sections numbered at this point, so sh_info 	 is set later, in elfNN_ia64_final_write_processing.  */
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_IA_64_UNWIND
expr_stmt|;
name|hdr
operator|->
name|sh_flags
operator||=
name|SHF_LINK_ORDER
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|ELF_STRING_ia64_archext
argument_list|)
operator|==
literal|0
condition|)
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_IA_64_EXT
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".HP.opt_annot"
argument_list|)
operator|==
literal|0
condition|)
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_IA_64_HP_OPT_ANOT
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".reloc"
argument_list|)
operator|==
literal|0
condition|)
comment|/* This is an ugly, but unfortunately necessary hack that is        needed when producing EFI binaries on IA-64. It tells        elf.c:elf_fake_sections() not to consider ".reloc" as a section        containing ELF relocation info.  We need this hack in order to        be able to generate ELF binaries that can be translated into        EFI applications (which are essentially COFF objects).  Those        files contain a COFF ".reloc" section inside an ELFNN object,        which would normally cause BFD to segfault because it would        attempt to interpret this section as containing relocation        entries for section "oc".  With this hack enabled, ".reloc"        will be treated as a normal data section, which will avoid the        segfault.  However, you won't be able to create an ELFNN binary        with a section named "oc" that needs relocations, but that's        the kind of ugly side-effects you get when detecting section        types based on their names...  In practice, this limitation is        unlikely to bite.  */
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_PROGBITS
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|flags
operator|&
name|SEC_SMALL_DATA
condition|)
name|hdr
operator|->
name|sh_flags
operator||=
name|SHF_IA_64_SHORT
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* The final processing done just before writing out an IA-64 ELF    object file.  */
end_comment

begin_function
specifier|static
name|void
name|elfNN_ia64_final_write_processing
parameter_list|(
name|abfd
parameter_list|,
name|linker
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|bfd_boolean
name|linker
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
specifier|const
name|char
modifier|*
name|sname
decl_stmt|;
name|asection
modifier|*
name|text_sect
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|size_t
name|len
decl_stmt|;
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|hdr
operator|=
operator|&
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|this_hdr
expr_stmt|;
switch|switch
condition|(
name|hdr
operator|->
name|sh_type
condition|)
block|{
case|case
name|SHT_IA_64_UNWIND
case|:
comment|/* See comments in gas/config/tc-ia64.c:dot_endp on why we 	     have to do this.  */
name|sname
operator|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|ELF_STRING_ia64_unwind
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|sname
operator|&&
name|strncmp
argument_list|(
name|sname
argument_list|,
name|ELF_STRING_ia64_unwind
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sname
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|sname
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
comment|/* .IA_64.unwind -> .text */
name|text_sect
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".text"
argument_list|)
expr_stmt|;
else|else
comment|/* .IA_64.unwindFOO -> FOO */
name|text_sect
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|sname
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sname
operator|&&
operator|(
name|len
operator|=
sizeof|sizeof
argument_list|(
name|ELF_STRING_ia64_unwind_once
argument_list|)
operator|-
literal|1
operator|,
name|strncmp
argument_list|(
name|sname
argument_list|,
name|ELF_STRING_ia64_unwind_once
argument_list|,
name|len
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* .gnu.linkonce.ia64unw.FOO -> .gnu.linkonce.t.FOO */
name|size_t
name|len2
init|=
sizeof|sizeof
argument_list|(
literal|".gnu.linkonce.t."
argument_list|)
operator|-
literal|1
decl_stmt|;
name|char
modifier|*
name|once_name
init|=
name|bfd_malloc
argument_list|(
name|len2
operator|+
name|strlen
argument_list|(
name|sname
operator|+
name|len
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|once_name
operator|!=
name|NULL
condition|)
block|{
name|memcpy
argument_list|(
name|once_name
argument_list|,
literal|".gnu.linkonce.t."
argument_list|,
name|len2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|once_name
operator|+
name|len2
argument_list|,
name|sname
operator|+
name|len
argument_list|)
expr_stmt|;
name|text_sect
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|once_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|once_name
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Should only happen if we run out of memory, in 		   which case we're probably toast anyway.  Try to 		   cope by finding the section the slow way.  */
for|for
control|(
name|text_sect
operator|=
name|abfd
operator|->
name|sections
init|;
name|text_sect
operator|!=
name|NULL
condition|;
name|text_sect
operator|=
name|text_sect
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|bfd_section_name
argument_list|(
name|abfd
argument_list|,
name|text_sect
argument_list|)
argument_list|,
literal|".gnu.linkonce.t."
argument_list|,
name|len2
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|bfd_section_name
argument_list|(
name|abfd
argument_list|,
name|text_sect
argument_list|)
operator|+
name|len2
argument_list|,
name|sname
operator|+
name|len
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
block|}
else|else
comment|/* last resort: fall back on .text */
name|text_sect
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".text"
argument_list|)
expr_stmt|;
if|if
condition|(
name|text_sect
condition|)
block|{
comment|/* The IA-64 processor-specific ABI requires setting 		 sh_link to the unwind section, whereas HP-UX requires 		 sh_info to do so.  For maximum compatibility, we'll 		 set both for now... */
name|hdr
operator|->
name|sh_link
operator|=
name|elf_section_data
argument_list|(
name|text_sect
argument_list|)
operator|->
name|this_idx
expr_stmt|;
name|hdr
operator|->
name|sh_info
operator|=
name|elf_section_data
argument_list|(
name|text_sect
argument_list|)
operator|->
name|this_idx
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|elf_flags_init
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|unsigned
name|long
name|flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|abfd
operator|->
name|xvec
operator|->
name|byteorder
operator|==
name|BFD_ENDIAN_BIG
condition|)
name|flags
operator||=
name|EF_IA_64_BE
expr_stmt|;
if|if
condition|(
name|bfd_get_mach
argument_list|(
name|abfd
argument_list|)
operator|==
name|bfd_mach_ia64_elf64
condition|)
name|flags
operator||=
name|EF_IA_64_ABI64
expr_stmt|;
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|=
name|flags
expr_stmt|;
name|elf_flags_init
argument_list|(
name|abfd
argument_list|)
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Hook called by the linker routine which adds symbols from an object    file.  We use it to put .comm items in .sbss, and not .bss.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elfNN_ia64_add_symbol_hook
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|sym
parameter_list|,
name|namep
parameter_list|,
name|flagsp
parameter_list|,
name|secp
parameter_list|,
name|valp
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|namep
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|flagword
modifier|*
name|flagsp
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
modifier|*
name|secp
decl_stmt|;
name|bfd_vma
modifier|*
name|valp
decl_stmt|;
block|{
if|if
condition|(
name|sym
operator|->
name|st_shndx
operator|==
name|SHN_COMMON
operator|&&
operator|!
name|info
operator|->
name|relocatable
operator|&&
name|sym
operator|->
name|st_size
operator|<=
name|elf_gp_size
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
comment|/* Common symbols less than or equal to -G nn bytes are 	 automatically put into .sbss.  */
name|asection
modifier|*
name|scomm
init|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".scommon"
argument_list|)
decl_stmt|;
if|if
condition|(
name|scomm
operator|==
name|NULL
condition|)
block|{
name|scomm
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".scommon"
argument_list|)
expr_stmt|;
if|if
condition|(
name|scomm
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|scomm
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_IS_COMMON
operator||
name|SEC_LINKER_CREATED
operator|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
operator|*
name|secp
operator|=
name|scomm
expr_stmt|;
operator|*
name|valp
operator|=
name|sym
operator|->
name|st_size
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return the number of additional phdrs we will need.  */
end_comment

begin_function
specifier|static
name|int
name|elfNN_ia64_additional_program_headers
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
comment|/* See if we need a PT_IA_64_ARCHEXT segment.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|ELF_STRING_ia64_archext
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
condition|)
operator|++
name|ret
expr_stmt|;
comment|/* Count how many PT_IA_64_UNWIND segments we need.  */
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
if|if
condition|(
name|is_unwind_section_name
argument_list|(
name|abfd
argument_list|,
name|s
operator|->
name|name
argument_list|)
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
condition|)
operator|++
name|ret
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elfNN_ia64_modify_segment_map
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|struct
name|elf_segment_map
modifier|*
name|m
decl_stmt|,
modifier|*
modifier|*
name|pm
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
comment|/* If we need a PT_IA_64_ARCHEXT segment, it must come before      all PT_LOAD segments.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|ELF_STRING_ia64_archext
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
condition|)
block|{
for|for
control|(
name|m
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_map
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
if|if
condition|(
name|m
operator|->
name|p_type
operator|==
name|PT_IA_64_ARCHEXT
condition|)
break|break;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|m
operator|=
operator|(
operator|(
expr|struct
name|elf_segment_map
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_size_type
operator|)
sizeof|sizeof
expr|*
name|m
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|m
operator|->
name|p_type
operator|=
name|PT_IA_64_ARCHEXT
expr_stmt|;
name|m
operator|->
name|count
operator|=
literal|1
expr_stmt|;
name|m
operator|->
name|sections
index|[
literal|0
index|]
operator|=
name|s
expr_stmt|;
comment|/* We want to put it after the PHDR and INTERP segments.  */
name|pm
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_map
expr_stmt|;
while|while
condition|(
operator|*
name|pm
operator|!=
name|NULL
operator|&&
operator|(
operator|(
operator|*
name|pm
operator|)
operator|->
name|p_type
operator|==
name|PT_PHDR
operator|||
operator|(
operator|*
name|pm
operator|)
operator|->
name|p_type
operator|==
name|PT_INTERP
operator|)
condition|)
name|pm
operator|=
operator|&
operator|(
operator|*
name|pm
operator|)
operator|->
name|next
expr_stmt|;
name|m
operator|->
name|next
operator|=
operator|*
name|pm
expr_stmt|;
operator|*
name|pm
operator|=
name|m
expr_stmt|;
block|}
block|}
comment|/* Install PT_IA_64_UNWIND segments, if needed.  */
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|hdr
operator|=
operator|&
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|this_hdr
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|sh_type
operator|!=
name|SHT_IA_64_UNWIND
condition|)
continue|continue;
if|if
condition|(
name|s
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
condition|)
block|{
for|for
control|(
name|m
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_map
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
if|if
condition|(
name|m
operator|->
name|p_type
operator|==
name|PT_IA_64_UNWIND
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Look through all sections in the unwind segment 		   for a match since there may be multiple sections 		   to a segment.  */
for|for
control|(
name|i
operator|=
name|m
operator|->
name|count
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
if|if
condition|(
name|m
operator|->
name|sections
index|[
name|i
index|]
operator|==
name|s
condition|)
break|break;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|m
operator|=
operator|(
operator|(
expr|struct
name|elf_segment_map
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_size_type
operator|)
sizeof|sizeof
expr|*
name|m
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|m
operator|->
name|p_type
operator|=
name|PT_IA_64_UNWIND
expr_stmt|;
name|m
operator|->
name|count
operator|=
literal|1
expr_stmt|;
name|m
operator|->
name|sections
index|[
literal|0
index|]
operator|=
name|s
expr_stmt|;
name|m
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
comment|/* We want to put it last.  */
name|pm
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_map
expr_stmt|;
while|while
condition|(
operator|*
name|pm
operator|!=
name|NULL
condition|)
name|pm
operator|=
operator|&
operator|(
operator|*
name|pm
operator|)
operator|->
name|next
expr_stmt|;
operator|*
name|pm
operator|=
name|m
expr_stmt|;
block|}
block|}
block|}
comment|/* Turn on PF_IA_64_NORECOV if needed.  This involves traversing all of      the input sections for each output section in the segment and testing      for SHF_IA_64_NORECOV on each.  */
for|for
control|(
name|m
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_map
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
if|if
condition|(
name|m
operator|->
name|p_type
operator|==
name|PT_LOAD
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|m
operator|->
name|count
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|struct
name|bfd_link_order
modifier|*
name|order
init|=
name|m
operator|->
name|sections
index|[
name|i
index|]
operator|->
name|link_order_head
decl_stmt|;
while|while
condition|(
name|order
condition|)
block|{
if|if
condition|(
name|order
operator|->
name|type
operator|==
name|bfd_indirect_link_order
condition|)
block|{
name|asection
modifier|*
name|is
init|=
name|order
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
decl_stmt|;
name|bfd_vma
name|flags
init|=
name|elf_section_data
argument_list|(
name|is
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_flags
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|SHF_IA_64_NORECOV
condition|)
block|{
name|m
operator|->
name|p_flags
operator||=
name|PF_IA_64_NORECOV
expr_stmt|;
goto|goto
name|found
goto|;
block|}
block|}
name|order
operator|=
name|order
operator|->
name|next
expr_stmt|;
block|}
block|}
name|found
label|:
empty_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* According to the Tahoe assembler spec, all labels starting with a    '.' are local.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elfNN_ia64_is_local_label_name
parameter_list|(
name|abfd
parameter_list|,
name|name
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
return|return
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
return|;
block|}
end_function

begin_comment
comment|/* Should we do dynamic things to this symbol?  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elfNN_ia64_dynamic_symbol_p
parameter_list|(
name|h
parameter_list|,
name|info
parameter_list|,
name|r_type
parameter_list|)
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|int
name|r_type
decl_stmt|;
block|{
name|bfd_boolean
name|ignore_protected
init|=
operator|(
operator|(
name|r_type
operator|&
literal|0xf8
operator|)
operator|==
literal|0x40
comment|/* FPTR relocs */
operator|||
operator|(
name|r_type
operator|&
literal|0xf8
operator|)
operator|==
literal|0x50
operator|)
decl_stmt|;
comment|/* LTOFF_FPTR relocs */
return|return
name|_bfd_elf_dynamic_symbol_p
argument_list|(
name|h
argument_list|,
name|info
argument_list|,
name|ignore_protected
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|elfNN_ia64_new_elf_hash_entry
parameter_list|(
name|entry
parameter_list|,
name|table
parameter_list|,
name|string
parameter_list|)
name|struct
name|bfd_hash_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|bfd_hash_table
modifier|*
name|table
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|struct
name|elfNN_ia64_link_hash_entry
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
operator|(
expr|struct
name|elfNN_ia64_link_hash_entry
operator|*
operator|)
name|entry
expr_stmt|;
comment|/* Allocate the structure if it has not already been allocated by a      subclass.  */
if|if
condition|(
operator|!
name|ret
condition|)
name|ret
operator|=
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ret
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
return|return
literal|0
return|;
comment|/* Initialize our local data.  All zeros, and definitely easier      than setting a handful of bit fields.  */
name|memset
argument_list|(
name|ret
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ret
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Call the allocation method of the superclass.  */
name|ret
operator|=
operator|(
operator|(
expr|struct
name|elfNN_ia64_link_hash_entry
operator|*
operator|)
name|_bfd_elf_link_hash_newfunc
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
operator|)
expr_stmt|;
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|elfNN_ia64_hash_copy_indirect
parameter_list|(
name|bed
parameter_list|,
name|xdir
parameter_list|,
name|xind
parameter_list|)
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|xdir
decl_stmt|,
decl|*
name|xind
decl_stmt|;
end_function

begin_block
block|{
name|struct
name|elfNN_ia64_link_hash_entry
modifier|*
name|dir
decl_stmt|,
modifier|*
name|ind
decl_stmt|;
name|dir
operator|=
operator|(
expr|struct
name|elfNN_ia64_link_hash_entry
operator|*
operator|)
name|xdir
expr_stmt|;
name|ind
operator|=
operator|(
expr|struct
name|elfNN_ia64_link_hash_entry
operator|*
operator|)
name|xind
expr_stmt|;
comment|/* Copy down any references that we may have already seen to the      symbol which just became indirect.  */
name|dir
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator||=
operator|(
name|ind
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator|&
operator|(
name|ELF_LINK_HASH_REF_DYNAMIC
operator||
name|ELF_LINK_HASH_REF_REGULAR
operator||
name|ELF_LINK_HASH_REF_REGULAR_NONWEAK
operator||
name|ELF_LINK_HASH_NEEDS_PLT
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|ind
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_indirect
condition|)
return|return;
comment|/* Copy over the got and plt data.  This would have been done      by check_relocs.  */
if|if
condition|(
name|dir
operator|->
name|info
operator|==
name|NULL
condition|)
block|{
name|struct
name|elfNN_ia64_dyn_sym_info
modifier|*
name|dyn_i
decl_stmt|;
name|dir
operator|->
name|info
operator|=
name|dyn_i
operator|=
name|ind
operator|->
name|info
expr_stmt|;
name|ind
operator|->
name|info
operator|=
name|NULL
expr_stmt|;
comment|/* Fix up the dyn_sym_info pointers to the global symbol.  */
for|for
control|(
init|;
name|dyn_i
condition|;
name|dyn_i
operator|=
name|dyn_i
operator|->
name|next
control|)
name|dyn_i
operator|->
name|h
operator|=
operator|&
name|dir
operator|->
name|root
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
name|ind
operator|->
name|info
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* Copy over the dynindx.  */
if|if
condition|(
name|dir
operator|->
name|root
operator|.
name|dynindx
operator|==
operator|-
literal|1
condition|)
block|{
name|dir
operator|->
name|root
operator|.
name|dynindx
operator|=
name|ind
operator|->
name|root
operator|.
name|dynindx
expr_stmt|;
name|dir
operator|->
name|root
operator|.
name|dynstr_index
operator|=
name|ind
operator|->
name|root
operator|.
name|dynstr_index
expr_stmt|;
name|ind
operator|->
name|root
operator|.
name|dynindx
operator|=
operator|-
literal|1
expr_stmt|;
name|ind
operator|->
name|root
operator|.
name|dynstr_index
operator|=
literal|0
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
name|ind
operator|->
name|root
operator|.
name|dynindx
operator|==
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|elfNN_ia64_hash_hide_symbol
parameter_list|(
name|info
parameter_list|,
name|xh
parameter_list|,
name|force_local
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|xh
decl_stmt|;
name|bfd_boolean
name|force_local
decl_stmt|;
block|{
name|struct
name|elfNN_ia64_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|elfNN_ia64_dyn_sym_info
modifier|*
name|dyn_i
decl_stmt|;
name|h
operator|=
operator|(
expr|struct
name|elfNN_ia64_link_hash_entry
operator|*
operator|)
name|xh
expr_stmt|;
name|_bfd_elf_link_hash_hide_symbol
argument_list|(
name|info
argument_list|,
operator|&
name|h
operator|->
name|root
argument_list|,
name|force_local
argument_list|)
expr_stmt|;
for|for
control|(
name|dyn_i
operator|=
name|h
operator|->
name|info
init|;
name|dyn_i
condition|;
name|dyn_i
operator|=
name|dyn_i
operator|->
name|next
control|)
block|{
name|dyn_i
operator|->
name|want_plt2
operator|=
literal|0
expr_stmt|;
name|dyn_i
operator|->
name|want_plt
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Compute a hash of a local hash entry.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|elfNN_ia64_local_htab_hash
parameter_list|(
name|ptr
parameter_list|)
specifier|const
name|void
modifier|*
name|ptr
decl_stmt|;
block|{
name|struct
name|elfNN_ia64_local_hash_entry
modifier|*
name|entry
init|=
operator|(
expr|struct
name|elfNN_ia64_local_hash_entry
operator|*
operator|)
name|ptr
decl_stmt|;
return|return
operator|(
operator|(
operator|(
name|entry
operator|->
name|id
operator|&
literal|0xff
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|entry
operator|->
name|id
operator|&
literal|0xff00
operator|)
operator|<<
literal|8
operator|)
operator|)
operator|^
name|entry
operator|->
name|r_sym
operator|^
operator|(
name|entry
operator|->
name|id
operator|>>
literal|16
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Compare local hash entries.  */
end_comment

begin_function
specifier|static
name|int
name|elfNN_ia64_local_htab_eq
parameter_list|(
name|ptr1
parameter_list|,
name|ptr2
parameter_list|)
specifier|const
name|void
modifier|*
name|ptr1
decl_stmt|,
decl|*
name|ptr2
decl_stmt|;
end_function

begin_block
block|{
name|struct
name|elfNN_ia64_local_hash_entry
modifier|*
name|entry1
init|=
operator|(
expr|struct
name|elfNN_ia64_local_hash_entry
operator|*
operator|)
name|ptr1
decl_stmt|;
name|struct
name|elfNN_ia64_local_hash_entry
modifier|*
name|entry2
init|=
operator|(
expr|struct
name|elfNN_ia64_local_hash_entry
operator|*
operator|)
name|ptr2
decl_stmt|;
return|return
name|entry1
operator|->
name|id
operator|==
name|entry2
operator|->
name|id
operator|&&
name|entry1
operator|->
name|r_sym
operator|==
name|entry2
operator|->
name|r_sym
return|;
block|}
end_block

begin_comment
comment|/* Create the derived linker hash table.  The IA-64 ELF port uses this    derived hash table to keep information specific to the IA-64 ElF    linker (without using static variables).  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_link_hash_table
modifier|*
name|elfNN_ia64_hash_table_create
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|elfNN_ia64_link_hash_table
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
name|bfd_zmalloc
argument_list|(
operator|(
name|bfd_size_type
operator|)
sizeof|sizeof
argument_list|(
operator|*
name|ret
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|_bfd_elf_link_hash_table_init
argument_list|(
operator|&
name|ret
operator|->
name|root
argument_list|,
name|abfd
argument_list|,
name|elfNN_ia64_new_elf_hash_entry
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ret
operator|->
name|loc_hash_table
operator|=
name|htab_try_create
argument_list|(
literal|1024
argument_list|,
name|elfNN_ia64_local_htab_hash
argument_list|,
name|elfNN_ia64_local_htab_eq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ret
operator|->
name|loc_hash_memory
operator|=
name|objalloc_create
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ret
operator|->
name|loc_hash_table
operator|||
operator|!
name|ret
operator|->
name|loc_hash_memory
condition|)
block|{
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
operator|&
name|ret
operator|->
name|root
operator|.
name|root
return|;
block|}
end_function

begin_comment
comment|/* Destroy IA-64 linker hash table.  */
end_comment

begin_function
specifier|static
name|void
name|elfNN_ia64_hash_table_free
parameter_list|(
name|hash
parameter_list|)
name|struct
name|bfd_link_hash_table
modifier|*
name|hash
decl_stmt|;
block|{
name|struct
name|elfNN_ia64_link_hash_table
modifier|*
name|ia64_info
init|=
operator|(
expr|struct
name|elfNN_ia64_link_hash_table
operator|*
operator|)
name|hash
decl_stmt|;
if|if
condition|(
name|ia64_info
operator|->
name|loc_hash_table
condition|)
name|htab_delete
argument_list|(
name|ia64_info
operator|->
name|loc_hash_table
argument_list|)
expr_stmt|;
if|if
condition|(
name|ia64_info
operator|->
name|loc_hash_memory
condition|)
name|objalloc_free
argument_list|(
operator|(
expr|struct
name|objalloc
operator|*
operator|)
name|ia64_info
operator|->
name|loc_hash_memory
argument_list|)
expr_stmt|;
name|_bfd_generic_link_hash_table_free
argument_list|(
name|hash
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Traverse both local and global hash tables.  */
end_comment

begin_struct
struct|struct
name|elfNN_ia64_dyn_sym_traverse_data
block|{
name|bfd_boolean
argument_list|(
argument|*func
argument_list|)
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elfNN_ia64_dyn_sym_info
operator|*
operator|,
name|PTR
operator|)
argument_list|)
expr_stmt|;
name|PTR
name|data
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|bfd_boolean
name|elfNN_ia64_global_dyn_sym_thunk
parameter_list|(
name|xentry
parameter_list|,
name|xdata
parameter_list|)
name|struct
name|bfd_hash_entry
modifier|*
name|xentry
decl_stmt|;
name|PTR
name|xdata
decl_stmt|;
block|{
name|struct
name|elfNN_ia64_link_hash_entry
modifier|*
name|entry
init|=
operator|(
expr|struct
name|elfNN_ia64_link_hash_entry
operator|*
operator|)
name|xentry
decl_stmt|;
name|struct
name|elfNN_ia64_dyn_sym_traverse_data
modifier|*
name|data
init|=
operator|(
expr|struct
name|elfNN_ia64_dyn_sym_traverse_data
operator|*
operator|)
name|xdata
decl_stmt|;
name|struct
name|elfNN_ia64_dyn_sym_info
modifier|*
name|dyn_i
decl_stmt|;
if|if
condition|(
name|entry
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|entry
operator|=
operator|(
expr|struct
name|elfNN_ia64_link_hash_entry
operator|*
operator|)
name|entry
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
for|for
control|(
name|dyn_i
operator|=
name|entry
operator|->
name|info
init|;
name|dyn_i
condition|;
name|dyn_i
operator|=
name|dyn_i
operator|->
name|next
control|)
if|if
condition|(
operator|!
call|(
modifier|*
name|data
operator|->
name|func
call|)
argument_list|(
name|dyn_i
argument_list|,
name|data
operator|->
name|data
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elfNN_ia64_local_dyn_sym_thunk
parameter_list|(
name|slot
parameter_list|,
name|xdata
parameter_list|)
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
name|PTR
name|xdata
decl_stmt|;
block|{
name|struct
name|elfNN_ia64_local_hash_entry
modifier|*
name|entry
init|=
operator|(
expr|struct
name|elfNN_ia64_local_hash_entry
operator|*
operator|)
operator|*
name|slot
decl_stmt|;
name|struct
name|elfNN_ia64_dyn_sym_traverse_data
modifier|*
name|data
init|=
operator|(
expr|struct
name|elfNN_ia64_dyn_sym_traverse_data
operator|*
operator|)
name|xdata
decl_stmt|;
name|struct
name|elfNN_ia64_dyn_sym_info
modifier|*
name|dyn_i
decl_stmt|;
for|for
control|(
name|dyn_i
operator|=
name|entry
operator|->
name|info
init|;
name|dyn_i
condition|;
name|dyn_i
operator|=
name|dyn_i
operator|->
name|next
control|)
if|if
condition|(
operator|!
call|(
modifier|*
name|data
operator|->
name|func
call|)
argument_list|(
name|dyn_i
argument_list|,
name|data
operator|->
name|data
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|elfNN_ia64_dyn_sym_traverse
parameter_list|(
name|ia64_info
parameter_list|,
name|func
parameter_list|,
name|data
parameter_list|)
name|struct
name|elfNN_ia64_link_hash_table
modifier|*
name|ia64_info
decl_stmt|;
function_decl|bfd_boolean
parameter_list|(
function_decl|*func
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elfNN_ia64_dyn_sym_info
operator|*
operator|,
name|PTR
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|PTR
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|elfNN_ia64_dyn_sym_traverse_data
name|xdata
decl_stmt|;
name|xdata
operator|.
name|func
operator|=
name|func
expr_stmt|;
name|xdata
operator|.
name|data
operator|=
name|data
expr_stmt|;
name|elf_link_hash_traverse
argument_list|(
operator|&
name|ia64_info
operator|->
name|root
argument_list|,
name|elfNN_ia64_global_dyn_sym_thunk
argument_list|,
operator|&
name|xdata
argument_list|)
expr_stmt|;
name|htab_traverse
argument_list|(
name|ia64_info
operator|->
name|loc_hash_table
argument_list|,
name|elfNN_ia64_local_dyn_sym_thunk
argument_list|,
operator|&
name|xdata
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_function
specifier|static
name|bfd_boolean
name|elfNN_ia64_create_dynamic_sections
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|struct
name|elfNN_ia64_link_hash_table
modifier|*
name|ia64_info
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|_bfd_elf_create_dynamic_sections
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|ia64_info
operator|=
name|elfNN_ia64_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|ia64_info
operator|->
name|plt_sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
name|ia64_info
operator|->
name|got_sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
block|{
name|flagword
name|flags
init|=
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|ia64_info
operator|->
name|got_sec
argument_list|)
decl_stmt|;
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|ia64_info
operator|->
name|got_sec
argument_list|,
name|SEC_SMALL_DATA
operator||
name|flags
argument_list|)
expr_stmt|;
comment|/* The .got section is always aligned at 8 bytes.  */
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|ia64_info
operator|->
name|got_sec
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|get_pltoff
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|ia64_info
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".rela.IA_64.pltoff"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_READONLY
operator|)
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
literal|3
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|ia64_info
operator|->
name|rel_pltoff_sec
operator|=
name|s
expr_stmt|;
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_READONLY
operator|)
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
literal|3
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|ia64_info
operator|->
name|rel_got_sec
operator|=
name|s
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Find and/or create a hash entry for local symbol.  */
end_comment

begin_function
specifier|static
name|struct
name|elfNN_ia64_local_hash_entry
modifier|*
name|get_local_sym_hash
parameter_list|(
name|ia64_info
parameter_list|,
name|abfd
parameter_list|,
name|rel
parameter_list|,
name|create
parameter_list|)
name|struct
name|elfNN_ia64_link_hash_table
modifier|*
name|ia64_info
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|bfd_boolean
name|create
decl_stmt|;
block|{
name|struct
name|elfNN_ia64_local_hash_entry
name|e
decl_stmt|,
modifier|*
name|ret
decl_stmt|;
name|asection
modifier|*
name|sec
init|=
name|abfd
operator|->
name|sections
decl_stmt|;
name|hashval_t
name|h
init|=
operator|(
operator|(
operator|(
name|sec
operator|->
name|id
operator|&
literal|0xff
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|sec
operator|->
name|id
operator|&
literal|0xff00
operator|)
operator|<<
literal|8
operator|)
operator|)
operator|^
name|ELFNN_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|^
operator|(
name|sec
operator|->
name|id
operator|>>
literal|16
operator|)
decl_stmt|;
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
name|e
operator|.
name|id
operator|=
name|sec
operator|->
name|id
expr_stmt|;
name|e
operator|.
name|r_sym
operator|=
name|ELFNN_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|slot
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|ia64_info
operator|->
name|loc_hash_table
argument_list|,
operator|&
name|e
argument_list|,
name|h
argument_list|,
name|create
condition|?
name|INSERT
else|:
name|NO_INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|slot
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|*
name|slot
condition|)
return|return
operator|(
expr|struct
name|elfNN_ia64_local_hash_entry
operator|*
operator|)
operator|*
name|slot
return|;
name|ret
operator|=
operator|(
expr|struct
name|elfNN_ia64_local_hash_entry
operator|*
operator|)
name|objalloc_alloc
argument_list|(
operator|(
expr|struct
name|objalloc
operator|*
operator|)
name|ia64_info
operator|->
name|loc_hash_memory
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|elfNN_ia64_local_hash_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|memset
argument_list|(
name|ret
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ret
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|->
name|id
operator|=
name|sec
operator|->
name|id
expr_stmt|;
name|ret
operator|->
name|r_sym
operator|=
name|ELFNN_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
operator|*
name|slot
operator|=
name|ret
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Find and/or create a descriptor for dynamic symbol info.  This will    vary based on global or local symbol, and the addend to the reloc.  */
end_comment

begin_function
specifier|static
name|struct
name|elfNN_ia64_dyn_sym_info
modifier|*
name|get_dyn_sym_info
parameter_list|(
name|ia64_info
parameter_list|,
name|h
parameter_list|,
name|abfd
parameter_list|,
name|rel
parameter_list|,
name|create
parameter_list|)
name|struct
name|elfNN_ia64_link_hash_table
modifier|*
name|ia64_info
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|bfd_boolean
name|create
decl_stmt|;
block|{
name|struct
name|elfNN_ia64_dyn_sym_info
modifier|*
modifier|*
name|pp
decl_stmt|;
name|struct
name|elfNN_ia64_dyn_sym_info
modifier|*
name|dyn_i
decl_stmt|;
name|bfd_vma
name|addend
init|=
name|rel
condition|?
name|rel
operator|->
name|r_addend
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|h
condition|)
name|pp
operator|=
operator|&
operator|(
operator|(
expr|struct
name|elfNN_ia64_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|info
expr_stmt|;
else|else
block|{
name|struct
name|elfNN_ia64_local_hash_entry
modifier|*
name|loc_h
decl_stmt|;
name|loc_h
operator|=
name|get_local_sym_hash
argument_list|(
name|ia64_info
argument_list|,
name|abfd
argument_list|,
name|rel
argument_list|,
name|create
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|loc_h
condition|)
block|{
name|BFD_ASSERT
argument_list|(
operator|!
name|create
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|pp
operator|=
operator|&
name|loc_h
operator|->
name|info
expr_stmt|;
block|}
for|for
control|(
name|dyn_i
operator|=
operator|*
name|pp
init|;
name|dyn_i
operator|&&
name|dyn_i
operator|->
name|addend
operator|!=
name|addend
condition|;
name|dyn_i
operator|=
operator|*
name|pp
control|)
name|pp
operator|=
operator|&
name|dyn_i
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|dyn_i
operator|==
name|NULL
operator|&&
name|create
condition|)
block|{
name|dyn_i
operator|=
operator|(
operator|(
expr|struct
name|elfNN_ia64_dyn_sym_info
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_size_type
operator|)
sizeof|sizeof
expr|*
name|dyn_i
argument_list|)
operator|)
expr_stmt|;
operator|*
name|pp
operator|=
name|dyn_i
expr_stmt|;
name|dyn_i
operator|->
name|addend
operator|=
name|addend
expr_stmt|;
block|}
return|return
name|dyn_i
return|;
block|}
end_function

begin_function
specifier|static
name|asection
modifier|*
name|get_got
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|ia64_info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|elfNN_ia64_link_hash_table
modifier|*
name|ia64_info
decl_stmt|;
block|{
name|asection
modifier|*
name|got
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|got
operator|=
name|ia64_info
operator|->
name|got_sec
expr_stmt|;
if|if
condition|(
operator|!
name|got
condition|)
block|{
name|flagword
name|flags
decl_stmt|;
name|dynobj
operator|=
name|ia64_info
operator|->
name|root
operator|.
name|dynobj
expr_stmt|;
if|if
condition|(
operator|!
name|dynobj
condition|)
name|ia64_info
operator|->
name|root
operator|.
name|dynobj
operator|=
name|dynobj
operator|=
name|abfd
expr_stmt|;
if|if
condition|(
operator|!
name|_bfd_elf_create_got_section
argument_list|(
name|dynobj
argument_list|,
name|info
argument_list|)
condition|)
return|return
literal|0
return|;
name|got
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|got
argument_list|)
expr_stmt|;
name|ia64_info
operator|->
name|got_sec
operator|=
name|got
expr_stmt|;
comment|/* The .got section is always aligned at 8 bytes.  */
if|if
condition|(
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|got
argument_list|,
literal|3
argument_list|)
condition|)
return|return
literal|0
return|;
name|flags
operator|=
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|got
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|got
argument_list|,
name|SEC_SMALL_DATA
operator||
name|flags
argument_list|)
expr_stmt|;
block|}
return|return
name|got
return|;
block|}
end_function

begin_comment
comment|/* Create function descriptor section (.opd).  This section is called .opd    because it contains "official procedure descriptors".  The "official"    refers to the fact that these descriptors are used when taking the address    of a procedure, thus ensuring a unique address for each procedure.  */
end_comment

begin_function
specifier|static
name|asection
modifier|*
name|get_fptr
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|ia64_info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|elfNN_ia64_link_hash_table
modifier|*
name|ia64_info
decl_stmt|;
block|{
name|asection
modifier|*
name|fptr
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|fptr
operator|=
name|ia64_info
operator|->
name|fptr_sec
expr_stmt|;
if|if
condition|(
operator|!
name|fptr
condition|)
block|{
name|dynobj
operator|=
name|ia64_info
operator|->
name|root
operator|.
name|dynobj
expr_stmt|;
if|if
condition|(
operator|!
name|dynobj
condition|)
name|ia64_info
operator|->
name|root
operator|.
name|dynobj
operator|=
name|dynobj
operator|=
name|abfd
expr_stmt|;
name|fptr
operator|=
name|bfd_make_section
argument_list|(
name|dynobj
argument_list|,
literal|".opd"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fptr
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|dynobj
argument_list|,
name|fptr
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
operator|(
name|info
operator|->
name|pie
condition|?
literal|0
else|:
name|SEC_READONLY
operator|)
operator||
name|SEC_LINKER_CREATED
operator|)
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|fptr
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|BFD_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ia64_info
operator|->
name|fptr_sec
operator|=
name|fptr
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|pie
condition|)
block|{
name|asection
modifier|*
name|fptr_rel
decl_stmt|;
name|fptr_rel
operator|=
name|bfd_make_section
argument_list|(
name|dynobj
argument_list|,
literal|".rela.opd"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fptr_rel
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|dynobj
argument_list|,
name|fptr_rel
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_READONLY
operator|)
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|fptr_rel
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|BFD_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ia64_info
operator|->
name|rel_fptr_sec
operator|=
name|fptr_rel
expr_stmt|;
block|}
block|}
return|return
name|fptr
return|;
block|}
end_function

begin_function
specifier|static
name|asection
modifier|*
name|get_pltoff
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|ia64_info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|elfNN_ia64_link_hash_table
modifier|*
name|ia64_info
decl_stmt|;
block|{
name|asection
modifier|*
name|pltoff
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|pltoff
operator|=
name|ia64_info
operator|->
name|pltoff_sec
expr_stmt|;
if|if
condition|(
operator|!
name|pltoff
condition|)
block|{
name|dynobj
operator|=
name|ia64_info
operator|->
name|root
operator|.
name|dynobj
expr_stmt|;
if|if
condition|(
operator|!
name|dynobj
condition|)
name|ia64_info
operator|->
name|root
operator|.
name|dynobj
operator|=
name|dynobj
operator|=
name|abfd
expr_stmt|;
name|pltoff
operator|=
name|bfd_make_section
argument_list|(
name|dynobj
argument_list|,
name|ELF_STRING_ia64_pltoff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pltoff
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|dynobj
argument_list|,
name|pltoff
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_SMALL_DATA
operator||
name|SEC_LINKER_CREATED
operator|)
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|pltoff
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|BFD_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ia64_info
operator|->
name|pltoff_sec
operator|=
name|pltoff
expr_stmt|;
block|}
return|return
name|pltoff
return|;
block|}
end_function

begin_function
specifier|static
name|asection
modifier|*
name|get_reloc_section
parameter_list|(
name|abfd
parameter_list|,
name|ia64_info
parameter_list|,
name|sec
parameter_list|,
name|create
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|elfNN_ia64_link_hash_table
modifier|*
name|ia64_info
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_boolean
name|create
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|srel_name
decl_stmt|;
name|asection
modifier|*
name|srel
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|srel_name
operator|=
operator|(
name|bfd_elf_string_from_elf_section
argument_list|(
name|abfd
argument_list|,
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_shstrndx
argument_list|,
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|rel_hdr
operator|.
name|sh_name
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|srel_name
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|BFD_ASSERT
argument_list|(
operator|(
name|strncmp
argument_list|(
name|srel_name
argument_list|,
literal|".rela"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|,
name|srel_name
operator|+
literal|5
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strncmp
argument_list|(
name|srel_name
argument_list|,
literal|".rel"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|,
name|srel_name
operator|+
literal|4
argument_list|)
operator|==
literal|0
operator|)
argument_list|)
expr_stmt|;
name|dynobj
operator|=
name|ia64_info
operator|->
name|root
operator|.
name|dynobj
expr_stmt|;
if|if
condition|(
operator|!
name|dynobj
condition|)
name|ia64_info
operator|->
name|root
operator|.
name|dynobj
operator|=
name|dynobj
operator|=
name|abfd
expr_stmt|;
name|srel
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|srel_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|srel
operator|==
name|NULL
operator|&&
name|create
condition|)
block|{
name|srel
operator|=
name|bfd_make_section
argument_list|(
name|dynobj
argument_list|,
name|srel_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|srel
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|dynobj
argument_list|,
name|srel
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_READONLY
operator|)
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|srel
argument_list|,
literal|3
argument_list|)
condition|)
return|return
name|NULL
return|;
block|}
return|return
name|srel
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|count_dyn_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|elfNN_ia64_dyn_sym_info
modifier|*
name|dyn_i
parameter_list|,
name|asection
modifier|*
name|srel
parameter_list|,
name|int
name|type
parameter_list|,
name|bfd_boolean
name|reltext
parameter_list|)
block|{
name|struct
name|elfNN_ia64_dyn_reloc_entry
modifier|*
name|rent
decl_stmt|;
for|for
control|(
name|rent
operator|=
name|dyn_i
operator|->
name|reloc_entries
init|;
name|rent
condition|;
name|rent
operator|=
name|rent
operator|->
name|next
control|)
if|if
condition|(
name|rent
operator|->
name|srel
operator|==
name|srel
operator|&&
name|rent
operator|->
name|type
operator|==
name|type
condition|)
break|break;
if|if
condition|(
operator|!
name|rent
condition|)
block|{
name|rent
operator|=
operator|(
operator|(
expr|struct
name|elfNN_ia64_dyn_reloc_entry
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_size_type
operator|)
sizeof|sizeof
argument_list|(
operator|*
name|rent
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|rent
condition|)
return|return
name|FALSE
return|;
name|rent
operator|->
name|next
operator|=
name|dyn_i
operator|->
name|reloc_entries
expr_stmt|;
name|rent
operator|->
name|srel
operator|=
name|srel
expr_stmt|;
name|rent
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|rent
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|dyn_i
operator|->
name|reloc_entries
operator|=
name|rent
expr_stmt|;
block|}
name|rent
operator|->
name|reltext
operator|=
name|reltext
expr_stmt|;
name|rent
operator|->
name|count
operator|++
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elfNN_ia64_check_relocs
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|sec
parameter_list|,
name|relocs
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|;
block|{
name|struct
name|elfNN_ia64_link_hash_table
modifier|*
name|ia64_info
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relend
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|asection
modifier|*
name|got
decl_stmt|,
modifier|*
name|fptr
decl_stmt|,
modifier|*
name|srel
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
return|return
name|TRUE
return|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|ia64_info
operator|=
name|elfNN_ia64_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|got
operator|=
name|fptr
operator|=
name|srel
operator|=
name|NULL
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|relend
condition|;
operator|++
name|rel
control|)
block|{
enum|enum
block|{
name|NEED_GOT
init|=
literal|1
block|,
name|NEED_GOTX
init|=
literal|2
block|,
name|NEED_FPTR
init|=
literal|4
block|,
name|NEED_PLTOFF
init|=
literal|8
block|,
name|NEED_MIN_PLT
init|=
literal|16
block|,
name|NEED_FULL_PLT
init|=
literal|32
block|,
name|NEED_DYNREL
init|=
literal|64
block|,
name|NEED_LTOFF_FPTR
init|=
literal|128
block|,
name|NEED_TPREL
init|=
literal|256
block|,
name|NEED_DTPMOD
init|=
literal|512
block|,
name|NEED_DTPREL
init|=
literal|1024
block|}
enum|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
init|=
name|NULL
decl_stmt|;
name|unsigned
name|long
name|r_symndx
init|=
name|ELFNN_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
decl_stmt|;
name|struct
name|elfNN_ia64_dyn_sym_info
modifier|*
name|dyn_i
decl_stmt|;
name|int
name|need_entry
decl_stmt|;
name|bfd_boolean
name|maybe_dynamic
decl_stmt|;
name|int
name|dynrel_type
init|=
name|R_IA64_NONE
decl_stmt|;
if|if
condition|(
name|r_symndx
operator|>=
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
comment|/* We're dealing with a global symbol -- find its hash entry 	     and mark it as being referenced.  */
name|long
name|indx
init|=
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
decl_stmt|;
name|h
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
index|[
name|indx
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_REF_REGULAR
expr_stmt|;
block|}
comment|/* We can only get preliminary data on whether a symbol is 	 locally or externally defined, as not all of the input files 	 have yet been processed.  Do something with what we know, as 	 this may help reduce memory usage and processing time later.  */
name|maybe_dynamic
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|h
operator|&&
operator|(
operator|(
operator|!
name|info
operator|->
name|executable
operator|&&
operator|(
operator|!
name|info
operator|->
name|symbolic
operator|||
name|info
operator|->
name|unresolved_syms_in_shared_libs
operator|==
name|RM_IGNORE
operator|)
operator|)
operator|||
operator|!
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
condition|)
name|maybe_dynamic
operator|=
name|TRUE
expr_stmt|;
name|need_entry
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|ELFNN_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_IA64_TPREL64MSB
case|:
case|case
name|R_IA64_TPREL64LSB
case|:
if|if
condition|(
name|info
operator|->
name|shared
operator|||
name|maybe_dynamic
condition|)
name|need_entry
operator|=
name|NEED_DYNREL
expr_stmt|;
name|dynrel_type
operator|=
name|R_IA64_TPREL64LSB
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
name|info
operator|->
name|flags
operator||=
name|DF_STATIC_TLS
expr_stmt|;
break|break;
case|case
name|R_IA64_LTOFF_TPREL22
case|:
name|need_entry
operator|=
name|NEED_TPREL
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
name|info
operator|->
name|flags
operator||=
name|DF_STATIC_TLS
expr_stmt|;
break|break;
case|case
name|R_IA64_DTPREL64MSB
case|:
case|case
name|R_IA64_DTPREL64LSB
case|:
if|if
condition|(
name|info
operator|->
name|shared
operator|||
name|maybe_dynamic
condition|)
name|need_entry
operator|=
name|NEED_DYNREL
expr_stmt|;
name|dynrel_type
operator|=
name|R_IA64_DTPREL64LSB
expr_stmt|;
break|break;
case|case
name|R_IA64_LTOFF_DTPREL22
case|:
name|need_entry
operator|=
name|NEED_DTPREL
expr_stmt|;
break|break;
case|case
name|R_IA64_DTPMOD64MSB
case|:
case|case
name|R_IA64_DTPMOD64LSB
case|:
if|if
condition|(
name|info
operator|->
name|shared
operator|||
name|maybe_dynamic
condition|)
name|need_entry
operator|=
name|NEED_DYNREL
expr_stmt|;
name|dynrel_type
operator|=
name|R_IA64_DTPMOD64LSB
expr_stmt|;
break|break;
case|case
name|R_IA64_LTOFF_DTPMOD22
case|:
name|need_entry
operator|=
name|NEED_DTPMOD
expr_stmt|;
break|break;
case|case
name|R_IA64_LTOFF_FPTR22
case|:
case|case
name|R_IA64_LTOFF_FPTR64I
case|:
case|case
name|R_IA64_LTOFF_FPTR32MSB
case|:
case|case
name|R_IA64_LTOFF_FPTR32LSB
case|:
case|case
name|R_IA64_LTOFF_FPTR64MSB
case|:
case|case
name|R_IA64_LTOFF_FPTR64LSB
case|:
name|need_entry
operator|=
name|NEED_FPTR
operator||
name|NEED_GOT
operator||
name|NEED_LTOFF_FPTR
expr_stmt|;
break|break;
case|case
name|R_IA64_FPTR64I
case|:
case|case
name|R_IA64_FPTR32MSB
case|:
case|case
name|R_IA64_FPTR32LSB
case|:
case|case
name|R_IA64_FPTR64MSB
case|:
case|case
name|R_IA64_FPTR64LSB
case|:
if|if
condition|(
name|info
operator|->
name|shared
operator|||
name|h
condition|)
name|need_entry
operator|=
name|NEED_FPTR
operator||
name|NEED_DYNREL
expr_stmt|;
else|else
name|need_entry
operator|=
name|NEED_FPTR
expr_stmt|;
name|dynrel_type
operator|=
name|R_IA64_FPTR64LSB
expr_stmt|;
break|break;
case|case
name|R_IA64_LTOFF22
case|:
case|case
name|R_IA64_LTOFF64I
case|:
name|need_entry
operator|=
name|NEED_GOT
expr_stmt|;
break|break;
case|case
name|R_IA64_LTOFF22X
case|:
name|need_entry
operator|=
name|NEED_GOTX
expr_stmt|;
break|break;
case|case
name|R_IA64_PLTOFF22
case|:
case|case
name|R_IA64_PLTOFF64I
case|:
case|case
name|R_IA64_PLTOFF64MSB
case|:
case|case
name|R_IA64_PLTOFF64LSB
case|:
name|need_entry
operator|=
name|NEED_PLTOFF
expr_stmt|;
if|if
condition|(
name|h
condition|)
block|{
if|if
condition|(
name|maybe_dynamic
condition|)
name|need_entry
operator||=
name|NEED_MIN_PLT
expr_stmt|;
block|}
else|else
block|{
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|warning
call|)
argument_list|(
name|info
argument_list|,
name|_
argument_list|(
literal|"@pltoff reloc against local symbol"
argument_list|)
argument_list|,
literal|0
argument_list|,
name|abfd
argument_list|,
literal|0
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|R_IA64_PCREL21B
case|:
case|case
name|R_IA64_PCREL60B
case|:
comment|/* Depending on where this symbol is defined, we may or may not 	     need a full plt entry.  Only skip if we know we'll not need 	     the entry -- static or symbolic, and the symbol definition 	     has already been seen.  */
if|if
condition|(
name|maybe_dynamic
operator|&&
name|rel
operator|->
name|r_addend
operator|==
literal|0
condition|)
name|need_entry
operator|=
name|NEED_FULL_PLT
expr_stmt|;
break|break;
case|case
name|R_IA64_IMM14
case|:
case|case
name|R_IA64_IMM22
case|:
case|case
name|R_IA64_IMM64
case|:
case|case
name|R_IA64_DIR32MSB
case|:
case|case
name|R_IA64_DIR32LSB
case|:
case|case
name|R_IA64_DIR64MSB
case|:
case|case
name|R_IA64_DIR64LSB
case|:
comment|/* Shared objects will always need at least a REL relocation.  */
if|if
condition|(
name|info
operator|->
name|shared
operator|||
name|maybe_dynamic
condition|)
name|need_entry
operator|=
name|NEED_DYNREL
expr_stmt|;
name|dynrel_type
operator|=
name|R_IA64_DIR64LSB
expr_stmt|;
break|break;
case|case
name|R_IA64_IPLTMSB
case|:
case|case
name|R_IA64_IPLTLSB
case|:
comment|/* Shared objects will always need at least a REL relocation.  */
if|if
condition|(
name|info
operator|->
name|shared
operator|||
name|maybe_dynamic
condition|)
name|need_entry
operator|=
name|NEED_DYNREL
expr_stmt|;
name|dynrel_type
operator|=
name|R_IA64_IPLTLSB
expr_stmt|;
break|break;
case|case
name|R_IA64_PCREL22
case|:
case|case
name|R_IA64_PCREL64I
case|:
case|case
name|R_IA64_PCREL32MSB
case|:
case|case
name|R_IA64_PCREL32LSB
case|:
case|case
name|R_IA64_PCREL64MSB
case|:
case|case
name|R_IA64_PCREL64LSB
case|:
if|if
condition|(
name|maybe_dynamic
condition|)
name|need_entry
operator|=
name|NEED_DYNREL
expr_stmt|;
name|dynrel_type
operator|=
name|R_IA64_PCREL64LSB
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|need_entry
condition|)
continue|continue;
if|if
condition|(
operator|(
name|need_entry
operator|&
name|NEED_FPTR
operator|)
operator|!=
literal|0
operator|&&
name|rel
operator|->
name|r_addend
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|warning
call|)
argument_list|(
name|info
argument_list|,
name|_
argument_list|(
literal|"non-zero addend in @fptr reloc"
argument_list|)
argument_list|,
literal|0
argument_list|,
name|abfd
argument_list|,
literal|0
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
name|dyn_i
operator|=
name|get_dyn_sym_info
argument_list|(
name|ia64_info
argument_list|,
name|h
argument_list|,
name|abfd
argument_list|,
name|rel
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* Record whether or not this is a local symbol.  */
name|dyn_i
operator|->
name|h
operator|=
name|h
expr_stmt|;
comment|/* Create what's needed.  */
if|if
condition|(
name|need_entry
operator|&
operator|(
name|NEED_GOT
operator||
name|NEED_GOTX
operator||
name|NEED_TPREL
operator||
name|NEED_DTPMOD
operator||
name|NEED_DTPREL
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|got
condition|)
block|{
name|got
operator|=
name|get_got
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|ia64_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|got
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|need_entry
operator|&
name|NEED_GOT
condition|)
name|dyn_i
operator|->
name|want_got
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|need_entry
operator|&
name|NEED_GOTX
condition|)
name|dyn_i
operator|->
name|want_gotx
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|need_entry
operator|&
name|NEED_TPREL
condition|)
name|dyn_i
operator|->
name|want_tprel
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|need_entry
operator|&
name|NEED_DTPMOD
condition|)
name|dyn_i
operator|->
name|want_dtpmod
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|need_entry
operator|&
name|NEED_DTPREL
condition|)
name|dyn_i
operator|->
name|want_dtprel
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|need_entry
operator|&
name|NEED_FPTR
condition|)
block|{
if|if
condition|(
operator|!
name|fptr
condition|)
block|{
name|fptr
operator|=
name|get_fptr
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|ia64_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fptr
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* FPTRs for shared libraries are allocated by the dynamic 	     linker.  Make sure this local symbol will appear in the 	     dynamic symbol table.  */
if|if
condition|(
operator|!
name|h
operator|&&
name|info
operator|->
name|shared
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|bfd_elf_link_record_local_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
operator|(
name|long
operator|)
name|r_symndx
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
block|}
name|dyn_i
operator|->
name|want_fptr
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|need_entry
operator|&
name|NEED_LTOFF_FPTR
condition|)
name|dyn_i
operator|->
name|want_ltoff_fptr
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|need_entry
operator|&
operator|(
name|NEED_MIN_PLT
operator||
name|NEED_FULL_PLT
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|ia64_info
operator|->
name|root
operator|.
name|dynobj
condition|)
name|ia64_info
operator|->
name|root
operator|.
name|dynobj
operator|=
name|abfd
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_NEEDS_PLT
expr_stmt|;
name|dyn_i
operator|->
name|want_plt
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|need_entry
operator|&
name|NEED_FULL_PLT
condition|)
name|dyn_i
operator|->
name|want_plt2
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|need_entry
operator|&
name|NEED_PLTOFF
condition|)
name|dyn_i
operator|->
name|want_pltoff
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|need_entry
operator|&
name|NEED_DYNREL
operator|)
operator|&&
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|srel
condition|)
block|{
name|srel
operator|=
name|get_reloc_section
argument_list|(
name|abfd
argument_list|,
name|ia64_info
argument_list|,
name|sec
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|srel
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|count_dyn_reloc
argument_list|(
name|abfd
argument_list|,
name|dyn_i
argument_list|,
name|srel
argument_list|,
name|dynrel_type
argument_list|,
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|!=
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* For cleanliness, and potentially faster dynamic loading, allocate    external GOT entries first.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|allocate_global_data_got
parameter_list|(
name|dyn_i
parameter_list|,
name|data
parameter_list|)
name|struct
name|elfNN_ia64_dyn_sym_info
modifier|*
name|dyn_i
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
name|struct
name|elfNN_ia64_allocate_data
modifier|*
name|x
init|=
operator|(
expr|struct
name|elfNN_ia64_allocate_data
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
operator|(
name|dyn_i
operator|->
name|want_got
operator|||
name|dyn_i
operator|->
name|want_gotx
operator|)
operator|&&
operator|!
name|dyn_i
operator|->
name|want_fptr
operator|&&
name|elfNN_ia64_dynamic_symbol_p
argument_list|(
name|dyn_i
operator|->
name|h
argument_list|,
name|x
operator|->
name|info
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|dyn_i
operator|->
name|got_offset
operator|=
name|x
operator|->
name|ofs
expr_stmt|;
name|x
operator|->
name|ofs
operator|+=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|dyn_i
operator|->
name|want_tprel
condition|)
block|{
name|dyn_i
operator|->
name|tprel_offset
operator|=
name|x
operator|->
name|ofs
expr_stmt|;
name|x
operator|->
name|ofs
operator|+=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|dyn_i
operator|->
name|want_dtpmod
condition|)
block|{
if|if
condition|(
name|elfNN_ia64_dynamic_symbol_p
argument_list|(
name|dyn_i
operator|->
name|h
argument_list|,
name|x
operator|->
name|info
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|dyn_i
operator|->
name|dtpmod_offset
operator|=
name|x
operator|->
name|ofs
expr_stmt|;
name|x
operator|->
name|ofs
operator|+=
literal|8
expr_stmt|;
block|}
else|else
block|{
name|struct
name|elfNN_ia64_link_hash_table
modifier|*
name|ia64_info
decl_stmt|;
name|ia64_info
operator|=
name|elfNN_ia64_hash_table
argument_list|(
name|x
operator|->
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|ia64_info
operator|->
name|self_dtpmod_offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
name|ia64_info
operator|->
name|self_dtpmod_offset
operator|=
name|x
operator|->
name|ofs
expr_stmt|;
name|x
operator|->
name|ofs
operator|+=
literal|8
expr_stmt|;
block|}
name|dyn_i
operator|->
name|dtpmod_offset
operator|=
name|ia64_info
operator|->
name|self_dtpmod_offset
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dyn_i
operator|->
name|want_dtprel
condition|)
block|{
name|dyn_i
operator|->
name|dtprel_offset
operator|=
name|x
operator|->
name|ofs
expr_stmt|;
name|x
operator|->
name|ofs
operator|+=
literal|8
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Next, allocate all the GOT entries used by LTOFF_FPTR relocs.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|allocate_global_fptr_got
parameter_list|(
name|dyn_i
parameter_list|,
name|data
parameter_list|)
name|struct
name|elfNN_ia64_dyn_sym_info
modifier|*
name|dyn_i
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
name|struct
name|elfNN_ia64_allocate_data
modifier|*
name|x
init|=
operator|(
expr|struct
name|elfNN_ia64_allocate_data
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|dyn_i
operator|->
name|want_got
operator|&&
name|dyn_i
operator|->
name|want_fptr
operator|&&
name|elfNN_ia64_dynamic_symbol_p
argument_list|(
name|dyn_i
operator|->
name|h
argument_list|,
name|x
operator|->
name|info
argument_list|,
name|R_IA64_FPTR64LSB
argument_list|)
condition|)
block|{
name|dyn_i
operator|->
name|got_offset
operator|=
name|x
operator|->
name|ofs
expr_stmt|;
name|x
operator|->
name|ofs
operator|+=
literal|8
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Lastly, allocate all the GOT entries for local data.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|allocate_local_got
parameter_list|(
name|dyn_i
parameter_list|,
name|data
parameter_list|)
name|struct
name|elfNN_ia64_dyn_sym_info
modifier|*
name|dyn_i
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
name|struct
name|elfNN_ia64_allocate_data
modifier|*
name|x
init|=
operator|(
expr|struct
name|elfNN_ia64_allocate_data
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
operator|(
name|dyn_i
operator|->
name|want_got
operator|||
name|dyn_i
operator|->
name|want_gotx
operator|)
operator|&&
operator|!
name|elfNN_ia64_dynamic_symbol_p
argument_list|(
name|dyn_i
operator|->
name|h
argument_list|,
name|x
operator|->
name|info
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|dyn_i
operator|->
name|got_offset
operator|=
name|x
operator|->
name|ofs
expr_stmt|;
name|x
operator|->
name|ofs
operator|+=
literal|8
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Search for the index of a global symbol in it's defining object file.  */
end_comment

begin_function
specifier|static
name|long
name|global_sym_index
parameter_list|(
name|h
parameter_list|)
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
block|{
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|p
decl_stmt|;
name|bfd
modifier|*
name|obj
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
argument_list|)
expr_stmt|;
name|obj
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
expr_stmt|;
for|for
control|(
name|p
operator|=
name|elf_sym_hashes
argument_list|(
name|obj
argument_list|)
init|;
operator|*
name|p
operator|!=
name|h
condition|;
operator|++
name|p
control|)
continue|continue;
return|return
name|p
operator|-
name|elf_sym_hashes
argument_list|(
name|obj
argument_list|)
operator|+
name|elf_tdata
argument_list|(
name|obj
argument_list|)
operator|->
name|symtab_hdr
operator|.
name|sh_info
return|;
block|}
end_function

begin_comment
comment|/* Allocate function descriptors.  We can do these for every function    in a main executable that is not exported.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|allocate_fptr
parameter_list|(
name|dyn_i
parameter_list|,
name|data
parameter_list|)
name|struct
name|elfNN_ia64_dyn_sym_info
modifier|*
name|dyn_i
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
name|struct
name|elfNN_ia64_allocate_data
modifier|*
name|x
init|=
operator|(
expr|struct
name|elfNN_ia64_allocate_data
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|dyn_i
operator|->
name|want_fptr
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
init|=
name|dyn_i
operator|->
name|h
decl_stmt|;
if|if
condition|(
name|h
condition|)
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
operator|!
name|x
operator|->
name|info
operator|->
name|executable
operator|&&
operator|(
operator|!
name|h
operator|||
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_DEFAULT
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefweak
operator|)
condition|)
block|{
if|if
condition|(
name|h
operator|&&
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
block|{
name|BFD_ASSERT
argument_list|(
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|)
operator|||
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_elf_link_record_local_dynamic_symbol
argument_list|(
name|x
operator|->
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
argument_list|,
name|global_sym_index
argument_list|(
name|h
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
name|dyn_i
operator|->
name|want_fptr
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
block|{
name|dyn_i
operator|->
name|fptr_offset
operator|=
name|x
operator|->
name|ofs
expr_stmt|;
name|x
operator|->
name|ofs
operator|+=
literal|16
expr_stmt|;
block|}
else|else
name|dyn_i
operator|->
name|want_fptr
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Allocate all the minimal PLT entries.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|allocate_plt_entries
parameter_list|(
name|dyn_i
parameter_list|,
name|data
parameter_list|)
name|struct
name|elfNN_ia64_dyn_sym_info
modifier|*
name|dyn_i
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
name|struct
name|elfNN_ia64_allocate_data
modifier|*
name|x
init|=
operator|(
expr|struct
name|elfNN_ia64_allocate_data
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|dyn_i
operator|->
name|want_plt
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
init|=
name|dyn_i
operator|->
name|h
decl_stmt|;
if|if
condition|(
name|h
condition|)
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
comment|/* ??? Versioned symbols seem to lose ELF_LINK_HASH_NEEDS_PLT.  */
if|if
condition|(
name|elfNN_ia64_dynamic_symbol_p
argument_list|(
name|h
argument_list|,
name|x
operator|->
name|info
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|bfd_size_type
name|offset
init|=
name|x
operator|->
name|ofs
decl_stmt|;
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
name|offset
operator|=
name|PLT_HEADER_SIZE
expr_stmt|;
name|dyn_i
operator|->
name|plt_offset
operator|=
name|offset
expr_stmt|;
name|x
operator|->
name|ofs
operator|=
name|offset
operator|+
name|PLT_MIN_ENTRY_SIZE
expr_stmt|;
name|dyn_i
operator|->
name|want_pltoff
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|dyn_i
operator|->
name|want_plt
operator|=
literal|0
expr_stmt|;
name|dyn_i
operator|->
name|want_plt2
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Allocate all the full PLT entries.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|allocate_plt2_entries
parameter_list|(
name|dyn_i
parameter_list|,
name|data
parameter_list|)
name|struct
name|elfNN_ia64_dyn_sym_info
modifier|*
name|dyn_i
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
name|struct
name|elfNN_ia64_allocate_data
modifier|*
name|x
init|=
operator|(
expr|struct
name|elfNN_ia64_allocate_data
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|dyn_i
operator|->
name|want_plt2
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
init|=
name|dyn_i
operator|->
name|h
decl_stmt|;
name|bfd_size_type
name|ofs
init|=
name|x
operator|->
name|ofs
decl_stmt|;
name|dyn_i
operator|->
name|plt2_offset
operator|=
name|ofs
expr_stmt|;
name|x
operator|->
name|ofs
operator|=
name|ofs
operator|+
name|PLT_FULL_ENTRY_SIZE
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|dyn_i
operator|->
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
name|ofs
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Allocate all the PLTOFF entries requested by relocations and    plt entries.  We can't share space with allocated FPTR entries,    because the latter are not necessarily addressable by the GP.    ??? Relaxation might be able to determine that they are.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|allocate_pltoff_entries
parameter_list|(
name|dyn_i
parameter_list|,
name|data
parameter_list|)
name|struct
name|elfNN_ia64_dyn_sym_info
modifier|*
name|dyn_i
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
name|struct
name|elfNN_ia64_allocate_data
modifier|*
name|x
init|=
operator|(
expr|struct
name|elfNN_ia64_allocate_data
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|dyn_i
operator|->
name|want_pltoff
condition|)
block|{
name|dyn_i
operator|->
name|pltoff_offset
operator|=
name|x
operator|->
name|ofs
expr_stmt|;
name|x
operator|->
name|ofs
operator|+=
literal|16
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Allocate dynamic relocations for those symbols that turned out    to be dynamic.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|allocate_dynrel_entries
parameter_list|(
name|dyn_i
parameter_list|,
name|data
parameter_list|)
name|struct
name|elfNN_ia64_dyn_sym_info
modifier|*
name|dyn_i
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
name|struct
name|elfNN_ia64_allocate_data
modifier|*
name|x
init|=
operator|(
expr|struct
name|elfNN_ia64_allocate_data
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|elfNN_ia64_link_hash_table
modifier|*
name|ia64_info
decl_stmt|;
name|struct
name|elfNN_ia64_dyn_reloc_entry
modifier|*
name|rent
decl_stmt|;
name|bfd_boolean
name|dynamic_symbol
decl_stmt|,
name|shared
decl_stmt|,
name|resolved_zero
decl_stmt|;
name|ia64_info
operator|=
name|elfNN_ia64_hash_table
argument_list|(
name|x
operator|->
name|info
argument_list|)
expr_stmt|;
comment|/* Note that this can't be used in relation to FPTR relocs below.  */
name|dynamic_symbol
operator|=
name|elfNN_ia64_dynamic_symbol_p
argument_list|(
name|dyn_i
operator|->
name|h
argument_list|,
name|x
operator|->
name|info
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|shared
operator|=
name|x
operator|->
name|info
operator|->
name|shared
expr_stmt|;
name|resolved_zero
operator|=
operator|(
name|dyn_i
operator|->
name|h
operator|&&
name|ELF_ST_VISIBILITY
argument_list|(
name|dyn_i
operator|->
name|h
operator|->
name|other
argument_list|)
operator|&&
name|dyn_i
operator|->
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|)
expr_stmt|;
comment|/* Take care of the normal data relocations.  */
for|for
control|(
name|rent
operator|=
name|dyn_i
operator|->
name|reloc_entries
init|;
name|rent
condition|;
name|rent
operator|=
name|rent
operator|->
name|next
control|)
block|{
name|int
name|count
init|=
name|rent
operator|->
name|count
decl_stmt|;
switch|switch
condition|(
name|rent
operator|->
name|type
condition|)
block|{
case|case
name|R_IA64_FPTR64LSB
case|:
comment|/* Allocate one iff !want_fptr and not PIE, which by this point 	     will be true only if we're actually allocating one statically 	     in the main executable.  Position independent executables 	     need a relative reloc.  */
if|if
condition|(
name|dyn_i
operator|->
name|want_fptr
operator|&&
operator|!
name|x
operator|->
name|info
operator|->
name|pie
condition|)
continue|continue;
break|break;
case|case
name|R_IA64_PCREL64LSB
case|:
if|if
condition|(
operator|!
name|dynamic_symbol
condition|)
continue|continue;
break|break;
case|case
name|R_IA64_DIR64LSB
case|:
if|if
condition|(
operator|!
name|dynamic_symbol
operator|&&
operator|!
name|shared
condition|)
continue|continue;
break|break;
case|case
name|R_IA64_IPLTLSB
case|:
if|if
condition|(
operator|!
name|dynamic_symbol
operator|&&
operator|!
name|shared
condition|)
continue|continue;
comment|/* Use two REL relocations for IPLT relocations 	     against local symbols.  */
if|if
condition|(
operator|!
name|dynamic_symbol
condition|)
name|count
operator|*=
literal|2
expr_stmt|;
break|break;
case|case
name|R_IA64_TPREL64LSB
case|:
case|case
name|R_IA64_DTPREL64LSB
case|:
case|case
name|R_IA64_DTPMOD64LSB
case|:
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|rent
operator|->
name|reltext
condition|)
name|ia64_info
operator|->
name|reltext
operator|=
literal|1
expr_stmt|;
name|rent
operator|->
name|srel
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|ElfNN_External_Rela
argument_list|)
operator|*
name|count
expr_stmt|;
block|}
comment|/* Take care of the GOT and PLT relocations.  */
if|if
condition|(
operator|(
operator|!
name|resolved_zero
operator|&&
operator|(
name|dynamic_symbol
operator|||
name|shared
operator|)
operator|&&
operator|(
name|dyn_i
operator|->
name|want_got
operator|||
name|dyn_i
operator|->
name|want_gotx
operator|)
operator|)
operator|||
operator|(
name|dyn_i
operator|->
name|want_ltoff_fptr
operator|&&
name|dyn_i
operator|->
name|h
operator|&&
name|dyn_i
operator|->
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|dyn_i
operator|->
name|want_ltoff_fptr
operator|||
operator|!
name|x
operator|->
name|info
operator|->
name|pie
operator|||
name|dyn_i
operator|->
name|h
operator|==
name|NULL
operator|||
name|dyn_i
operator|->
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefweak
condition|)
name|ia64_info
operator|->
name|rel_got_sec
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|ElfNN_External_Rela
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|dynamic_symbol
operator|||
name|shared
operator|)
operator|&&
name|dyn_i
operator|->
name|want_tprel
condition|)
name|ia64_info
operator|->
name|rel_got_sec
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|ElfNN_External_Rela
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynamic_symbol
operator|&&
name|dyn_i
operator|->
name|want_dtpmod
condition|)
name|ia64_info
operator|->
name|rel_got_sec
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|ElfNN_External_Rela
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynamic_symbol
operator|&&
name|dyn_i
operator|->
name|want_dtprel
condition|)
name|ia64_info
operator|->
name|rel_got_sec
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|ElfNN_External_Rela
argument_list|)
expr_stmt|;
if|if
condition|(
name|ia64_info
operator|->
name|rel_fptr_sec
operator|&&
name|dyn_i
operator|->
name|want_fptr
condition|)
block|{
if|if
condition|(
name|dyn_i
operator|->
name|h
operator|==
name|NULL
operator|||
name|dyn_i
operator|->
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefweak
condition|)
name|ia64_info
operator|->
name|rel_fptr_sec
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|ElfNN_External_Rela
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|resolved_zero
operator|&&
name|dyn_i
operator|->
name|want_pltoff
condition|)
block|{
name|bfd_size_type
name|t
init|=
literal|0
decl_stmt|;
comment|/* Dynamic symbols get one IPLT relocation.  Local symbols in 	 shared libraries get two REL relocations.  Local symbols in 	 main applications get nothing.  */
if|if
condition|(
name|dynamic_symbol
condition|)
name|t
operator|=
sizeof|sizeof
argument_list|(
name|ElfNN_External_Rela
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|shared
condition|)
name|t
operator|=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|ElfNN_External_Rela
argument_list|)
expr_stmt|;
name|ia64_info
operator|->
name|rel_pltoff_sec
operator|->
name|_raw_size
operator|+=
name|t
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elfNN_ia64_adjust_dynamic_symbol
parameter_list|(
name|info
parameter_list|,
name|h
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
block|{
comment|/* ??? Undefined symbols with PLT entries should be re-defined      to be the PLT entry.  */
comment|/* If this is a weak symbol, and there is a real definition, the      processor independent code will have arranged for us to see the      real definition first, and we can just use the same value.  */
if|if
condition|(
name|h
operator|->
name|weakdef
operator|!=
name|NULL
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
argument_list|)
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* If this is a reference to a symbol defined by a dynamic object which      is not a function, we might allocate the symbol in our .dynbss section      and allocate a COPY dynamic relocation.       But IA-64 code is canonically PIC, so as a rule we can avoid this sort      of hackery.  */
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elfNN_ia64_size_dynamic_sections
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|struct
name|elfNN_ia64_allocate_data
name|data
decl_stmt|;
name|struct
name|elfNN_ia64_link_hash_table
modifier|*
name|ia64_info
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|bfd_boolean
name|relplt
init|=
name|FALSE
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|ia64_info
operator|=
name|elfNN_ia64_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|ia64_info
operator|->
name|self_dtpmod_offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|dynobj
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|data
operator|.
name|info
operator|=
name|info
expr_stmt|;
comment|/* Set the contents of the .interp section to the interpreter.  */
if|if
condition|(
name|ia64_info
operator|->
name|root
operator|.
name|dynamic_sections_created
operator|&&
name|info
operator|->
name|executable
condition|)
block|{
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".interp"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sec
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|sec
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|ELF_DYNAMIC_INTERPRETER
expr_stmt|;
name|sec
operator|->
name|_raw_size
operator|=
name|strlen
argument_list|(
name|ELF_DYNAMIC_INTERPRETER
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
comment|/* Allocate the GOT entries.  */
if|if
condition|(
name|ia64_info
operator|->
name|got_sec
condition|)
block|{
name|data
operator|.
name|ofs
operator|=
literal|0
expr_stmt|;
name|elfNN_ia64_dyn_sym_traverse
argument_list|(
name|ia64_info
argument_list|,
name|allocate_global_data_got
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
name|elfNN_ia64_dyn_sym_traverse
argument_list|(
name|ia64_info
argument_list|,
name|allocate_global_fptr_got
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
name|elfNN_ia64_dyn_sym_traverse
argument_list|(
name|ia64_info
argument_list|,
name|allocate_local_got
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
name|ia64_info
operator|->
name|got_sec
operator|->
name|_raw_size
operator|=
name|data
operator|.
name|ofs
expr_stmt|;
block|}
comment|/* Allocate the FPTR entries.  */
if|if
condition|(
name|ia64_info
operator|->
name|fptr_sec
condition|)
block|{
name|data
operator|.
name|ofs
operator|=
literal|0
expr_stmt|;
name|elfNN_ia64_dyn_sym_traverse
argument_list|(
name|ia64_info
argument_list|,
name|allocate_fptr
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
name|ia64_info
operator|->
name|fptr_sec
operator|->
name|_raw_size
operator|=
name|data
operator|.
name|ofs
expr_stmt|;
block|}
comment|/* Now that we've seen all of the input files, we can decide which      symbols need plt entries.  Allocate the minimal PLT entries first.      We do this even though dynamic_sections_created may be FALSE, because      this has the side-effect of clearing want_plt and want_plt2.  */
name|data
operator|.
name|ofs
operator|=
literal|0
expr_stmt|;
name|elfNN_ia64_dyn_sym_traverse
argument_list|(
name|ia64_info
argument_list|,
name|allocate_plt_entries
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
name|ia64_info
operator|->
name|minplt_entries
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|data
operator|.
name|ofs
condition|)
block|{
name|ia64_info
operator|->
name|minplt_entries
operator|=
operator|(
name|data
operator|.
name|ofs
operator|-
name|PLT_HEADER_SIZE
operator|)
operator|/
name|PLT_MIN_ENTRY_SIZE
expr_stmt|;
block|}
comment|/* Align the pointer for the plt2 entries.  */
name|data
operator|.
name|ofs
operator|=
operator|(
name|data
operator|.
name|ofs
operator|+
literal|31
operator|)
operator|&
operator|(
name|bfd_vma
operator|)
operator|-
literal|32
expr_stmt|;
name|elfNN_ia64_dyn_sym_traverse
argument_list|(
name|ia64_info
argument_list|,
name|allocate_plt2_entries
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|.
name|ofs
operator|!=
literal|0
operator|||
name|ia64_info
operator|->
name|root
operator|.
name|dynamic_sections_created
condition|)
block|{
comment|/* FIXME: we always reserve the memory for dynamic linker even if 	 there are no PLT entries since dynamic linker may assume the 	 reserved memory always exists.  */
name|BFD_ASSERT
argument_list|(
name|ia64_info
operator|->
name|root
operator|.
name|dynamic_sections_created
argument_list|)
expr_stmt|;
name|ia64_info
operator|->
name|plt_sec
operator|->
name|_raw_size
operator|=
name|data
operator|.
name|ofs
expr_stmt|;
comment|/* If we've got a .plt, we need some extra memory for the dynamic 	 linker.  We stuff these in .got.plt.  */
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got.plt"
argument_list|)
expr_stmt|;
name|sec
operator|->
name|_raw_size
operator|=
literal|8
operator|*
name|PLT_RESERVED_WORDS
expr_stmt|;
block|}
comment|/* Allocate the PLTOFF entries.  */
if|if
condition|(
name|ia64_info
operator|->
name|pltoff_sec
condition|)
block|{
name|data
operator|.
name|ofs
operator|=
literal|0
expr_stmt|;
name|elfNN_ia64_dyn_sym_traverse
argument_list|(
name|ia64_info
argument_list|,
name|allocate_pltoff_entries
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
name|ia64_info
operator|->
name|pltoff_sec
operator|->
name|_raw_size
operator|=
name|data
operator|.
name|ofs
expr_stmt|;
block|}
if|if
condition|(
name|ia64_info
operator|->
name|root
operator|.
name|dynamic_sections_created
condition|)
block|{
comment|/* Allocate space for the dynamic relocations that turned out to be 	 required.  */
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
name|ia64_info
operator|->
name|self_dtpmod_offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
name|ia64_info
operator|->
name|rel_got_sec
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|ElfNN_External_Rela
argument_list|)
expr_stmt|;
name|elfNN_ia64_dyn_sym_traverse
argument_list|(
name|ia64_info
argument_list|,
name|allocate_dynrel_entries
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
block|}
comment|/* We have now determined the sizes of the various dynamic sections.      Allocate memory for them.  */
for|for
control|(
name|sec
operator|=
name|dynobj
operator|->
name|sections
init|;
name|sec
operator|!=
name|NULL
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
block|{
name|bfd_boolean
name|strip
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_LINKER_CREATED
operator|)
condition|)
continue|continue;
comment|/* If we don't need this section, strip it from the output file. 	 There were several sections primarily related to dynamic 	 linking that must be create before the linker maps input 	 sections to output sections.  The linker does that before 	 bfd_elf_size_dynamic_sections is called, and it is that 	 function which decides whether anything needs to go into 	 these sections.  */
name|strip
operator|=
operator|(
name|sec
operator|->
name|_raw_size
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|ia64_info
operator|->
name|got_sec
condition|)
name|strip
operator|=
name|FALSE
expr_stmt|;
elseif|else
if|if
condition|(
name|sec
operator|==
name|ia64_info
operator|->
name|rel_got_sec
condition|)
block|{
if|if
condition|(
name|strip
condition|)
name|ia64_info
operator|->
name|rel_got_sec
operator|=
name|NULL
expr_stmt|;
else|else
comment|/* We use the reloc_count field as a counter if we need to 	       copy relocs into the output file.  */
name|sec
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sec
operator|==
name|ia64_info
operator|->
name|fptr_sec
condition|)
block|{
if|if
condition|(
name|strip
condition|)
name|ia64_info
operator|->
name|fptr_sec
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sec
operator|==
name|ia64_info
operator|->
name|rel_fptr_sec
condition|)
block|{
if|if
condition|(
name|strip
condition|)
name|ia64_info
operator|->
name|rel_fptr_sec
operator|=
name|NULL
expr_stmt|;
else|else
comment|/* We use the reloc_count field as a counter if we need to 	       copy relocs into the output file.  */
name|sec
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sec
operator|==
name|ia64_info
operator|->
name|plt_sec
condition|)
block|{
if|if
condition|(
name|strip
condition|)
name|ia64_info
operator|->
name|plt_sec
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sec
operator|==
name|ia64_info
operator|->
name|pltoff_sec
condition|)
block|{
if|if
condition|(
name|strip
condition|)
name|ia64_info
operator|->
name|pltoff_sec
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sec
operator|==
name|ia64_info
operator|->
name|rel_pltoff_sec
condition|)
block|{
if|if
condition|(
name|strip
condition|)
name|ia64_info
operator|->
name|rel_pltoff_sec
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|relplt
operator|=
name|TRUE
expr_stmt|;
comment|/* We use the reloc_count field as a counter if we need to 		 copy relocs into the output file.  */
name|sec
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* It's OK to base decisions on the section name, because none 	     of the dynobj section names depend upon the input files.  */
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|dynobj
argument_list|,
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".got.plt"
argument_list|)
operator|==
literal|0
condition|)
name|strip
operator|=
name|FALSE
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".rel"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|strip
condition|)
block|{
comment|/* We use the reloc_count field as a counter if we need to 		     copy relocs into the output file.  */
name|sec
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
continue|continue;
block|}
if|if
condition|(
name|strip
condition|)
name|_bfd_strip_section_from_output
argument_list|(
name|info
argument_list|,
name|sec
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Allocate memory for the section contents.  */
name|sec
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|dynobj
argument_list|,
name|sec
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|contents
operator|==
name|NULL
operator|&&
name|sec
operator|->
name|_raw_size
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
block|}
block|}
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
comment|/* Add some entries to the .dynamic section.  We fill in the values 	 later (in finish_dynamic_sections) but we must add the entries now 	 so that we get the correct size for the .dynamic section.  */
if|if
condition|(
name|info
operator|->
name|executable
condition|)
block|{
comment|/* The DT_DEBUG entry is filled in by the dynamic linker and used 	     by the debugger.  */
define|#
directive|define
name|add_dynamic_entry
parameter_list|(
name|TAG
parameter_list|,
name|VAL
parameter_list|)
define|\
value|_bfd_elf_add_dynamic_entry (info, TAG, VAL)
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_DEBUG
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_IA_64_PLT_RESERVE
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PLTGOT
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|relplt
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PLTRELSZ
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PLTREL
argument_list|,
name|DT_RELA
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_JMPREL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELA
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELASZ
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELAENT
argument_list|,
sizeof|sizeof
argument_list|(
name|ElfNN_External_Rela
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|ia64_info
operator|->
name|reltext
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_TEXTREL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|info
operator|->
name|flags
operator||=
name|DF_TEXTREL
expr_stmt|;
block|}
block|}
comment|/* ??? Perhaps force __gp local.  */
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_status_type
name|elfNN_ia64_install_value
parameter_list|(
name|abfd
parameter_list|,
name|hit_addr
parameter_list|,
name|v
parameter_list|,
name|r_type
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|bfd_byte
modifier|*
name|hit_addr
decl_stmt|;
name|bfd_vma
name|v
decl_stmt|;
name|unsigned
name|int
name|r_type
decl_stmt|;
block|{
specifier|const
name|struct
name|ia64_operand
modifier|*
name|op
decl_stmt|;
name|int
name|bigendian
init|=
literal|0
decl_stmt|,
name|shift
init|=
literal|0
decl_stmt|;
name|bfd_vma
name|t0
decl_stmt|,
name|t1
decl_stmt|,
name|insn
decl_stmt|,
name|dword
decl_stmt|;
name|enum
name|ia64_opnd
name|opnd
decl_stmt|;
specifier|const
name|char
modifier|*
name|err
decl_stmt|;
name|size_t
name|size
init|=
literal|8
decl_stmt|;
ifdef|#
directive|ifdef
name|BFD_HOST_U_64_BIT
name|BFD_HOST_U_64_BIT
name|val
init|=
operator|(
name|BFD_HOST_U_64_BIT
operator|)
name|v
decl_stmt|;
else|#
directive|else
name|bfd_vma
name|val
init|=
name|v
decl_stmt|;
endif|#
directive|endif
name|opnd
operator|=
name|IA64_OPND_NIL
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_IA64_NONE
case|:
case|case
name|R_IA64_LDXMOV
case|:
return|return
name|bfd_reloc_ok
return|;
comment|/* Instruction relocations.  */
case|case
name|R_IA64_IMM14
case|:
case|case
name|R_IA64_TPREL14
case|:
case|case
name|R_IA64_DTPREL14
case|:
name|opnd
operator|=
name|IA64_OPND_IMM14
expr_stmt|;
break|break;
case|case
name|R_IA64_PCREL21F
case|:
name|opnd
operator|=
name|IA64_OPND_TGT25
expr_stmt|;
break|break;
case|case
name|R_IA64_PCREL21M
case|:
name|opnd
operator|=
name|IA64_OPND_TGT25b
expr_stmt|;
break|break;
case|case
name|R_IA64_PCREL60B
case|:
name|opnd
operator|=
name|IA64_OPND_TGT64
expr_stmt|;
break|break;
case|case
name|R_IA64_PCREL21B
case|:
case|case
name|R_IA64_PCREL21BI
case|:
name|opnd
operator|=
name|IA64_OPND_TGT25c
expr_stmt|;
break|break;
case|case
name|R_IA64_IMM22
case|:
case|case
name|R_IA64_GPREL22
case|:
case|case
name|R_IA64_LTOFF22
case|:
case|case
name|R_IA64_LTOFF22X
case|:
case|case
name|R_IA64_PLTOFF22
case|:
case|case
name|R_IA64_PCREL22
case|:
case|case
name|R_IA64_LTOFF_FPTR22
case|:
case|case
name|R_IA64_TPREL22
case|:
case|case
name|R_IA64_DTPREL22
case|:
case|case
name|R_IA64_LTOFF_TPREL22
case|:
case|case
name|R_IA64_LTOFF_DTPMOD22
case|:
case|case
name|R_IA64_LTOFF_DTPREL22
case|:
name|opnd
operator|=
name|IA64_OPND_IMM22
expr_stmt|;
break|break;
case|case
name|R_IA64_IMM64
case|:
case|case
name|R_IA64_GPREL64I
case|:
case|case
name|R_IA64_LTOFF64I
case|:
case|case
name|R_IA64_PLTOFF64I
case|:
case|case
name|R_IA64_PCREL64I
case|:
case|case
name|R_IA64_FPTR64I
case|:
case|case
name|R_IA64_LTOFF_FPTR64I
case|:
case|case
name|R_IA64_TPREL64I
case|:
case|case
name|R_IA64_DTPREL64I
case|:
name|opnd
operator|=
name|IA64_OPND_IMMU64
expr_stmt|;
break|break;
comment|/* Data relocations.  */
case|case
name|R_IA64_DIR32MSB
case|:
case|case
name|R_IA64_GPREL32MSB
case|:
case|case
name|R_IA64_FPTR32MSB
case|:
case|case
name|R_IA64_PCREL32MSB
case|:
case|case
name|R_IA64_LTOFF_FPTR32MSB
case|:
case|case
name|R_IA64_SEGREL32MSB
case|:
case|case
name|R_IA64_SECREL32MSB
case|:
case|case
name|R_IA64_LTV32MSB
case|:
case|case
name|R_IA64_DTPREL32MSB
case|:
name|size
operator|=
literal|4
expr_stmt|;
name|bigendian
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|R_IA64_DIR32LSB
case|:
case|case
name|R_IA64_GPREL32LSB
case|:
case|case
name|R_IA64_FPTR32LSB
case|:
case|case
name|R_IA64_PCREL32LSB
case|:
case|case
name|R_IA64_LTOFF_FPTR32LSB
case|:
case|case
name|R_IA64_SEGREL32LSB
case|:
case|case
name|R_IA64_SECREL32LSB
case|:
case|case
name|R_IA64_LTV32LSB
case|:
case|case
name|R_IA64_DTPREL32LSB
case|:
name|size
operator|=
literal|4
expr_stmt|;
name|bigendian
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|R_IA64_DIR64MSB
case|:
case|case
name|R_IA64_GPREL64MSB
case|:
case|case
name|R_IA64_PLTOFF64MSB
case|:
case|case
name|R_IA64_FPTR64MSB
case|:
case|case
name|R_IA64_PCREL64MSB
case|:
case|case
name|R_IA64_LTOFF_FPTR64MSB
case|:
case|case
name|R_IA64_SEGREL64MSB
case|:
case|case
name|R_IA64_SECREL64MSB
case|:
case|case
name|R_IA64_LTV64MSB
case|:
case|case
name|R_IA64_TPREL64MSB
case|:
case|case
name|R_IA64_DTPMOD64MSB
case|:
case|case
name|R_IA64_DTPREL64MSB
case|:
name|size
operator|=
literal|8
expr_stmt|;
name|bigendian
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|R_IA64_DIR64LSB
case|:
case|case
name|R_IA64_GPREL64LSB
case|:
case|case
name|R_IA64_PLTOFF64LSB
case|:
case|case
name|R_IA64_FPTR64LSB
case|:
case|case
name|R_IA64_PCREL64LSB
case|:
case|case
name|R_IA64_LTOFF_FPTR64LSB
case|:
case|case
name|R_IA64_SEGREL64LSB
case|:
case|case
name|R_IA64_SECREL64LSB
case|:
case|case
name|R_IA64_LTV64LSB
case|:
case|case
name|R_IA64_TPREL64LSB
case|:
case|case
name|R_IA64_DTPMOD64LSB
case|:
case|case
name|R_IA64_DTPREL64LSB
case|:
name|size
operator|=
literal|8
expr_stmt|;
name|bigendian
operator|=
literal|0
expr_stmt|;
break|break;
comment|/* Unsupported / Dynamic relocations.  */
default|default:
return|return
name|bfd_reloc_notsupported
return|;
block|}
switch|switch
condition|(
name|opnd
condition|)
block|{
case|case
name|IA64_OPND_IMMU64
case|:
name|hit_addr
operator|-=
operator|(
name|long
operator|)
name|hit_addr
operator|&
literal|0x3
expr_stmt|;
name|t0
operator|=
name|bfd_get_64
argument_list|(
name|abfd
argument_list|,
name|hit_addr
argument_list|)
expr_stmt|;
name|t1
operator|=
name|bfd_get_64
argument_list|(
name|abfd
argument_list|,
name|hit_addr
operator|+
literal|8
argument_list|)
expr_stmt|;
comment|/* tmpl/s: bits  0.. 5 in t0 	 slot 0: bits  5..45 in t0 	 slot 1: bits 46..63 in t0, bits 0..22 in t1 	 slot 2: bits 23..63 in t1 */
comment|/* First, clear the bits that form the 64 bit constant.  */
name|t0
operator|&=
operator|~
operator|(
literal|0x3ffffLL
operator|<<
literal|46
operator|)
expr_stmt|;
name|t1
operator|&=
operator|~
operator|(
literal|0x7fffffLL
operator||
operator|(
operator|(
operator|(
literal|0x07fLL
operator|<<
literal|13
operator|)
operator||
operator|(
literal|0x1ffLL
operator|<<
literal|27
operator|)
operator||
operator|(
literal|0x01fLL
operator|<<
literal|22
operator|)
operator||
operator|(
literal|0x001LL
operator|<<
literal|21
operator|)
operator||
operator|(
literal|0x001LL
operator|<<
literal|36
operator|)
operator|)
operator|<<
literal|23
operator|)
operator|)
expr_stmt|;
name|t0
operator||=
operator|(
operator|(
name|val
operator|>>
literal|22
operator|)
operator|&
literal|0x03ffffLL
operator|)
operator|<<
literal|46
expr_stmt|;
comment|/* 18 lsbs of imm41 */
name|t1
operator||=
operator|(
operator|(
name|val
operator|>>
literal|40
operator|)
operator|&
literal|0x7fffffLL
operator|)
operator|<<
literal|0
expr_stmt|;
comment|/* 23 msbs of imm41 */
name|t1
operator||=
operator|(
operator|(
operator|(
operator|(
name|val
operator|>>
literal|0
operator|)
operator|&
literal|0x07f
operator|)
operator|<<
literal|13
operator|)
comment|/* imm7b */
operator||
operator|(
operator|(
operator|(
name|val
operator|>>
literal|7
operator|)
operator|&
literal|0x1ff
operator|)
operator|<<
literal|27
operator|)
comment|/* imm9d */
operator||
operator|(
operator|(
operator|(
name|val
operator|>>
literal|16
operator|)
operator|&
literal|0x01f
operator|)
operator|<<
literal|22
operator|)
comment|/* imm5c */
operator||
operator|(
operator|(
operator|(
name|val
operator|>>
literal|21
operator|)
operator|&
literal|0x001
operator|)
operator|<<
literal|21
operator|)
comment|/* ic */
operator||
operator|(
operator|(
operator|(
name|val
operator|>>
literal|63
operator|)
operator|&
literal|0x001
operator|)
operator|<<
literal|36
operator|)
operator|)
operator|<<
literal|23
expr_stmt|;
comment|/* i */
name|bfd_put_64
argument_list|(
name|abfd
argument_list|,
name|t0
argument_list|,
name|hit_addr
argument_list|)
expr_stmt|;
name|bfd_put_64
argument_list|(
name|abfd
argument_list|,
name|t1
argument_list|,
name|hit_addr
operator|+
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
name|IA64_OPND_TGT64
case|:
name|hit_addr
operator|-=
operator|(
name|long
operator|)
name|hit_addr
operator|&
literal|0x3
expr_stmt|;
name|t0
operator|=
name|bfd_get_64
argument_list|(
name|abfd
argument_list|,
name|hit_addr
argument_list|)
expr_stmt|;
name|t1
operator|=
name|bfd_get_64
argument_list|(
name|abfd
argument_list|,
name|hit_addr
operator|+
literal|8
argument_list|)
expr_stmt|;
comment|/* tmpl/s: bits  0.. 5 in t0 	 slot 0: bits  5..45 in t0 	 slot 1: bits 46..63 in t0, bits 0..22 in t1 	 slot 2: bits 23..63 in t1 */
comment|/* First, clear the bits that form the 64 bit constant.  */
name|t0
operator|&=
operator|~
operator|(
literal|0x3ffffLL
operator|<<
literal|46
operator|)
expr_stmt|;
name|t1
operator|&=
operator|~
operator|(
literal|0x7fffffLL
operator||
operator|(
operator|(
literal|1LL
operator|<<
literal|36
operator||
literal|0xfffffLL
operator|<<
literal|13
operator|)
operator|<<
literal|23
operator|)
operator|)
expr_stmt|;
name|val
operator|>>=
literal|4
expr_stmt|;
name|t0
operator||=
operator|(
operator|(
name|val
operator|>>
literal|20
operator|)
operator|&
literal|0xffffLL
operator|)
operator|<<
literal|2
operator|<<
literal|46
expr_stmt|;
comment|/* 16 lsbs of imm39 */
name|t1
operator||=
operator|(
operator|(
name|val
operator|>>
literal|36
operator|)
operator|&
literal|0x7fffffLL
operator|)
operator|<<
literal|0
expr_stmt|;
comment|/* 23 msbs of imm39 */
name|t1
operator||=
operator|(
operator|(
operator|(
operator|(
name|val
operator|>>
literal|0
operator|)
operator|&
literal|0xfffffLL
operator|)
operator|<<
literal|13
operator|)
comment|/* imm20b */
operator||
operator|(
operator|(
operator|(
name|val
operator|>>
literal|59
operator|)
operator|&
literal|0x1LL
operator|)
operator|<<
literal|36
operator|)
operator|)
operator|<<
literal|23
expr_stmt|;
comment|/* i */
name|bfd_put_64
argument_list|(
name|abfd
argument_list|,
name|t0
argument_list|,
name|hit_addr
argument_list|)
expr_stmt|;
name|bfd_put_64
argument_list|(
name|abfd
argument_list|,
name|t1
argument_list|,
name|hit_addr
operator|+
literal|8
argument_list|)
expr_stmt|;
break|break;
default|default:
switch|switch
condition|(
operator|(
name|long
operator|)
name|hit_addr
operator|&
literal|0x3
condition|)
block|{
case|case
literal|0
case|:
name|shift
operator|=
literal|5
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|shift
operator|=
literal|14
expr_stmt|;
name|hit_addr
operator|+=
literal|3
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|shift
operator|=
literal|23
expr_stmt|;
name|hit_addr
operator|+=
literal|6
expr_stmt|;
break|break;
case|case
literal|3
case|:
return|return
name|bfd_reloc_notsupported
return|;
comment|/* shouldn't happen...  */
block|}
name|dword
operator|=
name|bfd_get_64
argument_list|(
name|abfd
argument_list|,
name|hit_addr
argument_list|)
expr_stmt|;
name|insn
operator|=
operator|(
name|dword
operator|>>
name|shift
operator|)
operator|&
literal|0x1ffffffffffLL
expr_stmt|;
name|op
operator|=
name|elf64_ia64_operands
operator|+
name|opnd
expr_stmt|;
name|err
operator|=
call|(
modifier|*
name|op
operator|->
name|insert
call|)
argument_list|(
name|op
argument_list|,
name|val
argument_list|,
operator|(
name|ia64_insn
operator|*
operator|)
operator|&
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|bfd_reloc_overflow
return|;
name|dword
operator|&=
operator|~
operator|(
literal|0x1ffffffffffLL
operator|<<
name|shift
operator|)
expr_stmt|;
name|dword
operator||=
operator|(
name|insn
operator|<<
name|shift
operator|)
expr_stmt|;
name|bfd_put_64
argument_list|(
name|abfd
argument_list|,
name|dword
argument_list|,
name|hit_addr
argument_list|)
expr_stmt|;
break|break;
case|case
name|IA64_OPND_NIL
case|:
comment|/* A data relocation.  */
if|if
condition|(
name|bigendian
condition|)
if|if
condition|(
name|size
operator|==
literal|4
condition|)
name|bfd_putb32
argument_list|(
name|val
argument_list|,
name|hit_addr
argument_list|)
expr_stmt|;
else|else
name|bfd_putb64
argument_list|(
name|val
argument_list|,
name|hit_addr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|==
literal|4
condition|)
name|bfd_putl32
argument_list|(
name|val
argument_list|,
name|hit_addr
argument_list|)
expr_stmt|;
else|else
name|bfd_putl64
argument_list|(
name|val
argument_list|,
name|hit_addr
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|elfNN_ia64_install_dyn_reloc
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|sec
parameter_list|,
name|srel
parameter_list|,
name|offset
parameter_list|,
name|type
parameter_list|,
name|dynindx
parameter_list|,
name|addend
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|asection
modifier|*
name|srel
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
name|unsigned
name|int
name|type
decl_stmt|;
name|long
name|dynindx
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|;
block|{
name|Elf_Internal_Rela
name|outrel
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|dynindx
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELFNN_R_INFO
argument_list|(
name|dynindx
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
name|addend
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|=
name|_bfd_elf_section_offset
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|sec
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|outrel
operator|.
name|r_offset
operator|>=
operator|(
name|bfd_vma
operator|)
operator|-
literal|2
condition|)
block|{
comment|/* Run for the hills.  We shouldn't be outputting a relocation 	 for this.  So do what everyone else does and output a no-op.  */
name|outrel
operator|.
name|r_info
operator|=
name|ELFNN_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_IA64_NONE
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|outrel
operator|.
name|r_offset
operator|+=
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
expr_stmt|;
name|loc
operator|=
name|srel
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
name|srel
operator|->
name|reloc_count
operator|++
operator|*
sizeof|sizeof
argument_list|(
name|ElfNN_External_Rela
argument_list|)
expr_stmt|;
name|bfd_elfNN_swap_reloca_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|outrel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
sizeof|sizeof
argument_list|(
name|ElfNN_External_Rela
argument_list|)
operator|*
name|srel
operator|->
name|reloc_count
operator|<=
name|srel
operator|->
name|_cooked_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store an entry for target address TARGET_ADDR in the linkage table    and return the gp-relative address of the linkage table entry.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|set_got_entry
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|dyn_i
parameter_list|,
name|dynindx
parameter_list|,
name|addend
parameter_list|,
name|value
parameter_list|,
name|dyn_r_type
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|elfNN_ia64_dyn_sym_info
modifier|*
name|dyn_i
decl_stmt|;
name|long
name|dynindx
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
name|unsigned
name|int
name|dyn_r_type
decl_stmt|;
block|{
name|struct
name|elfNN_ia64_link_hash_table
modifier|*
name|ia64_info
decl_stmt|;
name|asection
modifier|*
name|got_sec
decl_stmt|;
name|bfd_boolean
name|done
decl_stmt|;
name|bfd_vma
name|got_offset
decl_stmt|;
name|ia64_info
operator|=
name|elfNN_ia64_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|got_sec
operator|=
name|ia64_info
operator|->
name|got_sec
expr_stmt|;
switch|switch
condition|(
name|dyn_r_type
condition|)
block|{
case|case
name|R_IA64_TPREL64LSB
case|:
name|done
operator|=
name|dyn_i
operator|->
name|tprel_done
expr_stmt|;
name|dyn_i
operator|->
name|tprel_done
operator|=
name|TRUE
expr_stmt|;
name|got_offset
operator|=
name|dyn_i
operator|->
name|tprel_offset
expr_stmt|;
break|break;
case|case
name|R_IA64_DTPMOD64LSB
case|:
if|if
condition|(
name|dyn_i
operator|->
name|dtpmod_offset
operator|!=
name|ia64_info
operator|->
name|self_dtpmod_offset
condition|)
block|{
name|done
operator|=
name|dyn_i
operator|->
name|dtpmod_done
expr_stmt|;
name|dyn_i
operator|->
name|dtpmod_done
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|done
operator|=
name|ia64_info
operator|->
name|self_dtpmod_done
expr_stmt|;
name|ia64_info
operator|->
name|self_dtpmod_done
operator|=
name|TRUE
expr_stmt|;
name|dynindx
operator|=
literal|0
expr_stmt|;
block|}
name|got_offset
operator|=
name|dyn_i
operator|->
name|dtpmod_offset
expr_stmt|;
break|break;
case|case
name|R_IA64_DTPREL64LSB
case|:
name|done
operator|=
name|dyn_i
operator|->
name|dtprel_done
expr_stmt|;
name|dyn_i
operator|->
name|dtprel_done
operator|=
name|TRUE
expr_stmt|;
name|got_offset
operator|=
name|dyn_i
operator|->
name|dtprel_offset
expr_stmt|;
break|break;
default|default:
name|done
operator|=
name|dyn_i
operator|->
name|got_done
expr_stmt|;
name|dyn_i
operator|->
name|got_done
operator|=
name|TRUE
expr_stmt|;
name|got_offset
operator|=
name|dyn_i
operator|->
name|got_offset
expr_stmt|;
break|break;
block|}
name|BFD_ASSERT
argument_list|(
operator|(
name|got_offset
operator|&
literal|7
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|done
condition|)
block|{
comment|/* Store the target address in the linkage table entry.  */
name|bfd_put_64
argument_list|(
name|abfd
argument_list|,
name|value
argument_list|,
name|got_sec
operator|->
name|contents
operator|+
name|got_offset
argument_list|)
expr_stmt|;
comment|/* Install a dynamic relocation if needed.  */
if|if
condition|(
operator|(
operator|(
name|info
operator|->
name|shared
operator|&&
operator|(
operator|!
name|dyn_i
operator|->
name|h
operator|||
name|ELF_ST_VISIBILITY
argument_list|(
name|dyn_i
operator|->
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_DEFAULT
operator|||
name|dyn_i
operator|->
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefweak
operator|)
operator|&&
name|dyn_r_type
operator|!=
name|R_IA64_DTPREL64LSB
operator|)
operator|||
name|elfNN_ia64_dynamic_symbol_p
argument_list|(
name|dyn_i
operator|->
name|h
argument_list|,
name|info
argument_list|,
name|dyn_r_type
argument_list|)
operator|||
operator|(
name|dynindx
operator|!=
operator|-
literal|1
operator|&&
name|dyn_r_type
operator|==
name|R_IA64_FPTR64LSB
operator|)
operator|)
operator|&&
operator|(
operator|!
name|dyn_i
operator|->
name|want_ltoff_fptr
operator|||
operator|!
name|info
operator|->
name|pie
operator|||
operator|!
name|dyn_i
operator|->
name|h
operator|||
name|dyn_i
operator|->
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefweak
operator|)
condition|)
block|{
if|if
condition|(
name|dynindx
operator|==
operator|-
literal|1
operator|&&
name|dyn_r_type
operator|!=
name|R_IA64_TPREL64LSB
operator|&&
name|dyn_r_type
operator|!=
name|R_IA64_DTPMOD64LSB
operator|&&
name|dyn_r_type
operator|!=
name|R_IA64_DTPREL64LSB
condition|)
block|{
name|dyn_r_type
operator|=
name|R_IA64_REL64LSB
expr_stmt|;
name|dynindx
operator|=
literal|0
expr_stmt|;
name|addend
operator|=
name|value
expr_stmt|;
block|}
if|if
condition|(
name|bfd_big_endian
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|dyn_r_type
condition|)
block|{
case|case
name|R_IA64_REL64LSB
case|:
name|dyn_r_type
operator|=
name|R_IA64_REL64MSB
expr_stmt|;
break|break;
case|case
name|R_IA64_DIR64LSB
case|:
name|dyn_r_type
operator|=
name|R_IA64_DIR64MSB
expr_stmt|;
break|break;
case|case
name|R_IA64_FPTR64LSB
case|:
name|dyn_r_type
operator|=
name|R_IA64_FPTR64MSB
expr_stmt|;
break|break;
case|case
name|R_IA64_TPREL64LSB
case|:
name|dyn_r_type
operator|=
name|R_IA64_TPREL64MSB
expr_stmt|;
break|break;
case|case
name|R_IA64_DTPMOD64LSB
case|:
name|dyn_r_type
operator|=
name|R_IA64_DTPMOD64MSB
expr_stmt|;
break|break;
case|case
name|R_IA64_DTPREL64LSB
case|:
name|dyn_r_type
operator|=
name|R_IA64_DTPREL64MSB
expr_stmt|;
break|break;
default|default:
name|BFD_ASSERT
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|elfNN_ia64_install_dyn_reloc
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|,
name|got_sec
argument_list|,
name|ia64_info
operator|->
name|rel_got_sec
argument_list|,
name|got_offset
argument_list|,
name|dyn_r_type
argument_list|,
name|dynindx
argument_list|,
name|addend
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Return the address of the linkage table entry.  */
name|value
operator|=
operator|(
name|got_sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|got_sec
operator|->
name|output_offset
operator|+
name|got_offset
operator|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* Fill in a function descriptor consisting of the function's code    address and its global pointer.  Return the descriptor's address.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|set_fptr_entry
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|dyn_i
parameter_list|,
name|value
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|elfNN_ia64_dyn_sym_info
modifier|*
name|dyn_i
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
block|{
name|struct
name|elfNN_ia64_link_hash_table
modifier|*
name|ia64_info
decl_stmt|;
name|asection
modifier|*
name|fptr_sec
decl_stmt|;
name|ia64_info
operator|=
name|elfNN_ia64_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|fptr_sec
operator|=
name|ia64_info
operator|->
name|fptr_sec
expr_stmt|;
if|if
condition|(
operator|!
name|dyn_i
operator|->
name|fptr_done
condition|)
block|{
name|dyn_i
operator|->
name|fptr_done
operator|=
literal|1
expr_stmt|;
comment|/* Fill in the function descriptor.  */
name|bfd_put_64
argument_list|(
name|abfd
argument_list|,
name|value
argument_list|,
name|fptr_sec
operator|->
name|contents
operator|+
name|dyn_i
operator|->
name|fptr_offset
argument_list|)
expr_stmt|;
name|bfd_put_64
argument_list|(
name|abfd
argument_list|,
name|_bfd_get_gp_value
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|fptr_sec
operator|->
name|contents
operator|+
name|dyn_i
operator|->
name|fptr_offset
operator|+
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|ia64_info
operator|->
name|rel_fptr_sec
condition|)
block|{
name|Elf_Internal_Rela
name|outrel
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
if|if
condition|(
name|bfd_little_endian
argument_list|(
name|abfd
argument_list|)
condition|)
name|outrel
operator|.
name|r_info
operator|=
name|ELFNN_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_IA64_IPLTLSB
argument_list|)
expr_stmt|;
else|else
name|outrel
operator|.
name|r_info
operator|=
name|ELFNN_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_IA64_IPLTMSB
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
name|value
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|=
operator|(
name|fptr_sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|fptr_sec
operator|->
name|output_offset
operator|+
name|dyn_i
operator|->
name|fptr_offset
operator|)
expr_stmt|;
name|loc
operator|=
name|ia64_info
operator|->
name|rel_fptr_sec
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
name|ia64_info
operator|->
name|rel_fptr_sec
operator|->
name|reloc_count
operator|++
operator|*
sizeof|sizeof
argument_list|(
name|ElfNN_External_Rela
argument_list|)
expr_stmt|;
name|bfd_elfNN_swap_reloca_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|outrel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Return the descriptor's address.  */
name|value
operator|=
operator|(
name|fptr_sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|fptr_sec
operator|->
name|output_offset
operator|+
name|dyn_i
operator|->
name|fptr_offset
operator|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* Fill in a PLTOFF entry consisting of the function's code address    and its global pointer.  Return the descriptor's address.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|set_pltoff_entry
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|dyn_i
parameter_list|,
name|value
parameter_list|,
name|is_plt
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|elfNN_ia64_dyn_sym_info
modifier|*
name|dyn_i
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
name|bfd_boolean
name|is_plt
decl_stmt|;
block|{
name|struct
name|elfNN_ia64_link_hash_table
modifier|*
name|ia64_info
decl_stmt|;
name|asection
modifier|*
name|pltoff_sec
decl_stmt|;
name|ia64_info
operator|=
name|elfNN_ia64_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|pltoff_sec
operator|=
name|ia64_info
operator|->
name|pltoff_sec
expr_stmt|;
comment|/* Don't do anything if this symbol uses a real PLT entry.  In      that case, we'll fill this in during finish_dynamic_symbol.  */
if|if
condition|(
operator|(
operator|!
name|dyn_i
operator|->
name|want_plt
operator|||
name|is_plt
operator|)
operator|&&
operator|!
name|dyn_i
operator|->
name|pltoff_done
condition|)
block|{
name|bfd_vma
name|gp
init|=
name|_bfd_get_gp_value
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
comment|/* Fill in the function descriptor.  */
name|bfd_put_64
argument_list|(
name|abfd
argument_list|,
name|value
argument_list|,
name|pltoff_sec
operator|->
name|contents
operator|+
name|dyn_i
operator|->
name|pltoff_offset
argument_list|)
expr_stmt|;
name|bfd_put_64
argument_list|(
name|abfd
argument_list|,
name|gp
argument_list|,
name|pltoff_sec
operator|->
name|contents
operator|+
name|dyn_i
operator|->
name|pltoff_offset
operator|+
literal|8
argument_list|)
expr_stmt|;
comment|/* Install dynamic relocations if needed.  */
if|if
condition|(
operator|!
name|is_plt
operator|&&
name|info
operator|->
name|shared
operator|&&
operator|(
operator|!
name|dyn_i
operator|->
name|h
operator|||
name|ELF_ST_VISIBILITY
argument_list|(
name|dyn_i
operator|->
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_DEFAULT
operator|||
name|dyn_i
operator|->
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefweak
operator|)
condition|)
block|{
name|unsigned
name|int
name|dyn_r_type
decl_stmt|;
if|if
condition|(
name|bfd_big_endian
argument_list|(
name|abfd
argument_list|)
condition|)
name|dyn_r_type
operator|=
name|R_IA64_REL64MSB
expr_stmt|;
else|else
name|dyn_r_type
operator|=
name|R_IA64_REL64LSB
expr_stmt|;
name|elfNN_ia64_install_dyn_reloc
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|,
name|pltoff_sec
argument_list|,
name|ia64_info
operator|->
name|rel_pltoff_sec
argument_list|,
name|dyn_i
operator|->
name|pltoff_offset
argument_list|,
name|dyn_r_type
argument_list|,
literal|0
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|elfNN_ia64_install_dyn_reloc
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|,
name|pltoff_sec
argument_list|,
name|ia64_info
operator|->
name|rel_pltoff_sec
argument_list|,
name|dyn_i
operator|->
name|pltoff_offset
operator|+
literal|8
argument_list|,
name|dyn_r_type
argument_list|,
literal|0
argument_list|,
name|gp
argument_list|)
expr_stmt|;
block|}
name|dyn_i
operator|->
name|pltoff_done
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Return the descriptor's address.  */
name|value
operator|=
operator|(
name|pltoff_sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|pltoff_sec
operator|->
name|output_offset
operator|+
name|dyn_i
operator|->
name|pltoff_offset
operator|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* Return the base VMA address which should be subtracted from real addresses    when resolving @tprel() relocation.    Main program TLS (whose template starts at PT_TLS p_vaddr)    is assigned offset round(16, PT_TLS p_align).  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|elfNN_ia64_tprel_base
parameter_list|(
name|info
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|asection
modifier|*
name|tls_sec
init|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|tls_sec
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|tls_sec
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
name|tls_sec
operator|->
name|vma
operator|-
name|align_power
argument_list|(
operator|(
name|bfd_vma
operator|)
literal|16
argument_list|,
name|tls_sec
operator|->
name|alignment_power
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the base VMA address which should be subtracted from real addresses    when resolving @dtprel() relocation.    This is PT_TLS segment p_vaddr.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|elfNN_ia64_dtprel_base
parameter_list|(
name|info
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|BFD_ASSERT
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|tls_sec
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|tls_sec
operator|->
name|vma
return|;
block|}
end_function

begin_comment
comment|/* Called through qsort to sort the .IA_64.unwind section during a    non-relocatable link.  Set elfNN_ia64_unwind_entry_compare_bfd    to the output bfd so we can do proper endianness frobbing.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd
modifier|*
name|elfNN_ia64_unwind_entry_compare_bfd
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|elfNN_ia64_unwind_entry_compare
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
specifier|const
name|PTR
name|a
decl_stmt|;
specifier|const
name|PTR
name|b
decl_stmt|;
block|{
name|bfd_vma
name|av
decl_stmt|,
name|bv
decl_stmt|;
name|av
operator|=
name|bfd_get_64
argument_list|(
name|elfNN_ia64_unwind_entry_compare_bfd
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|bv
operator|=
name|bfd_get_64
argument_list|(
name|elfNN_ia64_unwind_entry_compare_bfd
argument_list|,
name|b
argument_list|)
expr_stmt|;
return|return
operator|(
name|av
operator|<
name|bv
condition|?
operator|-
literal|1
else|:
name|av
operator|>
name|bv
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Make sure we've got ourselves a nice fat __gp value.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elfNN_ia64_choose_gp
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|bfd_vma
name|min_vma
init|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
decl_stmt|,
name|max_vma
init|=
literal|0
decl_stmt|;
name|bfd_vma
name|min_short_vma
init|=
name|min_vma
decl_stmt|,
name|max_short_vma
init|=
literal|0
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|gp
decl_stmt|;
name|bfd_vma
name|gp_val
decl_stmt|;
name|asection
modifier|*
name|os
decl_stmt|;
name|struct
name|elfNN_ia64_link_hash_table
modifier|*
name|ia64_info
decl_stmt|;
name|ia64_info
operator|=
name|elfNN_ia64_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* Find the min and max vma of all sections marked short.  Also collect      min and max vma of any type, for use in selecting a nice gp.  */
for|for
control|(
name|os
operator|=
name|abfd
operator|->
name|sections
init|;
name|os
condition|;
name|os
operator|=
name|os
operator|->
name|next
control|)
block|{
name|bfd_vma
name|lo
decl_stmt|,
name|hi
decl_stmt|;
if|if
condition|(
operator|(
name|os
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|lo
operator|=
name|os
operator|->
name|vma
expr_stmt|;
name|hi
operator|=
name|os
operator|->
name|vma
operator|+
name|os
operator|->
name|_raw_size
expr_stmt|;
if|if
condition|(
name|hi
operator|<
name|lo
condition|)
name|hi
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|min_vma
operator|>
name|lo
condition|)
name|min_vma
operator|=
name|lo
expr_stmt|;
if|if
condition|(
name|max_vma
operator|<
name|hi
condition|)
name|max_vma
operator|=
name|hi
expr_stmt|;
if|if
condition|(
name|os
operator|->
name|flags
operator|&
name|SEC_SMALL_DATA
condition|)
block|{
if|if
condition|(
name|min_short_vma
operator|>
name|lo
condition|)
name|min_short_vma
operator|=
name|lo
expr_stmt|;
if|if
condition|(
name|max_short_vma
operator|<
name|hi
condition|)
name|max_short_vma
operator|=
name|hi
expr_stmt|;
block|}
block|}
comment|/* See if the user wants to force a value.  */
name|gp
operator|=
name|elf_link_hash_lookup
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
literal|"__gp"
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|gp
operator|&&
operator|(
name|gp
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|gp
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
condition|)
block|{
name|asection
modifier|*
name|gp_sec
init|=
name|gp
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
decl_stmt|;
name|gp_val
operator|=
operator|(
name|gp
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|gp_sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|gp_sec
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Pick a sensible value.  */
name|asection
modifier|*
name|got_sec
init|=
name|ia64_info
operator|->
name|got_sec
decl_stmt|;
comment|/* Start with just the address of the .got.  */
if|if
condition|(
name|got_sec
condition|)
name|gp_val
operator|=
name|got_sec
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
elseif|else
if|if
condition|(
name|max_short_vma
operator|!=
literal|0
condition|)
name|gp_val
operator|=
name|min_short_vma
expr_stmt|;
else|else
name|gp_val
operator|=
name|min_vma
expr_stmt|;
comment|/* If it is possible to address the entire image, but we 	 don't with the choice above, adjust.  */
if|if
condition|(
name|max_vma
operator|-
name|min_vma
operator|<
literal|0x400000
operator|&&
name|max_vma
operator|-
name|gp_val
operator|<=
literal|0x200000
operator|&&
name|gp_val
operator|-
name|min_vma
operator|>
literal|0x200000
condition|)
name|gp_val
operator|=
name|min_vma
operator|+
literal|0x200000
expr_stmt|;
elseif|else
if|if
condition|(
name|max_short_vma
operator|!=
literal|0
condition|)
block|{
comment|/* If we don't cover all the short data, adjust.  */
if|if
condition|(
name|max_short_vma
operator|-
name|gp_val
operator|>=
literal|0x200000
condition|)
name|gp_val
operator|=
name|min_short_vma
operator|+
literal|0x200000
expr_stmt|;
comment|/* If we're addressing stuff past the end, adjust back.  */
if|if
condition|(
name|gp_val
operator|>
name|max_vma
condition|)
name|gp_val
operator|=
name|max_vma
operator|-
literal|0x200000
operator|+
literal|8
expr_stmt|;
block|}
block|}
comment|/* Validate whether all SHF_IA_64_SHORT sections are within      range of the chosen GP.  */
if|if
condition|(
name|max_short_vma
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|max_short_vma
operator|-
name|min_short_vma
operator|>=
literal|0x400000
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: short data segment overflowed (0x%lx>= 0x400000)"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|max_short_vma
operator|-
name|min_short_vma
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|gp_val
operator|>
name|min_short_vma
operator|&&
name|gp_val
operator|-
name|min_short_vma
operator|>
literal|0x200000
operator|)
operator|||
operator|(
name|gp_val
operator|<
name|max_short_vma
operator|&&
name|max_short_vma
operator|-
name|gp_val
operator|>=
literal|0x200000
operator|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: __gp does not cover short data segment"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
name|_bfd_set_gp_value
argument_list|(
name|abfd
argument_list|,
name|gp_val
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elfNN_ia64_final_link
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|struct
name|elfNN_ia64_link_hash_table
modifier|*
name|ia64_info
decl_stmt|;
name|asection
modifier|*
name|unwind_output_sec
decl_stmt|;
name|ia64_info
operator|=
name|elfNN_ia64_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* Make sure we've got ourselves a nice fat __gp value.  */
if|if
condition|(
operator|!
name|info
operator|->
name|relocatable
condition|)
block|{
name|bfd_vma
name|gp_val
init|=
name|_bfd_get_gp_value
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|gp
decl_stmt|;
if|if
condition|(
name|gp_val
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|elfNN_ia64_choose_gp
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|gp_val
operator|=
name|_bfd_get_gp_value
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
name|gp
operator|=
name|elf_link_hash_lookup
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
literal|"__gp"
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|gp
condition|)
block|{
name|gp
operator|->
name|root
operator|.
name|type
operator|=
name|bfd_link_hash_defined
expr_stmt|;
name|gp
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|gp_val
expr_stmt|;
name|gp
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
block|}
block|}
comment|/* If we're producing a final executable, we need to sort the contents      of the .IA_64.unwind section.  Force this section to be relocated      into memory rather than written immediately to the output file.  */
name|unwind_output_sec
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|relocatable
condition|)
block|{
name|asection
modifier|*
name|s
init|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|ELF_STRING_ia64_unwind
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
condition|)
block|{
name|unwind_output_sec
operator|=
name|s
operator|->
name|output_section
expr_stmt|;
name|unwind_output_sec
operator|->
name|contents
operator|=
name|bfd_malloc
argument_list|(
name|unwind_output_sec
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|unwind_output_sec
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
block|}
comment|/* Invoke the regular ELF backend linker to do all the work.  */
if|if
condition|(
operator|!
name|bfd_elf_final_link
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|unwind_output_sec
condition|)
block|{
name|elfNN_ia64_unwind_entry_compare_bfd
operator|=
name|abfd
expr_stmt|;
name|qsort
argument_list|(
name|unwind_output_sec
operator|->
name|contents
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|unwind_output_sec
operator|->
name|_raw_size
operator|/
literal|24
argument_list|)
argument_list|,
literal|24
argument_list|,
name|elfNN_ia64_unwind_entry_compare
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|unwind_output_sec
argument_list|,
name|unwind_output_sec
operator|->
name|contents
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|unwind_output_sec
operator|->
name|_raw_size
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elfNN_ia64_relocate_section
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|contents
parameter_list|,
name|relocs
parameter_list|,
name|local_syms
parameter_list|,
name|local_sections
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|local_syms
decl_stmt|;
name|asection
modifier|*
modifier|*
name|local_sections
decl_stmt|;
block|{
name|struct
name|elfNN_ia64_link_hash_table
modifier|*
name|ia64_info
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relend
decl_stmt|;
name|asection
modifier|*
name|srel
decl_stmt|;
name|bfd_boolean
name|ret_val
init|=
name|TRUE
decl_stmt|;
comment|/* for non-fatal errors */
name|bfd_vma
name|gp_val
decl_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|ia64_info
operator|=
name|elfNN_ia64_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* Infect various flags from the input section to the output section.  */
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
block|{
name|bfd_vma
name|flags
decl_stmt|;
name|flags
operator|=
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_flags
expr_stmt|;
name|flags
operator|&=
name|SHF_IA_64_NORECOV
expr_stmt|;
name|elf_section_data
argument_list|(
name|input_section
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_flags
operator||=
name|flags
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|gp_val
operator|=
name|_bfd_get_gp_value
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
name|srel
operator|=
name|get_reloc_section
argument_list|(
name|input_bfd
argument_list|,
name|ia64_info
argument_list|,
name|input_section
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|rel
operator|=
name|relocs
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|input_section
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|rel
operator|<
name|relend
condition|;
operator|++
name|rel
control|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|elfNN_ia64_dyn_sym_info
modifier|*
name|dyn_i
decl_stmt|;
name|bfd_reloc_status_type
name|r
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|unsigned
name|int
name|r_type
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
name|asection
modifier|*
name|sym_sec
decl_stmt|;
name|bfd_byte
modifier|*
name|hit_addr
decl_stmt|;
name|bfd_boolean
name|dynamic_symbol_p
decl_stmt|;
name|bfd_boolean
name|undef_weak_ref
decl_stmt|;
name|r_type
operator|=
name|ELFNN_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|>
name|R_IA64_MAX_RELOC_CODE
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: unknown relocation type %d"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|r_type
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|FALSE
expr_stmt|;
continue|continue;
block|}
name|howto
operator|=
name|lookup_howto
argument_list|(
name|r_type
argument_list|)
expr_stmt|;
name|r_symndx
operator|=
name|ELFNN_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|h
operator|=
name|NULL
expr_stmt|;
name|sym
operator|=
name|NULL
expr_stmt|;
name|sym_sec
operator|=
name|NULL
expr_stmt|;
name|undef_weak_ref
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
comment|/* Reloc against local symbol.  */
name|asection
modifier|*
name|msec
decl_stmt|;
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
name|sym_sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|msec
operator|=
name|sym_sec
expr_stmt|;
name|value
operator|=
name|_bfd_elf_rela_local_sym
argument_list|(
name|output_bfd
argument_list|,
name|sym
argument_list|,
operator|&
name|msec
argument_list|,
name|rel
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sym_sec
operator|->
name|flags
operator|&
name|SEC_MERGE
operator|)
operator|&&
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_SECTION
operator|&&
name|sym_sec
operator|->
name|sec_info_type
operator|==
name|ELF_INFO_TYPE_MERGE
condition|)
block|{
name|struct
name|elfNN_ia64_local_hash_entry
modifier|*
name|loc_h
decl_stmt|;
name|loc_h
operator|=
name|get_local_sym_hash
argument_list|(
name|ia64_info
argument_list|,
name|input_bfd
argument_list|,
name|rel
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|loc_h
operator|&&
operator|!
name|loc_h
operator|->
name|sec_merge_done
condition|)
block|{
name|struct
name|elfNN_ia64_dyn_sym_info
modifier|*
name|dynent
decl_stmt|;
for|for
control|(
name|dynent
operator|=
name|loc_h
operator|->
name|info
init|;
name|dynent
condition|;
name|dynent
operator|=
name|dynent
operator|->
name|next
control|)
block|{
name|msec
operator|=
name|sym_sec
expr_stmt|;
name|dynent
operator|->
name|addend
operator|=
name|_bfd_merged_section_offset
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|msec
argument_list|,
name|elf_section_data
argument_list|(
name|msec
argument_list|)
operator|->
name|sec_info
argument_list|,
name|sym
operator|->
name|st_value
operator|+
name|dynent
operator|->
name|addend
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
expr_stmt|;
name|dynent
operator|->
name|addend
operator|-=
name|sym
operator|->
name|st_value
expr_stmt|;
name|dynent
operator|->
name|addend
operator|+=
name|msec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|msec
operator|->
name|output_offset
operator|-
name|sym_sec
operator|->
name|output_section
operator|->
name|vma
operator|-
name|sym_sec
operator|->
name|output_offset
expr_stmt|;
block|}
name|loc_h
operator|->
name|sec_merge_done
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|bfd_boolean
name|unresolved_reloc
decl_stmt|;
name|bfd_boolean
name|warned
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
init|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
decl_stmt|;
name|RELOC_FOR_GLOBAL_SYMBOL
argument_list|(
name|info
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
argument_list|,
name|r_symndx
argument_list|,
name|symtab_hdr
argument_list|,
name|sym_hashes
argument_list|,
name|h
argument_list|,
name|sym_sec
argument_list|,
name|value
argument_list|,
name|unresolved_reloc
argument_list|,
name|warned
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
name|undef_weak_ref
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|warned
condition|)
continue|continue;
block|}
name|hit_addr
operator|=
name|contents
operator|+
name|rel
operator|->
name|r_offset
expr_stmt|;
name|value
operator|+=
name|rel
operator|->
name|r_addend
expr_stmt|;
name|dynamic_symbol_p
operator|=
name|elfNN_ia64_dynamic_symbol_p
argument_list|(
name|h
argument_list|,
name|info
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_IA64_NONE
case|:
case|case
name|R_IA64_LDXMOV
case|:
continue|continue;
case|case
name|R_IA64_IMM14
case|:
case|case
name|R_IA64_IMM22
case|:
case|case
name|R_IA64_IMM64
case|:
case|case
name|R_IA64_DIR32MSB
case|:
case|case
name|R_IA64_DIR32LSB
case|:
case|case
name|R_IA64_DIR64MSB
case|:
case|case
name|R_IA64_DIR64LSB
case|:
comment|/* Install a dynamic relocation for this reloc.  */
if|if
condition|(
operator|(
name|dynamic_symbol_p
operator|||
name|info
operator|->
name|shared
operator|)
operator|&&
name|r_symndx
operator|!=
literal|0
operator|&&
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|int
name|dyn_r_type
decl_stmt|;
name|long
name|dynindx
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|srel
operator|!=
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_IA64_IMM14
case|:
case|case
name|R_IA64_IMM22
case|:
case|case
name|R_IA64_IMM64
case|:
comment|/* ??? People shouldn't be doing non-pic code in 		     shared libraries nor dynamic executables.  */
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: non-pic code with imm relocation against dynamic symbol `%s'"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|FALSE
expr_stmt|;
continue|continue;
default|default:
break|break;
block|}
comment|/* If we don't need dynamic symbol lookup, find a 		 matching RELATIVE relocation.  */
name|dyn_r_type
operator|=
name|r_type
expr_stmt|;
if|if
condition|(
name|dynamic_symbol_p
condition|)
block|{
name|dynindx
operator|=
name|h
operator|->
name|dynindx
expr_stmt|;
name|addend
operator|=
name|rel
operator|->
name|r_addend
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_IA64_DIR32MSB
case|:
name|dyn_r_type
operator|=
name|R_IA64_REL32MSB
expr_stmt|;
break|break;
case|case
name|R_IA64_DIR32LSB
case|:
name|dyn_r_type
operator|=
name|R_IA64_REL32LSB
expr_stmt|;
break|break;
case|case
name|R_IA64_DIR64MSB
case|:
name|dyn_r_type
operator|=
name|R_IA64_REL64MSB
expr_stmt|;
break|break;
case|case
name|R_IA64_DIR64LSB
case|:
name|dyn_r_type
operator|=
name|R_IA64_REL64LSB
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|dynindx
operator|=
literal|0
expr_stmt|;
name|addend
operator|=
name|value
expr_stmt|;
block|}
name|elfNN_ia64_install_dyn_reloc
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|input_section
argument_list|,
name|srel
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|dyn_r_type
argument_list|,
name|dynindx
argument_list|,
name|addend
argument_list|)
expr_stmt|;
block|}
comment|/* Fall through.  */
case|case
name|R_IA64_LTV32MSB
case|:
case|case
name|R_IA64_LTV32LSB
case|:
case|case
name|R_IA64_LTV64MSB
case|:
case|case
name|R_IA64_LTV64LSB
case|:
name|r
operator|=
name|elfNN_ia64_install_value
argument_list|(
name|output_bfd
argument_list|,
name|hit_addr
argument_list|,
name|value
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_IA64_GPREL22
case|:
case|case
name|R_IA64_GPREL64I
case|:
case|case
name|R_IA64_GPREL32MSB
case|:
case|case
name|R_IA64_GPREL32LSB
case|:
case|case
name|R_IA64_GPREL64MSB
case|:
case|case
name|R_IA64_GPREL64LSB
case|:
if|if
condition|(
name|dynamic_symbol_p
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: @gprel relocation against dynamic symbol %s"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|FALSE
expr_stmt|;
continue|continue;
block|}
name|value
operator|-=
name|gp_val
expr_stmt|;
name|r
operator|=
name|elfNN_ia64_install_value
argument_list|(
name|output_bfd
argument_list|,
name|hit_addr
argument_list|,
name|value
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_IA64_LTOFF22
case|:
case|case
name|R_IA64_LTOFF22X
case|:
case|case
name|R_IA64_LTOFF64I
case|:
name|dyn_i
operator|=
name|get_dyn_sym_info
argument_list|(
name|ia64_info
argument_list|,
name|h
argument_list|,
name|input_bfd
argument_list|,
name|rel
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|value
operator|=
name|set_got_entry
argument_list|(
name|input_bfd
argument_list|,
name|info
argument_list|,
name|dyn_i
argument_list|,
operator|(
name|h
condition|?
name|h
operator|->
name|dynindx
else|:
operator|-
literal|1
operator|)
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|,
name|value
argument_list|,
name|R_IA64_DIR64LSB
argument_list|)
expr_stmt|;
name|value
operator|-=
name|gp_val
expr_stmt|;
name|r
operator|=
name|elfNN_ia64_install_value
argument_list|(
name|output_bfd
argument_list|,
name|hit_addr
argument_list|,
name|value
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_IA64_PLTOFF22
case|:
case|case
name|R_IA64_PLTOFF64I
case|:
case|case
name|R_IA64_PLTOFF64MSB
case|:
case|case
name|R_IA64_PLTOFF64LSB
case|:
name|dyn_i
operator|=
name|get_dyn_sym_info
argument_list|(
name|ia64_info
argument_list|,
name|h
argument_list|,
name|input_bfd
argument_list|,
name|rel
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|value
operator|=
name|set_pltoff_entry
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|dyn_i
argument_list|,
name|value
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|value
operator|-=
name|gp_val
expr_stmt|;
name|r
operator|=
name|elfNN_ia64_install_value
argument_list|(
name|output_bfd
argument_list|,
name|hit_addr
argument_list|,
name|value
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_IA64_FPTR64I
case|:
case|case
name|R_IA64_FPTR32MSB
case|:
case|case
name|R_IA64_FPTR32LSB
case|:
case|case
name|R_IA64_FPTR64MSB
case|:
case|case
name|R_IA64_FPTR64LSB
case|:
name|dyn_i
operator|=
name|get_dyn_sym_info
argument_list|(
name|ia64_info
argument_list|,
name|h
argument_list|,
name|input_bfd
argument_list|,
name|rel
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|dyn_i
operator|->
name|want_fptr
condition|)
block|{
if|if
condition|(
operator|!
name|undef_weak_ref
condition|)
name|value
operator|=
name|set_fptr_entry
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|dyn_i
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|dyn_i
operator|->
name|want_fptr
operator|||
name|info
operator|->
name|pie
condition|)
block|{
name|long
name|dynindx
decl_stmt|;
name|unsigned
name|int
name|dyn_r_type
init|=
name|r_type
decl_stmt|;
name|bfd_vma
name|addend
init|=
name|rel
operator|->
name|r_addend
decl_stmt|;
comment|/* Otherwise, we expect the dynamic linker to create 		 the entry.  */
if|if
condition|(
name|dyn_i
operator|->
name|want_fptr
condition|)
block|{
if|if
condition|(
name|r_type
operator|==
name|R_IA64_FPTR64I
condition|)
block|{
comment|/* We can't represent this without a dynamic symbol. 			 Adjust the relocation to be against an output 			 section symbol, which are always present in the 			 dynamic symbol table.  */
comment|/* ??? People shouldn't be doing non-pic code in 			 shared libraries.  Hork.  */
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: linking non-pic code in a position independent executable"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|FALSE
expr_stmt|;
continue|continue;
block|}
name|dynindx
operator|=
literal|0
expr_stmt|;
name|addend
operator|=
name|value
expr_stmt|;
name|dyn_r_type
operator|=
name|r_type
operator|+
name|R_IA64_REL64LSB
operator|-
name|R_IA64_FPTR64LSB
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
condition|)
name|dynindx
operator|=
name|h
operator|->
name|dynindx
expr_stmt|;
else|else
name|dynindx
operator|=
operator|(
name|_bfd_elf_link_lookup_local_dynindx
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
argument_list|,
name|global_sym_index
argument_list|(
name|h
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|dynindx
operator|=
operator|(
name|_bfd_elf_link_lookup_local_dynindx
argument_list|(
name|info
argument_list|,
name|input_bfd
argument_list|,
operator|(
name|long
operator|)
name|r_symndx
argument_list|)
operator|)
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
block|}
name|elfNN_ia64_install_dyn_reloc
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|input_section
argument_list|,
name|srel
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|dyn_r_type
argument_list|,
name|dynindx
argument_list|,
name|addend
argument_list|)
expr_stmt|;
block|}
name|r
operator|=
name|elfNN_ia64_install_value
argument_list|(
name|output_bfd
argument_list|,
name|hit_addr
argument_list|,
name|value
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_IA64_LTOFF_FPTR22
case|:
case|case
name|R_IA64_LTOFF_FPTR64I
case|:
case|case
name|R_IA64_LTOFF_FPTR32MSB
case|:
case|case
name|R_IA64_LTOFF_FPTR32LSB
case|:
case|case
name|R_IA64_LTOFF_FPTR64MSB
case|:
case|case
name|R_IA64_LTOFF_FPTR64LSB
case|:
block|{
name|long
name|dynindx
decl_stmt|;
name|dyn_i
operator|=
name|get_dyn_sym_info
argument_list|(
name|ia64_info
argument_list|,
name|h
argument_list|,
name|input_bfd
argument_list|,
name|rel
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|dyn_i
operator|->
name|want_fptr
condition|)
block|{
name|BFD_ASSERT
argument_list|(
argument|h == NULL || h->dynindx == -
literal|1
argument_list|)
if|if
condition|(
operator|!
name|undef_weak_ref
condition|)
name|value
operator|=
name|set_fptr_entry
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|dyn_i
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|dynindx
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Otherwise, we expect the dynamic linker to create 		   the entry.  */
if|if
condition|(
name|h
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
condition|)
name|dynindx
operator|=
name|h
operator|->
name|dynindx
expr_stmt|;
else|else
name|dynindx
operator|=
operator|(
name|_bfd_elf_link_lookup_local_dynindx
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
argument_list|,
name|global_sym_index
argument_list|(
name|h
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
name|dynindx
operator|=
operator|(
name|_bfd_elf_link_lookup_local_dynindx
argument_list|(
name|info
argument_list|,
name|input_bfd
argument_list|,
operator|(
name|long
operator|)
name|r_symndx
argument_list|)
operator|)
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
block|}
name|value
operator|=
name|set_got_entry
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|dyn_i
argument_list|,
name|dynindx
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|,
name|value
argument_list|,
name|R_IA64_FPTR64LSB
argument_list|)
expr_stmt|;
name|value
operator|-=
name|gp_val
expr_stmt|;
name|r
operator|=
name|elfNN_ia64_install_value
argument_list|(
name|output_bfd
argument_list|,
name|hit_addr
argument_list|,
name|value
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|R_IA64_PCREL32MSB
case|:
case|case
name|R_IA64_PCREL32LSB
case|:
case|case
name|R_IA64_PCREL64MSB
case|:
case|case
name|R_IA64_PCREL64LSB
case|:
comment|/* Install a dynamic relocation for this reloc.  */
if|if
condition|(
name|dynamic_symbol_p
operator|&&
name|r_symndx
operator|!=
literal|0
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|srel
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|elfNN_ia64_install_dyn_reloc
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|input_section
argument_list|,
name|srel
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|r_type
argument_list|,
name|h
operator|->
name|dynindx
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
expr_stmt|;
block|}
goto|goto
name|finish_pcrel
goto|;
case|case
name|R_IA64_PCREL21B
case|:
case|case
name|R_IA64_PCREL60B
case|:
comment|/* We should have created a PLT entry for any dynamic symbol.  */
name|dyn_i
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|h
condition|)
name|dyn_i
operator|=
name|get_dyn_sym_info
argument_list|(
name|ia64_info
argument_list|,
name|h
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|dyn_i
operator|&&
name|dyn_i
operator|->
name|want_plt2
condition|)
block|{
comment|/* Should have caught this earlier.  */
name|BFD_ASSERT
argument_list|(
name|rel
operator|->
name|r_addend
operator|==
literal|0
argument_list|)
expr_stmt|;
name|value
operator|=
operator|(
name|ia64_info
operator|->
name|plt_sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|ia64_info
operator|->
name|plt_sec
operator|->
name|output_offset
operator|+
name|dyn_i
operator|->
name|plt2_offset
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Since there's no PLT entry, Validate that this is 		 locally defined.  */
name|BFD_ASSERT
argument_list|(
name|undef_weak_ref
operator|||
name|sym_sec
operator|->
name|output_section
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* If the symbol is undef_weak, we shouldn't be trying 		 to call it.  There's every chance that we'd wind up 		 with an out-of-range fixup here.  Don't bother setting 		 any value at all.  */
if|if
condition|(
name|undef_weak_ref
condition|)
continue|continue;
block|}
goto|goto
name|finish_pcrel
goto|;
case|case
name|R_IA64_PCREL21BI
case|:
case|case
name|R_IA64_PCREL21F
case|:
case|case
name|R_IA64_PCREL21M
case|:
case|case
name|R_IA64_PCREL22
case|:
case|case
name|R_IA64_PCREL64I
case|:
comment|/* The PCREL21BI reloc is specifically not intended for use with 	     dynamic relocs.  PCREL21F and PCREL21M are used for speculation 	     fixup code, and thus probably ought not be dynamic.  The  	     PCREL22 and PCREL64I relocs aren't emitted as dynamic relocs.  */
if|if
condition|(
name|dynamic_symbol_p
condition|)
block|{
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_IA64_PCREL21BI
condition|)
name|msg
operator|=
name|_
argument_list|(
literal|"%s: @internal branch to dynamic symbol %s"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|r_type
operator|==
name|R_IA64_PCREL21F
operator|||
name|r_type
operator|==
name|R_IA64_PCREL21M
condition|)
name|msg
operator|=
name|_
argument_list|(
literal|"%s: speculation fixup to dynamic symbol %s"
argument_list|)
expr_stmt|;
else|else
name|msg
operator|=
name|_
argument_list|(
literal|"%s: @pcrel relocation against dynamic symbol %s"
argument_list|)
expr_stmt|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|msg
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|FALSE
expr_stmt|;
continue|continue;
block|}
goto|goto
name|finish_pcrel
goto|;
name|finish_pcrel
label|:
comment|/* Make pc-relative.  */
name|value
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|rel
operator|->
name|r_offset
operator|)
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
literal|0x3
expr_stmt|;
name|r
operator|=
name|elfNN_ia64_install_value
argument_list|(
name|output_bfd
argument_list|,
name|hit_addr
argument_list|,
name|value
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_IA64_SEGREL32MSB
case|:
case|case
name|R_IA64_SEGREL32LSB
case|:
case|case
name|R_IA64_SEGREL64MSB
case|:
case|case
name|R_IA64_SEGREL64LSB
case|:
if|if
condition|(
name|r_symndx
operator|==
literal|0
condition|)
block|{
comment|/* If the input section was discarded from the output, then 		 do nothing.  */
name|r
operator|=
name|bfd_reloc_ok
expr_stmt|;
block|}
else|else
block|{
name|struct
name|elf_segment_map
modifier|*
name|m
decl_stmt|;
name|Elf_Internal_Phdr
modifier|*
name|p
decl_stmt|;
comment|/* Find the segment that contains the output_section.  */
for|for
control|(
name|m
operator|=
name|elf_tdata
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|segment_map
operator|,
name|p
operator|=
name|elf_tdata
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|phdr
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|next
operator|,
name|p
operator|++
control|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|m
operator|->
name|count
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|m
operator|->
name|sections
index|[
name|i
index|]
operator|==
name|input_section
operator|->
name|output_section
condition|)
break|break;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|r
operator|=
name|bfd_reloc_notsupported
expr_stmt|;
block|}
else|else
block|{
comment|/* The VMA of the segment is the vaddr of the associated 		     program header.  */
if|if
condition|(
name|value
operator|>
name|p
operator|->
name|p_vaddr
condition|)
name|value
operator|-=
name|p
operator|->
name|p_vaddr
expr_stmt|;
else|else
name|value
operator|=
literal|0
expr_stmt|;
name|r
operator|=
name|elfNN_ia64_install_value
argument_list|(
name|output_bfd
argument_list|,
name|hit_addr
argument_list|,
name|value
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|R_IA64_SECREL32MSB
case|:
case|case
name|R_IA64_SECREL32LSB
case|:
case|case
name|R_IA64_SECREL64MSB
case|:
case|case
name|R_IA64_SECREL64LSB
case|:
comment|/* Make output-section relative.  */
if|if
condition|(
name|value
operator|>
name|input_section
operator|->
name|output_section
operator|->
name|vma
condition|)
name|value
operator|-=
name|input_section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
else|else
name|value
operator|=
literal|0
expr_stmt|;
name|r
operator|=
name|elfNN_ia64_install_value
argument_list|(
name|output_bfd
argument_list|,
name|hit_addr
argument_list|,
name|value
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_IA64_IPLTMSB
case|:
case|case
name|R_IA64_IPLTLSB
case|:
comment|/* Install a dynamic relocation for this reloc.  */
if|if
condition|(
operator|(
name|dynamic_symbol_p
operator|||
name|info
operator|->
name|shared
operator|)
operator|&&
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|srel
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* If we don't need dynamic symbol lookup, install two 		 RELATIVE relocations.  */
if|if
condition|(
operator|!
name|dynamic_symbol_p
condition|)
block|{
name|unsigned
name|int
name|dyn_r_type
decl_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_IA64_IPLTMSB
condition|)
name|dyn_r_type
operator|=
name|R_IA64_REL64MSB
expr_stmt|;
else|else
name|dyn_r_type
operator|=
name|R_IA64_REL64LSB
expr_stmt|;
name|elfNN_ia64_install_dyn_reloc
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|input_section
argument_list|,
name|srel
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|dyn_r_type
argument_list|,
literal|0
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|elfNN_ia64_install_dyn_reloc
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|input_section
argument_list|,
name|srel
argument_list|,
name|rel
operator|->
name|r_offset
operator|+
literal|8
argument_list|,
name|dyn_r_type
argument_list|,
literal|0
argument_list|,
name|gp_val
argument_list|)
expr_stmt|;
block|}
else|else
name|elfNN_ia64_install_dyn_reloc
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|input_section
argument_list|,
name|srel
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|r_type
argument_list|,
name|h
operator|->
name|dynindx
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r_type
operator|==
name|R_IA64_IPLTMSB
condition|)
name|r_type
operator|=
name|R_IA64_DIR64MSB
expr_stmt|;
else|else
name|r_type
operator|=
name|R_IA64_DIR64LSB
expr_stmt|;
name|elfNN_ia64_install_value
argument_list|(
name|output_bfd
argument_list|,
name|hit_addr
argument_list|,
name|value
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
name|r
operator|=
name|elfNN_ia64_install_value
argument_list|(
name|output_bfd
argument_list|,
name|hit_addr
operator|+
literal|8
argument_list|,
name|gp_val
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_IA64_TPREL14
case|:
case|case
name|R_IA64_TPREL22
case|:
case|case
name|R_IA64_TPREL64I
case|:
name|value
operator|-=
name|elfNN_ia64_tprel_base
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|r
operator|=
name|elfNN_ia64_install_value
argument_list|(
name|output_bfd
argument_list|,
name|hit_addr
argument_list|,
name|value
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_IA64_DTPREL14
case|:
case|case
name|R_IA64_DTPREL22
case|:
case|case
name|R_IA64_DTPREL64I
case|:
case|case
name|R_IA64_DTPREL64LSB
case|:
case|case
name|R_IA64_DTPREL64MSB
case|:
name|value
operator|-=
name|elfNN_ia64_dtprel_base
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|r
operator|=
name|elfNN_ia64_install_value
argument_list|(
name|output_bfd
argument_list|,
name|hit_addr
argument_list|,
name|value
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_IA64_LTOFF_TPREL22
case|:
case|case
name|R_IA64_LTOFF_DTPMOD22
case|:
case|case
name|R_IA64_LTOFF_DTPREL22
case|:
block|{
name|int
name|got_r_type
decl_stmt|;
name|long
name|dynindx
init|=
name|h
condition|?
name|h
operator|->
name|dynindx
else|:
operator|-
literal|1
decl_stmt|;
name|bfd_vma
name|r_addend
init|=
name|rel
operator|->
name|r_addend
decl_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
default|default:
case|case
name|R_IA64_LTOFF_TPREL22
case|:
if|if
condition|(
operator|!
name|dynamic_symbol_p
condition|)
block|{
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
name|value
operator|-=
name|elfNN_ia64_tprel_base
argument_list|(
name|info
argument_list|)
expr_stmt|;
else|else
block|{
name|r_addend
operator|+=
name|value
operator|-
name|elfNN_ia64_dtprel_base
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|dynindx
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|got_r_type
operator|=
name|R_IA64_TPREL64LSB
expr_stmt|;
break|break;
case|case
name|R_IA64_LTOFF_DTPMOD22
case|:
if|if
condition|(
operator|!
name|dynamic_symbol_p
operator|&&
operator|!
name|info
operator|->
name|shared
condition|)
name|value
operator|=
literal|1
expr_stmt|;
name|got_r_type
operator|=
name|R_IA64_DTPMOD64LSB
expr_stmt|;
break|break;
case|case
name|R_IA64_LTOFF_DTPREL22
case|:
if|if
condition|(
operator|!
name|dynamic_symbol_p
condition|)
name|value
operator|-=
name|elfNN_ia64_dtprel_base
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|got_r_type
operator|=
name|R_IA64_DTPREL64LSB
expr_stmt|;
break|break;
block|}
name|dyn_i
operator|=
name|get_dyn_sym_info
argument_list|(
name|ia64_info
argument_list|,
name|h
argument_list|,
name|input_bfd
argument_list|,
name|rel
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|value
operator|=
name|set_got_entry
argument_list|(
name|input_bfd
argument_list|,
name|info
argument_list|,
name|dyn_i
argument_list|,
name|dynindx
argument_list|,
name|r_addend
argument_list|,
name|value
argument_list|,
name|got_r_type
argument_list|)
expr_stmt|;
name|value
operator|-=
name|gp_val
expr_stmt|;
name|r
operator|=
name|elfNN_ia64_install_value
argument_list|(
name|output_bfd
argument_list|,
name|hit_addr
argument_list|,
name|value
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|r
operator|=
name|bfd_reloc_notsupported
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|bfd_reloc_ok
case|:
break|break;
case|case
name|bfd_reloc_undefined
case|:
comment|/* This can happen for global table relative relocs if 	     __gp is undefined.  This is a panic situation so we 	     don't try to continue.  */
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|info
argument_list|,
literal|"__gp"
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
case|case
name|bfd_reloc_notsupported
case|:
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|h
condition|)
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
else|else
block|{
name|name
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_link
argument_list|,
name|sym
operator|->
name|st_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'\0'
condition|)
name|name
operator|=
name|bfd_section_name
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|warning
call|)
argument_list|(
name|info
argument_list|,
name|_
argument_list|(
literal|"unsupported reloc"
argument_list|)
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|ret_val
operator|=
name|FALSE
expr_stmt|;
block|}
break|break;
case|case
name|bfd_reloc_dangerous
case|:
case|case
name|bfd_reloc_outofrange
case|:
case|case
name|bfd_reloc_overflow
case|:
default|default:
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|h
condition|)
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
else|else
block|{
name|name
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_link
argument_list|,
name|sym
operator|->
name|st_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'\0'
condition|)
name|name
operator|=
name|bfd_section_name
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|info
argument_list|,
name|name
argument_list|,
name|howto
operator|->
name|name
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|ret_val
operator|=
name|FALSE
expr_stmt|;
block|}
break|break;
block|}
block|}
return|return
name|ret_val
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elfNN_ia64_finish_dynamic_symbol
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|h
parameter_list|,
name|sym
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
block|{
name|struct
name|elfNN_ia64_link_hash_table
modifier|*
name|ia64_info
decl_stmt|;
name|struct
name|elfNN_ia64_dyn_sym_info
modifier|*
name|dyn_i
decl_stmt|;
name|ia64_info
operator|=
name|elfNN_ia64_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|dyn_i
operator|=
name|get_dyn_sym_info
argument_list|(
name|ia64_info
argument_list|,
name|h
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Fill in the PLT data, if required.  */
if|if
condition|(
name|dyn_i
operator|&&
name|dyn_i
operator|->
name|want_plt
condition|)
block|{
name|Elf_Internal_Rela
name|outrel
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|asection
modifier|*
name|plt_sec
decl_stmt|;
name|bfd_vma
name|plt_addr
decl_stmt|,
name|pltoff_addr
decl_stmt|,
name|gp_val
decl_stmt|,
name|index
decl_stmt|;
name|gp_val
operator|=
name|_bfd_get_gp_value
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
comment|/* Initialize the minimal PLT entry.  */
name|index
operator|=
operator|(
name|dyn_i
operator|->
name|plt_offset
operator|-
name|PLT_HEADER_SIZE
operator|)
operator|/
name|PLT_MIN_ENTRY_SIZE
expr_stmt|;
name|plt_sec
operator|=
name|ia64_info
operator|->
name|plt_sec
expr_stmt|;
name|loc
operator|=
name|plt_sec
operator|->
name|contents
operator|+
name|dyn_i
operator|->
name|plt_offset
expr_stmt|;
name|memcpy
argument_list|(
name|loc
argument_list|,
name|plt_min_entry
argument_list|,
name|PLT_MIN_ENTRY_SIZE
argument_list|)
expr_stmt|;
name|elfNN_ia64_install_value
argument_list|(
name|output_bfd
argument_list|,
name|loc
argument_list|,
name|index
argument_list|,
name|R_IA64_IMM22
argument_list|)
expr_stmt|;
name|elfNN_ia64_install_value
argument_list|(
name|output_bfd
argument_list|,
name|loc
operator|+
literal|2
argument_list|,
operator|-
name|dyn_i
operator|->
name|plt_offset
argument_list|,
name|R_IA64_PCREL21B
argument_list|)
expr_stmt|;
name|plt_addr
operator|=
operator|(
name|plt_sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|plt_sec
operator|->
name|output_offset
operator|+
name|dyn_i
operator|->
name|plt_offset
operator|)
expr_stmt|;
name|pltoff_addr
operator|=
name|set_pltoff_entry
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|dyn_i
argument_list|,
name|plt_addr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* Initialize the FULL PLT entry, if needed.  */
if|if
condition|(
name|dyn_i
operator|->
name|want_plt2
condition|)
block|{
name|loc
operator|=
name|plt_sec
operator|->
name|contents
operator|+
name|dyn_i
operator|->
name|plt2_offset
expr_stmt|;
name|memcpy
argument_list|(
name|loc
argument_list|,
name|plt_full_entry
argument_list|,
name|PLT_FULL_ENTRY_SIZE
argument_list|)
expr_stmt|;
name|elfNN_ia64_install_value
argument_list|(
name|output_bfd
argument_list|,
name|loc
argument_list|,
name|pltoff_addr
operator|-
name|gp_val
argument_list|,
name|R_IA64_IMM22
argument_list|)
expr_stmt|;
comment|/* Mark the symbol as undefined, rather than as defined in the 	     plt section.  Leave the value alone.  */
comment|/* ??? We didn't redefine it in adjust_dynamic_symbol in the 	     first place.  But perhaps elflink.c did some for us.  */
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
condition|)
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_UNDEF
expr_stmt|;
block|}
comment|/* Create the dynamic relocation.  */
name|outrel
operator|.
name|r_offset
operator|=
name|pltoff_addr
expr_stmt|;
if|if
condition|(
name|bfd_little_endian
argument_list|(
name|output_bfd
argument_list|)
condition|)
name|outrel
operator|.
name|r_info
operator|=
name|ELFNN_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_IA64_IPLTLSB
argument_list|)
expr_stmt|;
else|else
name|outrel
operator|.
name|r_info
operator|=
name|ELFNN_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_IA64_IPLTMSB
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
comment|/* This is fun.  In the .IA_64.pltoff section, we've got entries 	 that correspond both to real PLT entries, and those that 	 happened to resolve to local symbols but need to be created 	 to satisfy @pltoff relocations.  The .rela.IA_64.pltoff 	 relocations for the real PLT should come at the end of the 	 section, so that they can be indexed by plt entry at runtime.  	 We emitted all of the relocations for the non-PLT @pltoff 	 entries during relocate_section.  So we can consider the 	 existing sec->reloc_count to be the base of the array of 	 PLT relocations.  */
name|loc
operator|=
name|ia64_info
operator|->
name|rel_pltoff_sec
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
operator|(
operator|(
name|ia64_info
operator|->
name|rel_pltoff_sec
operator|->
name|reloc_count
operator|+
name|index
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|ElfNN_External_Rela
argument_list|)
operator|)
expr_stmt|;
name|bfd_elfNN_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
comment|/* Mark some specially defined symbols as absolute.  */
if|if
condition|(
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_DYNAMIC"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_PROCEDURE_LINKAGE_TABLE_"
argument_list|)
operator|==
literal|0
condition|)
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_ABS
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elfNN_ia64_finish_dynamic_sections
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|struct
name|elfNN_ia64_link_hash_table
modifier|*
name|ia64_info
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|ia64_info
operator|=
name|elfNN_ia64_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|dynobj
operator|=
name|ia64_info
operator|->
name|root
operator|.
name|dynobj
expr_stmt|;
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
name|ElfNN_External_Dyn
modifier|*
name|dyncon
decl_stmt|,
modifier|*
name|dynconend
decl_stmt|;
name|asection
modifier|*
name|sdyn
decl_stmt|,
modifier|*
name|sgotplt
decl_stmt|;
name|bfd_vma
name|gp_val
decl_stmt|;
name|sdyn
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
name|sgotplt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got.plt"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sdyn
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dyncon
operator|=
operator|(
name|ElfNN_External_Dyn
operator|*
operator|)
name|sdyn
operator|->
name|contents
expr_stmt|;
name|dynconend
operator|=
operator|(
name|ElfNN_External_Dyn
operator|*
operator|)
operator|(
name|sdyn
operator|->
name|contents
operator|+
name|sdyn
operator|->
name|_raw_size
operator|)
expr_stmt|;
name|gp_val
operator|=
name|_bfd_get_gp_value
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|dyncon
operator|<
name|dynconend
condition|;
name|dyncon
operator|++
control|)
block|{
name|Elf_Internal_Dyn
name|dyn
decl_stmt|;
name|bfd_elfNN_swap_dyn_in
argument_list|(
name|dynobj
argument_list|,
name|dyncon
argument_list|,
operator|&
name|dyn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dyn
operator|.
name|d_tag
condition|)
block|{
case|case
name|DT_PLTGOT
case|:
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|gp_val
expr_stmt|;
break|break;
case|case
name|DT_PLTRELSZ
case|:
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
operator|(
name|ia64_info
operator|->
name|minplt_entries
operator|*
sizeof|sizeof
argument_list|(
name|ElfNN_External_Rela
argument_list|)
operator|)
expr_stmt|;
break|break;
case|case
name|DT_JMPREL
case|:
comment|/* See the comment above in finish_dynamic_symbol.  */
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
operator|(
name|ia64_info
operator|->
name|rel_pltoff_sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|ia64_info
operator|->
name|rel_pltoff_sec
operator|->
name|output_offset
operator|+
operator|(
name|ia64_info
operator|->
name|rel_pltoff_sec
operator|->
name|reloc_count
operator|*
sizeof|sizeof
argument_list|(
name|ElfNN_External_Rela
argument_list|)
operator|)
operator|)
expr_stmt|;
break|break;
case|case
name|DT_IA_64_PLT_RESERVE
case|:
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
operator|(
name|sgotplt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgotplt
operator|->
name|output_offset
operator|)
expr_stmt|;
break|break;
case|case
name|DT_RELASZ
case|:
comment|/* Do not have RELASZ include JMPREL.  This makes things 		 easier on ld.so.  This is not what the rest of BFD set up.  */
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|-=
operator|(
name|ia64_info
operator|->
name|minplt_entries
operator|*
sizeof|sizeof
argument_list|(
name|ElfNN_External_Rela
argument_list|)
operator|)
expr_stmt|;
break|break;
block|}
name|bfd_elfNN_swap_dyn_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize the PLT0 entry.  */
if|if
condition|(
name|ia64_info
operator|->
name|plt_sec
condition|)
block|{
name|bfd_byte
modifier|*
name|loc
init|=
name|ia64_info
operator|->
name|plt_sec
operator|->
name|contents
decl_stmt|;
name|bfd_vma
name|pltres
decl_stmt|;
name|memcpy
argument_list|(
name|loc
argument_list|,
name|plt_header
argument_list|,
name|PLT_HEADER_SIZE
argument_list|)
expr_stmt|;
name|pltres
operator|=
operator|(
name|sgotplt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgotplt
operator|->
name|output_offset
operator|-
name|gp_val
operator|)
expr_stmt|;
name|elfNN_ia64_install_value
argument_list|(
name|abfd
argument_list|,
name|loc
operator|+
literal|1
argument_list|,
name|pltres
argument_list|,
name|R_IA64_GPREL22
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ELF file flag handling:  */
end_comment

begin_comment
comment|/* Function to keep IA-64 specific file flags.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elfNN_ia64_set_private_flags
parameter_list|(
name|abfd
parameter_list|,
name|flags
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
block|{
name|BFD_ASSERT
argument_list|(
operator|!
name|elf_flags_init
argument_list|(
name|abfd
argument_list|)
operator|||
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|==
name|flags
argument_list|)
expr_stmt|;
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|=
name|flags
expr_stmt|;
name|elf_flags_init
argument_list|(
name|abfd
argument_list|)
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Merge backend specific data from an object file to the output    object file when linking.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elfNN_ia64_merge_private_bfd_data
parameter_list|(
name|ibfd
parameter_list|,
name|obfd
parameter_list|)
name|bfd
modifier|*
name|ibfd
decl_stmt|,
decl|*
name|obfd
decl_stmt|;
end_function

begin_block
block|{
name|flagword
name|out_flags
decl_stmt|;
name|flagword
name|in_flags
decl_stmt|;
name|bfd_boolean
name|ok
init|=
name|TRUE
decl_stmt|;
comment|/* Don't even pretend to support mixed-format linking.  */
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|ibfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
operator|||
name|bfd_get_flavour
argument_list|(
name|obfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
return|return
name|FALSE
return|;
name|in_flags
operator|=
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
name|out_flags
operator|=
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
if|if
condition|(
operator|!
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
condition|)
block|{
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
operator|=
name|TRUE
expr_stmt|;
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|=
name|in_flags
expr_stmt|;
if|if
condition|(
name|bfd_get_arch
argument_list|(
name|obfd
argument_list|)
operator|==
name|bfd_get_arch
argument_list|(
name|ibfd
argument_list|)
operator|&&
name|bfd_get_arch_info
argument_list|(
name|obfd
argument_list|)
operator|->
name|the_default
condition|)
block|{
return|return
name|bfd_set_arch_mach
argument_list|(
name|obfd
argument_list|,
name|bfd_get_arch
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|bfd_get_mach
argument_list|(
name|ibfd
argument_list|)
argument_list|)
return|;
block|}
return|return
name|TRUE
return|;
block|}
comment|/* Check flag compatibility.  */
if|if
condition|(
name|in_flags
operator|==
name|out_flags
condition|)
return|return
name|TRUE
return|;
comment|/* Output has EF_IA_64_REDUCEDFP set only if all inputs have it set.  */
if|if
condition|(
operator|!
operator|(
name|in_flags
operator|&
name|EF_IA_64_REDUCEDFP
operator|)
operator|&&
operator|(
name|out_flags
operator|&
name|EF_IA_64_REDUCEDFP
operator|)
condition|)
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|&=
operator|~
name|EF_IA_64_REDUCEDFP
expr_stmt|;
if|if
condition|(
operator|(
name|in_flags
operator|&
name|EF_IA_64_TRAPNIL
operator|)
operator|!=
operator|(
name|out_flags
operator|&
name|EF_IA_64_TRAPNIL
operator|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: linking trap-on-NULL-dereference with non-trapping files"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
name|ok
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|in_flags
operator|&
name|EF_IA_64_BE
operator|)
operator|!=
operator|(
name|out_flags
operator|&
name|EF_IA_64_BE
operator|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: linking big-endian files with little-endian files"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
name|ok
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|in_flags
operator|&
name|EF_IA_64_ABI64
operator|)
operator|!=
operator|(
name|out_flags
operator|&
name|EF_IA_64_ABI64
operator|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: linking 64-bit files with 32-bit files"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
name|ok
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|in_flags
operator|&
name|EF_IA_64_CONS_GP
operator|)
operator|!=
operator|(
name|out_flags
operator|&
name|EF_IA_64_CONS_GP
operator|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: linking constant-gp files with non-constant-gp files"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
name|ok
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|in_flags
operator|&
name|EF_IA_64_NOFUNCDESC_CONS_GP
operator|)
operator|!=
operator|(
name|out_flags
operator|&
name|EF_IA_64_NOFUNCDESC_CONS_GP
operator|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: linking auto-pic files with non-auto-pic files"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
name|ok
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|ok
return|;
block|}
end_block

begin_function
specifier|static
name|bfd_boolean
name|elfNN_ia64_print_private_bfd_data
parameter_list|(
name|abfd
parameter_list|,
name|ptr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|ptr
decl_stmt|;
block|{
name|FILE
modifier|*
name|file
init|=
operator|(
name|FILE
operator|*
operator|)
name|ptr
decl_stmt|;
name|flagword
name|flags
init|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|abfd
operator|!=
name|NULL
operator|&&
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"private flags = %s%s%s%s%s%s%s%s\n"
argument_list|,
operator|(
name|flags
operator|&
name|EF_IA_64_TRAPNIL
operator|)
condition|?
literal|"TRAPNIL, "
else|:
literal|""
argument_list|,
operator|(
name|flags
operator|&
name|EF_IA_64_EXT
operator|)
condition|?
literal|"EXT, "
else|:
literal|""
argument_list|,
operator|(
name|flags
operator|&
name|EF_IA_64_BE
operator|)
condition|?
literal|"BE, "
else|:
literal|"LE, "
argument_list|,
operator|(
name|flags
operator|&
name|EF_IA_64_REDUCEDFP
operator|)
condition|?
literal|"REDUCEDFP, "
else|:
literal|""
argument_list|,
operator|(
name|flags
operator|&
name|EF_IA_64_CONS_GP
operator|)
condition|?
literal|"CONS_GP, "
else|:
literal|""
argument_list|,
operator|(
name|flags
operator|&
name|EF_IA_64_NOFUNCDESC_CONS_GP
operator|)
condition|?
literal|"NOFUNCDESC_CONS_GP, "
else|:
literal|""
argument_list|,
operator|(
name|flags
operator|&
name|EF_IA_64_ABSOLUTE
operator|)
condition|?
literal|"ABSOLUTE, "
else|:
literal|""
argument_list|,
operator|(
name|flags
operator|&
name|EF_IA_64_ABI64
operator|)
condition|?
literal|"ABI64"
else|:
literal|"ABI32"
argument_list|)
expr_stmt|;
name|_bfd_elf_print_private_bfd_data
argument_list|(
name|abfd
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|elf_reloc_type_class
name|elfNN_ia64_reloc_type_class
parameter_list|(
name|rela
parameter_list|)
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rela
decl_stmt|;
block|{
switch|switch
condition|(
operator|(
name|int
operator|)
name|ELFNN_R_TYPE
argument_list|(
name|rela
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_IA64_REL32MSB
case|:
case|case
name|R_IA64_REL32LSB
case|:
case|case
name|R_IA64_REL64MSB
case|:
case|case
name|R_IA64_REL64LSB
case|:
return|return
name|reloc_class_relative
return|;
case|case
name|R_IA64_IPLTMSB
case|:
case|case
name|R_IA64_IPLTLSB
case|:
return|return
name|reloc_class_plt
return|;
case|case
name|R_IA64_COPY
case|:
return|return
name|reloc_class_copy
return|;
default|default:
return|return
name|reloc_class_normal
return|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|bfd_elf_special_section
specifier|const
name|elfNN_ia64_special_sections
index|[]
init|=
block|{
block|{
literal|".sbss"
block|,
literal|5
block|,
operator|-
literal|1
block|,
name|SHT_NOBITS
block|,
name|SHF_ALLOC
operator|+
name|SHF_WRITE
operator|+
name|SHF_IA_64_SHORT
block|}
block|,
block|{
literal|".sdata"
block|,
literal|6
block|,
operator|-
literal|1
block|,
name|SHT_PROGBITS
block|,
name|SHF_ALLOC
operator|+
name|SHF_WRITE
operator|+
name|SHF_IA_64_SHORT
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|bfd_boolean
name|elfNN_ia64_hpux_vec
parameter_list|(
specifier|const
name|bfd_target
modifier|*
name|vec
parameter_list|)
block|{
specifier|extern
specifier|const
name|bfd_target
name|bfd_elfNN_ia64_hpux_big_vec
decl_stmt|;
return|return
operator|(
name|vec
operator|==
operator|&
name|bfd_elfNN_ia64_hpux_big_vec
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|elfNN_hpux_post_process_headers
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|Elf_Internal_Ehdr
modifier|*
name|i_ehdrp
init|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|i_ehdrp
operator|->
name|e_ident
index|[
name|EI_OSABI
index|]
operator|=
name|ELFOSABI_HPUX
expr_stmt|;
name|i_ehdrp
operator|->
name|e_ident
index|[
name|EI_ABIVERSION
index|]
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|bfd_boolean
name|elfNN_hpux_backend_section_from_bfd_section
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|retval
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|int
modifier|*
name|retval
decl_stmt|;
block|{
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|sec
argument_list|)
condition|)
block|{
operator|*
name|retval
operator|=
name|SHN_IA_64_ANSI_COMMON
expr_stmt|;
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|elfNN_hpux_backend_symbol_processing
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asymbol
modifier|*
name|asym
parameter_list|)
block|{
name|elf_symbol_type
modifier|*
name|elfsym
init|=
operator|(
name|elf_symbol_type
operator|*
operator|)
name|asym
decl_stmt|;
empty_stmt|;
switch|switch
condition|(
name|elfsym
operator|->
name|internal_elf_sym
operator|.
name|st_shndx
condition|)
block|{
case|case
name|SHN_IA_64_ANSI_COMMON
case|:
name|asym
operator|->
name|section
operator|=
name|bfd_com_section_ptr
expr_stmt|;
name|asym
operator|->
name|value
operator|=
name|elfsym
operator|->
name|internal_elf_sym
operator|.
name|st_size
expr_stmt|;
name|asym
operator|->
name|flags
operator|&=
operator|~
name|BSF_GLOBAL
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|TARGET_LITTLE_SYM
value|bfd_elfNN_ia64_little_vec
end_define

begin_define
define|#
directive|define
name|TARGET_LITTLE_NAME
value|"elfNN-ia64-little"
end_define

begin_define
define|#
directive|define
name|TARGET_BIG_SYM
value|bfd_elfNN_ia64_big_vec
end_define

begin_define
define|#
directive|define
name|TARGET_BIG_NAME
value|"elfNN-ia64-big"
end_define

begin_define
define|#
directive|define
name|ELF_ARCH
value|bfd_arch_ia64
end_define

begin_define
define|#
directive|define
name|ELF_MACHINE_CODE
value|EM_IA_64
end_define

begin_define
define|#
directive|define
name|ELF_MACHINE_ALT1
value|1999
end_define

begin_comment
comment|/* EAS2.3 */
end_comment

begin_define
define|#
directive|define
name|ELF_MACHINE_ALT2
value|1998
end_define

begin_comment
comment|/* EAS2.2 */
end_comment

begin_define
define|#
directive|define
name|ELF_MAXPAGESIZE
value|0x10000
end_define

begin_comment
comment|/* 64KB */
end_comment

begin_define
define|#
directive|define
name|elf_backend_section_from_shdr
define|\
value|elfNN_ia64_section_from_shdr
end_define

begin_define
define|#
directive|define
name|elf_backend_section_flags
define|\
value|elfNN_ia64_section_flags
end_define

begin_define
define|#
directive|define
name|elf_backend_fake_sections
define|\
value|elfNN_ia64_fake_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_final_write_processing
define|\
value|elfNN_ia64_final_write_processing
end_define

begin_define
define|#
directive|define
name|elf_backend_add_symbol_hook
define|\
value|elfNN_ia64_add_symbol_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_additional_program_headers
define|\
value|elfNN_ia64_additional_program_headers
end_define

begin_define
define|#
directive|define
name|elf_backend_modify_segment_map
define|\
value|elfNN_ia64_modify_segment_map
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto
define|\
value|elfNN_ia64_info_to_howto
end_define

begin_define
define|#
directive|define
name|bfd_elfNN_bfd_reloc_type_lookup
define|\
value|elfNN_ia64_reloc_type_lookup
end_define

begin_define
define|#
directive|define
name|bfd_elfNN_bfd_is_local_label_name
define|\
value|elfNN_ia64_is_local_label_name
end_define

begin_define
define|#
directive|define
name|bfd_elfNN_bfd_relax_section
define|\
value|elfNN_ia64_relax_section
end_define

begin_comment
comment|/* Stuff for the BFD linker: */
end_comment

begin_define
define|#
directive|define
name|bfd_elfNN_bfd_link_hash_table_create
define|\
value|elfNN_ia64_hash_table_create
end_define

begin_define
define|#
directive|define
name|bfd_elfNN_bfd_link_hash_table_free
define|\
value|elfNN_ia64_hash_table_free
end_define

begin_define
define|#
directive|define
name|elf_backend_create_dynamic_sections
define|\
value|elfNN_ia64_create_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_check_relocs
define|\
value|elfNN_ia64_check_relocs
end_define

begin_define
define|#
directive|define
name|elf_backend_adjust_dynamic_symbol
define|\
value|elfNN_ia64_adjust_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_size_dynamic_sections
define|\
value|elfNN_ia64_size_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_relocate_section
define|\
value|elfNN_ia64_relocate_section
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_symbol
define|\
value|elfNN_ia64_finish_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_sections
define|\
value|elfNN_ia64_finish_dynamic_sections
end_define

begin_define
define|#
directive|define
name|bfd_elfNN_bfd_final_link
define|\
value|elfNN_ia64_final_link
end_define

begin_define
define|#
directive|define
name|bfd_elfNN_bfd_merge_private_bfd_data
define|\
value|elfNN_ia64_merge_private_bfd_data
end_define

begin_define
define|#
directive|define
name|bfd_elfNN_bfd_set_private_flags
define|\
value|elfNN_ia64_set_private_flags
end_define

begin_define
define|#
directive|define
name|bfd_elfNN_bfd_print_private_bfd_data
define|\
value|elfNN_ia64_print_private_bfd_data
end_define

begin_define
define|#
directive|define
name|elf_backend_plt_readonly
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_want_plt_sym
value|0
end_define

begin_define
define|#
directive|define
name|elf_backend_plt_alignment
value|5
end_define

begin_define
define|#
directive|define
name|elf_backend_got_header_size
value|0
end_define

begin_define
define|#
directive|define
name|elf_backend_want_got_plt
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_may_use_rel_p
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_may_use_rela_p
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_default_use_rela_p
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_want_dynbss
value|0
end_define

begin_define
define|#
directive|define
name|elf_backend_copy_indirect_symbol
value|elfNN_ia64_hash_copy_indirect
end_define

begin_define
define|#
directive|define
name|elf_backend_hide_symbol
value|elfNN_ia64_hash_hide_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_reloc_type_class
value|elfNN_ia64_reloc_type_class
end_define

begin_define
define|#
directive|define
name|elf_backend_rela_normal
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_special_sections
value|elfNN_ia64_special_sections
end_define

begin_include
include|#
directive|include
file|"elfNN-target.h"
end_include

begin_comment
comment|/* HPUX-specific vectors.  */
end_comment

begin_undef
undef|#
directive|undef
name|TARGET_LITTLE_SYM
end_undef

begin_undef
undef|#
directive|undef
name|TARGET_LITTLE_NAME
end_undef

begin_undef
undef|#
directive|undef
name|TARGET_BIG_SYM
end_undef

begin_define
define|#
directive|define
name|TARGET_BIG_SYM
value|bfd_elfNN_ia64_hpux_big_vec
end_define

begin_undef
undef|#
directive|undef
name|TARGET_BIG_NAME
end_undef

begin_define
define|#
directive|define
name|TARGET_BIG_NAME
value|"elfNN-ia64-hpux-big"
end_define

begin_comment
comment|/* These are HP-UX specific functions.  */
end_comment

begin_undef
undef|#
directive|undef
name|elf_backend_post_process_headers
end_undef

begin_define
define|#
directive|define
name|elf_backend_post_process_headers
value|elfNN_hpux_post_process_headers
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_section_from_bfd_section
end_undef

begin_define
define|#
directive|define
name|elf_backend_section_from_bfd_section
value|elfNN_hpux_backend_section_from_bfd_section
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_symbol_processing
end_undef

begin_define
define|#
directive|define
name|elf_backend_symbol_processing
value|elfNN_hpux_backend_symbol_processing
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_want_p_paddr_set_to_zero
end_undef

begin_define
define|#
directive|define
name|elf_backend_want_p_paddr_set_to_zero
value|1
end_define

begin_undef
undef|#
directive|undef
name|ELF_MAXPAGESIZE
end_undef

begin_define
define|#
directive|define
name|ELF_MAXPAGESIZE
value|0x1000
end_define

begin_comment
comment|/* 1K */
end_comment

begin_undef
undef|#
directive|undef
name|elfNN_bed
end_undef

begin_define
define|#
directive|define
name|elfNN_bed
value|elfNN_ia64_hpux_bed
end_define

begin_include
include|#
directive|include
file|"elfNN-target.h"
end_include

begin_undef
undef|#
directive|undef
name|elf_backend_want_p_paddr_set_to_zero
end_undef

end_unit

