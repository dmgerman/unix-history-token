begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* IA-64 support for 64-bit ELF    Copyright 1998, 1999, 2000, 2001 Free Software Foundation, Inc.    Contributed by David Mosberger-Tang<davidm@hpl.hp.com>  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"opcode/ia64.h"
end_include

begin_include
include|#
directive|include
file|"elf/ia64.h"
end_include

begin_comment
comment|/*  * THE RULES for all the stuff the linker creates --  *  * GOT		Entries created in response to LTOFF or LTOFF_FPTR  *		relocations.  Dynamic relocs created for dynamic  *		symbols in an application; REL relocs for locals  *		in a shared library.  *  * FPTR		The canonical function descriptor.  Created for local  *		symbols in applications.  Descriptors for dynamic symbols  *		and local symbols in shared libraries are created by  *		ld.so.  Thus there are no dynamic relocs against these  *		objects.  The FPTR relocs for such _are_ passed through  *		to the dynamic relocation tables.  *  * FULL_PLT	Created for a PCREL21B relocation against a dynamic symbol.  *		Requires the creation of a PLTOFF entry.  This does not  *		require any dynamic relocations.  *  * PLTOFF	Created by PLTOFF relocations.  For local symbols, this  *		is an alternate function descriptor, and in shared libraries  *		requires two REL relocations.  Note that this cannot be  *		transformed into an FPTR relocation, since it must be in  *		range of the GP.  For dynamic symbols, this is a function  *		descriptor for a MIN_PLT entry, and requires one IPLT reloc.  *  * MIN_PLT	Created by PLTOFF entries against dynamic symbols.  This  *		does not reqire dynamic relocations.  */
end_comment

begin_define
define|#
directive|define
name|USE_RELA
end_define

begin_comment
comment|/* we want RELA relocs, not REL */
end_comment

begin_define
define|#
directive|define
name|NELEMS
parameter_list|(
name|a
parameter_list|)
value|((int) (sizeof (a) / sizeof ((a)[0])))
end_define

begin_typedef
typedef|typedef
name|struct
name|bfd_hash_entry
modifier|*
argument_list|(
operator|*
name|new_hash_entry_func
argument_list|)
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|,
expr|struct
name|bfd_hash_table
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
typedef|;
end_typedef

begin_comment
comment|/* In dynamically (linker-) created sections, we generally need to keep track    of the place a symbol or expression got allocated to. This is done via hash    tables that store entries of the following type.  */
end_comment

begin_struct
struct|struct
name|elfNN_ia64_dyn_sym_info
block|{
comment|/* The addend for which this entry is relevant.  */
name|bfd_vma
name|addend
decl_stmt|;
comment|/* Next addend in the list.  */
name|struct
name|elfNN_ia64_dyn_sym_info
modifier|*
name|next
decl_stmt|;
name|bfd_vma
name|got_offset
decl_stmt|;
name|bfd_vma
name|fptr_offset
decl_stmt|;
name|bfd_vma
name|pltoff_offset
decl_stmt|;
name|bfd_vma
name|plt_offset
decl_stmt|;
name|bfd_vma
name|plt2_offset
decl_stmt|;
comment|/* The symbol table entry, if any, that this was derrived from.  */
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
comment|/* Used to count non-got, non-plt relocations for delayed sizing      of relocation sections.  */
struct|struct
name|elfNN_ia64_dyn_reloc_entry
block|{
name|struct
name|elfNN_ia64_dyn_reloc_entry
modifier|*
name|next
decl_stmt|;
name|asection
modifier|*
name|srel
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|count
decl_stmt|;
block|}
modifier|*
name|reloc_entries
struct|;
comment|/* True when the section contents have been updated.  */
name|unsigned
name|got_done
range|:
literal|1
decl_stmt|;
name|unsigned
name|fptr_done
range|:
literal|1
decl_stmt|;
name|unsigned
name|pltoff_done
range|:
literal|1
decl_stmt|;
comment|/* True for the different kinds of linker data we want created.  */
name|unsigned
name|want_got
range|:
literal|1
decl_stmt|;
name|unsigned
name|want_fptr
range|:
literal|1
decl_stmt|;
name|unsigned
name|want_ltoff_fptr
range|:
literal|1
decl_stmt|;
name|unsigned
name|want_plt
range|:
literal|1
decl_stmt|;
name|unsigned
name|want_plt2
range|:
literal|1
decl_stmt|;
name|unsigned
name|want_pltoff
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|elfNN_ia64_local_hash_entry
block|{
name|struct
name|bfd_hash_entry
name|root
decl_stmt|;
name|struct
name|elfNN_ia64_dyn_sym_info
modifier|*
name|info
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|elfNN_ia64_local_hash_table
block|{
name|struct
name|bfd_hash_table
name|root
decl_stmt|;
comment|/* No additional fields for now.  */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|elfNN_ia64_link_hash_entry
block|{
name|struct
name|elf_link_hash_entry
name|root
decl_stmt|;
name|struct
name|elfNN_ia64_dyn_sym_info
modifier|*
name|info
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|elfNN_ia64_link_hash_table
block|{
comment|/* The main hash table */
name|struct
name|elf_link_hash_table
name|root
decl_stmt|;
name|asection
modifier|*
name|got_sec
decl_stmt|;
comment|/* the linkage table section (or NULL) */
name|asection
modifier|*
name|rel_got_sec
decl_stmt|;
comment|/* dynamic relocation section for same */
name|asection
modifier|*
name|fptr_sec
decl_stmt|;
comment|/* function descriptor table (or NULL) */
name|asection
modifier|*
name|plt_sec
decl_stmt|;
comment|/* the primary plt section (or NULL) */
name|asection
modifier|*
name|pltoff_sec
decl_stmt|;
comment|/* private descriptors for plt (or NULL) */
name|asection
modifier|*
name|rel_pltoff_sec
decl_stmt|;
comment|/* dynamic relocation section for same */
name|bfd_size_type
name|minplt_entries
decl_stmt|;
comment|/* number of minplt entries */
name|struct
name|elfNN_ia64_local_hash_table
name|loc_hash_table
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|elfNN_ia64_hash_table
parameter_list|(
name|p
parameter_list|)
define|\
value|((struct elfNN_ia64_link_hash_table *) ((p)->hash))
end_define

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|elfNN_ia64_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|arelent
operator|*
name|reloc
operator|,
name|asymbol
operator|*
name|sym
operator|,
name|PTR
name|data
operator|,
name|asection
operator|*
name|input_section
operator|,
name|bfd
operator|*
name|output_bfd
operator|,
name|char
operator|*
operator|*
name|error_message
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
modifier|*
name|lookup_howto
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
name|rtype
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
modifier|*
name|elfNN_ia64_reloc_type_lookup
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|bfd_reloc_code_real_type
name|bfd_code
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|elfNN_ia64_info_to_howto
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|arelent
operator|*
name|bfd_reloc
operator|,
name|ElfNN_Internal_Rela
operator|*
name|elf_reloc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elfNN_ia64_relax_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|asection
operator|*
name|sec
operator|,
expr|struct
name|bfd_link_info
operator|*
name|link_info
operator|,
name|boolean
operator|*
name|again
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|is_unwind_section_name
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elfNN_ia64_section_from_shdr
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|ElfNN_Internal_Shdr
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elfNN_ia64_fake_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|ElfNN_Internal_Shdr
operator|*
name|hdr
operator|,
name|asection
operator|*
name|sec
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|elfNN_ia64_final_write_processing
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|boolean
name|linker
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elfNN_ia64_add_symbol_hook
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|,
specifier|const
name|Elf_Internal_Sym
operator|*
name|sym
operator|,
specifier|const
name|char
operator|*
operator|*
name|namep
operator|,
name|flagword
operator|*
name|flagsp
operator|,
name|asection
operator|*
operator|*
name|secp
operator|,
name|bfd_vma
operator|*
name|valp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|elfNN_ia64_additional_program_headers
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elfNN_ia64_is_local_label_name
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
specifier|const
name|char
operator|*
name|name
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elfNN_ia64_dynamic_symbol_p
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
name|h
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elfNN_ia64_local_hash_table_init
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elfNN_ia64_local_hash_table
operator|*
name|ht
operator|,
name|bfd
operator|*
name|abfd
operator|,
name|new_hash_entry_func
name|new
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|elfNN_ia64_new_loc_hash_entry
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
name|entry
operator|,
expr|struct
name|bfd_hash_table
operator|*
name|table
operator|,
specifier|const
name|char
operator|*
name|string
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|elfNN_ia64_new_elf_hash_entry
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
name|entry
operator|,
expr|struct
name|bfd_hash_table
operator|*
name|table
operator|,
specifier|const
name|char
operator|*
name|string
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bfd_link_hash_table
modifier|*
name|elfNN_ia64_hash_table_create
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|elfNN_ia64_local_hash_entry
modifier|*
name|elfNN_ia64_local_hash_lookup
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elfNN_ia64_local_hash_table
operator|*
name|table
operator|,
specifier|const
name|char
operator|*
name|string
operator|,
name|boolean
name|create
operator|,
name|boolean
name|copy
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|elfNN_ia64_dyn_sym_traverse
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elfNN_ia64_link_hash_table
operator|*
name|ia64_info
operator|,
name|boolean
argument_list|(
operator|*
name|func
argument_list|)
argument_list|(
expr|struct
name|elfNN_ia64_dyn_sym_info
operator|*
argument_list|,
name|PTR
argument_list|)
operator|,
name|PTR
name|info
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elfNN_ia64_create_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|elfNN_ia64_dyn_sym_info
modifier|*
name|get_dyn_sym_info
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elfNN_ia64_link_hash_table
operator|*
name|ia64_info
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
name|h
operator|,
name|bfd
operator|*
name|abfd
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
name|rel
operator|,
name|boolean
name|create
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asection
modifier|*
name|get_got
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|,
expr|struct
name|elfNN_ia64_link_hash_table
operator|*
name|ia64_info
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asection
modifier|*
name|get_fptr
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|,
expr|struct
name|elfNN_ia64_link_hash_table
operator|*
name|ia64_info
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asection
modifier|*
name|get_pltoff
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|,
expr|struct
name|elfNN_ia64_link_hash_table
operator|*
name|ia64_info
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asection
modifier|*
name|get_reloc_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
expr|struct
name|elfNN_ia64_link_hash_table
operator|*
name|ia64_info
operator|,
name|asection
operator|*
name|sec
operator|,
name|boolean
name|create
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|count_dyn_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
expr|struct
name|elfNN_ia64_dyn_sym_info
operator|*
name|dyn_i
operator|,
name|asection
operator|*
name|srel
operator|,
name|int
name|type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elfNN_ia64_check_relocs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|,
name|asection
operator|*
name|sec
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
name|relocs
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elfNN_ia64_adjust_dynamic_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
name|info
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
name|h
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|global_sym_index
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
name|h
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|allocate_fptr
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elfNN_ia64_dyn_sym_info
operator|*
name|dyn_i
operator|,
name|PTR
name|data
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|allocate_global_data_got
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elfNN_ia64_dyn_sym_info
operator|*
name|dyn_i
operator|,
name|PTR
name|data
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|allocate_global_fptr_got
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elfNN_ia64_dyn_sym_info
operator|*
name|dyn_i
operator|,
name|PTR
name|data
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|allocate_local_got
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elfNN_ia64_dyn_sym_info
operator|*
name|dyn_i
operator|,
name|PTR
name|data
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|allocate_pltoff_entries
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elfNN_ia64_dyn_sym_info
operator|*
name|dyn_i
operator|,
name|PTR
name|data
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|allocate_plt_entries
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elfNN_ia64_dyn_sym_info
operator|*
name|dyn_i
operator|,
name|PTR
name|data
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|allocate_plt2_entries
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elfNN_ia64_dyn_sym_info
operator|*
name|dyn_i
operator|,
name|PTR
name|data
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|allocate_dynrel_entries
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elfNN_ia64_dyn_sym_info
operator|*
name|dyn_i
operator|,
name|PTR
name|data
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elfNN_ia64_size_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|output_bfd
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|elfNN_ia64_install_value
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|bfd_byte
operator|*
name|hit_addr
operator|,
name|bfd_vma
name|val
operator|,
name|unsigned
name|int
name|r_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|elfNN_ia64_install_dyn_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|,
name|asection
operator|*
name|sec
operator|,
name|asection
operator|*
name|srel
operator|,
name|bfd_vma
name|offset
operator|,
name|unsigned
name|int
name|type
operator|,
name|long
name|dynindx
operator|,
name|bfd_vma
name|addend
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|set_got_entry
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|,
expr|struct
name|elfNN_ia64_dyn_sym_info
operator|*
name|dyn_i
operator|,
name|long
name|dynindx
operator|,
name|bfd_vma
name|addend
operator|,
name|bfd_vma
name|value
operator|,
name|unsigned
name|int
name|dyn_r_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|set_fptr_entry
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|,
expr|struct
name|elfNN_ia64_dyn_sym_info
operator|*
name|dyn_i
operator|,
name|bfd_vma
name|value
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|set_pltoff_entry
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|,
expr|struct
name|elfNN_ia64_dyn_sym_info
operator|*
name|dyn_i
operator|,
name|bfd_vma
name|value
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elfNN_ia64_final_link
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elfNN_ia64_relocate_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|output_bfd
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|,
name|bfd
operator|*
name|input_bfd
operator|,
name|asection
operator|*
name|input_section
operator|,
name|bfd_byte
operator|*
name|contents
operator|,
name|Elf_Internal_Rela
operator|*
name|relocs
operator|,
name|Elf_Internal_Sym
operator|*
name|local_syms
operator|,
name|asection
operator|*
operator|*
name|local_sections
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elfNN_ia64_finish_dynamic_symbol
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|output_bfd
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
name|h
operator|,
name|Elf_Internal_Sym
operator|*
name|sym
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elfNN_ia64_finish_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elfNN_ia64_set_private_flags
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|flagword
name|flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elfNN_ia64_copy_private_bfd_data
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|ibfd
operator|,
name|bfd
operator|*
name|obfd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elfNN_ia64_merge_private_bfd_data
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|ibfd
operator|,
name|bfd
operator|*
name|obfd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elfNN_ia64_print_private_bfd_data
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|PTR
name|ptr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* ia64-specific relocation */
end_comment

begin_comment
comment|/* Perform a relocation.  Not much to do here as all the hard work is    done in elfNN_ia64_final_link_relocate.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|elfNN_ia64_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc
parameter_list|,
name|sym
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|arelent
modifier|*
name|reloc
decl_stmt|;
name|asymbol
modifier|*
name|sym
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|PTR
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
block|{
if|if
condition|(
name|output_bfd
condition|)
block|{
name|reloc
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
operator|*
name|error_message
operator|=
literal|"Unsupported call to elfNN_ia64_reloc"
expr_stmt|;
return|return
name|bfd_reloc_notsupported
return|;
block|}
end_function

begin_define
define|#
directive|define
name|IA64_HOWTO
parameter_list|(
name|TYPE
parameter_list|,
name|NAME
parameter_list|,
name|SIZE
parameter_list|,
name|PCREL
parameter_list|,
name|IN
parameter_list|)
define|\
value|HOWTO (TYPE, 0, SIZE, 0, PCREL, 0, complain_overflow_signed,	\ 	 elfNN_ia64_reloc, NAME, false, 0, 0, IN)
end_define

begin_comment
comment|/* This table has to be sorted according to increasing number of the    TYPE field.  */
end_comment

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|ia64_howto_table
index|[]
init|=
block|{
name|IA64_HOWTO
argument_list|(
name|R_IA64_NONE
argument_list|,
literal|"NONE"
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_IMM14
argument_list|,
literal|"IMM14"
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_IMM22
argument_list|,
literal|"IMM22"
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_IMM64
argument_list|,
literal|"IMM64"
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_DIR32MSB
argument_list|,
literal|"DIR32MSB"
argument_list|,
literal|2
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_DIR32LSB
argument_list|,
literal|"DIR32LSB"
argument_list|,
literal|2
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_DIR64MSB
argument_list|,
literal|"DIR64MSB"
argument_list|,
literal|4
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_DIR64LSB
argument_list|,
literal|"DIR64LSB"
argument_list|,
literal|4
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_GPREL22
argument_list|,
literal|"GPREL22"
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_GPREL64I
argument_list|,
literal|"GPREL64I"
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_GPREL32MSB
argument_list|,
literal|"GPREL32MSB"
argument_list|,
literal|2
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_GPREL32LSB
argument_list|,
literal|"GPREL32LSB"
argument_list|,
literal|2
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_GPREL64MSB
argument_list|,
literal|"GPREL64MSB"
argument_list|,
literal|4
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_GPREL64LSB
argument_list|,
literal|"GPREL64LSB"
argument_list|,
literal|4
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_LTOFF22
argument_list|,
literal|"LTOFF22"
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_LTOFF64I
argument_list|,
literal|"LTOFF64I"
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_PLTOFF22
argument_list|,
literal|"PLTOFF22"
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_PLTOFF64I
argument_list|,
literal|"PLTOFF64I"
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_PLTOFF64MSB
argument_list|,
literal|"PLTOFF64MSB"
argument_list|,
literal|4
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_PLTOFF64LSB
argument_list|,
literal|"PLTOFF64LSB"
argument_list|,
literal|4
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_FPTR64I
argument_list|,
literal|"FPTR64I"
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_FPTR32MSB
argument_list|,
literal|"FPTR32MSB"
argument_list|,
literal|2
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_FPTR32LSB
argument_list|,
literal|"FPTR32LSB"
argument_list|,
literal|2
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_FPTR64MSB
argument_list|,
literal|"FPTR64MSB"
argument_list|,
literal|4
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_FPTR64LSB
argument_list|,
literal|"FPTR64LSB"
argument_list|,
literal|4
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_PCREL60B
argument_list|,
literal|"PCREL60B"
argument_list|,
literal|0
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_PCREL21B
argument_list|,
literal|"PCREL21B"
argument_list|,
literal|0
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_PCREL21M
argument_list|,
literal|"PCREL21M"
argument_list|,
literal|0
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_PCREL21F
argument_list|,
literal|"PCREL21F"
argument_list|,
literal|0
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_PCREL32MSB
argument_list|,
literal|"PCREL32MSB"
argument_list|,
literal|2
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_PCREL32LSB
argument_list|,
literal|"PCREL32LSB"
argument_list|,
literal|2
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_PCREL64MSB
argument_list|,
literal|"PCREL64MSB"
argument_list|,
literal|4
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_PCREL64LSB
argument_list|,
literal|"PCREL64LSB"
argument_list|,
literal|4
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_LTOFF_FPTR22
argument_list|,
literal|"LTOFF_FPTR22"
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_LTOFF_FPTR64I
argument_list|,
literal|"LTOFF_FPTR64I"
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_LTOFF_FPTR64MSB
argument_list|,
literal|"LTOFF_FPTR64MSB"
argument_list|,
literal|4
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_LTOFF_FPTR64LSB
argument_list|,
literal|"LTOFF_FPTR64LSB"
argument_list|,
literal|4
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_SEGREL32MSB
argument_list|,
literal|"SEGREL32MSB"
argument_list|,
literal|2
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_SEGREL32LSB
argument_list|,
literal|"SEGREL32LSB"
argument_list|,
literal|2
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_SEGREL64MSB
argument_list|,
literal|"SEGREL64MSB"
argument_list|,
literal|4
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_SEGREL64LSB
argument_list|,
literal|"SEGREL64LSB"
argument_list|,
literal|4
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_SECREL32MSB
argument_list|,
literal|"SECREL32MSB"
argument_list|,
literal|2
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_SECREL32LSB
argument_list|,
literal|"SECREL32LSB"
argument_list|,
literal|2
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_SECREL64MSB
argument_list|,
literal|"SECREL64MSB"
argument_list|,
literal|4
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_SECREL64LSB
argument_list|,
literal|"SECREL64LSB"
argument_list|,
literal|4
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_REL32MSB
argument_list|,
literal|"REL32MSB"
argument_list|,
literal|2
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_REL32LSB
argument_list|,
literal|"REL32LSB"
argument_list|,
literal|2
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_REL64MSB
argument_list|,
literal|"REL64MSB"
argument_list|,
literal|4
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_REL64LSB
argument_list|,
literal|"REL64LSB"
argument_list|,
literal|4
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_LTV32MSB
argument_list|,
literal|"LTV32MSB"
argument_list|,
literal|2
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_LTV32LSB
argument_list|,
literal|"LTV32LSB"
argument_list|,
literal|2
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_LTV64MSB
argument_list|,
literal|"LTV64MSB"
argument_list|,
literal|4
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_LTV64LSB
argument_list|,
literal|"LTV64LSB"
argument_list|,
literal|4
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_PCREL21BI
argument_list|,
literal|"PCREL21BI"
argument_list|,
literal|0
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_PCREL22
argument_list|,
literal|"PCREL22"
argument_list|,
literal|0
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_PCREL64I
argument_list|,
literal|"PCREL64I"
argument_list|,
literal|0
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_IPLTMSB
argument_list|,
literal|"IPLTMSB"
argument_list|,
literal|4
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_IPLTLSB
argument_list|,
literal|"IPLTLSB"
argument_list|,
literal|4
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_COPY
argument_list|,
literal|"COPY"
argument_list|,
literal|4
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_LTOFF22X
argument_list|,
literal|"LTOFF22X"
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_LDXMOV
argument_list|,
literal|"LDXMOV"
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_TPREL22
argument_list|,
literal|"TPREL22"
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_TPREL64MSB
argument_list|,
literal|"TPREL64MSB"
argument_list|,
literal|8
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_TPREL64LSB
argument_list|,
literal|"TPREL64LSB"
argument_list|,
literal|8
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
block|,
name|IA64_HOWTO
argument_list|(
name|R_IA64_LTOFF_TP22
argument_list|,
literal|"LTOFF_TP22"
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
block|,   }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|elf_code_to_howto_index
index|[
name|R_IA64_MAX_RELOC_CODE
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Given a BFD reloc type, return the matching HOWTO structure.  */
end_comment

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|lookup_howto
parameter_list|(
name|rtype
parameter_list|)
name|unsigned
name|int
name|rtype
decl_stmt|;
block|{
specifier|static
name|int
name|inited
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|inited
condition|)
block|{
name|inited
operator|=
literal|1
expr_stmt|;
name|memset
argument_list|(
name|elf_code_to_howto_index
argument_list|,
literal|0xff
argument_list|,
sizeof|sizeof
argument_list|(
name|elf_code_to_howto_index
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NELEMS
argument_list|(
name|ia64_howto_table
argument_list|)
condition|;
operator|++
name|i
control|)
name|elf_code_to_howto_index
index|[
name|ia64_howto_table
index|[
name|i
index|]
operator|.
name|type
index|]
operator|=
name|i
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
name|rtype
operator|<=
name|R_IA64_MAX_RELOC_CODE
argument_list|)
expr_stmt|;
name|i
operator|=
name|elf_code_to_howto_index
index|[
name|rtype
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|NELEMS
argument_list|(
name|ia64_howto_table
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|ia64_howto_table
operator|+
name|i
return|;
block|}
end_function

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|elfNN_ia64_reloc_type_lookup
parameter_list|(
name|abfd
parameter_list|,
name|bfd_code
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd_reloc_code_real_type
name|bfd_code
decl_stmt|;
block|{
name|unsigned
name|int
name|rtype
decl_stmt|;
switch|switch
condition|(
name|bfd_code
condition|)
block|{
case|case
name|BFD_RELOC_NONE
case|:
name|rtype
operator|=
name|R_IA64_NONE
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_IMM14
case|:
name|rtype
operator|=
name|R_IA64_IMM14
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_IMM22
case|:
name|rtype
operator|=
name|R_IA64_IMM22
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_IMM64
case|:
name|rtype
operator|=
name|R_IA64_IMM64
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR32MSB
case|:
name|rtype
operator|=
name|R_IA64_DIR32MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR32LSB
case|:
name|rtype
operator|=
name|R_IA64_DIR32LSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR64MSB
case|:
name|rtype
operator|=
name|R_IA64_DIR64MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_DIR64LSB
case|:
name|rtype
operator|=
name|R_IA64_DIR64LSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_GPREL22
case|:
name|rtype
operator|=
name|R_IA64_GPREL22
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_GPREL64I
case|:
name|rtype
operator|=
name|R_IA64_GPREL64I
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_GPREL32MSB
case|:
name|rtype
operator|=
name|R_IA64_GPREL32MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_GPREL32LSB
case|:
name|rtype
operator|=
name|R_IA64_GPREL32LSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_GPREL64MSB
case|:
name|rtype
operator|=
name|R_IA64_GPREL64MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_GPREL64LSB
case|:
name|rtype
operator|=
name|R_IA64_GPREL64LSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_LTOFF22
case|:
name|rtype
operator|=
name|R_IA64_LTOFF22
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_LTOFF64I
case|:
name|rtype
operator|=
name|R_IA64_LTOFF64I
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_PLTOFF22
case|:
name|rtype
operator|=
name|R_IA64_PLTOFF22
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_PLTOFF64I
case|:
name|rtype
operator|=
name|R_IA64_PLTOFF64I
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_PLTOFF64MSB
case|:
name|rtype
operator|=
name|R_IA64_PLTOFF64MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_PLTOFF64LSB
case|:
name|rtype
operator|=
name|R_IA64_PLTOFF64LSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_FPTR64I
case|:
name|rtype
operator|=
name|R_IA64_FPTR64I
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_FPTR32MSB
case|:
name|rtype
operator|=
name|R_IA64_FPTR32MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_FPTR32LSB
case|:
name|rtype
operator|=
name|R_IA64_FPTR32LSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_FPTR64MSB
case|:
name|rtype
operator|=
name|R_IA64_FPTR64MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_FPTR64LSB
case|:
name|rtype
operator|=
name|R_IA64_FPTR64LSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_PCREL21B
case|:
name|rtype
operator|=
name|R_IA64_PCREL21B
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_PCREL21BI
case|:
name|rtype
operator|=
name|R_IA64_PCREL21BI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_PCREL21M
case|:
name|rtype
operator|=
name|R_IA64_PCREL21M
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_PCREL21F
case|:
name|rtype
operator|=
name|R_IA64_PCREL21F
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_PCREL22
case|:
name|rtype
operator|=
name|R_IA64_PCREL22
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_PCREL60B
case|:
name|rtype
operator|=
name|R_IA64_PCREL60B
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_PCREL64I
case|:
name|rtype
operator|=
name|R_IA64_PCREL64I
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_PCREL32MSB
case|:
name|rtype
operator|=
name|R_IA64_PCREL32MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_PCREL32LSB
case|:
name|rtype
operator|=
name|R_IA64_PCREL32LSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_PCREL64MSB
case|:
name|rtype
operator|=
name|R_IA64_PCREL64MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_PCREL64LSB
case|:
name|rtype
operator|=
name|R_IA64_PCREL64LSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_LTOFF_FPTR22
case|:
name|rtype
operator|=
name|R_IA64_LTOFF_FPTR22
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_LTOFF_FPTR64I
case|:
name|rtype
operator|=
name|R_IA64_LTOFF_FPTR64I
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_LTOFF_FPTR64MSB
case|:
name|rtype
operator|=
name|R_IA64_LTOFF_FPTR64MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_LTOFF_FPTR64LSB
case|:
name|rtype
operator|=
name|R_IA64_LTOFF_FPTR64LSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_SEGREL32MSB
case|:
name|rtype
operator|=
name|R_IA64_SEGREL32MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_SEGREL32LSB
case|:
name|rtype
operator|=
name|R_IA64_SEGREL32LSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_SEGREL64MSB
case|:
name|rtype
operator|=
name|R_IA64_SEGREL64MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_SEGREL64LSB
case|:
name|rtype
operator|=
name|R_IA64_SEGREL64LSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_SECREL32MSB
case|:
name|rtype
operator|=
name|R_IA64_SECREL32MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_SECREL32LSB
case|:
name|rtype
operator|=
name|R_IA64_SECREL32LSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_SECREL64MSB
case|:
name|rtype
operator|=
name|R_IA64_SECREL64MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_SECREL64LSB
case|:
name|rtype
operator|=
name|R_IA64_SECREL64LSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_REL32MSB
case|:
name|rtype
operator|=
name|R_IA64_REL32MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_REL32LSB
case|:
name|rtype
operator|=
name|R_IA64_REL32LSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_REL64MSB
case|:
name|rtype
operator|=
name|R_IA64_REL64MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_REL64LSB
case|:
name|rtype
operator|=
name|R_IA64_REL64LSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_LTV32MSB
case|:
name|rtype
operator|=
name|R_IA64_LTV32MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_LTV32LSB
case|:
name|rtype
operator|=
name|R_IA64_LTV32LSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_LTV64MSB
case|:
name|rtype
operator|=
name|R_IA64_LTV64MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_LTV64LSB
case|:
name|rtype
operator|=
name|R_IA64_LTV64LSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_IPLTMSB
case|:
name|rtype
operator|=
name|R_IA64_IPLTMSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_IPLTLSB
case|:
name|rtype
operator|=
name|R_IA64_IPLTLSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_COPY
case|:
name|rtype
operator|=
name|R_IA64_COPY
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_LTOFF22X
case|:
name|rtype
operator|=
name|R_IA64_LTOFF22X
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_LDXMOV
case|:
name|rtype
operator|=
name|R_IA64_LDXMOV
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_TPREL22
case|:
name|rtype
operator|=
name|R_IA64_TPREL22
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_TPREL64MSB
case|:
name|rtype
operator|=
name|R_IA64_TPREL64MSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_TPREL64LSB
case|:
name|rtype
operator|=
name|R_IA64_TPREL64LSB
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_IA64_LTOFF_TP22
case|:
name|rtype
operator|=
name|R_IA64_LTOFF_TP22
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
return|return
name|lookup_howto
argument_list|(
name|rtype
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given a ELF reloc, return the matching HOWTO structure.  */
end_comment

begin_function
specifier|static
name|void
name|elfNN_ia64_info_to_howto
parameter_list|(
name|abfd
parameter_list|,
name|bfd_reloc
parameter_list|,
name|elf_reloc
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|arelent
modifier|*
name|bfd_reloc
decl_stmt|;
name|ElfNN_Internal_Rela
modifier|*
name|elf_reloc
decl_stmt|;
block|{
name|bfd_reloc
operator|->
name|howto
operator|=
name|lookup_howto
argument_list|(
name|ELFNN_R_TYPE
argument_list|(
name|elf_reloc
operator|->
name|r_info
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|PLT_HEADER_SIZE
value|(3 * 16)
end_define

begin_define
define|#
directive|define
name|PLT_MIN_ENTRY_SIZE
value|(1 * 16)
end_define

begin_define
define|#
directive|define
name|PLT_FULL_ENTRY_SIZE
value|(2 * 16)
end_define

begin_define
define|#
directive|define
name|PLT_RESERVED_WORDS
value|3
end_define

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
name|plt_header
index|[
name|PLT_HEADER_SIZE
index|]
init|=
block|{
literal|0x0b
block|,
literal|0x10
block|,
literal|0x00
block|,
literal|0x1c
block|,
literal|0x00
block|,
literal|0x21
block|,
comment|/*   [MMI]       mov r2=r14;;       */
literal|0xe0
block|,
literal|0x00
block|,
literal|0x08
block|,
literal|0x00
block|,
literal|0x48
block|,
literal|0x00
block|,
comment|/*               addl r14=0,r2      */
literal|0x00
block|,
literal|0x00
block|,
literal|0x04
block|,
literal|0x00
block|,
comment|/*               nop.i 0x0;;        */
literal|0x0b
block|,
literal|0x80
block|,
literal|0x20
block|,
literal|0x1c
block|,
literal|0x18
block|,
literal|0x14
block|,
comment|/*   [MMI]       ld8 r16=[r14],8;;  */
literal|0x10
block|,
literal|0x41
block|,
literal|0x38
block|,
literal|0x30
block|,
literal|0x28
block|,
literal|0x00
block|,
comment|/*               ld8 r17=[r14],8    */
literal|0x00
block|,
literal|0x00
block|,
literal|0x04
block|,
literal|0x00
block|,
comment|/*               nop.i 0x0;;        */
literal|0x11
block|,
literal|0x08
block|,
literal|0x00
block|,
literal|0x1c
block|,
literal|0x18
block|,
literal|0x10
block|,
comment|/*   [MIB]       ld8 r1=[r14]       */
literal|0x60
block|,
literal|0x88
block|,
literal|0x04
block|,
literal|0x80
block|,
literal|0x03
block|,
literal|0x00
block|,
comment|/*               mov b6=r17         */
literal|0x60
block|,
literal|0x00
block|,
literal|0x80
block|,
literal|0x00
comment|/*               br.few b6;;        */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
name|plt_min_entry
index|[
name|PLT_MIN_ENTRY_SIZE
index|]
init|=
block|{
literal|0x11
block|,
literal|0x78
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x24
block|,
comment|/*   [MIB]       mov r15=0          */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x02
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*               nop.i 0x0          */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x40
comment|/*               br.few 0<PLT0>;;  */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
name|plt_full_entry
index|[
name|PLT_FULL_ENTRY_SIZE
index|]
init|=
block|{
literal|0x0b
block|,
literal|0x78
block|,
literal|0x00
block|,
literal|0x02
block|,
literal|0x00
block|,
literal|0x24
block|,
comment|/*   [MMI]       addl r15=0,r1;;    */
literal|0x00
block|,
literal|0x41
block|,
literal|0x3c
block|,
literal|0x30
block|,
literal|0x28
block|,
literal|0xc0
block|,
comment|/*               ld8 r16=[r15],8    */
literal|0x01
block|,
literal|0x08
block|,
literal|0x00
block|,
literal|0x84
block|,
comment|/*               mov r14=r1;;       */
literal|0x11
block|,
literal|0x08
block|,
literal|0x00
block|,
literal|0x1e
block|,
literal|0x18
block|,
literal|0x10
block|,
comment|/*   [MIB]       ld8 r1=[r15]       */
literal|0x60
block|,
literal|0x80
block|,
literal|0x04
block|,
literal|0x80
block|,
literal|0x03
block|,
literal|0x00
block|,
comment|/*               mov b6=r16         */
literal|0x60
block|,
literal|0x00
block|,
literal|0x80
block|,
literal|0x00
comment|/*               br.few b6;;        */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ELF_DYNAMIC_INTERPRETER
value|"/usr/lib/ld.so.1"
end_define

begin_comment
comment|/* Select out of range branch fixup type.  Note that Itanium does    not support brl, and so it gets emulated by the kernel.  */
end_comment

begin_undef
undef|#
directive|undef
name|USE_BRL
end_undef

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
name|oor_brl
index|[
literal|16
index|]
init|=
block|{
literal|0x05
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x00
block|,
comment|/*  [MLX]        nop.m 0            */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*               brl.sptk.few tgt;; */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0xc0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
name|oor_ip
index|[
literal|48
index|]
init|=
block|{
literal|0x04
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x00
block|,
comment|/*  [MLX]        nop.m 0            */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0xe0
block|,
comment|/*               movl r15=0         */
literal|0x01
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x60
block|,
literal|0x03
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x00
block|,
comment|/*  [MII]        nop.m 0            */
literal|0x00
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0x60
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/*               mov r16=ip;;       */
literal|0xf2
block|,
literal|0x80
block|,
literal|0x00
block|,
literal|0x80
block|,
comment|/*               add r16=r15,r16;;  */
literal|0x11
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x00
block|,
comment|/*  [MIB]        nop.m 0            */
literal|0x60
block|,
literal|0x80
block|,
literal|0x04
block|,
literal|0x80
block|,
literal|0x03
block|,
literal|0x00
block|,
comment|/*               mov b6=r16         */
literal|0x60
block|,
literal|0x00
block|,
literal|0x80
block|,
literal|0x00
comment|/*               br b6;;            */
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* These functions do relaxation for IA-64 ELF.     This is primarily to support branches to targets out of range;    relaxation of R_IA64_LTOFF22X and R_IA64_LDXMOV not yet supported.  */
end_comment

begin_function
specifier|static
name|boolean
name|elfNN_ia64_relax_section
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|link_info
parameter_list|,
name|again
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|link_info
decl_stmt|;
name|boolean
modifier|*
name|again
decl_stmt|;
block|{
struct|struct
name|one_fixup
block|{
name|struct
name|one_fixup
modifier|*
name|next
decl_stmt|;
name|asection
modifier|*
name|tsec
decl_stmt|;
name|bfd_vma
name|toff
decl_stmt|;
name|bfd_vma
name|trampoff
decl_stmt|;
block|}
struct|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|free_relocs
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|,
modifier|*
name|irelend
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|bfd_byte
modifier|*
name|free_contents
init|=
name|NULL
decl_stmt|;
name|ElfNN_External_Sym
modifier|*
name|extsyms
decl_stmt|;
name|ElfNN_External_Sym
modifier|*
name|free_extsyms
init|=
name|NULL
decl_stmt|;
name|struct
name|elfNN_ia64_link_hash_table
modifier|*
name|ia64_info
decl_stmt|;
name|struct
name|one_fixup
modifier|*
name|fixups
init|=
name|NULL
decl_stmt|;
name|boolean
name|changed_contents
init|=
name|false
decl_stmt|;
name|boolean
name|changed_relocs
init|=
name|false
decl_stmt|;
comment|/* Assume we're not going to change any sizes, and we'll only need      one pass.  */
operator|*
name|again
operator|=
name|false
expr_stmt|;
comment|/* Nothing to do if there are no relocations.  */
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
operator|||
name|sec
operator|->
name|reloc_count
operator|==
literal|0
condition|)
return|return
name|true
return|;
comment|/* If this is the first time we have been called for this section,      initialize the cooked size.  */
if|if
condition|(
name|sec
operator|->
name|_cooked_size
operator|==
literal|0
condition|)
name|sec
operator|->
name|_cooked_size
operator|=
name|sec
operator|->
name|_raw_size
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
comment|/* Load the relocations for this section.  */
name|internal_relocs
operator|=
operator|(
name|_bfd_elfNN_link_read_relocs
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
operator|(
name|PTR
operator|)
name|NULL
argument_list|,
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
name|NULL
argument_list|,
name|link_info
operator|->
name|keep_memory
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|link_info
operator|->
name|keep_memory
condition|)
name|free_relocs
operator|=
name|internal_relocs
expr_stmt|;
name|ia64_info
operator|=
name|elfNN_ia64_hash_table
argument_list|(
name|link_info
argument_list|)
expr_stmt|;
name|irelend
operator|=
name|internal_relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|irel
operator|=
name|internal_relocs
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
control|)
if|if
condition|(
name|ELFNN_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_IA64_PCREL21B
condition|)
break|break;
comment|/* No branch-type relocations.  */
if|if
condition|(
name|irel
operator|==
name|irelend
condition|)
block|{
if|if
condition|(
name|free_relocs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|free_relocs
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* Get the section contents.  */
if|if
condition|(
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|NULL
condition|)
name|contents
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
expr_stmt|;
else|else
block|{
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|sec
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|free_contents
operator|=
name|contents
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|contents
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|sec
operator|->
name|_raw_size
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
comment|/* Read this BFD's symbols.  */
if|if
condition|(
name|symtab_hdr
operator|->
name|contents
operator|!=
name|NULL
condition|)
name|extsyms
operator|=
operator|(
name|ElfNN_External_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
else|else
block|{
name|extsyms
operator|=
operator|(
name|ElfNN_External_Sym
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|symtab_hdr
operator|->
name|sh_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|extsyms
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|free_extsyms
operator|=
name|extsyms
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|bfd_read
argument_list|(
name|extsyms
argument_list|,
literal|1
argument_list|,
name|symtab_hdr
operator|->
name|sh_size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|symtab_hdr
operator|->
name|sh_size
operator|)
condition|)
goto|goto
name|error_return
goto|;
block|}
for|for
control|(
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
control|)
block|{
name|bfd_vma
name|symaddr
decl_stmt|,
name|reladdr
decl_stmt|,
name|trampoff
decl_stmt|,
name|toff
decl_stmt|,
name|roff
decl_stmt|;
name|Elf_Internal_Sym
name|isym
decl_stmt|;
name|asection
modifier|*
name|tsec
decl_stmt|;
name|struct
name|one_fixup
modifier|*
name|f
decl_stmt|;
if|if
condition|(
name|ELFNN_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|R_IA64_PCREL21B
condition|)
continue|continue;
comment|/* Get the value of the symbol referred to by the reloc.  */
if|if
condition|(
name|ELFNN_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
comment|/* A local symbol.  */
name|bfd_elfNN_swap_symbol_in
argument_list|(
name|abfd
argument_list|,
name|extsyms
operator|+
name|ELFNN_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
operator|&
name|isym
argument_list|)
expr_stmt|;
if|if
condition|(
name|isym
operator|.
name|st_shndx
operator|==
name|SHN_UNDEF
condition|)
continue|continue;
comment|/* We can't do anthing with undefined symbols.  */
elseif|else
if|if
condition|(
name|isym
operator|.
name|st_shndx
operator|==
name|SHN_ABS
condition|)
name|tsec
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|isym
operator|.
name|st_shndx
operator|==
name|SHN_COMMON
condition|)
name|tsec
operator|=
name|bfd_com_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|isym
operator|.
name|st_shndx
operator|>
literal|0
operator|&&
name|isym
operator|.
name|st_shndx
operator|<
name|SHN_LORESERVE
condition|)
name|tsec
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|abfd
argument_list|,
name|isym
operator|.
name|st_shndx
argument_list|)
expr_stmt|;
else|else
continue|continue;
comment|/* who knows.  */
name|toff
operator|=
name|isym
operator|.
name|st_value
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|long
name|indx
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|elfNN_ia64_dyn_sym_info
modifier|*
name|dyn_i
decl_stmt|;
name|indx
operator|=
name|ELFNN_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|-
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|h
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
index|[
name|indx
index|]
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|h
operator|!=
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|dyn_i
operator|=
name|get_dyn_sym_info
argument_list|(
name|ia64_info
argument_list|,
name|h
argument_list|,
name|abfd
argument_list|,
name|irel
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* For branches to dynamic symbols, we're interested instead 	     in a branch to the PLT entry.  */
if|if
condition|(
name|dyn_i
operator|&&
name|dyn_i
operator|->
name|want_plt2
condition|)
block|{
name|tsec
operator|=
name|ia64_info
operator|->
name|plt_sec
expr_stmt|;
name|toff
operator|=
name|dyn_i
operator|->
name|plt2_offset
expr_stmt|;
block|}
else|else
block|{
comment|/* We can't do anthing with undefined symbols.  */
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
continue|continue;
name|tsec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|toff
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
block|}
block|}
name|symaddr
operator|=
operator|(
name|tsec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|tsec
operator|->
name|output_offset
operator|+
name|toff
operator|+
name|irel
operator|->
name|r_addend
operator|)
expr_stmt|;
name|roff
operator|=
name|irel
operator|->
name|r_offset
expr_stmt|;
name|reladdr
operator|=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|roff
operator|)
operator|&
operator|-
literal|4
expr_stmt|;
comment|/* If the branch is in range, no need to do anything.  */
if|if
condition|(
call|(
name|bfd_signed_vma
call|)
argument_list|(
name|symaddr
operator|-
name|reladdr
argument_list|)
operator|>=
operator|-
literal|0x1000000
operator|&&
call|(
name|bfd_signed_vma
call|)
argument_list|(
name|symaddr
operator|-
name|reladdr
argument_list|)
operator|<=
literal|0x0FFFFF0
condition|)
continue|continue;
comment|/* If the branch and target are in the same section, you've 	 got one honking big section and we can't help you.  You'll 	 get an error message later.  */
if|if
condition|(
name|tsec
operator|==
name|sec
condition|)
continue|continue;
comment|/* Look for an existing fixup to this address.  */
for|for
control|(
name|f
operator|=
name|fixups
init|;
name|f
condition|;
name|f
operator|=
name|f
operator|->
name|next
control|)
if|if
condition|(
name|f
operator|->
name|tsec
operator|==
name|tsec
operator|&&
name|f
operator|->
name|toff
operator|==
name|toff
condition|)
break|break;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
comment|/* Two alternatives: If it's a branch to a PLT entry, we can 	     make a copy of the FULL_PLT entry.  Otherwise, we'll have 	     to use a `brl' insn to get where we're going.  */
name|int
name|size
decl_stmt|;
if|if
condition|(
name|tsec
operator|==
name|ia64_info
operator|->
name|plt_sec
condition|)
name|size
operator|=
sizeof|sizeof
argument_list|(
name|plt_full_entry
argument_list|)
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|USE_BRL
name|size
operator|=
sizeof|sizeof
argument_list|(
name|oor_brl
argument_list|)
expr_stmt|;
else|#
directive|else
name|size
operator|=
sizeof|sizeof
argument_list|(
name|oor_ip
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Resize the current section to make room for the new branch.  */
name|trampoff
operator|=
operator|(
name|sec
operator|->
name|_cooked_size
operator|+
literal|15
operator|)
operator|&
operator|-
literal|16
expr_stmt|;
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_realloc
argument_list|(
name|contents
argument_list|,
name|trampoff
operator|+
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|sec
operator|->
name|_cooked_size
operator|=
name|trampoff
operator|+
name|size
expr_stmt|;
if|if
condition|(
name|tsec
operator|==
name|ia64_info
operator|->
name|plt_sec
condition|)
block|{
name|memcpy
argument_list|(
name|contents
operator|+
name|trampoff
argument_list|,
name|plt_full_entry
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* Hijack the old relocation for use as the PLTOFF reloc.  */
name|irel
operator|->
name|r_info
operator|=
name|ELFNN_R_INFO
argument_list|(
name|ELFNN_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
name|R_IA64_PLTOFF22
argument_list|)
expr_stmt|;
name|irel
operator|->
name|r_offset
operator|=
name|trampoff
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|USE_BRL
name|memcpy
argument_list|(
name|contents
operator|+
name|trampoff
argument_list|,
name|oor_brl
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|irel
operator|->
name|r_info
operator|=
name|ELFNN_R_INFO
argument_list|(
name|ELFNN_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
name|R_IA64_PCREL60B
argument_list|)
expr_stmt|;
name|irel
operator|->
name|r_offset
operator|=
name|trampoff
operator|+
literal|2
expr_stmt|;
else|#
directive|else
name|memcpy
argument_list|(
name|contents
operator|+
name|trampoff
argument_list|,
name|oor_ip
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|irel
operator|->
name|r_info
operator|=
name|ELFNN_R_INFO
argument_list|(
name|ELFNN_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
name|R_IA64_PCREL64I
argument_list|)
expr_stmt|;
name|irel
operator|->
name|r_addend
operator|-=
literal|16
expr_stmt|;
name|irel
operator|->
name|r_offset
operator|=
name|trampoff
operator|+
literal|2
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Record the fixup so we don't do it again this section.  */
name|f
operator|=
operator|(
expr|struct
name|one_fixup
operator|*
operator|)
name|bfd_malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|f
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|->
name|next
operator|=
name|fixups
expr_stmt|;
name|f
operator|->
name|tsec
operator|=
name|tsec
expr_stmt|;
name|f
operator|->
name|toff
operator|=
name|toff
expr_stmt|;
name|f
operator|->
name|trampoff
operator|=
name|trampoff
expr_stmt|;
name|fixups
operator|=
name|f
expr_stmt|;
block|}
else|else
block|{
comment|/* Nop out the reloc, since we're finalizing things here.  */
name|irel
operator|->
name|r_info
operator|=
name|ELFNN_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_IA64_NONE
argument_list|)
expr_stmt|;
block|}
comment|/* Fix up the existing branch to hit the trampoline.  Hope like 	 hell this doesn't overflow too.  */
if|if
condition|(
name|elfNN_ia64_install_value
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|roff
argument_list|,
name|f
operator|->
name|trampoff
operator|-
operator|(
name|roff
operator|&
operator|-
literal|4
operator|)
argument_list|,
name|R_IA64_PCREL21B
argument_list|)
operator|!=
name|bfd_reloc_ok
condition|)
goto|goto
name|error_return
goto|;
name|changed_contents
operator|=
name|true
expr_stmt|;
name|changed_relocs
operator|=
name|true
expr_stmt|;
block|}
comment|/* Clean up and go home.  */
while|while
condition|(
name|fixups
condition|)
block|{
name|struct
name|one_fixup
modifier|*
name|f
init|=
name|fixups
decl_stmt|;
name|fixups
operator|=
name|fixups
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|changed_relocs
condition|)
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|=
name|internal_relocs
expr_stmt|;
elseif|else
if|if
condition|(
name|free_relocs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|free_relocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|changed_contents
condition|)
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
elseif|else
if|if
condition|(
name|free_contents
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|link_info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|free_contents
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Cache the section contents for elf_link_input_bfd.  */
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
block|}
block|}
if|if
condition|(
name|free_extsyms
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|link_info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|free_extsyms
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Cache the symbols for elf_link_input_bfd.  */
name|symtab_hdr
operator|->
name|contents
operator|=
name|extsyms
expr_stmt|;
block|}
block|}
operator|*
name|again
operator|=
name|changed_contents
operator|||
name|changed_relocs
expr_stmt|;
return|return
name|true
return|;
name|error_return
label|:
if|if
condition|(
name|free_relocs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|free_relocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_contents
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|free_contents
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_extsyms
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|free_extsyms
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return true if NAME is an unwind table section name.  */
end_comment

begin_function
specifier|static
specifier|inline
name|boolean
name|is_unwind_section_name
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|size_t
name|len1
decl_stmt|,
name|len2
decl_stmt|,
name|len3
decl_stmt|;
name|len1
operator|=
sizeof|sizeof
argument_list|(
name|ELF_STRING_ia64_unwind
argument_list|)
operator|-
literal|1
expr_stmt|;
name|len2
operator|=
sizeof|sizeof
argument_list|(
name|ELF_STRING_ia64_unwind_info
argument_list|)
operator|-
literal|1
expr_stmt|;
name|len3
operator|=
sizeof|sizeof
argument_list|(
name|ELF_STRING_ia64_unwind_once
argument_list|)
operator|-
literal|1
expr_stmt|;
return|return
operator|(
operator|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|ELF_STRING_ia64_unwind
argument_list|,
name|len1
argument_list|)
operator|==
literal|0
operator|&&
name|strncmp
argument_list|(
name|name
argument_list|,
name|ELF_STRING_ia64_unwind_info
argument_list|,
name|len2
argument_list|)
operator|!=
literal|0
operator|)
operator|||
name|strncmp
argument_list|(
name|name
argument_list|,
name|ELF_STRING_ia64_unwind_once
argument_list|,
name|len3
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Handle an IA-64 specific section when reading an object file.  This    is called when elfcode.h finds a section with an unknown type.  */
end_comment

begin_function
specifier|static
name|boolean
name|elfNN_ia64_section_from_shdr
parameter_list|(
name|abfd
parameter_list|,
name|hdr
parameter_list|,
name|name
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|ElfNN_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|asection
modifier|*
name|newsect
decl_stmt|;
comment|/* There ought to be a place to keep ELF backend specific flags, but      at the moment there isn't one.  We just keep track of the      sections by their name, instead.  Fortunately, the ABI gives      suggested names for all the MIPS specific sections, so we will      probably get away with this.  */
switch|switch
condition|(
name|hdr
operator|->
name|sh_type
condition|)
block|{
case|case
name|SHT_IA_64_UNWIND
case|:
break|break;
case|case
name|SHT_IA_64_EXT
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|ELF_STRING_ia64_archext
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
break|break;
default|default:
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|_bfd_elf_make_section_from_shdr
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|false
return|;
name|newsect
operator|=
name|hdr
operator|->
name|bfd_section
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Convert IA-64 specific section flags to bfd internal section flags.  */
end_comment

begin_comment
comment|/* ??? There is no bfd internal flag equivalent to the SHF_IA_64_NORECOV    flag.  */
end_comment

begin_function
specifier|static
name|boolean
name|elfNN_ia64_section_flags
parameter_list|(
name|flags
parameter_list|,
name|hdr
parameter_list|)
name|flagword
modifier|*
name|flags
decl_stmt|;
name|ElfNN_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
block|{
if|if
condition|(
name|hdr
operator|->
name|sh_flags
operator|&
name|SHF_IA_64_SHORT
condition|)
operator|*
name|flags
operator||=
name|SEC_SMALL_DATA
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Set the correct type for an IA-64 ELF section.  We do this by the    section name, which is a hack, but ought to work.  */
end_comment

begin_function
specifier|static
name|boolean
name|elfNN_ia64_fake_sections
parameter_list|(
name|abfd
parameter_list|,
name|hdr
parameter_list|,
name|sec
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|ElfNN_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
block|{
specifier|register
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_unwind_section_name
argument_list|(
name|name
argument_list|)
condition|)
block|{
comment|/* We don't have the sections numbered at this point, so sh_info 	 is set later, in elfNN_ia64_final_write_processing.  */
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_IA_64_UNWIND
expr_stmt|;
name|hdr
operator|->
name|sh_flags
operator||=
name|SHF_LINK_ORDER
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|ELF_STRING_ia64_archext
argument_list|)
operator|==
literal|0
condition|)
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_IA_64_EXT
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".reloc"
argument_list|)
operator|==
literal|0
condition|)
comment|/*      * This is an ugly, but unfortunately necessary hack that is      * needed when producing EFI binaries on IA-64. It tells      * elf.c:elf_fake_sections() not to consider ".reloc" as a section      * containing ELF relocation info.  We need this hack in order to      * be able to generate ELF binaries that can be translated into      * EFI applications (which are essentially COFF objects).  Those      * files contain a COFF ".reloc" section inside an ELFNN object,      * which would normally cause BFD to segfault because it would      * attempt to interpret this section as containing relocation      * entries for section "oc".  With this hack enabled, ".reloc"      * will be treated as a normal data section, which will avoid the      * segfault.  However, you won't be able to create an ELFNN binary      * with a section named "oc" that needs relocations, but that's      * the kind of ugly side-effects you get when detecting section      * types based on their names...  In practice, this limitation is      * unlikely to bite.      */
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_PROGBITS
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|flags
operator|&
name|SEC_SMALL_DATA
condition|)
name|hdr
operator|->
name|sh_flags
operator||=
name|SHF_IA_64_SHORT
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* The final processing done just before writing out an IA-64 ELF    object file.  */
end_comment

begin_function
specifier|static
name|void
name|elfNN_ia64_final_write_processing
parameter_list|(
name|abfd
parameter_list|,
name|linker
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|boolean
name|linker
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
specifier|const
name|char
modifier|*
name|sname
decl_stmt|;
name|asection
modifier|*
name|text_sect
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|size_t
name|len
decl_stmt|;
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|hdr
operator|=
operator|&
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|this_hdr
expr_stmt|;
switch|switch
condition|(
name|hdr
operator|->
name|sh_type
condition|)
block|{
case|case
name|SHT_IA_64_UNWIND
case|:
comment|/* See comments in gas/config/tc-ia64.c:dot_endp on why we 	     have to do this.  */
name|sname
operator|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|ELF_STRING_ia64_unwind
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|sname
operator|&&
name|strncmp
argument_list|(
name|sname
argument_list|,
name|ELF_STRING_ia64_unwind
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sname
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|sname
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
comment|/* .IA_64.unwind -> .text */
name|text_sect
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".text"
argument_list|)
expr_stmt|;
else|else
comment|/* .IA_64.unwindFOO -> FOO */
name|text_sect
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|sname
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sname
operator|&&
operator|(
name|len
operator|=
sizeof|sizeof
argument_list|(
name|ELF_STRING_ia64_unwind_once
argument_list|)
operator|-
literal|1
operator|,
name|strncmp
argument_list|(
name|sname
argument_list|,
name|ELF_STRING_ia64_unwind_once
argument_list|,
name|len
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* .gnu.linkonce.ia64unw.FOO -> .gnu.linkonce.t.FOO */
name|size_t
name|len2
init|=
sizeof|sizeof
argument_list|(
literal|".gnu.linkonce.t."
argument_list|)
operator|-
literal|1
decl_stmt|;
name|char
modifier|*
name|once_name
init|=
name|alloca
argument_list|(
name|len2
operator|+
name|strlen
argument_list|(
name|sname
argument_list|)
operator|-
name|len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|once_name
argument_list|,
literal|".gnu.linkonce.t."
argument_list|,
name|len2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|once_name
operator|+
name|len2
argument_list|,
name|sname
operator|+
name|len
argument_list|)
expr_stmt|;
name|text_sect
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|once_name
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* last resort: fall back on .text */
name|text_sect
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".text"
argument_list|)
expr_stmt|;
if|if
condition|(
name|text_sect
condition|)
block|{
comment|/* The IA-64 processor-specific ABI requires setting 		 sh_link to the unwind section, whereas HP-UX requires 		 sh_info to do so.  For maximum compatibility, we'll 		 set both for now... */
name|hdr
operator|->
name|sh_link
operator|=
name|elf_section_data
argument_list|(
name|text_sect
argument_list|)
operator|->
name|this_idx
expr_stmt|;
name|hdr
operator|->
name|sh_info
operator|=
name|elf_section_data
argument_list|(
name|text_sect
argument_list|)
operator|->
name|this_idx
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Hook called by the linker routine which adds symbols from an object    file.  We use it to put .comm items in .sbss, and not .bss.  */
end_comment

begin_function
specifier|static
name|boolean
name|elfNN_ia64_add_symbol_hook
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|sym
parameter_list|,
name|namep
parameter_list|,
name|flagsp
parameter_list|,
name|secp
parameter_list|,
name|valp
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
specifier|const
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|namep
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|flagword
modifier|*
name|flagsp
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
modifier|*
name|secp
decl_stmt|;
name|bfd_vma
modifier|*
name|valp
decl_stmt|;
block|{
if|if
condition|(
name|sym
operator|->
name|st_shndx
operator|==
name|SHN_COMMON
operator|&&
operator|!
name|info
operator|->
name|relocateable
operator|&&
name|sym
operator|->
name|st_size
operator|<=
operator|(
name|unsigned
operator|)
name|bfd_get_gp_size
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
comment|/* Common symbols less than or equal to -G nn bytes are 	 automatically put into .sbss.  */
name|asection
modifier|*
name|scomm
init|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".scommon"
argument_list|)
decl_stmt|;
if|if
condition|(
name|scomm
operator|==
name|NULL
condition|)
block|{
name|scomm
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".scommon"
argument_list|)
expr_stmt|;
if|if
condition|(
name|scomm
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|scomm
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_IS_COMMON
operator||
name|SEC_LINKER_CREATED
operator|)
argument_list|)
condition|)
return|return
name|false
return|;
block|}
operator|*
name|secp
operator|=
name|scomm
expr_stmt|;
operator|*
name|valp
operator|=
name|sym
operator|->
name|st_size
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Return the number of additional phdrs we will need.  */
end_comment

begin_function
specifier|static
name|int
name|elfNN_ia64_additional_program_headers
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
comment|/* See if we need a PT_IA_64_ARCHEXT segment.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|ELF_STRING_ia64_archext
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
condition|)
operator|++
name|ret
expr_stmt|;
comment|/* Count how many PT_IA_64_UNWIND segments we need.  */
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
if|if
condition|(
name|is_unwind_section_name
argument_list|(
name|s
operator|->
name|name
argument_list|)
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
condition|)
operator|++
name|ret
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|elfNN_ia64_modify_segment_map
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|elf_segment_map
modifier|*
name|m
decl_stmt|,
modifier|*
modifier|*
name|pm
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
comment|/* If we need a PT_IA_64_ARCHEXT segment, it must come before      all PT_LOAD segments.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|ELF_STRING_ia64_archext
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
condition|)
block|{
for|for
control|(
name|m
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_map
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
if|if
condition|(
name|m
operator|->
name|p_type
operator|==
name|PT_IA_64_ARCHEXT
condition|)
break|break;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|m
operator|=
operator|(
expr|struct
name|elf_segment_map
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
expr|*
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|m
operator|->
name|p_type
operator|=
name|PT_IA_64_ARCHEXT
expr_stmt|;
name|m
operator|->
name|count
operator|=
literal|1
expr_stmt|;
name|m
operator|->
name|sections
index|[
literal|0
index|]
operator|=
name|s
expr_stmt|;
comment|/* We want to put it after the PHDR and INTERP segments.  */
name|pm
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_map
expr_stmt|;
while|while
condition|(
operator|*
name|pm
operator|!=
name|NULL
operator|&&
operator|(
operator|(
operator|*
name|pm
operator|)
operator|->
name|p_type
operator|==
name|PT_PHDR
operator|||
operator|(
operator|*
name|pm
operator|)
operator|->
name|p_type
operator|==
name|PT_INTERP
operator|)
condition|)
name|pm
operator|=
operator|&
operator|(
operator|*
name|pm
operator|)
operator|->
name|next
expr_stmt|;
name|m
operator|->
name|next
operator|=
operator|*
name|pm
expr_stmt|;
operator|*
name|pm
operator|=
name|m
expr_stmt|;
block|}
block|}
comment|/* Install PT_IA_64_UNWIND segments, if needed.  */
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|hdr
operator|=
operator|&
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|this_hdr
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|sh_type
operator|!=
name|SHT_IA_64_UNWIND
condition|)
continue|continue;
if|if
condition|(
name|s
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
condition|)
block|{
for|for
control|(
name|m
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_map
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
if|if
condition|(
name|m
operator|->
name|p_type
operator|==
name|PT_IA_64_UNWIND
operator|&&
name|m
operator|->
name|sections
index|[
literal|0
index|]
operator|==
name|s
condition|)
break|break;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|m
operator|=
operator|(
expr|struct
name|elf_segment_map
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
expr|*
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|m
operator|->
name|p_type
operator|=
name|PT_IA_64_UNWIND
expr_stmt|;
name|m
operator|->
name|count
operator|=
literal|1
expr_stmt|;
name|m
operator|->
name|sections
index|[
literal|0
index|]
operator|=
name|s
expr_stmt|;
name|m
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
comment|/* We want to put it last.  */
name|pm
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_map
expr_stmt|;
while|while
condition|(
operator|*
name|pm
operator|!=
name|NULL
condition|)
name|pm
operator|=
operator|&
operator|(
operator|*
name|pm
operator|)
operator|->
name|next
expr_stmt|;
operator|*
name|pm
operator|=
name|m
expr_stmt|;
block|}
block|}
block|}
comment|/* Turn on PF_IA_64_NORECOV if needed.  This involves traversing all of      the input sections for each output section in the segment and testing      for SHF_IA_64_NORECOV on each.  */
for|for
control|(
name|m
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_map
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
if|if
condition|(
name|m
operator|->
name|p_type
operator|==
name|PT_LOAD
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|m
operator|->
name|count
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|struct
name|bfd_link_order
modifier|*
name|order
init|=
name|m
operator|->
name|sections
index|[
name|i
index|]
operator|->
name|link_order_head
decl_stmt|;
while|while
condition|(
name|order
condition|)
block|{
if|if
condition|(
name|order
operator|->
name|type
operator|==
name|bfd_indirect_link_order
condition|)
block|{
name|asection
modifier|*
name|is
init|=
name|order
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
decl_stmt|;
name|bfd_vma
name|flags
init|=
name|elf_section_data
argument_list|(
name|is
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_flags
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|SHF_IA_64_NORECOV
condition|)
block|{
name|m
operator|->
name|p_flags
operator||=
name|PF_IA_64_NORECOV
expr_stmt|;
goto|goto
name|found
goto|;
block|}
block|}
name|order
operator|=
name|order
operator|->
name|next
expr_stmt|;
block|}
block|}
name|found
label|:
empty_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* According to the Tahoe assembler spec, all labels starting with a    '.' are local.  */
end_comment

begin_function
specifier|static
name|boolean
name|elfNN_ia64_is_local_label_name
parameter_list|(
name|abfd
parameter_list|,
name|name
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
return|return
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
return|;
block|}
end_function

begin_comment
comment|/* Should we do dynamic things to this symbol?  */
end_comment

begin_function
specifier|static
name|boolean
name|elfNN_ia64_dynamic_symbol_p
parameter_list|(
name|h
parameter_list|,
name|info
parameter_list|)
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
return|return
name|false
return|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
return|return
name|false
return|;
switch|switch
condition|(
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
condition|)
block|{
case|case
name|STV_INTERNAL
case|:
case|case
name|STV_HIDDEN
case|:
return|return
name|false
return|;
block|}
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
return|return
name|true
return|;
if|if
condition|(
operator|(
name|info
operator|->
name|shared
operator|&&
operator|!
name|info
operator|->
name|symbolic
operator|)
operator|||
operator|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
operator|(
name|ELF_LINK_HASH_DEF_DYNAMIC
operator||
name|ELF_LINK_HASH_REF_REGULAR
operator|)
operator|)
operator|==
operator|(
name|ELF_LINK_HASH_DEF_DYNAMIC
operator||
name|ELF_LINK_HASH_REF_REGULAR
operator|)
operator|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|boolean
name|elfNN_ia64_local_hash_table_init
parameter_list|(
name|ht
parameter_list|,
name|abfd
parameter_list|,
name|new
parameter_list|)
name|struct
name|elfNN_ia64_local_hash_table
modifier|*
name|ht
decl_stmt|;
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|new_hash_entry_func
name|new
decl_stmt|;
block|{
name|memset
argument_list|(
name|ht
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ht
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|bfd_hash_table_init
argument_list|(
operator|&
name|ht
operator|->
name|root
argument_list|,
name|new
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|elfNN_ia64_new_loc_hash_entry
parameter_list|(
name|entry
parameter_list|,
name|table
parameter_list|,
name|string
parameter_list|)
name|struct
name|bfd_hash_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|bfd_hash_table
modifier|*
name|table
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|struct
name|elfNN_ia64_local_hash_entry
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
operator|(
expr|struct
name|elfNN_ia64_local_hash_entry
operator|*
operator|)
name|entry
expr_stmt|;
comment|/* Allocate the structure if it has not already been allocated by a      subclass.  */
if|if
condition|(
operator|!
name|ret
condition|)
name|ret
operator|=
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ret
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
return|return
literal|0
return|;
comment|/* Initialize our local data.  All zeros, and definitely easier      than setting a handful of bit fields.  */
name|memset
argument_list|(
name|ret
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ret
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Call the allocation method of the superclass.  */
name|ret
operator|=
operator|(
operator|(
expr|struct
name|elfNN_ia64_local_hash_entry
operator|*
operator|)
name|bfd_hash_newfunc
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
operator|)
expr_stmt|;
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|elfNN_ia64_new_elf_hash_entry
parameter_list|(
name|entry
parameter_list|,
name|table
parameter_list|,
name|string
parameter_list|)
name|struct
name|bfd_hash_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|bfd_hash_table
modifier|*
name|table
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|struct
name|elfNN_ia64_link_hash_entry
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
operator|(
expr|struct
name|elfNN_ia64_link_hash_entry
operator|*
operator|)
name|entry
expr_stmt|;
comment|/* Allocate the structure if it has not already been allocated by a      subclass.  */
if|if
condition|(
operator|!
name|ret
condition|)
name|ret
operator|=
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ret
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
return|return
literal|0
return|;
comment|/* Initialize our local data.  All zeros, and definitely easier      than setting a handful of bit fields.  */
name|memset
argument_list|(
name|ret
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ret
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Call the allocation method of the superclass.  */
name|ret
operator|=
operator|(
operator|(
expr|struct
name|elfNN_ia64_link_hash_entry
operator|*
operator|)
name|_bfd_elf_link_hash_newfunc
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
operator|)
expr_stmt|;
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|elfNN_ia64_hash_copy_indirect
parameter_list|(
name|xdir
parameter_list|,
name|xind
parameter_list|)
name|struct
name|elf_link_hash_entry
modifier|*
name|xdir
decl_stmt|,
decl|*
name|xind
decl_stmt|;
end_function

begin_block
block|{
name|struct
name|elfNN_ia64_link_hash_entry
modifier|*
name|dir
decl_stmt|,
modifier|*
name|ind
decl_stmt|;
name|dir
operator|=
operator|(
expr|struct
name|elfNN_ia64_link_hash_entry
operator|*
operator|)
name|xdir
expr_stmt|;
name|ind
operator|=
operator|(
expr|struct
name|elfNN_ia64_link_hash_entry
operator|*
operator|)
name|xind
expr_stmt|;
comment|/* Copy down any references that we may have already seen to the      symbol which just became indirect.  */
name|dir
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator||=
operator|(
name|ind
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator|&
operator|(
name|ELF_LINK_HASH_REF_DYNAMIC
operator||
name|ELF_LINK_HASH_REF_REGULAR
operator||
name|ELF_LINK_HASH_REF_REGULAR_NONWEAK
operator|)
operator|)
expr_stmt|;
comment|/* Copy over the got and plt data.  This would have been done      by check_relocs.  */
if|if
condition|(
name|dir
operator|->
name|info
operator|==
name|NULL
condition|)
block|{
name|struct
name|elfNN_ia64_dyn_sym_info
modifier|*
name|dyn_i
decl_stmt|;
name|dir
operator|->
name|info
operator|=
name|dyn_i
operator|=
name|ind
operator|->
name|info
expr_stmt|;
name|ind
operator|->
name|info
operator|=
name|NULL
expr_stmt|;
comment|/* Fix up the dyn_sym_info pointers to the global symbol.  */
for|for
control|(
init|;
name|dyn_i
condition|;
name|dyn_i
operator|=
name|dyn_i
operator|->
name|next
control|)
name|dyn_i
operator|->
name|h
operator|=
operator|&
name|dir
operator|->
name|root
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
name|ind
operator|->
name|info
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* Copy over the dynindx.  */
if|if
condition|(
name|dir
operator|->
name|root
operator|.
name|dynindx
operator|==
operator|-
literal|1
condition|)
block|{
name|dir
operator|->
name|root
operator|.
name|dynindx
operator|=
name|ind
operator|->
name|root
operator|.
name|dynindx
expr_stmt|;
name|dir
operator|->
name|root
operator|.
name|dynstr_index
operator|=
name|ind
operator|->
name|root
operator|.
name|dynstr_index
expr_stmt|;
name|ind
operator|->
name|root
operator|.
name|dynindx
operator|=
operator|-
literal|1
expr_stmt|;
name|ind
operator|->
name|root
operator|.
name|dynstr_index
operator|=
literal|0
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
name|ind
operator|->
name|root
operator|.
name|dynindx
operator|==
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|elfNN_ia64_hash_hide_symbol
parameter_list|(
name|info
parameter_list|,
name|xh
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|xh
decl_stmt|;
block|{
name|struct
name|elfNN_ia64_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|elfNN_ia64_dyn_sym_info
modifier|*
name|dyn_i
decl_stmt|;
name|h
operator|=
operator|(
expr|struct
name|elfNN_ia64_link_hash_entry
operator|*
operator|)
name|xh
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_HASH_NEEDS_PLT
expr_stmt|;
if|if
condition|(
operator|(
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_FORCED_LOCAL
operator|)
operator|!=
literal|0
condition|)
name|h
operator|->
name|root
operator|.
name|dynindx
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|dyn_i
operator|=
name|h
operator|->
name|info
init|;
name|dyn_i
condition|;
name|dyn_i
operator|=
name|dyn_i
operator|->
name|next
control|)
name|dyn_i
operator|->
name|want_plt2
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create the derived linker hash table.  The IA-64 ELF port uses this    derived hash table to keep information specific to the IA-64 ElF    linker (without using static variables).  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_link_hash_table
modifier|*
name|elfNN_ia64_hash_table_create
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|elfNN_ia64_link_hash_table
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ret
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|_bfd_elf_link_hash_table_init
argument_list|(
operator|&
name|ret
operator|->
name|root
argument_list|,
name|abfd
argument_list|,
name|elfNN_ia64_new_elf_hash_entry
argument_list|)
condition|)
block|{
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|elfNN_ia64_local_hash_table_init
argument_list|(
operator|&
name|ret
operator|->
name|loc_hash_table
argument_list|,
name|abfd
argument_list|,
name|elfNN_ia64_new_loc_hash_entry
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
operator|&
name|ret
operator|->
name|root
operator|.
name|root
return|;
block|}
end_function

begin_comment
comment|/* Look up an entry in a Alpha ELF linker hash table.  */
end_comment

begin_expr_stmt
specifier|static
name|INLINE
expr|struct
name|elfNN_ia64_local_hash_entry
operator|*
name|elfNN_ia64_local_hash_lookup
argument_list|(
argument|table
argument_list|,
argument|string
argument_list|,
argument|create
argument_list|,
argument|copy
argument_list|)
expr|struct
name|elfNN_ia64_local_hash_table
operator|*
name|table
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|create
decl_stmt|,
name|copy
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
operator|(
expr|struct
name|elfNN_ia64_local_hash_entry
operator|*
operator|)
name|bfd_hash_lookup
argument_list|(
operator|&
name|table
operator|->
name|root
argument_list|,
name|string
argument_list|,
name|create
argument_list|,
name|copy
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Traverse both local and global hash tables.  */
end_comment

begin_struct
struct|struct
name|elfNN_ia64_dyn_sym_traverse_data
block|{
name|boolean
argument_list|(
argument|*func
argument_list|)
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elfNN_ia64_dyn_sym_info
operator|*
operator|,
name|PTR
operator|)
argument_list|)
expr_stmt|;
name|PTR
name|data
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|boolean
name|elfNN_ia64_global_dyn_sym_thunk
parameter_list|(
name|xentry
parameter_list|,
name|xdata
parameter_list|)
name|struct
name|bfd_hash_entry
modifier|*
name|xentry
decl_stmt|;
name|PTR
name|xdata
decl_stmt|;
block|{
name|struct
name|elfNN_ia64_link_hash_entry
modifier|*
name|entry
init|=
operator|(
expr|struct
name|elfNN_ia64_link_hash_entry
operator|*
operator|)
name|xentry
decl_stmt|;
name|struct
name|elfNN_ia64_dyn_sym_traverse_data
modifier|*
name|data
init|=
operator|(
expr|struct
name|elfNN_ia64_dyn_sym_traverse_data
operator|*
operator|)
name|xdata
decl_stmt|;
name|struct
name|elfNN_ia64_dyn_sym_info
modifier|*
name|dyn_i
decl_stmt|;
for|for
control|(
name|dyn_i
operator|=
name|entry
operator|->
name|info
init|;
name|dyn_i
condition|;
name|dyn_i
operator|=
name|dyn_i
operator|->
name|next
control|)
if|if
condition|(
operator|!
call|(
modifier|*
name|data
operator|->
name|func
call|)
argument_list|(
name|dyn_i
argument_list|,
name|data
operator|->
name|data
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|elfNN_ia64_local_dyn_sym_thunk
parameter_list|(
name|xentry
parameter_list|,
name|xdata
parameter_list|)
name|struct
name|bfd_hash_entry
modifier|*
name|xentry
decl_stmt|;
name|PTR
name|xdata
decl_stmt|;
block|{
name|struct
name|elfNN_ia64_local_hash_entry
modifier|*
name|entry
init|=
operator|(
expr|struct
name|elfNN_ia64_local_hash_entry
operator|*
operator|)
name|xentry
decl_stmt|;
name|struct
name|elfNN_ia64_dyn_sym_traverse_data
modifier|*
name|data
init|=
operator|(
expr|struct
name|elfNN_ia64_dyn_sym_traverse_data
operator|*
operator|)
name|xdata
decl_stmt|;
name|struct
name|elfNN_ia64_dyn_sym_info
modifier|*
name|dyn_i
decl_stmt|;
for|for
control|(
name|dyn_i
operator|=
name|entry
operator|->
name|info
init|;
name|dyn_i
condition|;
name|dyn_i
operator|=
name|dyn_i
operator|->
name|next
control|)
if|if
condition|(
operator|!
call|(
modifier|*
name|data
operator|->
name|func
call|)
argument_list|(
name|dyn_i
argument_list|,
name|data
operator|->
name|data
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|elfNN_ia64_dyn_sym_traverse
parameter_list|(
name|ia64_info
parameter_list|,
name|func
parameter_list|,
name|data
parameter_list|)
name|struct
name|elfNN_ia64_link_hash_table
modifier|*
name|ia64_info
decl_stmt|;
function_decl|boolean
parameter_list|(
function_decl|*func
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elfNN_ia64_dyn_sym_info
operator|*
operator|,
name|PTR
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|PTR
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|elfNN_ia64_dyn_sym_traverse_data
name|xdata
decl_stmt|;
name|xdata
operator|.
name|func
operator|=
name|func
expr_stmt|;
name|xdata
operator|.
name|data
operator|=
name|data
expr_stmt|;
name|elf_link_hash_traverse
argument_list|(
operator|&
name|ia64_info
operator|->
name|root
argument_list|,
name|elfNN_ia64_global_dyn_sym_thunk
argument_list|,
operator|&
name|xdata
argument_list|)
expr_stmt|;
name|bfd_hash_traverse
argument_list|(
operator|&
name|ia64_info
operator|->
name|loc_hash_table
operator|.
name|root
argument_list|,
name|elfNN_ia64_local_dyn_sym_thunk
argument_list|,
operator|&
name|xdata
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_function
specifier|static
name|boolean
name|elfNN_ia64_create_dynamic_sections
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|struct
name|elfNN_ia64_link_hash_table
modifier|*
name|ia64_info
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|_bfd_elf_create_dynamic_sections
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|false
return|;
name|ia64_info
operator|=
name|elfNN_ia64_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|ia64_info
operator|->
name|plt_sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
name|ia64_info
operator|->
name|got_sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
block|{
name|flagword
name|flags
init|=
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|ia64_info
operator|->
name|got_sec
argument_list|)
decl_stmt|;
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|ia64_info
operator|->
name|got_sec
argument_list|,
name|SEC_SMALL_DATA
operator||
name|flags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|get_pltoff
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|ia64_info
argument_list|)
condition|)
return|return
name|false
return|;
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".rela.IA_64.pltoff"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_READONLY
operator|)
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
literal|3
argument_list|)
condition|)
return|return
name|false
return|;
name|ia64_info
operator|->
name|rel_pltoff_sec
operator|=
name|s
expr_stmt|;
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_READONLY
operator|)
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
literal|3
argument_list|)
condition|)
return|return
name|false
return|;
name|ia64_info
operator|->
name|rel_got_sec
operator|=
name|s
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Find and/or create a descriptor for dynamic symbol info.  This will    vary based on global or local symbol, and the addend to the reloc.  */
end_comment

begin_function
specifier|static
name|struct
name|elfNN_ia64_dyn_sym_info
modifier|*
name|get_dyn_sym_info
parameter_list|(
name|ia64_info
parameter_list|,
name|h
parameter_list|,
name|abfd
parameter_list|,
name|rel
parameter_list|,
name|create
parameter_list|)
name|struct
name|elfNN_ia64_link_hash_table
modifier|*
name|ia64_info
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|boolean
name|create
decl_stmt|;
block|{
name|struct
name|elfNN_ia64_dyn_sym_info
modifier|*
modifier|*
name|pp
decl_stmt|;
name|struct
name|elfNN_ia64_dyn_sym_info
modifier|*
name|dyn_i
decl_stmt|;
name|bfd_vma
name|addend
init|=
name|rel
condition|?
name|rel
operator|->
name|r_addend
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|h
condition|)
name|pp
operator|=
operator|&
operator|(
operator|(
expr|struct
name|elfNN_ia64_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|info
expr_stmt|;
else|else
block|{
name|struct
name|elfNN_ia64_local_hash_entry
modifier|*
name|loc_h
decl_stmt|;
name|char
modifier|*
name|addr_name
decl_stmt|;
name|size_t
name|len
decl_stmt|;
comment|/* Construct a string for use in the elfNN_ia64_local_hash_table.          The name describes what was once anonymous memory.  */
name|len
operator|=
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|*
literal|2
operator|+
literal|1
operator|+
sizeof|sizeof
argument_list|(
name|bfd_vma
argument_list|)
operator|*
literal|4
operator|+
literal|1
operator|+
literal|1
expr_stmt|;
name|len
operator|+=
literal|10
expr_stmt|;
comment|/* %p slop */
name|addr_name
operator|=
name|alloca
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|addr_name
argument_list|,
literal|"%p:%lx"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|abfd
argument_list|,
name|ELFNN_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Collect the canonical entry data for this address.  */
name|loc_h
operator|=
name|elfNN_ia64_local_hash_lookup
argument_list|(
operator|&
name|ia64_info
operator|->
name|loc_hash_table
argument_list|,
name|addr_name
argument_list|,
name|create
argument_list|,
name|create
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|loc_h
argument_list|)
expr_stmt|;
name|pp
operator|=
operator|&
name|loc_h
operator|->
name|info
expr_stmt|;
block|}
for|for
control|(
name|dyn_i
operator|=
operator|*
name|pp
init|;
name|dyn_i
operator|&&
name|dyn_i
operator|->
name|addend
operator|!=
name|addend
condition|;
name|dyn_i
operator|=
operator|*
name|pp
control|)
name|pp
operator|=
operator|&
name|dyn_i
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|dyn_i
operator|==
name|NULL
operator|&&
name|create
condition|)
block|{
name|dyn_i
operator|=
operator|(
expr|struct
name|elfNN_ia64_dyn_sym_info
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
expr|*
name|dyn_i
argument_list|)
expr_stmt|;
operator|*
name|pp
operator|=
name|dyn_i
expr_stmt|;
name|dyn_i
operator|->
name|addend
operator|=
name|addend
expr_stmt|;
block|}
return|return
name|dyn_i
return|;
block|}
end_function

begin_function
specifier|static
name|asection
modifier|*
name|get_got
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|ia64_info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|elfNN_ia64_link_hash_table
modifier|*
name|ia64_info
decl_stmt|;
block|{
name|asection
modifier|*
name|got
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|got
operator|=
name|ia64_info
operator|->
name|got_sec
expr_stmt|;
if|if
condition|(
operator|!
name|got
condition|)
block|{
name|flagword
name|flags
decl_stmt|;
name|dynobj
operator|=
name|ia64_info
operator|->
name|root
operator|.
name|dynobj
expr_stmt|;
if|if
condition|(
operator|!
name|dynobj
condition|)
name|ia64_info
operator|->
name|root
operator|.
name|dynobj
operator|=
name|dynobj
operator|=
name|abfd
expr_stmt|;
if|if
condition|(
operator|!
name|_bfd_elf_create_got_section
argument_list|(
name|dynobj
argument_list|,
name|info
argument_list|)
condition|)
return|return
literal|0
return|;
name|got
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|got
argument_list|)
expr_stmt|;
name|ia64_info
operator|->
name|got_sec
operator|=
name|got
expr_stmt|;
name|flags
operator|=
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|got
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|got
argument_list|,
name|SEC_SMALL_DATA
operator||
name|flags
argument_list|)
expr_stmt|;
block|}
return|return
name|got
return|;
block|}
end_function

begin_comment
comment|/* Create function descriptor section (.opd).  This section is called .opd    because it contains "official prodecure descriptors".  The "official"    refers to the fact that these descriptors are used when taking the address    of a procedure, thus ensuring a unique address for each procedure.  */
end_comment

begin_function
specifier|static
name|asection
modifier|*
name|get_fptr
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|ia64_info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|elfNN_ia64_link_hash_table
modifier|*
name|ia64_info
decl_stmt|;
block|{
name|asection
modifier|*
name|fptr
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|fptr
operator|=
name|ia64_info
operator|->
name|fptr_sec
expr_stmt|;
if|if
condition|(
operator|!
name|fptr
condition|)
block|{
name|dynobj
operator|=
name|ia64_info
operator|->
name|root
operator|.
name|dynobj
expr_stmt|;
if|if
condition|(
operator|!
name|dynobj
condition|)
name|ia64_info
operator|->
name|root
operator|.
name|dynobj
operator|=
name|dynobj
operator|=
name|abfd
expr_stmt|;
name|fptr
operator|=
name|bfd_make_section
argument_list|(
name|dynobj
argument_list|,
literal|".opd"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fptr
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|dynobj
argument_list|,
name|fptr
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_READONLY
operator||
name|SEC_LINKER_CREATED
operator|)
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|fptr
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|BFD_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ia64_info
operator|->
name|fptr_sec
operator|=
name|fptr
expr_stmt|;
block|}
return|return
name|fptr
return|;
block|}
end_function

begin_function
specifier|static
name|asection
modifier|*
name|get_pltoff
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|ia64_info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|elfNN_ia64_link_hash_table
modifier|*
name|ia64_info
decl_stmt|;
block|{
name|asection
modifier|*
name|pltoff
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|pltoff
operator|=
name|ia64_info
operator|->
name|pltoff_sec
expr_stmt|;
if|if
condition|(
operator|!
name|pltoff
condition|)
block|{
name|dynobj
operator|=
name|ia64_info
operator|->
name|root
operator|.
name|dynobj
expr_stmt|;
if|if
condition|(
operator|!
name|dynobj
condition|)
name|ia64_info
operator|->
name|root
operator|.
name|dynobj
operator|=
name|dynobj
operator|=
name|abfd
expr_stmt|;
name|pltoff
operator|=
name|bfd_make_section
argument_list|(
name|dynobj
argument_list|,
name|ELF_STRING_ia64_pltoff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pltoff
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|dynobj
argument_list|,
name|pltoff
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_SMALL_DATA
operator||
name|SEC_LINKER_CREATED
operator|)
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|pltoff
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|BFD_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ia64_info
operator|->
name|pltoff_sec
operator|=
name|pltoff
expr_stmt|;
block|}
return|return
name|pltoff
return|;
block|}
end_function

begin_function
specifier|static
name|asection
modifier|*
name|get_reloc_section
parameter_list|(
name|abfd
parameter_list|,
name|ia64_info
parameter_list|,
name|sec
parameter_list|,
name|create
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|elfNN_ia64_link_hash_table
modifier|*
name|ia64_info
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|boolean
name|create
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|srel_name
decl_stmt|;
name|asection
modifier|*
name|srel
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|srel_name
operator|=
operator|(
name|bfd_elf_string_from_elf_section
argument_list|(
name|abfd
argument_list|,
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_shstrndx
argument_list|,
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|rel_hdr
operator|.
name|sh_name
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|srel_name
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|BFD_ASSERT
argument_list|(
operator|(
name|strncmp
argument_list|(
name|srel_name
argument_list|,
literal|".rela"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|,
name|srel_name
operator|+
literal|5
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strncmp
argument_list|(
name|srel_name
argument_list|,
literal|".rel"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|,
name|srel_name
operator|+
literal|4
argument_list|)
operator|==
literal|0
operator|)
argument_list|)
expr_stmt|;
name|dynobj
operator|=
name|ia64_info
operator|->
name|root
operator|.
name|dynobj
expr_stmt|;
if|if
condition|(
operator|!
name|dynobj
condition|)
name|ia64_info
operator|->
name|root
operator|.
name|dynobj
operator|=
name|dynobj
operator|=
name|abfd
expr_stmt|;
name|srel
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|srel_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|srel
operator|==
name|NULL
operator|&&
name|create
condition|)
block|{
name|srel
operator|=
name|bfd_make_section
argument_list|(
name|dynobj
argument_list|,
name|srel_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|srel
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|dynobj
argument_list|,
name|srel
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_READONLY
operator|)
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|srel
argument_list|,
literal|3
argument_list|)
condition|)
return|return
name|NULL
return|;
block|}
return|return
name|srel
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|count_dyn_reloc
parameter_list|(
name|abfd
parameter_list|,
name|dyn_i
parameter_list|,
name|srel
parameter_list|,
name|type
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|elfNN_ia64_dyn_sym_info
modifier|*
name|dyn_i
decl_stmt|;
name|asection
modifier|*
name|srel
decl_stmt|;
name|int
name|type
decl_stmt|;
block|{
name|struct
name|elfNN_ia64_dyn_reloc_entry
modifier|*
name|rent
decl_stmt|;
for|for
control|(
name|rent
operator|=
name|dyn_i
operator|->
name|reloc_entries
init|;
name|rent
condition|;
name|rent
operator|=
name|rent
operator|->
name|next
control|)
if|if
condition|(
name|rent
operator|->
name|srel
operator|==
name|srel
operator|&&
name|rent
operator|->
name|type
operator|==
name|type
condition|)
break|break;
if|if
condition|(
operator|!
name|rent
condition|)
block|{
name|rent
operator|=
operator|(
expr|struct
name|elfNN_ia64_dyn_reloc_entry
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rent
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rent
condition|)
return|return
name|false
return|;
name|rent
operator|->
name|next
operator|=
name|dyn_i
operator|->
name|reloc_entries
expr_stmt|;
name|rent
operator|->
name|srel
operator|=
name|srel
expr_stmt|;
name|rent
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|rent
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|dyn_i
operator|->
name|reloc_entries
operator|=
name|rent
expr_stmt|;
block|}
name|rent
operator|->
name|count
operator|++
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|elfNN_ia64_check_relocs
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|sec
parameter_list|,
name|relocs
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|;
block|{
name|struct
name|elfNN_ia64_link_hash_table
modifier|*
name|ia64_info
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relend
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|asection
modifier|*
name|got
decl_stmt|,
modifier|*
name|fptr
decl_stmt|,
modifier|*
name|srel
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocateable
condition|)
return|return
name|true
return|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|ia64_info
operator|=
name|elfNN_ia64_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|got
operator|=
name|fptr
operator|=
name|srel
operator|=
name|NULL
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|relend
condition|;
operator|++
name|rel
control|)
block|{
enum|enum
block|{
name|NEED_GOT
init|=
literal|1
block|,
name|NEED_FPTR
init|=
literal|2
block|,
name|NEED_PLTOFF
init|=
literal|4
block|,
name|NEED_MIN_PLT
init|=
literal|8
block|,
name|NEED_FULL_PLT
init|=
literal|16
block|,
name|NEED_DYNREL
init|=
literal|32
block|,
name|NEED_LTOFF_FPTR
init|=
literal|64
block|,       }
enum|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
init|=
name|NULL
decl_stmt|;
name|unsigned
name|long
name|r_symndx
init|=
name|ELFNN_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
decl_stmt|;
name|struct
name|elfNN_ia64_dyn_sym_info
modifier|*
name|dyn_i
decl_stmt|;
name|int
name|need_entry
decl_stmt|;
name|boolean
name|maybe_dynamic
decl_stmt|;
name|int
name|dynrel_type
init|=
name|R_IA64_NONE
decl_stmt|;
if|if
condition|(
name|r_symndx
operator|>=
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
comment|/* We're dealing with a global symbol -- find its hash entry 	     and mark it as being referenced.  */
name|long
name|indx
init|=
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
decl_stmt|;
name|h
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
index|[
name|indx
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_REF_REGULAR
expr_stmt|;
block|}
comment|/* We can only get preliminary data on whether a symbol is 	 locally or externally defined, as not all of the input files 	 have yet been processed.  Do something with what we know, as 	 this may help reduce memory usage and processing time later.  */
name|maybe_dynamic
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|h
operator|&&
operator|(
operator|(
name|info
operator|->
name|shared
operator|&&
operator|!
name|info
operator|->
name|symbolic
operator|)
operator|||
operator|!
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
condition|)
name|maybe_dynamic
operator|=
name|true
expr_stmt|;
name|need_entry
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|ELFNN_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_IA64_TPREL22
case|:
case|case
name|R_IA64_TPREL64MSB
case|:
case|case
name|R_IA64_TPREL64LSB
case|:
case|case
name|R_IA64_LTOFF_TP22
case|:
return|return
name|false
return|;
case|case
name|R_IA64_LTOFF_FPTR22
case|:
case|case
name|R_IA64_LTOFF_FPTR64I
case|:
case|case
name|R_IA64_LTOFF_FPTR64MSB
case|:
case|case
name|R_IA64_LTOFF_FPTR64LSB
case|:
name|need_entry
operator|=
name|NEED_FPTR
operator||
name|NEED_GOT
operator||
name|NEED_LTOFF_FPTR
expr_stmt|;
break|break;
case|case
name|R_IA64_FPTR64I
case|:
case|case
name|R_IA64_FPTR32MSB
case|:
case|case
name|R_IA64_FPTR32LSB
case|:
case|case
name|R_IA64_FPTR64MSB
case|:
case|case
name|R_IA64_FPTR64LSB
case|:
if|if
condition|(
name|info
operator|->
name|shared
operator|||
name|h
condition|)
name|need_entry
operator|=
name|NEED_FPTR
operator||
name|NEED_DYNREL
expr_stmt|;
else|else
name|need_entry
operator|=
name|NEED_FPTR
expr_stmt|;
name|dynrel_type
operator|=
name|R_IA64_FPTR64LSB
expr_stmt|;
break|break;
case|case
name|R_IA64_LTOFF22
case|:
case|case
name|R_IA64_LTOFF22X
case|:
case|case
name|R_IA64_LTOFF64I
case|:
name|need_entry
operator|=
name|NEED_GOT
expr_stmt|;
break|break;
case|case
name|R_IA64_PLTOFF22
case|:
case|case
name|R_IA64_PLTOFF64I
case|:
case|case
name|R_IA64_PLTOFF64MSB
case|:
case|case
name|R_IA64_PLTOFF64LSB
case|:
name|need_entry
operator|=
name|NEED_PLTOFF
expr_stmt|;
if|if
condition|(
name|h
condition|)
block|{
if|if
condition|(
name|maybe_dynamic
condition|)
name|need_entry
operator||=
name|NEED_MIN_PLT
expr_stmt|;
block|}
else|else
block|{
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|warning
call|)
argument_list|(
name|info
argument_list|,
name|_
argument_list|(
literal|"@pltoff reloc against local symbol"
argument_list|)
argument_list|,
literal|0
argument_list|,
name|abfd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|R_IA64_PCREL21B
case|:
case|case
name|R_IA64_PCREL60B
case|:
comment|/* Depending on where this symbol is defined, we may or may not 	     need a full plt entry.  Only skip if we know we'll not need 	     the entry -- static or symbolic, and the symbol definition 	     has already been seen.  */
if|if
condition|(
name|maybe_dynamic
operator|&&
name|rel
operator|->
name|r_addend
operator|==
literal|0
condition|)
name|need_entry
operator|=
name|NEED_FULL_PLT
expr_stmt|;
break|break;
case|case
name|R_IA64_IMM14
case|:
case|case
name|R_IA64_IMM22
case|:
case|case
name|R_IA64_IMM64
case|:
case|case
name|R_IA64_DIR32MSB
case|:
case|case
name|R_IA64_DIR32LSB
case|:
case|case
name|R_IA64_DIR64MSB
case|:
case|case
name|R_IA64_DIR64LSB
case|:
comment|/* Shared objects will always need at least a REL relocation.  */
if|if
condition|(
name|info
operator|->
name|shared
operator|||
name|maybe_dynamic
condition|)
name|need_entry
operator|=
name|NEED_DYNREL
expr_stmt|;
name|dynrel_type
operator|=
name|R_IA64_DIR64LSB
expr_stmt|;
break|break;
case|case
name|R_IA64_IPLTMSB
case|:
case|case
name|R_IA64_IPLTLSB
case|:
comment|/* Shared objects will always need at least a REL relocation.  */
if|if
condition|(
name|info
operator|->
name|shared
operator|||
name|maybe_dynamic
condition|)
name|need_entry
operator|=
name|NEED_DYNREL
expr_stmt|;
name|dynrel_type
operator|=
name|R_IA64_IPLTLSB
expr_stmt|;
break|break;
case|case
name|R_IA64_PCREL22
case|:
case|case
name|R_IA64_PCREL64I
case|:
case|case
name|R_IA64_PCREL32MSB
case|:
case|case
name|R_IA64_PCREL32LSB
case|:
case|case
name|R_IA64_PCREL64MSB
case|:
case|case
name|R_IA64_PCREL64LSB
case|:
if|if
condition|(
name|maybe_dynamic
condition|)
name|need_entry
operator|=
name|NEED_DYNREL
expr_stmt|;
name|dynrel_type
operator|=
name|R_IA64_PCREL64LSB
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|need_entry
condition|)
continue|continue;
if|if
condition|(
operator|(
name|need_entry
operator|&
name|NEED_FPTR
operator|)
operator|!=
literal|0
operator|&&
name|rel
operator|->
name|r_addend
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|warning
call|)
argument_list|(
name|info
argument_list|,
name|_
argument_list|(
literal|"non-zero addend in @fptr reloc"
argument_list|)
argument_list|,
literal|0
argument_list|,
name|abfd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|dyn_i
operator|=
name|get_dyn_sym_info
argument_list|(
name|ia64_info
argument_list|,
name|h
argument_list|,
name|abfd
argument_list|,
name|rel
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* Record whether or not this is a local symbol.  */
name|dyn_i
operator|->
name|h
operator|=
name|h
expr_stmt|;
comment|/* Create what's needed.  */
if|if
condition|(
name|need_entry
operator|&
name|NEED_GOT
condition|)
block|{
if|if
condition|(
operator|!
name|got
condition|)
block|{
name|got
operator|=
name|get_got
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|ia64_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|got
condition|)
return|return
name|false
return|;
block|}
name|dyn_i
operator|->
name|want_got
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|need_entry
operator|&
name|NEED_FPTR
condition|)
block|{
if|if
condition|(
operator|!
name|fptr
condition|)
block|{
name|fptr
operator|=
name|get_fptr
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|ia64_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fptr
condition|)
return|return
name|false
return|;
block|}
comment|/* FPTRs for shared libraries are allocated by the dynamic 	     linker.  Make sure this local symbol will appear in the 	     dynamic symbol table.  */
if|if
condition|(
operator|!
name|h
operator|&&
name|info
operator|->
name|shared
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|_bfd_elfNN_link_record_local_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
name|r_symndx
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
block|}
name|dyn_i
operator|->
name|want_fptr
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|need_entry
operator|&
name|NEED_LTOFF_FPTR
condition|)
name|dyn_i
operator|->
name|want_ltoff_fptr
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|need_entry
operator|&
operator|(
name|NEED_MIN_PLT
operator||
name|NEED_FULL_PLT
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|ia64_info
operator|->
name|root
operator|.
name|dynobj
condition|)
name|ia64_info
operator|->
name|root
operator|.
name|dynobj
operator|=
name|abfd
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_NEEDS_PLT
expr_stmt|;
name|dyn_i
operator|->
name|want_plt
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|need_entry
operator|&
name|NEED_FULL_PLT
condition|)
name|dyn_i
operator|->
name|want_plt2
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|need_entry
operator|&
name|NEED_PLTOFF
condition|)
name|dyn_i
operator|->
name|want_pltoff
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|need_entry
operator|&
name|NEED_DYNREL
operator|)
operator|&&
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|srel
condition|)
block|{
name|srel
operator|=
name|get_reloc_section
argument_list|(
name|abfd
argument_list|,
name|ia64_info
argument_list|,
name|sec
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|srel
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|count_dyn_reloc
argument_list|(
name|abfd
argument_list|,
name|dyn_i
argument_list|,
name|srel
argument_list|,
name|dynrel_type
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_struct
struct|struct
name|elfNN_ia64_allocate_data
block|{
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd_size_type
name|ofs
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* For cleanliness, and potentially faster dynamic loading, allocate    external GOT entries first.  */
end_comment

begin_function
specifier|static
name|boolean
name|allocate_global_data_got
parameter_list|(
name|dyn_i
parameter_list|,
name|data
parameter_list|)
name|struct
name|elfNN_ia64_dyn_sym_info
modifier|*
name|dyn_i
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
name|struct
name|elfNN_ia64_allocate_data
modifier|*
name|x
init|=
operator|(
expr|struct
name|elfNN_ia64_allocate_data
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|dyn_i
operator|->
name|want_got
operator|&&
operator|!
name|dyn_i
operator|->
name|want_fptr
operator|&&
name|elfNN_ia64_dynamic_symbol_p
argument_list|(
name|dyn_i
operator|->
name|h
argument_list|,
name|x
operator|->
name|info
argument_list|)
condition|)
block|{
name|dyn_i
operator|->
name|got_offset
operator|=
name|x
operator|->
name|ofs
expr_stmt|;
name|x
operator|->
name|ofs
operator|+=
literal|8
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Next, allocate all the GOT entries used by LTOFF_FPTR relocs.  */
end_comment

begin_function
specifier|static
name|boolean
name|allocate_global_fptr_got
parameter_list|(
name|dyn_i
parameter_list|,
name|data
parameter_list|)
name|struct
name|elfNN_ia64_dyn_sym_info
modifier|*
name|dyn_i
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
name|struct
name|elfNN_ia64_allocate_data
modifier|*
name|x
init|=
operator|(
expr|struct
name|elfNN_ia64_allocate_data
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|dyn_i
operator|->
name|want_got
operator|&&
name|dyn_i
operator|->
name|want_fptr
operator|&&
name|elfNN_ia64_dynamic_symbol_p
argument_list|(
name|dyn_i
operator|->
name|h
argument_list|,
name|x
operator|->
name|info
argument_list|)
condition|)
block|{
name|dyn_i
operator|->
name|got_offset
operator|=
name|x
operator|->
name|ofs
expr_stmt|;
name|x
operator|->
name|ofs
operator|+=
literal|8
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Lastly, allocate all the GOT entries for local data.  */
end_comment

begin_function
specifier|static
name|boolean
name|allocate_local_got
parameter_list|(
name|dyn_i
parameter_list|,
name|data
parameter_list|)
name|struct
name|elfNN_ia64_dyn_sym_info
modifier|*
name|dyn_i
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
name|struct
name|elfNN_ia64_allocate_data
modifier|*
name|x
init|=
operator|(
expr|struct
name|elfNN_ia64_allocate_data
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|dyn_i
operator|->
name|want_got
operator|&&
operator|!
name|elfNN_ia64_dynamic_symbol_p
argument_list|(
name|dyn_i
operator|->
name|h
argument_list|,
name|x
operator|->
name|info
argument_list|)
condition|)
block|{
name|dyn_i
operator|->
name|got_offset
operator|=
name|x
operator|->
name|ofs
expr_stmt|;
name|x
operator|->
name|ofs
operator|+=
literal|8
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Search for the index of a global symbol in it's defining object file.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|global_sym_index
parameter_list|(
name|h
parameter_list|)
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
block|{
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|p
decl_stmt|;
name|bfd
modifier|*
name|obj
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
argument_list|)
expr_stmt|;
name|obj
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
expr_stmt|;
for|for
control|(
name|p
operator|=
name|elf_sym_hashes
argument_list|(
name|obj
argument_list|)
init|;
operator|*
name|p
operator|!=
name|h
condition|;
operator|++
name|p
control|)
continue|continue;
return|return
name|p
operator|-
name|elf_sym_hashes
argument_list|(
name|obj
argument_list|)
operator|+
name|elf_tdata
argument_list|(
name|obj
argument_list|)
operator|->
name|symtab_hdr
operator|.
name|sh_info
return|;
block|}
end_function

begin_comment
comment|/* Allocate function descriptors.  We can do these for every function    in a main executable that is not exported.  */
end_comment

begin_function
specifier|static
name|boolean
name|allocate_fptr
parameter_list|(
name|dyn_i
parameter_list|,
name|data
parameter_list|)
name|struct
name|elfNN_ia64_dyn_sym_info
modifier|*
name|dyn_i
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
name|struct
name|elfNN_ia64_allocate_data
modifier|*
name|x
init|=
operator|(
expr|struct
name|elfNN_ia64_allocate_data
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|dyn_i
operator|->
name|want_fptr
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
init|=
name|dyn_i
operator|->
name|h
decl_stmt|;
if|if
condition|(
name|h
condition|)
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|x
operator|->
name|info
operator|->
name|shared
condition|)
block|{
if|if
condition|(
name|h
operator|&&
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
block|{
name|BFD_ASSERT
argument_list|(
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|)
operator|||
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|_bfd_elfNN_link_record_local_dynamic_symbol
argument_list|(
name|x
operator|->
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
argument_list|,
name|global_sym_index
argument_list|(
name|h
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
block|}
name|dyn_i
operator|->
name|want_fptr
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
block|{
name|dyn_i
operator|->
name|fptr_offset
operator|=
name|x
operator|->
name|ofs
expr_stmt|;
name|x
operator|->
name|ofs
operator|+=
literal|16
expr_stmt|;
block|}
else|else
name|dyn_i
operator|->
name|want_fptr
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Allocate all the minimal PLT entries.  */
end_comment

begin_function
specifier|static
name|boolean
name|allocate_plt_entries
parameter_list|(
name|dyn_i
parameter_list|,
name|data
parameter_list|)
name|struct
name|elfNN_ia64_dyn_sym_info
modifier|*
name|dyn_i
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
name|struct
name|elfNN_ia64_allocate_data
modifier|*
name|x
init|=
operator|(
expr|struct
name|elfNN_ia64_allocate_data
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|dyn_i
operator|->
name|want_plt
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
init|=
name|dyn_i
operator|->
name|h
decl_stmt|;
if|if
condition|(
name|h
condition|)
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
comment|/* ??? Versioned symbols seem to lose ELF_LINK_HASH_NEEDS_PLT.  */
if|if
condition|(
name|elfNN_ia64_dynamic_symbol_p
argument_list|(
name|h
argument_list|,
name|x
operator|->
name|info
argument_list|)
condition|)
block|{
name|bfd_size_type
name|offset
init|=
name|x
operator|->
name|ofs
decl_stmt|;
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
name|offset
operator|=
name|PLT_HEADER_SIZE
expr_stmt|;
name|dyn_i
operator|->
name|plt_offset
operator|=
name|offset
expr_stmt|;
name|x
operator|->
name|ofs
operator|=
name|offset
operator|+
name|PLT_MIN_ENTRY_SIZE
expr_stmt|;
name|dyn_i
operator|->
name|want_pltoff
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|dyn_i
operator|->
name|want_plt
operator|=
literal|0
expr_stmt|;
name|dyn_i
operator|->
name|want_plt2
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Allocate all the full PLT entries.  */
end_comment

begin_function
specifier|static
name|boolean
name|allocate_plt2_entries
parameter_list|(
name|dyn_i
parameter_list|,
name|data
parameter_list|)
name|struct
name|elfNN_ia64_dyn_sym_info
modifier|*
name|dyn_i
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
name|struct
name|elfNN_ia64_allocate_data
modifier|*
name|x
init|=
operator|(
expr|struct
name|elfNN_ia64_allocate_data
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|dyn_i
operator|->
name|want_plt2
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
init|=
name|dyn_i
operator|->
name|h
decl_stmt|;
name|bfd_size_type
name|ofs
init|=
name|x
operator|->
name|ofs
decl_stmt|;
name|dyn_i
operator|->
name|plt2_offset
operator|=
name|ofs
expr_stmt|;
name|x
operator|->
name|ofs
operator|=
name|ofs
operator|+
name|PLT_FULL_ENTRY_SIZE
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|dyn_i
operator|->
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
name|ofs
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Allocate all the PLTOFF entries requested by relocations and    plt entries.  We can't share space with allocated FPTR entries,    because the latter are not necessarily addressable by the GP.    ??? Relaxation might be able to determine that they are.  */
end_comment

begin_function
specifier|static
name|boolean
name|allocate_pltoff_entries
parameter_list|(
name|dyn_i
parameter_list|,
name|data
parameter_list|)
name|struct
name|elfNN_ia64_dyn_sym_info
modifier|*
name|dyn_i
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
name|struct
name|elfNN_ia64_allocate_data
modifier|*
name|x
init|=
operator|(
expr|struct
name|elfNN_ia64_allocate_data
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|dyn_i
operator|->
name|want_pltoff
condition|)
block|{
name|dyn_i
operator|->
name|pltoff_offset
operator|=
name|x
operator|->
name|ofs
expr_stmt|;
name|x
operator|->
name|ofs
operator|+=
literal|16
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Allocate dynamic relocations for those symbols that turned out    to be dynamic.  */
end_comment

begin_function
specifier|static
name|boolean
name|allocate_dynrel_entries
parameter_list|(
name|dyn_i
parameter_list|,
name|data
parameter_list|)
name|struct
name|elfNN_ia64_dyn_sym_info
modifier|*
name|dyn_i
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
name|struct
name|elfNN_ia64_allocate_data
modifier|*
name|x
init|=
operator|(
expr|struct
name|elfNN_ia64_allocate_data
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|elfNN_ia64_link_hash_table
modifier|*
name|ia64_info
decl_stmt|;
name|struct
name|elfNN_ia64_dyn_reloc_entry
modifier|*
name|rent
decl_stmt|;
name|boolean
name|dynamic_symbol
decl_stmt|,
name|shared
decl_stmt|;
name|ia64_info
operator|=
name|elfNN_ia64_hash_table
argument_list|(
name|x
operator|->
name|info
argument_list|)
expr_stmt|;
name|dynamic_symbol
operator|=
name|elfNN_ia64_dynamic_symbol_p
argument_list|(
name|dyn_i
operator|->
name|h
argument_list|,
name|x
operator|->
name|info
argument_list|)
expr_stmt|;
name|shared
operator|=
name|x
operator|->
name|info
operator|->
name|shared
expr_stmt|;
comment|/* Take care of the normal data relocations.  */
for|for
control|(
name|rent
operator|=
name|dyn_i
operator|->
name|reloc_entries
init|;
name|rent
condition|;
name|rent
operator|=
name|rent
operator|->
name|next
control|)
block|{
name|int
name|count
init|=
name|rent
operator|->
name|count
decl_stmt|;
switch|switch
condition|(
name|rent
operator|->
name|type
condition|)
block|{
case|case
name|R_IA64_FPTR64LSB
case|:
comment|/* Allocate one iff !want_fptr, which by this point will 	     be true only if we're actually allocating one statically 	     in the main executable.  */
if|if
condition|(
name|dyn_i
operator|->
name|want_fptr
condition|)
continue|continue;
break|break;
case|case
name|R_IA64_PCREL64LSB
case|:
if|if
condition|(
operator|!
name|dynamic_symbol
condition|)
continue|continue;
break|break;
case|case
name|R_IA64_DIR64LSB
case|:
if|if
condition|(
operator|!
name|dynamic_symbol
operator|&&
operator|!
name|shared
condition|)
continue|continue;
break|break;
case|case
name|R_IA64_IPLTLSB
case|:
if|if
condition|(
operator|!
name|dynamic_symbol
operator|&&
operator|!
name|shared
condition|)
continue|continue;
comment|/* Use two REL relocations for IPLT relocations 	     against local symbols.  */
if|if
condition|(
operator|!
name|dynamic_symbol
condition|)
name|count
operator|*=
literal|2
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|rent
operator|->
name|srel
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|ElfNN_External_Rela
argument_list|)
operator|*
name|count
expr_stmt|;
block|}
comment|/* Take care of the GOT and PLT relocations.  */
if|if
condition|(
operator|(
operator|(
name|dynamic_symbol
operator|||
name|shared
operator|)
operator|&&
name|dyn_i
operator|->
name|want_got
operator|)
operator|||
operator|(
name|dyn_i
operator|->
name|want_ltoff_fptr
operator|&&
name|dyn_i
operator|->
name|h
operator|&&
name|dyn_i
operator|->
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|)
condition|)
name|ia64_info
operator|->
name|rel_got_sec
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|ElfNN_External_Rela
argument_list|)
expr_stmt|;
if|if
condition|(
name|dyn_i
operator|->
name|want_pltoff
condition|)
block|{
name|bfd_size_type
name|t
init|=
literal|0
decl_stmt|;
comment|/* Dynamic symbols get one IPLT relocation.  Local symbols in 	 shared libraries get two REL relocations.  Local symbols in 	 main applications get nothing.  */
if|if
condition|(
name|dynamic_symbol
condition|)
name|t
operator|=
sizeof|sizeof
argument_list|(
name|ElfNN_External_Rela
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|shared
condition|)
name|t
operator|=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|ElfNN_External_Rela
argument_list|)
expr_stmt|;
name|ia64_info
operator|->
name|rel_pltoff_sec
operator|->
name|_raw_size
operator|+=
name|t
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|elfNN_ia64_adjust_dynamic_symbol
parameter_list|(
name|info
parameter_list|,
name|h
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
block|{
comment|/* ??? Undefined symbols with PLT entries should be re-defined      to be the PLT entry.  */
comment|/* If this is a weak symbol, and there is a real definition, the      processor independent code will have arranged for us to see the      real definition first, and we can just use the same value.  */
if|if
condition|(
name|h
operator|->
name|weakdef
operator|!=
name|NULL
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
argument_list|)
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* If this is a reference to a symbol defined by a dynamic object which      is not a function, we might allocate the symbol in our .dynbss section      and allocate a COPY dynamic relocation.       But IA-64 code is canonically PIC, so as a rule we can avoid this sort      of hackery.  */
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|elfNN_ia64_size_dynamic_sections
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|struct
name|elfNN_ia64_allocate_data
name|data
decl_stmt|;
name|struct
name|elfNN_ia64_link_hash_table
modifier|*
name|ia64_info
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|boolean
name|reltext
init|=
name|false
decl_stmt|;
name|boolean
name|relplt
init|=
name|false
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|ia64_info
operator|=
name|elfNN_ia64_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|dynobj
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|data
operator|.
name|info
operator|=
name|info
expr_stmt|;
comment|/* Set the contents of the .interp section to the interpreter.  */
if|if
condition|(
name|ia64_info
operator|->
name|root
operator|.
name|dynamic_sections_created
operator|&&
operator|!
name|info
operator|->
name|shared
condition|)
block|{
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".interp"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sec
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|sec
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|ELF_DYNAMIC_INTERPRETER
expr_stmt|;
name|sec
operator|->
name|_raw_size
operator|=
name|strlen
argument_list|(
name|ELF_DYNAMIC_INTERPRETER
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
comment|/* Allocate the GOT entries.  */
if|if
condition|(
name|ia64_info
operator|->
name|got_sec
condition|)
block|{
name|data
operator|.
name|ofs
operator|=
literal|0
expr_stmt|;
name|elfNN_ia64_dyn_sym_traverse
argument_list|(
name|ia64_info
argument_list|,
name|allocate_global_data_got
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
name|elfNN_ia64_dyn_sym_traverse
argument_list|(
name|ia64_info
argument_list|,
name|allocate_global_fptr_got
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
name|elfNN_ia64_dyn_sym_traverse
argument_list|(
name|ia64_info
argument_list|,
name|allocate_local_got
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
name|ia64_info
operator|->
name|got_sec
operator|->
name|_raw_size
operator|=
name|data
operator|.
name|ofs
expr_stmt|;
block|}
comment|/* Allocate the FPTR entries.  */
if|if
condition|(
name|ia64_info
operator|->
name|fptr_sec
condition|)
block|{
name|data
operator|.
name|ofs
operator|=
literal|0
expr_stmt|;
name|elfNN_ia64_dyn_sym_traverse
argument_list|(
name|ia64_info
argument_list|,
name|allocate_fptr
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
name|ia64_info
operator|->
name|fptr_sec
operator|->
name|_raw_size
operator|=
name|data
operator|.
name|ofs
expr_stmt|;
block|}
comment|/* Now that we've seen all of the input files, we can decide which      symbols need plt entries.  Allocate the minimal PLT entries first.      We do this even though dynamic_sections_created may be false, because      this has the side-effect of clearing want_plt and want_plt2.  */
name|data
operator|.
name|ofs
operator|=
literal|0
expr_stmt|;
name|elfNN_ia64_dyn_sym_traverse
argument_list|(
name|ia64_info
argument_list|,
name|allocate_plt_entries
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
name|ia64_info
operator|->
name|minplt_entries
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|data
operator|.
name|ofs
condition|)
block|{
name|ia64_info
operator|->
name|minplt_entries
operator|=
operator|(
name|data
operator|.
name|ofs
operator|-
name|PLT_HEADER_SIZE
operator|)
operator|/
name|PLT_MIN_ENTRY_SIZE
expr_stmt|;
block|}
comment|/* Align the pointer for the plt2 entries.  */
name|data
operator|.
name|ofs
operator|=
operator|(
name|data
operator|.
name|ofs
operator|+
literal|31
operator|)
operator|&
operator|-
literal|32
expr_stmt|;
name|elfNN_ia64_dyn_sym_traverse
argument_list|(
name|ia64_info
argument_list|,
name|allocate_plt2_entries
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|.
name|ofs
operator|!=
literal|0
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|ia64_info
operator|->
name|root
operator|.
name|dynamic_sections_created
argument_list|)
expr_stmt|;
name|ia64_info
operator|->
name|plt_sec
operator|->
name|_raw_size
operator|=
name|data
operator|.
name|ofs
expr_stmt|;
comment|/* If we've got a .plt, we need some extra memory for the dynamic 	 linker.  We stuff these in .got.plt.  */
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got.plt"
argument_list|)
expr_stmt|;
name|sec
operator|->
name|_raw_size
operator|=
literal|8
operator|*
name|PLT_RESERVED_WORDS
expr_stmt|;
block|}
comment|/* Allocate the PLTOFF entries.  */
if|if
condition|(
name|ia64_info
operator|->
name|pltoff_sec
condition|)
block|{
name|data
operator|.
name|ofs
operator|=
literal|0
expr_stmt|;
name|elfNN_ia64_dyn_sym_traverse
argument_list|(
name|ia64_info
argument_list|,
name|allocate_pltoff_entries
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
name|ia64_info
operator|->
name|pltoff_sec
operator|->
name|_raw_size
operator|=
name|data
operator|.
name|ofs
expr_stmt|;
block|}
if|if
condition|(
name|ia64_info
operator|->
name|root
operator|.
name|dynamic_sections_created
condition|)
block|{
comment|/* Allocate space for the dynamic relocations that turned out to be 	 required.  */
name|elfNN_ia64_dyn_sym_traverse
argument_list|(
name|ia64_info
argument_list|,
name|allocate_dynrel_entries
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
block|}
comment|/* We have now determined the sizes of the various dynamic sections.      Allocate memory for them.  */
for|for
control|(
name|sec
operator|=
name|dynobj
operator|->
name|sections
init|;
name|sec
operator|!=
name|NULL
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
block|{
name|boolean
name|strip
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_LINKER_CREATED
operator|)
condition|)
continue|continue;
comment|/* If we don't need this section, strip it from the output file. 	 There were several sections primarily related to dynamic 	 linking that must be create before the linker maps input 	 sections to output sections.  The linker does that before 	 bfd_elf_size_dynamic_sections is called, and it is that 	 function which decides whether anything needs to go into 	 these sections.  */
name|strip
operator|=
operator|(
name|sec
operator|->
name|_raw_size
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|ia64_info
operator|->
name|got_sec
condition|)
name|strip
operator|=
name|false
expr_stmt|;
elseif|else
if|if
condition|(
name|sec
operator|==
name|ia64_info
operator|->
name|rel_got_sec
condition|)
block|{
if|if
condition|(
name|strip
condition|)
name|ia64_info
operator|->
name|rel_got_sec
operator|=
name|NULL
expr_stmt|;
else|else
comment|/* We use the reloc_count field as a counter if we need to 	       copy relocs into the output file.  */
name|sec
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sec
operator|==
name|ia64_info
operator|->
name|fptr_sec
condition|)
block|{
if|if
condition|(
name|strip
condition|)
name|ia64_info
operator|->
name|fptr_sec
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sec
operator|==
name|ia64_info
operator|->
name|plt_sec
condition|)
block|{
if|if
condition|(
name|strip
condition|)
name|ia64_info
operator|->
name|plt_sec
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sec
operator|==
name|ia64_info
operator|->
name|pltoff_sec
condition|)
block|{
if|if
condition|(
name|strip
condition|)
name|ia64_info
operator|->
name|pltoff_sec
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sec
operator|==
name|ia64_info
operator|->
name|rel_pltoff_sec
condition|)
block|{
if|if
condition|(
name|strip
condition|)
name|ia64_info
operator|->
name|rel_pltoff_sec
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|relplt
operator|=
name|true
expr_stmt|;
comment|/* We use the reloc_count field as a counter if we need to 		 copy relocs into the output file.  */
name|sec
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* It's OK to base decisions on the section name, because none 	     of the dynobj section names depend upon the input files.  */
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|dynobj
argument_list|,
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".got.plt"
argument_list|)
operator|==
literal|0
condition|)
name|strip
operator|=
name|false
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".rel"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|strip
condition|)
block|{
specifier|const
name|char
modifier|*
name|outname
decl_stmt|;
name|asection
modifier|*
name|target
decl_stmt|;
comment|/* If this relocation section applies to a read only 		     section, then we probably need a DT_TEXTREL entry.  */
name|outname
operator|=
name|bfd_get_section_name
argument_list|(
name|output_bfd
argument_list|,
name|sec
operator|->
name|output_section
argument_list|)
expr_stmt|;
if|if
condition|(
name|outname
index|[
literal|4
index|]
operator|==
literal|'a'
condition|)
name|outname
operator|+=
literal|5
expr_stmt|;
else|else
name|outname
operator|+=
literal|4
expr_stmt|;
name|target
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
name|outname
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|!=
name|NULL
operator|&&
operator|(
name|target
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|target
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
name|reltext
operator|=
name|true
expr_stmt|;
comment|/* We use the reloc_count field as a counter if we need to 		     copy relocs into the output file.  */
name|sec
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
continue|continue;
block|}
if|if
condition|(
name|strip
condition|)
name|_bfd_strip_section_from_output
argument_list|(
name|info
argument_list|,
name|sec
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Allocate memory for the section contents.  */
name|sec
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|dynobj
argument_list|,
name|sec
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|contents
operator|==
name|NULL
operator|&&
name|sec
operator|->
name|_raw_size
operator|!=
literal|0
condition|)
return|return
name|false
return|;
block|}
block|}
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
comment|/* Add some entries to the .dynamic section.  We fill in the values 	 later (in finish_dynamic_sections) but we must add the entries now 	 so that we get the correct size for the .dynamic section.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
comment|/* The DT_DEBUG entry is filled in by the dynamic linker and used 	     by the debugger.  */
if|if
condition|(
operator|!
name|bfd_elfNN_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_DEBUG
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|bfd_elfNN_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_IA_64_PLT_RESERVE
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|bfd_elfNN_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_PLTGOT
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|relplt
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elfNN_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_PLTRELSZ
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|bfd_elfNN_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_PLTREL
argument_list|,
name|DT_RELA
argument_list|)
operator|||
operator|!
name|bfd_elfNN_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_JMPREL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|bfd_elfNN_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_RELA
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|bfd_elfNN_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_RELASZ
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|bfd_elfNN_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_RELAENT
argument_list|,
sizeof|sizeof
argument_list|(
name|ElfNN_External_Rela
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|reltext
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elfNN_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_TEXTREL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
name|info
operator|->
name|flags
operator||=
name|DF_TEXTREL
expr_stmt|;
block|}
block|}
comment|/* ??? Perhaps force __gp local.  */
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_status_type
name|elfNN_ia64_install_value
parameter_list|(
name|abfd
parameter_list|,
name|hit_addr
parameter_list|,
name|val
parameter_list|,
name|r_type
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|bfd_byte
modifier|*
name|hit_addr
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
name|unsigned
name|int
name|r_type
decl_stmt|;
block|{
specifier|const
name|struct
name|ia64_operand
modifier|*
name|op
decl_stmt|;
name|int
name|bigendian
init|=
literal|0
decl_stmt|,
name|shift
init|=
literal|0
decl_stmt|;
name|bfd_vma
name|t0
decl_stmt|,
name|t1
decl_stmt|,
name|insn
decl_stmt|,
name|dword
decl_stmt|;
name|enum
name|ia64_opnd
name|opnd
decl_stmt|;
specifier|const
name|char
modifier|*
name|err
decl_stmt|;
name|size_t
name|size
init|=
literal|8
decl_stmt|;
name|opnd
operator|=
name|IA64_OPND_NIL
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_IA64_NONE
case|:
case|case
name|R_IA64_LDXMOV
case|:
return|return
name|bfd_reloc_ok
return|;
comment|/* Instruction relocations.  */
case|case
name|R_IA64_IMM14
case|:
name|opnd
operator|=
name|IA64_OPND_IMM14
expr_stmt|;
break|break;
case|case
name|R_IA64_PCREL21F
case|:
name|opnd
operator|=
name|IA64_OPND_TGT25
expr_stmt|;
break|break;
case|case
name|R_IA64_PCREL21M
case|:
name|opnd
operator|=
name|IA64_OPND_TGT25b
expr_stmt|;
break|break;
case|case
name|R_IA64_PCREL60B
case|:
name|opnd
operator|=
name|IA64_OPND_TGT64
expr_stmt|;
break|break;
case|case
name|R_IA64_PCREL21B
case|:
case|case
name|R_IA64_PCREL21BI
case|:
name|opnd
operator|=
name|IA64_OPND_TGT25c
expr_stmt|;
break|break;
case|case
name|R_IA64_IMM22
case|:
case|case
name|R_IA64_GPREL22
case|:
case|case
name|R_IA64_LTOFF22
case|:
case|case
name|R_IA64_LTOFF22X
case|:
case|case
name|R_IA64_PLTOFF22
case|:
case|case
name|R_IA64_PCREL22
case|:
case|case
name|R_IA64_LTOFF_FPTR22
case|:
name|opnd
operator|=
name|IA64_OPND_IMM22
expr_stmt|;
break|break;
case|case
name|R_IA64_IMM64
case|:
case|case
name|R_IA64_GPREL64I
case|:
case|case
name|R_IA64_LTOFF64I
case|:
case|case
name|R_IA64_PLTOFF64I
case|:
case|case
name|R_IA64_PCREL64I
case|:
case|case
name|R_IA64_FPTR64I
case|:
case|case
name|R_IA64_LTOFF_FPTR64I
case|:
name|opnd
operator|=
name|IA64_OPND_IMMU64
expr_stmt|;
break|break;
comment|/* Data relocations.  */
case|case
name|R_IA64_DIR32MSB
case|:
case|case
name|R_IA64_GPREL32MSB
case|:
case|case
name|R_IA64_FPTR32MSB
case|:
case|case
name|R_IA64_PCREL32MSB
case|:
case|case
name|R_IA64_SEGREL32MSB
case|:
case|case
name|R_IA64_SECREL32MSB
case|:
case|case
name|R_IA64_LTV32MSB
case|:
name|size
operator|=
literal|4
expr_stmt|;
name|bigendian
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|R_IA64_DIR32LSB
case|:
case|case
name|R_IA64_GPREL32LSB
case|:
case|case
name|R_IA64_FPTR32LSB
case|:
case|case
name|R_IA64_PCREL32LSB
case|:
case|case
name|R_IA64_SEGREL32LSB
case|:
case|case
name|R_IA64_SECREL32LSB
case|:
case|case
name|R_IA64_LTV32LSB
case|:
name|size
operator|=
literal|4
expr_stmt|;
name|bigendian
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|R_IA64_DIR64MSB
case|:
case|case
name|R_IA64_GPREL64MSB
case|:
case|case
name|R_IA64_PLTOFF64MSB
case|:
case|case
name|R_IA64_FPTR64MSB
case|:
case|case
name|R_IA64_PCREL64MSB
case|:
case|case
name|R_IA64_LTOFF_FPTR64MSB
case|:
case|case
name|R_IA64_SEGREL64MSB
case|:
case|case
name|R_IA64_SECREL64MSB
case|:
case|case
name|R_IA64_LTV64MSB
case|:
name|size
operator|=
literal|8
expr_stmt|;
name|bigendian
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|R_IA64_DIR64LSB
case|:
case|case
name|R_IA64_GPREL64LSB
case|:
case|case
name|R_IA64_PLTOFF64LSB
case|:
case|case
name|R_IA64_FPTR64LSB
case|:
case|case
name|R_IA64_PCREL64LSB
case|:
case|case
name|R_IA64_LTOFF_FPTR64LSB
case|:
case|case
name|R_IA64_SEGREL64LSB
case|:
case|case
name|R_IA64_SECREL64LSB
case|:
case|case
name|R_IA64_LTV64LSB
case|:
name|size
operator|=
literal|8
expr_stmt|;
name|bigendian
operator|=
literal|0
expr_stmt|;
break|break;
comment|/* Unsupported / Dynamic relocations.  */
default|default:
return|return
name|bfd_reloc_notsupported
return|;
block|}
switch|switch
condition|(
name|opnd
condition|)
block|{
case|case
name|IA64_OPND_IMMU64
case|:
name|hit_addr
operator|-=
operator|(
name|long
operator|)
name|hit_addr
operator|&
literal|0x3
expr_stmt|;
name|t0
operator|=
name|bfd_get_64
argument_list|(
name|abfd
argument_list|,
name|hit_addr
argument_list|)
expr_stmt|;
name|t1
operator|=
name|bfd_get_64
argument_list|(
name|abfd
argument_list|,
name|hit_addr
operator|+
literal|8
argument_list|)
expr_stmt|;
comment|/* tmpl/s: bits  0.. 5 in t0 	 slot 0: bits  5..45 in t0 	 slot 1: bits 46..63 in t0, bits 0..22 in t1 	 slot 2: bits 23..63 in t1 */
comment|/* First, clear the bits that form the 64 bit constant.  */
name|t0
operator|&=
operator|~
operator|(
literal|0x3ffffLL
operator|<<
literal|46
operator|)
expr_stmt|;
name|t1
operator|&=
operator|~
operator|(
literal|0x7fffffLL
operator||
operator|(
operator|(
operator|(
literal|0x07fLL
operator|<<
literal|13
operator|)
operator||
operator|(
literal|0x1ffLL
operator|<<
literal|27
operator|)
operator||
operator|(
literal|0x01fLL
operator|<<
literal|22
operator|)
operator||
operator|(
literal|0x001LL
operator|<<
literal|21
operator|)
operator||
operator|(
literal|0x001LL
operator|<<
literal|36
operator|)
operator|)
operator|<<
literal|23
operator|)
operator|)
expr_stmt|;
name|t0
operator||=
operator|(
operator|(
name|val
operator|>>
literal|22
operator|)
operator|&
literal|0x03ffffLL
operator|)
operator|<<
literal|46
expr_stmt|;
comment|/* 18 lsbs of imm41 */
name|t1
operator||=
operator|(
operator|(
name|val
operator|>>
literal|40
operator|)
operator|&
literal|0x7fffffLL
operator|)
operator|<<
literal|0
expr_stmt|;
comment|/* 23 msbs of imm41 */
name|t1
operator||=
operator|(
operator|(
operator|(
operator|(
name|val
operator|>>
literal|0
operator|)
operator|&
literal|0x07f
operator|)
operator|<<
literal|13
operator|)
comment|/* imm7b */
operator||
operator|(
operator|(
operator|(
name|val
operator|>>
literal|7
operator|)
operator|&
literal|0x1ff
operator|)
operator|<<
literal|27
operator|)
comment|/* imm9d */
operator||
operator|(
operator|(
operator|(
name|val
operator|>>
literal|16
operator|)
operator|&
literal|0x01f
operator|)
operator|<<
literal|22
operator|)
comment|/* imm5c */
operator||
operator|(
operator|(
operator|(
name|val
operator|>>
literal|21
operator|)
operator|&
literal|0x001
operator|)
operator|<<
literal|21
operator|)
comment|/* ic */
operator||
operator|(
operator|(
operator|(
name|val
operator|>>
literal|63
operator|)
operator|&
literal|0x001
operator|)
operator|<<
literal|36
operator|)
operator|)
operator|<<
literal|23
expr_stmt|;
comment|/* i */
name|bfd_put_64
argument_list|(
name|abfd
argument_list|,
name|t0
argument_list|,
name|hit_addr
argument_list|)
expr_stmt|;
name|bfd_put_64
argument_list|(
name|abfd
argument_list|,
name|t1
argument_list|,
name|hit_addr
operator|+
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
name|IA64_OPND_TGT64
case|:
name|hit_addr
operator|-=
operator|(
name|long
operator|)
name|hit_addr
operator|&
literal|0x3
expr_stmt|;
name|t0
operator|=
name|bfd_get_64
argument_list|(
name|abfd
argument_list|,
name|hit_addr
argument_list|)
expr_stmt|;
name|t1
operator|=
name|bfd_get_64
argument_list|(
name|abfd
argument_list|,
name|hit_addr
operator|+
literal|8
argument_list|)
expr_stmt|;
comment|/* tmpl/s: bits  0.. 5 in t0 	 slot 0: bits  5..45 in t0 	 slot 1: bits 46..63 in t0, bits 0..22 in t1 	 slot 2: bits 23..63 in t1 */
comment|/* First, clear the bits that form the 64 bit constant.  */
name|t0
operator|&=
operator|~
operator|(
literal|0x3ffffLL
operator|<<
literal|46
operator|)
expr_stmt|;
name|t1
operator|&=
operator|~
operator|(
literal|0x7fffffLL
operator||
operator|(
operator|(
literal|1LL
operator|<<
literal|36
operator||
literal|0xfffffLL
operator|<<
literal|13
operator|)
operator|<<
literal|23
operator|)
operator|)
expr_stmt|;
name|val
operator|>>=
literal|4
expr_stmt|;
name|t0
operator||=
operator|(
operator|(
name|val
operator|>>
literal|20
operator|)
operator|&
literal|0xffffLL
operator|)
operator|<<
literal|2
operator|<<
literal|46
expr_stmt|;
comment|/* 16 lsbs of imm39 */
name|t1
operator||=
operator|(
operator|(
name|val
operator|>>
literal|36
operator|)
operator|&
literal|0x7fffffLL
operator|)
operator|<<
literal|0
expr_stmt|;
comment|/* 23 msbs of imm39 */
name|t1
operator||=
operator|(
operator|(
operator|(
operator|(
name|val
operator|>>
literal|0
operator|)
operator|&
literal|0xfffffLL
operator|)
operator|<<
literal|13
operator|)
comment|/* imm20b */
operator||
operator|(
operator|(
operator|(
name|val
operator|>>
literal|59
operator|)
operator|&
literal|0x1LL
operator|)
operator|<<
literal|36
operator|)
operator|)
operator|<<
literal|23
expr_stmt|;
comment|/* i */
name|bfd_put_64
argument_list|(
name|abfd
argument_list|,
name|t0
argument_list|,
name|hit_addr
argument_list|)
expr_stmt|;
name|bfd_put_64
argument_list|(
name|abfd
argument_list|,
name|t1
argument_list|,
name|hit_addr
operator|+
literal|8
argument_list|)
expr_stmt|;
break|break;
default|default:
switch|switch
condition|(
operator|(
name|long
operator|)
name|hit_addr
operator|&
literal|0x3
condition|)
block|{
case|case
literal|0
case|:
name|shift
operator|=
literal|5
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|shift
operator|=
literal|14
expr_stmt|;
name|hit_addr
operator|+=
literal|3
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|shift
operator|=
literal|23
expr_stmt|;
name|hit_addr
operator|+=
literal|6
expr_stmt|;
break|break;
case|case
literal|3
case|:
return|return
name|bfd_reloc_notsupported
return|;
comment|/* shouldn't happen...  */
block|}
name|dword
operator|=
name|bfd_get_64
argument_list|(
name|abfd
argument_list|,
name|hit_addr
argument_list|)
expr_stmt|;
name|insn
operator|=
operator|(
name|dword
operator|>>
name|shift
operator|)
operator|&
literal|0x1ffffffffffLL
expr_stmt|;
name|op
operator|=
name|elf64_ia64_operands
operator|+
name|opnd
expr_stmt|;
name|err
operator|=
call|(
modifier|*
name|op
operator|->
name|insert
call|)
argument_list|(
name|op
argument_list|,
name|val
argument_list|,
operator|&
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|bfd_reloc_overflow
return|;
name|dword
operator|&=
operator|~
operator|(
literal|0x1ffffffffffLL
operator|<<
name|shift
operator|)
expr_stmt|;
name|dword
operator||=
operator|(
name|insn
operator|<<
name|shift
operator|)
expr_stmt|;
name|bfd_put_64
argument_list|(
name|abfd
argument_list|,
name|dword
argument_list|,
name|hit_addr
argument_list|)
expr_stmt|;
break|break;
case|case
name|IA64_OPND_NIL
case|:
comment|/* A data relocation.  */
if|if
condition|(
name|bigendian
condition|)
if|if
condition|(
name|size
operator|==
literal|4
condition|)
name|bfd_putb32
argument_list|(
name|val
argument_list|,
name|hit_addr
argument_list|)
expr_stmt|;
else|else
name|bfd_putb64
argument_list|(
name|val
argument_list|,
name|hit_addr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|==
literal|4
condition|)
name|bfd_putl32
argument_list|(
name|val
argument_list|,
name|hit_addr
argument_list|)
expr_stmt|;
else|else
name|bfd_putl64
argument_list|(
name|val
argument_list|,
name|hit_addr
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|elfNN_ia64_install_dyn_reloc
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|sec
parameter_list|,
name|srel
parameter_list|,
name|offset
parameter_list|,
name|type
parameter_list|,
name|dynindx
parameter_list|,
name|addend
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|asection
modifier|*
name|srel
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
name|unsigned
name|int
name|type
decl_stmt|;
name|long
name|dynindx
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|;
block|{
name|Elf_Internal_Rela
name|outrel
decl_stmt|;
name|outrel
operator|.
name|r_offset
operator|=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|offset
operator|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|dynindx
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELFNN_R_INFO
argument_list|(
name|dynindx
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
name|addend
expr_stmt|;
if|if
condition|(
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|stab_info
operator|!=
name|NULL
condition|)
block|{
comment|/* This may be NULL for linker-generated relocations, as it is 	 inconvenient to pass all the bits around.  And this shouldn't 	 happen.  */
name|BFD_ASSERT
argument_list|(
name|info
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|(
name|_bfd_stab_section_offset
argument_list|(
name|abfd
argument_list|,
operator|&
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|stab_info
argument_list|,
name|sec
argument_list|,
operator|&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|stab_info
argument_list|,
name|offset
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
comment|/* Run for the hills.  We shouldn't be outputting a relocation 	     for this.  So do what everyone else does and output a no-op.  */
name|outrel
operator|.
name|r_info
operator|=
name|ELFNN_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_IA64_NONE
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
block|}
name|outrel
operator|.
name|r_offset
operator|=
name|offset
expr_stmt|;
block|}
name|bfd_elfNN_swap_reloca_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|outrel
argument_list|,
operator|(
operator|(
name|ElfNN_External_Rela
operator|*
operator|)
name|srel
operator|->
name|contents
operator|+
name|srel
operator|->
name|reloc_count
operator|++
operator|)
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
sizeof|sizeof
argument_list|(
name|ElfNN_External_Rela
argument_list|)
operator|*
name|srel
operator|->
name|reloc_count
operator|<=
name|srel
operator|->
name|_cooked_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store an entry for target address TARGET_ADDR in the linkage table    and return the gp-relative address of the linkage table entry.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|set_got_entry
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|dyn_i
parameter_list|,
name|dynindx
parameter_list|,
name|addend
parameter_list|,
name|value
parameter_list|,
name|dyn_r_type
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|elfNN_ia64_dyn_sym_info
modifier|*
name|dyn_i
decl_stmt|;
name|long
name|dynindx
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
name|unsigned
name|int
name|dyn_r_type
decl_stmt|;
block|{
name|struct
name|elfNN_ia64_link_hash_table
modifier|*
name|ia64_info
decl_stmt|;
name|asection
modifier|*
name|got_sec
decl_stmt|;
name|ia64_info
operator|=
name|elfNN_ia64_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|got_sec
operator|=
name|ia64_info
operator|->
name|got_sec
expr_stmt|;
name|BFD_ASSERT
argument_list|(
operator|(
name|dyn_i
operator|->
name|got_offset
operator|&
literal|7
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dyn_i
operator|->
name|got_done
condition|)
block|{
name|dyn_i
operator|->
name|got_done
operator|=
name|true
expr_stmt|;
comment|/* Store the target address in the linkage table entry.  */
name|bfd_put_64
argument_list|(
name|abfd
argument_list|,
name|value
argument_list|,
name|got_sec
operator|->
name|contents
operator|+
name|dyn_i
operator|->
name|got_offset
argument_list|)
expr_stmt|;
comment|/* Install a dynamic relocation if needed.  */
if|if
condition|(
name|info
operator|->
name|shared
operator|||
name|elfNN_ia64_dynamic_symbol_p
argument_list|(
name|dyn_i
operator|->
name|h
argument_list|,
name|info
argument_list|)
operator|||
operator|(
name|dynindx
operator|!=
operator|-
literal|1
operator|&&
name|dyn_r_type
operator|==
name|R_IA64_FPTR64LSB
operator|)
condition|)
block|{
if|if
condition|(
name|dynindx
operator|==
operator|-
literal|1
condition|)
block|{
name|dyn_r_type
operator|=
name|R_IA64_REL64LSB
expr_stmt|;
name|dynindx
operator|=
literal|0
expr_stmt|;
name|addend
operator|=
name|value
expr_stmt|;
block|}
if|if
condition|(
name|bfd_big_endian
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|dyn_r_type
condition|)
block|{
case|case
name|R_IA64_REL64LSB
case|:
name|dyn_r_type
operator|=
name|R_IA64_REL64MSB
expr_stmt|;
break|break;
case|case
name|R_IA64_DIR64LSB
case|:
name|dyn_r_type
operator|=
name|R_IA64_DIR64MSB
expr_stmt|;
break|break;
case|case
name|R_IA64_FPTR64LSB
case|:
name|dyn_r_type
operator|=
name|R_IA64_FPTR64MSB
expr_stmt|;
break|break;
default|default:
name|BFD_ASSERT
argument_list|(
name|false
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|elfNN_ia64_install_dyn_reloc
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|,
name|got_sec
argument_list|,
name|ia64_info
operator|->
name|rel_got_sec
argument_list|,
name|dyn_i
operator|->
name|got_offset
argument_list|,
name|dyn_r_type
argument_list|,
name|dynindx
argument_list|,
name|addend
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Return the address of the linkage table entry.  */
name|value
operator|=
operator|(
name|got_sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|got_sec
operator|->
name|output_offset
operator|+
name|dyn_i
operator|->
name|got_offset
operator|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* Fill in a function descriptor consisting of the function's code    address and its global pointer.  Return the descriptor's address.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|set_fptr_entry
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|dyn_i
parameter_list|,
name|value
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|elfNN_ia64_dyn_sym_info
modifier|*
name|dyn_i
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
block|{
name|struct
name|elfNN_ia64_link_hash_table
modifier|*
name|ia64_info
decl_stmt|;
name|asection
modifier|*
name|fptr_sec
decl_stmt|;
name|ia64_info
operator|=
name|elfNN_ia64_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|fptr_sec
operator|=
name|ia64_info
operator|->
name|fptr_sec
expr_stmt|;
if|if
condition|(
operator|!
name|dyn_i
operator|->
name|fptr_done
condition|)
block|{
name|dyn_i
operator|->
name|fptr_done
operator|=
literal|1
expr_stmt|;
comment|/* Fill in the function descriptor.  */
name|bfd_put_64
argument_list|(
name|abfd
argument_list|,
name|value
argument_list|,
name|fptr_sec
operator|->
name|contents
operator|+
name|dyn_i
operator|->
name|fptr_offset
argument_list|)
expr_stmt|;
name|bfd_put_64
argument_list|(
name|abfd
argument_list|,
name|_bfd_get_gp_value
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|fptr_sec
operator|->
name|contents
operator|+
name|dyn_i
operator|->
name|fptr_offset
operator|+
literal|8
argument_list|)
expr_stmt|;
block|}
comment|/* Return the descriptor's address.  */
name|value
operator|=
operator|(
name|fptr_sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|fptr_sec
operator|->
name|output_offset
operator|+
name|dyn_i
operator|->
name|fptr_offset
operator|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* Fill in a PLTOFF entry consisting of the function's code address    and its global pointer.  Return the descriptor's address.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|set_pltoff_entry
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|dyn_i
parameter_list|,
name|value
parameter_list|,
name|is_plt
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|elfNN_ia64_dyn_sym_info
modifier|*
name|dyn_i
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
name|boolean
name|is_plt
decl_stmt|;
block|{
name|struct
name|elfNN_ia64_link_hash_table
modifier|*
name|ia64_info
decl_stmt|;
name|asection
modifier|*
name|pltoff_sec
decl_stmt|;
name|ia64_info
operator|=
name|elfNN_ia64_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|pltoff_sec
operator|=
name|ia64_info
operator|->
name|pltoff_sec
expr_stmt|;
comment|/* Don't do anything if this symbol uses a real PLT entry.  In      that case, we'll fill this in during finish_dynamic_symbol.  */
if|if
condition|(
operator|(
operator|!
name|dyn_i
operator|->
name|want_plt
operator|||
name|is_plt
operator|)
operator|&&
operator|!
name|dyn_i
operator|->
name|pltoff_done
condition|)
block|{
name|bfd_vma
name|gp
init|=
name|_bfd_get_gp_value
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
comment|/* Fill in the function descriptor.  */
name|bfd_put_64
argument_list|(
name|abfd
argument_list|,
name|value
argument_list|,
name|pltoff_sec
operator|->
name|contents
operator|+
name|dyn_i
operator|->
name|pltoff_offset
argument_list|)
expr_stmt|;
name|bfd_put_64
argument_list|(
name|abfd
argument_list|,
name|gp
argument_list|,
name|pltoff_sec
operator|->
name|contents
operator|+
name|dyn_i
operator|->
name|pltoff_offset
operator|+
literal|8
argument_list|)
expr_stmt|;
comment|/* Install dynamic relocations if needed.  */
if|if
condition|(
operator|!
name|is_plt
operator|&&
name|info
operator|->
name|shared
condition|)
block|{
name|unsigned
name|int
name|dyn_r_type
decl_stmt|;
if|if
condition|(
name|bfd_big_endian
argument_list|(
name|abfd
argument_list|)
condition|)
name|dyn_r_type
operator|=
name|R_IA64_REL64MSB
expr_stmt|;
else|else
name|dyn_r_type
operator|=
name|R_IA64_REL64LSB
expr_stmt|;
name|elfNN_ia64_install_dyn_reloc
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|,
name|pltoff_sec
argument_list|,
name|ia64_info
operator|->
name|rel_pltoff_sec
argument_list|,
name|dyn_i
operator|->
name|pltoff_offset
argument_list|,
name|dyn_r_type
argument_list|,
literal|0
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|elfNN_ia64_install_dyn_reloc
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|,
name|pltoff_sec
argument_list|,
name|ia64_info
operator|->
name|rel_pltoff_sec
argument_list|,
name|dyn_i
operator|->
name|pltoff_offset
operator|+
literal|8
argument_list|,
name|dyn_r_type
argument_list|,
literal|0
argument_list|,
name|gp
argument_list|)
expr_stmt|;
block|}
name|dyn_i
operator|->
name|pltoff_done
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Return the descriptor's address.  */
name|value
operator|=
operator|(
name|pltoff_sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|pltoff_sec
operator|->
name|output_offset
operator|+
name|dyn_i
operator|->
name|pltoff_offset
operator|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* Called through qsort to sort the .IA_64.unwind section during a    non-relocatable link.  Set elfNN_ia64_unwind_entry_compare_bfd    to the output bfd so we can do proper endianness frobbing.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd
modifier|*
name|elfNN_ia64_unwind_entry_compare_bfd
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|elfNN_ia64_unwind_entry_compare
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|PTR
name|a
decl_stmt|;
name|PTR
name|b
decl_stmt|;
block|{
name|bfd_vma
name|av
decl_stmt|,
name|bv
decl_stmt|;
name|av
operator|=
name|bfd_get_64
argument_list|(
name|elfNN_ia64_unwind_entry_compare_bfd
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|bv
operator|=
name|bfd_get_64
argument_list|(
name|elfNN_ia64_unwind_entry_compare_bfd
argument_list|,
name|b
argument_list|)
expr_stmt|;
return|return
operator|(
name|av
operator|<
name|bv
condition|?
operator|-
literal|1
else|:
name|av
operator|>
name|bv
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|elfNN_ia64_final_link
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|struct
name|elfNN_ia64_link_hash_table
modifier|*
name|ia64_info
decl_stmt|;
name|asection
modifier|*
name|unwind_output_sec
decl_stmt|;
name|ia64_info
operator|=
name|elfNN_ia64_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* Make sure we've got ourselves a nice fat __gp value.  */
if|if
condition|(
operator|!
name|info
operator|->
name|relocateable
condition|)
block|{
name|bfd_vma
name|min_vma
init|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
decl_stmt|,
name|max_vma
init|=
literal|0
decl_stmt|;
name|bfd_vma
name|min_short_vma
init|=
name|min_vma
decl_stmt|,
name|max_short_vma
init|=
literal|0
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|gp
decl_stmt|;
name|bfd_vma
name|gp_val
decl_stmt|;
name|asection
modifier|*
name|os
decl_stmt|;
comment|/* Find the min and max vma of all sections marked short.  Also 	 collect min and max vma of any type, for use in selecting a 	 nice gp.  */
for|for
control|(
name|os
operator|=
name|abfd
operator|->
name|sections
init|;
name|os
condition|;
name|os
operator|=
name|os
operator|->
name|next
control|)
block|{
name|bfd_vma
name|lo
decl_stmt|,
name|hi
decl_stmt|;
if|if
condition|(
operator|(
name|os
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|lo
operator|=
name|os
operator|->
name|vma
expr_stmt|;
name|hi
operator|=
name|os
operator|->
name|vma
operator|+
name|os
operator|->
name|_raw_size
expr_stmt|;
if|if
condition|(
name|hi
operator|<
name|lo
condition|)
name|hi
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|min_vma
operator|>
name|lo
condition|)
name|min_vma
operator|=
name|lo
expr_stmt|;
if|if
condition|(
name|max_vma
operator|<
name|hi
condition|)
name|max_vma
operator|=
name|hi
expr_stmt|;
if|if
condition|(
name|os
operator|->
name|flags
operator|&
name|SEC_SMALL_DATA
condition|)
block|{
if|if
condition|(
name|min_short_vma
operator|>
name|lo
condition|)
name|min_short_vma
operator|=
name|lo
expr_stmt|;
if|if
condition|(
name|max_short_vma
operator|<
name|hi
condition|)
name|max_short_vma
operator|=
name|hi
expr_stmt|;
block|}
block|}
comment|/* See if the user wants to force a value.  */
name|gp
operator|=
name|elf_link_hash_lookup
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
literal|"__gp"
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|gp
operator|&&
operator|(
name|gp
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|gp
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
condition|)
block|{
name|asection
modifier|*
name|gp_sec
init|=
name|gp
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
decl_stmt|;
name|gp_val
operator|=
operator|(
name|gp
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|gp_sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|gp_sec
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Pick a sensible value.  */
name|asection
modifier|*
name|got_sec
init|=
name|ia64_info
operator|->
name|got_sec
decl_stmt|;
comment|/* Start with just the address of the .got.  */
if|if
condition|(
name|got_sec
condition|)
name|gp_val
operator|=
name|got_sec
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
elseif|else
if|if
condition|(
name|max_short_vma
operator|!=
literal|0
condition|)
name|gp_val
operator|=
name|min_short_vma
expr_stmt|;
else|else
name|gp_val
operator|=
name|min_vma
expr_stmt|;
comment|/* If it is possible to address the entire image, but we 	     don't with the choice above, adjust.  */
if|if
condition|(
name|max_vma
operator|-
name|min_vma
operator|<
literal|0x400000
operator|&&
name|max_vma
operator|-
name|gp_val
operator|<=
literal|0x200000
operator|&&
name|gp_val
operator|-
name|min_vma
operator|>
literal|0x200000
condition|)
name|gp_val
operator|=
name|min_vma
operator|+
literal|0x200000
expr_stmt|;
elseif|else
if|if
condition|(
name|max_short_vma
operator|!=
literal|0
condition|)
block|{
comment|/* If we don't cover all the short data, adjust.  */
if|if
condition|(
name|max_short_vma
operator|-
name|gp_val
operator|>=
literal|0x200000
condition|)
name|gp_val
operator|=
name|min_short_vma
operator|+
literal|0x200000
expr_stmt|;
comment|/* If we're addressing stuff past the end, adjust back.  */
if|if
condition|(
name|gp_val
operator|>
name|max_vma
condition|)
name|gp_val
operator|=
name|max_vma
operator|-
literal|0x200000
operator|+
literal|8
expr_stmt|;
block|}
block|}
comment|/* Validate whether all SHF_IA_64_SHORT sections are within 	 range of the chosen GP.  */
if|if
condition|(
name|max_short_vma
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|max_short_vma
operator|-
name|min_short_vma
operator|>=
literal|0x400000
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: short data segment overflowed (0x%lx>= 0x400000)"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|max_short_vma
operator|-
name|min_short_vma
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|gp_val
operator|>
name|min_short_vma
operator|&&
name|gp_val
operator|-
name|min_short_vma
operator|>
literal|0x200000
operator|)
operator|||
operator|(
name|gp_val
operator|<
name|max_short_vma
operator|&&
name|max_short_vma
operator|-
name|gp_val
operator|>=
literal|0x200000
operator|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: __gp does not cover short data segment"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
name|_bfd_set_gp_value
argument_list|(
name|abfd
argument_list|,
name|gp_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|gp
condition|)
block|{
name|gp
operator|->
name|root
operator|.
name|type
operator|=
name|bfd_link_hash_defined
expr_stmt|;
name|gp
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|gp_val
expr_stmt|;
name|gp
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
block|}
block|}
comment|/* If we're producing a final executable, we need to sort the contents      of the .IA_64.unwind section.  Force this section to be relocated      into memory rather than written immediately to the output file.  */
name|unwind_output_sec
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|relocateable
condition|)
block|{
name|asection
modifier|*
name|s
init|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|ELF_STRING_ia64_unwind
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
condition|)
block|{
name|unwind_output_sec
operator|=
name|s
operator|->
name|output_section
expr_stmt|;
name|unwind_output_sec
operator|->
name|contents
operator|=
name|bfd_malloc
argument_list|(
name|unwind_output_sec
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|unwind_output_sec
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|false
return|;
block|}
block|}
comment|/* Invoke the regular ELF backend linker to do all the work.  */
if|if
condition|(
operator|!
name|bfd_elfNN_bfd_final_link
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|unwind_output_sec
condition|)
block|{
name|elfNN_ia64_unwind_entry_compare_bfd
operator|=
name|abfd
expr_stmt|;
name|qsort
argument_list|(
name|unwind_output_sec
operator|->
name|contents
argument_list|,
name|unwind_output_sec
operator|->
name|_raw_size
operator|/
literal|24
argument_list|,
literal|24
argument_list|,
name|elfNN_ia64_unwind_entry_compare
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|unwind_output_sec
argument_list|,
name|unwind_output_sec
operator|->
name|contents
argument_list|,
literal|0
argument_list|,
name|unwind_output_sec
operator|->
name|_raw_size
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|elfNN_ia64_relocate_section
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|contents
parameter_list|,
name|relocs
parameter_list|,
name|local_syms
parameter_list|,
name|local_sections
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|local_syms
decl_stmt|;
name|asection
modifier|*
modifier|*
name|local_sections
decl_stmt|;
block|{
name|struct
name|elfNN_ia64_link_hash_table
modifier|*
name|ia64_info
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relend
decl_stmt|;
name|asection
modifier|*
name|srel
decl_stmt|;
name|boolean
name|ret_val
init|=
name|true
decl_stmt|;
comment|/* for non-fatal errors */
name|bfd_vma
name|gp_val
decl_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|ia64_info
operator|=
name|elfNN_ia64_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* Infect various flags from the input section to the output section.  */
if|if
condition|(
name|info
operator|->
name|relocateable
condition|)
block|{
name|bfd_vma
name|flags
decl_stmt|;
name|flags
operator|=
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_flags
expr_stmt|;
name|flags
operator|&=
name|SHF_IA_64_NORECOV
expr_stmt|;
name|elf_section_data
argument_list|(
name|input_section
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_flags
operator||=
name|flags
expr_stmt|;
block|}
name|gp_val
operator|=
name|_bfd_get_gp_value
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
name|srel
operator|=
name|get_reloc_section
argument_list|(
name|input_bfd
argument_list|,
name|ia64_info
argument_list|,
name|input_section
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|rel
operator|=
name|relocs
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|input_section
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|rel
operator|<
name|relend
condition|;
operator|++
name|rel
control|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|elfNN_ia64_dyn_sym_info
modifier|*
name|dyn_i
decl_stmt|;
name|bfd_reloc_status_type
name|r
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|unsigned
name|int
name|r_type
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
name|asection
modifier|*
name|sym_sec
decl_stmt|;
name|bfd_byte
modifier|*
name|hit_addr
decl_stmt|;
name|boolean
name|dynamic_symbol_p
decl_stmt|;
name|boolean
name|undef_weak_ref
decl_stmt|;
name|r_type
operator|=
name|ELFNN_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|>
name|R_IA64_MAX_RELOC_CODE
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: unknown relocation type %d"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|r_type
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|false
expr_stmt|;
continue|continue;
block|}
name|howto
operator|=
name|lookup_howto
argument_list|(
name|r_type
argument_list|)
expr_stmt|;
name|r_symndx
operator|=
name|ELFNN_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|relocateable
condition|)
block|{
comment|/* This is a relocateable link.  We don't have to change 	     anything, unless the reloc is against a section symbol, 	     in which case we have to adjust according to where the 	     section symbol winds up in the output section.  */
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_SECTION
condition|)
block|{
name|sym_sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|rel
operator|->
name|r_addend
operator|+=
name|sym_sec
operator|->
name|output_offset
expr_stmt|;
block|}
block|}
continue|continue;
block|}
comment|/* This is a final link.  */
name|h
operator|=
name|NULL
expr_stmt|;
name|sym
operator|=
name|NULL
expr_stmt|;
name|sym_sec
operator|=
name|NULL
expr_stmt|;
name|undef_weak_ref
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
comment|/* Reloc against local symbol.  */
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
name|sym_sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|value
operator|=
operator|(
name|sym_sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sym_sec
operator|->
name|output_offset
operator|+
name|sym
operator|->
name|st_value
operator|)
expr_stmt|;
block|}
else|else
block|{
name|long
name|indx
decl_stmt|;
comment|/* Reloc against global symbol.  */
name|indx
operator|=
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|h
operator|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
index|[
name|indx
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
block|{
name|sym_sec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
comment|/* Detect the cases that sym_sec->output_section is 		 expected to be NULL -- all cases in which the symbol 		 is defined in another shared module.  This includes 		 PLT relocs for which we've created a PLT entry and 		 other relocs for which we're prepared to create 		 dynamic relocations.  */
comment|/* ??? Just accept it NULL and continue.  */
if|if
condition|(
name|sym_sec
operator|->
name|output_section
operator|!=
name|NULL
condition|)
block|{
name|value
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|sym_sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sym_sec
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
name|undef_weak_ref
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
operator|!
name|info
operator|->
name|symbolic
operator|&&
operator|!
name|info
operator|->
name|no_undefined
operator|&&
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_DEFAULT
condition|)
empty_stmt|;
else|else
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
operator|(
operator|!
name|info
operator|->
name|shared
operator|||
name|info
operator|->
name|no_undefined
operator|||
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|)
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
name|ret_val
operator|=
name|false
expr_stmt|;
continue|continue;
block|}
block|}
name|hit_addr
operator|=
name|contents
operator|+
name|rel
operator|->
name|r_offset
expr_stmt|;
name|value
operator|+=
name|rel
operator|->
name|r_addend
expr_stmt|;
name|dynamic_symbol_p
operator|=
name|elfNN_ia64_dynamic_symbol_p
argument_list|(
name|h
argument_list|,
name|info
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_IA64_NONE
case|:
case|case
name|R_IA64_LDXMOV
case|:
continue|continue;
case|case
name|R_IA64_IMM14
case|:
case|case
name|R_IA64_IMM22
case|:
case|case
name|R_IA64_IMM64
case|:
case|case
name|R_IA64_DIR32MSB
case|:
case|case
name|R_IA64_DIR32LSB
case|:
case|case
name|R_IA64_DIR64MSB
case|:
case|case
name|R_IA64_DIR64LSB
case|:
comment|/* Install a dynamic relocation for this reloc.  */
if|if
condition|(
operator|(
name|dynamic_symbol_p
operator|||
name|info
operator|->
name|shared
operator|)
operator|&&
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|int
name|dyn_r_type
decl_stmt|;
name|long
name|dynindx
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|srel
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* If we don't need dynamic symbol lookup, find a 		 matching RELATIVE relocation.  */
name|dyn_r_type
operator|=
name|r_type
expr_stmt|;
if|if
condition|(
name|dynamic_symbol_p
condition|)
block|{
name|dynindx
operator|=
name|h
operator|->
name|dynindx
expr_stmt|;
name|addend
operator|=
name|rel
operator|->
name|r_addend
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_IA64_DIR32MSB
case|:
name|dyn_r_type
operator|=
name|R_IA64_REL32MSB
expr_stmt|;
break|break;
case|case
name|R_IA64_DIR32LSB
case|:
name|dyn_r_type
operator|=
name|R_IA64_REL32LSB
expr_stmt|;
break|break;
case|case
name|R_IA64_DIR64MSB
case|:
name|dyn_r_type
operator|=
name|R_IA64_REL64MSB
expr_stmt|;
break|break;
case|case
name|R_IA64_DIR64LSB
case|:
name|dyn_r_type
operator|=
name|R_IA64_REL64LSB
expr_stmt|;
break|break;
default|default:
comment|/* We can't represent this without a dynamic symbol. 			 Adjust the relocation to be against an output 			 section symbol, which are always present in the 			 dynamic symbol table.  */
comment|/* ??? People shouldn't be doing non-pic code in 			 shared libraries.  Hork.  */
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: linking non-pic code in a shared library"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|false
expr_stmt|;
continue|continue;
block|}
name|dynindx
operator|=
literal|0
expr_stmt|;
name|addend
operator|=
name|value
expr_stmt|;
block|}
name|elfNN_ia64_install_dyn_reloc
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|input_section
argument_list|,
name|srel
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|dyn_r_type
argument_list|,
name|dynindx
argument_list|,
name|addend
argument_list|)
expr_stmt|;
block|}
comment|/* FALLTHRU */
case|case
name|R_IA64_LTV32MSB
case|:
case|case
name|R_IA64_LTV32LSB
case|:
case|case
name|R_IA64_LTV64MSB
case|:
case|case
name|R_IA64_LTV64LSB
case|:
name|r
operator|=
name|elfNN_ia64_install_value
argument_list|(
name|output_bfd
argument_list|,
name|hit_addr
argument_list|,
name|value
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_IA64_GPREL22
case|:
case|case
name|R_IA64_GPREL64I
case|:
case|case
name|R_IA64_GPREL32MSB
case|:
case|case
name|R_IA64_GPREL32LSB
case|:
case|case
name|R_IA64_GPREL64MSB
case|:
case|case
name|R_IA64_GPREL64LSB
case|:
if|if
condition|(
name|dynamic_symbol_p
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: @gprel relocation against dynamic symbol %s"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|false
expr_stmt|;
continue|continue;
block|}
name|value
operator|-=
name|gp_val
expr_stmt|;
name|r
operator|=
name|elfNN_ia64_install_value
argument_list|(
name|output_bfd
argument_list|,
name|hit_addr
argument_list|,
name|value
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_IA64_LTOFF22
case|:
case|case
name|R_IA64_LTOFF22X
case|:
case|case
name|R_IA64_LTOFF64I
case|:
name|dyn_i
operator|=
name|get_dyn_sym_info
argument_list|(
name|ia64_info
argument_list|,
name|h
argument_list|,
name|input_bfd
argument_list|,
name|rel
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|value
operator|=
name|set_got_entry
argument_list|(
name|input_bfd
argument_list|,
name|info
argument_list|,
name|dyn_i
argument_list|,
operator|(
name|h
condition|?
name|h
operator|->
name|dynindx
else|:
operator|-
literal|1
operator|)
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|,
name|value
argument_list|,
name|R_IA64_DIR64LSB
argument_list|)
expr_stmt|;
name|value
operator|-=
name|gp_val
expr_stmt|;
name|r
operator|=
name|elfNN_ia64_install_value
argument_list|(
name|output_bfd
argument_list|,
name|hit_addr
argument_list|,
name|value
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_IA64_PLTOFF22
case|:
case|case
name|R_IA64_PLTOFF64I
case|:
case|case
name|R_IA64_PLTOFF64MSB
case|:
case|case
name|R_IA64_PLTOFF64LSB
case|:
name|dyn_i
operator|=
name|get_dyn_sym_info
argument_list|(
name|ia64_info
argument_list|,
name|h
argument_list|,
name|input_bfd
argument_list|,
name|rel
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|value
operator|=
name|set_pltoff_entry
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|dyn_i
argument_list|,
name|value
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|value
operator|-=
name|gp_val
expr_stmt|;
name|r
operator|=
name|elfNN_ia64_install_value
argument_list|(
name|output_bfd
argument_list|,
name|hit_addr
argument_list|,
name|value
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_IA64_FPTR64I
case|:
case|case
name|R_IA64_FPTR32MSB
case|:
case|case
name|R_IA64_FPTR32LSB
case|:
case|case
name|R_IA64_FPTR64MSB
case|:
case|case
name|R_IA64_FPTR64LSB
case|:
name|dyn_i
operator|=
name|get_dyn_sym_info
argument_list|(
name|ia64_info
argument_list|,
name|h
argument_list|,
name|input_bfd
argument_list|,
name|rel
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|dyn_i
operator|->
name|want_fptr
condition|)
block|{
if|if
condition|(
operator|!
name|undef_weak_ref
condition|)
name|value
operator|=
name|set_fptr_entry
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|dyn_i
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|long
name|dynindx
decl_stmt|;
comment|/* Otherwise, we expect the dynamic linker to create 		 the entry.  */
if|if
condition|(
name|h
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
condition|)
name|dynindx
operator|=
name|h
operator|->
name|dynindx
expr_stmt|;
else|else
name|dynindx
operator|=
operator|(
name|_bfd_elf_link_lookup_local_dynindx
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
argument_list|,
name|global_sym_index
argument_list|(
name|h
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|dynindx
operator|=
operator|(
name|_bfd_elf_link_lookup_local_dynindx
argument_list|(
name|info
argument_list|,
name|input_bfd
argument_list|,
name|r_symndx
argument_list|)
operator|)
expr_stmt|;
block|}
name|elfNN_ia64_install_dyn_reloc
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|input_section
argument_list|,
name|srel
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|r_type
argument_list|,
name|dynindx
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
block|}
name|r
operator|=
name|elfNN_ia64_install_value
argument_list|(
name|output_bfd
argument_list|,
name|hit_addr
argument_list|,
name|value
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_IA64_LTOFF_FPTR22
case|:
case|case
name|R_IA64_LTOFF_FPTR64I
case|:
case|case
name|R_IA64_LTOFF_FPTR64MSB
case|:
case|case
name|R_IA64_LTOFF_FPTR64LSB
case|:
block|{
name|long
name|dynindx
decl_stmt|;
name|dyn_i
operator|=
name|get_dyn_sym_info
argument_list|(
name|ia64_info
argument_list|,
name|h
argument_list|,
name|input_bfd
argument_list|,
name|rel
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|dyn_i
operator|->
name|want_fptr
condition|)
block|{
name|BFD_ASSERT
argument_list|(
argument|h == NULL || h->dynindx == -
literal|1
argument_list|)
if|if
condition|(
operator|!
name|undef_weak_ref
condition|)
name|value
operator|=
name|set_fptr_entry
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|dyn_i
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|dynindx
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Otherwise, we expect the dynamic linker to create 		   the entry.  */
if|if
condition|(
name|h
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
condition|)
name|dynindx
operator|=
name|h
operator|->
name|dynindx
expr_stmt|;
else|else
name|dynindx
operator|=
operator|(
name|_bfd_elf_link_lookup_local_dynindx
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
argument_list|,
name|global_sym_index
argument_list|(
name|h
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
name|dynindx
operator|=
operator|(
name|_bfd_elf_link_lookup_local_dynindx
argument_list|(
name|info
argument_list|,
name|input_bfd
argument_list|,
name|r_symndx
argument_list|)
operator|)
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
block|}
name|value
operator|=
name|set_got_entry
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|dyn_i
argument_list|,
name|dynindx
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|,
name|value
argument_list|,
name|R_IA64_FPTR64LSB
argument_list|)
expr_stmt|;
name|value
operator|-=
name|gp_val
expr_stmt|;
name|r
operator|=
name|elfNN_ia64_install_value
argument_list|(
name|output_bfd
argument_list|,
name|hit_addr
argument_list|,
name|value
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|R_IA64_PCREL32MSB
case|:
case|case
name|R_IA64_PCREL32LSB
case|:
case|case
name|R_IA64_PCREL64MSB
case|:
case|case
name|R_IA64_PCREL64LSB
case|:
comment|/* Install a dynamic relocation for this reloc.  */
if|if
condition|(
name|dynamic_symbol_p
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|srel
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|elfNN_ia64_install_dyn_reloc
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|input_section
argument_list|,
name|srel
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|r_type
argument_list|,
name|h
operator|->
name|dynindx
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
expr_stmt|;
block|}
goto|goto
name|finish_pcrel
goto|;
case|case
name|R_IA64_PCREL21BI
case|:
case|case
name|R_IA64_PCREL21F
case|:
case|case
name|R_IA64_PCREL21M
case|:
comment|/* ??? These two are only used for speculation fixup code. 	     They should never be dynamic.  */
if|if
condition|(
name|dynamic_symbol_p
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: dynamic relocation against speculation fixup"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|false
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|undef_weak_ref
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: speculation fixup against undefined weak symbol"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|false
expr_stmt|;
continue|continue;
block|}
goto|goto
name|finish_pcrel
goto|;
case|case
name|R_IA64_PCREL21B
case|:
case|case
name|R_IA64_PCREL60B
case|:
comment|/* We should have created a PLT entry for any dynamic symbol.  */
name|dyn_i
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|h
condition|)
name|dyn_i
operator|=
name|get_dyn_sym_info
argument_list|(
name|ia64_info
argument_list|,
name|h
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|dyn_i
operator|&&
name|dyn_i
operator|->
name|want_plt2
condition|)
block|{
comment|/* Should have caught this earlier.  */
name|BFD_ASSERT
argument_list|(
name|rel
operator|->
name|r_addend
operator|==
literal|0
argument_list|)
expr_stmt|;
name|value
operator|=
operator|(
name|ia64_info
operator|->
name|plt_sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|ia64_info
operator|->
name|plt_sec
operator|->
name|output_offset
operator|+
name|dyn_i
operator|->
name|plt2_offset
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Since there's no PLT entry, Validate that this is 		 locally defined.  */
name|BFD_ASSERT
argument_list|(
name|undef_weak_ref
operator|||
name|sym_sec
operator|->
name|output_section
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* If the symbol is undef_weak, we shouldn't be trying 		 to call it.  There's every chance that we'd wind up 		 with an out-of-range fixup here.  Don't bother setting 		 any value at all.  */
if|if
condition|(
name|undef_weak_ref
condition|)
continue|continue;
block|}
goto|goto
name|finish_pcrel
goto|;
case|case
name|R_IA64_PCREL22
case|:
case|case
name|R_IA64_PCREL64I
case|:
name|finish_pcrel
label|:
comment|/* Make pc-relative.  */
name|value
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|rel
operator|->
name|r_offset
operator|)
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
literal|0x3
expr_stmt|;
name|r
operator|=
name|elfNN_ia64_install_value
argument_list|(
name|output_bfd
argument_list|,
name|hit_addr
argument_list|,
name|value
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_IA64_SEGREL32MSB
case|:
case|case
name|R_IA64_SEGREL32LSB
case|:
case|case
name|R_IA64_SEGREL64MSB
case|:
case|case
name|R_IA64_SEGREL64LSB
case|:
block|{
name|struct
name|elf_segment_map
modifier|*
name|m
decl_stmt|;
name|Elf_Internal_Phdr
modifier|*
name|p
decl_stmt|;
comment|/* Find the segment that contains the output_section.  */
for|for
control|(
name|m
operator|=
name|elf_tdata
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|segment_map
operator|,
name|p
operator|=
name|elf_tdata
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|phdr
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|next
operator|,
name|p
operator|++
control|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|m
operator|->
name|count
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|m
operator|->
name|sections
index|[
name|i
index|]
operator|==
name|sym_sec
operator|->
name|output_section
condition|)
break|break;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* If the input section was discarded from the output, then 		   do nothing.  */
if|if
condition|(
name|bfd_is_abs_section
argument_list|(
name|sym_sec
operator|->
name|output_section
argument_list|)
condition|)
name|r
operator|=
name|bfd_reloc_ok
expr_stmt|;
else|else
name|r
operator|=
name|bfd_reloc_notsupported
expr_stmt|;
block|}
else|else
block|{
comment|/* The VMA of the segment is the vaddr of the associated 		   program header.  */
if|if
condition|(
name|value
operator|>
name|p
operator|->
name|p_vaddr
condition|)
name|value
operator|-=
name|p
operator|->
name|p_vaddr
expr_stmt|;
else|else
name|value
operator|=
literal|0
expr_stmt|;
name|r
operator|=
name|elfNN_ia64_install_value
argument_list|(
name|output_bfd
argument_list|,
name|hit_addr
argument_list|,
name|value
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|R_IA64_SECREL32MSB
case|:
case|case
name|R_IA64_SECREL32LSB
case|:
case|case
name|R_IA64_SECREL64MSB
case|:
case|case
name|R_IA64_SECREL64LSB
case|:
comment|/* Make output-section relative.  */
if|if
condition|(
name|value
operator|>
name|input_section
operator|->
name|output_section
operator|->
name|vma
condition|)
name|value
operator|-=
name|input_section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
else|else
name|value
operator|=
literal|0
expr_stmt|;
name|r
operator|=
name|elfNN_ia64_install_value
argument_list|(
name|output_bfd
argument_list|,
name|hit_addr
argument_list|,
name|value
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_IA64_IPLTMSB
case|:
case|case
name|R_IA64_IPLTLSB
case|:
comment|/* Install a dynamic relocation for this reloc.  */
if|if
condition|(
operator|(
name|dynamic_symbol_p
operator|||
name|info
operator|->
name|shared
operator|)
operator|&&
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|srel
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* If we don't need dynamic symbol lookup, install two 		 RELATIVE relocations.  */
if|if
condition|(
operator|!
name|dynamic_symbol_p
condition|)
block|{
name|unsigned
name|int
name|dyn_r_type
decl_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_IA64_IPLTMSB
condition|)
name|dyn_r_type
operator|=
name|R_IA64_REL64MSB
expr_stmt|;
else|else
name|dyn_r_type
operator|=
name|R_IA64_REL64LSB
expr_stmt|;
name|elfNN_ia64_install_dyn_reloc
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|input_section
argument_list|,
name|srel
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|dyn_r_type
argument_list|,
literal|0
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|elfNN_ia64_install_dyn_reloc
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|input_section
argument_list|,
name|srel
argument_list|,
name|rel
operator|->
name|r_offset
operator|+
literal|8
argument_list|,
name|dyn_r_type
argument_list|,
literal|0
argument_list|,
name|gp_val
argument_list|)
expr_stmt|;
block|}
else|else
name|elfNN_ia64_install_dyn_reloc
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|input_section
argument_list|,
name|srel
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|r_type
argument_list|,
name|h
operator|->
name|dynindx
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r_type
operator|==
name|R_IA64_IPLTMSB
condition|)
name|r_type
operator|=
name|R_IA64_DIR64MSB
expr_stmt|;
else|else
name|r_type
operator|=
name|R_IA64_DIR64LSB
expr_stmt|;
name|elfNN_ia64_install_value
argument_list|(
name|output_bfd
argument_list|,
name|hit_addr
argument_list|,
name|value
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
name|r
operator|=
name|elfNN_ia64_install_value
argument_list|(
name|output_bfd
argument_list|,
name|hit_addr
operator|+
literal|8
argument_list|,
name|gp_val
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
break|break;
default|default:
name|r
operator|=
name|bfd_reloc_notsupported
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|bfd_reloc_ok
case|:
break|break;
case|case
name|bfd_reloc_undefined
case|:
comment|/* This can happen for global table relative relocs if 	     __gp is undefined.  This is a panic situation so we 	     don't try to continue.  */
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|info
argument_list|,
literal|"__gp"
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
name|bfd_reloc_notsupported
case|:
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|h
condition|)
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
else|else
block|{
name|name
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_link
argument_list|,
name|sym
operator|->
name|st_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'\0'
condition|)
name|name
operator|=
name|bfd_section_name
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|warning
call|)
argument_list|(
name|info
argument_list|,
name|_
argument_list|(
literal|"unsupported reloc"
argument_list|)
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
condition|)
return|return
name|false
return|;
name|ret_val
operator|=
name|false
expr_stmt|;
block|}
break|break;
case|case
name|bfd_reloc_dangerous
case|:
case|case
name|bfd_reloc_outofrange
case|:
case|case
name|bfd_reloc_overflow
case|:
default|default:
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|h
condition|)
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
else|else
block|{
name|name
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_link
argument_list|,
name|sym
operator|->
name|st_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'\0'
condition|)
name|name
operator|=
name|bfd_section_name
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|info
argument_list|,
name|name
argument_list|,
name|howto
operator|->
name|name
argument_list|,
literal|0
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
condition|)
return|return
name|false
return|;
name|ret_val
operator|=
name|false
expr_stmt|;
block|}
break|break;
block|}
block|}
return|return
name|ret_val
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|elfNN_ia64_finish_dynamic_symbol
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|h
parameter_list|,
name|sym
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
block|{
name|struct
name|elfNN_ia64_link_hash_table
modifier|*
name|ia64_info
decl_stmt|;
name|struct
name|elfNN_ia64_dyn_sym_info
modifier|*
name|dyn_i
decl_stmt|;
name|ia64_info
operator|=
name|elfNN_ia64_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|dyn_i
operator|=
name|get_dyn_sym_info
argument_list|(
name|ia64_info
argument_list|,
name|h
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* Fill in the PLT data, if required.  */
if|if
condition|(
name|dyn_i
operator|&&
name|dyn_i
operator|->
name|want_plt
condition|)
block|{
name|Elf_Internal_Rela
name|outrel
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|asection
modifier|*
name|plt_sec
decl_stmt|;
name|bfd_vma
name|plt_addr
decl_stmt|,
name|pltoff_addr
decl_stmt|,
name|gp_val
decl_stmt|,
name|index
decl_stmt|;
name|ElfNN_External_Rela
modifier|*
name|rel
decl_stmt|;
name|gp_val
operator|=
name|_bfd_get_gp_value
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
comment|/* Initialize the minimal PLT entry.  */
name|index
operator|=
operator|(
name|dyn_i
operator|->
name|plt_offset
operator|-
name|PLT_HEADER_SIZE
operator|)
operator|/
name|PLT_MIN_ENTRY_SIZE
expr_stmt|;
name|plt_sec
operator|=
name|ia64_info
operator|->
name|plt_sec
expr_stmt|;
name|loc
operator|=
name|plt_sec
operator|->
name|contents
operator|+
name|dyn_i
operator|->
name|plt_offset
expr_stmt|;
name|memcpy
argument_list|(
name|loc
argument_list|,
name|plt_min_entry
argument_list|,
name|PLT_MIN_ENTRY_SIZE
argument_list|)
expr_stmt|;
name|elfNN_ia64_install_value
argument_list|(
name|output_bfd
argument_list|,
name|loc
argument_list|,
name|index
argument_list|,
name|R_IA64_IMM22
argument_list|)
expr_stmt|;
name|elfNN_ia64_install_value
argument_list|(
name|output_bfd
argument_list|,
name|loc
operator|+
literal|2
argument_list|,
operator|-
name|dyn_i
operator|->
name|plt_offset
argument_list|,
name|R_IA64_PCREL21B
argument_list|)
expr_stmt|;
name|plt_addr
operator|=
operator|(
name|plt_sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|plt_sec
operator|->
name|output_offset
operator|+
name|dyn_i
operator|->
name|plt_offset
operator|)
expr_stmt|;
name|pltoff_addr
operator|=
name|set_pltoff_entry
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|dyn_i
argument_list|,
name|plt_addr
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* Initialize the FULL PLT entry, if needed.  */
if|if
condition|(
name|dyn_i
operator|->
name|want_plt2
condition|)
block|{
name|loc
operator|=
name|plt_sec
operator|->
name|contents
operator|+
name|dyn_i
operator|->
name|plt2_offset
expr_stmt|;
name|memcpy
argument_list|(
name|loc
argument_list|,
name|plt_full_entry
argument_list|,
name|PLT_FULL_ENTRY_SIZE
argument_list|)
expr_stmt|;
name|elfNN_ia64_install_value
argument_list|(
name|output_bfd
argument_list|,
name|loc
argument_list|,
name|pltoff_addr
operator|-
name|gp_val
argument_list|,
name|R_IA64_IMM22
argument_list|)
expr_stmt|;
comment|/* Mark the symbol as undefined, rather than as defined in the 	     plt section.  Leave the value alone.  */
comment|/* ??? We didn't redefine it in adjust_dynamic_symbol in the 	     first place.  But perhaps elflink.h did some for us.  */
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
condition|)
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_UNDEF
expr_stmt|;
block|}
comment|/* Create the dynamic relocation.  */
name|outrel
operator|.
name|r_offset
operator|=
name|pltoff_addr
expr_stmt|;
if|if
condition|(
name|bfd_little_endian
argument_list|(
name|output_bfd
argument_list|)
condition|)
name|outrel
operator|.
name|r_info
operator|=
name|ELFNN_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_IA64_IPLTLSB
argument_list|)
expr_stmt|;
else|else
name|outrel
operator|.
name|r_info
operator|=
name|ELFNN_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_IA64_IPLTMSB
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
comment|/* This is fun.  In the .IA_64.pltoff section, we've got entries 	 that correspond both to real PLT entries, and those that 	 happened to resolve to local symbols but need to be created 	 to satisfy @pltoff relocations.  The .rela.IA_64.pltoff 	 relocations for the real PLT should come at the end of the 	 section, so that they can be indexed by plt entry at runtime.  	 We emitted all of the relocations for the non-PLT @pltoff 	 entries during relocate_section.  So we can consider the 	 existing sec->reloc_count to be the base of the array of 	 PLT relocations.  */
name|rel
operator|=
operator|(
name|ElfNN_External_Rela
operator|*
operator|)
name|ia64_info
operator|->
name|rel_pltoff_sec
operator|->
name|contents
expr_stmt|;
name|rel
operator|+=
name|ia64_info
operator|->
name|rel_pltoff_sec
operator|->
name|reloc_count
expr_stmt|;
name|bfd_elfNN_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
name|rel
operator|+
name|index
argument_list|)
expr_stmt|;
block|}
comment|/* Mark some specially defined symbols as absolute.  */
if|if
condition|(
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_DYNAMIC"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_PROCEDURE_LINKAGE_TABLE_"
argument_list|)
operator|==
literal|0
condition|)
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_ABS
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|elfNN_ia64_finish_dynamic_sections
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|struct
name|elfNN_ia64_link_hash_table
modifier|*
name|ia64_info
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|ia64_info
operator|=
name|elfNN_ia64_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|dynobj
operator|=
name|ia64_info
operator|->
name|root
operator|.
name|dynobj
expr_stmt|;
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
name|ElfNN_External_Dyn
modifier|*
name|dyncon
decl_stmt|,
modifier|*
name|dynconend
decl_stmt|;
name|asection
modifier|*
name|sdyn
decl_stmt|,
modifier|*
name|sgotplt
decl_stmt|;
name|bfd_vma
name|gp_val
decl_stmt|;
name|sdyn
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
name|sgotplt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got.plt"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sdyn
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dyncon
operator|=
operator|(
name|ElfNN_External_Dyn
operator|*
operator|)
name|sdyn
operator|->
name|contents
expr_stmt|;
name|dynconend
operator|=
operator|(
name|ElfNN_External_Dyn
operator|*
operator|)
operator|(
name|sdyn
operator|->
name|contents
operator|+
name|sdyn
operator|->
name|_raw_size
operator|)
expr_stmt|;
name|gp_val
operator|=
name|_bfd_get_gp_value
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|dyncon
operator|<
name|dynconend
condition|;
name|dyncon
operator|++
control|)
block|{
name|Elf_Internal_Dyn
name|dyn
decl_stmt|;
name|bfd_elfNN_swap_dyn_in
argument_list|(
name|dynobj
argument_list|,
name|dyncon
argument_list|,
operator|&
name|dyn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dyn
operator|.
name|d_tag
condition|)
block|{
case|case
name|DT_PLTGOT
case|:
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|gp_val
expr_stmt|;
break|break;
case|case
name|DT_PLTRELSZ
case|:
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
operator|(
name|ia64_info
operator|->
name|minplt_entries
operator|*
sizeof|sizeof
argument_list|(
name|ElfNN_External_Rela
argument_list|)
operator|)
expr_stmt|;
break|break;
case|case
name|DT_JMPREL
case|:
comment|/* See the comment above in finish_dynamic_symbol.  */
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
operator|(
name|ia64_info
operator|->
name|rel_pltoff_sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|ia64_info
operator|->
name|rel_pltoff_sec
operator|->
name|output_offset
operator|+
operator|(
name|ia64_info
operator|->
name|rel_pltoff_sec
operator|->
name|reloc_count
operator|*
sizeof|sizeof
argument_list|(
name|ElfNN_External_Rela
argument_list|)
operator|)
operator|)
expr_stmt|;
break|break;
case|case
name|DT_IA_64_PLT_RESERVE
case|:
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
operator|(
name|sgotplt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgotplt
operator|->
name|output_offset
operator|)
expr_stmt|;
break|break;
case|case
name|DT_RELASZ
case|:
comment|/* Do not have RELASZ include JMPREL.  This makes things 		 easier on ld.so.  This is not what the rest of BFD set up.  */
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|-=
operator|(
name|ia64_info
operator|->
name|minplt_entries
operator|*
sizeof|sizeof
argument_list|(
name|ElfNN_External_Rela
argument_list|)
operator|)
expr_stmt|;
break|break;
block|}
name|bfd_elfNN_swap_dyn_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize the PLT0 entry */
if|if
condition|(
name|ia64_info
operator|->
name|plt_sec
condition|)
block|{
name|bfd_byte
modifier|*
name|loc
init|=
name|ia64_info
operator|->
name|plt_sec
operator|->
name|contents
decl_stmt|;
name|bfd_vma
name|pltres
decl_stmt|;
name|memcpy
argument_list|(
name|loc
argument_list|,
name|plt_header
argument_list|,
name|PLT_HEADER_SIZE
argument_list|)
expr_stmt|;
name|pltres
operator|=
operator|(
name|sgotplt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgotplt
operator|->
name|output_offset
operator|-
name|gp_val
operator|)
expr_stmt|;
name|elfNN_ia64_install_value
argument_list|(
name|abfd
argument_list|,
name|loc
operator|+
literal|1
argument_list|,
name|pltres
argument_list|,
name|R_IA64_GPREL22
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ELF file flag handling: */
end_comment

begin_comment
comment|/* Function to keep IA-64 specific file flags.  */
end_comment

begin_function
specifier|static
name|boolean
name|elfNN_ia64_set_private_flags
parameter_list|(
name|abfd
parameter_list|,
name|flags
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
block|{
name|BFD_ASSERT
argument_list|(
operator|!
name|elf_flags_init
argument_list|(
name|abfd
argument_list|)
operator|||
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|==
name|flags
argument_list|)
expr_stmt|;
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|=
name|flags
expr_stmt|;
name|elf_flags_init
argument_list|(
name|abfd
argument_list|)
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Copy backend specific data from one object module to another */
end_comment

begin_function
specifier|static
name|boolean
name|elfNN_ia64_copy_private_bfd_data
parameter_list|(
name|ibfd
parameter_list|,
name|obfd
parameter_list|)
name|bfd
modifier|*
name|ibfd
decl_stmt|,
decl|*
name|obfd
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|ibfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
operator|||
name|bfd_get_flavour
argument_list|(
name|obfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
return|return
name|true
return|;
name|BFD_ASSERT
argument_list|(
operator|!
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
operator|||
operator|(
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|==
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
operator|->
name|e_flags
operator|)
argument_list|)
expr_stmt|;
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|=
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
end_block

begin_comment
comment|/* Merge backend specific data from an object file to the output    object file when linking.  */
end_comment

begin_function
specifier|static
name|boolean
name|elfNN_ia64_merge_private_bfd_data
parameter_list|(
name|ibfd
parameter_list|,
name|obfd
parameter_list|)
name|bfd
modifier|*
name|ibfd
decl_stmt|,
decl|*
name|obfd
decl_stmt|;
end_function

begin_block
block|{
name|flagword
name|out_flags
decl_stmt|;
name|flagword
name|in_flags
decl_stmt|;
name|boolean
name|ok
init|=
name|true
decl_stmt|;
comment|/* Don't even pretend to support mixed-format linking.  */
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|ibfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
operator|||
name|bfd_get_flavour
argument_list|(
name|obfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
return|return
name|false
return|;
name|in_flags
operator|=
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
name|out_flags
operator|=
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
if|if
condition|(
operator|!
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
condition|)
block|{
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
operator|=
name|true
expr_stmt|;
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|=
name|in_flags
expr_stmt|;
if|if
condition|(
name|bfd_get_arch
argument_list|(
name|obfd
argument_list|)
operator|==
name|bfd_get_arch
argument_list|(
name|ibfd
argument_list|)
operator|&&
name|bfd_get_arch_info
argument_list|(
name|obfd
argument_list|)
operator|->
name|the_default
condition|)
block|{
return|return
name|bfd_set_arch_mach
argument_list|(
name|obfd
argument_list|,
name|bfd_get_arch
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|bfd_get_mach
argument_list|(
name|ibfd
argument_list|)
argument_list|)
return|;
block|}
return|return
name|true
return|;
block|}
comment|/* Check flag compatibility.  */
if|if
condition|(
name|in_flags
operator|==
name|out_flags
condition|)
return|return
name|true
return|;
comment|/* Output has EF_IA_64_REDUCEDFP set only if all inputs have it set.  */
if|if
condition|(
operator|!
operator|(
name|in_flags
operator|&
name|EF_IA_64_REDUCEDFP
operator|)
operator|&&
operator|(
name|out_flags
operator|&
name|EF_IA_64_REDUCEDFP
operator|)
condition|)
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|&=
operator|~
name|EF_IA_64_REDUCEDFP
expr_stmt|;
if|if
condition|(
operator|(
name|in_flags
operator|&
name|EF_IA_64_TRAPNIL
operator|)
operator|!=
operator|(
name|out_flags
operator|&
name|EF_IA_64_TRAPNIL
operator|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: linking trap-on-NULL-dereference with non-trapping files"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
name|ok
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|in_flags
operator|&
name|EF_IA_64_BE
operator|)
operator|!=
operator|(
name|out_flags
operator|&
name|EF_IA_64_BE
operator|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: linking big-endian files with little-endian files"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
name|ok
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|in_flags
operator|&
name|EF_IA_64_ABI64
operator|)
operator|!=
operator|(
name|out_flags
operator|&
name|EF_IA_64_ABI64
operator|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: linking 64-bit files with 32-bit files"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
name|ok
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|in_flags
operator|&
name|EF_IA_64_CONS_GP
operator|)
operator|!=
operator|(
name|out_flags
operator|&
name|EF_IA_64_CONS_GP
operator|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: linking constant-gp files with non-constant-gp files"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
name|ok
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|in_flags
operator|&
name|EF_IA_64_NOFUNCDESC_CONS_GP
operator|)
operator|!=
operator|(
name|out_flags
operator|&
name|EF_IA_64_NOFUNCDESC_CONS_GP
operator|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: linking auto-pic files with non-auto-pic files"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
name|ok
operator|=
name|false
expr_stmt|;
block|}
return|return
name|ok
return|;
block|}
end_block

begin_function
specifier|static
name|boolean
name|elfNN_ia64_print_private_bfd_data
parameter_list|(
name|abfd
parameter_list|,
name|ptr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|ptr
decl_stmt|;
block|{
name|FILE
modifier|*
name|file
init|=
operator|(
name|FILE
operator|*
operator|)
name|ptr
decl_stmt|;
name|flagword
name|flags
init|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|abfd
operator|!=
name|NULL
operator|&&
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"private flags = %s%s%s%s%s%s%s%s\n"
argument_list|,
operator|(
name|flags
operator|&
name|EF_IA_64_TRAPNIL
operator|)
condition|?
literal|"TRAPNIL, "
else|:
literal|""
argument_list|,
operator|(
name|flags
operator|&
name|EF_IA_64_EXT
operator|)
condition|?
literal|"EXT, "
else|:
literal|""
argument_list|,
operator|(
name|flags
operator|&
name|EF_IA_64_BE
operator|)
condition|?
literal|"BE, "
else|:
literal|"LE, "
argument_list|,
operator|(
name|flags
operator|&
name|EF_IA_64_REDUCEDFP
operator|)
condition|?
literal|"REDUCEDFP, "
else|:
literal|""
argument_list|,
operator|(
name|flags
operator|&
name|EF_IA_64_CONS_GP
operator|)
condition|?
literal|"CONS_GP, "
else|:
literal|""
argument_list|,
operator|(
name|flags
operator|&
name|EF_IA_64_NOFUNCDESC_CONS_GP
operator|)
condition|?
literal|"NOFUNCDESC_CONS_GP, "
else|:
literal|""
argument_list|,
operator|(
name|flags
operator|&
name|EF_IA_64_ABSOLUTE
operator|)
condition|?
literal|"ABSOLUTE, "
else|:
literal|""
argument_list|,
operator|(
name|flags
operator|&
name|EF_IA_64_ABI64
operator|)
condition|?
literal|"ABI64"
else|:
literal|"ABI32"
argument_list|)
expr_stmt|;
name|_bfd_elf_print_private_bfd_data
argument_list|(
name|abfd
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|TARGET_LITTLE_SYM
value|bfd_elfNN_ia64_little_vec
end_define

begin_define
define|#
directive|define
name|TARGET_LITTLE_NAME
value|"elfNN-ia64-little"
end_define

begin_define
define|#
directive|define
name|TARGET_BIG_SYM
value|bfd_elfNN_ia64_big_vec
end_define

begin_define
define|#
directive|define
name|TARGET_BIG_NAME
value|"elfNN-ia64-big"
end_define

begin_define
define|#
directive|define
name|ELF_ARCH
value|bfd_arch_ia64
end_define

begin_define
define|#
directive|define
name|ELF_MACHINE_CODE
value|EM_IA_64
end_define

begin_define
define|#
directive|define
name|ELF_MACHINE_ALT1
value|1999
end_define

begin_comment
comment|/* EAS2.3 */
end_comment

begin_define
define|#
directive|define
name|ELF_MACHINE_ALT2
value|1998
end_define

begin_comment
comment|/* EAS2.2 */
end_comment

begin_define
define|#
directive|define
name|ELF_MAXPAGESIZE
value|0x10000
end_define

begin_comment
comment|/* 64KB */
end_comment

begin_define
define|#
directive|define
name|elf_backend_section_from_shdr
define|\
value|elfNN_ia64_section_from_shdr
end_define

begin_define
define|#
directive|define
name|elf_backend_section_flags
define|\
value|elfNN_ia64_section_flags
end_define

begin_define
define|#
directive|define
name|elf_backend_fake_sections
define|\
value|elfNN_ia64_fake_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_final_write_processing
define|\
value|elfNN_ia64_final_write_processing
end_define

begin_define
define|#
directive|define
name|elf_backend_add_symbol_hook
define|\
value|elfNN_ia64_add_symbol_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_additional_program_headers
define|\
value|elfNN_ia64_additional_program_headers
end_define

begin_define
define|#
directive|define
name|elf_backend_modify_segment_map
define|\
value|elfNN_ia64_modify_segment_map
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto
define|\
value|elfNN_ia64_info_to_howto
end_define

begin_define
define|#
directive|define
name|bfd_elfNN_bfd_reloc_type_lookup
define|\
value|elfNN_ia64_reloc_type_lookup
end_define

begin_define
define|#
directive|define
name|bfd_elfNN_bfd_is_local_label_name
define|\
value|elfNN_ia64_is_local_label_name
end_define

begin_define
define|#
directive|define
name|bfd_elfNN_bfd_relax_section
define|\
value|elfNN_ia64_relax_section
end_define

begin_comment
comment|/* Stuff for the BFD linker: */
end_comment

begin_define
define|#
directive|define
name|bfd_elfNN_bfd_link_hash_table_create
define|\
value|elfNN_ia64_hash_table_create
end_define

begin_define
define|#
directive|define
name|elf_backend_create_dynamic_sections
define|\
value|elfNN_ia64_create_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_check_relocs
define|\
value|elfNN_ia64_check_relocs
end_define

begin_define
define|#
directive|define
name|elf_backend_adjust_dynamic_symbol
define|\
value|elfNN_ia64_adjust_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_size_dynamic_sections
define|\
value|elfNN_ia64_size_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_relocate_section
define|\
value|elfNN_ia64_relocate_section
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_symbol
define|\
value|elfNN_ia64_finish_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_sections
define|\
value|elfNN_ia64_finish_dynamic_sections
end_define

begin_define
define|#
directive|define
name|bfd_elfNN_bfd_final_link
define|\
value|elfNN_ia64_final_link
end_define

begin_define
define|#
directive|define
name|bfd_elfNN_bfd_copy_private_bfd_data
define|\
value|elfNN_ia64_copy_private_bfd_data
end_define

begin_define
define|#
directive|define
name|bfd_elfNN_bfd_merge_private_bfd_data
define|\
value|elfNN_ia64_merge_private_bfd_data
end_define

begin_define
define|#
directive|define
name|bfd_elfNN_bfd_set_private_flags
define|\
value|elfNN_ia64_set_private_flags
end_define

begin_define
define|#
directive|define
name|bfd_elfNN_bfd_print_private_bfd_data
define|\
value|elfNN_ia64_print_private_bfd_data
end_define

begin_define
define|#
directive|define
name|elf_backend_plt_readonly
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_want_plt_sym
value|0
end_define

begin_define
define|#
directive|define
name|elf_backend_plt_alignment
value|5
end_define

begin_define
define|#
directive|define
name|elf_backend_got_header_size
value|0
end_define

begin_define
define|#
directive|define
name|elf_backend_plt_header_size
value|PLT_HEADER_SIZE
end_define

begin_define
define|#
directive|define
name|elf_backend_want_got_plt
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_may_use_rel_p
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_may_use_rela_p
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_default_use_rela_p
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_want_dynbss
value|0
end_define

begin_define
define|#
directive|define
name|elf_backend_copy_indirect_symbol
value|elfNN_ia64_hash_copy_indirect
end_define

begin_define
define|#
directive|define
name|elf_backend_hide_symbol
value|elfNN_ia64_hash_hide_symbol
end_define

begin_include
include|#
directive|include
file|"elfNN-target.h"
end_include

end_unit

