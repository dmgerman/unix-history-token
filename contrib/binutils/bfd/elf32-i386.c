begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Intel 80386/80486-specific support for 32-bit ELF    Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,    2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf-vxworks.h"
end_include

begin_comment
comment|/* 386 uses REL relocations instead of RELA.  */
end_comment

begin_define
define|#
directive|define
name|USE_REL
value|1
end_define

begin_include
include|#
directive|include
file|"elf/i386.h"
end_include

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|elf_howto_table
index|[]
init|=
block|{
name|HOWTO
argument_list|(
name|R_386_NONE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_386_NONE"
argument_list|,
name|TRUE
argument_list|,
literal|0x00000000
argument_list|,
literal|0x00000000
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_386_32
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_386_32"
argument_list|,
name|TRUE
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_386_PC32
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_386_PC32"
argument_list|,
name|TRUE
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_386_GOT32
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_386_GOT32"
argument_list|,
name|TRUE
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_386_PLT32
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_386_PLT32"
argument_list|,
name|TRUE
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_386_COPY
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_386_COPY"
argument_list|,
name|TRUE
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_386_GLOB_DAT
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_386_GLOB_DAT"
argument_list|,
name|TRUE
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_386_JUMP_SLOT
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_386_JUMP_SLOT"
argument_list|,
name|TRUE
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_386_RELATIVE
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_386_RELATIVE"
argument_list|,
name|TRUE
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_386_GOTOFF
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_386_GOTOFF"
argument_list|,
name|TRUE
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_386_GOTPC
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_386_GOTPC"
argument_list|,
name|TRUE
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|TRUE
argument_list|)
block|,
comment|/* We have a gap in the reloc numbers here.      R_386_standard counts the number up to this point, and      R_386_ext_offset is the value to subtract from a reloc type of      R_386_16 thru R_386_PC8 to form an index into this table.  */
define|#
directive|define
name|R_386_standard
value|(R_386_GOTPC + 1)
define|#
directive|define
name|R_386_ext_offset
value|(R_386_TLS_TPOFF - R_386_standard)
comment|/* These relocs are a GNU extension.  */
name|HOWTO
argument_list|(
name|R_386_TLS_TPOFF
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_386_TLS_TPOFF"
argument_list|,
name|TRUE
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_386_TLS_IE
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_386_TLS_IE"
argument_list|,
name|TRUE
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_386_TLS_GOTIE
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_386_TLS_GOTIE"
argument_list|,
name|TRUE
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_386_TLS_LE
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_386_TLS_LE"
argument_list|,
name|TRUE
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_386_TLS_GD
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_386_TLS_GD"
argument_list|,
name|TRUE
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_386_TLS_LDM
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_386_TLS_LDM"
argument_list|,
name|TRUE
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_386_16
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_386_16"
argument_list|,
name|TRUE
argument_list|,
literal|0xffff
argument_list|,
literal|0xffff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_386_PC16
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_386_PC16"
argument_list|,
name|TRUE
argument_list|,
literal|0xffff
argument_list|,
literal|0xffff
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_386_8
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_386_8"
argument_list|,
name|TRUE
argument_list|,
literal|0xff
argument_list|,
literal|0xff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_386_PC8
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_386_PC8"
argument_list|,
name|TRUE
argument_list|,
literal|0xff
argument_list|,
literal|0xff
argument_list|,
name|TRUE
argument_list|)
block|,
define|#
directive|define
name|R_386_ext
value|(R_386_PC8 + 1 - R_386_ext_offset)
define|#
directive|define
name|R_386_tls_offset
value|(R_386_TLS_LDO_32 - R_386_ext)
comment|/* These are common with Solaris TLS implementation.  */
name|HOWTO
argument_list|(
name|R_386_TLS_LDO_32
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_386_TLS_LDO_32"
argument_list|,
name|TRUE
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_386_TLS_IE_32
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_386_TLS_IE_32"
argument_list|,
name|TRUE
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_386_TLS_LE_32
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_386_TLS_LE_32"
argument_list|,
name|TRUE
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_386_TLS_DTPMOD32
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_386_TLS_DTPMOD32"
argument_list|,
name|TRUE
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_386_TLS_DTPOFF32
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_386_TLS_DTPOFF32"
argument_list|,
name|TRUE
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_386_TLS_TPOFF32
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_386_TLS_TPOFF32"
argument_list|,
name|TRUE
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|FALSE
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|38
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_386_TLS_GOTDESC
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_386_TLS_GOTDESC"
argument_list|,
name|TRUE
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_386_TLS_DESC_CALL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_386_TLS_DESC_CALL"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_386_TLS_DESC
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_386_TLS_DESC"
argument_list|,
name|TRUE
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|FALSE
argument_list|)
block|,
comment|/* Another gap.  */
define|#
directive|define
name|R_386_tls
value|(R_386_TLS_DESC + 1 - R_386_tls_offset)
define|#
directive|define
name|R_386_vt_offset
value|(R_386_GNU_VTINHERIT - R_386_tls)
comment|/* GNU extension to record C++ vtable hierarchy.  */
name|HOWTO
argument_list|(
name|R_386_GNU_VTINHERIT
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|NULL
argument_list|,
comment|/* special_function */
literal|"R_386_GNU_VTINHERIT"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* GNU extension to record C++ vtable member usage.  */
name|HOWTO
argument_list|(
argument|R_386_GNU_VTENTRY
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
argument|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
argument|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
argument|_bfd_elf_rel_vtable_reloc_fn
argument_list|,
comment|/* special_function */
literal|"R_386_GNU_VTENTRY"
argument_list|,
comment|/* name */
argument|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
argument|FALSE
argument_list|)
comment|/* pcrel_offset */
define|#
directive|define
name|R_386_vt
value|(R_386_GNU_VTENTRY + 1 - R_386_vt_offset)
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_GEN_RELOC
end_ifdef

begin_define
define|#
directive|define
name|TRACE
parameter_list|(
name|str
parameter_list|)
define|\
value|fprintf (stderr, "i386 bfd reloc lookup %d (%s)\n", code, str)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|TRACE
parameter_list|(
name|str
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|elf_i386_reloc_type_lookup
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd_reloc_code_real_type
name|code
parameter_list|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|BFD_RELOC_NONE
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_NONE"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
name|R_386_NONE
index|]
return|;
case|case
name|BFD_RELOC_32
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_32"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
name|R_386_32
index|]
return|;
case|case
name|BFD_RELOC_CTOR
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_CTOR"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
name|R_386_32
index|]
return|;
case|case
name|BFD_RELOC_32_PCREL
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_PC32"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
name|R_386_PC32
index|]
return|;
case|case
name|BFD_RELOC_386_GOT32
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_386_GOT32"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
name|R_386_GOT32
index|]
return|;
case|case
name|BFD_RELOC_386_PLT32
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_386_PLT32"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
name|R_386_PLT32
index|]
return|;
case|case
name|BFD_RELOC_386_COPY
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_386_COPY"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
name|R_386_COPY
index|]
return|;
case|case
name|BFD_RELOC_386_GLOB_DAT
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_386_GLOB_DAT"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
name|R_386_GLOB_DAT
index|]
return|;
case|case
name|BFD_RELOC_386_JUMP_SLOT
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_386_JUMP_SLOT"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
name|R_386_JUMP_SLOT
index|]
return|;
case|case
name|BFD_RELOC_386_RELATIVE
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_386_RELATIVE"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
name|R_386_RELATIVE
index|]
return|;
case|case
name|BFD_RELOC_386_GOTOFF
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_386_GOTOFF"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
name|R_386_GOTOFF
index|]
return|;
case|case
name|BFD_RELOC_386_GOTPC
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_386_GOTPC"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
name|R_386_GOTPC
index|]
return|;
comment|/* These relocs are a GNU extension.  */
case|case
name|BFD_RELOC_386_TLS_TPOFF
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_386_TLS_TPOFF"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
name|R_386_TLS_TPOFF
operator|-
name|R_386_ext_offset
index|]
return|;
case|case
name|BFD_RELOC_386_TLS_IE
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_386_TLS_IE"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
name|R_386_TLS_IE
operator|-
name|R_386_ext_offset
index|]
return|;
case|case
name|BFD_RELOC_386_TLS_GOTIE
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_386_TLS_GOTIE"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
name|R_386_TLS_GOTIE
operator|-
name|R_386_ext_offset
index|]
return|;
case|case
name|BFD_RELOC_386_TLS_LE
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_386_TLS_LE"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
name|R_386_TLS_LE
operator|-
name|R_386_ext_offset
index|]
return|;
case|case
name|BFD_RELOC_386_TLS_GD
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_386_TLS_GD"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
name|R_386_TLS_GD
operator|-
name|R_386_ext_offset
index|]
return|;
case|case
name|BFD_RELOC_386_TLS_LDM
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_386_TLS_LDM"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
name|R_386_TLS_LDM
operator|-
name|R_386_ext_offset
index|]
return|;
case|case
name|BFD_RELOC_16
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_16"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
name|R_386_16
operator|-
name|R_386_ext_offset
index|]
return|;
case|case
name|BFD_RELOC_16_PCREL
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_16_PCREL"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
name|R_386_PC16
operator|-
name|R_386_ext_offset
index|]
return|;
case|case
name|BFD_RELOC_8
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_8"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
name|R_386_8
operator|-
name|R_386_ext_offset
index|]
return|;
case|case
name|BFD_RELOC_8_PCREL
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_8_PCREL"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
name|R_386_PC8
operator|-
name|R_386_ext_offset
index|]
return|;
comment|/* Common with Sun TLS implementation.  */
case|case
name|BFD_RELOC_386_TLS_LDO_32
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_386_TLS_LDO_32"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
name|R_386_TLS_LDO_32
operator|-
name|R_386_tls_offset
index|]
return|;
case|case
name|BFD_RELOC_386_TLS_IE_32
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_386_TLS_IE_32"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
name|R_386_TLS_IE_32
operator|-
name|R_386_tls_offset
index|]
return|;
case|case
name|BFD_RELOC_386_TLS_LE_32
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_386_TLS_LE_32"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
name|R_386_TLS_LE_32
operator|-
name|R_386_tls_offset
index|]
return|;
case|case
name|BFD_RELOC_386_TLS_DTPMOD32
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_386_TLS_DTPMOD32"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
name|R_386_TLS_DTPMOD32
operator|-
name|R_386_tls_offset
index|]
return|;
case|case
name|BFD_RELOC_386_TLS_DTPOFF32
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_386_TLS_DTPOFF32"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
name|R_386_TLS_DTPOFF32
operator|-
name|R_386_tls_offset
index|]
return|;
case|case
name|BFD_RELOC_386_TLS_TPOFF32
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_386_TLS_TPOFF32"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
name|R_386_TLS_TPOFF32
operator|-
name|R_386_tls_offset
index|]
return|;
case|case
name|BFD_RELOC_386_TLS_GOTDESC
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_386_TLS_GOTDESC"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
name|R_386_TLS_GOTDESC
operator|-
name|R_386_tls_offset
index|]
return|;
case|case
name|BFD_RELOC_386_TLS_DESC_CALL
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_386_TLS_DESC_CALL"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
name|R_386_TLS_DESC_CALL
operator|-
name|R_386_tls_offset
index|]
return|;
case|case
name|BFD_RELOC_386_TLS_DESC
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_386_TLS_DESC"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
name|R_386_TLS_DESC
operator|-
name|R_386_tls_offset
index|]
return|;
case|case
name|BFD_RELOC_VTABLE_INHERIT
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_VTABLE_INHERIT"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
name|R_386_GNU_VTINHERIT
operator|-
name|R_386_vt_offset
index|]
return|;
case|case
name|BFD_RELOC_VTABLE_ENTRY
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_VTABLE_ENTRY"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
name|R_386_GNU_VTENTRY
operator|-
name|R_386_vt_offset
index|]
return|;
default|default:
break|break;
block|}
name|TRACE
argument_list|(
literal|"Unknown"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|elf_i386_reloc_name_lookup
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|r_name
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|elf_howto_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|elf_howto_table
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|elf_howto_table
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
operator|&&
name|strcasecmp
argument_list|(
name|elf_howto_table
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|r_name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|&
name|elf_howto_table
index|[
name|i
index|]
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|elf_i386_info_to_howto_rel
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|arelent
modifier|*
name|cache_ptr
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|dst
parameter_list|)
block|{
name|unsigned
name|int
name|r_type
init|=
name|ELF32_R_TYPE
argument_list|(
name|dst
operator|->
name|r_info
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|indx
decl_stmt|;
if|if
condition|(
operator|(
name|indx
operator|=
name|r_type
operator|)
operator|>=
name|R_386_standard
operator|&&
operator|(
operator|(
name|indx
operator|=
name|r_type
operator|-
name|R_386_ext_offset
operator|)
operator|-
name|R_386_standard
operator|>=
name|R_386_ext
operator|-
name|R_386_standard
operator|)
operator|&&
operator|(
operator|(
name|indx
operator|=
name|r_type
operator|-
name|R_386_tls_offset
operator|)
operator|-
name|R_386_ext
operator|>=
name|R_386_tls
operator|-
name|R_386_ext
operator|)
operator|&&
operator|(
operator|(
name|indx
operator|=
name|r_type
operator|-
name|R_386_vt_offset
operator|)
operator|-
name|R_386_tls
operator|>=
name|R_386_vt
operator|-
name|R_386_tls
operator|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: invalid relocation type %d"
argument_list|)
argument_list|,
name|abfd
argument_list|,
operator|(
name|int
operator|)
name|r_type
argument_list|)
expr_stmt|;
name|indx
operator|=
name|R_386_NONE
expr_stmt|;
block|}
name|cache_ptr
operator|->
name|howto
operator|=
operator|&
name|elf_howto_table
index|[
name|indx
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return whether a symbol name implies a local label.  The UnixWare    2.1 cc generates temporary symbols that start with .X, so we    recognize them here.  FIXME: do other SVR4 compilers also use .X?.    If so, we should move the .X recognition into    _bfd_elf_is_local_label_name.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_i386_is_local_label_name
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'X'
condition|)
return|return
name|TRUE
return|;
return|return
name|_bfd_elf_is_local_label_name
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Support for core dump NOTE sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_i386_grok_prstatus
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Note
modifier|*
name|note
parameter_list|)
block|{
name|int
name|offset
decl_stmt|;
name|size_t
name|size
decl_stmt|;
if|if
condition|(
name|note
operator|->
name|namesz
operator|==
literal|8
operator|&&
name|strcmp
argument_list|(
name|note
operator|->
name|namedata
argument_list|,
literal|"FreeBSD"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|pr_version
init|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|note
operator|->
name|descdata
argument_list|)
decl_stmt|;
if|if
condition|(
name|pr_version
operator|!=
literal|1
condition|)
return|return
name|FALSE
return|;
comment|/* pr_cursig */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_signal
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|note
operator|->
name|descdata
operator|+
literal|20
argument_list|)
expr_stmt|;
comment|/* pr_pid */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_pid
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|note
operator|->
name|descdata
operator|+
literal|24
argument_list|)
expr_stmt|;
comment|/* pr_reg */
name|offset
operator|=
literal|28
expr_stmt|;
name|size
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|note
operator|->
name|descdata
operator|+
literal|8
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|note
operator|->
name|descsz
condition|)
block|{
default|default:
return|return
name|FALSE
return|;
case|case
literal|144
case|:
comment|/* Linux/i386 */
comment|/* pr_cursig */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_signal
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|note
operator|->
name|descdata
operator|+
literal|12
argument_list|)
expr_stmt|;
comment|/* pr_pid */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_pid
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|note
operator|->
name|descdata
operator|+
literal|24
argument_list|)
expr_stmt|;
comment|/* pr_reg */
name|offset
operator|=
literal|72
expr_stmt|;
name|size
operator|=
literal|68
expr_stmt|;
break|break;
block|}
block|}
comment|/* Make a ".reg/999" section.  */
return|return
name|_bfd_elfcore_make_pseudosection
argument_list|(
name|abfd
argument_list|,
literal|".reg"
argument_list|,
name|size
argument_list|,
name|note
operator|->
name|descpos
operator|+
name|offset
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elf_i386_grok_psinfo
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Note
modifier|*
name|note
parameter_list|)
block|{
if|if
condition|(
name|note
operator|->
name|namesz
operator|==
literal|8
operator|&&
name|strcmp
argument_list|(
name|note
operator|->
name|namedata
argument_list|,
literal|"FreeBSD"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|pr_version
init|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|note
operator|->
name|descdata
argument_list|)
decl_stmt|;
if|if
condition|(
name|pr_version
operator|!=
literal|1
condition|)
return|return
name|FALSE
return|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_program
operator|=
name|_bfd_elfcore_strndup
argument_list|(
name|abfd
argument_list|,
name|note
operator|->
name|descdata
operator|+
literal|8
argument_list|,
literal|17
argument_list|)
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_command
operator|=
name|_bfd_elfcore_strndup
argument_list|(
name|abfd
argument_list|,
name|note
operator|->
name|descdata
operator|+
literal|25
argument_list|,
literal|81
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|note
operator|->
name|descsz
condition|)
block|{
default|default:
return|return
name|FALSE
return|;
case|case
literal|124
case|:
comment|/* Linux/i386 elf_prpsinfo.  */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_program
operator|=
name|_bfd_elfcore_strndup
argument_list|(
name|abfd
argument_list|,
name|note
operator|->
name|descdata
operator|+
literal|28
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_command
operator|=
name|_bfd_elfcore_strndup
argument_list|(
name|abfd
argument_list|,
name|note
operator|->
name|descdata
operator|+
literal|44
argument_list|,
literal|80
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Note that for some reason, a spurious space is tacked      onto the end of the args in some (at least one anyway)      implementations, so strip it off if it exists.  */
block|{
name|char
modifier|*
name|command
init|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_command
decl_stmt|;
name|int
name|n
init|=
name|strlen
argument_list|(
name|command
argument_list|)
decl_stmt|;
if|if
condition|(
literal|0
operator|<
name|n
operator|&&
name|command
index|[
name|n
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
name|command
index|[
name|n
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Functions for the i386 ELF linker.     In order to gain some understanding of code in this file without    knowing all the intricate details of the linker, note the    following:     Functions named elf_i386_* are called by external routines, other    functions are only called locally.  elf_i386_* functions appear    in this file more or less in the order in which they are called    from external routines.  eg. elf_i386_check_relocs is called    early in the link process, elf_i386_finish_dynamic_sections is    one of the last functions.  */
end_comment

begin_comment
comment|/* The name of the dynamic interpreter.  This is put in the .interp    section.  */
end_comment

begin_define
define|#
directive|define
name|ELF_DYNAMIC_INTERPRETER
value|"/usr/lib/libc.so.1"
end_define

begin_comment
comment|/* If ELIMINATE_COPY_RELOCS is non-zero, the linker will try to avoid    copying dynamic variables from a shared lib into an app's dynbss    section, and instead use a dynamic relocation to point into the    shared lib.  */
end_comment

begin_define
define|#
directive|define
name|ELIMINATE_COPY_RELOCS
value|1
end_define

begin_comment
comment|/* The size in bytes of an entry in the procedure linkage table.  */
end_comment

begin_define
define|#
directive|define
name|PLT_ENTRY_SIZE
value|16
end_define

begin_comment
comment|/* The first entry in an absolute procedure linkage table looks like    this.  See the SVR4 ABI i386 supplement to see how this works.    Will be padded to PLT_ENTRY_SIZE with htab->plt0_pad_byte.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
name|elf_i386_plt0_entry
index|[
literal|12
index|]
init|=
block|{
literal|0xff
block|,
literal|0x35
block|,
comment|/* pushl contents of address */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* replaced with address of .got + 4.  */
literal|0xff
block|,
literal|0x25
block|,
comment|/* jmp indirect */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
comment|/* replaced with address of .got + 8.  */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Subsequent entries in an absolute procedure linkage table look like    this.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
name|elf_i386_plt_entry
index|[
name|PLT_ENTRY_SIZE
index|]
init|=
block|{
literal|0xff
block|,
literal|0x25
block|,
comment|/* jmp indirect */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* replaced with address of this symbol in .got.  */
literal|0x68
block|,
comment|/* pushl immediate */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* replaced with offset into relocation table.  */
literal|0xe9
block|,
comment|/* jmp relative */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
comment|/* replaced with offset to start of .plt.  */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The first entry in a PIC procedure linkage table look like this.    Will be padded to PLT_ENTRY_SIZE with htab->plt0_pad_byte.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
name|elf_i386_pic_plt0_entry
index|[
literal|12
index|]
init|=
block|{
literal|0xff
block|,
literal|0xb3
block|,
literal|4
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* pushl 4(%ebx) */
literal|0xff
block|,
literal|0xa3
block|,
literal|8
block|,
literal|0
block|,
literal|0
block|,
literal|0
comment|/* jmp *8(%ebx) */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Subsequent entries in a PIC procedure linkage table look like this.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
name|elf_i386_pic_plt_entry
index|[
name|PLT_ENTRY_SIZE
index|]
init|=
block|{
literal|0xff
block|,
literal|0xa3
block|,
comment|/* jmp *offset(%ebx) */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* replaced with offset of this symbol in .got.  */
literal|0x68
block|,
comment|/* pushl immediate */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* replaced with offset into relocation table.  */
literal|0xe9
block|,
comment|/* jmp relative */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
comment|/* replaced with offset to start of .plt.  */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* On VxWorks, the .rel.plt.unloaded section has absolute relocations    for the PLTResolve stub and then for each PLT entry.  */
end_comment

begin_define
define|#
directive|define
name|PLTRESOLVE_RELOCS_SHLIB
value|0
end_define

begin_define
define|#
directive|define
name|PLTRESOLVE_RELOCS
value|2
end_define

begin_define
define|#
directive|define
name|PLT_NON_JUMP_SLOT_RELOCS
value|2
end_define

begin_comment
comment|/* The i386 linker needs to keep track of the number of relocs that it    decides to copy as dynamic relocs in check_relocs for each symbol.    This is so that it can later discard them if they are found to be    unnecessary.  We store the information in a field extending the    regular ELF linker hash table.  */
end_comment

begin_struct
struct|struct
name|elf_i386_dyn_relocs
block|{
name|struct
name|elf_i386_dyn_relocs
modifier|*
name|next
decl_stmt|;
comment|/* The input section of the reloc.  */
name|asection
modifier|*
name|sec
decl_stmt|;
comment|/* Total number of relocs copied for the input section.  */
name|bfd_size_type
name|count
decl_stmt|;
comment|/* Number of pc-relative relocs copied for the input section.  */
name|bfd_size_type
name|pc_count
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* i386 ELF linker hash entry.  */
end_comment

begin_struct
struct|struct
name|elf_i386_link_hash_entry
block|{
name|struct
name|elf_link_hash_entry
name|elf
decl_stmt|;
comment|/* Track dynamic relocs copied for this symbol.  */
name|struct
name|elf_i386_dyn_relocs
modifier|*
name|dyn_relocs
decl_stmt|;
define|#
directive|define
name|GOT_UNKNOWN
value|0
define|#
directive|define
name|GOT_NORMAL
value|1
define|#
directive|define
name|GOT_TLS_GD
value|2
define|#
directive|define
name|GOT_TLS_IE
value|4
define|#
directive|define
name|GOT_TLS_IE_POS
value|5
define|#
directive|define
name|GOT_TLS_IE_NEG
value|6
define|#
directive|define
name|GOT_TLS_IE_BOTH
value|7
define|#
directive|define
name|GOT_TLS_GDESC
value|8
define|#
directive|define
name|GOT_TLS_GD_BOTH_P
parameter_list|(
name|type
parameter_list|)
define|\
value|((type) == (GOT_TLS_GD | GOT_TLS_GDESC))
define|#
directive|define
name|GOT_TLS_GD_P
parameter_list|(
name|type
parameter_list|)
define|\
value|((type) == GOT_TLS_GD || GOT_TLS_GD_BOTH_P (type))
define|#
directive|define
name|GOT_TLS_GDESC_P
parameter_list|(
name|type
parameter_list|)
define|\
value|((type) == GOT_TLS_GDESC || GOT_TLS_GD_BOTH_P (type))
define|#
directive|define
name|GOT_TLS_GD_ANY_P
parameter_list|(
name|type
parameter_list|)
define|\
value|(GOT_TLS_GD_P (type) || GOT_TLS_GDESC_P (type))
name|unsigned
name|char
name|tls_type
decl_stmt|;
comment|/* Offset of the GOTPLT entry reserved for the TLS descriptor,      starting at the end of the jump table.  */
name|bfd_vma
name|tlsdesc_got
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|elf_i386_hash_entry
parameter_list|(
name|ent
parameter_list|)
value|((struct elf_i386_link_hash_entry *)(ent))
end_define

begin_struct
struct|struct
name|elf_i386_obj_tdata
block|{
name|struct
name|elf_obj_tdata
name|root
decl_stmt|;
comment|/* tls_type for each local got entry.  */
name|char
modifier|*
name|local_got_tls_type
decl_stmt|;
comment|/* GOTPLT entries for TLS descriptors.  */
name|bfd_vma
modifier|*
name|local_tlsdesc_gotent
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|elf_i386_tdata
parameter_list|(
name|abfd
parameter_list|)
define|\
value|((struct elf_i386_obj_tdata *) (abfd)->tdata.any)
end_define

begin_define
define|#
directive|define
name|elf_i386_local_got_tls_type
parameter_list|(
name|abfd
parameter_list|)
define|\
value|(elf_i386_tdata (abfd)->local_got_tls_type)
end_define

begin_define
define|#
directive|define
name|elf_i386_local_tlsdesc_gotent
parameter_list|(
name|abfd
parameter_list|)
define|\
value|(elf_i386_tdata (abfd)->local_tlsdesc_gotent)
end_define

begin_function
specifier|static
name|bfd_boolean
name|elf_i386_mkobject
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
if|if
condition|(
name|abfd
operator|->
name|tdata
operator|.
name|any
operator|==
name|NULL
condition|)
block|{
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|elf_i386_obj_tdata
argument_list|)
decl_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|any
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|tdata
operator|.
name|any
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|bfd_elf_mkobject
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* i386 ELF linker hash table.  */
end_comment

begin_struct
struct|struct
name|elf_i386_link_hash_table
block|{
name|struct
name|elf_link_hash_table
name|elf
decl_stmt|;
comment|/* Short-cuts to get to dynamic linker sections.  */
name|asection
modifier|*
name|sgot
decl_stmt|;
name|asection
modifier|*
name|sgotplt
decl_stmt|;
name|asection
modifier|*
name|srelgot
decl_stmt|;
name|asection
modifier|*
name|splt
decl_stmt|;
name|asection
modifier|*
name|srelplt
decl_stmt|;
name|asection
modifier|*
name|sdynbss
decl_stmt|;
name|asection
modifier|*
name|srelbss
decl_stmt|;
comment|/* The (unloaded but important) .rel.plt.unloaded section on VxWorks.  */
name|asection
modifier|*
name|srelplt2
decl_stmt|;
comment|/* True if the target system is VxWorks.  */
name|int
name|is_vxworks
decl_stmt|;
comment|/* Value used to fill the last word of the first plt entry.  */
name|bfd_byte
name|plt0_pad_byte
decl_stmt|;
comment|/* The index of the next unused R_386_TLS_DESC slot in .rel.plt.  */
name|bfd_vma
name|next_tls_desc_index
decl_stmt|;
union|union
block|{
name|bfd_signed_vma
name|refcount
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
block|}
name|tls_ldm_got
union|;
comment|/* The amount of space used by the reserved portion of the sgotplt      section, plus whatever space is used by the jump slots.  */
name|bfd_vma
name|sgotplt_jump_table_size
decl_stmt|;
comment|/* Small local sym to section mapping cache.  */
name|struct
name|sym_sec_cache
name|sym_sec
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Get the i386 ELF linker hash table from a link_info structure.  */
end_comment

begin_define
define|#
directive|define
name|elf_i386_hash_table
parameter_list|(
name|p
parameter_list|)
define|\
value|((struct elf_i386_link_hash_table *) ((p)->hash))
end_define

begin_define
define|#
directive|define
name|elf_i386_compute_jump_table_size
parameter_list|(
name|htab
parameter_list|)
define|\
value|((htab)->next_tls_desc_index * 4)
end_define

begin_comment
comment|/* Create an entry in an i386 ELF linker hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|link_hash_newfunc
parameter_list|(
name|struct
name|bfd_hash_entry
modifier|*
name|entry
parameter_list|,
name|struct
name|bfd_hash_table
modifier|*
name|table
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
comment|/* Allocate the structure if it has not already been allocated by a      subclass.  */
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
name|entry
operator|=
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|elf_i386_link_hash_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
return|return
name|entry
return|;
block|}
comment|/* Call the allocation method of the superclass.  */
name|entry
operator|=
name|_bfd_elf_link_hash_newfunc
argument_list|(
name|entry
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|!=
name|NULL
condition|)
block|{
name|struct
name|elf_i386_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|elf_i386_link_hash_entry
operator|*
operator|)
name|entry
expr_stmt|;
name|eh
operator|->
name|dyn_relocs
operator|=
name|NULL
expr_stmt|;
name|eh
operator|->
name|tls_type
operator|=
name|GOT_UNKNOWN
expr_stmt|;
name|eh
operator|->
name|tlsdesc_got
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|entry
return|;
block|}
end_function

begin_comment
comment|/* Create an i386 ELF linker hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_link_hash_table
modifier|*
name|elf_i386_link_hash_table_create
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|struct
name|elf_i386_link_hash_table
modifier|*
name|ret
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|elf_i386_link_hash_table
argument_list|)
decl_stmt|;
name|ret
operator|=
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|_bfd_elf_link_hash_table_init
argument_list|(
operator|&
name|ret
operator|->
name|elf
argument_list|,
name|abfd
argument_list|,
name|link_hash_newfunc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|elf_i386_link_hash_entry
argument_list|)
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ret
operator|->
name|sgot
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|sgotplt
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|srelgot
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|splt
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|srelplt
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|sdynbss
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|srelbss
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|tls_ldm_got
operator|.
name|refcount
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|next_tls_desc_index
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|sgotplt_jump_table_size
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|sym_sec
operator|.
name|abfd
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|is_vxworks
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|srelplt2
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|plt0_pad_byte
operator|=
literal|0
expr_stmt|;
return|return
operator|&
name|ret
operator|->
name|elf
operator|.
name|root
return|;
block|}
end_function

begin_comment
comment|/* Create .got, .gotplt, and .rel.got sections in DYNOBJ, and set up    shortcuts to them in our hash table.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|create_got_section
parameter_list|(
name|bfd
modifier|*
name|dynobj
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|elf_i386_link_hash_table
modifier|*
name|htab
decl_stmt|;
if|if
condition|(
operator|!
name|_bfd_elf_create_got_section
argument_list|(
name|dynobj
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|htab
operator|=
name|elf_i386_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|htab
operator|->
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
name|htab
operator|->
name|sgotplt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got.plt"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|htab
operator|->
name|sgot
operator|||
operator|!
name|htab
operator|->
name|sgotplt
condition|)
name|abort
argument_list|()
expr_stmt|;
name|htab
operator|->
name|srelgot
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|dynobj
argument_list|,
literal|".rel.got"
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_READONLY
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|srelgot
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|htab
operator|->
name|srelgot
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Create .plt, .rel.plt, .got, .got.plt, .rel.got, .dynbss, and    .rel.bss sections in DYNOBJ, and set up shortcuts to them in our    hash table.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_i386_create_dynamic_sections
parameter_list|(
name|bfd
modifier|*
name|dynobj
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|elf_i386_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|htab
operator|=
name|elf_i386_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|htab
operator|->
name|sgot
operator|&&
operator|!
name|create_got_section
argument_list|(
name|dynobj
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|_bfd_elf_create_dynamic_sections
argument_list|(
name|dynobj
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|htab
operator|->
name|splt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
name|htab
operator|->
name|srelplt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rel.plt"
argument_list|)
expr_stmt|;
name|htab
operator|->
name|sdynbss
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynbss"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
name|htab
operator|->
name|srelbss
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rel.bss"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|htab
operator|->
name|splt
operator|||
operator|!
name|htab
operator|->
name|srelplt
operator|||
operator|!
name|htab
operator|->
name|sdynbss
operator|||
operator|(
operator|!
name|info
operator|->
name|shared
operator|&&
operator|!
name|htab
operator|->
name|srelbss
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|is_vxworks
operator|&&
operator|!
name|elf_vxworks_create_dynamic_sections
argument_list|(
name|dynobj
argument_list|,
name|info
argument_list|,
operator|&
name|htab
operator|->
name|srelplt2
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Copy the extra info we tack onto an elf_link_hash_entry.  */
end_comment

begin_function
specifier|static
name|void
name|elf_i386_copy_indirect_symbol
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|dir
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|ind
parameter_list|)
block|{
name|struct
name|elf_i386_link_hash_entry
modifier|*
name|edir
decl_stmt|,
modifier|*
name|eind
decl_stmt|;
name|edir
operator|=
operator|(
expr|struct
name|elf_i386_link_hash_entry
operator|*
operator|)
name|dir
expr_stmt|;
name|eind
operator|=
operator|(
expr|struct
name|elf_i386_link_hash_entry
operator|*
operator|)
name|ind
expr_stmt|;
if|if
condition|(
name|eind
operator|->
name|dyn_relocs
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|edir
operator|->
name|dyn_relocs
operator|!=
name|NULL
condition|)
block|{
name|struct
name|elf_i386_dyn_relocs
modifier|*
modifier|*
name|pp
decl_stmt|;
name|struct
name|elf_i386_dyn_relocs
modifier|*
name|p
decl_stmt|;
comment|/* Add reloc counts against the indirect sym to the direct sym 	     list.  Merge any entries against the same section.  */
for|for
control|(
name|pp
operator|=
operator|&
name|eind
operator|->
name|dyn_relocs
init|;
operator|(
name|p
operator|=
operator|*
name|pp
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
name|struct
name|elf_i386_dyn_relocs
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|q
operator|=
name|edir
operator|->
name|dyn_relocs
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|next
control|)
if|if
condition|(
name|q
operator|->
name|sec
operator|==
name|p
operator|->
name|sec
condition|)
block|{
name|q
operator|->
name|pc_count
operator|+=
name|p
operator|->
name|pc_count
expr_stmt|;
name|q
operator|->
name|count
operator|+=
name|p
operator|->
name|count
expr_stmt|;
operator|*
name|pp
operator|=
name|p
operator|->
name|next
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
name|pp
operator|=
operator|&
name|p
operator|->
name|next
expr_stmt|;
block|}
operator|*
name|pp
operator|=
name|edir
operator|->
name|dyn_relocs
expr_stmt|;
block|}
name|edir
operator|->
name|dyn_relocs
operator|=
name|eind
operator|->
name|dyn_relocs
expr_stmt|;
name|eind
operator|->
name|dyn_relocs
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ind
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|&&
name|dir
operator|->
name|got
operator|.
name|refcount
operator|<=
literal|0
condition|)
block|{
name|edir
operator|->
name|tls_type
operator|=
name|eind
operator|->
name|tls_type
expr_stmt|;
name|eind
operator|->
name|tls_type
operator|=
name|GOT_UNKNOWN
expr_stmt|;
block|}
if|if
condition|(
name|ELIMINATE_COPY_RELOCS
operator|&&
name|ind
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_indirect
operator|&&
name|dir
operator|->
name|dynamic_adjusted
condition|)
block|{
comment|/* If called to transfer flags for a weakdef during processing 	 of elf_adjust_dynamic_symbol, don't copy non_got_ref. 	 We clear it ourselves for ELIMINATE_COPY_RELOCS.  */
name|dir
operator|->
name|ref_dynamic
operator||=
name|ind
operator|->
name|ref_dynamic
expr_stmt|;
name|dir
operator|->
name|ref_regular
operator||=
name|ind
operator|->
name|ref_regular
expr_stmt|;
name|dir
operator|->
name|ref_regular_nonweak
operator||=
name|ind
operator|->
name|ref_regular_nonweak
expr_stmt|;
name|dir
operator|->
name|needs_plt
operator||=
name|ind
operator|->
name|needs_plt
expr_stmt|;
name|dir
operator|->
name|pointer_equality_needed
operator||=
name|ind
operator|->
name|pointer_equality_needed
expr_stmt|;
block|}
else|else
name|_bfd_elf_link_hash_copy_indirect
argument_list|(
name|info
argument_list|,
name|dir
argument_list|,
name|ind
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|elf_i386_tls_transition
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|int
name|r_type
parameter_list|,
name|int
name|is_local
parameter_list|)
block|{
if|if
condition|(
name|info
operator|->
name|shared
condition|)
return|return
name|r_type
return|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_386_TLS_GD
case|:
case|case
name|R_386_TLS_GOTDESC
case|:
case|case
name|R_386_TLS_DESC_CALL
case|:
case|case
name|R_386_TLS_IE_32
case|:
if|if
condition|(
name|is_local
condition|)
return|return
name|R_386_TLS_LE_32
return|;
return|return
name|R_386_TLS_IE_32
return|;
case|case
name|R_386_TLS_IE
case|:
case|case
name|R_386_TLS_GOTIE
case|:
if|if
condition|(
name|is_local
condition|)
return|return
name|R_386_TLS_LE_32
return|;
return|return
name|r_type
return|;
case|case
name|R_386_TLS_LDM
case|:
return|return
name|R_386_TLS_LE_32
return|;
block|}
return|return
name|r_type
return|;
block|}
end_function

begin_comment
comment|/* Look through the relocs for a section during the first phase, and    calculate needed space in the global offset table, procedure linkage    table, and dynamic reloc sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_i386_check_relocs
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
parameter_list|)
block|{
name|struct
name|elf_i386_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel_end
decl_stmt|;
name|asection
modifier|*
name|sreloc
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
return|return
name|TRUE
return|;
name|htab
operator|=
name|elf_i386_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|sreloc
operator|=
name|NULL
expr_stmt|;
name|rel_end
operator|=
name|relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|rel_end
condition|;
name|rel
operator|++
control|)
block|{
name|unsigned
name|int
name|r_type
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|>=
name|NUM_SHDR_ENTRIES
argument_list|(
name|symtab_hdr
argument_list|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: bad symbol index: %d"
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|r_symndx
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
name|h
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
block|}
name|r_type
operator|=
name|elf_i386_tls_transition
argument_list|(
name|info
argument_list|,
name|r_type
argument_list|,
name|h
operator|==
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_386_TLS_LDM
case|:
name|htab
operator|->
name|tls_ldm_got
operator|.
name|refcount
operator|+=
literal|1
expr_stmt|;
goto|goto
name|create_got
goto|;
case|case
name|R_386_PLT32
case|:
comment|/* This symbol requires a procedure linkage table entry.  We 	     actually build the entry in adjust_dynamic_symbol, 	     because this might be a case of linking PIC code which is 	     never referenced by a dynamic object, in which case we 	     don't need to generate a procedure linkage table entry 	     after all.  */
comment|/* If this is a local symbol, we resolve it directly without 	     creating a procedure linkage table entry.  */
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
continue|continue;
name|h
operator|->
name|needs_plt
operator|=
literal|1
expr_stmt|;
name|h
operator|->
name|plt
operator|.
name|refcount
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|R_386_TLS_IE_32
case|:
case|case
name|R_386_TLS_IE
case|:
case|case
name|R_386_TLS_GOTIE
case|:
if|if
condition|(
name|info
operator|->
name|shared
condition|)
name|info
operator|->
name|flags
operator||=
name|DF_STATIC_TLS
expr_stmt|;
comment|/* Fall through */
case|case
name|R_386_GOT32
case|:
case|case
name|R_386_TLS_GD
case|:
case|case
name|R_386_TLS_GOTDESC
case|:
case|case
name|R_386_TLS_DESC_CALL
case|:
comment|/* This symbol requires a global offset table entry.  */
block|{
name|int
name|tls_type
decl_stmt|,
name|old_tls_type
decl_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
default|default:
case|case
name|R_386_GOT32
case|:
name|tls_type
operator|=
name|GOT_NORMAL
expr_stmt|;
break|break;
case|case
name|R_386_TLS_GD
case|:
name|tls_type
operator|=
name|GOT_TLS_GD
expr_stmt|;
break|break;
case|case
name|R_386_TLS_GOTDESC
case|:
case|case
name|R_386_TLS_DESC_CALL
case|:
name|tls_type
operator|=
name|GOT_TLS_GDESC
expr_stmt|;
break|break;
case|case
name|R_386_TLS_IE_32
case|:
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|==
name|r_type
condition|)
name|tls_type
operator|=
name|GOT_TLS_IE_NEG
expr_stmt|;
else|else
comment|/* If this is a GD->IE transition, we may use either of 		     R_386_TLS_TPOFF and R_386_TLS_TPOFF32.  */
name|tls_type
operator|=
name|GOT_TLS_IE
expr_stmt|;
break|break;
case|case
name|R_386_TLS_IE
case|:
case|case
name|R_386_TLS_GOTIE
case|:
name|tls_type
operator|=
name|GOT_TLS_IE_POS
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|h
operator|->
name|got
operator|.
name|refcount
operator|+=
literal|1
expr_stmt|;
name|old_tls_type
operator|=
name|elf_i386_hash_entry
argument_list|(
name|h
argument_list|)
operator|->
name|tls_type
expr_stmt|;
block|}
else|else
block|{
name|bfd_signed_vma
modifier|*
name|local_got_refcounts
decl_stmt|;
comment|/* This is a global offset table entry for a local symbol.  */
name|local_got_refcounts
operator|=
name|elf_local_got_refcounts
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_got_refcounts
operator|==
name|NULL
condition|)
block|{
name|bfd_size_type
name|size
decl_stmt|;
name|size
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|size
operator|*=
operator|(
sizeof|sizeof
argument_list|(
name|bfd_signed_vma
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|bfd_vma
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|)
expr_stmt|;
name|local_got_refcounts
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_got_refcounts
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|elf_local_got_refcounts
argument_list|(
name|abfd
argument_list|)
operator|=
name|local_got_refcounts
expr_stmt|;
name|elf_i386_local_tlsdesc_gotent
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
name|bfd_vma
operator|*
operator|)
operator|(
name|local_got_refcounts
operator|+
name|symtab_hdr
operator|->
name|sh_info
operator|)
expr_stmt|;
name|elf_i386_local_got_tls_type
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|local_got_refcounts
operator|+
literal|2
operator|*
name|symtab_hdr
operator|->
name|sh_info
operator|)
expr_stmt|;
block|}
name|local_got_refcounts
index|[
name|r_symndx
index|]
operator|+=
literal|1
expr_stmt|;
name|old_tls_type
operator|=
name|elf_i386_local_got_tls_type
argument_list|(
name|abfd
argument_list|)
index|[
name|r_symndx
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|old_tls_type
operator|&
name|GOT_TLS_IE
operator|)
operator|&&
operator|(
name|tls_type
operator|&
name|GOT_TLS_IE
operator|)
condition|)
name|tls_type
operator||=
name|old_tls_type
expr_stmt|;
comment|/* If a TLS symbol is accessed using IE at least once, 	       there is no point to use dynamic model for it.  */
elseif|else
if|if
condition|(
name|old_tls_type
operator|!=
name|tls_type
operator|&&
name|old_tls_type
operator|!=
name|GOT_UNKNOWN
operator|&&
operator|(
operator|!
name|GOT_TLS_GD_ANY_P
argument_list|(
name|old_tls_type
argument_list|)
operator|||
operator|(
name|tls_type
operator|&
name|GOT_TLS_IE
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|old_tls_type
operator|&
name|GOT_TLS_IE
operator|)
operator|&&
name|GOT_TLS_GD_ANY_P
argument_list|(
name|tls_type
argument_list|)
condition|)
name|tls_type
operator|=
name|old_tls_type
expr_stmt|;
elseif|else
if|if
condition|(
name|GOT_TLS_GD_ANY_P
argument_list|(
name|old_tls_type
argument_list|)
operator|&&
name|GOT_TLS_GD_ANY_P
argument_list|(
name|tls_type
argument_list|)
condition|)
name|tls_type
operator||=
name|old_tls_type
expr_stmt|;
else|else
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: `%s' accessed both as normal and "
literal|"thread local symbol"
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|h
condition|?
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
else|:
literal|"<local>"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
if|if
condition|(
name|old_tls_type
operator|!=
name|tls_type
condition|)
block|{
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|elf_i386_hash_entry
argument_list|(
name|h
argument_list|)
operator|->
name|tls_type
operator|=
name|tls_type
expr_stmt|;
else|else
name|elf_i386_local_got_tls_type
argument_list|(
name|abfd
argument_list|)
index|[
name|r_symndx
index|]
operator|=
name|tls_type
expr_stmt|;
block|}
block|}
comment|/* Fall through */
case|case
name|R_386_GOTOFF
case|:
case|case
name|R_386_GOTPC
case|:
name|create_got
label|:
if|if
condition|(
name|htab
operator|->
name|sgot
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
operator|==
name|NULL
condition|)
name|htab
operator|->
name|elf
operator|.
name|dynobj
operator|=
name|abfd
expr_stmt|;
if|if
condition|(
operator|!
name|create_got_section
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|r_type
operator|!=
name|R_386_TLS_IE
condition|)
break|break;
comment|/* Fall through */
case|case
name|R_386_TLS_LE_32
case|:
case|case
name|R_386_TLS_LE
case|:
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
break|break;
name|info
operator|->
name|flags
operator||=
name|DF_STATIC_TLS
expr_stmt|;
comment|/* Fall through */
case|case
name|R_386_32
case|:
case|case
name|R_386_PC32
case|:
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|!
name|info
operator|->
name|shared
condition|)
block|{
comment|/* If this reloc is in a read-only section, we might 		 need a copy reloc.  We can't check reliably at this 		 stage whether the section is read-only, as input 		 sections have not yet been mapped to output sections. 		 Tentatively set the flag for now, and correct in 		 adjust_dynamic_symbol.  */
name|h
operator|->
name|non_got_ref
operator|=
literal|1
expr_stmt|;
comment|/* We may need a .plt entry if the function this reloc 		 refers to is in a shared lib.  */
name|h
operator|->
name|plt
operator|.
name|refcount
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|r_type
operator|!=
name|R_386_PC32
condition|)
name|h
operator|->
name|pointer_equality_needed
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If we are creating a shared library, and this is a reloc 	     against a global symbol, or a non PC relative reloc 	     against a local symbol, then we need to copy the reloc 	     into the shared library.  However, if we are linking with 	     -Bsymbolic, we do not need to copy a reloc against a 	     global symbol which is defined in an object we are 	     including in the link (i.e., DEF_REGULAR is set).  At 	     this point we have not seen all the input files, so it is 	     possible that DEF_REGULAR is not set now but will be set 	     later (it is never cleared).  In case of a weak definition, 	     DEF_REGULAR may be cleared later by a strong definition in 	     a shared library.  We account for that possibility below by 	     storing information in the relocs_copied field of the hash 	     table entry.  A similar situation occurs when creating 	     shared libraries and symbol visibility changes render the 	     symbol local.  	     If on the other hand, we are creating an executable, we 	     may need to keep relocations for symbols satisfied by a 	     dynamic library if we manage to avoid copy relocs for the 	     symbol.  */
if|if
condition|(
operator|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|r_type
operator|!=
name|R_386_PC32
operator|||
operator|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
operator|!
name|SYMBOLIC_BIND
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|||
operator|!
name|h
operator|->
name|def_regular
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|ELIMINATE_COPY_RELOCS
operator|&&
operator|!
name|info
operator|->
name|shared
operator|&&
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
operator|&&
name|h
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|||
operator|!
name|h
operator|->
name|def_regular
operator|)
operator|)
condition|)
block|{
name|struct
name|elf_i386_dyn_relocs
modifier|*
name|p
decl_stmt|;
name|struct
name|elf_i386_dyn_relocs
modifier|*
modifier|*
name|head
decl_stmt|;
comment|/* We must copy these reloc types into the output file. 		 Create a reloc section in dynobj and make room for 		 this reloc.  */
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|unsigned
name|int
name|strndx
init|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_shstrndx
decl_stmt|;
name|unsigned
name|int
name|shnam
init|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|rel_hdr
operator|.
name|sh_name
decl_stmt|;
name|name
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|abfd
argument_list|,
name|strndx
argument_list|,
name|shnam
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|CONST_STRNEQ
argument_list|(
name|name
argument_list|,
literal|".rel"
argument_list|)
operator|||
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|,
name|name
operator|+
literal|4
argument_list|)
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: bad relocation section name `%s\'"
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
operator|==
name|NULL
condition|)
name|htab
operator|->
name|elf
operator|.
name|dynobj
operator|=
name|abfd
expr_stmt|;
name|dynobj
operator|=
name|htab
operator|->
name|elf
operator|.
name|dynobj
expr_stmt|;
name|sreloc
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
block|{
name|flagword
name|flags
decl_stmt|;
name|flags
operator|=
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_READONLY
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
name|flags
operator||=
name|SEC_ALLOC
operator||
name|SEC_LOAD
expr_stmt|;
name|sreloc
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|dynobj
argument_list|,
name|name
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|sreloc
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|sreloc
operator|=
name|sreloc
expr_stmt|;
block|}
comment|/* If this is a global symbol, we count the number of 		 relocations we need for this symbol.  */
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|head
operator|=
operator|&
operator|(
operator|(
expr|struct
name|elf_i386_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|dyn_relocs
expr_stmt|;
block|}
else|else
block|{
name|void
modifier|*
modifier|*
name|vpp
decl_stmt|;
comment|/* Track dynamic relocs needed for local syms too. 		     We really need local syms available to do this 		     easily.  Oh well.  */
name|asection
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|bfd_section_from_r_symndx
argument_list|(
name|abfd
argument_list|,
operator|&
name|htab
operator|->
name|sym_sec
argument_list|,
name|sec
argument_list|,
name|r_symndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|vpp
operator|=
operator|&
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|local_dynrel
expr_stmt|;
name|head
operator|=
operator|(
expr|struct
name|elf_i386_dyn_relocs
operator|*
operator|*
operator|)
name|vpp
expr_stmt|;
block|}
name|p
operator|=
operator|*
name|head
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|p
operator|->
name|sec
operator|!=
name|sec
condition|)
block|{
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
expr|*
name|p
decl_stmt|;
name|p
operator|=
name|bfd_alloc
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|p
operator|->
name|next
operator|=
operator|*
name|head
expr_stmt|;
operator|*
name|head
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|sec
operator|=
name|sec
expr_stmt|;
name|p
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|pc_count
operator|=
literal|0
expr_stmt|;
block|}
name|p
operator|->
name|count
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_386_PC32
condition|)
name|p
operator|->
name|pc_count
operator|+=
literal|1
expr_stmt|;
block|}
break|break;
comment|/* This relocation describes the C++ object vtable hierarchy. 	     Reconstruct it for later use during GC.  */
case|case
name|R_386_GNU_VTINHERIT
case|:
if|if
condition|(
operator|!
name|bfd_elf_gc_record_vtinherit
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|h
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
comment|/* This relocation describes which C++ vtable entries are actually 	     used.  Record for later use during GC.  */
case|case
name|R_386_GNU_VTENTRY
case|:
if|if
condition|(
operator|!
name|bfd_elf_gc_record_vtentry
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|h
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
default|default:
break|break;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return the section that should be marked against GC for a given    relocation.  */
end_comment

begin_function
specifier|static
name|asection
modifier|*
name|elf_i386_gc_mark_hook
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|rel
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|)
block|{
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
switch|switch
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_386_GNU_VTINHERIT
case|:
case|case
name|R_386_GNU_VTENTRY
case|:
return|return
name|NULL
return|;
block|}
return|return
name|_bfd_elf_gc_mark_hook
argument_list|(
name|sec
argument_list|,
name|info
argument_list|,
name|rel
argument_list|,
name|h
argument_list|,
name|sym
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Update the got entry reference counts for the section being removed.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_i386_gc_sweep_hook
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|bfd_signed_vma
modifier|*
name|local_got_refcounts
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|,
modifier|*
name|relend
decl_stmt|;
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|local_dynrel
operator|=
name|NULL
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|local_got_refcounts
operator|=
name|elf_local_got_refcounts
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|unsigned
name|int
name|r_type
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
init|=
name|NULL
decl_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|>=
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|struct
name|elf_i386_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|struct
name|elf_i386_dyn_relocs
modifier|*
modifier|*
name|pp
decl_stmt|;
name|struct
name|elf_i386_dyn_relocs
modifier|*
name|p
decl_stmt|;
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|elf_i386_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
for|for
control|(
name|pp
operator|=
operator|&
name|eh
operator|->
name|dyn_relocs
init|;
operator|(
name|p
operator|=
operator|*
name|pp
operator|)
operator|!=
name|NULL
condition|;
name|pp
operator|=
operator|&
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|sec
operator|==
name|sec
condition|)
block|{
comment|/* Everything must go for SEC.  */
operator|*
name|pp
operator|=
name|p
operator|->
name|next
expr_stmt|;
break|break;
block|}
block|}
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|elf_i386_tls_transition
argument_list|(
name|info
argument_list|,
name|r_type
argument_list|,
name|h
operator|!=
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_386_TLS_LDM
case|:
if|if
condition|(
name|elf_i386_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|tls_ldm_got
operator|.
name|refcount
operator|>
literal|0
condition|)
name|elf_i386_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|tls_ldm_got
operator|.
name|refcount
operator|-=
literal|1
expr_stmt|;
break|break;
case|case
name|R_386_TLS_GD
case|:
case|case
name|R_386_TLS_GOTDESC
case|:
case|case
name|R_386_TLS_DESC_CALL
case|:
case|case
name|R_386_TLS_IE_32
case|:
case|case
name|R_386_TLS_IE
case|:
case|case
name|R_386_TLS_GOTIE
case|:
case|case
name|R_386_GOT32
case|:
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|refcount
operator|>
literal|0
condition|)
name|h
operator|->
name|got
operator|.
name|refcount
operator|-=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|local_got_refcounts
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|local_got_refcounts
index|[
name|r_symndx
index|]
operator|>
literal|0
condition|)
name|local_got_refcounts
index|[
name|r_symndx
index|]
operator|-=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|R_386_32
case|:
case|case
name|R_386_PC32
case|:
if|if
condition|(
name|info
operator|->
name|shared
condition|)
break|break;
comment|/* Fall through */
case|case
name|R_386_PLT32
case|:
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|refcount
operator|>
literal|0
condition|)
name|h
operator|->
name|plt
operator|.
name|refcount
operator|-=
literal|1
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Adjust a symbol defined by a dynamic object and referenced by a    regular object.  The current definition is in some section of the    dynamic object, but we're not including those sections.  We have to    change the definition to something the rest of the link can    understand.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_i386_adjust_dynamic_symbol
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|)
block|{
name|struct
name|elf_i386_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
comment|/* If this is a function, put it in the procedure linkage table.  We      will fill in the contents of the procedure linkage table later,      when we know the address of the .got section.  */
if|if
condition|(
name|h
operator|->
name|type
operator|==
name|STT_FUNC
operator|||
name|h
operator|->
name|needs_plt
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|refcount
operator|<=
literal|0
operator|||
name|SYMBOL_CALLS_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
operator|||
operator|(
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|!=
name|STV_DEFAULT
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|)
condition|)
block|{
comment|/* This case can occur if we saw a PLT32 reloc in an input 	     file, but the symbol was never referred to by a dynamic 	     object, or if all references were garbage collected.  In 	     such a case, we don't actually need to build a procedure 	     linkage table, and we can just do a PC32 reloc instead.  */
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
name|h
operator|->
name|needs_plt
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
else|else
comment|/* It's possible that we incorrectly decided a .plt reloc was        needed for an R_386_PC32 reloc to a non-function sym in        check_relocs.  We can't decide accurately between function and        non-function syms in check-relocs;  Objects loaded later in        the link may change h->type.  So fix it now.  */
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* If this is a weak symbol, and there is a real definition, the      processor independent code will have arranged for us to see the      real definition first, and we can just use the same value.  */
if|if
condition|(
name|h
operator|->
name|u
operator|.
name|weakdef
operator|!=
name|NULL
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
argument_list|)
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
if|if
condition|(
name|ELIMINATE_COPY_RELOCS
operator|||
name|info
operator|->
name|nocopyreloc
condition|)
name|h
operator|->
name|non_got_ref
operator|=
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|non_got_ref
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* This is a reference to a symbol defined by a dynamic object which      is not a function.  */
comment|/* If we are creating a shared library, we must presume that the      only references to the symbol are via the global offset table.      For such cases we need not do anything here; the relocations will      be handled correctly by relocate_section.  */
if|if
condition|(
name|info
operator|->
name|shared
condition|)
return|return
name|TRUE
return|;
comment|/* If there are no references to this symbol that do not use the      GOT, we don't need to generate a copy reloc.  */
if|if
condition|(
operator|!
name|h
operator|->
name|non_got_ref
condition|)
return|return
name|TRUE
return|;
comment|/* If -z nocopyreloc was given, we won't generate them either.  */
if|if
condition|(
name|info
operator|->
name|nocopyreloc
condition|)
block|{
name|h
operator|->
name|non_got_ref
operator|=
literal|0
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|htab
operator|=
name|elf_i386_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* If there aren't any dynamic relocs in read-only sections, then      we can keep the dynamic relocs and avoid the copy reloc.  This      doesn't work on VxWorks, where we can not have dynamic relocations      (other than copy and jump slot relocations) in an executable.  */
if|if
condition|(
name|ELIMINATE_COPY_RELOCS
operator|&&
operator|!
name|htab
operator|->
name|is_vxworks
condition|)
block|{
name|struct
name|elf_i386_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|struct
name|elf_i386_dyn_relocs
modifier|*
name|p
decl_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|elf_i386_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
for|for
control|(
name|p
operator|=
name|eh
operator|->
name|dyn_relocs
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|s
operator|=
name|p
operator|->
name|sec
operator|->
name|output_section
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|!=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|h
operator|->
name|non_got_ref
operator|=
literal|0
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
if|if
condition|(
name|h
operator|->
name|size
operator|==
literal|0
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"dynamic variable `%s' is zero size"
argument_list|)
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* We must allocate the symbol in our .dynbss section, which will      become part of the .bss section of the executable.  There will be      an entry for this symbol in the .dynsym section.  The dynamic      object will contain position independent code, so all references      from the dynamic object to this symbol will go through the global      offset table.  The dynamic linker will use the .dynsym entry to      determine the address it must put in the global offset table, so      both the dynamic object and the regular object will refer to the      same memory location for the variable.  */
comment|/* We must generate a R_386_COPY reloc to tell the dynamic linker to      copy the initial value out of the dynamic object and into the      runtime process image.  */
if|if
condition|(
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
name|htab
operator|->
name|srelbss
operator|->
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
expr_stmt|;
name|h
operator|->
name|needs_copy
operator|=
literal|1
expr_stmt|;
block|}
name|s
operator|=
name|htab
operator|->
name|sdynbss
expr_stmt|;
return|return
name|_bfd_elf_adjust_dynamic_copy
argument_list|(
name|h
argument_list|,
name|s
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Allocate space in .plt, .got and associated reloc sections for    dynamic relocs.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|allocate_dynrelocs
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|void
modifier|*
name|inf
parameter_list|)
block|{
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|elf_i386_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|struct
name|elf_i386_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|struct
name|elf_i386_dyn_relocs
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
comment|/* When warning symbols are created, they **replace** the "real"        entry in the hash table, thus we never get to see the real        symbol in a hash traversal.  So look at it now.  */
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|info
operator|=
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|)
name|inf
expr_stmt|;
name|htab
operator|=
name|elf_i386_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|elf
operator|.
name|dynamic_sections_created
operator|&&
name|h
operator|->
name|plt
operator|.
name|refcount
operator|>
literal|0
condition|)
block|{
comment|/* Make sure this symbol is output as a dynamic symbol. 	 Undefined weak syms won't yet be marked as dynamic.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|&&
operator|!
name|h
operator|->
name|forced_local
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|info
operator|->
name|shared
operator|||
name|WILL_CALL_FINISH_DYNAMIC_SYMBOL
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
name|h
argument_list|)
condition|)
block|{
name|asection
modifier|*
name|s
init|=
name|htab
operator|->
name|splt
decl_stmt|;
comment|/* If this is the first .plt entry, make room for the special 	     first entry.  */
if|if
condition|(
name|s
operator|->
name|size
operator|==
literal|0
condition|)
name|s
operator|->
name|size
operator|+=
name|PLT_ENTRY_SIZE
expr_stmt|;
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
name|s
operator|->
name|size
expr_stmt|;
comment|/* If this symbol is not defined in a regular file, and we are 	     not generating a shared library, then set the symbol to this 	     location in the .plt.  This is required to make function 	     pointers compare as equal between the normal executable and 	     the shared library.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
operator|&&
operator|!
name|h
operator|->
name|def_regular
condition|)
block|{
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|s
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|h
operator|->
name|plt
operator|.
name|offset
expr_stmt|;
block|}
comment|/* Make room for this entry.  */
name|s
operator|->
name|size
operator|+=
name|PLT_ENTRY_SIZE
expr_stmt|;
comment|/* We also need to make an entry in the .got.plt section, which 	     will be placed in the .got section by the linker script.  */
name|htab
operator|->
name|sgotplt
operator|->
name|size
operator|+=
literal|4
expr_stmt|;
comment|/* We also need to make an entry in the .rel.plt section.  */
name|htab
operator|->
name|srelplt
operator|->
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
expr_stmt|;
name|htab
operator|->
name|next_tls_desc_index
operator|++
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|is_vxworks
operator|&&
operator|!
name|info
operator|->
name|shared
condition|)
block|{
comment|/* VxWorks has a second set of relocations for each PLT entry 		 in executables.  They go in a separate relocation section, 		 which is processed by the kernel loader.  */
comment|/* There are two relocations for the initial PLT entry: an 		 R_386_32 relocation for _GLOBAL_OFFSET_TABLE_ + 4 and an 		 R_386_32 relocation for _GLOBAL_OFFSET_TABLE_ + 8.  */
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|==
name|PLT_ENTRY_SIZE
condition|)
name|htab
operator|->
name|srelplt2
operator|->
name|size
operator|+=
operator|(
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
operator|*
literal|2
operator|)
expr_stmt|;
comment|/* There are two extra relocations for each subsequent PLT entry: 		 an R_386_32 relocation for the GOT entry, and an R_386_32 		 relocation for the PLT entry.  */
name|htab
operator|->
name|srelplt2
operator|->
name|size
operator|+=
operator|(
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
operator|*
literal|2
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
name|h
operator|->
name|needs_plt
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
name|h
operator|->
name|needs_plt
operator|=
literal|0
expr_stmt|;
block|}
name|eh
operator|=
operator|(
expr|struct
name|elf_i386_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
name|eh
operator|->
name|tlsdesc_got
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* If R_386_TLS_{IE_32,IE,GOTIE} symbol is now local to the binary,      make it a R_386_TLS_LE_32 requiring no TLS entry.  */
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|refcount
operator|>
literal|0
operator|&&
operator|!
name|info
operator|->
name|shared
operator|&&
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|&&
operator|(
name|elf_i386_hash_entry
argument_list|(
name|h
argument_list|)
operator|->
name|tls_type
operator|&
name|GOT_TLS_IE
operator|)
condition|)
name|h
operator|->
name|got
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|refcount
operator|>
literal|0
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_boolean
name|dyn
decl_stmt|;
name|int
name|tls_type
init|=
name|elf_i386_hash_entry
argument_list|(
name|h
argument_list|)
operator|->
name|tls_type
decl_stmt|;
comment|/* Make sure this symbol is output as a dynamic symbol. 	 Undefined weak syms won't yet be marked as dynamic.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|&&
operator|!
name|h
operator|->
name|forced_local
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
name|s
operator|=
name|htab
operator|->
name|sgot
expr_stmt|;
if|if
condition|(
name|GOT_TLS_GDESC_P
argument_list|(
name|tls_type
argument_list|)
condition|)
block|{
name|eh
operator|->
name|tlsdesc_got
operator|=
name|htab
operator|->
name|sgotplt
operator|->
name|size
operator|-
name|elf_i386_compute_jump_table_size
argument_list|(
name|htab
argument_list|)
expr_stmt|;
name|htab
operator|->
name|sgotplt
operator|->
name|size
operator|+=
literal|8
expr_stmt|;
name|h
operator|->
name|got
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|2
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|GOT_TLS_GDESC_P
argument_list|(
name|tls_type
argument_list|)
operator|||
name|GOT_TLS_GD_P
argument_list|(
name|tls_type
argument_list|)
condition|)
block|{
name|h
operator|->
name|got
operator|.
name|offset
operator|=
name|s
operator|->
name|size
expr_stmt|;
name|s
operator|->
name|size
operator|+=
literal|4
expr_stmt|;
comment|/* R_386_TLS_GD needs 2 consecutive GOT slots.  */
if|if
condition|(
name|GOT_TLS_GD_P
argument_list|(
name|tls_type
argument_list|)
operator|||
name|tls_type
operator|==
name|GOT_TLS_IE_BOTH
condition|)
name|s
operator|->
name|size
operator|+=
literal|4
expr_stmt|;
block|}
name|dyn
operator|=
name|htab
operator|->
name|elf
operator|.
name|dynamic_sections_created
expr_stmt|;
comment|/* R_386_TLS_IE_32 needs one dynamic relocation, 	 R_386_TLS_IE resp. R_386_TLS_GOTIE needs one dynamic relocation, 	 (but if both R_386_TLS_IE_32 and R_386_TLS_IE is present, we 	 need two), R_386_TLS_GD needs one if local symbol and two if 	 global.  */
if|if
condition|(
name|tls_type
operator|==
name|GOT_TLS_IE_BOTH
condition|)
name|htab
operator|->
name|srelgot
operator|->
name|size
operator|+=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|GOT_TLS_GD_P
argument_list|(
name|tls_type
argument_list|)
operator|&&
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|tls_type
operator|&
name|GOT_TLS_IE
operator|)
condition|)
name|htab
operator|->
name|srelgot
operator|->
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GOT_TLS_GD_P
argument_list|(
name|tls_type
argument_list|)
condition|)
name|htab
operator|->
name|srelgot
operator|->
name|size
operator|+=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|GOT_TLS_GDESC_P
argument_list|(
name|tls_type
argument_list|)
operator|&&
operator|(
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_DEFAULT
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefweak
operator|)
operator|&&
operator|(
name|info
operator|->
name|shared
operator|||
name|WILL_CALL_FINISH_DYNAMIC_SYMBOL
argument_list|(
name|dyn
argument_list|,
literal|0
argument_list|,
name|h
argument_list|)
operator|)
condition|)
name|htab
operator|->
name|srelgot
operator|->
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
expr_stmt|;
if|if
condition|(
name|GOT_TLS_GDESC_P
argument_list|(
name|tls_type
argument_list|)
condition|)
name|htab
operator|->
name|srelplt
operator|->
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
expr_stmt|;
block|}
else|else
name|h
operator|->
name|got
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|eh
operator|->
name|dyn_relocs
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
comment|/* In the shared -Bsymbolic case, discard space allocated for      dynamic pc-relative relocs against symbols which turn out to be      defined in regular objects.  For the normal shared case, discard      space for pc-relative relocs that have become local due to symbol      visibility changes.  */
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
comment|/* The only reloc that uses pc_count is R_386_PC32, which will 	 appear on a call or on something like ".long foo - .".  We 	 want calls to protected symbols to resolve directly to the 	 function rather than going via the plt.  If people want 	 function pointer comparisons to work as expected then they 	 should avoid writing assembly like ".long foo - .".  */
if|if
condition|(
name|SYMBOL_CALLS_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
block|{
name|struct
name|elf_i386_dyn_relocs
modifier|*
modifier|*
name|pp
decl_stmt|;
for|for
control|(
name|pp
operator|=
operator|&
name|eh
operator|->
name|dyn_relocs
init|;
operator|(
name|p
operator|=
operator|*
name|pp
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
name|p
operator|->
name|count
operator|-=
name|p
operator|->
name|pc_count
expr_stmt|;
name|p
operator|->
name|pc_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|count
operator|==
literal|0
condition|)
operator|*
name|pp
operator|=
name|p
operator|->
name|next
expr_stmt|;
else|else
name|pp
operator|=
operator|&
name|p
operator|->
name|next
expr_stmt|;
block|}
block|}
comment|/* Also discard relocs on undefined weak syms with non-default 	 visibility.  */
if|if
condition|(
name|eh
operator|->
name|dyn_relocs
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
block|{
if|if
condition|(
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|!=
name|STV_DEFAULT
condition|)
name|eh
operator|->
name|dyn_relocs
operator|=
name|NULL
expr_stmt|;
comment|/* Make sure undefined weak symbols are output as a dynamic 	     symbol in PIEs.  */
elseif|else
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|&&
operator|!
name|h
operator|->
name|forced_local
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|ELIMINATE_COPY_RELOCS
condition|)
block|{
comment|/* For the non-shared case, discard space for relocs against 	 symbols which turn out to need copy relocs or are not 	 dynamic.  */
if|if
condition|(
operator|!
name|h
operator|->
name|non_got_ref
operator|&&
operator|(
operator|(
name|h
operator|->
name|def_dynamic
operator|&&
operator|!
name|h
operator|->
name|def_regular
operator|)
operator|||
operator|(
name|htab
operator|->
name|elf
operator|.
name|dynamic_sections_created
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* Make sure this symbol is output as a dynamic symbol. 	     Undefined weak syms won't yet be marked as dynamic.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|&&
operator|!
name|h
operator|->
name|forced_local
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* If that succeeded, we know we'll be keeping all the 	     relocs.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
condition|)
goto|goto
name|keep
goto|;
block|}
name|eh
operator|->
name|dyn_relocs
operator|=
name|NULL
expr_stmt|;
name|keep
label|:
empty_stmt|;
block|}
comment|/* Finally, allocate space.  */
for|for
control|(
name|p
operator|=
name|eh
operator|->
name|dyn_relocs
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|asection
modifier|*
name|sreloc
init|=
name|elf_section_data
argument_list|(
name|p
operator|->
name|sec
argument_list|)
operator|->
name|sreloc
decl_stmt|;
name|sreloc
operator|->
name|size
operator|+=
name|p
operator|->
name|count
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Find any dynamic relocs that apply to read-only sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|readonly_dynrelocs
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|void
modifier|*
name|inf
parameter_list|)
block|{
name|struct
name|elf_i386_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|struct
name|elf_i386_dyn_relocs
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|elf_i386_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
for|for
control|(
name|p
operator|=
name|eh
operator|->
name|dyn_relocs
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|asection
modifier|*
name|s
init|=
name|p
operator|->
name|sec
operator|->
name|output_section
decl_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|bfd_link_info
modifier|*
name|info
init|=
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|)
name|inf
decl_stmt|;
name|info
operator|->
name|flags
operator||=
name|DF_TEXTREL
expr_stmt|;
comment|/* Not an error, just cut short the traversal.  */
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Set the sizes of the dynamic sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_i386_size_dynamic_sections
parameter_list|(
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|elf_i386_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_boolean
name|relocs
decl_stmt|;
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|htab
operator|=
name|elf_i386_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|dynobj
operator|=
name|htab
operator|->
name|elf
operator|.
name|dynobj
expr_stmt|;
if|if
condition|(
name|dynobj
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|elf
operator|.
name|dynamic_sections_created
condition|)
block|{
comment|/* Set the contents of the .interp section to the interpreter.  */
if|if
condition|(
name|info
operator|->
name|executable
condition|)
block|{
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".interp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|s
operator|->
name|size
operator|=
sizeof|sizeof
name|ELF_DYNAMIC_INTERPRETER
expr_stmt|;
name|s
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ELF_DYNAMIC_INTERPRETER
expr_stmt|;
block|}
block|}
comment|/* Set up .got offsets for local syms, and space for local dynamic      relocs.  */
for|for
control|(
name|ibfd
operator|=
name|info
operator|->
name|input_bfds
init|;
name|ibfd
operator|!=
name|NULL
condition|;
name|ibfd
operator|=
name|ibfd
operator|->
name|link_next
control|)
block|{
name|bfd_signed_vma
modifier|*
name|local_got
decl_stmt|;
name|bfd_signed_vma
modifier|*
name|end_local_got
decl_stmt|;
name|char
modifier|*
name|local_tls_type
decl_stmt|;
name|bfd_vma
modifier|*
name|local_tlsdesc_gotent
decl_stmt|;
name|bfd_size_type
name|locsymcount
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|asection
modifier|*
name|srel
decl_stmt|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|ibfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
continue|continue;
for|for
control|(
name|s
operator|=
name|ibfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|struct
name|elf_i386_dyn_relocs
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
operator|(
operator|(
expr|struct
name|elf_i386_dyn_relocs
operator|*
operator|)
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|local_dynrel
operator|)
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|bfd_is_abs_section
argument_list|(
name|p
operator|->
name|sec
argument_list|)
operator|&&
name|bfd_is_abs_section
argument_list|(
name|p
operator|->
name|sec
operator|->
name|output_section
argument_list|)
condition|)
block|{
comment|/* Input section has been discarded, either because 		     it is a copy of a linkonce section or due to 		     linker script /DISCARD/, so we'll be discarding 		     the relocs too.  */
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|count
operator|!=
literal|0
condition|)
block|{
name|srel
operator|=
name|elf_section_data
argument_list|(
name|p
operator|->
name|sec
argument_list|)
operator|->
name|sreloc
expr_stmt|;
name|srel
operator|->
name|size
operator|+=
name|p
operator|->
name|count
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|sec
operator|->
name|output_section
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|!=
literal|0
condition|)
name|info
operator|->
name|flags
operator||=
name|DF_TEXTREL
expr_stmt|;
block|}
block|}
block|}
name|local_got
operator|=
name|elf_local_got_refcounts
argument_list|(
name|ibfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|local_got
condition|)
continue|continue;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|locsymcount
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|end_local_got
operator|=
name|local_got
operator|+
name|locsymcount
expr_stmt|;
name|local_tls_type
operator|=
name|elf_i386_local_got_tls_type
argument_list|(
name|ibfd
argument_list|)
expr_stmt|;
name|local_tlsdesc_gotent
operator|=
name|elf_i386_local_tlsdesc_gotent
argument_list|(
name|ibfd
argument_list|)
expr_stmt|;
name|s
operator|=
name|htab
operator|->
name|sgot
expr_stmt|;
name|srel
operator|=
name|htab
operator|->
name|srelgot
expr_stmt|;
for|for
control|(
init|;
name|local_got
operator|<
name|end_local_got
condition|;
operator|++
name|local_got
operator|,
operator|++
name|local_tls_type
operator|,
operator|++
name|local_tlsdesc_gotent
control|)
block|{
operator|*
name|local_tlsdesc_gotent
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|local_got
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|GOT_TLS_GDESC_P
argument_list|(
operator|*
name|local_tls_type
argument_list|)
condition|)
block|{
operator|*
name|local_tlsdesc_gotent
operator|=
name|htab
operator|->
name|sgotplt
operator|->
name|size
operator|-
name|elf_i386_compute_jump_table_size
argument_list|(
name|htab
argument_list|)
expr_stmt|;
name|htab
operator|->
name|sgotplt
operator|->
name|size
operator|+=
literal|8
expr_stmt|;
operator|*
name|local_got
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|2
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|GOT_TLS_GDESC_P
argument_list|(
operator|*
name|local_tls_type
argument_list|)
operator|||
name|GOT_TLS_GD_P
argument_list|(
operator|*
name|local_tls_type
argument_list|)
condition|)
block|{
operator|*
name|local_got
operator|=
name|s
operator|->
name|size
expr_stmt|;
name|s
operator|->
name|size
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|GOT_TLS_GD_P
argument_list|(
operator|*
name|local_tls_type
argument_list|)
operator|||
operator|*
name|local_tls_type
operator|==
name|GOT_TLS_IE_BOTH
condition|)
name|s
operator|->
name|size
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|shared
operator|||
name|GOT_TLS_GD_ANY_P
argument_list|(
operator|*
name|local_tls_type
argument_list|)
operator|||
operator|(
operator|*
name|local_tls_type
operator|&
name|GOT_TLS_IE
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|local_tls_type
operator|==
name|GOT_TLS_IE_BOTH
condition|)
name|srel
operator|->
name|size
operator|+=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GOT_TLS_GD_P
argument_list|(
operator|*
name|local_tls_type
argument_list|)
operator|||
operator|!
name|GOT_TLS_GDESC_P
argument_list|(
operator|*
name|local_tls_type
argument_list|)
condition|)
name|srel
operator|->
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
expr_stmt|;
if|if
condition|(
name|GOT_TLS_GDESC_P
argument_list|(
operator|*
name|local_tls_type
argument_list|)
condition|)
name|htab
operator|->
name|srelplt
operator|->
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
expr_stmt|;
block|}
block|}
else|else
operator|*
name|local_got
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|htab
operator|->
name|tls_ldm_got
operator|.
name|refcount
operator|>
literal|0
condition|)
block|{
comment|/* Allocate 2 got entries and 1 dynamic reloc for R_386_TLS_LDM 	 relocs.  */
name|htab
operator|->
name|tls_ldm_got
operator|.
name|offset
operator|=
name|htab
operator|->
name|sgot
operator|->
name|size
expr_stmt|;
name|htab
operator|->
name|sgot
operator|->
name|size
operator|+=
literal|8
expr_stmt|;
name|htab
operator|->
name|srelgot
operator|->
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
expr_stmt|;
block|}
else|else
name|htab
operator|->
name|tls_ldm_got
operator|.
name|offset
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Allocate global sym .plt and .got entries, and space for global      sym dynamic relocs.  */
name|elf_link_hash_traverse
argument_list|(
operator|&
name|htab
operator|->
name|elf
argument_list|,
name|allocate_dynrelocs
argument_list|,
operator|(
name|PTR
operator|)
name|info
argument_list|)
expr_stmt|;
comment|/* For every jump slot reserved in the sgotplt, reloc_count is      incremented.  However, when we reserve space for TLS descriptors,      it's not incremented, so in order to compute the space reserved      for them, it suffices to multiply the reloc count by the jump      slot size.  */
if|if
condition|(
name|htab
operator|->
name|srelplt
condition|)
name|htab
operator|->
name|sgotplt_jump_table_size
operator|=
name|htab
operator|->
name|next_tls_desc_index
operator|*
literal|4
expr_stmt|;
comment|/* We now have determined the sizes of the various dynamic sections.      Allocate memory for them.  */
name|relocs
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|s
operator|=
name|dynobj
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|bfd_boolean
name|strip_section
init|=
name|TRUE
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LINKER_CREATED
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|s
operator|==
name|htab
operator|->
name|splt
operator|||
name|s
operator|==
name|htab
operator|->
name|sgot
operator|||
name|s
operator|==
name|htab
operator|->
name|sgotplt
operator|||
name|s
operator|==
name|htab
operator|->
name|sdynbss
condition|)
block|{
comment|/* Strip this section if we don't need it; see the 	     comment below.  */
comment|/* We'd like to strip these sections if they aren't needed, but if 	     we've exported dynamic symbols from them we must leave them. 	     It's too late to tell BFD to get rid of the symbols.  */
if|if
condition|(
name|htab
operator|->
name|elf
operator|.
name|hplt
operator|!=
name|NULL
condition|)
name|strip_section
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CONST_STRNEQ
argument_list|(
name|bfd_get_section_name
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|)
argument_list|,
literal|".rel"
argument_list|)
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|size
operator|!=
literal|0
operator|&&
name|s
operator|!=
name|htab
operator|->
name|srelplt
operator|&&
name|s
operator|!=
name|htab
operator|->
name|srelplt2
condition|)
name|relocs
operator|=
name|TRUE
expr_stmt|;
comment|/* We use the reloc_count field as a counter if we need 	     to copy relocs into the output file.  */
name|s
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* It's not one of our sections, so don't allocate space.  */
continue|continue;
block|}
if|if
condition|(
name|s
operator|->
name|size
operator|==
literal|0
condition|)
block|{
comment|/* If we don't need this section, strip it from the 	     output file.  This is mostly to handle .rel.bss and 	     .rel.plt.  We must create both sections in 	     create_dynamic_sections, because they must be created 	     before the linker maps input sections to output 	     sections.  The linker does that before 	     adjust_dynamic_symbol is called, and it is that 	     function which decides whether anything needs to go 	     into these sections.  */
if|if
condition|(
name|strip_section
condition|)
name|s
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* Allocate memory for the section contents.  We use bfd_zalloc 	 here in case unused entries are not reclaimed before the 	 section's contents are written out.  This should not happen, 	 but this way if it does, we get a R_386_NONE reloc instead 	 of garbage.  */
name|s
operator|->
name|contents
operator|=
name|bfd_zalloc
argument_list|(
name|dynobj
argument_list|,
name|s
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|htab
operator|->
name|elf
operator|.
name|dynamic_sections_created
condition|)
block|{
comment|/* Add some entries to the .dynamic section.  We fill in the 	 values later, in elf_i386_finish_dynamic_sections, but we 	 must add the entries now so that we get the correct size for 	 the .dynamic section.  The DT_DEBUG entry is filled in by the 	 dynamic linker and used by the debugger.  */
define|#
directive|define
name|add_dynamic_entry
parameter_list|(
name|TAG
parameter_list|,
name|VAL
parameter_list|)
define|\
value|_bfd_elf_add_dynamic_entry (info, TAG, VAL)
if|if
condition|(
name|info
operator|->
name|executable
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_DEBUG
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|htab
operator|->
name|splt
operator|->
name|size
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PLTGOT
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PLTRELSZ
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PLTREL
argument_list|,
name|DT_REL
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_JMPREL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|relocs
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_REL
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELSZ
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELENT
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* If any dynamic relocs apply to a read-only section, 	     then we need a DT_TEXTREL entry.  */
if|if
condition|(
operator|(
name|info
operator|->
name|flags
operator|&
name|DF_TEXTREL
operator|)
operator|==
literal|0
condition|)
name|elf_link_hash_traverse
argument_list|(
operator|&
name|htab
operator|->
name|elf
argument_list|,
name|readonly_dynrelocs
argument_list|,
operator|(
name|PTR
operator|)
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|info
operator|->
name|flags
operator|&
name|DF_TEXTREL
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_TEXTREL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
block|}
undef|#
directive|undef
name|add_dynamic_entry
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elf_i386_always_size_sections
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|asection
modifier|*
name|tls_sec
init|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|tls_sec
decl_stmt|;
if|if
condition|(
name|tls_sec
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|tlsbase
decl_stmt|;
name|tlsbase
operator|=
name|elf_link_hash_lookup
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
literal|"_TLS_MODULE_BASE_"
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|tlsbase
operator|&&
name|tlsbase
operator|->
name|type
operator|==
name|STT_TLS
condition|)
block|{
name|struct
name|bfd_link_hash_entry
modifier|*
name|bh
init|=
name|NULL
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|output_bfd
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|output_bfd
argument_list|,
literal|"_TLS_MODULE_BASE_"
argument_list|,
name|BSF_LOCAL
argument_list|,
name|tls_sec
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|bed
operator|->
name|collect
argument_list|,
operator|&
name|bh
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
name|tlsbase
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|bh
expr_stmt|;
name|tlsbase
operator|->
name|def_regular
operator|=
literal|1
expr_stmt|;
name|tlsbase
operator|->
name|other
operator|=
name|STV_HIDDEN
expr_stmt|;
call|(
modifier|*
name|bed
operator|->
name|elf_backend_hide_symbol
call|)
argument_list|(
name|info
argument_list|,
name|tlsbase
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Set the correct type for an x86 ELF section.  We do this by the    section name, which is a hack, but ought to work.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_i386_fake_sections
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|Elf_Internal_Shdr
modifier|*
name|hdr
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|)
block|{
specifier|register
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
comment|/* This is an ugly, but unfortunately necessary hack that is      needed when producing EFI binaries on x86. It tells      elf.c:elf_fake_sections() not to consider ".reloc" as a section      containing ELF relocation info.  We need this hack in order to      be able to generate ELF binaries that can be translated into      EFI applications (which are essentially COFF objects).  Those      files contain a COFF ".reloc" section inside an ELFNN object,      which would normally cause BFD to segfault because it would      attempt to interpret this section as containing relocation      entries for section "oc".  With this hack enabled, ".reloc"      will be treated as a normal data section, which will avoid the      segfault.  However, you won't be able to create an ELFNN binary      with a section named "oc" that needs relocations, but that's      the kind of ugly side-effects you get when detecting section      types based on their names...  In practice, this limitation is      unlikely to bite.  */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".reloc"
argument_list|)
operator|==
literal|0
condition|)
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_PROGBITS
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return the base VMA address which should be subtracted from real addresses    when resolving @dtpoff relocation.    This is PT_TLS segment p_vaddr.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|dtpoff_base
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
comment|/* If tls_sec is NULL, we should have signalled an error already.  */
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|tls_sec
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
return|return
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|tls_sec
operator|->
name|vma
return|;
block|}
end_function

begin_comment
comment|/* Return the relocation value for @tpoff relocation    if STT_TLS virtual address is ADDRESS.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|tpoff
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd_vma
name|address
parameter_list|)
block|{
name|struct
name|elf_link_hash_table
modifier|*
name|htab
init|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
decl_stmt|;
comment|/* If tls_sec is NULL, we should have signalled an error already.  */
if|if
condition|(
name|htab
operator|->
name|tls_sec
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
return|return
name|htab
operator|->
name|tls_size
operator|+
name|htab
operator|->
name|tls_sec
operator|->
name|vma
operator|-
name|address
return|;
block|}
end_function

begin_comment
comment|/* Relocate an i386 ELF section.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_i386_relocate_section
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|relocs
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|local_syms
parameter_list|,
name|asection
modifier|*
modifier|*
name|local_sections
parameter_list|)
block|{
name|struct
name|elf_i386_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|bfd_vma
modifier|*
name|local_got_offsets
decl_stmt|;
name|bfd_vma
modifier|*
name|local_tlsdesc_gotents
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relend
decl_stmt|;
name|htab
operator|=
name|elf_i386_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|local_got_offsets
operator|=
name|elf_local_got_offsets
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|local_tlsdesc_gotents
operator|=
name|elf_i386_local_tlsdesc_gotent
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|rel
operator|=
name|relocs
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|input_section
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|unsigned
name|int
name|r_type
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_vma
name|off
decl_stmt|,
name|offplt
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_boolean
name|unresolved_reloc
decl_stmt|;
name|bfd_reloc_status_type
name|r
decl_stmt|;
name|unsigned
name|int
name|indx
decl_stmt|;
name|int
name|tls_type
decl_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_386_GNU_VTINHERIT
operator|||
name|r_type
operator|==
name|R_386_GNU_VTENTRY
condition|)
continue|continue;
if|if
condition|(
operator|(
name|indx
operator|=
name|r_type
operator|)
operator|>=
name|R_386_standard
operator|&&
operator|(
operator|(
name|indx
operator|=
name|r_type
operator|-
name|R_386_ext_offset
operator|)
operator|-
name|R_386_standard
operator|>=
name|R_386_ext
operator|-
name|R_386_standard
operator|)
operator|&&
operator|(
operator|(
name|indx
operator|=
name|r_type
operator|-
name|R_386_tls_offset
operator|)
operator|-
name|R_386_ext
operator|>=
name|R_386_tls
operator|-
name|R_386_ext
operator|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: unrecognized relocation (0x%x) in section `%A'"
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|howto
operator|=
name|elf_howto_table
operator|+
name|indx
expr_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|h
operator|=
name|NULL
expr_stmt|;
name|sym
operator|=
name|NULL
expr_stmt|;
name|sec
operator|=
name|NULL
expr_stmt|;
name|unresolved_reloc
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|relocation
operator|=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|sym
operator|->
name|st_value
operator|)
expr_stmt|;
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_SECTION
operator|&&
operator|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_MERGE
operator|)
operator|!=
literal|0
operator|||
operator|(
name|info
operator|->
name|relocatable
operator|&&
name|sec
operator|->
name|output_offset
operator|!=
literal|0
operator|)
operator|)
condition|)
block|{
name|bfd_vma
name|addend
decl_stmt|;
name|bfd_byte
modifier|*
name|where
init|=
name|contents
operator|+
name|rel
operator|->
name|r_offset
decl_stmt|;
switch|switch
condition|(
name|howto
operator|->
name|size
condition|)
block|{
case|case
literal|0
case|:
name|addend
operator|=
name|bfd_get_8
argument_list|(
name|input_bfd
argument_list|,
name|where
argument_list|)
expr_stmt|;
if|if
condition|(
name|howto
operator|->
name|pc_relative
condition|)
block|{
name|addend
operator|=
operator|(
name|addend
operator|^
literal|0x80
operator|)
operator|-
literal|0x80
expr_stmt|;
name|addend
operator|+=
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|1
case|:
name|addend
operator|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|where
argument_list|)
expr_stmt|;
if|if
condition|(
name|howto
operator|->
name|pc_relative
condition|)
block|{
name|addend
operator|=
operator|(
name|addend
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
expr_stmt|;
name|addend
operator|+=
literal|2
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
name|addend
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|where
argument_list|)
expr_stmt|;
if|if
condition|(
name|howto
operator|->
name|pc_relative
condition|)
block|{
name|addend
operator|=
operator|(
name|addend
operator|^
literal|0x80000000
operator|)
operator|-
literal|0x80000000
expr_stmt|;
name|addend
operator|+=
literal|4
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
name|addend
operator|+=
name|sec
operator|->
name|output_offset
expr_stmt|;
else|else
block|{
name|asection
modifier|*
name|msec
init|=
name|sec
decl_stmt|;
name|addend
operator|=
name|_bfd_elf_rel_local_sym
argument_list|(
name|output_bfd
argument_list|,
name|sym
argument_list|,
operator|&
name|msec
argument_list|,
name|addend
argument_list|)
expr_stmt|;
name|addend
operator|-=
name|relocation
expr_stmt|;
name|addend
operator|+=
name|msec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|msec
operator|->
name|output_offset
expr_stmt|;
block|}
switch|switch
condition|(
name|howto
operator|->
name|size
condition|)
block|{
case|case
literal|0
case|:
comment|/* FIXME: overflow checks.  */
if|if
condition|(
name|howto
operator|->
name|pc_relative
condition|)
name|addend
operator|-=
literal|1
expr_stmt|;
name|bfd_put_8
argument_list|(
name|input_bfd
argument_list|,
name|addend
argument_list|,
name|where
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|howto
operator|->
name|pc_relative
condition|)
name|addend
operator|-=
literal|2
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|addend
argument_list|,
name|where
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|howto
operator|->
name|pc_relative
condition|)
name|addend
operator|-=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|addend
argument_list|,
name|where
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
name|bfd_boolean
name|warned
decl_stmt|;
name|RELOC_FOR_GLOBAL_SYMBOL
argument_list|(
name|info
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
argument_list|,
name|r_symndx
argument_list|,
name|symtab_hdr
argument_list|,
name|sym_hashes
argument_list|,
name|h
argument_list|,
name|sec
argument_list|,
name|relocation
argument_list|,
name|unresolved_reloc
argument_list|,
name|warned
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sec
operator|!=
name|NULL
operator|&&
name|elf_discarded_section
argument_list|(
name|sec
argument_list|)
condition|)
block|{
comment|/* For relocs against symbols from removed linkonce sections, 	     or sections discarded by a linker script, we just want the 	     section contents zeroed.  Avoid any special processing.  */
name|_bfd_clear_contents
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|rel
operator|->
name|r_info
operator|=
literal|0
expr_stmt|;
name|rel
operator|->
name|r_addend
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
continue|continue;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_386_GOT32
case|:
comment|/* Relocation is to the entry for this symbol in the global 	     offset table.  */
if|if
condition|(
name|htab
operator|->
name|sgot
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|bfd_boolean
name|dyn
decl_stmt|;
name|off
operator|=
name|h
operator|->
name|got
operator|.
name|offset
expr_stmt|;
name|dyn
operator|=
name|htab
operator|->
name|elf
operator|.
name|dynamic_sections_created
expr_stmt|;
if|if
condition|(
operator|!
name|WILL_CALL_FINISH_DYNAMIC_SYMBOL
argument_list|(
name|dyn
argument_list|,
name|info
operator|->
name|shared
argument_list|,
name|h
argument_list|)
operator|||
operator|(
name|info
operator|->
name|shared
operator|&&
name|SYMBOL_REFERENCES_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
operator|)
operator|||
operator|(
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|)
condition|)
block|{
comment|/* This is actually a static link, or it is a 		     -Bsymbolic link and the symbol is defined 		     locally, or the symbol was forced to be local 		     because of a version file.  We must initialize 		     this entry in the global offset table.  Since the 		     offset must always be a multiple of 4, we use the 		     least significant bit to record whether we have 		     initialized it already.  		     When doing a dynamic link, we create a .rel.got 		     relocation entry to initialize the value.  This 		     is done in the finish_dynamic_symbol routine.  */
if|if
condition|(
operator|(
name|off
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|off
operator|&=
operator|~
literal|1
expr_stmt|;
else|else
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|relocation
argument_list|,
name|htab
operator|->
name|sgot
operator|->
name|contents
operator|+
name|off
argument_list|)
expr_stmt|;
name|h
operator|->
name|got
operator|.
name|offset
operator||=
literal|1
expr_stmt|;
block|}
block|}
else|else
name|unresolved_reloc
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|local_got_offsets
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|off
operator|=
name|local_got_offsets
index|[
name|r_symndx
index|]
expr_stmt|;
comment|/* The offset must always be a multiple of 4.  We use 		 the least significant bit to record whether we have 		 already generated the necessary reloc.  */
if|if
condition|(
operator|(
name|off
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|off
operator|&=
operator|~
literal|1
expr_stmt|;
else|else
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|relocation
argument_list|,
name|htab
operator|->
name|sgot
operator|->
name|contents
operator|+
name|off
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|Elf_Internal_Rela
name|outrel
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|s
operator|=
name|htab
operator|->
name|srelgot
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|=
operator|(
name|htab
operator|->
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|sgot
operator|->
name|output_offset
operator|+
name|off
operator|)
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_386_RELATIVE
argument_list|)
expr_stmt|;
name|loc
operator|=
name|s
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
name|s
operator|->
name|reloc_count
operator|++
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloc_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
name|local_got_offsets
index|[
name|r_symndx
index|]
operator||=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|off
operator|>=
operator|(
name|bfd_vma
operator|)
operator|-
literal|2
condition|)
name|abort
argument_list|()
expr_stmt|;
name|relocation
operator|=
name|htab
operator|->
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|sgot
operator|->
name|output_offset
operator|+
name|off
operator|-
name|htab
operator|->
name|sgotplt
operator|->
name|output_section
operator|->
name|vma
operator|-
name|htab
operator|->
name|sgotplt
operator|->
name|output_offset
expr_stmt|;
break|break;
case|case
name|R_386_GOTOFF
case|:
comment|/* Relocation is relative to the start of the global offset 	     table.  */
comment|/* Check to make sure it isn't a protected function symbol 	     for shared library since it may not be local when used 	     as function address.  */
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
operator|!
name|info
operator|->
name|executable
operator|&&
name|h
operator|&&
name|h
operator|->
name|def_regular
operator|&&
name|h
operator|->
name|type
operator|==
name|STT_FUNC
operator|&&
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_PROTECTED
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: relocation R_386_GOTOFF against protected function `%s' can not be used when making a shared object"
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Note that sgot is not involved in this 	     calculation.  We always want the start of .got.plt.  If we 	     defined _GLOBAL_OFFSET_TABLE_ in a different way, as is 	     permitted by the ABI, we might have to change this 	     calculation.  */
name|relocation
operator|-=
name|htab
operator|->
name|sgotplt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|sgotplt
operator|->
name|output_offset
expr_stmt|;
break|break;
case|case
name|R_386_GOTPC
case|:
comment|/* Use global offset table as symbol value.  */
name|relocation
operator|=
name|htab
operator|->
name|sgotplt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|sgotplt
operator|->
name|output_offset
expr_stmt|;
name|unresolved_reloc
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|R_386_PLT32
case|:
comment|/* Relocation is to the entry for this symbol in the 	     procedure linkage table.  */
comment|/* Resolve a PLT32 reloc against a local symbol directly, 	     without using the procedure linkage table.  */
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|||
name|htab
operator|->
name|splt
operator|==
name|NULL
condition|)
block|{
comment|/* We didn't make a PLT entry for this symbol.  This 		 happens when statically linking PIC code, or when 		 using -Bsymbolic.  */
break|break;
block|}
name|relocation
operator|=
operator|(
name|htab
operator|->
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|splt
operator|->
name|output_offset
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|)
expr_stmt|;
name|unresolved_reloc
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|R_386_32
case|:
case|case
name|R_386_PC32
case|:
if|if
condition|(
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|h
operator|==
name|NULL
operator|||
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_DEFAULT
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefweak
operator|)
operator|&&
operator|(
name|r_type
operator|!=
name|R_386_PC32
operator|||
operator|!
name|SYMBOL_CALLS_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|ELIMINATE_COPY_RELOCS
operator|&&
operator|!
name|info
operator|->
name|shared
operator|&&
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|&&
operator|!
name|h
operator|->
name|non_got_ref
operator|&&
operator|(
operator|(
name|h
operator|->
name|def_dynamic
operator|&&
operator|!
name|h
operator|->
name|def_regular
operator|)
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
operator|)
operator|)
condition|)
block|{
name|Elf_Internal_Rela
name|outrel
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|bfd_boolean
name|skip
decl_stmt|,
name|relocate
decl_stmt|;
name|asection
modifier|*
name|sreloc
decl_stmt|;
comment|/* When generating a shared object, these relocations 		 are copied into the output file to be resolved at run 		 time.  */
name|skip
operator|=
name|FALSE
expr_stmt|;
name|relocate
operator|=
name|FALSE
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|=
name|_bfd_elf_section_offset
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|outrel
operator|.
name|r_offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
name|skip
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|outrel
operator|.
name|r_offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|2
condition|)
name|skip
operator|=
name|TRUE
operator|,
name|relocate
operator|=
name|TRUE
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|+=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
if|if
condition|(
name|skip
condition|)
name|memset
argument_list|(
operator|&
name|outrel
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|outrel
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|r_type
operator|==
name|R_386_PC32
operator|||
operator|!
name|info
operator|->
name|shared
operator|||
operator|!
name|SYMBOLIC_BIND
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
operator|||
operator|!
name|h
operator|->
name|def_regular
operator|)
condition|)
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* This symbol is local, or marked to become local.  */
name|relocate
operator|=
name|TRUE
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_386_RELATIVE
argument_list|)
expr_stmt|;
block|}
name|sreloc
operator|=
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|sreloc
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|loc
operator|=
name|sreloc
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
name|sreloc
operator|->
name|reloc_count
operator|++
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloc_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
comment|/* If this reloc is against an external symbol, we do 		 not want to fiddle with the addend.  Otherwise, we 		 need to include the symbol value so that it becomes 		 an addend for the dynamic reloc.  */
if|if
condition|(
operator|!
name|relocate
condition|)
continue|continue;
block|}
break|break;
case|case
name|R_386_TLS_IE
case|:
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
name|Elf_Internal_Rela
name|outrel
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|asection
modifier|*
name|sreloc
decl_stmt|;
name|outrel
operator|.
name|r_offset
operator|=
name|rel
operator|->
name|r_offset
operator|+
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_386_RELATIVE
argument_list|)
expr_stmt|;
name|sreloc
operator|=
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|sreloc
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|loc
operator|=
name|sreloc
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
name|sreloc
operator|->
name|reloc_count
operator|++
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloc_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
comment|/* Fall through */
case|case
name|R_386_TLS_GD
case|:
case|case
name|R_386_TLS_GOTDESC
case|:
case|case
name|R_386_TLS_DESC_CALL
case|:
case|case
name|R_386_TLS_IE_32
case|:
case|case
name|R_386_TLS_GOTIE
case|:
name|r_type
operator|=
name|elf_i386_tls_transition
argument_list|(
name|info
argument_list|,
name|r_type
argument_list|,
name|h
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|tls_type
operator|=
name|GOT_UNKNOWN
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
operator|&&
name|local_got_offsets
condition|)
name|tls_type
operator|=
name|elf_i386_local_got_tls_type
argument_list|(
name|input_bfd
argument_list|)
index|[
name|r_symndx
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|tls_type
operator|=
name|elf_i386_hash_entry
argument_list|(
name|h
argument_list|)
operator|->
name|tls_type
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|shared
operator|&&
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|&&
operator|(
name|tls_type
operator|&
name|GOT_TLS_IE
operator|)
condition|)
name|r_type
operator|=
name|R_386_TLS_LE_32
expr_stmt|;
block|}
if|if
condition|(
name|tls_type
operator|==
name|GOT_TLS_IE
condition|)
name|tls_type
operator|=
name|GOT_TLS_IE_NEG
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_386_TLS_GD
operator|||
name|r_type
operator|==
name|R_386_TLS_GOTDESC
operator|||
name|r_type
operator|==
name|R_386_TLS_DESC_CALL
condition|)
block|{
if|if
condition|(
name|tls_type
operator|==
name|GOT_TLS_IE_POS
condition|)
name|r_type
operator|=
name|R_386_TLS_GOTIE
expr_stmt|;
elseif|else
if|if
condition|(
name|tls_type
operator|&
name|GOT_TLS_IE
condition|)
name|r_type
operator|=
name|R_386_TLS_IE_32
expr_stmt|;
block|}
if|if
condition|(
name|r_type
operator|==
name|R_386_TLS_LE_32
condition|)
block|{
name|BFD_ASSERT
argument_list|(
operator|!
name|unresolved_reloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|==
name|R_386_TLS_GD
condition|)
block|{
name|unsigned
name|int
name|val
decl_stmt|,
name|type
decl_stmt|;
name|bfd_vma
name|roff
decl_stmt|;
comment|/* GD->LE transition.  */
name|BFD_ASSERT
argument_list|(
name|rel
operator|->
name|r_offset
operator|>=
literal|2
argument_list|)
expr_stmt|;
name|type
operator|=
name|bfd_get_8
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|-
literal|2
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|type
operator|==
literal|0x8d
operator|||
name|type
operator|==
literal|0x04
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|rel
operator|->
name|r_offset
operator|+
literal|9
operator|<=
name|input_section
operator|->
name|size
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|bfd_get_8
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|+
literal|4
argument_list|)
operator|==
literal|0xe8
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|rel
operator|+
literal|1
operator|<
name|relend
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|ELF32_R_TYPE
argument_list|(
name|rel
index|[
literal|1
index|]
operator|.
name|r_info
argument_list|)
operator|==
name|R_386_PLT32
argument_list|)
expr_stmt|;
name|roff
operator|=
name|rel
operator|->
name|r_offset
operator|+
literal|5
expr_stmt|;
name|val
operator|=
name|bfd_get_8
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
literal|0x04
condition|)
block|{
comment|/* leal foo(,%reg,1), %eax; call ___tls_get_addr 			 Change it into: 			 movl %gs:0, %eax; subl $foo@tpoff, %eax 			 (6 byte form of subl).  */
name|BFD_ASSERT
argument_list|(
name|rel
operator|->
name|r_offset
operator|>=
literal|3
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|bfd_get_8
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|-
literal|3
argument_list|)
operator|==
literal|0x8d
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
operator|(
name|val
operator|&
literal|0xc7
operator|)
operator|==
literal|0x05
operator|&&
name|val
operator|!=
operator|(
literal|4
operator|<<
literal|3
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|-
literal|3
argument_list|,
literal|"\x65\xa1\0\0\0\0\x81\xe8\0\0\0"
argument_list|,
literal|12
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|BFD_ASSERT
argument_list|(
operator|(
name|val
operator|&
literal|0xf8
operator|)
operator|==
literal|0x80
operator|&&
operator|(
name|val
operator|&
literal|7
operator|)
operator|!=
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|rel
operator|->
name|r_offset
operator|+
literal|10
operator|<=
name|input_section
operator|->
name|size
operator|&&
name|bfd_get_8
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|+
literal|9
argument_list|)
operator|==
literal|0x90
condition|)
block|{
comment|/* leal foo(%reg), %eax; call ___tls_get_addr; nop 			     Change it into: 			     movl %gs:0, %eax; subl $foo@tpoff, %eax 			     (6 byte form of subl).  */
name|memcpy
argument_list|(
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|-
literal|2
argument_list|,
literal|"\x65\xa1\0\0\0\0\x81\xe8\0\0\0"
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|roff
operator|=
name|rel
operator|->
name|r_offset
operator|+
literal|6
expr_stmt|;
block|}
else|else
block|{
comment|/* leal foo(%reg), %eax; call ___tls_get_addr 			     Change it into: 			     movl %gs:0, %eax; subl $foo@tpoff, %eax 			     (5 byte form of subl).  */
name|memcpy
argument_list|(
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|-
literal|2
argument_list|,
literal|"\x65\xa1\0\0\0\0\x2d\0\0\0"
argument_list|,
literal|11
argument_list|)
expr_stmt|;
block|}
block|}
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|tpoff
argument_list|(
name|info
argument_list|,
name|relocation
argument_list|)
argument_list|,
name|contents
operator|+
name|roff
argument_list|)
expr_stmt|;
comment|/* Skip R_386_PLT32.  */
name|rel
operator|++
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|==
name|R_386_TLS_GOTDESC
condition|)
block|{
comment|/* GDesc -> LE transition. 		     It's originally something like: 		     leal x@tlsdesc(%ebx), %eax  		     leal x@ntpoff, %eax  		     Registers other than %eax may be set up here.  */
name|unsigned
name|int
name|val
decl_stmt|,
name|type
decl_stmt|;
name|bfd_vma
name|roff
decl_stmt|;
comment|/* First, make sure it's a leal adding ebx to a 		     32-bit offset into any register, although it's 		     probably almost always going to be eax.  */
name|roff
operator|=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|roff
operator|>=
literal|2
argument_list|)
expr_stmt|;
name|type
operator|=
name|bfd_get_8
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|roff
operator|-
literal|2
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|type
operator|==
literal|0x8d
argument_list|)
expr_stmt|;
name|val
operator|=
name|bfd_get_8
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|roff
operator|-
literal|1
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
operator|(
name|val
operator|&
literal|0xc7
operator|)
operator|==
literal|0x83
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|roff
operator|+
literal|4
operator|<=
name|input_section
operator|->
name|size
argument_list|)
expr_stmt|;
comment|/* Now modify the instruction as appropriate.  */
comment|/* aoliva FIXME: remove the above and xor the byte 		     below with 0x86.  */
name|bfd_put_8
argument_list|(
name|output_bfd
argument_list|,
name|val
operator|^
literal|0x86
argument_list|,
name|contents
operator|+
name|roff
operator|-
literal|1
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|-
name|tpoff
argument_list|(
name|info
argument_list|,
name|relocation
argument_list|)
argument_list|,
name|contents
operator|+
name|roff
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|==
name|R_386_TLS_DESC_CALL
condition|)
block|{
comment|/* GDesc -> LE transition. 		     It's originally: 		     call *(%eax) 		     Turn it into: 		     nop; nop  */
name|unsigned
name|int
name|val
decl_stmt|,
name|type
decl_stmt|;
name|bfd_vma
name|roff
decl_stmt|;
comment|/* First, make sure it's a call *(%eax).  */
name|roff
operator|=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|roff
operator|+
literal|2
operator|<=
name|input_section
operator|->
name|size
argument_list|)
expr_stmt|;
name|type
operator|=
name|bfd_get_8
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|roff
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|type
operator|==
literal|0xff
argument_list|)
expr_stmt|;
name|val
operator|=
name|bfd_get_8
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|roff
operator|+
literal|1
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|val
operator|==
literal|0x10
argument_list|)
expr_stmt|;
comment|/* Now modify the instruction as appropriate.  Use 		     xchg %ax,%ax instead of 2 nops.  */
name|bfd_put_8
argument_list|(
name|output_bfd
argument_list|,
literal|0x66
argument_list|,
name|contents
operator|+
name|roff
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|output_bfd
argument_list|,
literal|0x90
argument_list|,
name|contents
operator|+
name|roff
operator|+
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|==
name|R_386_TLS_IE
condition|)
block|{
name|unsigned
name|int
name|val
decl_stmt|,
name|type
decl_stmt|;
comment|/* IE->LE transition: 		     Originally it can be one of: 		     movl foo, %eax 		     movl foo, %reg 		     addl foo, %reg 		     We change it into: 		     movl $foo, %eax 		     movl $foo, %reg 		     addl $foo, %reg.  */
name|BFD_ASSERT
argument_list|(
name|rel
operator|->
name|r_offset
operator|>=
literal|1
argument_list|)
expr_stmt|;
name|val
operator|=
name|bfd_get_8
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|-
literal|1
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|rel
operator|->
name|r_offset
operator|+
literal|4
operator|<=
name|input_section
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0xa1
condition|)
block|{
comment|/* movl foo, %eax.  */
name|bfd_put_8
argument_list|(
name|output_bfd
argument_list|,
literal|0xb8
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|BFD_ASSERT
argument_list|(
name|rel
operator|->
name|r_offset
operator|>=
literal|2
argument_list|)
expr_stmt|;
name|type
operator|=
name|bfd_get_8
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|-
literal|2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|0x8b
case|:
comment|/* movl */
name|BFD_ASSERT
argument_list|(
operator|(
name|val
operator|&
literal|0xc7
operator|)
operator|==
literal|0x05
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|output_bfd
argument_list|,
literal|0xc7
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|-
literal|2
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|output_bfd
argument_list|,
literal|0xc0
operator||
operator|(
operator|(
name|val
operator|>>
literal|3
operator|)
operator|&
literal|7
operator|)
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x03
case|:
comment|/* addl */
name|BFD_ASSERT
argument_list|(
operator|(
name|val
operator|&
literal|0xc7
operator|)
operator|==
literal|0x05
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|output_bfd
argument_list|,
literal|0x81
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|-
literal|2
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|output_bfd
argument_list|,
literal|0xc0
operator||
operator|(
operator|(
name|val
operator|>>
literal|3
operator|)
operator|&
literal|7
operator|)
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|BFD_FAIL
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|-
name|tpoff
argument_list|(
name|info
argument_list|,
name|relocation
argument_list|)
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|unsigned
name|int
name|val
decl_stmt|,
name|type
decl_stmt|;
comment|/* {IE_32,GOTIE}->LE transition: 		     Originally it can be one of: 		     subl foo(%reg1), %reg2 		     movl foo(%reg1), %reg2 		     addl foo(%reg1), %reg2 		     We change it into: 		     subl $foo, %reg2 		     movl $foo, %reg2 (6 byte form) 		     addl $foo, %reg2.  */
name|BFD_ASSERT
argument_list|(
name|rel
operator|->
name|r_offset
operator|>=
literal|2
argument_list|)
expr_stmt|;
name|type
operator|=
name|bfd_get_8
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|-
literal|2
argument_list|)
expr_stmt|;
name|val
operator|=
name|bfd_get_8
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|-
literal|1
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|rel
operator|->
name|r_offset
operator|+
literal|4
operator|<=
name|input_section
operator|->
name|size
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
operator|(
name|val
operator|&
literal|0xc0
operator|)
operator|==
literal|0x80
operator|&&
operator|(
name|val
operator|&
literal|7
operator|)
operator|!=
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
literal|0x8b
condition|)
block|{
comment|/* movl */
name|bfd_put_8
argument_list|(
name|output_bfd
argument_list|,
literal|0xc7
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|-
literal|2
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|output_bfd
argument_list|,
literal|0xc0
operator||
operator|(
operator|(
name|val
operator|>>
literal|3
operator|)
operator|&
literal|7
operator|)
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
literal|0x2b
condition|)
block|{
comment|/* subl */
name|bfd_put_8
argument_list|(
name|output_bfd
argument_list|,
literal|0x81
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|-
literal|2
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|output_bfd
argument_list|,
literal|0xe8
operator||
operator|(
operator|(
name|val
operator|>>
literal|3
operator|)
operator|&
literal|7
operator|)
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
literal|0x03
condition|)
block|{
comment|/* addl */
name|bfd_put_8
argument_list|(
name|output_bfd
argument_list|,
literal|0x81
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|-
literal|2
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|output_bfd
argument_list|,
literal|0xc0
operator||
operator|(
operator|(
name|val
operator|>>
literal|3
operator|)
operator|&
literal|7
operator|)
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|BFD_FAIL
argument_list|()
expr_stmt|;
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|==
name|R_386_TLS_GOTIE
condition|)
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|-
name|tpoff
argument_list|(
name|info
argument_list|,
name|relocation
argument_list|)
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
else|else
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|tpoff
argument_list|(
name|info
argument_list|,
name|relocation
argument_list|)
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|htab
operator|->
name|sgot
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|off
operator|=
name|h
operator|->
name|got
operator|.
name|offset
expr_stmt|;
name|offplt
operator|=
name|elf_i386_hash_entry
argument_list|(
name|h
argument_list|)
operator|->
name|tlsdesc_got
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|local_got_offsets
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|off
operator|=
name|local_got_offsets
index|[
name|r_symndx
index|]
expr_stmt|;
name|offplt
operator|=
name|local_tlsdesc_gotents
index|[
name|r_symndx
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|off
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|off
operator|&=
operator|~
literal|1
expr_stmt|;
else|else
block|{
name|Elf_Internal_Rela
name|outrel
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|int
name|dr_type
decl_stmt|,
name|indx
decl_stmt|;
name|asection
modifier|*
name|sreloc
decl_stmt|;
if|if
condition|(
name|htab
operator|->
name|srelgot
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|indx
operator|=
name|h
operator|&&
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
condition|?
name|h
operator|->
name|dynindx
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|GOT_TLS_GDESC_P
argument_list|(
name|tls_type
argument_list|)
condition|)
block|{
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|indx
argument_list|,
name|R_386_TLS_DESC
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|htab
operator|->
name|sgotplt_jump_table_size
operator|+
name|offplt
operator|+
literal|8
operator|<=
name|htab
operator|->
name|sgotplt
operator|->
name|size
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|=
operator|(
name|htab
operator|->
name|sgotplt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|sgotplt
operator|->
name|output_offset
operator|+
name|offplt
operator|+
name|htab
operator|->
name|sgotplt_jump_table_size
operator|)
expr_stmt|;
name|sreloc
operator|=
name|htab
operator|->
name|srelplt
expr_stmt|;
name|loc
operator|=
name|sreloc
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
operator|(
name|htab
operator|->
name|next_tls_desc_index
operator|++
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
operator|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|loc
operator|+
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
operator|<=
name|sreloc
operator|->
name|contents
operator|+
name|sreloc
operator|->
name|size
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloc_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
if|if
condition|(
name|indx
operator|==
literal|0
condition|)
block|{
name|BFD_ASSERT
argument_list|(
operator|!
name|unresolved_reloc
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|relocation
operator|-
name|dtpoff_base
argument_list|(
name|info
argument_list|)
argument_list|,
name|htab
operator|->
name|sgotplt
operator|->
name|contents
operator|+
name|offplt
operator|+
name|htab
operator|->
name|sgotplt_jump_table_size
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
literal|0
argument_list|,
name|htab
operator|->
name|sgotplt
operator|->
name|contents
operator|+
name|offplt
operator|+
name|htab
operator|->
name|sgotplt_jump_table_size
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
name|sreloc
operator|=
name|htab
operator|->
name|srelgot
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|=
operator|(
name|htab
operator|->
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|sgot
operator|->
name|output_offset
operator|+
name|off
operator|)
expr_stmt|;
if|if
condition|(
name|GOT_TLS_GD_P
argument_list|(
name|tls_type
argument_list|)
condition|)
name|dr_type
operator|=
name|R_386_TLS_DTPMOD32
expr_stmt|;
elseif|else
if|if
condition|(
name|GOT_TLS_GDESC_P
argument_list|(
name|tls_type
argument_list|)
condition|)
goto|goto
name|dr_done
goto|;
elseif|else
if|if
condition|(
name|tls_type
operator|==
name|GOT_TLS_IE_POS
condition|)
name|dr_type
operator|=
name|R_386_TLS_TPOFF
expr_stmt|;
else|else
name|dr_type
operator|=
name|R_386_TLS_TPOFF32
expr_stmt|;
if|if
condition|(
name|dr_type
operator|==
name|R_386_TLS_TPOFF
operator|&&
name|indx
operator|==
literal|0
condition|)
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|relocation
operator|-
name|dtpoff_base
argument_list|(
name|info
argument_list|)
argument_list|,
name|htab
operator|->
name|sgot
operator|->
name|contents
operator|+
name|off
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|dr_type
operator|==
name|R_386_TLS_TPOFF32
operator|&&
name|indx
operator|==
literal|0
condition|)
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|dtpoff_base
argument_list|(
name|info
argument_list|)
operator|-
name|relocation
argument_list|,
name|htab
operator|->
name|sgot
operator|->
name|contents
operator|+
name|off
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|dr_type
operator|!=
name|R_386_TLS_DESC
condition|)
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
literal|0
argument_list|,
name|htab
operator|->
name|sgot
operator|->
name|contents
operator|+
name|off
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|indx
argument_list|,
name|dr_type
argument_list|)
expr_stmt|;
name|loc
operator|=
name|sreloc
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
name|sreloc
operator|->
name|reloc_count
operator|++
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|loc
operator|+
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
operator|<=
name|sreloc
operator|->
name|contents
operator|+
name|sreloc
operator|->
name|size
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloc_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
if|if
condition|(
name|GOT_TLS_GD_P
argument_list|(
name|tls_type
argument_list|)
condition|)
block|{
if|if
condition|(
name|indx
operator|==
literal|0
condition|)
block|{
name|BFD_ASSERT
argument_list|(
operator|!
name|unresolved_reloc
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|relocation
operator|-
name|dtpoff_base
argument_list|(
name|info
argument_list|)
argument_list|,
name|htab
operator|->
name|sgot
operator|->
name|contents
operator|+
name|off
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
literal|0
argument_list|,
name|htab
operator|->
name|sgot
operator|->
name|contents
operator|+
name|off
operator|+
literal|4
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|indx
argument_list|,
name|R_386_TLS_DTPOFF32
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|+=
literal|4
expr_stmt|;
name|sreloc
operator|->
name|reloc_count
operator|++
expr_stmt|;
name|loc
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|loc
operator|+
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
operator|<=
name|sreloc
operator|->
name|contents
operator|+
name|sreloc
operator|->
name|size
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloc_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|tls_type
operator|==
name|GOT_TLS_IE_BOTH
condition|)
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|indx
operator|==
literal|0
condition|?
name|relocation
operator|-
name|dtpoff_base
argument_list|(
name|info
argument_list|)
else|:
literal|0
argument_list|,
name|htab
operator|->
name|sgot
operator|->
name|contents
operator|+
name|off
operator|+
literal|4
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|indx
argument_list|,
name|R_386_TLS_TPOFF
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|+=
literal|4
expr_stmt|;
name|sreloc
operator|->
name|reloc_count
operator|++
expr_stmt|;
name|loc
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloc_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
name|dr_done
label|:
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|h
operator|->
name|got
operator|.
name|offset
operator||=
literal|1
expr_stmt|;
else|else
name|local_got_offsets
index|[
name|r_symndx
index|]
operator||=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|off
operator|>=
operator|(
name|bfd_vma
operator|)
operator|-
literal|2
operator|&&
operator|!
name|GOT_TLS_GDESC_P
argument_list|(
name|tls_type
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_386_TLS_GOTDESC
operator|||
name|r_type
operator|==
name|R_386_TLS_DESC_CALL
condition|)
block|{
name|relocation
operator|=
name|htab
operator|->
name|sgotplt_jump_table_size
operator|+
name|offplt
expr_stmt|;
name|unresolved_reloc
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r_type
operator|==
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
name|bfd_vma
name|g_o_t
init|=
name|htab
operator|->
name|sgotplt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|sgotplt
operator|->
name|output_offset
decl_stmt|;
name|relocation
operator|=
name|htab
operator|->
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|sgot
operator|->
name|output_offset
operator|+
name|off
operator|-
name|g_o_t
expr_stmt|;
if|if
condition|(
operator|(
name|r_type
operator|==
name|R_386_TLS_IE
operator|||
name|r_type
operator|==
name|R_386_TLS_GOTIE
operator|)
operator|&&
name|tls_type
operator|==
name|GOT_TLS_IE_BOTH
condition|)
name|relocation
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_386_TLS_IE
condition|)
name|relocation
operator|+=
name|g_o_t
expr_stmt|;
name|unresolved_reloc
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|==
name|R_386_TLS_GD
condition|)
block|{
name|unsigned
name|int
name|val
decl_stmt|,
name|type
decl_stmt|;
name|bfd_vma
name|roff
decl_stmt|;
comment|/* GD->IE transition.  */
name|BFD_ASSERT
argument_list|(
name|rel
operator|->
name|r_offset
operator|>=
literal|2
argument_list|)
expr_stmt|;
name|type
operator|=
name|bfd_get_8
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|-
literal|2
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|type
operator|==
literal|0x8d
operator|||
name|type
operator|==
literal|0x04
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|rel
operator|->
name|r_offset
operator|+
literal|9
operator|<=
name|input_section
operator|->
name|size
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|bfd_get_8
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|+
literal|4
argument_list|)
operator|==
literal|0xe8
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|rel
operator|+
literal|1
operator|<
name|relend
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|ELF32_R_TYPE
argument_list|(
name|rel
index|[
literal|1
index|]
operator|.
name|r_info
argument_list|)
operator|==
name|R_386_PLT32
argument_list|)
expr_stmt|;
name|roff
operator|=
name|rel
operator|->
name|r_offset
operator|-
literal|3
expr_stmt|;
name|val
operator|=
name|bfd_get_8
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
literal|0x04
condition|)
block|{
comment|/* leal foo(,%reg,1), %eax; call ___tls_get_addr 		     Change it into: 		     movl %gs:0, %eax; subl $foo@gottpoff(%reg), %eax.  */
name|BFD_ASSERT
argument_list|(
name|rel
operator|->
name|r_offset
operator|>=
literal|3
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|bfd_get_8
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|-
literal|3
argument_list|)
operator|==
literal|0x8d
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
operator|(
name|val
operator|&
literal|0xc7
operator|)
operator|==
literal|0x05
operator|&&
name|val
operator|!=
operator|(
literal|4
operator|<<
literal|3
operator|)
argument_list|)
expr_stmt|;
name|val
operator|>>=
literal|3
expr_stmt|;
block|}
else|else
block|{
comment|/* leal foo(%reg), %eax; call ___tls_get_addr; nop 		     Change it into: 		     movl %gs:0, %eax; subl $foo@gottpoff(%reg), %eax.  */
name|BFD_ASSERT
argument_list|(
name|rel
operator|->
name|r_offset
operator|+
literal|10
operator|<=
name|input_section
operator|->
name|size
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
operator|(
name|val
operator|&
literal|0xf8
operator|)
operator|==
literal|0x80
operator|&&
operator|(
name|val
operator|&
literal|7
operator|)
operator|!=
literal|4
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|bfd_get_8
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|+
literal|9
argument_list|)
operator|==
literal|0x90
argument_list|)
expr_stmt|;
name|roff
operator|=
name|rel
operator|->
name|r_offset
operator|-
literal|2
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|contents
operator|+
name|roff
argument_list|,
literal|"\x65\xa1\0\0\0\0\x2b\x80\0\0\0"
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|contents
index|[
name|roff
operator|+
literal|7
index|]
operator|=
literal|0x80
operator||
operator|(
name|val
operator|&
literal|7
operator|)
expr_stmt|;
comment|/* If foo is used only with foo@gotntpoff(%reg) and 		 foo@indntpoff, but not with foo@gottpoff(%reg), change 		 subl $foo@gottpoff(%reg), %eax 		 into: 		 addl $foo@gotntpoff(%reg), %eax.  */
if|if
condition|(
name|tls_type
operator|==
name|GOT_TLS_IE_POS
condition|)
name|contents
index|[
name|roff
operator|+
literal|6
index|]
operator|=
literal|0x03
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|htab
operator|->
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|sgot
operator|->
name|output_offset
operator|+
name|off
operator|-
name|htab
operator|->
name|sgotplt
operator|->
name|output_section
operator|->
name|vma
operator|-
name|htab
operator|->
name|sgotplt
operator|->
name|output_offset
argument_list|,
name|contents
operator|+
name|roff
operator|+
literal|8
argument_list|)
expr_stmt|;
comment|/* Skip R_386_PLT32.  */
name|rel
operator|++
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|==
name|R_386_TLS_GOTDESC
condition|)
block|{
comment|/* GDesc -> IE transition. 		 It's originally something like: 		 leal x@tlsdesc(%ebx), %eax  		 Change it to: 		 movl x@gotntpoff(%ebx), %eax # before nop; nop 		 or: 		 movl x@gottpoff(%ebx), %eax # before negl %eax  		 Registers other than %eax may be set up here.  */
name|unsigned
name|int
name|val
decl_stmt|,
name|type
decl_stmt|;
name|bfd_vma
name|roff
decl_stmt|;
comment|/* First, make sure it's a leal adding ebx to a 32-bit 		 offset into any register, although it's probably 		 almost always going to be eax.  */
name|roff
operator|=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|roff
operator|>=
literal|2
argument_list|)
expr_stmt|;
name|type
operator|=
name|bfd_get_8
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|roff
operator|-
literal|2
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|type
operator|==
literal|0x8d
argument_list|)
expr_stmt|;
name|val
operator|=
name|bfd_get_8
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|roff
operator|-
literal|1
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
operator|(
name|val
operator|&
literal|0xc7
operator|)
operator|==
literal|0x83
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|roff
operator|+
literal|4
operator|<=
name|input_section
operator|->
name|size
argument_list|)
expr_stmt|;
comment|/* Now modify the instruction as appropriate.  */
comment|/* To turn a leal into a movl in the form we use it, it 		 suffices to change the first byte from 0x8d to 0x8b. 		 aoliva FIXME: should we decide to keep the leal, all 		 we have to do is remove the statement below, and 		 adjust the relaxation of R_386_TLS_DESC_CALL.  */
name|bfd_put_8
argument_list|(
name|output_bfd
argument_list|,
literal|0x8b
argument_list|,
name|contents
operator|+
name|roff
operator|-
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|tls_type
operator|==
name|GOT_TLS_IE_BOTH
condition|)
name|off
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|htab
operator|->
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|sgot
operator|->
name|output_offset
operator|+
name|off
operator|-
name|htab
operator|->
name|sgotplt
operator|->
name|output_section
operator|->
name|vma
operator|-
name|htab
operator|->
name|sgotplt
operator|->
name|output_offset
argument_list|,
name|contents
operator|+
name|roff
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|==
name|R_386_TLS_DESC_CALL
condition|)
block|{
comment|/* GDesc -> IE transition. 		 It's originally: 		 call *(%eax)  		 Change it to: 		 nop; nop 		 or 		 negl %eax 		 depending on how we transformed the TLS_GOTDESC above. 	      */
name|unsigned
name|int
name|val
decl_stmt|,
name|type
decl_stmt|;
name|bfd_vma
name|roff
decl_stmt|;
comment|/* First, make sure it's a call *(%eax).  */
name|roff
operator|=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|roff
operator|+
literal|2
operator|<=
name|input_section
operator|->
name|size
argument_list|)
expr_stmt|;
name|type
operator|=
name|bfd_get_8
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|roff
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|type
operator|==
literal|0xff
argument_list|)
expr_stmt|;
name|val
operator|=
name|bfd_get_8
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|roff
operator|+
literal|1
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|val
operator|==
literal|0x10
argument_list|)
expr_stmt|;
comment|/* Now modify the instruction as appropriate.  */
if|if
condition|(
name|tls_type
operator|!=
name|GOT_TLS_IE_NEG
condition|)
block|{
comment|/* xchg %ax,%ax */
name|bfd_put_8
argument_list|(
name|output_bfd
argument_list|,
literal|0x66
argument_list|,
name|contents
operator|+
name|roff
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|output_bfd
argument_list|,
literal|0x90
argument_list|,
name|contents
operator|+
name|roff
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* negl %eax */
name|bfd_put_8
argument_list|(
name|output_bfd
argument_list|,
literal|0xf7
argument_list|,
name|contents
operator|+
name|roff
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|output_bfd
argument_list|,
literal|0xd8
argument_list|,
name|contents
operator|+
name|roff
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
else|else
name|BFD_ASSERT
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_386_TLS_LDM
case|:
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
name|unsigned
name|int
name|val
decl_stmt|;
comment|/* LD->LE transition: 		 Ensure it is: 		 leal foo(%reg), %eax; call ___tls_get_addr. 		 We change it into: 		 movl %gs:0, %eax; nop; leal 0(%esi,1), %esi.  */
name|BFD_ASSERT
argument_list|(
name|rel
operator|->
name|r_offset
operator|>=
literal|2
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|bfd_get_8
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|-
literal|2
argument_list|)
operator|==
literal|0x8d
argument_list|)
expr_stmt|;
name|val
operator|=
name|bfd_get_8
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|-
literal|1
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
operator|(
name|val
operator|&
literal|0xf8
operator|)
operator|==
literal|0x80
operator|&&
operator|(
name|val
operator|&
literal|7
operator|)
operator|!=
literal|4
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|rel
operator|->
name|r_offset
operator|+
literal|9
operator|<=
name|input_section
operator|->
name|size
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|bfd_get_8
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|+
literal|4
argument_list|)
operator|==
literal|0xe8
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|rel
operator|+
literal|1
operator|<
name|relend
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|ELF32_R_TYPE
argument_list|(
name|rel
index|[
literal|1
index|]
operator|.
name|r_info
argument_list|)
operator|==
name|R_386_PLT32
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|-
literal|2
argument_list|,
literal|"\x65\xa1\0\0\0\0\x90\x8d\x74\x26"
argument_list|,
literal|11
argument_list|)
expr_stmt|;
comment|/* Skip R_386_PLT32.  */
name|rel
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|htab
operator|->
name|sgot
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|off
operator|=
name|htab
operator|->
name|tls_ldm_got
operator|.
name|offset
expr_stmt|;
if|if
condition|(
name|off
operator|&
literal|1
condition|)
name|off
operator|&=
operator|~
literal|1
expr_stmt|;
else|else
block|{
name|Elf_Internal_Rela
name|outrel
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
if|if
condition|(
name|htab
operator|->
name|srelgot
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|=
operator|(
name|htab
operator|->
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|sgot
operator|->
name|output_offset
operator|+
name|off
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
literal|0
argument_list|,
name|htab
operator|->
name|sgot
operator|->
name|contents
operator|+
name|off
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
literal|0
argument_list|,
name|htab
operator|->
name|sgot
operator|->
name|contents
operator|+
name|off
operator|+
literal|4
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_386_TLS_DTPMOD32
argument_list|)
expr_stmt|;
name|loc
operator|=
name|htab
operator|->
name|srelgot
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
name|htab
operator|->
name|srelgot
operator|->
name|reloc_count
operator|++
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloc_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|htab
operator|->
name|tls_ldm_got
operator|.
name|offset
operator||=
literal|1
expr_stmt|;
block|}
name|relocation
operator|=
name|htab
operator|->
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|sgot
operator|->
name|output_offset
operator|+
name|off
operator|-
name|htab
operator|->
name|sgotplt
operator|->
name|output_section
operator|->
name|vma
operator|-
name|htab
operator|->
name|sgotplt
operator|->
name|output_offset
expr_stmt|;
name|unresolved_reloc
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|R_386_TLS_LDO_32
case|:
if|if
condition|(
name|info
operator|->
name|shared
operator|||
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_CODE
operator|)
operator|==
literal|0
condition|)
name|relocation
operator|-=
name|dtpoff_base
argument_list|(
name|info
argument_list|)
expr_stmt|;
else|else
comment|/* When converting LDO to LE, we must negate.  */
name|relocation
operator|=
operator|-
name|tpoff
argument_list|(
name|info
argument_list|,
name|relocation
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_386_TLS_LE_32
case|:
case|case
name|R_386_TLS_LE
case|:
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
name|Elf_Internal_Rela
name|outrel
decl_stmt|;
name|asection
modifier|*
name|sreloc
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|int
name|indx
decl_stmt|;
name|outrel
operator|.
name|r_offset
operator|=
name|rel
operator|->
name|r_offset
operator|+
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
condition|)
name|indx
operator|=
name|h
operator|->
name|dynindx
expr_stmt|;
else|else
name|indx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_386_TLS_LE_32
condition|)
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|indx
argument_list|,
name|R_386_TLS_TPOFF32
argument_list|)
expr_stmt|;
else|else
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|indx
argument_list|,
name|R_386_TLS_TPOFF
argument_list|)
expr_stmt|;
name|sreloc
operator|=
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|sreloc
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|loc
operator|=
name|sreloc
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
name|sreloc
operator|->
name|reloc_count
operator|++
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloc_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
if|if
condition|(
name|indx
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|r_type
operator|==
name|R_386_TLS_LE_32
condition|)
name|relocation
operator|=
name|dtpoff_base
argument_list|(
name|info
argument_list|)
operator|-
name|relocation
expr_stmt|;
else|else
name|relocation
operator|-=
name|dtpoff_base
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r_type
operator|==
name|R_386_TLS_LE_32
condition|)
name|relocation
operator|=
name|tpoff
argument_list|(
name|info
argument_list|,
name|relocation
argument_list|)
expr_stmt|;
else|else
name|relocation
operator|=
operator|-
name|tpoff
argument_list|(
name|info
argument_list|,
name|relocation
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* Dynamic relocs are not propagated for SEC_DEBUGGING sections 	 because such sections are not SEC_ALLOC and thus ld.so will 	 not process them.  */
if|if
condition|(
name|unresolved_reloc
operator|&&
operator|!
operator|(
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_DEBUGGING
operator|)
operator|!=
literal|0
operator|&&
name|h
operator|->
name|def_dynamic
operator|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B(%A+0x%lx): unresolvable %s relocation against symbol `%s'"
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
name|long
operator|)
name|rel
operator|->
name|r_offset
argument_list|,
name|howto
operator|->
name|name
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|r
operator|=
name|_bfd_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|relocation
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|bfd_reloc_ok
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
else|else
block|{
name|name
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_link
argument_list|,
name|sym
operator|->
name|st_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'\0'
condition|)
name|name
operator|=
name|bfd_section_name
argument_list|(
name|input_bfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|==
name|bfd_reloc_overflow
condition|)
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|info
argument_list|,
operator|(
name|h
condition|?
operator|&
name|h
operator|->
name|root
else|:
name|NULL
operator|)
argument_list|,
name|name
argument_list|,
name|howto
operator|->
name|name
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
block|}
else|else
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B(%A+0x%lx): reloc against `%s': error %d"
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
name|long
operator|)
name|rel
operator|->
name|r_offset
argument_list|,
name|name
argument_list|,
operator|(
name|int
operator|)
name|r
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Finish up dynamic symbol handling.  We set the contents of various    dynamic sections here.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_i386_finish_dynamic_symbol
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|)
block|{
name|struct
name|elf_i386_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|htab
operator|=
name|elf_i386_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
name|bfd_vma
name|plt_index
decl_stmt|;
name|bfd_vma
name|got_offset
decl_stmt|;
name|Elf_Internal_Rela
name|rel
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
comment|/* This symbol has an entry in the procedure linkage table.  Set 	 it up.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|||
name|htab
operator|->
name|splt
operator|==
name|NULL
operator|||
name|htab
operator|->
name|sgotplt
operator|==
name|NULL
operator|||
name|htab
operator|->
name|srelplt
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Get the index in the procedure linkage table which 	 corresponds to this symbol.  This is the index of this symbol 	 in all the symbols for which we are making plt entries.  The 	 first entry in the procedure linkage table is reserved.  */
name|plt_index
operator|=
name|h
operator|->
name|plt
operator|.
name|offset
operator|/
name|PLT_ENTRY_SIZE
operator|-
literal|1
expr_stmt|;
comment|/* Get the offset into the .got table of the entry that 	 corresponds to this function.  Each .got entry is 4 bytes. 	 The first three are reserved.  */
name|got_offset
operator|=
operator|(
name|plt_index
operator|+
literal|3
operator|)
operator|*
literal|4
expr_stmt|;
comment|/* Fill in the entry in the procedure linkage table.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
name|memcpy
argument_list|(
name|htab
operator|->
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
argument_list|,
name|elf_i386_plt_entry
argument_list|,
name|PLT_ENTRY_SIZE
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|htab
operator|->
name|sgotplt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|sgotplt
operator|->
name|output_offset
operator|+
name|got_offset
operator|)
argument_list|,
name|htab
operator|->
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|is_vxworks
condition|)
block|{
name|int
name|s
decl_stmt|,
name|k
decl_stmt|,
name|reloc_index
decl_stmt|;
comment|/* Create the R_386_32 relocation referencing the GOT 		 for this PLT entry.  */
comment|/* S: Current slot number (zero-based).  */
name|s
operator|=
operator|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|-
name|PLT_ENTRY_SIZE
operator|)
operator|/
name|PLT_ENTRY_SIZE
expr_stmt|;
comment|/* K: Number of relocations for PLTResolve. */
if|if
condition|(
name|info
operator|->
name|shared
condition|)
name|k
operator|=
name|PLTRESOLVE_RELOCS_SHLIB
expr_stmt|;
else|else
name|k
operator|=
name|PLTRESOLVE_RELOCS
expr_stmt|;
comment|/* Skip the PLTresolve relocations, and the relocations for 		 the other PLT slots. */
name|reloc_index
operator|=
name|k
operator|+
name|s
operator|*
name|PLT_NON_JUMP_SLOT_RELOCS
expr_stmt|;
name|loc
operator|=
operator|(
name|htab
operator|->
name|srelplt2
operator|->
name|contents
operator|+
name|reloc_index
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
operator|)
expr_stmt|;
name|rel
operator|.
name|r_offset
operator|=
operator|(
name|htab
operator|->
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|splt
operator|->
name|output_offset
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
literal|2
operator|)
operator|,
name|rel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|hgot
operator|->
name|indx
argument_list|,
name|R_386_32
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloc_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
comment|/* Create the R_386_32 relocation referencing the beginning of 		 the PLT for this GOT entry.  */
name|rel
operator|.
name|r_offset
operator|=
operator|(
name|htab
operator|->
name|sgotplt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|sgotplt
operator|->
name|output_offset
operator|+
name|got_offset
operator|)
expr_stmt|;
name|rel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|hplt
operator|->
name|indx
argument_list|,
name|R_386_32
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloc_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rel
argument_list|,
name|loc
operator|+
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|memcpy
argument_list|(
name|htab
operator|->
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
argument_list|,
name|elf_i386_pic_plt_entry
argument_list|,
name|PLT_ENTRY_SIZE
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|got_offset
argument_list|,
name|htab
operator|->
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|plt_index
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
argument_list|,
name|htab
operator|->
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
literal|7
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|-
operator|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
name|PLT_ENTRY_SIZE
operator|)
argument_list|,
name|htab
operator|->
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
literal|12
argument_list|)
expr_stmt|;
comment|/* Fill in the entry in the global offset table.  */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|htab
operator|->
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|splt
operator|->
name|output_offset
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
literal|6
operator|)
argument_list|,
name|htab
operator|->
name|sgotplt
operator|->
name|contents
operator|+
name|got_offset
argument_list|)
expr_stmt|;
comment|/* Fill in the entry in the .rel.plt section.  */
name|rel
operator|.
name|r_offset
operator|=
operator|(
name|htab
operator|->
name|sgotplt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|sgotplt
operator|->
name|output_offset
operator|+
name|got_offset
operator|)
expr_stmt|;
name|rel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_386_JUMP_SLOT
argument_list|)
expr_stmt|;
name|loc
operator|=
name|htab
operator|->
name|srelplt
operator|->
name|contents
operator|+
name|plt_index
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloc_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|h
operator|->
name|def_regular
condition|)
block|{
comment|/* Mark the symbol as undefined, rather than as defined in 	     the .plt section.  Leave the value if there were any 	     relocations where pointer equality matters (this is a clue 	     for the dynamic linker, to make function pointer 	     comparisons work between an application and shared 	     library), otherwise set it to zero.  If a function is only 	     called from a binary, there is no need to slow down 	     shared libraries because of that.  */
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_UNDEF
expr_stmt|;
if|if
condition|(
operator|!
name|h
operator|->
name|pointer_equality_needed
condition|)
name|sym
operator|->
name|st_value
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|&&
operator|!
name|GOT_TLS_GD_ANY_P
argument_list|(
name|elf_i386_hash_entry
argument_list|(
name|h
argument_list|)
operator|->
name|tls_type
argument_list|)
operator|&&
operator|(
name|elf_i386_hash_entry
argument_list|(
name|h
argument_list|)
operator|->
name|tls_type
operator|&
name|GOT_TLS_IE
operator|)
operator|==
literal|0
condition|)
block|{
name|Elf_Internal_Rela
name|rel
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
comment|/* This symbol has an entry in the global offset table.  Set it 	 up.  */
if|if
condition|(
name|htab
operator|->
name|sgot
operator|==
name|NULL
operator|||
name|htab
operator|->
name|srelgot
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|rel
operator|.
name|r_offset
operator|=
operator|(
name|htab
operator|->
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|sgot
operator|->
name|output_offset
operator|+
operator|(
name|h
operator|->
name|got
operator|.
name|offset
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
literal|1
operator|)
operator|)
expr_stmt|;
comment|/* If this is a static link, or it is a -Bsymbolic link and the 	 symbol is defined locally or was forced to be local because 	 of a version file, we just want to emit a RELATIVE reloc. 	 The entry in the global offset table will already have been 	 initialized in the relocate_section function.  */
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
name|SYMBOL_REFERENCES_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
block|{
name|BFD_ASSERT
argument_list|(
operator|(
name|h
operator|->
name|got
operator|.
name|offset
operator|&
literal|1
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|rel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_386_RELATIVE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|BFD_ASSERT
argument_list|(
operator|(
name|h
operator|->
name|got
operator|.
name|offset
operator|&
literal|1
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|htab
operator|->
name|sgot
operator|->
name|contents
operator|+
name|h
operator|->
name|got
operator|.
name|offset
argument_list|)
expr_stmt|;
name|rel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_386_GLOB_DAT
argument_list|)
expr_stmt|;
block|}
name|loc
operator|=
name|htab
operator|->
name|srelgot
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
name|htab
operator|->
name|srelgot
operator|->
name|reloc_count
operator|++
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloc_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|->
name|needs_copy
condition|)
block|{
name|Elf_Internal_Rela
name|rel
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
comment|/* This symbol needs a copy reloc.  Set it up.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|||
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defined
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
operator|)
operator|||
name|htab
operator|->
name|srelbss
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|rel
operator|.
name|r_offset
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|rel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_386_COPY
argument_list|)
expr_stmt|;
name|loc
operator|=
name|htab
operator|->
name|srelbss
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
name|htab
operator|->
name|srelbss
operator|->
name|reloc_count
operator|++
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloc_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
comment|/* Mark _DYNAMIC and _GLOBAL_OFFSET_TABLE_ as absolute.      On VxWorks, the _GLOBAL_OFFSET_TABLE_ symbol is not absolute: it      is relative to the ".got" section.  */
if|if
condition|(
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_DYNAMIC"
argument_list|)
operator|==
literal|0
operator|||
operator|(
operator|!
name|htab
operator|->
name|is_vxworks
operator|&&
name|h
operator|==
name|htab
operator|->
name|elf
operator|.
name|hgot
operator|)
condition|)
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_ABS
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Used to decide how to sort relocs in an optimal manner for the    dynamic linker, before writing them out.  */
end_comment

begin_function
specifier|static
name|enum
name|elf_reloc_type_class
name|elf_i386_reloc_type_class
parameter_list|(
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rela
parameter_list|)
block|{
switch|switch
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rela
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_386_RELATIVE
case|:
return|return
name|reloc_class_relative
return|;
case|case
name|R_386_JUMP_SLOT
case|:
return|return
name|reloc_class_plt
return|;
case|case
name|R_386_COPY
case|:
return|return
name|reloc_class_copy
return|;
default|default:
return|return
name|reloc_class_normal
return|;
block|}
block|}
end_function

begin_comment
comment|/* Finish up the dynamic sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_i386_finish_dynamic_sections
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|elf_i386_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|sdyn
decl_stmt|;
name|htab
operator|=
name|elf_i386_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|dynobj
operator|=
name|htab
operator|->
name|elf
operator|.
name|dynobj
expr_stmt|;
name|sdyn
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|elf
operator|.
name|dynamic_sections_created
condition|)
block|{
name|Elf32_External_Dyn
modifier|*
name|dyncon
decl_stmt|,
modifier|*
name|dynconend
decl_stmt|;
if|if
condition|(
name|sdyn
operator|==
name|NULL
operator|||
name|htab
operator|->
name|sgot
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|dyncon
operator|=
operator|(
name|Elf32_External_Dyn
operator|*
operator|)
name|sdyn
operator|->
name|contents
expr_stmt|;
name|dynconend
operator|=
operator|(
name|Elf32_External_Dyn
operator|*
operator|)
operator|(
name|sdyn
operator|->
name|contents
operator|+
name|sdyn
operator|->
name|size
operator|)
expr_stmt|;
for|for
control|(
init|;
name|dyncon
operator|<
name|dynconend
condition|;
name|dyncon
operator|++
control|)
block|{
name|Elf_Internal_Dyn
name|dyn
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_elf32_swap_dyn_in
argument_list|(
name|dynobj
argument_list|,
name|dyncon
argument_list|,
operator|&
name|dyn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dyn
operator|.
name|d_tag
condition|)
block|{
default|default:
continue|continue;
case|case
name|DT_PLTGOT
case|:
name|s
operator|=
name|htab
operator|->
name|sgotplt
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|s
operator|->
name|output_section
operator|->
name|vma
operator|+
name|s
operator|->
name|output_offset
expr_stmt|;
break|break;
case|case
name|DT_JMPREL
case|:
name|s
operator|=
name|htab
operator|->
name|srelplt
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|s
operator|->
name|output_section
operator|->
name|vma
operator|+
name|s
operator|->
name|output_offset
expr_stmt|;
break|break;
case|case
name|DT_PLTRELSZ
case|:
name|s
operator|=
name|htab
operator|->
name|srelplt
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|s
operator|->
name|size
expr_stmt|;
break|break;
case|case
name|DT_RELSZ
case|:
comment|/* My reading of the SVR4 ABI indicates that the 		 procedure linkage table relocs (DT_JMPREL) should be 		 included in the overall relocs (DT_REL).  This is 		 what Solaris does.  However, UnixWare can not handle 		 that case.  Therefore, we override the DT_RELSZ entry 		 here to make it not include the JMPREL relocs.  */
name|s
operator|=
name|htab
operator|->
name|srelplt
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
continue|continue;
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|-=
name|s
operator|->
name|size
expr_stmt|;
break|break;
case|case
name|DT_REL
case|:
comment|/* We may not be using the standard ELF linker script. 		 If .rel.plt is the first .rel section, we adjust 		 DT_REL to not include it.  */
name|s
operator|=
name|htab
operator|->
name|srelplt
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|!=
name|s
operator|->
name|output_section
operator|->
name|vma
operator|+
name|s
operator|->
name|output_offset
condition|)
continue|continue;
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|+=
name|s
operator|->
name|size
expr_stmt|;
break|break;
block|}
name|bfd_elf32_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
block|}
comment|/* Fill in the first entry in the procedure linkage table.  */
if|if
condition|(
name|htab
operator|->
name|splt
operator|&&
name|htab
operator|->
name|splt
operator|->
name|size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
name|memcpy
argument_list|(
name|htab
operator|->
name|splt
operator|->
name|contents
argument_list|,
name|elf_i386_pic_plt0_entry
argument_list|,
sizeof|sizeof
argument_list|(
name|elf_i386_pic_plt0_entry
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|htab
operator|->
name|splt
operator|->
name|contents
operator|+
sizeof|sizeof
argument_list|(
name|elf_i386_pic_plt0_entry
argument_list|)
argument_list|,
name|htab
operator|->
name|plt0_pad_byte
argument_list|,
name|PLT_ENTRY_SIZE
operator|-
sizeof|sizeof
argument_list|(
name|elf_i386_pic_plt0_entry
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|htab
operator|->
name|splt
operator|->
name|contents
argument_list|,
name|elf_i386_plt0_entry
argument_list|,
sizeof|sizeof
argument_list|(
name|elf_i386_plt0_entry
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|htab
operator|->
name|splt
operator|->
name|contents
operator|+
sizeof|sizeof
argument_list|(
name|elf_i386_plt0_entry
argument_list|)
argument_list|,
name|htab
operator|->
name|plt0_pad_byte
argument_list|,
name|PLT_ENTRY_SIZE
operator|-
sizeof|sizeof
argument_list|(
name|elf_i386_plt0_entry
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|htab
operator|->
name|sgotplt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|sgotplt
operator|->
name|output_offset
operator|+
literal|4
operator|)
argument_list|,
name|htab
operator|->
name|splt
operator|->
name|contents
operator|+
literal|2
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|htab
operator|->
name|sgotplt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|sgotplt
operator|->
name|output_offset
operator|+
literal|8
operator|)
argument_list|,
name|htab
operator|->
name|splt
operator|->
name|contents
operator|+
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|is_vxworks
condition|)
block|{
name|Elf_Internal_Rela
name|rel
decl_stmt|;
comment|/* Generate a relocation for _GLOBAL_OFFSET_TABLE_ + 4. 		     On IA32 we use REL relocations so the addend goes in 		     the PLT directly.  */
name|rel
operator|.
name|r_offset
operator|=
operator|(
name|htab
operator|->
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|splt
operator|->
name|output_offset
operator|+
literal|2
operator|)
expr_stmt|;
name|rel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|hgot
operator|->
name|indx
argument_list|,
name|R_386_32
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloc_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rel
argument_list|,
name|htab
operator|->
name|srelplt2
operator|->
name|contents
argument_list|)
expr_stmt|;
comment|/* Generate a relocation for _GLOBAL_OFFSET_TABLE_ + 8.  */
name|rel
operator|.
name|r_offset
operator|=
operator|(
name|htab
operator|->
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|splt
operator|->
name|output_offset
operator|+
literal|8
operator|)
expr_stmt|;
name|rel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|hgot
operator|->
name|indx
argument_list|,
name|R_386_32
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloc_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rel
argument_list|,
name|htab
operator|->
name|srelplt2
operator|->
name|contents
operator|+
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* UnixWare sets the entsize of .plt to 4, although that doesn't 	     really seem like the right value.  */
name|elf_section_data
argument_list|(
name|htab
operator|->
name|splt
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
operator|=
literal|4
expr_stmt|;
comment|/* Correct the .rel.plt.unloaded relocations.  */
if|if
condition|(
name|htab
operator|->
name|is_vxworks
operator|&&
operator|!
name|info
operator|->
name|shared
condition|)
block|{
name|int
name|num_plts
init|=
operator|(
name|htab
operator|->
name|splt
operator|->
name|size
operator|/
name|PLT_ENTRY_SIZE
operator|)
operator|-
literal|1
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|htab
operator|->
name|srelplt2
operator|->
name|contents
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
name|p
operator|+=
name|PLTRESOLVE_RELOCS_SHLIB
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
expr_stmt|;
else|else
name|p
operator|+=
name|PLTRESOLVE_RELOCS
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|num_plts
condition|;
name|num_plts
operator|--
control|)
block|{
name|Elf_Internal_Rela
name|rel
decl_stmt|;
name|bfd_elf32_swap_reloc_in
argument_list|(
name|output_bfd
argument_list|,
name|p
argument_list|,
operator|&
name|rel
argument_list|)
expr_stmt|;
name|rel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|hgot
operator|->
name|indx
argument_list|,
name|R_386_32
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloc_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rel
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloc_in
argument_list|(
name|output_bfd
argument_list|,
name|p
argument_list|,
operator|&
name|rel
argument_list|)
expr_stmt|;
name|rel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|hplt
operator|->
name|indx
argument_list|,
name|R_386_32
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloc_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rel
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|htab
operator|->
name|sgotplt
condition|)
block|{
comment|/* Fill in the first three entries in the global offset table.  */
if|if
condition|(
name|htab
operator|->
name|sgotplt
operator|->
name|size
operator|>
literal|0
condition|)
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|sdyn
operator|==
name|NULL
condition|?
literal|0
else|:
name|sdyn
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sdyn
operator|->
name|output_offset
operator|)
argument_list|,
name|htab
operator|->
name|sgotplt
operator|->
name|contents
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
literal|0
argument_list|,
name|htab
operator|->
name|sgotplt
operator|->
name|contents
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
literal|0
argument_list|,
name|htab
operator|->
name|sgotplt
operator|->
name|contents
operator|+
literal|8
argument_list|)
expr_stmt|;
block|}
name|elf_section_data
argument_list|(
name|htab
operator|->
name|sgotplt
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
operator|=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|htab
operator|->
name|sgot
operator|&&
name|htab
operator|->
name|sgot
operator|->
name|size
operator|>
literal|0
condition|)
name|elf_section_data
argument_list|(
name|htab
operator|->
name|sgot
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
operator|=
literal|4
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return address for Ith PLT stub in section PLT, for relocation REL    or (bfd_vma) -1 if it should not be included.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|elf_i386_plt_sym_val
parameter_list|(
name|bfd_vma
name|i
parameter_list|,
specifier|const
name|asection
modifier|*
name|plt
parameter_list|,
specifier|const
name|arelent
modifier|*
name|rel
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|plt
operator|->
name|vma
operator|+
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
name|PLT_ENTRY_SIZE
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if symbol should be hashed in the `.gnu.hash' section.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_i386_hash_symbol
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|)
block|{
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|&&
operator|!
name|h
operator|->
name|def_regular
operator|&&
operator|!
name|h
operator|->
name|pointer_equality_needed
condition|)
return|return
name|FALSE
return|;
return|return
name|_bfd_elf_hash_symbol
argument_list|(
name|h
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|TARGET_LITTLE_SYM
value|bfd_elf32_i386_vec
end_define

begin_define
define|#
directive|define
name|TARGET_LITTLE_NAME
value|"elf32-i386"
end_define

begin_define
define|#
directive|define
name|ELF_ARCH
value|bfd_arch_i386
end_define

begin_define
define|#
directive|define
name|ELF_MACHINE_CODE
value|EM_386
end_define

begin_define
define|#
directive|define
name|ELF_MAXPAGESIZE
value|0x1000
end_define

begin_define
define|#
directive|define
name|elf_backend_can_gc_sections
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_can_refcount
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_want_got_plt
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_plt_readonly
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_want_plt_sym
value|0
end_define

begin_define
define|#
directive|define
name|elf_backend_got_header_size
value|12
end_define

begin_comment
comment|/* Support RELA for objdump of prelink objects.  */
end_comment

begin_define
define|#
directive|define
name|elf_info_to_howto
value|elf_i386_info_to_howto_rel
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto_rel
value|elf_i386_info_to_howto_rel
end_define

begin_define
define|#
directive|define
name|bfd_elf32_mkobject
value|elf_i386_mkobject
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_is_local_label_name
value|elf_i386_is_local_label_name
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_link_hash_table_create
value|elf_i386_link_hash_table_create
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_reloc_type_lookup
value|elf_i386_reloc_type_lookup
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_reloc_name_lookup
value|elf_i386_reloc_name_lookup
end_define

begin_define
define|#
directive|define
name|elf_backend_adjust_dynamic_symbol
value|elf_i386_adjust_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_relocs_compatible
value|_bfd_elf_relocs_compatible
end_define

begin_define
define|#
directive|define
name|elf_backend_check_relocs
value|elf_i386_check_relocs
end_define

begin_define
define|#
directive|define
name|elf_backend_copy_indirect_symbol
value|elf_i386_copy_indirect_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_create_dynamic_sections
value|elf_i386_create_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_fake_sections
value|elf_i386_fake_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_sections
value|elf_i386_finish_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_symbol
value|elf_i386_finish_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_mark_hook
value|elf_i386_gc_mark_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_sweep_hook
value|elf_i386_gc_sweep_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_grok_prstatus
value|elf_i386_grok_prstatus
end_define

begin_define
define|#
directive|define
name|elf_backend_grok_psinfo
value|elf_i386_grok_psinfo
end_define

begin_define
define|#
directive|define
name|elf_backend_reloc_type_class
value|elf_i386_reloc_type_class
end_define

begin_define
define|#
directive|define
name|elf_backend_relocate_section
value|elf_i386_relocate_section
end_define

begin_define
define|#
directive|define
name|elf_backend_size_dynamic_sections
value|elf_i386_size_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_always_size_sections
value|elf_i386_always_size_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_omit_section_dynsym
define|\
value|((bfd_boolean (*) (bfd *, struct bfd_link_info *, asection *)) bfd_true)
end_define

begin_define
define|#
directive|define
name|elf_backend_plt_sym_val
value|elf_i386_plt_sym_val
end_define

begin_define
define|#
directive|define
name|elf_backend_hash_symbol
value|elf_i386_hash_symbol
end_define

begin_include
include|#
directive|include
file|"elf32-target.h"
end_include

begin_comment
comment|/* FreeBSD support.  */
end_comment

begin_undef
undef|#
directive|undef
name|TARGET_LITTLE_SYM
end_undef

begin_define
define|#
directive|define
name|TARGET_LITTLE_SYM
value|bfd_elf32_i386_freebsd_vec
end_define

begin_undef
undef|#
directive|undef
name|TARGET_LITTLE_NAME
end_undef

begin_define
define|#
directive|define
name|TARGET_LITTLE_NAME
value|"elf32-i386-freebsd"
end_define

begin_undef
undef|#
directive|undef
name|ELF_OSABI
end_undef

begin_define
define|#
directive|define
name|ELF_OSABI
value|ELFOSABI_FREEBSD
end_define

begin_comment
comment|/* The kernel recognizes executables as valid only if they carry a    "FreeBSD" label in the ELF header.  So we put this label on all    executables and (for simplicity) also all other object files.  */
end_comment

begin_function
specifier|static
name|void
name|elf_i386_post_process_headers
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|Elf_Internal_Ehdr
modifier|*
name|i_ehdrp
decl_stmt|;
name|i_ehdrp
operator|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* Put an ABI label supported by FreeBSD>= 4.1.  */
name|i_ehdrp
operator|->
name|e_ident
index|[
name|EI_OSABI
index|]
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_osabi
expr_stmt|;
ifdef|#
directive|ifdef
name|OLD_FREEBSD_ABI_LABEL
comment|/* The ABI label supported by FreeBSD<= 4.0 is quite nonstandard.  */
name|memcpy
argument_list|(
operator|&
name|i_ehdrp
operator|->
name|e_ident
index|[
name|EI_ABIVERSION
index|]
argument_list|,
literal|"FreeBSD"
argument_list|,
literal|8
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_undef
undef|#
directive|undef
name|elf_backend_post_process_headers
end_undef

begin_define
define|#
directive|define
name|elf_backend_post_process_headers
value|elf_i386_post_process_headers
end_define

begin_undef
undef|#
directive|undef
name|elf32_bed
end_undef

begin_define
define|#
directive|define
name|elf32_bed
value|elf32_i386_fbsd_bed
end_define

begin_include
include|#
directive|include
file|"elf32-target.h"
end_include

begin_comment
comment|/* VxWorks support.  */
end_comment

begin_undef
undef|#
directive|undef
name|TARGET_LITTLE_SYM
end_undef

begin_define
define|#
directive|define
name|TARGET_LITTLE_SYM
value|bfd_elf32_i386_vxworks_vec
end_define

begin_undef
undef|#
directive|undef
name|TARGET_LITTLE_NAME
end_undef

begin_define
define|#
directive|define
name|TARGET_LITTLE_NAME
value|"elf32-i386-vxworks"
end_define

begin_undef
undef|#
directive|undef
name|ELF_OSABI
end_undef

begin_comment
comment|/* Like elf_i386_link_hash_table_create but with tweaks for VxWorks.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_link_hash_table
modifier|*
name|elf_i386_vxworks_link_hash_table_create
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|struct
name|bfd_link_hash_table
modifier|*
name|ret
decl_stmt|;
name|struct
name|elf_i386_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|ret
operator|=
name|elf_i386_link_hash_table_create
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|htab
operator|=
operator|(
expr|struct
name|elf_i386_link_hash_table
operator|*
operator|)
name|ret
expr_stmt|;
name|htab
operator|->
name|is_vxworks
operator|=
literal|1
expr_stmt|;
name|htab
operator|->
name|plt0_pad_byte
operator|=
literal|0x90
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|elf_backend_relocs_compatible
end_undef

begin_undef
undef|#
directive|undef
name|elf_backend_post_process_headers
end_undef

begin_undef
undef|#
directive|undef
name|bfd_elf32_bfd_link_hash_table_create
end_undef

begin_define
define|#
directive|define
name|bfd_elf32_bfd_link_hash_table_create
define|\
value|elf_i386_vxworks_link_hash_table_create
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_add_symbol_hook
end_undef

begin_define
define|#
directive|define
name|elf_backend_add_symbol_hook
define|\
value|elf_vxworks_add_symbol_hook
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_link_output_symbol_hook
end_undef

begin_define
define|#
directive|define
name|elf_backend_link_output_symbol_hook
define|\
value|elf_vxworks_link_output_symbol_hook
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_emit_relocs
end_undef

begin_define
define|#
directive|define
name|elf_backend_emit_relocs
value|elf_vxworks_emit_relocs
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_final_write_processing
end_undef

begin_define
define|#
directive|define
name|elf_backend_final_write_processing
define|\
value|elf_vxworks_final_write_processing
end_define

begin_comment
comment|/* On VxWorks, we emit relocations against _PROCEDURE_LINKAGE_TABLE_, so    define it.  */
end_comment

begin_undef
undef|#
directive|undef
name|elf_backend_want_plt_sym
end_undef

begin_define
define|#
directive|define
name|elf_backend_want_plt_sym
value|1
end_define

begin_undef
undef|#
directive|undef
name|elf32_bed
end_undef

begin_define
define|#
directive|define
name|elf32_bed
value|elf32_i386_vxworks_bed
end_define

begin_include
include|#
directive|include
file|"elf32-target.h"
end_include

end_unit

