begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Support for the generic parts of most COFF variants, for BFD.    Copyright 1990, 91, 92, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.    Written by Cygnus Support.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Most of this hacked by  Steve Chamberlain, 			sac@cygnus.com */
end_comment

begin_comment
comment|/*  SECTION 	coff backends  	BFD supports a number of different flavours of coff format. 	The major differences between formats are the sizes and 	alignments of fields in structures on disk, and the occasional 	extra field.  	Coff in all its varieties is implemented with a few common 	files and a number of implementation specific files. For 	example, The 88k bcs coff format is implemented in the file 	@file{coff-m88k.c}. This file @code{#include}s 	@file{coff/m88k.h} which defines the external structure of the 	coff format for the 88k, and @file{coff/internal.h} which 	defines the internal structure. @file{coff-m88k.c} also 	defines the relocations used by the 88k format 	@xref{Relocations}.  	The Intel i960 processor version of coff is implemented in 	@file{coff-i960.c}. This file has the same structure as 	@file{coff-m88k.c}, except that it includes @file{coff/i960.h} 	rather than @file{coff-m88k.h}.  SUBSECTION 	Porting to a new version of coff  	The recommended method is to select from the existing 	implementations the version of coff which is most like the one 	you want to use.  For example, we'll say that i386 coff is 	the one you select, and that your coff flavour is called foo. 	Copy @file{i386coff.c} to @file{foocoff.c}, copy 	@file{../include/coff/i386.h} to @file{../include/coff/foo.h}, 	and add the lines to @file{targets.c} and @file{Makefile.in} 	so that your new back end is used. Alter the shapes of the 	structures in @file{../include/coff/foo.h} so that they match 	what you need. You will probably also have to add 	@code{#ifdef}s to the code in @file{coff/internal.h} and 	@file{coffcode.h} if your version of coff is too wild.  	You can verify that your new BFD backend works quite simply by 	building @file{objdump} from the @file{binutils} directory, 	and making sure that its version of what's going on and your 	host system's idea (assuming it has the pretty standard coff 	dump utility, usually called @code{att-dump} or just 	@code{dump}) are the same.  Then clean up your code, and send 	what you've done to Cygnus. Then your stuff will be in the 	next release, and you won't have to keep integrating it.  SUBSECTION 	How the coff backend works  SUBSUBSECTION 	File layout  	The Coff backend is split into generic routines that are 	applicable to any Coff target and routines that are specific 	to a particular target.  The target-specific routines are 	further split into ones which are basically the same for all 	Coff targets except that they use the external symbol format 	or use different values for certain constants.  	The generic routines are in @file{coffgen.c}.  These routines 	work for any Coff target.  They use some hooks into the target 	specific code; the hooks are in a @code{bfd_coff_backend_data} 	structure, one of which exists for each target.  	The essentially similar target-specific routines are in 	@file{coffcode.h}.  This header file includes executable C code. 	The various Coff targets first include the appropriate Coff 	header file, make any special defines that are needed, and 	then include @file{coffcode.h}.  	Some of the Coff targets then also have additional routines in 	the target source file itself.  	For example, @file{coff-i960.c} includes 	@file{coff/internal.h} and @file{coff/i960.h}.  It then 	defines a few constants, such as @code{I960}, and includes 	@file{coffcode.h}.  Since the i960 has complex relocation 	types, @file{coff-i960.c} also includes some code to 	manipulate the i960 relocs.  This code is not in 	@file{coffcode.h} because it would not be used by any other 	target.  SUBSUBSECTION 	Bit twiddling  	Each flavour of coff supported in BFD has its own header file 	describing the external layout of the structures. There is also 	an internal description of the coff layout, in 	@file{coff/internal.h}. A major function of the 	coff backend is swapping the bytes and twiddling the bits to 	translate the external form of the structures into the normal 	internal form. This is all performed in the 	@code{bfd_swap}_@i{thing}_@i{direction} routines. Some 	elements are different sizes between different versions of 	coff; it is the duty of the coff version specific include file 	to override the definitions of various packing routines in 	@file{coffcode.h}. E.g., the size of line number entry in coff is 	sometimes 16 bits, and sometimes 32 bits. @code{#define}ing 	@code{PUT_LNSZ_LNNO} and @code{GET_LNSZ_LNNO} will select the 	correct one. No doubt, some day someone will find a version of 	coff which has a varying field size not catered to at the 	moment. To port BFD, that person will have to add more @code{#defines}. 	Three of the bit twiddling routines are exported to 	@code{gdb}; @code{coff_swap_aux_in}, @code{coff_swap_sym_in} 	and @code{coff_swap_linno_in}. @code{GDB} reads the symbol 	table on its own, but uses BFD to fix things up.  More of the 	bit twiddlers are exported for @code{gas}; 	@code{coff_swap_aux_out}, @code{coff_swap_sym_out}, 	@code{coff_swap_lineno_out}, @code{coff_swap_reloc_out}, 	@code{coff_swap_filehdr_out}, @code{coff_swap_aouthdr_out}, 	@code{coff_swap_scnhdr_out}. @code{Gas} currently keeps track 	of all the symbol table and reloc drudgery itself, thereby 	saving the internal BFD overhead, but uses BFD to swap things 	on the way out, making cross ports much safer.  Doing so also 	allows BFD (and thus the linker) to use the same header files 	as @code{gas}, which makes one avenue to disaster disappear.  SUBSUBSECTION 	Symbol reading  	The simple canonical form for symbols used by BFD is not rich 	enough to keep all the information available in a coff symbol 	table. The back end gets around this problem by keeping the original 	symbol table around, "behind the scenes".  	When a symbol table is requested (through a call to 	@code{bfd_canonicalize_symtab}), a request gets through to 	@code{coff_get_normalized_symtab}. This reads the symbol table from 	the coff file and swaps all the structures inside into the 	internal form. It also fixes up all the pointers in the table 	(represented in the file by offsets from the first symbol in 	the table) into physical pointers to elements in the new 	internal table. This involves some work since the meanings of 	fields change depending upon context: a field that is a 	pointer to another structure in the symbol table at one moment 	may be the size in bytes of a structure at the next.  Another 	pass is made over the table. All symbols which mark file names 	(<<C_FILE>> symbols) are modified so that the internal 	string points to the value in the auxent (the real filename) 	rather than the normal text associated with the symbol 	(@code{".file"}).  	At this time the symbol names are moved around. Coff stores 	all symbols less than nine characters long physically 	within the symbol table; longer strings are kept at the end of 	the file in the string 	table. This pass moves all strings 	into memory and replaces them with pointers to the strings.   	The symbol table is massaged once again, this time to create 	the canonical table used by the BFD application. Each symbol 	is inspected in turn, and a decision made (using the 	@code{sclass} field) about the various flags to set in the 	@code{asymbol}.  @xref{Symbols}. The generated canonical table 	shares strings with the hidden internal symbol table.  	Any linenumbers are read from the coff file too, and attached 	to the symbols which own the functions the linenumbers belong to.  SUBSUBSECTION 	Symbol writing  	Writing a symbol to a coff file which didn't come from a coff 	file will lose any debugging information. The @code{asymbol} 	structure remembers the BFD from which the symbol was taken, and on 	output the back end makes sure that the same destination target as 	source target is present.  	When the symbols have come from a coff file then all the 	debugging information is preserved.  	Symbol tables are provided for writing to the back end in a 	vector of pointers to pointers. This allows applications like 	the linker to accumulate and output large symbol tables 	without having to do too much byte copying.  	This function runs through the provided symbol table and 	patches each symbol marked as a file place holder 	(@code{C_FILE}) to point to the next file place holder in the 	list. It also marks each @code{offset} field in the list with 	the offset from the first symbol of the current symbol.  	Another function of this procedure is to turn the canonical 	value form of BFD into the form used by coff. Internally, BFD 	expects symbol values to be offsets from a section base; so a 	symbol physically at 0x120, but in a section starting at 	0x100, would have the value 0x20. Coff expects symbols to 	contain their final value, so symbols have their values 	changed at this point to reflect their sum with their owning 	section.  This transformation uses the<<output_section>> field of the @code{asymbol}'s 	@code{asection} @xref{Sections}.  	o<<coff_mangle_symbols>>  	This routine runs though the provided symbol table and uses 	the offsets generated by the previous pass and the pointers 	generated when the symbol table was read in to create the 	structured hierachy required by coff. It changes each pointer 	to a symbol into the index into the symbol table of the asymbol.  	o<<coff_write_symbols>>  	This routine runs through the symbol table and patches up the 	symbols from their internal form into the coff way, calls the 	bit twiddlers, and writes out the table to the file.  */
end_comment

begin_comment
comment|/* INTERNAL_DEFINITION 	coff_symbol_type  DESCRIPTION 	The hidden information for an<<asymbol>> is described in a<<combined_entry_type>>:  CODE_FRAGMENT . .typedef struct coff_ptr_struct .{ . .       {* Remembers the offset from the first symbol in the file for .          this symbol. Generated by coff_renumber_symbols. *} .unsigned int offset; . .       {* Should the value of this symbol be renumbered.  Used for .          XCOFF C_BSTAT symbols.  Set by coff_slurp_symbol_table.  *} .unsigned int fix_value : 1; . .       {* Should the tag field of this symbol be renumbered. .          Created by coff_pointerize_aux. *} .unsigned int fix_tag : 1; . .       {* Should the endidx field of this symbol be renumbered. .          Created by coff_pointerize_aux. *} .unsigned int fix_end : 1; . .       {* Should the x_csect.x_scnlen field be renumbered. .          Created by coff_pointerize_aux. *} .unsigned int fix_scnlen : 1; . .       {* Fix up an XCOFF C_BINCL/C_EINCL symbol.  The value is the .          index into the line number entries.  Set by .          coff_slurp_symbol_table.  *} .unsigned int fix_line : 1; . .       {* The container for the symbol structure as read and translated .           from the file. *} . .union { .   union internal_auxent auxent; .   struct internal_syment syment; . } u; .} combined_entry_type; . . .{* Each canonical asymbol really looks like this: *} . .typedef struct coff_symbol_struct .{ .   {* The actual symbol which the rest of BFD works with *} .asymbol symbol; . .   {* A pointer to the hidden information for this symbol *} .combined_entry_type *native; . .   {* A pointer to the linenumber information for this symbol *} .struct lineno_cache_entry *lineno; . .   {* Have the line numbers been relocated yet ? *} .boolean done_lineno; .} coff_symbol_type;   */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|COFF_WITH_PE
end_ifdef

begin_include
include|#
directive|include
file|"peicode.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"coffswap.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|STRING_SIZE_SIZE
value|(4)
end_define

begin_decl_stmt
specifier|static
name|long
name|sec_to_styp_flags
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|flagword
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|flagword
name|styp_to_sec_flags
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|coff_bad_format_hook
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|coff_new_section_hook
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|coff_set_arch_mach_hook
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|coff_write_relocs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|coff_set_flags
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|unsigned
name|int
operator|*
operator|,
name|unsigned
name|short
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|coff_set_arch_mach
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|enum
name|bfd_architecture
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|coff_compute_section_file_positions
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|coff_write_object_contents
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|coff_set_section_contents
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|,
name|file_ptr
operator|,
name|bfd_size_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|PTR
name|buy_and_read
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|file_ptr
operator|,
name|int
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|coff_slurp_line_table
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|coff_slurp_symbol_table
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|coff_slurp_reloc_table
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|asymbol
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|coff_canonicalize_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|arelent
operator|*
operator|*
operator|,
name|asymbol
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|coff_mkobject_hook
end_ifndef

begin_decl_stmt
specifier|static
name|PTR
name|coff_mkobject_hook
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* void warning(); */
end_comment

begin_comment
comment|/*  * Return a word with STYP_* (scnhdr.s_flags) flags set to represent the  * incoming SEC_* flags.  The inverse of this function is styp_to_sec_flags().  * NOTE: If you add to/change this routine, you should mirror the changes  * 	in styp_to_sec_flags().  */
end_comment

begin_function
specifier|static
name|long
name|sec_to_styp_flags
parameter_list|(
name|sec_name
parameter_list|,
name|sec_flags
parameter_list|)
name|CONST
name|char
modifier|*
name|sec_name
decl_stmt|;
name|flagword
name|sec_flags
decl_stmt|;
block|{
name|long
name|styp_flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|sec_name
argument_list|,
name|_TEXT
argument_list|)
condition|)
block|{
name|styp_flags
operator|=
name|STYP_TEXT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|sec_name
argument_list|,
name|_DATA
argument_list|)
condition|)
block|{
name|styp_flags
operator|=
name|STYP_DATA
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|sec_name
argument_list|,
name|_BSS
argument_list|)
condition|)
block|{
name|styp_flags
operator|=
name|STYP_BSS
expr_stmt|;
ifdef|#
directive|ifdef
name|_COMMENT
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|sec_name
argument_list|,
name|_COMMENT
argument_list|)
condition|)
block|{
name|styp_flags
operator|=
name|STYP_INFO
expr_stmt|;
endif|#
directive|endif
comment|/* _COMMENT */
ifdef|#
directive|ifdef
name|_LIB
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|sec_name
argument_list|,
name|_LIB
argument_list|)
condition|)
block|{
name|styp_flags
operator|=
name|STYP_LIB
expr_stmt|;
endif|#
directive|endif
comment|/* _LIB */
ifdef|#
directive|ifdef
name|_LIT
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|sec_name
argument_list|,
name|_LIT
argument_list|)
condition|)
block|{
name|styp_flags
operator|=
name|STYP_LIT
expr_stmt|;
endif|#
directive|endif
comment|/* _LIT */
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|sec_name
argument_list|,
literal|".debug"
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|STYP_DEBUG
name|styp_flags
operator|=
name|STYP_DEBUG
expr_stmt|;
else|#
directive|else
name|styp_flags
operator|=
name|STYP_INFO
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|sec_name
argument_list|,
literal|".stab"
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|styp_flags
operator|=
name|STYP_INFO
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|COFF_WITH_PE
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|sec_name
argument_list|,
literal|".edata"
argument_list|)
condition|)
block|{
name|styp_flags
operator|=
name|STYP_DATA
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RS6000COFF_C
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|sec_name
argument_list|,
name|_PAD
argument_list|)
condition|)
block|{
name|styp_flags
operator|=
name|STYP_PAD
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|sec_name
argument_list|,
name|_LOADER
argument_list|)
condition|)
block|{
name|styp_flags
operator|=
name|STYP_LOADER
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Try and figure out what it should be */
elseif|else
if|if
condition|(
name|sec_flags
operator|&
name|SEC_CODE
condition|)
block|{
name|styp_flags
operator|=
name|STYP_TEXT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sec_flags
operator|&
name|SEC_DATA
condition|)
block|{
name|styp_flags
operator|=
name|STYP_DATA
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sec_flags
operator|&
name|SEC_READONLY
condition|)
block|{
ifdef|#
directive|ifdef
name|STYP_LIT
comment|/* 29k readonly text/data section */
name|styp_flags
operator|=
name|STYP_LIT
expr_stmt|;
else|#
directive|else
name|styp_flags
operator|=
name|STYP_TEXT
expr_stmt|;
endif|#
directive|endif
comment|/* STYP_LIT */
block|}
elseif|else
if|if
condition|(
name|sec_flags
operator|&
name|SEC_LOAD
condition|)
block|{
name|styp_flags
operator|=
name|STYP_TEXT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sec_flags
operator|&
name|SEC_ALLOC
condition|)
block|{
name|styp_flags
operator|=
name|STYP_BSS
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|STYP_NOLOAD
if|if
condition|(
operator|(
name|sec_flags
operator|&
operator|(
name|SEC_NEVER_LOAD
operator||
name|SEC_COFF_SHARED_LIBRARY
operator|)
operator|)
operator|!=
literal|0
condition|)
name|styp_flags
operator||=
name|STYP_NOLOAD
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|COFF_WITH_PE
if|if
condition|(
name|sec_flags
operator|&
name|SEC_LINK_ONCE
condition|)
name|styp_flags
operator||=
name|IMAGE_SCN_LNK_COMDAT
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|styp_flags
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return a word with SEC_* flags set to represent the incoming  * STYP_* flags (from scnhdr.s_flags).   The inverse of this  * function is sec_to_styp_flags().  * NOTE: If you add to/change this routine, you should mirror the changes  *      in sec_to_styp_flags().  */
end_comment

begin_function
specifier|static
name|flagword
name|styp_to_sec_flags
parameter_list|(
name|abfd
parameter_list|,
name|hdr
parameter_list|,
name|name
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|hdr
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|internal_scnhdr
modifier|*
name|internal_s
init|=
operator|(
expr|struct
name|internal_scnhdr
operator|*
operator|)
name|hdr
decl_stmt|;
name|long
name|styp_flags
init|=
name|internal_s
operator|->
name|s_flags
decl_stmt|;
name|flagword
name|sec_flags
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|STYP_NOLOAD
if|if
condition|(
name|styp_flags
operator|&
name|STYP_NOLOAD
condition|)
block|{
name|sec_flags
operator||=
name|SEC_NEVER_LOAD
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* STYP_NOLOAD */
comment|/* For 386 COFF, at least, an unloadable text or data section is      actually a shared library section.  */
if|if
condition|(
name|styp_flags
operator|&
name|STYP_TEXT
condition|)
block|{
if|if
condition|(
name|sec_flags
operator|&
name|SEC_NEVER_LOAD
condition|)
name|sec_flags
operator||=
name|SEC_CODE
operator||
name|SEC_COFF_SHARED_LIBRARY
expr_stmt|;
else|else
name|sec_flags
operator||=
name|SEC_CODE
operator||
name|SEC_LOAD
operator||
name|SEC_ALLOC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|styp_flags
operator|&
name|STYP_DATA
condition|)
block|{
if|if
condition|(
name|sec_flags
operator|&
name|SEC_NEVER_LOAD
condition|)
name|sec_flags
operator||=
name|SEC_DATA
operator||
name|SEC_COFF_SHARED_LIBRARY
expr_stmt|;
else|else
name|sec_flags
operator||=
name|SEC_DATA
operator||
name|SEC_LOAD
operator||
name|SEC_ALLOC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|styp_flags
operator|&
name|STYP_BSS
condition|)
block|{
ifdef|#
directive|ifdef
name|BSS_NOLOAD_IS_SHARED_LIBRARY
if|if
condition|(
name|sec_flags
operator|&
name|SEC_NEVER_LOAD
condition|)
name|sec_flags
operator||=
name|SEC_ALLOC
operator||
name|SEC_COFF_SHARED_LIBRARY
expr_stmt|;
else|else
endif|#
directive|endif
name|sec_flags
operator||=
name|SEC_ALLOC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|styp_flags
operator|&
name|STYP_INFO
condition|)
block|{
comment|/* We mark these as SEC_DEBUGGING, but only if COFF_PAGE_SIZE is 	 defined.  coff_compute_section_file_positions uses 	 COFF_PAGE_SIZE to ensure that the low order bits of the 	 section VMA and the file offset match.  If we don't know 	 COFF_PAGE_SIZE, we can't ensure the correct correspondence, 	 and demand page loading of the file will fail.  */
ifdef|#
directive|ifdef
name|COFF_PAGE_SIZE
name|sec_flags
operator||=
name|SEC_DEBUGGING
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|styp_flags
operator|&
name|STYP_PAD
condition|)
block|{
name|sec_flags
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|_TEXT
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sec_flags
operator|&
name|SEC_NEVER_LOAD
condition|)
name|sec_flags
operator||=
name|SEC_CODE
operator||
name|SEC_COFF_SHARED_LIBRARY
expr_stmt|;
else|else
name|sec_flags
operator||=
name|SEC_CODE
operator||
name|SEC_LOAD
operator||
name|SEC_ALLOC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|_DATA
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sec_flags
operator|&
name|SEC_NEVER_LOAD
condition|)
name|sec_flags
operator||=
name|SEC_DATA
operator||
name|SEC_COFF_SHARED_LIBRARY
expr_stmt|;
else|else
name|sec_flags
operator||=
name|SEC_DATA
operator||
name|SEC_LOAD
operator||
name|SEC_ALLOC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|_BSS
argument_list|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|BSS_NOLOAD_IS_SHARED_LIBRARY
if|if
condition|(
name|sec_flags
operator|&
name|SEC_NEVER_LOAD
condition|)
name|sec_flags
operator||=
name|SEC_ALLOC
operator||
name|SEC_COFF_SHARED_LIBRARY
expr_stmt|;
else|else
endif|#
directive|endif
name|sec_flags
operator||=
name|SEC_ALLOC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".debug"
argument_list|)
operator|==
literal|0
ifdef|#
directive|ifdef
name|_COMMENT
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
name|_COMMENT
argument_list|)
operator|==
literal|0
endif|#
directive|endif
operator|||
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".stab"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|COFF_PAGE_SIZE
name|sec_flags
operator||=
name|SEC_DEBUGGING
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|_LIB
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|_LIB
argument_list|)
operator|==
literal|0
condition|)
empty_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|_LIT
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|_LIT
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sec_flags
operator|=
name|SEC_LOAD
operator||
name|SEC_ALLOC
operator||
name|SEC_READONLY
expr_stmt|;
block|}
endif|#
directive|endif
else|else
block|{
name|sec_flags
operator||=
name|SEC_ALLOC
operator||
name|SEC_LOAD
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|STYP_LIT
comment|/* A29k readonly text/data section type */
if|if
condition|(
operator|(
name|styp_flags
operator|&
name|STYP_LIT
operator|)
operator|==
name|STYP_LIT
condition|)
block|{
name|sec_flags
operator|=
operator|(
name|SEC_LOAD
operator||
name|SEC_ALLOC
operator||
name|SEC_READONLY
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* STYP_LIT */
ifdef|#
directive|ifdef
name|STYP_OTHER_LOAD
comment|/* Other loaded sections */
if|if
condition|(
name|styp_flags
operator|&
name|STYP_OTHER_LOAD
condition|)
block|{
name|sec_flags
operator|=
operator|(
name|SEC_LOAD
operator||
name|SEC_ALLOC
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* STYP_SDATA */
ifdef|#
directive|ifdef
name|COFF_WITH_PE
if|if
condition|(
name|styp_flags
operator|&
name|IMAGE_SCN_LNK_REMOVE
condition|)
name|sec_flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
if|if
condition|(
name|styp_flags
operator|&
name|IMAGE_SCN_LNK_COMDAT
condition|)
block|{
name|sec_flags
operator||=
name|SEC_LINK_ONCE
expr_stmt|;
comment|/* Unfortunately, the PE format stores essential information in          the symbol table, of all places.  We need to extract that          information now, so that objdump and the linker will know how          to handle the section without worrying about the symbols.  We          can't call slurp_symtab, because the linker doesn't want the          swapped symbols.  */
if|if
condition|(
name|_bfd_coff_get_external_symbols
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|bfd_byte
modifier|*
name|esym
decl_stmt|,
modifier|*
name|esymend
decl_stmt|;
name|esym
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|obj_coff_external_syms
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|esymend
operator|=
name|esym
operator|+
name|obj_raw_syment_count
argument_list|(
name|abfd
argument_list|)
operator|*
name|SYMESZ
expr_stmt|;
while|while
condition|(
name|esym
operator|<
name|esymend
condition|)
block|{
name|struct
name|internal_syment
name|isym
decl_stmt|;
name|bfd_coff_swap_sym_in
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|esym
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|isym
argument_list|)
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|internal_s
operator|->
name|s_name
argument_list|)
operator|>
name|SYMNMLEN
condition|)
block|{
comment|/* This case implies that the matching symbol name                      will be in the string table.  */
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|isym
operator|.
name|n_sclass
operator|==
name|C_STAT
operator|&&
name|isym
operator|.
name|n_type
operator|==
name|T_NULL
operator|&&
name|isym
operator|.
name|n_numaux
operator|==
literal|1
condition|)
block|{
name|char
name|buf
index|[
name|SYMNMLEN
operator|+
literal|1
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|symname
decl_stmt|;
name|symname
operator|=
name|_bfd_coff_internal_syment_name
argument_list|(
name|abfd
argument_list|,
operator|&
name|isym
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|symname
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|symname
argument_list|)
operator|==
literal|0
condition|)
block|{
name|union
name|internal_auxent
name|aux
decl_stmt|;
comment|/* This is the section symbol.  */
name|bfd_coff_swap_aux_in
argument_list|(
name|abfd
argument_list|,
call|(
name|PTR
call|)
argument_list|(
name|esym
operator|+
name|SYMESZ
argument_list|)
argument_list|,
name|isym
operator|.
name|n_type
argument_list|,
name|isym
operator|.
name|n_sclass
argument_list|,
literal|0
argument_list|,
name|isym
operator|.
name|n_numaux
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|aux
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|aux
operator|.
name|x_scn
operator|.
name|x_comdat
condition|)
block|{
case|case
name|IMAGE_COMDAT_SELECT_NODUPLICATES
case|:
name|sec_flags
operator||=
name|SEC_LINK_DUPLICATES_ONE_ONLY
expr_stmt|;
break|break;
default|default:
case|case
name|IMAGE_COMDAT_SELECT_ANY
case|:
name|sec_flags
operator||=
name|SEC_LINK_DUPLICATES_DISCARD
expr_stmt|;
break|break;
case|case
name|IMAGE_COMDAT_SELECT_SAME_SIZE
case|:
name|sec_flags
operator||=
name|SEC_LINK_DUPLICATES_SAME_SIZE
expr_stmt|;
break|break;
case|case
name|IMAGE_COMDAT_SELECT_EXACT_MATCH
case|:
name|sec_flags
operator||=
name|SEC_LINK_DUPLICATES_SAME_CONTENTS
expr_stmt|;
break|break;
case|case
name|IMAGE_COMDAT_SELECT_ASSOCIATIVE
case|:
comment|/* FIXME: This is not currently implemented.  */
name|sec_flags
operator||=
name|SEC_LINK_DUPLICATES_DISCARD
expr_stmt|;
break|break;
block|}
break|break;
block|}
block|}
name|esym
operator|+=
operator|(
name|isym
operator|.
name|n_numaux
operator|+
literal|1
operator|)
operator|*
name|SYMESZ
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
return|return
operator|(
name|sec_flags
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|get_index
parameter_list|(
name|symbol
parameter_list|)
value|((symbol)->udata.i)
end_define

begin_comment
comment|/* INTERNAL_DEFINITION 	bfd_coff_backend_data  CODE_FRAGMENT  Special entry points for gdb to swap in coff symbol table parts: .typedef struct .{ .  void (*_bfd_coff_swap_aux_in) PARAMS (( .       bfd            *abfd, .       PTR             ext, .       int             type, .       int             class, .       int             indaux, .       int             numaux, .       PTR             in)); . .  void (*_bfd_coff_swap_sym_in) PARAMS (( .       bfd            *abfd , .       PTR             ext, .       PTR             in)); . .  void (*_bfd_coff_swap_lineno_in) PARAMS (( .       bfd            *abfd, .       PTR            ext, .       PTR             in)); .  Special entry points for gas to swap out coff parts:  . unsigned int (*_bfd_coff_swap_aux_out) PARAMS (( .       bfd   	*abfd, .       PTR	in, .       int    	type, .       int    	class, .       int     indaux, .       int     numaux, .       PTR    	ext)); . . unsigned int (*_bfd_coff_swap_sym_out) PARAMS (( .      bfd      *abfd, .      PTR	in, .      PTR	ext)); . . unsigned int (*_bfd_coff_swap_lineno_out) PARAMS (( .      	bfd   	*abfd, .      	PTR	in, .	PTR	ext)); . . unsigned int (*_bfd_coff_swap_reloc_out) PARAMS (( .      	bfd     *abfd, .     	PTR	src, .	PTR	dst)); . . unsigned int (*_bfd_coff_swap_filehdr_out) PARAMS (( .      	bfd  	*abfd, .	PTR 	in, .	PTR 	out)); . . unsigned int (*_bfd_coff_swap_aouthdr_out) PARAMS (( .      	bfd 	*abfd, .	PTR 	in, .	PTR	out)); . . unsigned int (*_bfd_coff_swap_scnhdr_out) PARAMS (( .      	bfd  	*abfd, .      	PTR	in, .	PTR	out)); .  Special entry points for generic COFF routines to call target dependent COFF routines:  . unsigned int _bfd_filhsz; . unsigned int _bfd_aoutsz; . unsigned int _bfd_scnhsz; . unsigned int _bfd_symesz; . unsigned int _bfd_auxesz; . unsigned int _bfd_relsz; . unsigned int _bfd_linesz; . boolean _bfd_coff_long_filenames; . boolean _bfd_coff_long_section_names; . unsigned int _bfd_coff_default_section_alignment_power; . void (*_bfd_coff_swap_filehdr_in) PARAMS (( .       bfd     *abfd, .       PTR     ext, .       PTR     in)); . void (*_bfd_coff_swap_aouthdr_in) PARAMS (( .       bfd     *abfd, .       PTR     ext, .       PTR     in)); . void (*_bfd_coff_swap_scnhdr_in) PARAMS (( .       bfd     *abfd, .       PTR     ext, .       PTR     in)); . void (*_bfd_coff_swap_reloc_in) PARAMS (( .       bfd     *abfd, .       PTR     ext, .       PTR     in)); . boolean (*_bfd_coff_bad_format_hook) PARAMS (( .       bfd     *abfd, .       PTR     internal_filehdr)); . boolean (*_bfd_coff_set_arch_mach_hook) PARAMS (( .       bfd     *abfd, .       PTR     internal_filehdr)); . PTR (*_bfd_coff_mkobject_hook) PARAMS (( .       bfd     *abfd, .       PTR     internal_filehdr, .       PTR     internal_aouthdr)); . flagword (*_bfd_styp_to_sec_flags_hook) PARAMS (( .       bfd     *abfd, .       PTR     internal_scnhdr, .       const char *name)); . void (*_bfd_set_alignment_hook) PARAMS (( .       bfd     *abfd, .       asection *sec, .       PTR     internal_scnhdr)); . boolean (*_bfd_coff_slurp_symbol_table) PARAMS (( .       bfd     *abfd)); . boolean (*_bfd_coff_symname_in_debug) PARAMS (( .       bfd     *abfd, .       struct internal_syment *sym)); . boolean (*_bfd_coff_pointerize_aux_hook) PARAMS (( .       bfd *abfd, .       combined_entry_type *table_base, .       combined_entry_type *symbol, .       unsigned int indaux, .       combined_entry_type *aux)); . boolean (*_bfd_coff_print_aux) PARAMS (( .       bfd *abfd, .       FILE *file, .       combined_entry_type *table_base, .       combined_entry_type *symbol, .       combined_entry_type *aux, .       unsigned int indaux)); . void (*_bfd_coff_reloc16_extra_cases) PARAMS (( .       bfd     *abfd, .       struct bfd_link_info *link_info, .       struct bfd_link_order *link_order, .       arelent *reloc, .       bfd_byte *data, .       unsigned int *src_ptr, .       unsigned int *dst_ptr)); . int (*_bfd_coff_reloc16_estimate) PARAMS (( .       bfd *abfd, .       asection *input_section, .       arelent *r, .       unsigned int shrink, .       struct bfd_link_info *link_info)); . boolean (*_bfd_coff_sym_is_global) PARAMS (( .       bfd *abfd, .       struct internal_syment *)); . boolean (*_bfd_coff_compute_section_file_positions) PARAMS (( .       bfd *abfd)); . boolean (*_bfd_coff_start_final_link) PARAMS (( .       bfd *output_bfd, .       struct bfd_link_info *info)); . boolean (*_bfd_coff_relocate_section) PARAMS (( .       bfd *output_bfd, .       struct bfd_link_info *info, .       bfd *input_bfd, .       asection *input_section, .       bfd_byte *contents, .       struct internal_reloc *relocs, .       struct internal_syment *syms, .       asection **sections)); . reloc_howto_type *(*_bfd_coff_rtype_to_howto) PARAMS (( .       bfd *abfd, .       asection *sec, .       struct internal_reloc *rel, .       struct coff_link_hash_entry *h, .       struct internal_syment *sym, .       bfd_vma *addendp)); . boolean (*_bfd_coff_adjust_symndx) PARAMS (( .       bfd *obfd, .       struct bfd_link_info *info, .       bfd *ibfd, .       asection *sec, .       struct internal_reloc *reloc, .       boolean *adjustedp)); . boolean (*_bfd_coff_link_add_one_symbol) PARAMS (( .       struct bfd_link_info *info, .       bfd *abfd, .       const char *name, .       flagword flags,  .       asection *section, .       bfd_vma value, .       const char *string, .       boolean copy, .       boolean collect,  .       struct bfd_link_hash_entry **hashp)); . .} bfd_coff_backend_data; . .#define coff_backend_info(abfd) ((bfd_coff_backend_data *) (abfd)->xvec->backend_data) . .#define bfd_coff_swap_aux_in(a,e,t,c,ind,num,i) \ .        ((coff_backend_info (a)->_bfd_coff_swap_aux_in) (a,e,t,c,ind,num,i)) . .#define bfd_coff_swap_sym_in(a,e,i) \ .        ((coff_backend_info (a)->_bfd_coff_swap_sym_in) (a,e,i)) . .#define bfd_coff_swap_lineno_in(a,e,i) \ .        ((coff_backend_info ( a)->_bfd_coff_swap_lineno_in) (a,e,i)) . .#define bfd_coff_swap_reloc_out(abfd, i, o) \ .        ((coff_backend_info (abfd)->_bfd_coff_swap_reloc_out) (abfd, i, o)) . .#define bfd_coff_swap_lineno_out(abfd, i, o) \ .        ((coff_backend_info (abfd)->_bfd_coff_swap_lineno_out) (abfd, i, o)) . .#define bfd_coff_swap_aux_out(a,i,t,c,ind,num,o) \ .        ((coff_backend_info (a)->_bfd_coff_swap_aux_out) (a,i,t,c,ind,num,o)) . .#define bfd_coff_swap_sym_out(abfd, i,o) \ .        ((coff_backend_info (abfd)->_bfd_coff_swap_sym_out) (abfd, i, o)) . .#define bfd_coff_swap_scnhdr_out(abfd, i,o) \ .        ((coff_backend_info (abfd)->_bfd_coff_swap_scnhdr_out) (abfd, i, o)) . .#define bfd_coff_swap_filehdr_out(abfd, i,o) \ .        ((coff_backend_info (abfd)->_bfd_coff_swap_filehdr_out) (abfd, i, o)) . .#define bfd_coff_swap_aouthdr_out(abfd, i,o) \ .        ((coff_backend_info (abfd)->_bfd_coff_swap_aouthdr_out) (abfd, i, o)) . .#define bfd_coff_filhsz(abfd) (coff_backend_info (abfd)->_bfd_filhsz) .#define bfd_coff_aoutsz(abfd) (coff_backend_info (abfd)->_bfd_aoutsz) .#define bfd_coff_scnhsz(abfd) (coff_backend_info (abfd)->_bfd_scnhsz) .#define bfd_coff_symesz(abfd) (coff_backend_info (abfd)->_bfd_symesz) .#define bfd_coff_auxesz(abfd) (coff_backend_info (abfd)->_bfd_auxesz) .#define bfd_coff_relsz(abfd)  (coff_backend_info (abfd)->_bfd_relsz) .#define bfd_coff_linesz(abfd) (coff_backend_info (abfd)->_bfd_linesz) .#define bfd_coff_long_filenames(abfd) (coff_backend_info (abfd)->_bfd_coff_long_filenames) .#define bfd_coff_long_section_names(abfd) \ .        (coff_backend_info (abfd)->_bfd_coff_long_section_names) .#define bfd_coff_default_section_alignment_power(abfd) \ .	 (coff_backend_info (abfd)->_bfd_coff_default_section_alignment_power) .#define bfd_coff_swap_filehdr_in(abfd, i,o) \ .        ((coff_backend_info (abfd)->_bfd_coff_swap_filehdr_in) (abfd, i, o)) . .#define bfd_coff_swap_aouthdr_in(abfd, i,o) \ .        ((coff_backend_info (abfd)->_bfd_coff_swap_aouthdr_in) (abfd, i, o)) . .#define bfd_coff_swap_scnhdr_in(abfd, i,o) \ .        ((coff_backend_info (abfd)->_bfd_coff_swap_scnhdr_in) (abfd, i, o)) . .#define bfd_coff_swap_reloc_in(abfd, i, o) \ .        ((coff_backend_info (abfd)->_bfd_coff_swap_reloc_in) (abfd, i, o)) . .#define bfd_coff_bad_format_hook(abfd, filehdr) \ .        ((coff_backend_info (abfd)->_bfd_coff_bad_format_hook) (abfd, filehdr)) . .#define bfd_coff_set_arch_mach_hook(abfd, filehdr)\ .        ((coff_backend_info (abfd)->_bfd_coff_set_arch_mach_hook) (abfd, filehdr)) .#define bfd_coff_mkobject_hook(abfd, filehdr, aouthdr)\ .        ((coff_backend_info (abfd)->_bfd_coff_mkobject_hook) (abfd, filehdr, aouthdr)) . .#define bfd_coff_styp_to_sec_flags_hook(abfd, scnhdr, name)\ .        ((coff_backend_info (abfd)->_bfd_styp_to_sec_flags_hook) (abfd, scnhdr, name)) . .#define bfd_coff_set_alignment_hook(abfd, sec, scnhdr)\ .        ((coff_backend_info (abfd)->_bfd_set_alignment_hook) (abfd, sec, scnhdr)) . .#define bfd_coff_slurp_symbol_table(abfd)\ .        ((coff_backend_info (abfd)->_bfd_coff_slurp_symbol_table) (abfd)) . .#define bfd_coff_symname_in_debug(abfd, sym)\ .        ((coff_backend_info (abfd)->_bfd_coff_symname_in_debug) (abfd, sym)) . .#define bfd_coff_print_aux(abfd, file, base, symbol, aux, indaux)\ .        ((coff_backend_info (abfd)->_bfd_coff_print_aux)\ .         (abfd, file, base, symbol, aux, indaux)) . .#define bfd_coff_reloc16_extra_cases(abfd, link_info, link_order, reloc, data, src_ptr, dst_ptr)\ .        ((coff_backend_info (abfd)->_bfd_coff_reloc16_extra_cases)\ .         (abfd, link_info, link_order, reloc, data, src_ptr, dst_ptr)) . .#define bfd_coff_reloc16_estimate(abfd, section, reloc, shrink, link_info)\ .        ((coff_backend_info (abfd)->_bfd_coff_reloc16_estimate)\ .         (abfd, section, reloc, shrink, link_info)) . .#define bfd_coff_sym_is_global(abfd, sym)\ .        ((coff_backend_info (abfd)->_bfd_coff_sym_is_global)\ .         (abfd, sym)) . .#define bfd_coff_compute_section_file_positions(abfd)\ .        ((coff_backend_info (abfd)->_bfd_coff_compute_section_file_positions)\ .         (abfd)) . .#define bfd_coff_start_final_link(obfd, info)\ .        ((coff_backend_info (obfd)->_bfd_coff_start_final_link)\ .         (obfd, info)) .#define bfd_coff_relocate_section(obfd,info,ibfd,o,con,rel,isyms,secs)\ .        ((coff_backend_info (ibfd)->_bfd_coff_relocate_section)\ .         (obfd, info, ibfd, o, con, rel, isyms, secs)) .#define bfd_coff_rtype_to_howto(abfd, sec, rel, h, sym, addendp)\ .        ((coff_backend_info (abfd)->_bfd_coff_rtype_to_howto)\ .         (abfd, sec, rel, h, sym, addendp)) .#define bfd_coff_adjust_symndx(obfd, info, ibfd, sec, rel, adjustedp)\ .        ((coff_backend_info (abfd)->_bfd_coff_adjust_symndx)\ .         (obfd, info, ibfd, sec, rel, adjustedp)) .#define bfd_coff_link_add_one_symbol(info,abfd,name,flags,section,value,string,cp,coll,hashp)\ .        ((coff_backend_info (abfd)->_bfd_coff_link_add_one_symbol)\ .         (info, abfd, name, flags, section, value, string, cp, coll, hashp)) . */
end_comment

begin_comment
comment|/* See whether the magic number matches.  */
end_comment

begin_function
specifier|static
name|boolean
name|coff_bad_format_hook
parameter_list|(
name|abfd
parameter_list|,
name|filehdr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|filehdr
decl_stmt|;
block|{
name|struct
name|internal_filehdr
modifier|*
name|internal_f
init|=
operator|(
expr|struct
name|internal_filehdr
operator|*
operator|)
name|filehdr
decl_stmt|;
if|if
condition|(
name|BADMAG
argument_list|(
operator|*
name|internal_f
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* if the optional header is NULL or not the correct size then      quit; the only difference I can see between m88k dgux headers (MC88DMAGIC)      and Intel 960 readwrite headers (I960WRMAGIC) is that the      optional header is of a different size.       But the mips keeps extra stuff in it's opthdr, so dont check      when doing that      */
if|#
directive|if
name|defined
argument_list|(
name|M88
argument_list|)
operator|||
name|defined
argument_list|(
name|I960
argument_list|)
if|if
condition|(
name|internal_f
operator|->
name|f_opthdr
operator|!=
literal|0
operator|&&
name|AOUTSZ
operator|!=
name|internal_f
operator|->
name|f_opthdr
condition|)
return|return
name|false
return|;
endif|#
directive|endif
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/*    initialize a section structure with information peculiar to this    particular implementation of coff */
end_comment

begin_function
specifier|static
name|boolean
name|coff_new_section_hook
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
block|{
name|section
operator|->
name|alignment_power
operator|=
name|COFF_DEFAULT_SECTION_ALIGNMENT_POWER
expr_stmt|;
ifdef|#
directive|ifdef
name|RS6000COFF_C
if|if
condition|(
name|xcoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|text_align_power
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
argument_list|,
literal|".text"
argument_list|)
operator|==
literal|0
condition|)
name|section
operator|->
name|alignment_power
operator|=
name|xcoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|text_align_power
expr_stmt|;
if|if
condition|(
name|xcoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|data_align_power
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
argument_list|,
literal|".data"
argument_list|)
operator|==
literal|0
condition|)
name|section
operator|->
name|alignment_power
operator|=
name|xcoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|data_align_power
expr_stmt|;
endif|#
directive|endif
comment|/* Allocate aux records for section symbols, to store size and      related info.       @@ The 10 is a guess at a plausible maximum number of aux entries      (but shouldn't be a constant).  */
name|coffsymbol
argument_list|(
name|section
operator|->
name|symbol
argument_list|)
operator|->
name|native
operator|=
operator|(
name|combined_entry_type
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|combined_entry_type
argument_list|)
operator|*
literal|10
argument_list|)
expr_stmt|;
comment|/* The .stab section must be aligned to 2**2 at most, because      otherwise there may be gaps in the section which gdb will not      know how to interpret.  Examining the section name is a hack, but      that is also how gdb locates the section.      We need to handle the .ctors and .dtors sections similarly, to      avoid introducing null words in the tables.  */
if|if
condition|(
name|COFF_DEFAULT_SECTION_ALIGNMENT_POWER
operator|>
literal|2
operator|&&
operator|(
name|strncmp
argument_list|(
name|section
operator|->
name|name
argument_list|,
literal|".stab"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|section
operator|->
name|name
argument_list|,
literal|".ctors"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|section
operator|->
name|name
argument_list|,
literal|".dtors"
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|section
operator|->
name|alignment_power
operator|=
literal|2
expr_stmt|;
comment|/* Similarly, the .stabstr section must be aligned to 2**0 at most.  */
if|if
condition|(
name|COFF_DEFAULT_SECTION_ALIGNMENT_POWER
operator|>
literal|0
operator|&&
name|strncmp
argument_list|(
name|section
operator|->
name|name
argument_list|,
literal|".stabstr"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
name|section
operator|->
name|alignment_power
operator|=
literal|0
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|I960
end_ifdef

begin_comment
comment|/* Set the alignment of a BFD section.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|coff_set_alignment_hook
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|coff_set_alignment_hook
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|scnhdr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|PTR
name|scnhdr
decl_stmt|;
block|{
name|struct
name|internal_scnhdr
modifier|*
name|hdr
init|=
operator|(
expr|struct
name|internal_scnhdr
operator|*
operator|)
name|scnhdr
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
literal|1
operator|<<
name|i
operator|)
operator|>=
name|hdr
operator|->
name|s_align
condition|)
break|break;
name|section
operator|->
name|alignment_power
operator|=
name|i
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! I960 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|COFF_WITH_PE
end_ifdef

begin_comment
comment|/* a couple of macros to help setting the alignment power field */
end_comment

begin_define
define|#
directive|define
name|ALIGN_SET
parameter_list|(
name|field
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|)
define|\
value|if (((field)& IMAGE_SCN_ALIGN_64BYTES) == x )\   {\      section->alignment_power = y;\   }
end_define

begin_define
define|#
directive|define
name|ELIFALIGN_SET
parameter_list|(
name|field
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|)
define|\
value|else if (( (field)& IMAGE_SCN_ALIGN_64BYTES) == x ) \   {\      section->alignment_power = y;\   }
end_define

begin_decl_stmt
specifier|static
name|void
name|coff_set_alignment_hook
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|coff_set_alignment_hook
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|scnhdr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|PTR
name|scnhdr
decl_stmt|;
block|{
name|struct
name|internal_scnhdr
modifier|*
name|hdr
init|=
operator|(
expr|struct
name|internal_scnhdr
operator|*
operator|)
name|scnhdr
decl_stmt|;
name|ALIGN_SET
argument_list|(
argument|hdr->s_flags
argument_list|,
argument|IMAGE_SCN_ALIGN_64BYTES
argument_list|,
literal|6
argument_list|)
name|ELIFALIGN_SET
argument_list|(
argument|hdr->s_flags
argument_list|,
argument|IMAGE_SCN_ALIGN_32BYTES
argument_list|,
literal|5
argument_list|)
name|ELIFALIGN_SET
argument_list|(
argument|hdr->s_flags
argument_list|,
argument|IMAGE_SCN_ALIGN_16BYTES
argument_list|,
literal|4
argument_list|)
name|ELIFALIGN_SET
argument_list|(
argument|hdr->s_flags
argument_list|,
argument|IMAGE_SCN_ALIGN_8BYTES
argument_list|,
literal|3
argument_list|)
name|ELIFALIGN_SET
argument_list|(
argument|hdr->s_flags
argument_list|,
argument|IMAGE_SCN_ALIGN_4BYTES
argument_list|,
literal|2
argument_list|)
name|ELIFALIGN_SET
argument_list|(
argument|hdr->s_flags
argument_list|,
argument|IMAGE_SCN_ALIGN_2BYTES
argument_list|,
literal|1
argument_list|)
name|ELIFALIGN_SET
argument_list|(
argument|hdr->s_flags
argument_list|,
argument|IMAGE_SCN_ALIGN_1BYTES
argument_list|,
literal|0
argument_list|)
ifdef|#
directive|ifdef
name|POWERPC_LE_PE
if|if
condition|(
name|strcmp
argument_list|(
name|section
operator|->
name|name
argument_list|,
literal|".idata$2"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|section
operator|->
name|alignment_power
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|section
operator|->
name|name
argument_list|,
literal|".idata$3"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|section
operator|->
name|alignment_power
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|section
operator|->
name|name
argument_list|,
literal|".idata$4"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|section
operator|->
name|alignment_power
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|section
operator|->
name|name
argument_list|,
literal|".idata$5"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|section
operator|->
name|alignment_power
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|section
operator|->
name|name
argument_list|,
literal|".idata$6"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|section
operator|->
name|alignment_power
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|section
operator|->
name|name
argument_list|,
literal|".reloc"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|section
operator|->
name|alignment_power
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|section
operator|->
name|name
argument_list|,
literal|".stab"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|section
operator|->
name|alignment_power
operator|=
literal|2
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|COFF_IMAGE_WITH_PE
comment|/* In a PE image file, the s_paddr field holds the virtual size of a      section, while the s_size field holds the raw size.  */
if|if
condition|(
name|hdr
operator|->
name|s_paddr
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|section
operator|->
name|used_by_bfd
operator|=
operator|(
name|PTR
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|coff_section_tdata
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|section
operator|->
name|used_by_bfd
operator|==
name|NULL
condition|)
block|{
comment|/* FIXME: Return error.  */
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pei_section_data
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
operator|->
name|tdata
operator|=
operator|(
name|PTR
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pei_section_tdata
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
operator|->
name|tdata
operator|==
name|NULL
condition|)
block|{
comment|/* FIXME: Return error.  */
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
name|pei_section_data
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
operator|->
name|virt_size
operator|=
name|hdr
operator|->
name|s_paddr
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_undef
undef|#
directive|undef
name|ALIGN_SET
end_undef

begin_undef
undef|#
directive|undef
name|ELIFALIGN_SET
end_undef

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! COFF_WITH_PE */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|RS6000COFF_C
end_ifdef

begin_comment
comment|/* We grossly abuse this function to handle XCOFF overflow headers.    When we see one, we correct the reloc and line number counts in the    real header, and remove the section we just created.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|coff_set_alignment_hook
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|coff_set_alignment_hook
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|scnhdr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|PTR
name|scnhdr
decl_stmt|;
block|{
name|struct
name|internal_scnhdr
modifier|*
name|hdr
init|=
operator|(
expr|struct
name|internal_scnhdr
operator|*
operator|)
name|scnhdr
decl_stmt|;
name|asection
modifier|*
name|real_sec
decl_stmt|;
name|asection
modifier|*
modifier|*
name|ps
decl_stmt|;
if|if
condition|(
operator|(
name|hdr
operator|->
name|s_flags
operator|&
name|STYP_OVRFLO
operator|)
operator|==
literal|0
condition|)
return|return;
name|real_sec
operator|=
name|coff_section_from_bfd_index
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|s_nreloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|real_sec
operator|==
name|NULL
condition|)
return|return;
name|real_sec
operator|->
name|reloc_count
operator|=
name|hdr
operator|->
name|s_paddr
expr_stmt|;
name|real_sec
operator|->
name|lineno_count
operator|=
name|hdr
operator|->
name|s_vaddr
expr_stmt|;
for|for
control|(
name|ps
operator|=
operator|&
name|abfd
operator|->
name|sections
init|;
operator|*
name|ps
operator|!=
name|NULL
condition|;
name|ps
operator|=
operator|&
operator|(
operator|*
name|ps
operator|)
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|*
name|ps
operator|==
name|section
condition|)
block|{
operator|*
name|ps
operator|=
operator|(
operator|*
name|ps
operator|)
operator|->
name|next
expr_stmt|;
operator|--
name|abfd
operator|->
name|section_count
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! RS6000COFF_C */
end_comment

begin_define
define|#
directive|define
name|coff_set_alignment_hook
define|\
value|((void (*) PARAMS ((bfd *, asection *, PTR))) bfd_void)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! RS6000COFF_C */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! COFF_WITH_PE */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! I960 */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|coff_mkobject
end_ifndef

begin_decl_stmt
specifier|static
name|boolean
name|coff_mkobject
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|boolean
name|coff_mkobject
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|coff_data_type
modifier|*
name|coff
decl_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|coff_obj_data
operator|=
operator|(
expr|struct
name|coff_tdata
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|coff_data_type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|tdata
operator|.
name|coff_obj_data
operator|==
literal|0
condition|)
return|return
name|false
return|;
name|coff
operator|=
name|coff_data
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|coff
operator|->
name|symbols
operator|=
operator|(
name|coff_symbol_type
operator|*
operator|)
name|NULL
expr_stmt|;
name|coff
operator|->
name|conversion_table
operator|=
operator|(
name|unsigned
name|int
operator|*
operator|)
name|NULL
expr_stmt|;
name|coff
operator|->
name|raw_syments
operator|=
operator|(
expr|struct
name|coff_ptr_struct
operator|*
operator|)
name|NULL
expr_stmt|;
name|coff
operator|->
name|relocbase
operator|=
literal|0
expr_stmt|;
name|coff
operator|->
name|local_toc_sym_map
operator|=
literal|0
expr_stmt|;
comment|/*  make_abs_section(abfd);*/
return|return
name|true
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Create the COFF backend specific information.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|coff_mkobject_hook
end_ifndef

begin_function
specifier|static
name|PTR
name|coff_mkobject_hook
parameter_list|(
name|abfd
parameter_list|,
name|filehdr
parameter_list|,
name|aouthdr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|filehdr
decl_stmt|;
name|PTR
name|aouthdr
decl_stmt|;
block|{
name|struct
name|internal_filehdr
modifier|*
name|internal_f
init|=
operator|(
expr|struct
name|internal_filehdr
operator|*
operator|)
name|filehdr
decl_stmt|;
name|coff_data_type
modifier|*
name|coff
decl_stmt|;
if|if
condition|(
name|coff_mkobject
argument_list|(
name|abfd
argument_list|)
operator|==
name|false
condition|)
return|return
name|NULL
return|;
name|coff
operator|=
name|coff_data
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|coff
operator|->
name|sym_filepos
operator|=
name|internal_f
operator|->
name|f_symptr
expr_stmt|;
comment|/* These members communicate important constants about the symbol      table to GDB's symbol-reading code.  These `constants'      unfortunately vary among coff implementations...  */
name|coff
operator|->
name|local_n_btmask
operator|=
name|N_BTMASK
expr_stmt|;
name|coff
operator|->
name|local_n_btshft
operator|=
name|N_BTSHFT
expr_stmt|;
name|coff
operator|->
name|local_n_tmask
operator|=
name|N_TMASK
expr_stmt|;
name|coff
operator|->
name|local_n_tshift
operator|=
name|N_TSHIFT
expr_stmt|;
name|coff
operator|->
name|local_symesz
operator|=
name|SYMESZ
expr_stmt|;
name|coff
operator|->
name|local_auxesz
operator|=
name|AUXESZ
expr_stmt|;
name|coff
operator|->
name|local_linesz
operator|=
name|LINESZ
expr_stmt|;
name|obj_raw_syment_count
argument_list|(
name|abfd
argument_list|)
operator|=
name|obj_conv_table_size
argument_list|(
name|abfd
argument_list|)
operator|=
name|internal_f
operator|->
name|f_nsyms
expr_stmt|;
ifdef|#
directive|ifdef
name|RS6000COFF_C
if|if
condition|(
operator|(
name|internal_f
operator|->
name|f_flags
operator|&
name|F_SHROBJ
operator|)
operator|!=
literal|0
condition|)
name|abfd
operator|->
name|flags
operator||=
name|DYNAMIC
expr_stmt|;
if|if
condition|(
name|aouthdr
operator|!=
name|NULL
operator|&&
name|internal_f
operator|->
name|f_opthdr
operator|>=
name|AOUTSZ
condition|)
block|{
name|struct
name|internal_aouthdr
modifier|*
name|internal_a
init|=
operator|(
expr|struct
name|internal_aouthdr
operator|*
operator|)
name|aouthdr
decl_stmt|;
name|struct
name|xcoff_tdata
modifier|*
name|xcoff
decl_stmt|;
name|xcoff
operator|=
name|xcoff_data
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|xcoff
operator|->
name|full_aouthdr
operator|=
name|true
expr_stmt|;
name|xcoff
operator|->
name|toc
operator|=
name|internal_a
operator|->
name|o_toc
expr_stmt|;
name|xcoff
operator|->
name|sntoc
operator|=
name|internal_a
operator|->
name|o_sntoc
expr_stmt|;
name|xcoff
operator|->
name|snentry
operator|=
name|internal_a
operator|->
name|o_snentry
expr_stmt|;
name|xcoff
operator|->
name|text_align_power
operator|=
name|internal_a
operator|->
name|o_algntext
expr_stmt|;
name|xcoff
operator|->
name|data_align_power
operator|=
name|internal_a
operator|->
name|o_algndata
expr_stmt|;
name|xcoff
operator|->
name|modtype
operator|=
name|internal_a
operator|->
name|o_modtype
expr_stmt|;
name|xcoff
operator|->
name|cputype
operator|=
name|internal_a
operator|->
name|o_cputype
expr_stmt|;
name|xcoff
operator|->
name|maxdata
operator|=
name|internal_a
operator|->
name|o_maxdata
expr_stmt|;
name|xcoff
operator|->
name|maxstack
operator|=
name|internal_a
operator|->
name|o_maxstack
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|PTR
operator|)
name|coff
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Determine the machine architecture and type.  FIXME: This is target    dependent because the magic numbers are defined in the target    dependent header files.  But there is no particular need for this.    If the magic numbers were moved to a separate file, this function    would be target independent and would also be much more successful    at linking together COFF files for different architectures.  */
end_comment

begin_function
specifier|static
name|boolean
name|coff_set_arch_mach_hook
parameter_list|(
name|abfd
parameter_list|,
name|filehdr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|filehdr
decl_stmt|;
block|{
name|long
name|machine
decl_stmt|;
name|enum
name|bfd_architecture
name|arch
decl_stmt|;
name|struct
name|internal_filehdr
modifier|*
name|internal_f
init|=
operator|(
expr|struct
name|internal_filehdr
operator|*
operator|)
name|filehdr
decl_stmt|;
name|machine
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|internal_f
operator|->
name|f_magic
condition|)
block|{
ifdef|#
directive|ifdef
name|PPCMAGIC
case|case
name|PPCMAGIC
case|:
name|arch
operator|=
name|bfd_arch_powerpc
expr_stmt|;
name|machine
operator|=
literal|0
expr_stmt|;
comment|/* what does this mean? (krk) */
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|I386MAGIC
case|case
name|I386MAGIC
case|:
case|case
name|I386PTXMAGIC
case|:
case|case
name|I386AIXMAGIC
case|:
comment|/* Danbury PS/2 AIX C Compiler */
case|case
name|LYNXCOFFMAGIC
case|:
comment|/* shadows the m68k Lynx number below, sigh */
name|arch
operator|=
name|bfd_arch_i386
expr_stmt|;
name|machine
operator|=
literal|0
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|A29K_MAGIC_BIG
case|case
name|A29K_MAGIC_BIG
case|:
case|case
name|A29K_MAGIC_LITTLE
case|:
name|arch
operator|=
name|bfd_arch_a29k
expr_stmt|;
name|machine
operator|=
literal|0
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARMMAGIC
case|case
name|ARMMAGIC
case|:
name|arch
operator|=
name|bfd_arch_arm
expr_stmt|;
name|machine
operator|=
literal|0
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MC68MAGIC
case|case
name|MC68MAGIC
case|:
case|case
name|M68MAGIC
case|:
ifdef|#
directive|ifdef
name|MC68KBCSMAGIC
case|case
name|MC68KBCSMAGIC
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|APOLLOM68KMAGIC
case|case
name|APOLLOM68KMAGIC
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LYNXCOFFMAGIC
case|case
name|LYNXCOFFMAGIC
case|:
endif|#
directive|endif
name|arch
operator|=
name|bfd_arch_m68k
expr_stmt|;
name|machine
operator|=
literal|68020
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MC88MAGIC
case|case
name|MC88MAGIC
case|:
case|case
name|MC88DMAGIC
case|:
case|case
name|MC88OMAGIC
case|:
name|arch
operator|=
name|bfd_arch_m88k
expr_stmt|;
name|machine
operator|=
literal|88100
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|Z8KMAGIC
case|case
name|Z8KMAGIC
case|:
name|arch
operator|=
name|bfd_arch_z8k
expr_stmt|;
switch|switch
condition|(
name|internal_f
operator|->
name|f_flags
operator|&
name|F_MACHMASK
condition|)
block|{
case|case
name|F_Z8001
case|:
name|machine
operator|=
name|bfd_mach_z8001
expr_stmt|;
break|break;
case|case
name|F_Z8002
case|:
name|machine
operator|=
name|bfd_mach_z8002
expr_stmt|;
break|break;
default|default:
return|return
name|false
return|;
block|}
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|I860
case|case
name|I860MAGIC
case|:
name|arch
operator|=
name|bfd_arch_i860
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|I960
ifdef|#
directive|ifdef
name|I960ROMAGIC
case|case
name|I960ROMAGIC
case|:
case|case
name|I960RWMAGIC
case|:
name|arch
operator|=
name|bfd_arch_i960
expr_stmt|;
switch|switch
condition|(
name|F_I960TYPE
operator|&
name|internal_f
operator|->
name|f_flags
condition|)
block|{
default|default:
case|case
name|F_I960CORE
case|:
name|machine
operator|=
name|bfd_mach_i960_core
expr_stmt|;
break|break;
case|case
name|F_I960KB
case|:
name|machine
operator|=
name|bfd_mach_i960_kb_sb
expr_stmt|;
break|break;
case|case
name|F_I960MC
case|:
name|machine
operator|=
name|bfd_mach_i960_mc
expr_stmt|;
break|break;
case|case
name|F_I960XA
case|:
name|machine
operator|=
name|bfd_mach_i960_xa
expr_stmt|;
break|break;
case|case
name|F_I960CA
case|:
name|machine
operator|=
name|bfd_mach_i960_ca
expr_stmt|;
break|break;
case|case
name|F_I960KA
case|:
name|machine
operator|=
name|bfd_mach_i960_ka_sa
expr_stmt|;
break|break;
case|case
name|F_I960JX
case|:
name|machine
operator|=
name|bfd_mach_i960_jx
expr_stmt|;
break|break;
case|case
name|F_I960HX
case|:
name|machine
operator|=
name|bfd_mach_i960_hx
expr_stmt|;
break|break;
block|}
break|break;
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RS6000COFF_C
case|case
name|U802ROMAGIC
case|:
case|case
name|U802WRMAGIC
case|:
case|case
name|U802TOCMAGIC
case|:
block|{
name|int
name|cputype
decl_stmt|;
if|if
condition|(
name|xcoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|cputype
operator|!=
operator|-
literal|1
condition|)
name|cputype
operator|=
name|xcoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|cputype
operator|&
literal|0xff
expr_stmt|;
else|else
block|{
comment|/* We did not get a value from the a.out header.  If the 	       file has not been stripped, we may be able to get the 	       architecture information from the first symbol, if it 	       is a .file symbol.  */
if|if
condition|(
name|obj_raw_syment_count
argument_list|(
name|abfd
argument_list|)
operator|==
literal|0
condition|)
name|cputype
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|bfd_byte
name|buf
index|[
name|SYMESZ
index|]
decl_stmt|;
name|struct
name|internal_syment
name|sym
decl_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|obj_sym_filepos
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_read
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|SYMESZ
argument_list|,
name|abfd
argument_list|)
operator|!=
name|SYMESZ
condition|)
return|return
name|false
return|;
name|coff_swap_sym_in
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|buf
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|.
name|n_sclass
operator|==
name|C_FILE
condition|)
name|cputype
operator|=
name|sym
operator|.
name|n_type
operator|&
literal|0xff
expr_stmt|;
else|else
name|cputype
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* FIXME: We don't handle all cases here.  */
switch|switch
condition|(
name|cputype
condition|)
block|{
default|default:
case|case
literal|0
case|:
ifdef|#
directive|ifdef
name|POWERMAC
comment|/* PowerPC Macs use the same magic numbers as RS/6000 	       (because that's how they were bootstrapped originally), 	       but they are always PowerPC architecture.  */
name|arch
operator|=
name|bfd_arch_powerpc
expr_stmt|;
name|machine
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|arch
operator|=
name|bfd_arch_rs6000
expr_stmt|;
name|machine
operator|=
literal|6000
expr_stmt|;
endif|#
directive|endif
comment|/* POWERMAC */
break|break;
case|case
literal|1
case|:
name|arch
operator|=
name|bfd_arch_powerpc
expr_stmt|;
name|machine
operator|=
literal|601
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* 64 bit PowerPC */
name|arch
operator|=
name|bfd_arch_powerpc
expr_stmt|;
name|machine
operator|=
literal|620
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|arch
operator|=
name|bfd_arch_powerpc
expr_stmt|;
name|machine
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|arch
operator|=
name|bfd_arch_rs6000
expr_stmt|;
name|machine
operator|=
literal|6000
expr_stmt|;
break|break;
block|}
block|}
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|WE32KMAGIC
case|case
name|WE32KMAGIC
case|:
name|arch
operator|=
name|bfd_arch_we32k
expr_stmt|;
name|machine
operator|=
literal|0
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|H8300MAGIC
case|case
name|H8300MAGIC
case|:
name|arch
operator|=
name|bfd_arch_h8300
expr_stmt|;
name|machine
operator|=
name|bfd_mach_h8300
expr_stmt|;
comment|/* !! FIXME this probably isn't the right place for this */
name|abfd
operator|->
name|flags
operator||=
name|BFD_IS_RELAXABLE
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|H8300HMAGIC
case|case
name|H8300HMAGIC
case|:
name|arch
operator|=
name|bfd_arch_h8300
expr_stmt|;
name|machine
operator|=
name|bfd_mach_h8300h
expr_stmt|;
comment|/* !! FIXME this probably isn't the right place for this */
name|abfd
operator|->
name|flags
operator||=
name|BFD_IS_RELAXABLE
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|H8300SMAGIC
case|case
name|H8300SMAGIC
case|:
name|arch
operator|=
name|bfd_arch_h8300
expr_stmt|;
name|machine
operator|=
name|bfd_mach_h8300s
expr_stmt|;
comment|/* !! FIXME this probably isn't the right place for this */
name|abfd
operator|->
name|flags
operator||=
name|BFD_IS_RELAXABLE
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SH_ARCH_MAGIC_BIG
case|case
name|SH_ARCH_MAGIC_BIG
case|:
case|case
name|SH_ARCH_MAGIC_LITTLE
case|:
name|arch
operator|=
name|bfd_arch_sh
expr_stmt|;
name|machine
operator|=
literal|0
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|H8500MAGIC
case|case
name|H8500MAGIC
case|:
name|arch
operator|=
name|bfd_arch_h8500
expr_stmt|;
name|machine
operator|=
literal|0
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SPARCMAGIC
case|case
name|SPARCMAGIC
case|:
ifdef|#
directive|ifdef
name|LYNXCOFFMAGIC
case|case
name|LYNXCOFFMAGIC
case|:
endif|#
directive|endif
name|arch
operator|=
name|bfd_arch_sparc
expr_stmt|;
name|machine
operator|=
literal|0
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TIC80_ARCH_MAGIC
case|case
name|TIC80_ARCH_MAGIC
case|:
name|arch
operator|=
name|bfd_arch_tic80
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
comment|/* Unreadable input file type */
name|arch
operator|=
name|bfd_arch_obscure
expr_stmt|;
break|break;
block|}
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|arch
argument_list|,
name|machine
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SYMNAME_IN_DEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|boolean
name|symname_in_debug_hook
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|internal_syment
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|boolean
name|symname_in_debug_hook
parameter_list|(
name|abfd
parameter_list|,
name|sym
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|internal_syment
modifier|*
name|sym
decl_stmt|;
block|{
return|return
name|SYMNAME_IN_DEBUG
argument_list|(
name|sym
argument_list|)
condition|?
name|true
else|:
name|false
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|symname_in_debug_hook
define|\
value|(boolean (*) PARAMS ((bfd *, struct internal_syment *))) bfd_false
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|RS6000COFF_C
end_ifdef

begin_comment
comment|/* Handle the csect auxent of a C_EXT or C_HIDEXT symbol.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|coff_pointerize_aux_hook
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|combined_entry_type
operator|*
operator|,
name|combined_entry_type
operator|*
operator|,
name|unsigned
name|int
operator|,
name|combined_entry_type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|boolean
name|coff_pointerize_aux_hook
parameter_list|(
name|abfd
parameter_list|,
name|table_base
parameter_list|,
name|symbol
parameter_list|,
name|indaux
parameter_list|,
name|aux
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|combined_entry_type
modifier|*
name|table_base
decl_stmt|;
name|combined_entry_type
modifier|*
name|symbol
decl_stmt|;
name|unsigned
name|int
name|indaux
decl_stmt|;
name|combined_entry_type
modifier|*
name|aux
decl_stmt|;
block|{
name|int
name|class
init|=
name|symbol
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
decl_stmt|;
if|if
condition|(
operator|(
name|class
operator|==
name|C_EXT
operator|||
name|class
operator|==
name|C_HIDEXT
operator|)
operator|&&
name|indaux
operator|+
literal|1
operator|==
name|symbol
operator|->
name|u
operator|.
name|syment
operator|.
name|n_numaux
condition|)
block|{
if|if
condition|(
name|SMTYP_SMTYP
argument_list|(
name|aux
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_csect
operator|.
name|x_smtyp
argument_list|)
operator|==
name|XTY_LD
condition|)
block|{
name|aux
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_csect
operator|.
name|x_scnlen
operator|.
name|p
operator|=
name|table_base
operator|+
name|aux
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_csect
operator|.
name|x_scnlen
operator|.
name|l
expr_stmt|;
name|aux
operator|->
name|fix_scnlen
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Return true to indicate that the caller should not do any          further work on this auxent.  */
return|return
name|true
return|;
block|}
comment|/* Return false to indicate that this auxent should be handled by      the caller.  */
return|return
name|false
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|I960
end_ifdef

begin_comment
comment|/* We don't want to pointerize bal entries.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|coff_pointerize_aux_hook
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|combined_entry_type
operator|*
operator|,
name|combined_entry_type
operator|*
operator|,
name|unsigned
name|int
operator|,
name|combined_entry_type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|boolean
name|coff_pointerize_aux_hook
parameter_list|(
name|abfd
parameter_list|,
name|table_base
parameter_list|,
name|symbol
parameter_list|,
name|indaux
parameter_list|,
name|aux
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|combined_entry_type
modifier|*
name|table_base
decl_stmt|;
name|combined_entry_type
modifier|*
name|symbol
decl_stmt|;
name|unsigned
name|int
name|indaux
decl_stmt|;
name|combined_entry_type
modifier|*
name|aux
decl_stmt|;
block|{
comment|/* Return true if we don't want to pointerize this aux entry, which      is the case for the lastfirst aux entry for a C_LEAFPROC symbol.  */
return|return
operator|(
name|indaux
operator|==
literal|1
operator|&&
operator|(
name|symbol
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
operator|==
name|C_LEAFPROC
operator|||
name|symbol
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
operator|==
name|C_LEAFSTAT
operator|||
name|symbol
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
operator|==
name|C_LEAFEXT
operator|)
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! I960 */
end_comment

begin_define
define|#
directive|define
name|coff_pointerize_aux_hook
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! I960 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! RS6000COFF_C */
end_comment

begin_comment
comment|/* Print an aux entry.  This returns true if it has printed it.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|coff_print_aux
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|FILE
operator|*
operator|,
name|combined_entry_type
operator|*
operator|,
name|combined_entry_type
operator|*
operator|,
name|combined_entry_type
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|boolean
name|coff_print_aux
parameter_list|(
name|abfd
parameter_list|,
name|file
parameter_list|,
name|table_base
parameter_list|,
name|symbol
parameter_list|,
name|aux
parameter_list|,
name|indaux
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
name|combined_entry_type
modifier|*
name|table_base
decl_stmt|;
name|combined_entry_type
modifier|*
name|symbol
decl_stmt|;
name|combined_entry_type
modifier|*
name|aux
decl_stmt|;
name|unsigned
name|int
name|indaux
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|RS6000COFF_C
if|if
condition|(
operator|(
name|symbol
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
operator|==
name|C_EXT
operator|||
name|symbol
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
operator|==
name|C_HIDEXT
operator|)
operator|&&
name|indaux
operator|+
literal|1
operator|==
name|symbol
operator|->
name|u
operator|.
name|syment
operator|.
name|n_numaux
condition|)
block|{
comment|/* This is a csect entry.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"AUX "
argument_list|)
expr_stmt|;
if|if
condition|(
name|SMTYP_SMTYP
argument_list|(
name|aux
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_csect
operator|.
name|x_smtyp
argument_list|)
operator|!=
name|XTY_LD
condition|)
block|{
name|BFD_ASSERT
argument_list|(
operator|!
name|aux
operator|->
name|fix_scnlen
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"val %5ld"
argument_list|,
name|aux
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_csect
operator|.
name|x_scnlen
operator|.
name|l
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"indx "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|aux
operator|->
name|fix_scnlen
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%4ld"
argument_list|,
name|aux
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_csect
operator|.
name|x_scnlen
operator|.
name|l
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%4ld"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|aux
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_csect
operator|.
name|x_scnlen
operator|.
name|p
operator|-
name|table_base
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" prmhsh %ld snhsh %u typ %d algn %d clss %u stb %ld snstb %u"
argument_list|,
name|aux
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_csect
operator|.
name|x_parmhash
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|aux
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_csect
operator|.
name|x_snhash
argument_list|,
name|SMTYP_SMTYP
argument_list|(
name|aux
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_csect
operator|.
name|x_smtyp
argument_list|)
argument_list|,
name|SMTYP_ALIGN
argument_list|(
name|aux
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_csect
operator|.
name|x_smtyp
argument_list|)
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|aux
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_csect
operator|.
name|x_smclas
argument_list|,
name|aux
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_csect
operator|.
name|x_stab
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|aux
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_csect
operator|.
name|x_snstab
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
endif|#
directive|endif
comment|/* Return false to indicate that no special action was taken.  */
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* SUBSUBSECTION 	Writing relocations  	To write relocations, the back end steps though the 	canonical relocation table and create an 	@code{internal_reloc}. The symbol index to use is removed from 	the @code{offset} field in the symbol table supplied.  The 	address comes directly from the sum of the section base 	address and the relocation offset; the type is dug directly 	from the howto field.  Then the @code{internal_reloc} is 	swapped into the shape of an @code{external_reloc} and written 	out to disk.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TARG_AUX
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|compare_arelent_ptr
name|PARAMS
argument_list|(
operator|(
specifier|const
name|PTR
operator|,
specifier|const
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* AUX's ld wants relocations to be sorted */
end_comment

begin_function
specifier|static
name|int
name|compare_arelent_ptr
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
specifier|const
name|PTR
name|x
decl_stmt|;
specifier|const
name|PTR
name|y
decl_stmt|;
block|{
specifier|const
name|arelent
modifier|*
modifier|*
name|a
init|=
operator|(
specifier|const
name|arelent
operator|*
operator|*
operator|)
name|x
decl_stmt|;
specifier|const
name|arelent
modifier|*
modifier|*
name|b
init|=
operator|(
specifier|const
name|arelent
operator|*
operator|*
operator|)
name|y
decl_stmt|;
name|bfd_size_type
name|aadr
init|=
operator|(
operator|*
name|a
operator|)
operator|->
name|address
decl_stmt|;
name|bfd_size_type
name|badr
init|=
operator|(
operator|*
name|b
operator|)
operator|->
name|address
decl_stmt|;
return|return
operator|(
name|aadr
operator|<
name|badr
condition|?
operator|-
literal|1
else|:
name|badr
operator|<
name|aadr
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TARG_AUX */
end_comment

begin_function
specifier|static
name|boolean
name|coff_write_relocs
parameter_list|(
name|abfd
parameter_list|,
name|first_undef
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|int
name|first_undef
decl_stmt|;
block|{
name|asection
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|external_reloc
name|dst
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|p
decl_stmt|;
ifndef|#
directive|ifndef
name|TARG_AUX
name|p
operator|=
name|s
operator|->
name|orelocation
expr_stmt|;
else|#
directive|else
comment|/* sort relocations before we write them out */
name|p
operator|=
operator|(
name|arelent
operator|*
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|s
operator|->
name|reloc_count
operator|*
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|&&
name|s
operator|->
name|reloc_count
operator|>
literal|0
condition|)
return|return
name|false
return|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|s
operator|->
name|orelocation
argument_list|,
name|s
operator|->
name|reloc_count
operator|*
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|p
argument_list|,
name|s
operator|->
name|reloc_count
argument_list|,
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
argument_list|,
name|compare_arelent_ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|s
operator|->
name|rel_filepos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|s
operator|->
name|reloc_count
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|internal_reloc
name|n
decl_stmt|;
name|arelent
modifier|*
name|q
init|=
name|p
index|[
name|i
index|]
decl_stmt|;
name|memset
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|n
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now we've renumbered the symbols we know where the 	     undefined symbols live in the table.  Check the reloc 	     entries for symbols who's output bfd isn't the right one. 	     This is because the symbol was undefined (which means 	     that all the pointers are never made to point to the same 	     place). This is a bad thing,'cause the symbols attached 	     to the output bfd are indexed, so that the relocation 	     entries know which symbol index they point to.  So we 	     have to look up the output symbol here. */
if|if
condition|(
name|q
operator|->
name|sym_ptr_ptr
index|[
literal|0
index|]
operator|->
name|the_bfd
operator|!=
name|abfd
condition|)
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|sname
init|=
name|q
operator|->
name|sym_ptr_ptr
index|[
literal|0
index|]
operator|->
name|name
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|outsyms
init|=
name|abfd
operator|->
name|outsymbols
decl_stmt|;
for|for
control|(
name|i
operator|=
name|first_undef
init|;
name|outsyms
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|intable
init|=
name|outsyms
index|[
name|i
index|]
operator|->
name|name
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|intable
argument_list|,
name|sname
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* got a hit, so repoint the reloc */
name|q
operator|->
name|sym_ptr_ptr
operator|=
name|outsyms
operator|+
name|i
expr_stmt|;
break|break;
block|}
block|}
block|}
name|n
operator|.
name|r_vaddr
operator|=
name|q
operator|->
name|address
operator|+
name|s
operator|->
name|vma
expr_stmt|;
ifdef|#
directive|ifdef
name|R_IHCONST
comment|/* The 29k const/consth reloc pair is a real kludge.  The consth 	     part doesn't have a symbol; it has an offset.  So rebuilt 	     that here.  */
if|if
condition|(
name|q
operator|->
name|howto
operator|->
name|type
operator|==
name|R_IHCONST
condition|)
name|n
operator|.
name|r_symndx
operator|=
name|q
operator|->
name|addend
expr_stmt|;
elseif|else
endif|#
directive|endif
if|if
condition|(
name|q
operator|->
name|sym_ptr_ptr
condition|)
block|{
if|if
condition|(
name|q
operator|->
name|sym_ptr_ptr
operator|==
name|bfd_abs_section_ptr
operator|->
name|symbol_ptr_ptr
condition|)
comment|/* This is a relocation relative to the absolute symbol.  */
name|n
operator|.
name|r_symndx
operator|=
operator|-
literal|1
expr_stmt|;
else|else
block|{
name|n
operator|.
name|r_symndx
operator|=
name|get_index
argument_list|(
operator|(
operator|*
operator|(
name|q
operator|->
name|sym_ptr_ptr
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Take notice if the symbol reloc points to a symbol 		       we don't have in our symbol table.  What should we 		       do for this??  */
if|if
condition|(
name|n
operator|.
name|r_symndx
operator|>
name|obj_conv_table_size
argument_list|(
name|abfd
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|SWAP_OUT_RELOC_OFFSET
name|n
operator|.
name|r_offset
operator|=
name|q
operator|->
name|addend
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SELECT_RELOC
comment|/* Work out reloc type from what is required */
name|SELECT_RELOC
argument_list|(
name|n
argument_list|,
name|q
operator|->
name|howto
argument_list|)
expr_stmt|;
else|#
directive|else
name|n
operator|.
name|r_type
operator|=
name|q
operator|->
name|howto
operator|->
name|type
expr_stmt|;
endif|#
directive|endif
name|coff_swap_reloc_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|n
argument_list|,
operator|&
name|dst
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|dst
argument_list|,
literal|1
argument_list|,
name|RELSZ
argument_list|,
name|abfd
argument_list|)
operator|!=
name|RELSZ
condition|)
return|return
name|false
return|;
block|}
ifdef|#
directive|ifdef
name|TARG_AUX
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Set flags and magic number of a coff file from architecture and machine    type.  Result is true if we can represent the arch&type, false if not.  */
end_comment

begin_function
specifier|static
name|boolean
name|coff_set_flags
parameter_list|(
name|abfd
parameter_list|,
name|magicp
parameter_list|,
name|flagsp
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|unsigned
name|int
modifier|*
name|magicp
decl_stmt|;
name|unsigned
name|short
modifier|*
name|flagsp
decl_stmt|;
block|{
switch|switch
condition|(
name|bfd_get_arch
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|Z8KMAGIC
case|case
name|bfd_arch_z8k
case|:
operator|*
name|magicp
operator|=
name|Z8KMAGIC
expr_stmt|;
switch|switch
condition|(
name|bfd_get_mach
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
case|case
name|bfd_mach_z8001
case|:
operator|*
name|flagsp
operator|=
name|F_Z8001
expr_stmt|;
break|break;
case|case
name|bfd_mach_z8002
case|:
operator|*
name|flagsp
operator|=
name|F_Z8002
expr_stmt|;
break|break;
default|default:
return|return
name|false
return|;
block|}
return|return
name|true
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|I960ROMAGIC
case|case
name|bfd_arch_i960
case|:
block|{
name|unsigned
name|flags
decl_stmt|;
operator|*
name|magicp
operator|=
name|I960ROMAGIC
expr_stmt|;
comment|/* 	  ((bfd_get_file_flags(abfd)& WP_TEXT) ? I960ROMAGIC : 	  I960RWMAGIC);   FIXME??? 	  */
switch|switch
condition|(
name|bfd_get_mach
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
case|case
name|bfd_mach_i960_core
case|:
name|flags
operator|=
name|F_I960CORE
expr_stmt|;
break|break;
case|case
name|bfd_mach_i960_kb_sb
case|:
name|flags
operator|=
name|F_I960KB
expr_stmt|;
break|break;
case|case
name|bfd_mach_i960_mc
case|:
name|flags
operator|=
name|F_I960MC
expr_stmt|;
break|break;
case|case
name|bfd_mach_i960_xa
case|:
name|flags
operator|=
name|F_I960XA
expr_stmt|;
break|break;
case|case
name|bfd_mach_i960_ca
case|:
name|flags
operator|=
name|F_I960CA
expr_stmt|;
break|break;
case|case
name|bfd_mach_i960_ka_sa
case|:
name|flags
operator|=
name|F_I960KA
expr_stmt|;
break|break;
case|case
name|bfd_mach_i960_jx
case|:
name|flags
operator|=
name|F_I960JX
expr_stmt|;
break|break;
case|case
name|bfd_mach_i960_hx
case|:
name|flags
operator|=
name|F_I960HX
expr_stmt|;
break|break;
default|default:
return|return
name|false
return|;
block|}
operator|*
name|flagsp
operator|=
name|flags
expr_stmt|;
return|return
name|true
return|;
block|}
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARMMAGIC
case|case
name|bfd_arch_arm
case|:
operator|*
name|magicp
operator|=
name|ARMMAGIC
expr_stmt|;
return|return
name|true
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PPCMAGIC
case|case
name|bfd_arch_powerpc
case|:
operator|*
name|magicp
operator|=
name|PPCMAGIC
expr_stmt|;
return|return
name|true
return|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|I386MAGIC
case|case
name|bfd_arch_i386
case|:
operator|*
name|magicp
operator|=
name|I386MAGIC
expr_stmt|;
ifdef|#
directive|ifdef
name|LYNXOS
comment|/* Just overwrite the usual value if we're doing Lynx. */
operator|*
name|magicp
operator|=
name|LYNXCOFFMAGIC
expr_stmt|;
endif|#
directive|endif
return|return
name|true
return|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|I860MAGIC
case|case
name|bfd_arch_i860
case|:
operator|*
name|magicp
operator|=
name|I860MAGIC
expr_stmt|;
return|return
name|true
return|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MC68MAGIC
case|case
name|bfd_arch_m68k
case|:
ifdef|#
directive|ifdef
name|APOLLOM68KMAGIC
operator|*
name|magicp
operator|=
name|APOLLO_COFF_VERSION_NUMBER
expr_stmt|;
else|#
directive|else
comment|/* NAMES_HAVE_UNDERSCORE may be defined by coff-u68k.c.  */
ifdef|#
directive|ifdef
name|NAMES_HAVE_UNDERSCORE
operator|*
name|magicp
operator|=
name|MC68KBCSMAGIC
expr_stmt|;
else|#
directive|else
operator|*
name|magicp
operator|=
name|MC68MAGIC
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LYNXOS
comment|/* Just overwrite the usual value if we're doing Lynx. */
operator|*
name|magicp
operator|=
name|LYNXCOFFMAGIC
expr_stmt|;
endif|#
directive|endif
return|return
name|true
return|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MC88MAGIC
case|case
name|bfd_arch_m88k
case|:
operator|*
name|magicp
operator|=
name|MC88OMAGIC
expr_stmt|;
return|return
name|true
return|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|H8300MAGIC
case|case
name|bfd_arch_h8300
case|:
switch|switch
condition|(
name|bfd_get_mach
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
case|case
name|bfd_mach_h8300
case|:
operator|*
name|magicp
operator|=
name|H8300MAGIC
expr_stmt|;
return|return
name|true
return|;
case|case
name|bfd_mach_h8300h
case|:
operator|*
name|magicp
operator|=
name|H8300HMAGIC
expr_stmt|;
return|return
name|true
return|;
case|case
name|bfd_mach_h8300s
case|:
operator|*
name|magicp
operator|=
name|H8300SMAGIC
expr_stmt|;
return|return
name|true
return|;
block|}
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SH_ARCH_MAGIC_BIG
case|case
name|bfd_arch_sh
case|:
if|if
condition|(
name|bfd_big_endian
argument_list|(
name|abfd
argument_list|)
condition|)
operator|*
name|magicp
operator|=
name|SH_ARCH_MAGIC_BIG
expr_stmt|;
else|else
operator|*
name|magicp
operator|=
name|SH_ARCH_MAGIC_LITTLE
expr_stmt|;
return|return
name|true
return|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SPARCMAGIC
case|case
name|bfd_arch_sparc
case|:
operator|*
name|magicp
operator|=
name|SPARCMAGIC
expr_stmt|;
ifdef|#
directive|ifdef
name|LYNXOS
comment|/* Just overwrite the usual value if we're doing Lynx. */
operator|*
name|magicp
operator|=
name|LYNXCOFFMAGIC
expr_stmt|;
endif|#
directive|endif
return|return
name|true
return|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|H8500MAGIC
case|case
name|bfd_arch_h8500
case|:
operator|*
name|magicp
operator|=
name|H8500MAGIC
expr_stmt|;
return|return
name|true
return|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|A29K_MAGIC_BIG
case|case
name|bfd_arch_a29k
case|:
if|if
condition|(
name|bfd_big_endian
argument_list|(
name|abfd
argument_list|)
condition|)
operator|*
name|magicp
operator|=
name|A29K_MAGIC_BIG
expr_stmt|;
else|else
operator|*
name|magicp
operator|=
name|A29K_MAGIC_LITTLE
expr_stmt|;
return|return
name|true
return|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|WE32KMAGIC
case|case
name|bfd_arch_we32k
case|:
operator|*
name|magicp
operator|=
name|WE32KMAGIC
expr_stmt|;
return|return
name|true
return|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|U802TOCMAGIC
case|case
name|bfd_arch_rs6000
case|:
ifndef|#
directive|ifndef
name|PPCMAGIC
case|case
name|bfd_arch_powerpc
case|:
endif|#
directive|endif
operator|*
name|magicp
operator|=
name|U802TOCMAGIC
expr_stmt|;
return|return
name|true
return|;
break|break;
endif|#
directive|endif
default|default:
comment|/* Unknown architecture */
comment|/* return false;  -- fall through to "return false" below, to avoid        "statement never reached" errors on the one below. */
break|break;
block|}
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|coff_set_arch_mach
parameter_list|(
name|abfd
parameter_list|,
name|arch
parameter_list|,
name|machine
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|enum
name|bfd_architecture
name|arch
decl_stmt|;
name|unsigned
name|long
name|machine
decl_stmt|;
block|{
name|unsigned
name|dummy1
decl_stmt|;
name|unsigned
name|short
name|dummy2
decl_stmt|;
if|if
condition|(
operator|!
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|arch
argument_list|,
name|machine
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|arch
operator|!=
name|bfd_arch_unknown
operator|&&
name|coff_set_flags
argument_list|(
name|abfd
argument_list|,
operator|&
name|dummy1
argument_list|,
operator|&
name|dummy2
argument_list|)
operator|!=
name|true
condition|)
return|return
name|false
return|;
comment|/* We can't represent this type */
return|return
name|true
return|;
comment|/* We're easy ... */
block|}
end_function

begin_comment
comment|/* Calculate the file position for each section. */
end_comment

begin_function
specifier|static
name|boolean
name|coff_compute_section_file_positions
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|asection
modifier|*
name|current
decl_stmt|;
name|asection
modifier|*
name|previous
init|=
operator|(
name|asection
operator|*
operator|)
name|NULL
decl_stmt|;
name|file_ptr
name|sofar
init|=
name|FILHSZ
decl_stmt|;
name|boolean
name|align_adjust
decl_stmt|;
ifndef|#
directive|ifndef
name|I960
name|file_ptr
name|old_sofar
decl_stmt|;
endif|#
directive|endif
name|unsigned
name|int
name|count
decl_stmt|;
ifdef|#
directive|ifdef
name|RS6000COFF_C
comment|/* On XCOFF, if we have symbols, set up the .debug section.  */
if|if
condition|(
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|>
literal|0
condition|)
block|{
name|bfd_size_type
name|sz
decl_stmt|;
name|bfd_size_type
name|i
decl_stmt|,
name|symcount
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symp
decl_stmt|;
name|sz
operator|=
literal|0
expr_stmt|;
name|symcount
operator|=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
for|for
control|(
name|symp
operator|=
name|abfd
operator|->
name|outsymbols
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|symcount
condition|;
name|symp
operator|++
operator|,
name|i
operator|++
control|)
block|{
name|coff_symbol_type
modifier|*
name|cf
decl_stmt|;
name|cf
operator|=
name|coff_symbol_from
argument_list|(
name|abfd
argument_list|,
operator|*
name|symp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cf
operator|!=
name|NULL
operator|&&
name|cf
operator|->
name|native
operator|!=
name|NULL
operator|&&
name|SYMNAME_IN_DEBUG
argument_list|(
operator|&
name|cf
operator|->
name|native
operator|->
name|u
operator|.
name|syment
argument_list|)
condition|)
block|{
name|size_t
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|bfd_asymbol_name
argument_list|(
operator|*
name|symp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|SYMNMLEN
condition|)
name|sz
operator|+=
name|len
operator|+
literal|3
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sz
operator|>
literal|0
condition|)
block|{
name|asection
modifier|*
name|dsec
decl_stmt|;
name|dsec
operator|=
name|bfd_make_section_old_way
argument_list|(
name|abfd
argument_list|,
literal|".debug"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsec
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|dsec
operator|->
name|_raw_size
operator|=
name|sz
expr_stmt|;
name|dsec
operator|->
name|flags
operator||=
name|SEC_HAS_CONTENTS
expr_stmt|;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|COFF_IMAGE_WITH_PE
name|int
name|page_size
decl_stmt|;
if|if
condition|(
name|coff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|link_info
condition|)
block|{
name|page_size
operator|=
name|pe_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|pe_opthdr
operator|.
name|FileAlignment
expr_stmt|;
block|}
else|else
name|page_size
operator|=
name|PE_DEF_FILE_ALIGNMENT
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|COFF_PAGE_SIZE
name|int
name|page_size
init|=
name|COFF_PAGE_SIZE
decl_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|bfd_get_start_address
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
comment|/*  A start address may have been added to the original file. In this 	  case it will need an optional header to record it.  */
name|abfd
operator|->
name|flags
operator||=
name|EXEC_P
expr_stmt|;
block|}
if|if
condition|(
name|abfd
operator|->
name|flags
operator|&
name|EXEC_P
condition|)
name|sofar
operator|+=
name|AOUTSZ
expr_stmt|;
ifdef|#
directive|ifdef
name|RS6000COFF_C
elseif|else
if|if
condition|(
name|xcoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|full_aouthdr
condition|)
name|sofar
operator|+=
name|AOUTSZ
expr_stmt|;
else|else
name|sofar
operator|+=
name|SMALL_AOUTSZ
expr_stmt|;
endif|#
directive|endif
name|sofar
operator|+=
name|abfd
operator|->
name|section_count
operator|*
name|SCNHSZ
expr_stmt|;
ifdef|#
directive|ifdef
name|RS6000COFF_C
comment|/* XCOFF handles overflows in the reloc and line number count fields      by allocating a new section header to hold the correct counts.  */
for|for
control|(
name|current
operator|=
name|abfd
operator|->
name|sections
init|;
name|current
operator|!=
name|NULL
condition|;
name|current
operator|=
name|current
operator|->
name|next
control|)
if|if
condition|(
name|current
operator|->
name|reloc_count
operator|>=
literal|0xffff
operator|||
name|current
operator|->
name|lineno_count
operator|>=
literal|0xffff
condition|)
name|sofar
operator|+=
name|SCNHSZ
expr_stmt|;
endif|#
directive|endif
name|align_adjust
operator|=
name|false
expr_stmt|;
for|for
control|(
name|current
operator|=
name|abfd
operator|->
name|sections
operator|,
name|count
operator|=
literal|1
init|;
name|current
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|;
name|current
operator|=
name|current
operator|->
name|next
operator|,
operator|++
name|count
control|)
block|{
name|current
operator|->
name|target_index
operator|=
name|count
expr_stmt|;
comment|/* Only deal with sections which have contents */
if|if
condition|(
operator|!
operator|(
name|current
operator|->
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
condition|)
continue|continue;
comment|/* Align the sections in the file to the same boundary on 	 which they are aligned in virtual memory.  I960 doesn't 	 do this (FIXME) so we can stay in sync with Intel.  960 	 doesn't yet page from files... */
ifndef|#
directive|ifndef
name|I960
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|EXEC_P
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* make sure this section is aligned on the right boundary - by 	     padding the previous section up if necessary */
name|old_sofar
operator|=
name|sofar
expr_stmt|;
name|sofar
operator|=
name|BFD_ALIGN
argument_list|(
name|sofar
argument_list|,
literal|1
operator|<<
name|current
operator|->
name|alignment_power
argument_list|)
expr_stmt|;
if|if
condition|(
name|previous
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
block|{
name|previous
operator|->
name|_raw_size
operator|+=
name|sofar
operator|-
name|old_sofar
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* In demand paged files the low order bits of the file offset 	 must match the low order bits of the virtual address.  */
ifdef|#
directive|ifdef
name|COFF_PAGE_SIZE
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|D_PAGED
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|current
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
name|sofar
operator|+=
operator|(
name|current
operator|->
name|vma
operator|-
name|sofar
operator|)
operator|%
name|page_size
expr_stmt|;
endif|#
directive|endif
name|current
operator|->
name|filepos
operator|=
name|sofar
expr_stmt|;
ifdef|#
directive|ifdef
name|COFF_IMAGE_WITH_PE
comment|/* With PE we have to pad each section to be a multiple of its 	 page size too, and remember both sizes.  */
if|if
condition|(
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|current
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|current
operator|->
name|used_by_bfd
operator|=
operator|(
name|PTR
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|coff_section_tdata
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|->
name|used_by_bfd
operator|==
name|NULL
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|pei_section_data
argument_list|(
name|abfd
argument_list|,
name|current
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|current
argument_list|)
operator|->
name|tdata
operator|=
operator|(
name|PTR
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pei_section_tdata
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|current
argument_list|)
operator|->
name|tdata
operator|==
name|NULL
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|pei_section_data
argument_list|(
name|abfd
argument_list|,
name|current
argument_list|)
operator|->
name|virt_size
operator|==
literal|0
condition|)
name|pei_section_data
argument_list|(
name|abfd
argument_list|,
name|current
argument_list|)
operator|->
name|virt_size
operator|=
name|current
operator|->
name|_raw_size
expr_stmt|;
name|current
operator|->
name|_raw_size
operator|=
operator|(
name|current
operator|->
name|_raw_size
operator|+
name|page_size
operator|-
literal|1
operator|)
operator|&
operator|-
name|page_size
expr_stmt|;
endif|#
directive|endif
name|sofar
operator|+=
name|current
operator|->
name|_raw_size
expr_stmt|;
ifndef|#
directive|ifndef
name|I960
comment|/* make sure that this section is of the right size too */
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|EXEC_P
operator|)
operator|==
literal|0
condition|)
block|{
name|bfd_size_type
name|old_size
decl_stmt|;
name|old_size
operator|=
name|current
operator|->
name|_raw_size
expr_stmt|;
name|current
operator|->
name|_raw_size
operator|=
name|BFD_ALIGN
argument_list|(
name|current
operator|->
name|_raw_size
argument_list|,
literal|1
operator|<<
name|current
operator|->
name|alignment_power
argument_list|)
expr_stmt|;
name|align_adjust
operator|=
name|current
operator|->
name|_raw_size
operator|!=
name|old_size
expr_stmt|;
name|sofar
operator|+=
name|current
operator|->
name|_raw_size
operator|-
name|old_size
expr_stmt|;
block|}
else|else
block|{
name|old_sofar
operator|=
name|sofar
expr_stmt|;
name|sofar
operator|=
name|BFD_ALIGN
argument_list|(
name|sofar
argument_list|,
literal|1
operator|<<
name|current
operator|->
name|alignment_power
argument_list|)
expr_stmt|;
name|align_adjust
operator|=
name|sofar
operator|!=
name|old_sofar
expr_stmt|;
name|current
operator|->
name|_raw_size
operator|+=
name|sofar
operator|-
name|old_sofar
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|_LIB
comment|/* Force .lib sections to start at zero.  The vma is then 	 incremented in coff_set_section_contents.  This is right for 	 SVR3.2.  */
if|if
condition|(
name|strcmp
argument_list|(
name|current
operator|->
name|name
argument_list|,
name|_LIB
argument_list|)
operator|==
literal|0
condition|)
name|bfd_set_section_vma
argument_list|(
name|abfd
argument_list|,
name|current
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|previous
operator|=
name|current
expr_stmt|;
block|}
comment|/* It is now safe to write to the output file.  If we needed an      alignment adjustment for the last section, then make sure that      there is a byte at offset sofar.  If there are no symbols and no      relocs, then nothing follows the last section.  If we don't force      the last byte out, then the file may appear to be truncated.  */
if|if
condition|(
name|align_adjust
condition|)
block|{
name|bfd_byte
name|b
decl_stmt|;
name|b
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|sofar
operator|-
literal|1
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_write
argument_list|(
operator|&
name|b
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|1
condition|)
return|return
name|false
return|;
block|}
comment|/* Make sure the relocations are aligned.  We don't need to make      sure that this byte exists, because it will only matter if there      really are relocs.  */
name|sofar
operator|=
name|BFD_ALIGN
argument_list|(
name|sofar
argument_list|,
literal|1
operator|<<
name|COFF_DEFAULT_SECTION_ALIGNMENT_POWER
argument_list|)
expr_stmt|;
name|obj_relocbase
argument_list|(
name|abfd
argument_list|)
operator|=
name|sofar
expr_stmt|;
name|abfd
operator|->
name|output_has_begun
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* This can never work, because it is called too late--after the    section positions have been set.  I can't figure out what it is    for, so I am going to disable it--Ian Taylor 20 March 1996.  */
end_comment

begin_comment
comment|/* If .file, .text, .data, .bss symbols are missing, add them.  */
end_comment

begin_comment
comment|/* @@ Should we only be adding missing symbols, or overriding the aux    values for existing section symbols?  */
end_comment

begin_comment
unit|static boolean coff_add_missing_symbols (abfd)      bfd *abfd; {   unsigned int nsyms = bfd_get_symcount (abfd);   asymbol **sympp = abfd->outsymbols;   asymbol **sympp2;   unsigned int i;   int need_text = 1, need_data = 1, need_bss = 1, need_file = 1;    for (i = 0; i< nsyms; i++)     {       coff_symbol_type *csym = coff_symbol_from (abfd, sympp[i]);       CONST char *name;       if (csym) 	{
comment|/* only do this if there is a coff representation of the input 	   symbol */
end_comment

begin_ifdef
unit|if (csym->native&& csym->native->u.syment.n_sclass == C_FILE) 	    { 	      need_file = 0; 	      continue; 	    } 	  name = csym->symbol.name; 	  if (!name) 	    continue; 	  if (!strcmp (name, _TEXT)) 	    need_text = 0;
ifdef|#
directive|ifdef
name|APOLLO_M68
end_ifdef

begin_endif
unit|else if (!strcmp (name, ".wtext")) 	    need_text = 0;
endif|#
directive|endif
end_endif

begin_comment
unit|else if (!strcmp (name, _DATA)) 	    need_data = 0; 	  else if (!strcmp (name, _BSS)) 	    need_bss = 0; 	}     }
comment|/* Now i == bfd_get_symcount (abfd).  */
end_comment

begin_comment
comment|/* @@ For now, don't deal with .file symbol.  */
end_comment

begin_comment
unit|need_file = 0;    if (!need_text&& !need_data&& !need_bss&& !need_file)     return true;   nsyms += need_text + need_data + need_bss + need_file;   sympp2 = (asymbol **) bfd_alloc (abfd, nsyms * sizeof (asymbol *));   if (!sympp2)     return false;   memcpy (sympp2, sympp, i * sizeof (asymbol *));   if (need_file)     {
comment|/* @@ Generate fake .file symbol, in sympp2[i], and increment i.  */
end_comment

begin_endif
unit|abort ();     }   if (need_text)     sympp2[i++] = coff_section_symbol (abfd, _TEXT);   if (need_data)     sympp2[i++] = coff_section_symbol (abfd, _DATA);   if (need_bss)     sympp2[i++] = coff_section_symbol (abfd, _BSS);   BFD_ASSERT (i == nsyms);   bfd_set_symtab (abfd, sympp2, nsyms);   return true; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_comment
comment|/* SUPPRESS 558 */
end_comment

begin_comment
comment|/* SUPPRESS 529 */
end_comment

begin_function
specifier|static
name|boolean
name|coff_write_object_contents
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|asection
modifier|*
name|current
decl_stmt|;
name|boolean
name|hasrelocs
init|=
name|false
decl_stmt|;
name|boolean
name|haslinno
init|=
name|false
decl_stmt|;
name|file_ptr
name|scn_base
decl_stmt|;
name|file_ptr
name|reloc_base
decl_stmt|;
name|file_ptr
name|lineno_base
decl_stmt|;
name|file_ptr
name|sym_base
decl_stmt|;
name|unsigned
name|long
name|reloc_size
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|lnno_size
init|=
literal|0
decl_stmt|;
name|boolean
name|long_section_names
decl_stmt|;
name|asection
modifier|*
name|text_sec
init|=
name|NULL
decl_stmt|;
name|asection
modifier|*
name|data_sec
init|=
name|NULL
decl_stmt|;
name|asection
modifier|*
name|bss_sec
init|=
name|NULL
decl_stmt|;
name|struct
name|internal_filehdr
name|internal_f
decl_stmt|;
name|struct
name|internal_aouthdr
name|internal_a
decl_stmt|;
ifdef|#
directive|ifdef
name|COFF_LONG_SECTION_NAMES
name|size_t
name|string_size
init|=
name|STRING_SIZE_SIZE
decl_stmt|;
endif|#
directive|endif
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
comment|/* Make a pass through the symbol table to count line number entries and      put them into the correct asections */
name|lnno_size
operator|=
name|coff_count_linenumbers
argument_list|(
name|abfd
argument_list|)
operator|*
name|LINESZ
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|output_has_begun
operator|==
name|false
condition|)
block|{
if|if
condition|(
operator|!
name|coff_compute_section_file_positions
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
block|}
name|reloc_base
operator|=
name|obj_relocbase
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* Work out the size of the reloc and linno areas */
for|for
control|(
name|current
operator|=
name|abfd
operator|->
name|sections
init|;
name|current
operator|!=
name|NULL
condition|;
name|current
operator|=
name|current
operator|->
name|next
control|)
name|reloc_size
operator|+=
name|current
operator|->
name|reloc_count
operator|*
name|RELSZ
expr_stmt|;
name|lineno_base
operator|=
name|reloc_base
operator|+
name|reloc_size
expr_stmt|;
name|sym_base
operator|=
name|lineno_base
operator|+
name|lnno_size
expr_stmt|;
comment|/* Indicate in each section->line_filepos its actual file address */
for|for
control|(
name|current
operator|=
name|abfd
operator|->
name|sections
init|;
name|current
operator|!=
name|NULL
condition|;
name|current
operator|=
name|current
operator|->
name|next
control|)
block|{
if|if
condition|(
name|current
operator|->
name|lineno_count
condition|)
block|{
name|current
operator|->
name|line_filepos
operator|=
name|lineno_base
expr_stmt|;
name|current
operator|->
name|moving_line_filepos
operator|=
name|lineno_base
expr_stmt|;
name|lineno_base
operator|+=
name|current
operator|->
name|lineno_count
operator|*
name|LINESZ
expr_stmt|;
block|}
else|else
block|{
name|current
operator|->
name|line_filepos
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|current
operator|->
name|reloc_count
condition|)
block|{
name|current
operator|->
name|rel_filepos
operator|=
name|reloc_base
expr_stmt|;
name|reloc_base
operator|+=
name|current
operator|->
name|reloc_count
operator|*
name|RELSZ
expr_stmt|;
block|}
else|else
block|{
name|current
operator|->
name|rel_filepos
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Write section headers to the file.  */
name|internal_f
operator|.
name|f_nscns
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|EXEC_P
operator|)
operator|!=
literal|0
condition|)
name|scn_base
operator|=
name|FILHSZ
operator|+
name|AOUTSZ
expr_stmt|;
else|else
block|{
name|scn_base
operator|=
name|FILHSZ
expr_stmt|;
ifdef|#
directive|ifdef
name|RS6000COFF_C
if|if
condition|(
name|xcoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|full_aouthdr
condition|)
name|scn_base
operator|+=
name|AOUTSZ
expr_stmt|;
else|else
name|scn_base
operator|+=
name|SMALL_AOUTSZ
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|scn_base
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
name|long_section_names
operator|=
name|false
expr_stmt|;
for|for
control|(
name|current
operator|=
name|abfd
operator|->
name|sections
init|;
name|current
operator|!=
name|NULL
condition|;
name|current
operator|=
name|current
operator|->
name|next
control|)
block|{
name|struct
name|internal_scnhdr
name|section
decl_stmt|;
ifdef|#
directive|ifdef
name|COFF_WITH_PE
comment|/* If we've got a .reloc section, remember. */
ifdef|#
directive|ifdef
name|COFF_IMAGE_WITH_PE
if|if
condition|(
name|strcmp
argument_list|(
name|current
operator|->
name|name
argument_list|,
literal|".reloc"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|pe_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|has_reloc_section
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
name|internal_f
operator|.
name|f_nscns
operator|++
expr_stmt|;
name|strncpy
argument_list|(
name|section
operator|.
name|s_name
argument_list|,
name|current
operator|->
name|name
argument_list|,
name|SCNNMLEN
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COFF_LONG_SECTION_NAMES
comment|/* Handle long section names as in PE.  This must be compatible          with the code in coff_write_symbols.  */
block|{
name|size_t
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|current
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|SCNNMLEN
condition|)
block|{
name|memset
argument_list|(
name|section
operator|.
name|s_name
argument_list|,
literal|0
argument_list|,
name|SCNNMLEN
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|section
operator|.
name|s_name
argument_list|,
literal|"/%lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|string_size
argument_list|)
expr_stmt|;
name|string_size
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
name|long_section_names
operator|=
name|true
expr_stmt|;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|_LIB
comment|/* Always set s_vaddr of .lib to 0.  This is right for SVR3.2 	 Ian Taylor<ian@cygnus.com>.  */
if|if
condition|(
name|strcmp
argument_list|(
name|current
operator|->
name|name
argument_list|,
name|_LIB
argument_list|)
operator|==
literal|0
condition|)
name|section
operator|.
name|s_vaddr
operator|=
literal|0
expr_stmt|;
else|else
endif|#
directive|endif
name|section
operator|.
name|s_vaddr
operator|=
name|current
operator|->
name|vma
expr_stmt|;
name|section
operator|.
name|s_paddr
operator|=
name|current
operator|->
name|lma
expr_stmt|;
name|section
operator|.
name|s_size
operator|=
name|current
operator|->
name|_raw_size
expr_stmt|;
ifdef|#
directive|ifdef
name|COFF_WITH_PE
name|section
operator|.
name|s_paddr
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|COFF_IMAGE_WITH_PE
comment|/* Reminder: s_paddr holds the virtual size of the section.  */
if|if
condition|(
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|current
argument_list|)
operator|!=
name|NULL
operator|&&
name|pei_section_data
argument_list|(
name|abfd
argument_list|,
name|current
argument_list|)
operator|!=
name|NULL
condition|)
name|section
operator|.
name|s_paddr
operator|=
name|pei_section_data
argument_list|(
name|abfd
argument_list|,
name|current
argument_list|)
operator|->
name|virt_size
expr_stmt|;
else|else
name|section
operator|.
name|s_paddr
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* 	 If this section has no size or is unloadable then the scnptr 	 will be 0 too 	 */
if|if
condition|(
name|current
operator|->
name|_raw_size
operator|==
literal|0
operator|||
operator|(
name|current
operator|->
name|flags
operator|&
operator|(
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|section
operator|.
name|s_scnptr
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|section
operator|.
name|s_scnptr
operator|=
name|current
operator|->
name|filepos
expr_stmt|;
block|}
name|section
operator|.
name|s_relptr
operator|=
name|current
operator|->
name|rel_filepos
expr_stmt|;
name|section
operator|.
name|s_lnnoptr
operator|=
name|current
operator|->
name|line_filepos
expr_stmt|;
name|section
operator|.
name|s_nreloc
operator|=
name|current
operator|->
name|reloc_count
expr_stmt|;
name|section
operator|.
name|s_nlnno
operator|=
name|current
operator|->
name|lineno_count
expr_stmt|;
if|if
condition|(
name|current
operator|->
name|reloc_count
operator|!=
literal|0
condition|)
name|hasrelocs
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|current
operator|->
name|lineno_count
operator|!=
literal|0
condition|)
name|haslinno
operator|=
name|true
expr_stmt|;
ifdef|#
directive|ifdef
name|RS6000COFF_C
comment|/* Indicate the use of an XCOFF overflow section header.  */
if|if
condition|(
name|current
operator|->
name|reloc_count
operator|>=
literal|0xffff
operator|||
name|current
operator|->
name|lineno_count
operator|>=
literal|0xffff
condition|)
block|{
name|section
operator|.
name|s_nreloc
operator|=
literal|0xffff
expr_stmt|;
name|section
operator|.
name|s_nlnno
operator|=
literal|0xffff
expr_stmt|;
block|}
endif|#
directive|endif
name|section
operator|.
name|s_flags
operator|=
name|sec_to_styp_flags
argument_list|(
name|current
operator|->
name|name
argument_list|,
name|current
operator|->
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|current
operator|->
name|name
argument_list|,
name|_TEXT
argument_list|)
condition|)
block|{
name|text_sec
operator|=
name|current
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|current
operator|->
name|name
argument_list|,
name|_DATA
argument_list|)
condition|)
block|{
name|data_sec
operator|=
name|current
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|current
operator|->
name|name
argument_list|,
name|_BSS
argument_list|)
condition|)
block|{
name|bss_sec
operator|=
name|current
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|I960
name|section
operator|.
name|s_align
operator|=
operator|(
name|current
operator|->
name|alignment_power
condition|?
literal|1
operator|<<
name|current
operator|->
name|alignment_power
else|:
literal|0
operator|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|COFF_IMAGE_WITH_PE
comment|/* suppress output of the sections if they are null.  ld includes 	 the bss and data sections even if there is no size assigned 	 to them.  NT loader doesn't like it if these section headers are 	 included if the sections themselves are not needed */
if|if
condition|(
name|section
operator|.
name|s_size
operator|==
literal|0
condition|)
name|internal_f
operator|.
name|f_nscns
operator|--
expr_stmt|;
else|else
endif|#
directive|endif
block|{
name|SCNHDR
name|buff
decl_stmt|;
if|if
condition|(
name|coff_swap_scnhdr_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|section
argument_list|,
operator|&
name|buff
argument_list|)
operator|==
literal|0
operator|||
name|bfd_write
argument_list|(
call|(
name|PTR
call|)
argument_list|(
operator|&
name|buff
argument_list|)
argument_list|,
literal|1
argument_list|,
name|SCNHSZ
argument_list|,
name|abfd
argument_list|)
operator|!=
name|SCNHSZ
condition|)
return|return
name|false
return|;
block|}
ifdef|#
directive|ifdef
name|COFF_WITH_PE
comment|/* PE stores COMDAT section information in the symbol table.  If          this section is supposed to have some COMDAT info, track down          the symbol in the symbol table and modify it.  */
if|if
condition|(
operator|(
name|current
operator|->
name|flags
operator|&
name|SEC_LINK_ONCE
operator|)
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|count
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|psym
decl_stmt|;
name|coff_symbol_type
modifier|*
name|csym
decl_stmt|;
name|count
operator|=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|psym
operator|=
name|abfd
operator|->
name|outsymbols
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|psym
operator|++
control|)
block|{
comment|/* Here *PSYM is the section symbol for CURRENT.  */
if|if
condition|(
name|strcmp
argument_list|(
operator|(
operator|*
name|psym
operator|)
operator|->
name|name
argument_list|,
name|current
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|csym
operator|=
name|coff_symbol_from
argument_list|(
name|abfd
argument_list|,
operator|*
name|psym
argument_list|)
expr_stmt|;
if|if
condition|(
name|csym
operator|==
name|NULL
operator|||
name|csym
operator|->
name|native
operator|==
name|NULL
operator|||
name|csym
operator|->
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_numaux
operator|<
literal|1
operator|||
name|csym
operator|->
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
operator|!=
name|C_STAT
operator|||
name|csym
operator|->
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_type
operator|!=
name|T_NULL
condition|)
continue|continue;
break|break;
block|}
block|}
comment|/* Did we find it? 	     Note that we might not if we're converting the file from 	     some other object file format.  */
if|if
condition|(
name|i
operator|<
name|count
condition|)
block|{
name|combined_entry_type
modifier|*
name|aux
decl_stmt|;
comment|/* We don't touch the x_checksum field.  The 		 x_associated field is not currently supported.  */
name|aux
operator|=
name|csym
operator|->
name|native
operator|+
literal|1
expr_stmt|;
switch|switch
condition|(
name|current
operator|->
name|flags
operator|&
name|SEC_LINK_DUPLICATES
condition|)
block|{
case|case
name|SEC_LINK_DUPLICATES_DISCARD
case|:
name|aux
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_scn
operator|.
name|x_comdat
operator|=
name|IMAGE_COMDAT_SELECT_ANY
expr_stmt|;
break|break;
case|case
name|SEC_LINK_DUPLICATES_ONE_ONLY
case|:
name|aux
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_scn
operator|.
name|x_comdat
operator|=
name|IMAGE_COMDAT_SELECT_NODUPLICATES
expr_stmt|;
break|break;
case|case
name|SEC_LINK_DUPLICATES_SAME_SIZE
case|:
name|aux
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_scn
operator|.
name|x_comdat
operator|=
name|IMAGE_COMDAT_SELECT_SAME_SIZE
expr_stmt|;
break|break;
case|case
name|SEC_LINK_DUPLICATES_SAME_CONTENTS
case|:
name|aux
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_scn
operator|.
name|x_comdat
operator|=
name|IMAGE_COMDAT_SELECT_EXACT_MATCH
expr_stmt|;
break|break;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* COFF_WITH_PE */
block|}
ifdef|#
directive|ifdef
name|RS6000COFF_C
comment|/* XCOFF handles overflows in the reloc and line number count fields      by creating a new section header to hold the correct values.  */
for|for
control|(
name|current
operator|=
name|abfd
operator|->
name|sections
init|;
name|current
operator|!=
name|NULL
condition|;
name|current
operator|=
name|current
operator|->
name|next
control|)
block|{
if|if
condition|(
name|current
operator|->
name|reloc_count
operator|>=
literal|0xffff
operator|||
name|current
operator|->
name|lineno_count
operator|>=
literal|0xffff
condition|)
block|{
name|struct
name|internal_scnhdr
name|scnhdr
decl_stmt|;
name|SCNHDR
name|buff
decl_stmt|;
name|internal_f
operator|.
name|f_nscns
operator|++
expr_stmt|;
name|strncpy
argument_list|(
operator|&
operator|(
name|scnhdr
operator|.
name|s_name
index|[
literal|0
index|]
operator|)
argument_list|,
name|current
operator|->
name|name
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|scnhdr
operator|.
name|s_paddr
operator|=
name|current
operator|->
name|reloc_count
expr_stmt|;
name|scnhdr
operator|.
name|s_vaddr
operator|=
name|current
operator|->
name|lineno_count
expr_stmt|;
name|scnhdr
operator|.
name|s_size
operator|=
literal|0
expr_stmt|;
name|scnhdr
operator|.
name|s_scnptr
operator|=
literal|0
expr_stmt|;
name|scnhdr
operator|.
name|s_relptr
operator|=
name|current
operator|->
name|rel_filepos
expr_stmt|;
name|scnhdr
operator|.
name|s_lnnoptr
operator|=
name|current
operator|->
name|line_filepos
expr_stmt|;
name|scnhdr
operator|.
name|s_nreloc
operator|=
name|current
operator|->
name|target_index
expr_stmt|;
name|scnhdr
operator|.
name|s_nlnno
operator|=
name|current
operator|->
name|target_index
expr_stmt|;
name|scnhdr
operator|.
name|s_flags
operator|=
name|STYP_OVRFLO
expr_stmt|;
if|if
condition|(
name|coff_swap_scnhdr_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|scnhdr
argument_list|,
operator|&
name|buff
argument_list|)
operator|==
literal|0
operator|||
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|buff
argument_list|,
literal|1
argument_list|,
name|SCNHSZ
argument_list|,
name|abfd
argument_list|)
operator|!=
name|SCNHSZ
condition|)
return|return
name|false
return|;
block|}
block|}
endif|#
directive|endif
comment|/* OK, now set up the filehdr... */
comment|/* Don't include the internal abs section in the section count */
comment|/*      We will NOT put a fucking timestamp in the header here. Every time you      put it back, I will come in and take it out again.  I'm sorry.  This      field does not belong here.  We fill it with a 0 so it compares the      same but is not a reasonable time. -- gnu@cygnus.com      */
name|internal_f
operator|.
name|f_timdat
operator|=
literal|0
expr_stmt|;
name|internal_f
operator|.
name|f_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|flags
operator|&
name|EXEC_P
condition|)
name|internal_f
operator|.
name|f_opthdr
operator|=
name|AOUTSZ
expr_stmt|;
else|else
block|{
name|internal_f
operator|.
name|f_opthdr
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|RS6000COFF_C
if|if
condition|(
name|xcoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|full_aouthdr
condition|)
name|internal_f
operator|.
name|f_opthdr
operator|=
name|AOUTSZ
expr_stmt|;
else|else
name|internal_f
operator|.
name|f_opthdr
operator|=
name|SMALL_AOUTSZ
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|!
name|hasrelocs
condition|)
name|internal_f
operator|.
name|f_flags
operator||=
name|F_RELFLG
expr_stmt|;
if|if
condition|(
operator|!
name|haslinno
condition|)
name|internal_f
operator|.
name|f_flags
operator||=
name|F_LNNO
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|flags
operator|&
name|EXEC_P
condition|)
name|internal_f
operator|.
name|f_flags
operator||=
name|F_EXEC
expr_stmt|;
comment|/* FIXME: this is wrong for PPC_PE! */
if|if
condition|(
name|bfd_little_endian
argument_list|(
name|abfd
argument_list|)
condition|)
name|internal_f
operator|.
name|f_flags
operator||=
name|F_AR32WR
expr_stmt|;
else|else
name|internal_f
operator|.
name|f_flags
operator||=
name|F_AR32W
expr_stmt|;
comment|/*      FIXME, should do something about the other byte orders and      architectures.      */
ifdef|#
directive|ifdef
name|RS6000COFF_C
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
condition|)
name|internal_f
operator|.
name|f_flags
operator||=
name|F_SHROBJ
expr_stmt|;
if|if
condition|(
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|_LOADER
argument_list|)
operator|!=
name|NULL
condition|)
name|internal_f
operator|.
name|f_flags
operator||=
name|F_DYNLOAD
expr_stmt|;
endif|#
directive|endif
name|memset
argument_list|(
operator|&
name|internal_a
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|internal_a
argument_list|)
expr_stmt|;
comment|/* Set up architecture-dependent stuff */
block|{
name|unsigned
name|int
name|magic
init|=
literal|0
decl_stmt|;
name|unsigned
name|short
name|flags
init|=
literal|0
decl_stmt|;
name|coff_set_flags
argument_list|(
name|abfd
argument_list|,
operator|&
name|magic
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
name|internal_f
operator|.
name|f_magic
operator|=
name|magic
expr_stmt|;
name|internal_f
operator|.
name|f_flags
operator||=
name|flags
expr_stmt|;
comment|/* ...and the "opt"hdr... */
ifdef|#
directive|ifdef
name|A29K
ifdef|#
directive|ifdef
name|ULTRA3
comment|/* NYU's machine */
comment|/* FIXME: This is a bogus check.  I really want to see if there      * is a .shbss or a .shdata section, if so then set the magic      * number to indicate a shared data executable.      */
if|if
condition|(
name|internal_f
operator|.
name|f_nscns
operator|>=
literal|7
condition|)
name|internal_a
operator|.
name|magic
operator|=
name|SHMAGIC
expr_stmt|;
comment|/* Shared magic */
else|else
endif|#
directive|endif
comment|/* ULTRA3 */
name|internal_a
operator|.
name|magic
operator|=
name|NMAGIC
expr_stmt|;
comment|/* Assume separate i/d */
define|#
directive|define
name|__A_MAGIC_SET__
endif|#
directive|endif
comment|/* A29K */
ifdef|#
directive|ifdef
name|TIC80
name|internal_a
operator|.
name|magic
operator|=
name|TIC80_ARCH_MAGIC
expr_stmt|;
define|#
directive|define
name|__A_MAGIC_SET__
endif|#
directive|endif
comment|/* TIC80 */
ifdef|#
directive|ifdef
name|I860
comment|/* FIXME: What are the a.out magic numbers for the i860?  */
name|internal_a
operator|.
name|magic
operator|=
literal|0
expr_stmt|;
define|#
directive|define
name|__A_MAGIC_SET__
endif|#
directive|endif
comment|/* I860 */
ifdef|#
directive|ifdef
name|I960
name|internal_a
operator|.
name|magic
operator|=
operator|(
name|magic
operator|==
name|I960ROMAGIC
condition|?
name|NMAGIC
else|:
name|OMAGIC
operator|)
expr_stmt|;
define|#
directive|define
name|__A_MAGIC_SET__
endif|#
directive|endif
comment|/* I960 */
if|#
directive|if
name|M88
define|#
directive|define
name|__A_MAGIC_SET__
name|internal_a
operator|.
name|magic
operator|=
name|PAGEMAGICBCS
expr_stmt|;
endif|#
directive|endif
comment|/* M88 */
if|#
directive|if
name|APOLLO_M68
define|#
directive|define
name|__A_MAGIC_SET__
name|internal_a
operator|.
name|magic
operator|=
name|APOLLO_COFF_VERSION_NUMBER
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|M68
argument_list|)
operator|||
name|defined
argument_list|(
name|WE32K
argument_list|)
operator|||
name|defined
argument_list|(
name|M68K
argument_list|)
define|#
directive|define
name|__A_MAGIC_SET__
if|#
directive|if
name|defined
argument_list|(
name|LYNXOS
argument_list|)
name|internal_a
operator|.
name|magic
operator|=
name|LYNXCOFFMAGIC
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|TARG_AUX
argument_list|)
name|internal_a
operator|.
name|magic
operator|=
operator|(
name|abfd
operator|->
name|flags
operator|&
name|D_PAGED
condition|?
name|PAGEMAGICPEXECPAGED
else|:
name|abfd
operator|->
name|flags
operator|&
name|WP_TEXT
condition|?
name|PAGEMAGICPEXECSWAPPED
else|:
name|PAGEMAGICEXECSWAPPED
operator|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|PAGEMAGICPEXECPAGED
argument_list|)
name|internal_a
operator|.
name|magic
operator|=
name|PAGEMAGICPEXECPAGED
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* TARG_AUX */
endif|#
directive|endif
comment|/* LYNXOS */
endif|#
directive|endif
comment|/* M68 || WE32K || M68K */
if|#
directive|if
name|defined
argument_list|(
name|ARM
argument_list|)
define|#
directive|define
name|__A_MAGIC_SET__
name|internal_a
operator|.
name|magic
operator|=
name|ZMAGIC
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PPC_PE
argument_list|)
define|#
directive|define
name|__A_MAGIC_SET__
name|internal_a
operator|.
name|magic
operator|=
name|IMAGE_NT_OPTIONAL_HDR_MAGIC
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|I386
argument_list|)
define|#
directive|define
name|__A_MAGIC_SET__
if|#
directive|if
name|defined
argument_list|(
name|LYNXOS
argument_list|)
name|internal_a
operator|.
name|magic
operator|=
name|LYNXCOFFMAGIC
expr_stmt|;
else|#
directive|else
comment|/* LYNXOS */
name|internal_a
operator|.
name|magic
operator|=
name|ZMAGIC
expr_stmt|;
endif|#
directive|endif
comment|/* LYNXOS */
endif|#
directive|endif
comment|/* I386 */
if|#
directive|if
name|defined
argument_list|(
name|SPARC
argument_list|)
define|#
directive|define
name|__A_MAGIC_SET__
if|#
directive|if
name|defined
argument_list|(
name|LYNXOS
argument_list|)
name|internal_a
operator|.
name|magic
operator|=
name|LYNXCOFFMAGIC
expr_stmt|;
endif|#
directive|endif
comment|/* LYNXOS */
endif|#
directive|endif
comment|/* SPARC */
if|#
directive|if
name|RS6000COFF_C
define|#
directive|define
name|__A_MAGIC_SET__
name|internal_a
operator|.
name|magic
operator|=
operator|(
name|abfd
operator|->
name|flags
operator|&
name|D_PAGED
operator|)
condition|?
name|RS6K_AOUTHDR_ZMAGIC
else|:
operator|(
name|abfd
operator|->
name|flags
operator|&
name|WP_TEXT
operator|)
condition|?
name|RS6K_AOUTHDR_NMAGIC
else|:
name|RS6K_AOUTHDR_OMAGIC
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|__A_MAGIC_SET__
include|#
directive|include
file|"Your aouthdr magic number is not being set!"
else|#
directive|else
undef|#
directive|undef
name|__A_MAGIC_SET__
endif|#
directive|endif
block|}
comment|/* FIXME: Does anybody ever set this to another value?  */
name|internal_a
operator|.
name|vstamp
operator|=
literal|0
expr_stmt|;
comment|/* Now should write relocs, strings, syms */
name|obj_sym_filepos
argument_list|(
name|abfd
argument_list|)
operator|=
name|sym_base
expr_stmt|;
if|if
condition|(
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|int
name|firstundef
decl_stmt|;
if|#
directive|if
literal|0
block|if (!coff_add_missing_symbols (abfd)) 	return false;
endif|#
directive|endif
if|if
condition|(
operator|!
name|coff_renumber_symbols
argument_list|(
name|abfd
argument_list|,
operator|&
name|firstundef
argument_list|)
condition|)
return|return
name|false
return|;
name|coff_mangle_symbols
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|coff_write_symbols
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|coff_write_linenumbers
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|coff_write_relocs
argument_list|(
name|abfd
argument_list|,
name|firstundef
argument_list|)
condition|)
return|return
name|false
return|;
block|}
ifdef|#
directive|ifdef
name|COFF_IMAGE_WITH_PE
ifdef|#
directive|ifdef
name|PPC_PE
elseif|else
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|EXEC_P
operator|)
operator|!=
literal|0
condition|)
block|{
name|bfd_byte
name|b
decl_stmt|;
comment|/* PowerPC PE appears to require that all executable files be          rounded up to the page size.  */
name|b
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|BFD_ALIGN
argument_list|(
name|sym_base
argument_list|,
name|COFF_PAGE_SIZE
argument_list|)
operator|-
literal|1
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_write
argument_list|(
operator|&
name|b
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|1
condition|)
return|return
name|false
return|;
block|}
endif|#
directive|endif
endif|#
directive|endif
comment|/* If bfd_get_symcount (abfd) != 0, then we are not using the COFF      backend linker, and obj_raw_syment_count is not valid until after      coff_write_symbols is called.  */
if|if
condition|(
name|obj_raw_syment_count
argument_list|(
name|abfd
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|internal_f
operator|.
name|f_symptr
operator|=
name|sym_base
expr_stmt|;
ifdef|#
directive|ifdef
name|RS6000COFF_C
comment|/* AIX appears to require that F_RELFLG not be set if there are          local symbols but no relocations.  */
name|internal_f
operator|.
name|f_flags
operator|&=
operator|~
name|F_RELFLG
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|if
condition|(
name|long_section_names
condition|)
name|internal_f
operator|.
name|f_symptr
operator|=
name|sym_base
expr_stmt|;
else|else
name|internal_f
operator|.
name|f_symptr
operator|=
literal|0
expr_stmt|;
name|internal_f
operator|.
name|f_flags
operator||=
name|F_LSYMS
expr_stmt|;
block|}
if|if
condition|(
name|text_sec
condition|)
block|{
name|internal_a
operator|.
name|tsize
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|text_sec
argument_list|)
expr_stmt|;
name|internal_a
operator|.
name|text_start
operator|=
name|internal_a
operator|.
name|tsize
condition|?
name|text_sec
operator|->
name|vma
else|:
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|data_sec
condition|)
block|{
name|internal_a
operator|.
name|dsize
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|data_sec
argument_list|)
expr_stmt|;
name|internal_a
operator|.
name|data_start
operator|=
name|internal_a
operator|.
name|dsize
condition|?
name|data_sec
operator|->
name|vma
else|:
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|bss_sec
condition|)
block|{
name|internal_a
operator|.
name|bsize
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|bss_sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_a
operator|.
name|bsize
operator|&&
name|bss_sec
operator|->
name|vma
operator|<
name|internal_a
operator|.
name|data_start
condition|)
name|internal_a
operator|.
name|data_start
operator|=
name|bss_sec
operator|->
name|vma
expr_stmt|;
block|}
name|internal_a
operator|.
name|entry
operator|=
name|bfd_get_start_address
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|internal_f
operator|.
name|f_nsyms
operator|=
name|obj_raw_syment_count
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RS6000COFF_C
if|if
condition|(
name|xcoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|full_aouthdr
condition|)
block|{
name|bfd_vma
name|toc
decl_stmt|;
name|asection
modifier|*
name|loader_sec
decl_stmt|;
name|internal_a
operator|.
name|vstamp
operator|=
literal|1
expr_stmt|;
name|internal_a
operator|.
name|o_snentry
operator|=
name|xcoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|snentry
expr_stmt|;
if|if
condition|(
name|internal_a
operator|.
name|o_snentry
operator|==
literal|0
condition|)
name|internal_a
operator|.
name|entry
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|text_sec
operator|!=
name|NULL
condition|)
block|{
name|internal_a
operator|.
name|o_sntext
operator|=
name|text_sec
operator|->
name|target_index
expr_stmt|;
name|internal_a
operator|.
name|o_algntext
operator|=
name|bfd_get_section_alignment
argument_list|(
name|abfd
argument_list|,
name|text_sec
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|internal_a
operator|.
name|o_sntext
operator|=
literal|0
expr_stmt|;
name|internal_a
operator|.
name|o_algntext
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|data_sec
operator|!=
name|NULL
condition|)
block|{
name|internal_a
operator|.
name|o_sndata
operator|=
name|data_sec
operator|->
name|target_index
expr_stmt|;
name|internal_a
operator|.
name|o_algndata
operator|=
name|bfd_get_section_alignment
argument_list|(
name|abfd
argument_list|,
name|data_sec
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|internal_a
operator|.
name|o_sndata
operator|=
literal|0
expr_stmt|;
name|internal_a
operator|.
name|o_algndata
operator|=
literal|0
expr_stmt|;
block|}
name|loader_sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".loader"
argument_list|)
expr_stmt|;
if|if
condition|(
name|loader_sec
operator|!=
name|NULL
condition|)
name|internal_a
operator|.
name|o_snloader
operator|=
name|loader_sec
operator|->
name|target_index
expr_stmt|;
else|else
name|internal_a
operator|.
name|o_snloader
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bss_sec
operator|!=
name|NULL
condition|)
name|internal_a
operator|.
name|o_snbss
operator|=
name|bss_sec
operator|->
name|target_index
expr_stmt|;
else|else
name|internal_a
operator|.
name|o_snbss
operator|=
literal|0
expr_stmt|;
name|toc
operator|=
name|xcoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|toc
expr_stmt|;
name|internal_a
operator|.
name|o_toc
operator|=
name|toc
expr_stmt|;
name|internal_a
operator|.
name|o_sntoc
operator|=
name|xcoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|sntoc
expr_stmt|;
name|internal_a
operator|.
name|o_modtype
operator|=
name|xcoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|modtype
expr_stmt|;
if|if
condition|(
name|xcoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|cputype
operator|!=
operator|-
literal|1
condition|)
name|internal_a
operator|.
name|o_cputype
operator|=
name|xcoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|cputype
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|bfd_get_arch
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
case|case
name|bfd_arch_rs6000
case|:
name|internal_a
operator|.
name|o_cputype
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|bfd_arch_powerpc
case|:
if|if
condition|(
name|bfd_get_mach
argument_list|(
name|abfd
argument_list|)
operator|==
literal|0
condition|)
name|internal_a
operator|.
name|o_cputype
operator|=
literal|3
expr_stmt|;
else|else
name|internal_a
operator|.
name|o_cputype
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
name|internal_a
operator|.
name|o_maxstack
operator|=
name|xcoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|maxstack
expr_stmt|;
name|internal_a
operator|.
name|o_maxdata
operator|=
name|xcoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|maxdata
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* now write them */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
block|{
name|char
name|buff
index|[
name|FILHSZ
index|]
decl_stmt|;
name|coff_swap_filehdr_out
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|internal_f
argument_list|,
operator|(
name|PTR
operator|)
name|buff
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|buff
argument_list|,
literal|1
argument_list|,
name|FILHSZ
argument_list|,
name|abfd
argument_list|)
operator|!=
name|FILHSZ
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|abfd
operator|->
name|flags
operator|&
name|EXEC_P
condition|)
block|{
comment|/* Note that peicode.h fills in a PEAOUTHDR, not an AOUTHDR.  	 include/coff/pe.h sets AOUTSZ == sizeof(PEAOUTHDR)) */
name|char
name|buff
index|[
name|AOUTSZ
index|]
decl_stmt|;
name|coff_swap_aouthdr_out
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|internal_a
argument_list|,
operator|(
name|PTR
operator|)
name|buff
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|buff
argument_list|,
literal|1
argument_list|,
name|AOUTSZ
argument_list|,
name|abfd
argument_list|)
operator|!=
name|AOUTSZ
condition|)
return|return
name|false
return|;
block|}
ifdef|#
directive|ifdef
name|RS6000COFF_C
else|else
block|{
name|AOUTHDR
name|buff
decl_stmt|;
name|size_t
name|size
decl_stmt|;
comment|/* XCOFF seems to always write at least a small a.out header.  */
name|coff_swap_aouthdr_out
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|internal_a
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|buff
argument_list|)
expr_stmt|;
if|if
condition|(
name|xcoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|full_aouthdr
condition|)
name|size
operator|=
name|AOUTSZ
expr_stmt|;
else|else
name|size
operator|=
name|SMALL_AOUTSZ
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|buff
argument_list|,
literal|1
argument_list|,
name|size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|size
condition|)
return|return
name|false
return|;
block|}
endif|#
directive|endif
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|coff_set_section_contents
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|location
parameter_list|,
name|offset
parameter_list|,
name|count
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|sec_ptr
name|section
decl_stmt|;
name|PTR
name|location
decl_stmt|;
name|file_ptr
name|offset
decl_stmt|;
name|bfd_size_type
name|count
decl_stmt|;
block|{
if|if
condition|(
name|abfd
operator|->
name|output_has_begun
operator|==
name|false
condition|)
comment|/* set by bfd.c handler */
block|{
if|if
condition|(
operator|!
name|coff_compute_section_file_positions
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|_LIB
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|TARG_AUX
argument_list|)
comment|/* The physical address field of a .lib section is used to hold the       number of shared libraries in the section.  This code counts the       number of sections being written, and increments the lma field       with the number.        I have found no documentation on the contents of this section.       Experimentation indicates that the section contains zero or more       records, each of which has the following structure:        - a (four byte) word holding the length of this record, in words,       - a word that always seems to be set to "2",       - the path to a shared library, null-terminated and then padded         to a whole word boundary.        bfd_assert calls have been added to alert if an attempt is made       to write a section which doesn't follow these assumptions.  The       code has been tested on ISC 4.1 by me, and on SCO by Robert Lipe<robertl@arnet.com> (Thanks!).          Gvran Uddeborg<gvran@uddeborg.pp.se> */
if|if
condition|(
name|strcmp
argument_list|(
name|section
operator|->
name|name
argument_list|,
name|_LIB
argument_list|)
operator|==
literal|0
condition|)
block|{
name|bfd_byte
modifier|*
name|rec
decl_stmt|,
modifier|*
name|recend
decl_stmt|;
name|rec
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|location
expr_stmt|;
name|recend
operator|=
name|rec
operator|+
name|count
expr_stmt|;
while|while
condition|(
name|rec
operator|<
name|recend
condition|)
block|{
operator|++
name|section
operator|->
name|lma
expr_stmt|;
name|rec
operator|+=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|rec
argument_list|)
operator|*
literal|4
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
name|rec
operator|==
name|recend
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Don't write out bss sections - one way to do this is to        see if the filepos has not been set. */
if|if
condition|(
name|section
operator|->
name|filepos
operator|==
literal|0
condition|)
return|return
name|true
return|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
call|(
name|file_ptr
call|)
argument_list|(
name|section
operator|->
name|filepos
operator|+
name|offset
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|bfd_write
argument_list|(
name|location
argument_list|,
literal|1
argument_list|,
name|count
argument_list|,
name|abfd
argument_list|)
operator|==
name|count
operator|)
condition|?
name|true
else|:
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static boolean coff_close_and_cleanup (abfd)      bfd *abfd; {   if (!bfd_read_p (abfd))     switch (abfd->format)       {       case bfd_archive: 	if (!_bfd_write_archive_contents (abfd)) 	  return false; 	break;       case bfd_object: 	if (!coff_write_object_contents (abfd)) 	  return false; 	break;       default: 	bfd_set_error (bfd_error_invalid_operation); 	return false;       }
comment|/* We depend on bfd_close to free all the memory on the objalloc.  */
end_comment

begin_endif
unit|return true; }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|PTR
name|buy_and_read
parameter_list|(
name|abfd
parameter_list|,
name|where
parameter_list|,
name|seek_direction
parameter_list|,
name|size
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|file_ptr
name|where
decl_stmt|;
name|int
name|seek_direction
decl_stmt|;
name|size_t
name|size
decl_stmt|;
block|{
name|PTR
name|area
init|=
operator|(
name|PTR
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|area
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|where
argument_list|,
name|seek_direction
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_read
argument_list|(
name|area
argument_list|,
literal|1
argument_list|,
name|size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|size
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|area
operator|)
return|;
block|}
end_function

begin_comment
comment|/* buy_and_read() */
end_comment

begin_comment
comment|/* SUBSUBSECTION 	Reading linenumbers  	Creating the linenumber table is done by reading in the entire 	coff linenumber table, and creating another table for internal use.  	A coff linenumber table is structured so that each function 	is marked as having a line number of 0. Each line within the 	function is an offset from the first line in the function. The 	base of the line number information for the table is stored in 	the symbol associated with the function.  	The information is copied from the external to the internal 	table, and each symbol which marks a function is marked by 	pointing its...  	How does this work ?  */
end_comment

begin_function
specifier|static
name|boolean
name|coff_slurp_line_table
parameter_list|(
name|abfd
parameter_list|,
name|asect
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|asect
decl_stmt|;
block|{
name|LINENO
modifier|*
name|native_lineno
decl_stmt|;
name|alent
modifier|*
name|lineno_cache
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|asect
operator|->
name|lineno
operator|==
operator|(
name|alent
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|native_lineno
operator|=
operator|(
name|LINENO
operator|*
operator|)
name|buy_and_read
argument_list|(
name|abfd
argument_list|,
name|asect
operator|->
name|line_filepos
argument_list|,
name|SEEK_SET
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|LINESZ
operator|*
name|asect
operator|->
name|lineno_count
argument_list|)
argument_list|)
expr_stmt|;
name|lineno_cache
operator|=
operator|(
name|alent
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
call|(
name|size_t
call|)
argument_list|(
operator|(
name|asect
operator|->
name|lineno_count
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|alent
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lineno_cache
operator|==
name|NULL
condition|)
return|return
name|false
return|;
else|else
block|{
name|unsigned
name|int
name|counter
init|=
literal|0
decl_stmt|;
name|alent
modifier|*
name|cache_ptr
init|=
name|lineno_cache
decl_stmt|;
name|LINENO
modifier|*
name|src
init|=
name|native_lineno
decl_stmt|;
while|while
condition|(
name|counter
operator|<
name|asect
operator|->
name|lineno_count
condition|)
block|{
name|struct
name|internal_lineno
name|dst
decl_stmt|;
name|coff_swap_lineno_in
argument_list|(
name|abfd
argument_list|,
name|src
argument_list|,
operator|&
name|dst
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|line_number
operator|=
name|dst
operator|.
name|l_lnno
expr_stmt|;
if|if
condition|(
name|cache_ptr
operator|->
name|line_number
operator|==
literal|0
condition|)
block|{
name|boolean
name|warned
decl_stmt|;
name|long
name|symndx
decl_stmt|;
name|coff_symbol_type
modifier|*
name|sym
decl_stmt|;
name|warned
operator|=
name|false
expr_stmt|;
name|symndx
operator|=
name|dst
operator|.
name|l_addr
operator|.
name|l_symndx
expr_stmt|;
if|if
condition|(
name|symndx
operator|<
literal|0
operator|||
name|symndx
operator|>=
name|obj_raw_syment_count
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"%s: warning: illegal symbol index %ld in line numbers"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|dst
operator|.
name|l_addr
operator|.
name|l_symndx
argument_list|)
expr_stmt|;
name|symndx
operator|=
literal|0
expr_stmt|;
name|warned
operator|=
name|true
expr_stmt|;
block|}
comment|/* FIXME: We should not be casting between ints and                  pointers like this.  */
name|sym
operator|=
operator|(
operator|(
name|coff_symbol_type
operator|*
operator|)
operator|(
operator|(
name|symndx
operator|+
name|obj_raw_syments
argument_list|(
name|abfd
argument_list|)
operator|)
operator|->
name|u
operator|.
name|syment
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_zeroes
operator|)
operator|)
expr_stmt|;
name|cache_ptr
operator|->
name|u
operator|.
name|sym
operator|=
operator|(
name|asymbol
operator|*
operator|)
name|sym
expr_stmt|;
if|if
condition|(
name|sym
operator|->
name|lineno
operator|!=
name|NULL
operator|&&
operator|!
name|warned
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"%s: warning: duplicate line number information for `%s'"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|bfd_asymbol_name
argument_list|(
operator|&
name|sym
operator|->
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sym
operator|->
name|lineno
operator|=
name|cache_ptr
expr_stmt|;
block|}
else|else
block|{
name|cache_ptr
operator|->
name|u
operator|.
name|offset
operator|=
name|dst
operator|.
name|l_addr
operator|.
name|l_paddr
operator|-
name|bfd_section_vma
argument_list|(
name|abfd
argument_list|,
name|asect
argument_list|)
expr_stmt|;
block|}
comment|/* If no linenumber expect a symbol index */
name|cache_ptr
operator|++
expr_stmt|;
name|src
operator|++
expr_stmt|;
name|counter
operator|++
expr_stmt|;
block|}
name|cache_ptr
operator|->
name|line_number
operator|=
literal|0
expr_stmt|;
block|}
name|asect
operator|->
name|lineno
operator|=
name|lineno_cache
expr_stmt|;
comment|/* FIXME, free native_lineno here, or use alloca or something. */
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|coff_slurp_symbol_table
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|combined_entry_type
modifier|*
name|native_symbols
decl_stmt|;
name|coff_symbol_type
modifier|*
name|cached_area
decl_stmt|;
name|unsigned
name|int
modifier|*
name|table_ptr
decl_stmt|;
name|unsigned
name|int
name|number_of_symbols
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|obj_symbols
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* Read in the symbol table */
if|if
condition|(
operator|(
name|native_symbols
operator|=
name|coff_get_normalized_symtab
argument_list|(
name|abfd
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|false
operator|)
return|;
block|}
comment|/* on error */
comment|/* Allocate enough room for all the symbols in cached form */
name|cached_area
operator|=
operator|(
operator|(
name|coff_symbol_type
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
operator|(
name|obj_raw_syment_count
argument_list|(
name|abfd
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|coff_symbol_type
argument_list|)
operator|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|cached_area
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|table_ptr
operator|=
operator|(
operator|(
name|unsigned
name|int
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
operator|(
name|obj_raw_syment_count
argument_list|(
name|abfd
argument_list|)
operator|*
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
operator|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|table_ptr
operator|==
name|NULL
condition|)
return|return
name|false
return|;
else|else
block|{
name|coff_symbol_type
modifier|*
name|dst
init|=
name|cached_area
decl_stmt|;
name|unsigned
name|int
name|last_native_index
init|=
name|obj_raw_syment_count
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|this_index
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|this_index
operator|<
name|last_native_index
condition|)
block|{
name|combined_entry_type
modifier|*
name|src
init|=
name|native_symbols
operator|+
name|this_index
decl_stmt|;
name|table_ptr
index|[
name|this_index
index|]
operator|=
name|number_of_symbols
expr_stmt|;
name|dst
operator|->
name|symbol
operator|.
name|the_bfd
operator|=
name|abfd
expr_stmt|;
name|dst
operator|->
name|symbol
operator|.
name|name
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
operator|)
expr_stmt|;
comment|/* We use the native name field to point to the cached field.  */
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_zeroes
operator|=
operator|(
name|long
operator|)
name|dst
expr_stmt|;
name|dst
operator|->
name|symbol
operator|.
name|section
operator|=
name|coff_section_from_bfd_index
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_scnum
argument_list|)
expr_stmt|;
name|dst
operator|->
name|symbol
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|dst
operator|->
name|done_lineno
operator|=
name|false
expr_stmt|;
switch|switch
condition|(
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
condition|)
block|{
ifdef|#
directive|ifdef
name|I960
case|case
name|C_LEAFEXT
case|:
if|#
directive|if
literal|0
block|dst->symbol.value = src->u.syment.n_value - dst->symbol.section->vma; 	      dst->symbol.flags = BSF_EXPORT | BSF_GLOBAL; 	      dst->symbol.flags |= BSF_NOT_AT_END | BSF_FUNCTION;
endif|#
directive|endif
comment|/* Fall through to next case */
endif|#
directive|endif
case|case
name|C_EXT
case|:
ifdef|#
directive|ifdef
name|RS6000COFF_C
case|case
name|C_HIDEXT
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|COFF_WITH_PE
comment|/* PE uses storage class 0x68 to denote a section symbol */
case|case
name|C_SECTION
case|:
comment|/* PE uses storage class 0x67 for a weak external symbol.  */
case|case
name|C_NT_WEAK
case|:
endif|#
directive|endif
if|if
condition|(
operator|(
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_scnum
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
operator|)
operator|==
literal|0
condition|)
block|{
name|dst
operator|->
name|symbol
operator|.
name|section
operator|=
name|bfd_und_section_ptr
expr_stmt|;
name|dst
operator|->
name|symbol
operator|.
name|value
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|dst
operator|->
name|symbol
operator|.
name|section
operator|=
name|bfd_com_section_ptr
expr_stmt|;
name|dst
operator|->
name|symbol
operator|.
name|value
operator|=
operator|(
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Base the value as an index from the base of the 		     section */
name|dst
operator|->
name|symbol
operator|.
name|flags
operator|=
name|BSF_EXPORT
operator||
name|BSF_GLOBAL
expr_stmt|;
name|dst
operator|->
name|symbol
operator|.
name|value
operator|=
operator|(
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
operator|-
name|dst
operator|->
name|symbol
operator|.
name|section
operator|->
name|vma
operator|)
expr_stmt|;
if|if
condition|(
name|ISFCN
argument_list|(
operator|(
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_type
operator|)
argument_list|)
condition|)
block|{
comment|/* A function ext does not go at the end of a 			 file.  */
name|dst
operator|->
name|symbol
operator|.
name|flags
operator||=
name|BSF_NOT_AT_END
operator||
name|BSF_FUNCTION
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|RS6000COFF_C
comment|/* A C_HIDEXT symbol is not global.  */
if|if
condition|(
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
operator|==
name|C_HIDEXT
condition|)
name|dst
operator|->
name|symbol
operator|.
name|flags
operator|=
name|BSF_LOCAL
expr_stmt|;
comment|/* A symbol with a csect entry should not go at the end.  */
if|if
condition|(
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_numaux
operator|>
literal|0
condition|)
name|dst
operator|->
name|symbol
operator|.
name|flags
operator||=
name|BSF_NOT_AT_END
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|COFF_WITH_PE
if|if
condition|(
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
operator|==
name|C_NT_WEAK
condition|)
name|dst
operator|->
name|symbol
operator|.
name|flags
operator|=
name|BSF_WEAK
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|C_STAT
case|:
comment|/* static			 */
ifdef|#
directive|ifdef
name|I960
case|case
name|C_LEAFSTAT
case|:
comment|/* static leaf procedure        */
endif|#
directive|endif
case|case
name|C_LABEL
case|:
comment|/* label			 */
if|if
condition|(
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_scnum
operator|==
operator|-
literal|2
condition|)
name|dst
operator|->
name|symbol
operator|.
name|flags
operator|=
name|BSF_DEBUGGING
expr_stmt|;
else|else
name|dst
operator|->
name|symbol
operator|.
name|flags
operator|=
name|BSF_LOCAL
expr_stmt|;
comment|/* Base the value as an index from the base of the 		 section, if there is one.  */
if|if
condition|(
name|dst
operator|->
name|symbol
operator|.
name|section
condition|)
name|dst
operator|->
name|symbol
operator|.
name|value
operator|=
operator|(
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
operator|-
name|dst
operator|->
name|symbol
operator|.
name|section
operator|->
name|vma
operator|)
expr_stmt|;
else|else
name|dst
operator|->
name|symbol
operator|.
name|value
operator|=
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
expr_stmt|;
break|break;
case|case
name|C_MOS
case|:
comment|/* member of structure	 */
case|case
name|C_EOS
case|:
comment|/* end of structure		 */
ifdef|#
directive|ifdef
name|NOTDEF
comment|/* C_AUTOARG has the same value */
ifdef|#
directive|ifdef
name|C_GLBLREG
case|case
name|C_GLBLREG
case|:
comment|/* A29k-specific storage class */
endif|#
directive|endif
endif|#
directive|endif
case|case
name|C_REGPARM
case|:
comment|/* register parameter		 */
case|case
name|C_REG
case|:
comment|/* register variable		 */
ifdef|#
directive|ifdef
name|C_AUTOARG
case|case
name|C_AUTOARG
case|:
comment|/* 960-specific storage class */
endif|#
directive|endif
case|case
name|C_TPDEF
case|:
comment|/* type definition		 */
case|case
name|C_ARG
case|:
case|case
name|C_AUTO
case|:
comment|/* automatic variable */
case|case
name|C_FIELD
case|:
comment|/* bit field */
case|case
name|C_ENTAG
case|:
comment|/* enumeration tag		 */
case|case
name|C_MOE
case|:
comment|/* member of enumeration	 */
case|case
name|C_MOU
case|:
comment|/* member of union		 */
case|case
name|C_UNTAG
case|:
comment|/* union tag			 */
name|dst
operator|->
name|symbol
operator|.
name|flags
operator|=
name|BSF_DEBUGGING
expr_stmt|;
name|dst
operator|->
name|symbol
operator|.
name|value
operator|=
operator|(
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
operator|)
expr_stmt|;
break|break;
case|case
name|C_FILE
case|:
comment|/* file name			 */
case|case
name|C_STRTAG
case|:
comment|/* structure tag		 */
ifdef|#
directive|ifdef
name|RS6000COFF_C
case|case
name|C_GSYM
case|:
case|case
name|C_LSYM
case|:
case|case
name|C_PSYM
case|:
case|case
name|C_RSYM
case|:
case|case
name|C_RPSYM
case|:
case|case
name|C_STSYM
case|:
case|case
name|C_BCOMM
case|:
case|case
name|C_ECOMM
case|:
case|case
name|C_DECL
case|:
case|case
name|C_ENTRY
case|:
case|case
name|C_FUN
case|:
case|case
name|C_ESTAT
case|:
endif|#
directive|endif
name|dst
operator|->
name|symbol
operator|.
name|flags
operator|=
name|BSF_DEBUGGING
expr_stmt|;
name|dst
operator|->
name|symbol
operator|.
name|value
operator|=
operator|(
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
operator|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|RS6000COFF_C
case|case
name|C_BINCL
case|:
comment|/* beginning of include file     */
case|case
name|C_EINCL
case|:
comment|/* ending of include file        */
comment|/* The value is actually a pointer into the line numbers                  of the file.  We locate the line number entry, and                  set the section to the section which contains it, and                  the value to the index in that section.  */
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|dst
operator|->
name|symbol
operator|.
name|flags
operator|=
name|BSF_DEBUGGING
expr_stmt|;
for|for
control|(
name|sec
operator|=
name|abfd
operator|->
name|sections
init|;
name|sec
operator|!=
name|NULL
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
if|if
condition|(
name|sec
operator|->
name|line_filepos
operator|<=
operator|(
name|file_ptr
operator|)
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
operator|&&
operator|(
call|(
name|file_ptr
call|)
argument_list|(
name|sec
operator|->
name|line_filepos
operator|+
name|sec
operator|->
name|lineno_count
operator|*
name|LINESZ
argument_list|)
operator|>
operator|(
name|file_ptr
operator|)
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
operator|)
condition|)
break|break;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
name|dst
operator|->
name|symbol
operator|.
name|value
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|dst
operator|->
name|symbol
operator|.
name|section
operator|=
name|sec
expr_stmt|;
name|dst
operator|->
name|symbol
operator|.
name|value
operator|=
operator|(
operator|(
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
operator|-
name|sec
operator|->
name|line_filepos
operator|)
operator|/
name|LINESZ
operator|)
expr_stmt|;
name|src
operator|->
name|fix_line
operator|=
literal|1
expr_stmt|;
block|}
block|}
break|break;
case|case
name|C_BSTAT
case|:
name|dst
operator|->
name|symbol
operator|.
name|flags
operator|=
name|BSF_DEBUGGING
expr_stmt|;
comment|/* The value is actually a symbol index.  Save a pointer 		 to the symbol instead of the index.  FIXME: This 		 should use a union.  */
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
operator|=
call|(
name|long
call|)
argument_list|(
name|native_symbols
operator|+
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
argument_list|)
expr_stmt|;
name|dst
operator|->
name|symbol
operator|.
name|value
operator|=
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
expr_stmt|;
name|src
operator|->
name|fix_value
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|C_BLOCK
case|:
comment|/* ".bb" or ".eb"		 */
case|case
name|C_FCN
case|:
comment|/* ".bf" or ".ef"		 */
case|case
name|C_EFCN
case|:
comment|/* physical end of function	 */
name|dst
operator|->
name|symbol
operator|.
name|flags
operator|=
name|BSF_LOCAL
expr_stmt|;
comment|/* Base the value as an index from the base of the 		 section.  */
name|dst
operator|->
name|symbol
operator|.
name|value
operator|=
operator|(
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
operator|-
name|dst
operator|->
name|symbol
operator|.
name|section
operator|->
name|vma
operator|)
expr_stmt|;
break|break;
case|case
name|C_NULL
case|:
case|case
name|C_EXTDEF
case|:
comment|/* external definition		 */
case|case
name|C_ULABEL
case|:
comment|/* undefined label		 */
case|case
name|C_USTATIC
case|:
comment|/* undefined static		 */
ifndef|#
directive|ifndef
name|COFF_WITH_PE
comment|/* C_LINE in regular coff is 0x68.  NT has taken over this storage                class to represent a section symbol */
case|case
name|C_LINE
case|:
comment|/* line # reformatted as symbol table entry */
comment|/* NT uses 0x67 for a weak symbol, not C_ALIAS.  */
case|case
name|C_ALIAS
case|:
comment|/* duplicate tag		 */
endif|#
directive|endif
case|case
name|C_HIDDEN
case|:
comment|/* ext symbol in dmert public lib */
default|default:
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"%s: Unrecognized storage class %d for %s symbol `%s'"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
argument_list|,
name|dst
operator|->
name|symbol
operator|.
name|section
operator|->
name|name
argument_list|,
name|dst
operator|->
name|symbol
operator|.
name|name
argument_list|)
expr_stmt|;
name|dst
operator|->
name|symbol
operator|.
name|flags
operator|=
name|BSF_DEBUGGING
expr_stmt|;
name|dst
operator|->
name|symbol
operator|.
name|value
operator|=
operator|(
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
operator|)
expr_stmt|;
break|break;
block|}
comment|/*      BFD_ASSERT(dst->symbol.flags != 0);*/
name|dst
operator|->
name|native
operator|=
name|src
expr_stmt|;
name|dst
operator|->
name|symbol
operator|.
name|udata
operator|.
name|i
operator|=
literal|0
expr_stmt|;
name|dst
operator|->
name|lineno
operator|=
operator|(
name|alent
operator|*
operator|)
name|NULL
expr_stmt|;
name|this_index
operator|+=
operator|(
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_numaux
operator|)
operator|+
literal|1
expr_stmt|;
name|dst
operator|++
expr_stmt|;
name|number_of_symbols
operator|++
expr_stmt|;
block|}
comment|/* walk the native symtab */
block|}
comment|/* bfdize the native symtab */
name|obj_symbols
argument_list|(
name|abfd
argument_list|)
operator|=
name|cached_area
expr_stmt|;
name|obj_raw_syments
argument_list|(
name|abfd
argument_list|)
operator|=
name|native_symbols
expr_stmt|;
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|=
name|number_of_symbols
expr_stmt|;
name|obj_convert
argument_list|(
name|abfd
argument_list|)
operator|=
name|table_ptr
expr_stmt|;
comment|/* Slurp the line tables for each section too */
block|{
name|asection
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|abfd
operator|->
name|sections
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|coff_slurp_line_table
argument_list|(
name|abfd
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* coff_slurp_symbol_table() */
end_comment

begin_comment
comment|/* Check whether a symbol is globally visible.  This is used by the    COFF backend linker code in cofflink.c, since a couple of targets    have globally visible symbols which are not class C_EXT.  This    function need not handle the case of n_class == C_EXT.  */
end_comment

begin_undef
undef|#
directive|undef
name|OTHER_GLOBAL_CLASS
end_undef

begin_ifdef
ifdef|#
directive|ifdef
name|I960
end_ifdef

begin_define
define|#
directive|define
name|OTHER_GLOBAL_CLASS
value|C_LEAFEXT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|COFF_WITH_PE
end_ifdef

begin_define
define|#
directive|define
name|OTHER_GLOBAL_CLASS
value|C_SECTION
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|OTHER_GLOBAL_CLASS
end_ifdef

begin_decl_stmt
specifier|static
name|boolean
name|coff_sym_is_global
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|internal_syment
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|boolean
name|coff_sym_is_global
parameter_list|(
name|abfd
parameter_list|,
name|syment
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|internal_syment
modifier|*
name|syment
decl_stmt|;
block|{
if|if
condition|(
name|syment
operator|->
name|n_sclass
operator|==
name|OTHER_GLOBAL_CLASS
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|OTHER_GLOBAL_CLASS
end_undef

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! defined (OTHER_GLOBAL_CLASS) */
end_comment

begin_comment
comment|/* sym_is_global should not be defined if it has nothing to do.  */
end_comment

begin_define
define|#
directive|define
name|coff_sym_is_global
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! defined (OTHER_GLOBAL_CLASS) */
end_comment

begin_comment
comment|/* SUBSUBSECTION 	Reading relocations  	Coff relocations are easily transformed into the internal BFD form 	(@code{arelent}).  	Reading a coff relocation table is done in the following stages:  	o Read the entire coff relocation table into memory.  	o Process each relocation in turn; first swap it from the 	external to the internal form.  	o Turn the symbol referenced in the relocation's symbol index 	into a pointer into the canonical symbol table. 	This table is the same as the one returned by a call to 	@code{bfd_canonicalize_symtab}. The back end will call that 	routine and save the result if a canonicalization hasn't been done.  	o The reloc index is turned into a pointer to a howto 	structure, in a back end specific way. For instance, the 386 	and 960 use the @code{r_type} to directly produce an index 	into a howto table vector; the 88k subtracts a number from the 	@code{r_type} field and creates an addend field.   */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CALC_ADDEND
end_ifndef

begin_define
define|#
directive|define
name|CALC_ADDEND
parameter_list|(
name|abfd
parameter_list|,
name|ptr
parameter_list|,
name|reloc
parameter_list|,
name|cache_ptr
parameter_list|)
define|\
value|{                                                             \     coff_symbol_type *coffsym = (coff_symbol_type *) NULL;      \     if (ptr&& bfd_asymbol_bfd (ptr) != abfd)                   \       coffsym = (obj_symbols (abfd)                             \                  + (cache_ptr->sym_ptr_ptr - symbols));         \     else if (ptr)                                               \       coffsym = coff_symbol_from (abfd, ptr);                   \     if (coffsym != (coff_symbol_type *) NULL                    \&& coffsym->native->u.syment.n_scnum == 0)              \       cache_ptr->addend = 0;                                    \     else if (ptr&& bfd_asymbol_bfd (ptr) == abfd               \&& ptr->section != (asection *) NULL)              \       cache_ptr->addend = - (ptr->section->vma + ptr->value);   \     else                                                        \       cache_ptr->addend = 0;                                    \   }
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|boolean
name|coff_slurp_reloc_table
parameter_list|(
name|abfd
parameter_list|,
name|asect
parameter_list|,
name|symbols
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|sec_ptr
name|asect
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
block|{
name|RELOC
modifier|*
name|native_relocs
decl_stmt|;
name|arelent
modifier|*
name|reloc_cache
decl_stmt|;
name|arelent
modifier|*
name|cache_ptr
decl_stmt|;
name|unsigned
name|int
name|idx
decl_stmt|;
if|if
condition|(
name|asect
operator|->
name|relocation
condition|)
return|return
name|true
return|;
if|if
condition|(
name|asect
operator|->
name|reloc_count
operator|==
literal|0
condition|)
return|return
name|true
return|;
if|if
condition|(
name|asect
operator|->
name|flags
operator|&
name|SEC_CONSTRUCTOR
condition|)
return|return
name|true
return|;
if|if
condition|(
operator|!
name|coff_slurp_symbol_table
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
name|native_relocs
operator|=
operator|(
name|RELOC
operator|*
operator|)
name|buy_and_read
argument_list|(
name|abfd
argument_list|,
name|asect
operator|->
name|rel_filepos
argument_list|,
name|SEEK_SET
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|RELSZ
operator|*
name|asect
operator|->
name|reloc_count
argument_list|)
argument_list|)
expr_stmt|;
name|reloc_cache
operator|=
operator|(
name|arelent
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|asect
operator|->
name|reloc_count
operator|*
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc_cache
operator|==
name|NULL
condition|)
return|return
name|false
return|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|asect
operator|->
name|reloc_count
condition|;
name|idx
operator|++
control|)
block|{
name|struct
name|internal_reloc
name|dst
decl_stmt|;
name|struct
name|external_reloc
modifier|*
name|src
decl_stmt|;
ifndef|#
directive|ifndef
name|RELOC_PROCESSING
name|asymbol
modifier|*
name|ptr
decl_stmt|;
endif|#
directive|endif
name|cache_ptr
operator|=
name|reloc_cache
operator|+
name|idx
expr_stmt|;
name|src
operator|=
name|native_relocs
operator|+
name|idx
expr_stmt|;
name|coff_swap_reloc_in
argument_list|(
name|abfd
argument_list|,
name|src
argument_list|,
operator|&
name|dst
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RELOC_PROCESSING
name|RELOC_PROCESSING
argument_list|(
name|cache_ptr
argument_list|,
operator|&
name|dst
argument_list|,
name|symbols
argument_list|,
name|abfd
argument_list|,
name|asect
argument_list|)
expr_stmt|;
else|#
directive|else
name|cache_ptr
operator|->
name|address
operator|=
name|dst
operator|.
name|r_vaddr
expr_stmt|;
if|if
condition|(
name|dst
operator|.
name|r_symndx
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|dst
operator|.
name|r_symndx
operator|<
literal|0
operator|||
name|dst
operator|.
name|r_symndx
operator|>=
name|obj_conv_table_size
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"%s: warning: illegal symbol index %ld in relocs"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|dst
operator|.
name|r_symndx
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|sym_ptr_ptr
operator|=
name|bfd_abs_section_ptr
operator|->
name|symbol_ptr_ptr
expr_stmt|;
name|ptr
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|cache_ptr
operator|->
name|sym_ptr_ptr
operator|=
operator|(
name|symbols
operator|+
name|obj_convert
argument_list|(
name|abfd
argument_list|)
index|[
name|dst
operator|.
name|r_symndx
index|]
operator|)
expr_stmt|;
name|ptr
operator|=
operator|*
operator|(
name|cache_ptr
operator|->
name|sym_ptr_ptr
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|cache_ptr
operator|->
name|sym_ptr_ptr
operator|=
name|bfd_abs_section_ptr
operator|->
name|symbol_ptr_ptr
expr_stmt|;
name|ptr
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* The symbols definitions that we have read in have been 	 relocated as if their sections started at 0. But the offsets 	 refering to the symbols in the raw data have not been 	 modified, so we have to have a negative addend to compensate.  	 Note that symbols which used to be common must be left alone */
comment|/* Calculate any reloc addend by looking at the symbol */
name|CALC_ADDEND
argument_list|(
name|abfd
argument_list|,
name|ptr
argument_list|,
name|dst
argument_list|,
name|cache_ptr
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|address
operator|-=
name|asect
operator|->
name|vma
expr_stmt|;
comment|/* !!     cache_ptr->section = (asection *) NULL;*/
comment|/* Fill in the cache_ptr->howto field from dst.r_type */
name|RTYPE2HOWTO
argument_list|(
name|cache_ptr
argument_list|,
operator|&
name|dst
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RELOC_PROCESSING */
if|if
condition|(
name|cache_ptr
operator|->
name|howto
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"%s: illegal relocation type %d at address 0x%lx"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|dst
operator|.
name|r_type
argument_list|,
operator|(
name|long
operator|)
name|dst
operator|.
name|r_vaddr
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
name|asect
operator|->
name|relocation
operator|=
name|reloc_cache
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|coff_rtype_to_howto
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|RTYPE2HOWTO
end_ifdef

begin_comment
comment|/* Get the howto structure for a reloc.  This is only used if the file    including this one defines coff_relocate_section to be    _bfd_coff_generic_relocate_section, so it is OK if it does not    always work.  It is the responsibility of the including file to    make sure it is reasonable if it is needed.  */
end_comment

begin_decl_stmt
specifier|static
name|reloc_howto_type
modifier|*
name|coff_rtype_to_howto
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
expr|struct
name|internal_reloc
operator|*
operator|,
expr|struct
name|coff_link_hash_entry
operator|*
operator|,
expr|struct
name|internal_syment
operator|*
operator|,
name|bfd_vma
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|coff_rtype_to_howto
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|rel
parameter_list|,
name|h
parameter_list|,
name|sym
parameter_list|,
name|addendp
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|rel
decl_stmt|;
name|struct
name|coff_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|internal_syment
modifier|*
name|sym
decl_stmt|;
name|bfd_vma
modifier|*
name|addendp
decl_stmt|;
block|{
name|arelent
name|genrel
decl_stmt|;
name|RTYPE2HOWTO
argument_list|(
operator|&
name|genrel
argument_list|,
name|rel
argument_list|)
expr_stmt|;
return|return
name|genrel
operator|.
name|howto
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! defined (RTYPE2HOWTO) */
end_comment

begin_define
define|#
directive|define
name|coff_rtype_to_howto
value|NULL
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! defined (RTYPE2HOWTO) */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! defined (coff_rtype_to_howto) */
end_comment

begin_comment
comment|/* This is stupid.  This function should be a boolean predicate.  */
end_comment

begin_function
specifier|static
name|long
name|coff_canonicalize_reloc
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|relptr
parameter_list|,
name|symbols
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|sec_ptr
name|section
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|relptr
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
block|{
name|arelent
modifier|*
name|tblptr
init|=
name|section
operator|->
name|relocation
decl_stmt|;
name|unsigned
name|int
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|section
operator|->
name|flags
operator|&
name|SEC_CONSTRUCTOR
condition|)
block|{
comment|/* this section has relocs made up by us, they are not in the        file, so take them out of their chain and place them into        the data area provided */
name|arelent_chain
modifier|*
name|chain
init|=
name|section
operator|->
name|constructor_chain
decl_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|section
operator|->
name|reloc_count
condition|;
name|count
operator|++
control|)
block|{
operator|*
name|relptr
operator|++
operator|=
operator|&
name|chain
operator|->
name|relent
expr_stmt|;
name|chain
operator|=
name|chain
operator|->
name|next
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|coff_slurp_reloc_table
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|symbols
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|tblptr
operator|=
name|section
operator|->
name|relocation
expr_stmt|;
for|for
control|(
init|;
name|count
operator|++
operator|<
name|section
operator|->
name|reloc_count
condition|;
control|)
operator|*
name|relptr
operator|++
operator|=
name|tblptr
operator|++
expr_stmt|;
block|}
operator|*
name|relptr
operator|=
literal|0
expr_stmt|;
return|return
name|section
operator|->
name|reloc_count
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|GNU960
end_ifdef

begin_function
name|file_ptr
name|coff_sym_filepos
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
return|return
name|obj_sym_filepos
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|coff_reloc16_estimate
end_ifndef

begin_define
define|#
directive|define
name|coff_reloc16_estimate
value|dummy_reloc16_estimate
end_define

begin_decl_stmt
specifier|static
name|int
name|dummy_reloc16_estimate
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|arelent
operator|*
operator|,
name|unsigned
name|int
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|dummy_reloc16_estimate
parameter_list|(
name|abfd
parameter_list|,
name|input_section
parameter_list|,
name|reloc
parameter_list|,
name|shrink
parameter_list|,
name|link_info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|arelent
modifier|*
name|reloc
decl_stmt|;
name|unsigned
name|int
name|shrink
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|link_info
decl_stmt|;
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|coff_reloc16_extra_cases
end_ifndef

begin_define
define|#
directive|define
name|coff_reloc16_extra_cases
value|dummy_reloc16_extra_cases
end_define

begin_comment
comment|/* This works even if abort is not declared in any header file.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|dummy_reloc16_extra_cases
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|bfd_link_order
operator|*
operator|,
name|arelent
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|unsigned
name|int
operator|*
operator|,
name|unsigned
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|dummy_reloc16_extra_cases
parameter_list|(
name|abfd
parameter_list|,
name|link_info
parameter_list|,
name|link_order
parameter_list|,
name|reloc
parameter_list|,
name|data
parameter_list|,
name|src_ptr
parameter_list|,
name|dst_ptr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|link_info
decl_stmt|;
name|struct
name|bfd_link_order
modifier|*
name|link_order
decl_stmt|;
name|arelent
modifier|*
name|reloc
decl_stmt|;
name|bfd_byte
modifier|*
name|data
decl_stmt|;
name|unsigned
name|int
modifier|*
name|src_ptr
decl_stmt|;
name|unsigned
name|int
modifier|*
name|dst_ptr
decl_stmt|;
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If coff_relocate_section is defined, we can use the optimized COFF    backend linker.  Otherwise we must continue to use the old linker.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|coff_relocate_section
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|coff_bfd_link_hash_table_create
end_ifndef

begin_define
define|#
directive|define
name|coff_bfd_link_hash_table_create
value|_bfd_coff_link_hash_table_create
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|coff_bfd_link_add_symbols
end_ifndef

begin_define
define|#
directive|define
name|coff_bfd_link_add_symbols
value|_bfd_coff_link_add_symbols
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|coff_bfd_final_link
end_ifndef

begin_define
define|#
directive|define
name|coff_bfd_final_link
value|_bfd_coff_final_link
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! defined (coff_relocate_section) */
end_comment

begin_define
define|#
directive|define
name|coff_relocate_section
value|NULL
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|coff_bfd_link_hash_table_create
end_ifndef

begin_define
define|#
directive|define
name|coff_bfd_link_hash_table_create
value|_bfd_generic_link_hash_table_create
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|coff_bfd_link_add_symbols
end_ifndef

begin_define
define|#
directive|define
name|coff_bfd_link_add_symbols
value|_bfd_generic_link_add_symbols
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|coff_bfd_final_link
value|_bfd_generic_final_link
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! defined (coff_relocate_section) */
end_comment

begin_define
define|#
directive|define
name|coff_bfd_link_split_section
value|_bfd_generic_link_split_section
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|coff_start_final_link
end_ifndef

begin_define
define|#
directive|define
name|coff_start_final_link
value|NULL
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|coff_adjust_symndx
end_ifndef

begin_define
define|#
directive|define
name|coff_adjust_symndx
value|NULL
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|coff_link_add_one_symbol
end_ifndef

begin_define
define|#
directive|define
name|coff_link_add_one_symbol
value|_bfd_generic_link_add_one_symbol
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|CONST
name|bfd_coff_backend_data
name|bfd_coff_std_swap_table
init|=
block|{
name|coff_swap_aux_in
block|,
name|coff_swap_sym_in
block|,
name|coff_swap_lineno_in
block|,
name|coff_swap_aux_out
block|,
name|coff_swap_sym_out
block|,
name|coff_swap_lineno_out
block|,
name|coff_swap_reloc_out
block|,
name|coff_swap_filehdr_out
block|,
name|coff_swap_aouthdr_out
block|,
name|coff_swap_scnhdr_out
block|,
name|FILHSZ
block|,
name|AOUTSZ
block|,
name|SCNHSZ
block|,
name|SYMESZ
block|,
name|AUXESZ
block|,
name|RELSZ
block|,
name|LINESZ
block|,
ifdef|#
directive|ifdef
name|COFF_LONG_FILENAMES
name|true
block|,
else|#
directive|else
name|false
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|COFF_LONG_SECTION_NAMES
name|true
block|,
else|#
directive|else
name|false
block|,
endif|#
directive|endif
name|COFF_DEFAULT_SECTION_ALIGNMENT_POWER
block|,
name|coff_swap_filehdr_in
block|,
name|coff_swap_aouthdr_in
block|,
name|coff_swap_scnhdr_in
block|,
name|coff_swap_reloc_in
block|,
name|coff_bad_format_hook
block|,
name|coff_set_arch_mach_hook
block|,
name|coff_mkobject_hook
block|,
name|styp_to_sec_flags
block|,
name|coff_set_alignment_hook
block|,
name|coff_slurp_symbol_table
block|,
name|symname_in_debug_hook
block|,
name|coff_pointerize_aux_hook
block|,
name|coff_print_aux
block|,
name|coff_reloc16_extra_cases
block|,
name|coff_reloc16_estimate
block|,
name|coff_sym_is_global
block|,
name|coff_compute_section_file_positions
block|,
name|coff_start_final_link
block|,
name|coff_relocate_section
block|,
name|coff_rtype_to_howto
block|,
name|coff_adjust_symndx
block|,
name|coff_link_add_one_symbol
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|coff_close_and_cleanup
value|_bfd_generic_close_and_cleanup
end_define

begin_define
define|#
directive|define
name|coff_bfd_free_cached_info
value|_bfd_generic_bfd_free_cached_info
end_define

begin_define
define|#
directive|define
name|coff_get_section_contents
value|_bfd_generic_get_section_contents
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|coff_bfd_copy_private_symbol_data
end_ifndef

begin_define
define|#
directive|define
name|coff_bfd_copy_private_symbol_data
value|_bfd_generic_bfd_copy_private_symbol_data
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|coff_bfd_copy_private_section_data
end_ifndef

begin_define
define|#
directive|define
name|coff_bfd_copy_private_section_data
value|_bfd_generic_bfd_copy_private_section_data
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|coff_bfd_copy_private_bfd_data
end_ifndef

begin_define
define|#
directive|define
name|coff_bfd_copy_private_bfd_data
value|_bfd_generic_bfd_copy_private_bfd_data
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|coff_bfd_merge_private_bfd_data
value|_bfd_generic_bfd_merge_private_bfd_data
end_define

begin_define
define|#
directive|define
name|coff_bfd_set_private_flags
value|_bfd_generic_bfd_set_private_flags
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|coff_bfd_print_private_bfd_data
end_ifndef

begin_define
define|#
directive|define
name|coff_bfd_print_private_bfd_data
value|_bfd_generic_bfd_print_private_bfd_data
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|coff_bfd_is_local_label_name
end_ifndef

begin_define
define|#
directive|define
name|coff_bfd_is_local_label_name
value|_bfd_coff_is_local_label_name
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|coff_read_minisymbols
end_ifndef

begin_define
define|#
directive|define
name|coff_read_minisymbols
value|_bfd_generic_read_minisymbols
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|coff_minisymbol_to_symbol
end_ifndef

begin_define
define|#
directive|define
name|coff_minisymbol_to_symbol
value|_bfd_generic_minisymbol_to_symbol
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The reloc lookup routine must be supplied by each individual COFF    backend.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|coff_bfd_reloc_type_lookup
end_ifndef

begin_define
define|#
directive|define
name|coff_bfd_reloc_type_lookup
value|_bfd_norelocs_bfd_reloc_type_lookup
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|coff_bfd_get_relocated_section_contents
end_ifndef

begin_define
define|#
directive|define
name|coff_bfd_get_relocated_section_contents
define|\
value|bfd_generic_get_relocated_section_contents
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|coff_bfd_relax_section
end_ifndef

begin_define
define|#
directive|define
name|coff_bfd_relax_section
value|bfd_generic_relax_section
end_define

begin_endif
endif|#
directive|endif
end_endif

end_unit

