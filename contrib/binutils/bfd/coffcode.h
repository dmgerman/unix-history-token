begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Support for the generic parts of most COFF variants, for BFD.    Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,    2000, 2001, 2002    Free Software Foundation, Inc.    Written by Cygnus Support.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Most of this hacked by  Steve Chamberlain, 			sac@cygnus.com */
end_comment

begin_comment
comment|/*  SECTION 	coff backends  	BFD supports a number of different flavours of coff format. 	The major differences between formats are the sizes and 	alignments of fields in structures on disk, and the occasional 	extra field.  	Coff in all its varieties is implemented with a few common 	files and a number of implementation specific files. For 	example, The 88k bcs coff format is implemented in the file 	@file{coff-m88k.c}. This file @code{#include}s 	@file{coff/m88k.h} which defines the external structure of the 	coff format for the 88k, and @file{coff/internal.h} which 	defines the internal structure. @file{coff-m88k.c} also 	defines the relocations used by the 88k format 	@xref{Relocations}.  	The Intel i960 processor version of coff is implemented in 	@file{coff-i960.c}. This file has the same structure as 	@file{coff-m88k.c}, except that it includes @file{coff/i960.h} 	rather than @file{coff-m88k.h}.  SUBSECTION 	Porting to a new version of coff  	The recommended method is to select from the existing 	implementations the version of coff which is most like the one 	you want to use.  For example, we'll say that i386 coff is 	the one you select, and that your coff flavour is called foo. 	Copy @file{i386coff.c} to @file{foocoff.c}, copy 	@file{../include/coff/i386.h} to @file{../include/coff/foo.h}, 	and add the lines to @file{targets.c} and @file{Makefile.in} 	so that your new back end is used. Alter the shapes of the 	structures in @file{../include/coff/foo.h} so that they match 	what you need. You will probably also have to add 	@code{#ifdef}s to the code in @file{coff/internal.h} and 	@file{coffcode.h} if your version of coff is too wild.  	You can verify that your new BFD backend works quite simply by 	building @file{objdump} from the @file{binutils} directory, 	and making sure that its version of what's going on and your 	host system's idea (assuming it has the pretty standard coff 	dump utility, usually called @code{att-dump} or just 	@code{dump}) are the same.  Then clean up your code, and send 	what you've done to Cygnus. Then your stuff will be in the 	next release, and you won't have to keep integrating it.  SUBSECTION 	How the coff backend works  SUBSUBSECTION 	File layout  	The Coff backend is split into generic routines that are 	applicable to any Coff target and routines that are specific 	to a particular target.  The target-specific routines are 	further split into ones which are basically the same for all 	Coff targets except that they use the external symbol format 	or use different values for certain constants.  	The generic routines are in @file{coffgen.c}.  These routines 	work for any Coff target.  They use some hooks into the target 	specific code; the hooks are in a @code{bfd_coff_backend_data} 	structure, one of which exists for each target.  	The essentially similar target-specific routines are in 	@file{coffcode.h}.  This header file includes executable C code. 	The various Coff targets first include the appropriate Coff 	header file, make any special defines that are needed, and 	then include @file{coffcode.h}.  	Some of the Coff targets then also have additional routines in 	the target source file itself.  	For example, @file{coff-i960.c} includes 	@file{coff/internal.h} and @file{coff/i960.h}.  It then 	defines a few constants, such as @code{I960}, and includes 	@file{coffcode.h}.  Since the i960 has complex relocation 	types, @file{coff-i960.c} also includes some code to 	manipulate the i960 relocs.  This code is not in 	@file{coffcode.h} because it would not be used by any other 	target.  SUBSUBSECTION 	Bit twiddling  	Each flavour of coff supported in BFD has its own header file 	describing the external layout of the structures. There is also 	an internal description of the coff layout, in 	@file{coff/internal.h}. A major function of the 	coff backend is swapping the bytes and twiddling the bits to 	translate the external form of the structures into the normal 	internal form. This is all performed in the 	@code{bfd_swap}_@i{thing}_@i{direction} routines. Some 	elements are different sizes between different versions of 	coff; it is the duty of the coff version specific include file 	to override the definitions of various packing routines in 	@file{coffcode.h}. E.g., the size of line number entry in coff is 	sometimes 16 bits, and sometimes 32 bits. @code{#define}ing 	@code{PUT_LNSZ_LNNO} and @code{GET_LNSZ_LNNO} will select the 	correct one. No doubt, some day someone will find a version of 	coff which has a varying field size not catered to at the 	moment. To port BFD, that person will have to add more @code{#defines}. 	Three of the bit twiddling routines are exported to 	@code{gdb}; @code{coff_swap_aux_in}, @code{coff_swap_sym_in} 	and @code{coff_swap_lineno_in}. @code{GDB} reads the symbol 	table on its own, but uses BFD to fix things up.  More of the 	bit twiddlers are exported for @code{gas}; 	@code{coff_swap_aux_out}, @code{coff_swap_sym_out}, 	@code{coff_swap_lineno_out}, @code{coff_swap_reloc_out}, 	@code{coff_swap_filehdr_out}, @code{coff_swap_aouthdr_out}, 	@code{coff_swap_scnhdr_out}. @code{Gas} currently keeps track 	of all the symbol table and reloc drudgery itself, thereby 	saving the internal BFD overhead, but uses BFD to swap things 	on the way out, making cross ports much safer.  Doing so also 	allows BFD (and thus the linker) to use the same header files 	as @code{gas}, which makes one avenue to disaster disappear.  SUBSUBSECTION 	Symbol reading  	The simple canonical form for symbols used by BFD is not rich 	enough to keep all the information available in a coff symbol 	table. The back end gets around this problem by keeping the original 	symbol table around, "behind the scenes".  	When a symbol table is requested (through a call to 	@code{bfd_canonicalize_symtab}), a request gets through to 	@code{coff_get_normalized_symtab}. This reads the symbol table from 	the coff file and swaps all the structures inside into the 	internal form. It also fixes up all the pointers in the table 	(represented in the file by offsets from the first symbol in 	the table) into physical pointers to elements in the new 	internal table. This involves some work since the meanings of 	fields change depending upon context: a field that is a 	pointer to another structure in the symbol table at one moment 	may be the size in bytes of a structure at the next.  Another 	pass is made over the table. All symbols which mark file names 	(<<C_FILE>> symbols) are modified so that the internal 	string points to the value in the auxent (the real filename) 	rather than the normal text associated with the symbol 	(@code{".file"}).  	At this time the symbol names are moved around. Coff stores 	all symbols less than nine characters long physically 	within the symbol table; longer strings are kept at the end of 	the file in the string 	table. This pass moves all strings 	into memory and replaces them with pointers to the strings.  	The symbol table is massaged once again, this time to create 	the canonical table used by the BFD application. Each symbol 	is inspected in turn, and a decision made (using the 	@code{sclass} field) about the various flags to set in the 	@code{asymbol}.  @xref{Symbols}. The generated canonical table 	shares strings with the hidden internal symbol table.  	Any linenumbers are read from the coff file too, and attached 	to the symbols which own the functions the linenumbers belong to.  SUBSUBSECTION 	Symbol writing  	Writing a symbol to a coff file which didn't come from a coff 	file will lose any debugging information. The @code{asymbol} 	structure remembers the BFD from which the symbol was taken, and on 	output the back end makes sure that the same destination target as 	source target is present.  	When the symbols have come from a coff file then all the 	debugging information is preserved.  	Symbol tables are provided for writing to the back end in a 	vector of pointers to pointers. This allows applications like 	the linker to accumulate and output large symbol tables 	without having to do too much byte copying.  	This function runs through the provided symbol table and 	patches each symbol marked as a file place holder 	(@code{C_FILE}) to point to the next file place holder in the 	list. It also marks each @code{offset} field in the list with 	the offset from the first symbol of the current symbol.  	Another function of this procedure is to turn the canonical 	value form of BFD into the form used by coff. Internally, BFD 	expects symbol values to be offsets from a section base; so a 	symbol physically at 0x120, but in a section starting at 	0x100, would have the value 0x20. Coff expects symbols to 	contain their final value, so symbols have their values 	changed at this point to reflect their sum with their owning 	section.  This transformation uses the<<output_section>> field of the @code{asymbol}'s 	@code{asection} @xref{Sections}.  	o<<coff_mangle_symbols>>  	This routine runs though the provided symbol table and uses 	the offsets generated by the previous pass and the pointers 	generated when the symbol table was read in to create the 	structured hierachy required by coff. It changes each pointer 	to a symbol into the index into the symbol table of the asymbol.  	o<<coff_write_symbols>>  	This routine runs through the symbol table and patches up the 	symbols from their internal form into the coff way, calls the 	bit twiddlers, and writes out the table to the file.  */
end_comment

begin_comment
comment|/* INTERNAL_DEFINITION 	coff_symbol_type  DESCRIPTION 	The hidden information for an<<asymbol>> is described in a<<combined_entry_type>>:  CODE_FRAGMENT . .typedef struct coff_ptr_struct .{ .  {* Remembers the offset from the first symbol in the file for .     this symbol. Generated by coff_renumber_symbols. *} .  unsigned int offset; . .  {* Should the value of this symbol be renumbered.  Used for .     XCOFF C_BSTAT symbols.  Set by coff_slurp_symbol_table.  *} .  unsigned int fix_value : 1; . .  {* Should the tag field of this symbol be renumbered. .     Created by coff_pointerize_aux. *} .  unsigned int fix_tag : 1; . .  {* Should the endidx field of this symbol be renumbered. .     Created by coff_pointerize_aux. *} .  unsigned int fix_end : 1; . .  {* Should the x_csect.x_scnlen field be renumbered. .     Created by coff_pointerize_aux. *} .  unsigned int fix_scnlen : 1; . .  {* Fix up an XCOFF C_BINCL/C_EINCL symbol.  The value is the .     index into the line number entries.  Set by coff_slurp_symbol_table.  *} .  unsigned int fix_line : 1; . .  {* The container for the symbol structure as read and translated .     from the file. *} .  union .  { .    union internal_auxent auxent; .    struct internal_syment syment; .  } u; .} combined_entry_type; . . .{* Each canonical asymbol really looks like this: *} . .typedef struct coff_symbol_struct .{ .  {* The actual symbol which the rest of BFD works with *} .  asymbol symbol; . .  {* A pointer to the hidden information for this symbol *} .  combined_entry_type *native; . .  {* A pointer to the linenumber information for this symbol *} .  struct lineno_cache_entry *lineno; . .  {* Have the line numbers been relocated yet ? *} .  boolean done_lineno; .} coff_symbol_type;  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|COFF_WITH_PE
end_ifdef

begin_include
include|#
directive|include
file|"peicode.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"coffswap.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|STRING_SIZE_SIZE
value|(4)
end_define

begin_decl_stmt
specifier|static
name|long
name|sec_to_styp_flags
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|flagword
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|styp_to_sec_flags
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
specifier|const
name|char
operator|*
operator|,
name|asection
operator|*
operator|,
name|flagword
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|coff_bad_format_hook
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|coff_set_custom_section_alignment
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
specifier|const
expr|struct
name|coff_section_alignment_entry
operator|*
operator|,
specifier|const
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|coff_new_section_hook
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|coff_set_arch_mach_hook
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|coff_write_relocs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|coff_set_flags
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|unsigned
name|int
operator|*
operator|,
name|unsigned
name|short
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|coff_set_arch_mach
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|enum
name|bfd_architecture
operator|,
name|unsigned
name|long
operator|)
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|coff_compute_section_file_positions
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|coff_write_object_contents
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|coff_set_section_contents
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|,
name|file_ptr
operator|,
name|bfd_size_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|PTR
name|buy_and_read
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|file_ptr
operator|,
name|bfd_size_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|coff_slurp_line_table
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|coff_slurp_symbol_table
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|coff_symbol_classification
name|coff_classify_symbol
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|internal_syment
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|coff_slurp_reloc_table
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|asymbol
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|coff_canonicalize_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|arelent
operator|*
operator|*
operator|,
name|asymbol
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|coff_mkobject_hook
end_ifndef

begin_decl_stmt
specifier|static
name|PTR
name|coff_mkobject_hook
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|COFF_WITH_PE
end_ifdef

begin_decl_stmt
specifier|static
name|flagword
name|handle_COMDAT
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|flagword
operator|,
name|PTR
operator|,
specifier|const
name|char
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* void warning(); */
end_comment

begin_comment
comment|/* Return a word with STYP_* (scnhdr.s_flags) flags set to represent    the incoming SEC_* flags.  The inverse of this function is    styp_to_sec_flags().  NOTE: If you add to/change this routine, you    should probably mirror the changes in styp_to_sec_flags().  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|COFF_WITH_PE
end_ifndef

begin_comment
comment|/* Macros for setting debugging flags.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|STYP_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|STYP_XCOFF_DEBUG
value|STYP_DEBUG
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|STYP_XCOFF_DEBUG
value|STYP_INFO
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|COFF_ALIGN_IN_S_FLAGS
end_ifdef

begin_define
define|#
directive|define
name|STYP_DEBUG_INFO
value|STYP_DSECT
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|STYP_DEBUG_INFO
value|STYP_INFO
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|long
name|sec_to_styp_flags
parameter_list|(
name|sec_name
parameter_list|,
name|sec_flags
parameter_list|)
specifier|const
name|char
modifier|*
name|sec_name
decl_stmt|;
name|flagword
name|sec_flags
decl_stmt|;
block|{
name|long
name|styp_flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|sec_name
argument_list|,
name|_TEXT
argument_list|)
condition|)
block|{
name|styp_flags
operator|=
name|STYP_TEXT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|sec_name
argument_list|,
name|_DATA
argument_list|)
condition|)
block|{
name|styp_flags
operator|=
name|STYP_DATA
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|sec_name
argument_list|,
name|_BSS
argument_list|)
condition|)
block|{
name|styp_flags
operator|=
name|STYP_BSS
expr_stmt|;
ifdef|#
directive|ifdef
name|_COMMENT
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|sec_name
argument_list|,
name|_COMMENT
argument_list|)
condition|)
block|{
name|styp_flags
operator|=
name|STYP_INFO
expr_stmt|;
endif|#
directive|endif
comment|/* _COMMENT */
ifdef|#
directive|ifdef
name|_LIB
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|sec_name
argument_list|,
name|_LIB
argument_list|)
condition|)
block|{
name|styp_flags
operator|=
name|STYP_LIB
expr_stmt|;
endif|#
directive|endif
comment|/* _LIB */
ifdef|#
directive|ifdef
name|_LIT
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|sec_name
argument_list|,
name|_LIT
argument_list|)
condition|)
block|{
name|styp_flags
operator|=
name|STYP_LIT
expr_stmt|;
endif|#
directive|endif
comment|/* _LIT */
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|sec_name
argument_list|,
literal|".debug"
argument_list|,
literal|6
argument_list|)
condition|)
block|{
comment|/* Handle the XCOFF debug section and DWARF2 debug sections.  */
if|if
condition|(
operator|!
name|sec_name
index|[
literal|6
index|]
condition|)
name|styp_flags
operator|=
name|STYP_XCOFF_DEBUG
expr_stmt|;
else|else
name|styp_flags
operator|=
name|STYP_DEBUG_INFO
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|sec_name
argument_list|,
literal|".stab"
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|styp_flags
operator|=
name|STYP_DEBUG_INFO
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|COFF_LONG_SECTION_NAMES
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|sec_name
argument_list|,
literal|".gnu.linkonce.wi."
argument_list|,
literal|17
argument_list|)
condition|)
block|{
name|styp_flags
operator|=
name|STYP_DEBUG_INFO
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RS6000COFF_C
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|sec_name
argument_list|,
name|_PAD
argument_list|)
condition|)
block|{
name|styp_flags
operator|=
name|STYP_PAD
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|sec_name
argument_list|,
name|_LOADER
argument_list|)
condition|)
block|{
name|styp_flags
operator|=
name|STYP_LOADER
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|sec_name
argument_list|,
name|_EXCEPT
argument_list|)
condition|)
block|{
name|styp_flags
operator|=
name|STYP_EXCEPT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|sec_name
argument_list|,
name|_TYPCHK
argument_list|)
condition|)
block|{
name|styp_flags
operator|=
name|STYP_TYPCHK
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Try and figure out what it should be */
elseif|else
if|if
condition|(
name|sec_flags
operator|&
name|SEC_CODE
condition|)
block|{
name|styp_flags
operator|=
name|STYP_TEXT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sec_flags
operator|&
name|SEC_DATA
condition|)
block|{
name|styp_flags
operator|=
name|STYP_DATA
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sec_flags
operator|&
name|SEC_READONLY
condition|)
block|{
ifdef|#
directive|ifdef
name|STYP_LIT
comment|/* 29k readonly text/data section */
name|styp_flags
operator|=
name|STYP_LIT
expr_stmt|;
else|#
directive|else
name|styp_flags
operator|=
name|STYP_TEXT
expr_stmt|;
endif|#
directive|endif
comment|/* STYP_LIT */
block|}
elseif|else
if|if
condition|(
name|sec_flags
operator|&
name|SEC_LOAD
condition|)
block|{
name|styp_flags
operator|=
name|STYP_TEXT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sec_flags
operator|&
name|SEC_ALLOC
condition|)
block|{
name|styp_flags
operator|=
name|STYP_BSS
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|STYP_CLINK
if|if
condition|(
name|sec_flags
operator|&
name|SEC_CLINK
condition|)
name|styp_flags
operator||=
name|STYP_CLINK
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|STYP_BLOCK
if|if
condition|(
name|sec_flags
operator|&
name|SEC_BLOCK
condition|)
name|styp_flags
operator||=
name|STYP_BLOCK
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|STYP_NOLOAD
if|if
condition|(
operator|(
name|sec_flags
operator|&
operator|(
name|SEC_NEVER_LOAD
operator||
name|SEC_COFF_SHARED_LIBRARY
operator|)
operator|)
operator|!=
literal|0
condition|)
name|styp_flags
operator||=
name|STYP_NOLOAD
expr_stmt|;
endif|#
directive|endif
return|return
name|styp_flags
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* COFF_WITH_PE */
end_comment

begin_comment
comment|/* The PE version; see above for the general comments.  The non-PE    case seems to be more guessing, and breaks PE format; specifically,    .rdata is readonly, but it sure ain't text.  Really, all this    should be set up properly in gas (or whatever assembler is in use),    and honor whatever objcopy/strip, etc. sent us as input.  */
end_comment

begin_function
specifier|static
name|long
name|sec_to_styp_flags
parameter_list|(
name|sec_name
parameter_list|,
name|sec_flags
parameter_list|)
specifier|const
name|char
modifier|*
name|sec_name
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|flagword
name|sec_flags
decl_stmt|;
block|{
name|long
name|styp_flags
init|=
literal|0
decl_stmt|;
comment|/* caution: there are at least three groups of symbols that have      very similar bits and meanings: IMAGE_SCN*, SEC_*, and STYP_*.      SEC_* are the BFD internal flags, used for generic BFD      information.  STYP_* are the COFF section flags which appear in      COFF files.  IMAGE_SCN_* are the PE section flags which appear in      PE files.  The STYP_* flags and the IMAGE_SCN_* flags overlap,      but there are more IMAGE_SCN_* flags.  */
comment|/* skip LOAD */
comment|/* READONLY later */
comment|/* skip RELOC */
if|if
condition|(
operator|(
name|sec_flags
operator|&
name|SEC_CODE
operator|)
operator|!=
literal|0
condition|)
name|styp_flags
operator||=
name|IMAGE_SCN_CNT_CODE
expr_stmt|;
if|if
condition|(
operator|(
name|sec_flags
operator|&
name|SEC_DATA
operator|)
operator|!=
literal|0
condition|)
name|styp_flags
operator||=
name|IMAGE_SCN_CNT_INITIALIZED_DATA
expr_stmt|;
if|if
condition|(
operator|(
name|sec_flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|sec_flags
operator|&
name|SEC_LOAD
operator|)
operator|==
literal|0
condition|)
name|styp_flags
operator||=
name|IMAGE_SCN_CNT_UNINITIALIZED_DATA
expr_stmt|;
comment|/* ==STYP_BSS */
comment|/* skip ROM */
comment|/* skip constRUCTOR */
comment|/* skip CONTENTS */
ifdef|#
directive|ifdef
name|STYP_NOLOAD
if|if
condition|(
operator|(
name|sec_flags
operator|&
operator|(
name|SEC_NEVER_LOAD
operator||
name|SEC_COFF_SHARED_LIBRARY
operator|)
operator|)
operator|!=
literal|0
condition|)
name|styp_flags
operator||=
name|STYP_NOLOAD
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|sec_flags
operator|&
name|SEC_IS_COMMON
operator|)
operator|!=
literal|0
condition|)
name|styp_flags
operator||=
name|IMAGE_SCN_LNK_COMDAT
expr_stmt|;
if|if
condition|(
operator|(
name|sec_flags
operator|&
name|SEC_DEBUGGING
operator|)
operator|!=
literal|0
condition|)
name|styp_flags
operator||=
name|IMAGE_SCN_MEM_DISCARDABLE
expr_stmt|;
if|if
condition|(
operator|(
name|sec_flags
operator|&
name|SEC_EXCLUDE
operator|)
operator|!=
literal|0
condition|)
name|styp_flags
operator||=
name|IMAGE_SCN_LNK_REMOVE
expr_stmt|;
if|if
condition|(
operator|(
name|sec_flags
operator|&
name|SEC_NEVER_LOAD
operator|)
operator|!=
literal|0
condition|)
name|styp_flags
operator||=
name|IMAGE_SCN_LNK_REMOVE
expr_stmt|;
comment|/* skip IN_MEMORY */
comment|/* skip SORT */
if|if
condition|(
name|sec_flags
operator|&
name|SEC_LINK_ONCE
condition|)
name|styp_flags
operator||=
name|IMAGE_SCN_LNK_COMDAT
expr_stmt|;
comment|/* skip LINK_DUPLICATES */
comment|/* skip LINKER_CREATED */
comment|/* For now, the read/write bits are mapped onto SEC_READONLY, even      though the semantics don't quite match.  The bits from the input      are retained in pei_section_data(abfd, section)->pe_flags */
name|styp_flags
operator||=
name|IMAGE_SCN_MEM_READ
expr_stmt|;
comment|/* always readable.  */
if|if
condition|(
operator|(
name|sec_flags
operator|&
name|SEC_READONLY
operator|)
operator|==
literal|0
condition|)
name|styp_flags
operator||=
name|IMAGE_SCN_MEM_WRITE
expr_stmt|;
comment|/* Invert READONLY for write */
if|if
condition|(
name|sec_flags
operator|&
name|SEC_CODE
condition|)
name|styp_flags
operator||=
name|IMAGE_SCN_MEM_EXECUTE
expr_stmt|;
comment|/* CODE->EXECUTE */
if|if
condition|(
name|sec_flags
operator|&
name|SEC_SHARED
condition|)
name|styp_flags
operator||=
name|IMAGE_SCN_MEM_SHARED
expr_stmt|;
comment|/* Shared remains meaningful */
return|return
name|styp_flags
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* COFF_WITH_PE */
end_comment

begin_comment
comment|/* Return a word with SEC_* flags set to represent the incoming STYP_*    flags (from scnhdr.s_flags).  The inverse of this function is    sec_to_styp_flags().  NOTE: If you add to/change this routine, you    should probably mirror the changes in sec_to_styp_flags().  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|COFF_WITH_PE
end_ifndef

begin_function
specifier|static
name|boolean
name|styp_to_sec_flags
parameter_list|(
name|abfd
parameter_list|,
name|hdr
parameter_list|,
name|name
parameter_list|,
name|section
parameter_list|,
name|flags_ptr
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|PTR
name|hdr
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|asection
modifier|*
name|section
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|flagword
modifier|*
name|flags_ptr
decl_stmt|;
block|{
name|struct
name|internal_scnhdr
modifier|*
name|internal_s
init|=
operator|(
expr|struct
name|internal_scnhdr
operator|*
operator|)
name|hdr
decl_stmt|;
name|long
name|styp_flags
init|=
name|internal_s
operator|->
name|s_flags
decl_stmt|;
name|flagword
name|sec_flags
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|STYP_BLOCK
if|if
condition|(
name|styp_flags
operator|&
name|STYP_BLOCK
condition|)
name|sec_flags
operator||=
name|SEC_BLOCK
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|STYP_CLINK
if|if
condition|(
name|styp_flags
operator|&
name|STYP_CLINK
condition|)
name|sec_flags
operator||=
name|SEC_CLINK
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|STYP_NOLOAD
if|if
condition|(
name|styp_flags
operator|&
name|STYP_NOLOAD
condition|)
name|sec_flags
operator||=
name|SEC_NEVER_LOAD
expr_stmt|;
endif|#
directive|endif
comment|/* STYP_NOLOAD */
comment|/* For 386 COFF, at least, an unloadable text or data section is      actually a shared library section.  */
if|if
condition|(
name|styp_flags
operator|&
name|STYP_TEXT
condition|)
block|{
if|if
condition|(
name|sec_flags
operator|&
name|SEC_NEVER_LOAD
condition|)
name|sec_flags
operator||=
name|SEC_CODE
operator||
name|SEC_COFF_SHARED_LIBRARY
expr_stmt|;
else|else
name|sec_flags
operator||=
name|SEC_CODE
operator||
name|SEC_LOAD
operator||
name|SEC_ALLOC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|styp_flags
operator|&
name|STYP_DATA
condition|)
block|{
if|if
condition|(
name|sec_flags
operator|&
name|SEC_NEVER_LOAD
condition|)
name|sec_flags
operator||=
name|SEC_DATA
operator||
name|SEC_COFF_SHARED_LIBRARY
expr_stmt|;
else|else
name|sec_flags
operator||=
name|SEC_DATA
operator||
name|SEC_LOAD
operator||
name|SEC_ALLOC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|styp_flags
operator|&
name|STYP_BSS
condition|)
block|{
ifdef|#
directive|ifdef
name|BSS_NOLOAD_IS_SHARED_LIBRARY
if|if
condition|(
name|sec_flags
operator|&
name|SEC_NEVER_LOAD
condition|)
name|sec_flags
operator||=
name|SEC_ALLOC
operator||
name|SEC_COFF_SHARED_LIBRARY
expr_stmt|;
else|else
endif|#
directive|endif
name|sec_flags
operator||=
name|SEC_ALLOC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|styp_flags
operator|&
name|STYP_INFO
condition|)
block|{
comment|/* We mark these as SEC_DEBUGGING, but only if COFF_PAGE_SIZE is 	 defined.  coff_compute_section_file_positions uses 	 COFF_PAGE_SIZE to ensure that the low order bits of the 	 section VMA and the file offset match.  If we don't know 	 COFF_PAGE_SIZE, we can't ensure the correct correspondence, 	 and demand page loading of the file will fail.  */
if|#
directive|if
name|defined
argument_list|(
name|COFF_PAGE_SIZE
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|COFF_ALIGN_IN_S_FLAGS
argument_list|)
name|sec_flags
operator||=
name|SEC_DEBUGGING
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|styp_flags
operator|&
name|STYP_PAD
condition|)
name|sec_flags
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|_TEXT
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sec_flags
operator|&
name|SEC_NEVER_LOAD
condition|)
name|sec_flags
operator||=
name|SEC_CODE
operator||
name|SEC_COFF_SHARED_LIBRARY
expr_stmt|;
else|else
name|sec_flags
operator||=
name|SEC_CODE
operator||
name|SEC_LOAD
operator||
name|SEC_ALLOC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|_DATA
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sec_flags
operator|&
name|SEC_NEVER_LOAD
condition|)
name|sec_flags
operator||=
name|SEC_DATA
operator||
name|SEC_COFF_SHARED_LIBRARY
expr_stmt|;
else|else
name|sec_flags
operator||=
name|SEC_DATA
operator||
name|SEC_LOAD
operator||
name|SEC_ALLOC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|_BSS
argument_list|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|BSS_NOLOAD_IS_SHARED_LIBRARY
if|if
condition|(
name|sec_flags
operator|&
name|SEC_NEVER_LOAD
condition|)
name|sec_flags
operator||=
name|SEC_ALLOC
operator||
name|SEC_COFF_SHARED_LIBRARY
expr_stmt|;
else|else
endif|#
directive|endif
name|sec_flags
operator||=
name|SEC_ALLOC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".debug"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
ifdef|#
directive|ifdef
name|_COMMENT
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
name|_COMMENT
argument_list|)
operator|==
literal|0
endif|#
directive|endif
ifdef|#
directive|ifdef
name|COFF_LONG_SECTION_NAMES
operator|||
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".gnu.linkonce.wi."
argument_list|,
literal|17
argument_list|)
operator|==
literal|0
endif|#
directive|endif
operator|||
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".stab"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|COFF_PAGE_SIZE
name|sec_flags
operator||=
name|SEC_DEBUGGING
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|_LIB
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|_LIB
argument_list|)
operator|==
literal|0
condition|)
empty_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|_LIT
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|_LIT
argument_list|)
operator|==
literal|0
condition|)
name|sec_flags
operator|=
name|SEC_LOAD
operator||
name|SEC_ALLOC
operator||
name|SEC_READONLY
expr_stmt|;
endif|#
directive|endif
else|else
name|sec_flags
operator||=
name|SEC_ALLOC
operator||
name|SEC_LOAD
expr_stmt|;
ifdef|#
directive|ifdef
name|STYP_LIT
comment|/* A29k readonly text/data section type */
if|if
condition|(
operator|(
name|styp_flags
operator|&
name|STYP_LIT
operator|)
operator|==
name|STYP_LIT
condition|)
name|sec_flags
operator|=
operator|(
name|SEC_LOAD
operator||
name|SEC_ALLOC
operator||
name|SEC_READONLY
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* STYP_LIT */
ifdef|#
directive|ifdef
name|STYP_OTHER_LOAD
comment|/* Other loaded sections */
if|if
condition|(
name|styp_flags
operator|&
name|STYP_OTHER_LOAD
condition|)
name|sec_flags
operator|=
operator|(
name|SEC_LOAD
operator||
name|SEC_ALLOC
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* STYP_SDATA */
if|#
directive|if
name|defined
argument_list|(
name|COFF_LONG_SECTION_NAMES
argument_list|)
operator|&&
name|defined
argument_list|(
name|COFF_SUPPORT_GNU_LINKONCE
argument_list|)
comment|/* As a GNU extension, if the name begins with .gnu.linkonce, we      only link a single copy of the section.  This is used to support      g++.  g++ will emit each template expansion in its own section.      The symbols will be defined as weak, so that multiple definitions      are permitted.  The GNU linker extension is to actually discard      all but one of the sections.  */
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".gnu.linkonce"
argument_list|,
sizeof|sizeof
expr|".gnu.linkonce"
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|sec_flags
operator||=
name|SEC_LINK_ONCE
operator||
name|SEC_LINK_DUPLICATES_DISCARD
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|flags_ptr
operator|==
name|NULL
condition|)
return|return
name|false
return|;
operator|*
name|flags_ptr
operator|=
name|sec_flags
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* COFF_WITH_PE */
end_comment

begin_function
specifier|static
name|flagword
name|handle_COMDAT
parameter_list|(
name|abfd
parameter_list|,
name|sec_flags
parameter_list|,
name|hdr
parameter_list|,
name|name
parameter_list|,
name|section
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|flagword
name|sec_flags
decl_stmt|;
name|PTR
name|hdr
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
block|{
name|struct
name|internal_scnhdr
modifier|*
name|internal_s
init|=
operator|(
expr|struct
name|internal_scnhdr
operator|*
operator|)
name|hdr
decl_stmt|;
name|bfd_byte
modifier|*
name|esymstart
decl_stmt|,
modifier|*
name|esym
decl_stmt|,
modifier|*
name|esymend
decl_stmt|;
name|int
name|seen_state
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|target_name
init|=
name|NULL
decl_stmt|;
name|sec_flags
operator||=
name|SEC_LINK_ONCE
expr_stmt|;
comment|/* Unfortunately, the PE format stores essential information in      the symbol table, of all places.  We need to extract that      information now, so that objdump and the linker will know how      to handle the section without worrying about the symbols.  We      can't call slurp_symtab, because the linker doesn't want the      swapped symbols.  */
comment|/* COMDAT sections are special.  The first symbol is the section      symbol, which tells what kind of COMDAT section it is.  The      second symbol is the "comdat symbol" - the one with the      unique name.  GNU uses the section symbol for the unique      name; MS uses ".text" for every comdat section.  Sigh.  - DJ */
comment|/* This is not mirrored in sec_to_styp_flags(), but there      doesn't seem to be a need to, either, and it would at best be      rather messy.  */
if|if
condition|(
operator|!
name|_bfd_coff_get_external_symbols
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|sec_flags
return|;
name|esymstart
operator|=
name|esym
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|obj_coff_external_syms
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|esymend
operator|=
name|esym
operator|+
name|obj_raw_syment_count
argument_list|(
name|abfd
argument_list|)
operator|*
name|bfd_coff_symesz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
while|while
condition|(
name|esym
operator|<
name|esymend
condition|)
block|{
name|struct
name|internal_syment
name|isym
decl_stmt|;
name|char
name|buf
index|[
name|SYMNMLEN
operator|+
literal|1
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|symname
decl_stmt|;
name|bfd_coff_swap_sym_in
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|esym
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|isym
argument_list|)
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|internal_s
operator|->
name|s_name
argument_list|)
operator|>
name|SYMNMLEN
condition|)
block|{
comment|/* This case implies that the matching 	     symbol name will be in the string table.  */
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|isym
operator|.
name|n_scnum
operator|==
name|section
operator|->
name|target_index
condition|)
block|{
comment|/* According to the MSVC documentation, the first 	     TWO entries with the section # are both of 	     interest to us.  The first one is the "section 	     symbol" (section name).  The second is the comdat 	     symbol name.  Here, we've found the first 	     qualifying entry; we distinguish it from the 	     second with a state flag.  	     In the case of gas-generated (at least until that 	     is fixed) .o files, it isn't necessarily the 	     second one.  It may be some other later symbol.  	     Since gas also doesn't follow MS conventions and 	     emits the section similar to .text$<name>, where<something> is the name we're looking for, we 	     distinguish the two as follows:  	     If the section name is simply a section name (no 	     $) we presume it's MS-generated, and look at 	     precisely the second symbol for the comdat name. 	     If the section name has a $, we assume it's 	     gas-generated, and look for<something> (whatever 	     follows the $) as the comdat symbol.  */
comment|/* All 3 branches use this */
name|symname
operator|=
name|_bfd_coff_internal_syment_name
argument_list|(
name|abfd
argument_list|,
operator|&
name|isym
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|symname
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|seen_state
condition|)
block|{
case|case
literal|0
case|:
block|{
comment|/* The first time we've seen the symbol.  */
name|union
name|internal_auxent
name|aux
decl_stmt|;
name|seen_state
operator|=
literal|1
expr_stmt|;
comment|/* If it isn't the stuff we're expecting, die; 		   The MS documentation is vague, but it 		   appears that the second entry serves BOTH 		   as the comdat symbol and the defining 		   symbol record (either C_STAT or C_EXT, 		   possibly with an aux entry with debug 		   information if it's a function.)  It 		   appears the only way to find the second one 		   is to count.  (On Intel, they appear to be 		   adjacent, but on Alpha, they have been 		   found separated.)  		   Here, we think we've found the first one, 		   but there's some checking we can do to be 		   sure.  */
if|if
condition|(
operator|!
operator|(
name|isym
operator|.
name|n_sclass
operator|==
name|C_STAT
operator|&&
name|isym
operator|.
name|n_type
operator|==
name|T_NULL
operator|&&
name|isym
operator|.
name|n_value
operator|==
literal|0
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* FIXME LATER: MSVC generates section names 		   like .text for comdats.  Gas generates 		   names like .text$foo__Fv (in the case of a 		   function).  See comment above for more.  */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|symname
argument_list|)
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* This is the section symbol.  */
name|bfd_coff_swap_aux_in
argument_list|(
name|abfd
argument_list|,
call|(
name|PTR
call|)
argument_list|(
name|esym
operator|+
name|bfd_coff_symesz
argument_list|(
name|abfd
argument_list|)
argument_list|)
argument_list|,
name|isym
operator|.
name|n_type
argument_list|,
name|isym
operator|.
name|n_sclass
argument_list|,
literal|0
argument_list|,
name|isym
operator|.
name|n_numaux
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|aux
argument_list|)
expr_stmt|;
name|target_name
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|'$'
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_name
operator|!=
name|NULL
condition|)
block|{
comment|/* Gas mode.  */
name|seen_state
operator|=
literal|2
expr_stmt|;
comment|/* Skip the `$'.  */
name|target_name
operator|+=
literal|1
expr_stmt|;
block|}
comment|/* FIXME: Microsoft uses NODUPLICATES and 		   ASSOCIATIVE, but gnu uses ANY and 		   SAME_SIZE.  Unfortunately, gnu doesn't do 		   the comdat symbols right.  So, until we can 		   fix it to do the right thing, we are 		   temporarily disabling comdats for the MS 		   types (they're used in DLLs and C++, but we 		   don't support *their* C++ libraries anyway 		   - DJ.  */
comment|/* Cygwin does not follow the MS style, and 		   uses ANY and SAME_SIZE where NODUPLICATES 		   and ASSOCIATIVE should be used.  For 		   Interix, we just do the right thing up 		   front.  */
switch|switch
condition|(
name|aux
operator|.
name|x_scn
operator|.
name|x_comdat
condition|)
block|{
case|case
name|IMAGE_COMDAT_SELECT_NODUPLICATES
case|:
ifdef|#
directive|ifdef
name|STRICT_PE_FORMAT
name|sec_flags
operator||=
name|SEC_LINK_DUPLICATES_ONE_ONLY
expr_stmt|;
else|#
directive|else
name|sec_flags
operator|&=
operator|~
name|SEC_LINK_ONCE
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|IMAGE_COMDAT_SELECT_ANY
case|:
name|sec_flags
operator||=
name|SEC_LINK_DUPLICATES_DISCARD
expr_stmt|;
break|break;
case|case
name|IMAGE_COMDAT_SELECT_SAME_SIZE
case|:
name|sec_flags
operator||=
name|SEC_LINK_DUPLICATES_SAME_SIZE
expr_stmt|;
break|break;
case|case
name|IMAGE_COMDAT_SELECT_EXACT_MATCH
case|:
comment|/* Not yet fully implemented ??? */
name|sec_flags
operator||=
name|SEC_LINK_DUPLICATES_SAME_CONTENTS
expr_stmt|;
break|break;
comment|/* debug$S gets this case; other 		       implications ??? */
comment|/* There may be no symbol... we'll search 		       the whole table... Is this the right 		       place to play this game? Or should we do 		       it when reading it in.  */
case|case
name|IMAGE_COMDAT_SELECT_ASSOCIATIVE
case|:
ifdef|#
directive|ifdef
name|STRICT_PE_FORMAT
comment|/* FIXME: This is not currently implemented.  */
name|sec_flags
operator||=
name|SEC_LINK_DUPLICATES_DISCARD
expr_stmt|;
else|#
directive|else
name|sec_flags
operator|&=
operator|~
name|SEC_LINK_ONCE
expr_stmt|;
endif|#
directive|endif
break|break;
default|default:
comment|/* 0 means "no symbol" */
comment|/* debug$F gets this case; other 		       implications ??? */
name|sec_flags
operator||=
name|SEC_LINK_DUPLICATES_DISCARD
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
literal|2
case|:
comment|/* Gas mode: the first matching on partial name.  */
ifndef|#
directive|ifndef
name|TARGET_UNDERSCORE
define|#
directive|define
name|TARGET_UNDERSCORE
value|0
endif|#
directive|endif
comment|/* Is this the name we're looking for? */
if|if
condition|(
name|strcmp
argument_list|(
name|target_name
argument_list|,
name|symname
operator|+
operator|(
name|TARGET_UNDERSCORE
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Not the name we're looking for */
name|esym
operator|+=
operator|(
name|isym
operator|.
name|n_numaux
operator|+
literal|1
operator|)
operator|*
name|bfd_coff_symesz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Fall through.  */
case|case
literal|1
case|:
comment|/* MSVC mode: the lexically second symbol (or 		 drop through from the above).  */
block|{
name|char
modifier|*
name|newname
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
comment|/* This must the second symbol with the 		   section #.  It is the actual symbol name. 		   Intel puts the two adjacent, but Alpha (at 		   least) spreads them out.  */
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|bfd_comdat_info
argument_list|)
expr_stmt|;
name|section
operator|->
name|comdat
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|section
operator|->
name|comdat
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|section
operator|->
name|comdat
operator|->
name|symbol
operator|=
operator|(
name|esym
operator|-
name|esymstart
operator|)
operator|/
name|bfd_coff_symesz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|amt
operator|=
name|strlen
argument_list|(
name|symname
argument_list|)
operator|+
literal|1
expr_stmt|;
name|newname
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|newname
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|strcpy
argument_list|(
name|newname
argument_list|,
name|symname
argument_list|)
expr_stmt|;
name|section
operator|->
name|comdat
operator|->
name|name
operator|=
name|newname
expr_stmt|;
block|}
goto|goto
name|breakloop
goto|;
block|}
block|}
name|esym
operator|+=
operator|(
name|isym
operator|.
name|n_numaux
operator|+
literal|1
operator|)
operator|*
name|bfd_coff_symesz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
name|breakloop
label|:
return|return
name|sec_flags
return|;
block|}
end_function

begin_comment
comment|/* The PE version; see above for the general comments.     Since to set the SEC_LINK_ONCE and associated flags, we have to    look at the symbol table anyway, we return the symbol table index    of the symbol being used as the COMDAT symbol.  This is admittedly    ugly, but there's really nowhere else that we have access to the    required information.  FIXME: Is the COMDAT symbol index used for    any purpose other than objdump?  */
end_comment

begin_function
specifier|static
name|boolean
name|styp_to_sec_flags
parameter_list|(
name|abfd
parameter_list|,
name|hdr
parameter_list|,
name|name
parameter_list|,
name|section
parameter_list|,
name|flags_ptr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|hdr
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|flagword
modifier|*
name|flags_ptr
decl_stmt|;
block|{
name|struct
name|internal_scnhdr
modifier|*
name|internal_s
init|=
operator|(
expr|struct
name|internal_scnhdr
operator|*
operator|)
name|hdr
decl_stmt|;
name|long
name|styp_flags
init|=
name|internal_s
operator|->
name|s_flags
decl_stmt|;
name|flagword
name|sec_flags
decl_stmt|;
name|boolean
name|result
init|=
name|true
decl_stmt|;
comment|/* Assume read only unless IMAGE_SCN_MEM_WRITE is specified.  */
name|sec_flags
operator|=
name|SEC_READONLY
expr_stmt|;
comment|/* Process each flag bit in styp_flags in turn.  */
while|while
condition|(
name|styp_flags
condition|)
block|{
name|long
name|flag
init|=
name|styp_flags
operator|&
operator|-
name|styp_flags
decl_stmt|;
name|char
modifier|*
name|unhandled
init|=
name|NULL
decl_stmt|;
name|styp_flags
operator|&=
operator|~
name|flag
expr_stmt|;
comment|/* We infer from the distinct read/write/execute bits the settings 	 of some of the bfd flags; the actual values, should we need them, 	 are also in pei_section_data (abfd, section)->pe_flags.  */
switch|switch
condition|(
name|flag
condition|)
block|{
case|case
name|STYP_DSECT
case|:
name|unhandled
operator|=
literal|"STYP_DSECT"
expr_stmt|;
break|break;
case|case
name|STYP_GROUP
case|:
name|unhandled
operator|=
literal|"STYP_GROUP"
expr_stmt|;
break|break;
case|case
name|STYP_COPY
case|:
name|unhandled
operator|=
literal|"STYP_COPY"
expr_stmt|;
break|break;
case|case
name|STYP_OVER
case|:
name|unhandled
operator|=
literal|"STYP_OVER"
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|SEC_NEVER_LOAD
case|case
name|STYP_NOLOAD
case|:
name|sec_flags
operator||=
name|SEC_NEVER_LOAD
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|IMAGE_SCN_MEM_READ
case|:
comment|/* Ignored, assume it always to be true.  */
break|break;
case|case
name|IMAGE_SCN_TYPE_NO_PAD
case|:
comment|/* Skip.  */
break|break;
case|case
name|IMAGE_SCN_LNK_OTHER
case|:
name|unhandled
operator|=
literal|"IMAGE_SCN_LNK_OTHER"
expr_stmt|;
break|break;
case|case
name|IMAGE_SCN_MEM_NOT_CACHED
case|:
name|unhandled
operator|=
literal|"IMAGE_SCN_MEM_NOT_CACHED"
expr_stmt|;
break|break;
case|case
name|IMAGE_SCN_MEM_NOT_PAGED
case|:
name|unhandled
operator|=
literal|"IMAGE_SCN_MEM_NOT_PAGED"
expr_stmt|;
break|break;
case|case
name|IMAGE_SCN_MEM_EXECUTE
case|:
name|sec_flags
operator||=
name|SEC_CODE
expr_stmt|;
break|break;
case|case
name|IMAGE_SCN_MEM_WRITE
case|:
name|sec_flags
operator|&=
operator|~
name|SEC_READONLY
expr_stmt|;
break|break;
case|case
name|IMAGE_SCN_MEM_DISCARDABLE
case|:
name|sec_flags
operator||=
name|SEC_DEBUGGING
expr_stmt|;
break|break;
case|case
name|IMAGE_SCN_MEM_SHARED
case|:
name|sec_flags
operator||=
name|SEC_SHARED
expr_stmt|;
break|break;
case|case
name|IMAGE_SCN_LNK_REMOVE
case|:
name|sec_flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
break|break;
case|case
name|IMAGE_SCN_CNT_CODE
case|:
name|sec_flags
operator||=
name|SEC_CODE
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
expr_stmt|;
break|break;
case|case
name|IMAGE_SCN_CNT_INITIALIZED_DATA
case|:
name|sec_flags
operator||=
name|SEC_DATA
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
expr_stmt|;
break|break;
case|case
name|IMAGE_SCN_CNT_UNINITIALIZED_DATA
case|:
name|sec_flags
operator||=
name|SEC_ALLOC
expr_stmt|;
break|break;
case|case
name|IMAGE_SCN_LNK_INFO
case|:
comment|/* We mark these as SEC_DEBUGGING, but only if COFF_PAGE_SIZE is 	     defined.  coff_compute_section_file_positions uses 	     COFF_PAGE_SIZE to ensure that the low order bits of the 	     section VMA and the file offset match.  If we don't know 	     COFF_PAGE_SIZE, we can't ensure the correct correspondence, 	     and demand page loading of the file will fail.  */
ifdef|#
directive|ifdef
name|COFF_PAGE_SIZE
name|sec_flags
operator||=
name|SEC_DEBUGGING
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|IMAGE_SCN_LNK_COMDAT
case|:
comment|/* COMDAT gets very special treatment.  */
name|sec_flags
operator|=
name|handle_COMDAT
argument_list|(
name|abfd
argument_list|,
name|sec_flags
argument_list|,
name|hdr
argument_list|,
name|name
argument_list|,
name|section
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Silently ignore for now.  */
break|break;
block|}
comment|/* If the section flag was not handled, report it here.  */
if|if
condition|(
name|unhandled
operator|!=
name|NULL
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s (%s): Section flag %s (0x%x) ignored"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|name
argument_list|,
name|unhandled
argument_list|,
name|flag
argument_list|)
expr_stmt|;
name|result
operator|=
name|false
expr_stmt|;
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|COFF_LONG_SECTION_NAMES
argument_list|)
operator|&&
name|defined
argument_list|(
name|COFF_SUPPORT_GNU_LINKONCE
argument_list|)
comment|/* As a GNU extension, if the name begins with .gnu.linkonce, we      only link a single copy of the section.  This is used to support      g++.  g++ will emit each template expansion in its own section.      The symbols will be defined as weak, so that multiple definitions      are permitted.  The GNU linker extension is to actually discard      all but one of the sections.  */
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".gnu.linkonce"
argument_list|,
sizeof|sizeof
expr|".gnu.linkonce"
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|sec_flags
operator||=
name|SEC_LINK_ONCE
operator||
name|SEC_LINK_DUPLICATES_DISCARD
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|flags_ptr
condition|)
operator|*
name|flags_ptr
operator|=
name|sec_flags
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* COFF_WITH_PE */
end_comment

begin_define
define|#
directive|define
name|get_index
parameter_list|(
name|symbol
parameter_list|)
value|((symbol)->udata.i)
end_define

begin_comment
comment|/* INTERNAL_DEFINITION 	bfd_coff_backend_data  CODE_FRAGMENT  .{* COFF symbol classifications.  *} . .enum coff_symbol_classification .{ .  {* Global symbol.  *} .  COFF_SYMBOL_GLOBAL, .  {* Common symbol.  *} .  COFF_SYMBOL_COMMON, .  {* Undefined symbol.  *} .  COFF_SYMBOL_UNDEFINED, .  {* Local symbol.  *} .  COFF_SYMBOL_LOCAL, .  {* PE section symbol.  *} .  COFF_SYMBOL_PE_SECTION .}; . Special entry points for gdb to swap in coff symbol table parts: .typedef struct .{ .  void (*_bfd_coff_swap_aux_in) .    PARAMS ((bfd *, PTR, int, int, int, int, PTR)); . .  void (*_bfd_coff_swap_sym_in) .    PARAMS ((bfd *, PTR, PTR)); . .  void (*_bfd_coff_swap_lineno_in) .    PARAMS ((bfd *, PTR, PTR)); . .  unsigned int (*_bfd_coff_swap_aux_out) .    PARAMS ((bfd *, PTR, int, int, int, int, PTR)); . .  unsigned int (*_bfd_coff_swap_sym_out) .    PARAMS ((bfd *, PTR, PTR)); . .  unsigned int (*_bfd_coff_swap_lineno_out) .    PARAMS ((bfd *, PTR, PTR)); . .  unsigned int (*_bfd_coff_swap_reloc_out) .    PARAMS ((bfd *, PTR, PTR)); . .  unsigned int (*_bfd_coff_swap_filehdr_out) .    PARAMS ((bfd *, PTR, PTR)); . .  unsigned int (*_bfd_coff_swap_aouthdr_out) .    PARAMS ((bfd *, PTR, PTR)); . .  unsigned int (*_bfd_coff_swap_scnhdr_out) .    PARAMS ((bfd *, PTR, PTR)); . .  unsigned int _bfd_filhsz; .  unsigned int _bfd_aoutsz; .  unsigned int _bfd_scnhsz; .  unsigned int _bfd_symesz; .  unsigned int _bfd_auxesz; .  unsigned int _bfd_relsz; .  unsigned int _bfd_linesz; .  unsigned int _bfd_filnmlen; .  boolean _bfd_coff_long_filenames; .  boolean _bfd_coff_long_section_names; .  unsigned int _bfd_coff_default_section_alignment_power; .  boolean _bfd_coff_force_symnames_in_strings; .  unsigned int _bfd_coff_debug_string_prefix_length; . .  void (*_bfd_coff_swap_filehdr_in) .    PARAMS ((bfd *, PTR, PTR)); . .  void (*_bfd_coff_swap_aouthdr_in) .    PARAMS ((bfd *, PTR, PTR)); . .  void (*_bfd_coff_swap_scnhdr_in) .    PARAMS ((bfd *, PTR, PTR)); . .  void (*_bfd_coff_swap_reloc_in) .    PARAMS ((bfd *abfd, PTR, PTR)); . .  boolean (*_bfd_coff_bad_format_hook) .    PARAMS ((bfd *, PTR)); . .  boolean (*_bfd_coff_set_arch_mach_hook) .    PARAMS ((bfd *, PTR)); . .  PTR (*_bfd_coff_mkobject_hook) .    PARAMS ((bfd *, PTR, PTR)); . .  boolean (*_bfd_styp_to_sec_flags_hook) .    PARAMS ((bfd *, PTR, const char *, asection *, flagword *)); . .  void (*_bfd_set_alignment_hook) .    PARAMS ((bfd *, asection *, PTR)); . .  boolean (*_bfd_coff_slurp_symbol_table) .    PARAMS ((bfd *)); . .  boolean (*_bfd_coff_symname_in_debug) .    PARAMS ((bfd *, struct internal_syment *)); . .  boolean (*_bfd_coff_pointerize_aux_hook) .    PARAMS ((bfd *, combined_entry_type *, combined_entry_type *, .	     unsigned int, combined_entry_type *)); . .  boolean (*_bfd_coff_print_aux) .    PARAMS ((bfd *, FILE *, combined_entry_type *, combined_entry_type *, .	     combined_entry_type *, unsigned int)); . .  void (*_bfd_coff_reloc16_extra_cases) .    PARAMS ((bfd *, struct bfd_link_info *, struct bfd_link_order *, arelent *, .	    bfd_byte *, unsigned int *, unsigned int *)); . .  int (*_bfd_coff_reloc16_estimate) .    PARAMS ((bfd *, asection *, arelent *, unsigned int, .	     struct bfd_link_info *)); . .  enum coff_symbol_classification (*_bfd_coff_classify_symbol) .    PARAMS ((bfd *, struct internal_syment *)); . .  boolean (*_bfd_coff_compute_section_file_positions) .    PARAMS ((bfd *)); . .  boolean (*_bfd_coff_start_final_link) .    PARAMS ((bfd *, struct bfd_link_info *)); . .  boolean (*_bfd_coff_relocate_section) .    PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *, .	     struct internal_reloc *, struct internal_syment *, asection **)); . .  reloc_howto_type *(*_bfd_coff_rtype_to_howto) .    PARAMS ((bfd *, asection *, struct internal_reloc *, .	     struct coff_link_hash_entry *, struct internal_syment *, .	     bfd_vma *)); . .  boolean (*_bfd_coff_adjust_symndx)\ .    PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, .	     struct internal_reloc *, boolean *)); . .  boolean (*_bfd_coff_link_add_one_symbol) .    PARAMS ((struct bfd_link_info *, bfd *, const char *, flagword, .	     asection *, bfd_vma, const char *, boolean, boolean, .	     struct bfd_link_hash_entry **)); . .  boolean (*_bfd_coff_link_output_has_begun) .    PARAMS ((bfd *, struct coff_final_link_info *)); . .  boolean (*_bfd_coff_final_link_postscript) .    PARAMS ((bfd *, struct coff_final_link_info *)); . .} bfd_coff_backend_data; . .#define coff_backend_info(abfd) \ .  ((bfd_coff_backend_data *) (abfd)->xvec->backend_data) . .#define bfd_coff_swap_aux_in(a,e,t,c,ind,num,i) \ .  ((coff_backend_info (a)->_bfd_coff_swap_aux_in) (a,e,t,c,ind,num,i)) . .#define bfd_coff_swap_sym_in(a,e,i) \ .  ((coff_backend_info (a)->_bfd_coff_swap_sym_in) (a,e,i)) . .#define bfd_coff_swap_lineno_in(a,e,i) \ .  ((coff_backend_info ( a)->_bfd_coff_swap_lineno_in) (a,e,i)) . .#define bfd_coff_swap_reloc_out(abfd, i, o) \ .  ((coff_backend_info (abfd)->_bfd_coff_swap_reloc_out) (abfd, i, o)) . .#define bfd_coff_swap_lineno_out(abfd, i, o) \ .  ((coff_backend_info (abfd)->_bfd_coff_swap_lineno_out) (abfd, i, o)) . .#define bfd_coff_swap_aux_out(a,i,t,c,ind,num,o) \ .  ((coff_backend_info (a)->_bfd_coff_swap_aux_out) (a,i,t,c,ind,num,o)) . .#define bfd_coff_swap_sym_out(abfd, i,o) \ .  ((coff_backend_info (abfd)->_bfd_coff_swap_sym_out) (abfd, i, o)) . .#define bfd_coff_swap_scnhdr_out(abfd, i,o) \ .  ((coff_backend_info (abfd)->_bfd_coff_swap_scnhdr_out) (abfd, i, o)) . .#define bfd_coff_swap_filehdr_out(abfd, i,o) \ .  ((coff_backend_info (abfd)->_bfd_coff_swap_filehdr_out) (abfd, i, o)) . .#define bfd_coff_swap_aouthdr_out(abfd, i,o) \ .  ((coff_backend_info (abfd)->_bfd_coff_swap_aouthdr_out) (abfd, i, o)) . .#define bfd_coff_filhsz(abfd) (coff_backend_info (abfd)->_bfd_filhsz) .#define bfd_coff_aoutsz(abfd) (coff_backend_info (abfd)->_bfd_aoutsz) .#define bfd_coff_scnhsz(abfd) (coff_backend_info (abfd)->_bfd_scnhsz) .#define bfd_coff_symesz(abfd) (coff_backend_info (abfd)->_bfd_symesz) .#define bfd_coff_auxesz(abfd) (coff_backend_info (abfd)->_bfd_auxesz) .#define bfd_coff_relsz(abfd)  (coff_backend_info (abfd)->_bfd_relsz) .#define bfd_coff_linesz(abfd) (coff_backend_info (abfd)->_bfd_linesz) .#define bfd_coff_filnmlen(abfd) (coff_backend_info (abfd)->_bfd_filnmlen) .#define bfd_coff_long_filenames(abfd) \ .  (coff_backend_info (abfd)->_bfd_coff_long_filenames) .#define bfd_coff_long_section_names(abfd) \ .  (coff_backend_info (abfd)->_bfd_coff_long_section_names) .#define bfd_coff_default_section_alignment_power(abfd) \ .  (coff_backend_info (abfd)->_bfd_coff_default_section_alignment_power) .#define bfd_coff_swap_filehdr_in(abfd, i,o) \ .  ((coff_backend_info (abfd)->_bfd_coff_swap_filehdr_in) (abfd, i, o)) . .#define bfd_coff_swap_aouthdr_in(abfd, i,o) \ .  ((coff_backend_info (abfd)->_bfd_coff_swap_aouthdr_in) (abfd, i, o)) . .#define bfd_coff_swap_scnhdr_in(abfd, i,o) \ .  ((coff_backend_info (abfd)->_bfd_coff_swap_scnhdr_in) (abfd, i, o)) . .#define bfd_coff_swap_reloc_in(abfd, i, o) \ .  ((coff_backend_info (abfd)->_bfd_coff_swap_reloc_in) (abfd, i, o)) . .#define bfd_coff_bad_format_hook(abfd, filehdr) \ .  ((coff_backend_info (abfd)->_bfd_coff_bad_format_hook) (abfd, filehdr)) . .#define bfd_coff_set_arch_mach_hook(abfd, filehdr)\ .  ((coff_backend_info (abfd)->_bfd_coff_set_arch_mach_hook) (abfd, filehdr)) .#define bfd_coff_mkobject_hook(abfd, filehdr, aouthdr)\ .  ((coff_backend_info (abfd)->_bfd_coff_mkobject_hook) (abfd, filehdr, aouthdr)) . .#define bfd_coff_styp_to_sec_flags_hook(abfd, scnhdr, name, section, flags_ptr)\ .  ((coff_backend_info (abfd)->_bfd_styp_to_sec_flags_hook)\ .   (abfd, scnhdr, name, section, flags_ptr)) . .#define bfd_coff_set_alignment_hook(abfd, sec, scnhdr)\ .  ((coff_backend_info (abfd)->_bfd_set_alignment_hook) (abfd, sec, scnhdr)) . .#define bfd_coff_slurp_symbol_table(abfd)\ .  ((coff_backend_info (abfd)->_bfd_coff_slurp_symbol_table) (abfd)) . .#define bfd_coff_symname_in_debug(abfd, sym)\ .  ((coff_backend_info (abfd)->_bfd_coff_symname_in_debug) (abfd, sym)) . .#define bfd_coff_force_symnames_in_strings(abfd)\ .  (coff_backend_info (abfd)->_bfd_coff_force_symnames_in_strings) . .#define bfd_coff_debug_string_prefix_length(abfd)\ .  (coff_backend_info (abfd)->_bfd_coff_debug_string_prefix_length) . .#define bfd_coff_print_aux(abfd, file, base, symbol, aux, indaux)\ .  ((coff_backend_info (abfd)->_bfd_coff_print_aux)\ .   (abfd, file, base, symbol, aux, indaux)) . .#define bfd_coff_reloc16_extra_cases(abfd, link_info, link_order, reloc, data, src_ptr, dst_ptr)\ .  ((coff_backend_info (abfd)->_bfd_coff_reloc16_extra_cases)\ .   (abfd, link_info, link_order, reloc, data, src_ptr, dst_ptr)) . .#define bfd_coff_reloc16_estimate(abfd, section, reloc, shrink, link_info)\ .  ((coff_backend_info (abfd)->_bfd_coff_reloc16_estimate)\ .   (abfd, section, reloc, shrink, link_info)) . .#define bfd_coff_classify_symbol(abfd, sym)\ .  ((coff_backend_info (abfd)->_bfd_coff_classify_symbol)\ .   (abfd, sym)) . .#define bfd_coff_compute_section_file_positions(abfd)\ .  ((coff_backend_info (abfd)->_bfd_coff_compute_section_file_positions)\ .   (abfd)) . .#define bfd_coff_start_final_link(obfd, info)\ .  ((coff_backend_info (obfd)->_bfd_coff_start_final_link)\ .   (obfd, info)) .#define bfd_coff_relocate_section(obfd,info,ibfd,o,con,rel,isyms,secs)\ .  ((coff_backend_info (ibfd)->_bfd_coff_relocate_section)\ .   (obfd, info, ibfd, o, con, rel, isyms, secs)) .#define bfd_coff_rtype_to_howto(abfd, sec, rel, h, sym, addendp)\ .  ((coff_backend_info (abfd)->_bfd_coff_rtype_to_howto)\ .   (abfd, sec, rel, h, sym, addendp)) .#define bfd_coff_adjust_symndx(obfd, info, ibfd, sec, rel, adjustedp)\ .  ((coff_backend_info (abfd)->_bfd_coff_adjust_symndx)\ .   (obfd, info, ibfd, sec, rel, adjustedp)) .#define bfd_coff_link_add_one_symbol(info,abfd,name,flags,section,value,string,cp,coll,hashp)\ .  ((coff_backend_info (abfd)->_bfd_coff_link_add_one_symbol)\ .   (info, abfd, name, flags, section, value, string, cp, coll, hashp)) . .#define bfd_coff_link_output_has_begun(a,p) \ .  ((coff_backend_info (a)->_bfd_coff_link_output_has_begun) (a,p)) .#define bfd_coff_final_link_postscript(a,p) \ .  ((coff_backend_info (a)->_bfd_coff_final_link_postscript) (a,p)) . */
end_comment

begin_comment
comment|/* See whether the magic number matches.  */
end_comment

begin_function
specifier|static
name|boolean
name|coff_bad_format_hook
parameter_list|(
name|abfd
parameter_list|,
name|filehdr
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|PTR
name|filehdr
decl_stmt|;
block|{
name|struct
name|internal_filehdr
modifier|*
name|internal_f
init|=
operator|(
expr|struct
name|internal_filehdr
operator|*
operator|)
name|filehdr
decl_stmt|;
if|if
condition|(
name|BADMAG
argument_list|(
operator|*
name|internal_f
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* if the optional header is NULL or not the correct size then      quit; the only difference I can see between m88k dgux headers (MC88DMAGIC)      and Intel 960 readwrite headers (I960WRMAGIC) is that the      optional header is of a different size.       But the mips keeps extra stuff in it's opthdr, so dont check      when doing that      */
if|#
directive|if
name|defined
argument_list|(
name|M88
argument_list|)
operator|||
name|defined
argument_list|(
name|I960
argument_list|)
if|if
condition|(
name|internal_f
operator|->
name|f_opthdr
operator|!=
literal|0
operator|&&
name|bfd_coff_aoutsz
argument_list|(
name|abfd
argument_list|)
operator|!=
name|internal_f
operator|->
name|f_opthdr
condition|)
return|return
name|false
return|;
endif|#
directive|endif
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Check whether this section uses an alignment other than the    default.  */
end_comment

begin_function
specifier|static
name|void
name|coff_set_custom_section_alignment
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|alignment_table
parameter_list|,
name|table_size
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
specifier|const
name|struct
name|coff_section_alignment_entry
modifier|*
name|alignment_table
decl_stmt|;
specifier|const
name|unsigned
name|int
name|table_size
decl_stmt|;
block|{
specifier|const
name|unsigned
name|int
name|default_alignment
init|=
name|COFF_DEFAULT_SECTION_ALIGNMENT_POWER
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|table_size
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|char
modifier|*
name|secname
init|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
decl_stmt|;
if|if
condition|(
name|alignment_table
index|[
name|i
index|]
operator|.
name|comparison_length
operator|==
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
condition|?
name|strcmp
argument_list|(
name|alignment_table
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|secname
argument_list|)
operator|==
literal|0
else|:
name|strncmp
argument_list|(
name|alignment_table
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|secname
argument_list|,
name|alignment_table
index|[
name|i
index|]
operator|.
name|comparison_length
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>=
name|table_size
condition|)
return|return;
if|if
condition|(
name|alignment_table
index|[
name|i
index|]
operator|.
name|default_alignment_min
operator|!=
name|COFF_ALIGNMENT_FIELD_EMPTY
operator|&&
name|default_alignment
operator|<
name|alignment_table
index|[
name|i
index|]
operator|.
name|default_alignment_min
condition|)
return|return;
if|if
condition|(
name|alignment_table
index|[
name|i
index|]
operator|.
name|default_alignment_max
operator|!=
name|COFF_ALIGNMENT_FIELD_EMPTY
if|#
directive|if
name|COFF_DEFAULT_SECTION_ALIGNMENT_POWER
operator|!=
literal|0
operator|&&
name|default_alignment
operator|>
name|alignment_table
index|[
name|i
index|]
operator|.
name|default_alignment_max
endif|#
directive|endif
condition|)
return|return;
name|section
operator|->
name|alignment_power
operator|=
name|alignment_table
index|[
name|i
index|]
operator|.
name|alignment_power
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Custom section alignment records.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|coff_section_alignment_entry
name|coff_section_alignment_table
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|COFF_SECTION_ALIGNMENT_ENTRIES
name|COFF_SECTION_ALIGNMENT_ENTRIES
block|,
endif|#
directive|endif
comment|/* There must not be any gaps between .stabstr sections.  */
block|{
name|COFF_SECTION_NAME_PARTIAL_MATCH
argument_list|(
literal|".stabstr"
argument_list|)
block|,
literal|1
block|,
name|COFF_ALIGNMENT_FIELD_EMPTY
block|,
literal|0
block|}
block|,
comment|/* The .stab section must be aligned to 2**2 at most, to avoid gaps.  */
block|{
name|COFF_SECTION_NAME_PARTIAL_MATCH
argument_list|(
literal|".stab"
argument_list|)
block|,
literal|3
block|,
name|COFF_ALIGNMENT_FIELD_EMPTY
block|,
literal|2
block|}
block|,
comment|/* Similarly for the .ctors and .dtors sections.  */
block|{
name|COFF_SECTION_NAME_EXACT_MATCH
argument_list|(
literal|".ctors"
argument_list|)
block|,
literal|3
block|,
name|COFF_ALIGNMENT_FIELD_EMPTY
block|,
literal|2
block|}
block|,
block|{
name|COFF_SECTION_NAME_EXACT_MATCH
argument_list|(
literal|".dtors"
argument_list|)
block|,
literal|3
block|,
name|COFF_ALIGNMENT_FIELD_EMPTY
block|,
literal|2
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|int
name|coff_section_alignment_table_size
init|=
sizeof|sizeof
name|coff_section_alignment_table
operator|/
sizeof|sizeof
name|coff_section_alignment_table
index|[
literal|0
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize a section structure with information peculiar to this    particular implementation of COFF.  */
end_comment

begin_function
specifier|static
name|boolean
name|coff_new_section_hook
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
block|{
name|combined_entry_type
modifier|*
name|native
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|section
operator|->
name|alignment_power
operator|=
name|COFF_DEFAULT_SECTION_ALIGNMENT_POWER
expr_stmt|;
ifdef|#
directive|ifdef
name|RS6000COFF_C
if|if
condition|(
name|xcoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|text_align_power
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
argument_list|,
literal|".text"
argument_list|)
operator|==
literal|0
condition|)
name|section
operator|->
name|alignment_power
operator|=
name|xcoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|text_align_power
expr_stmt|;
if|if
condition|(
name|xcoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|data_align_power
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
argument_list|,
literal|".data"
argument_list|)
operator|==
literal|0
condition|)
name|section
operator|->
name|alignment_power
operator|=
name|xcoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|data_align_power
expr_stmt|;
endif|#
directive|endif
comment|/* Allocate aux records for section symbols, to store size and      related info.       @@ The 10 is a guess at a plausible maximum number of aux entries      (but shouldn't be a constant).  */
name|amt
operator|=
sizeof|sizeof
argument_list|(
name|combined_entry_type
argument_list|)
operator|*
literal|10
expr_stmt|;
name|native
operator|=
operator|(
name|combined_entry_type
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|native
operator|==
name|NULL
condition|)
return|return
name|false
return|;
comment|/* We don't need to set up n_name, n_value, or n_scnum in the native      symbol information, since they'll be overriden by the BFD symbol      anyhow.  However, we do need to set the type and storage class,      in case this symbol winds up getting written out.  The value 0      for n_numaux is already correct.  */
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_type
operator|=
name|T_NULL
expr_stmt|;
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
operator|=
name|C_STAT
expr_stmt|;
name|coffsymbol
argument_list|(
name|section
operator|->
name|symbol
argument_list|)
operator|->
name|native
operator|=
name|native
expr_stmt|;
name|coff_set_custom_section_alignment
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|coff_section_alignment_table
argument_list|,
name|coff_section_alignment_table_size
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|COFF_ALIGN_IN_SECTION_HEADER
end_ifdef

begin_comment
comment|/* Set the alignment of a BFD section.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|coff_set_alignment_hook
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|coff_set_alignment_hook
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|scnhdr
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|PTR
name|scnhdr
decl_stmt|;
block|{
name|struct
name|internal_scnhdr
modifier|*
name|hdr
init|=
operator|(
expr|struct
name|internal_scnhdr
operator|*
operator|)
name|scnhdr
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|I960
comment|/* Extract ALIGN from 2**ALIGN stored in section header */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
literal|1
operator|<<
name|i
operator|)
operator|>=
name|hdr
operator|->
name|s_align
condition|)
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TIC80COFF
comment|/* TI tools puts the alignment power in bits 8-11 */
name|i
operator|=
operator|(
name|hdr
operator|->
name|s_flags
operator|>>
literal|8
operator|)
operator|&
literal|0xF
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|COFF_DECODE_ALIGNMENT
name|i
operator|=
name|COFF_DECODE_ALIGNMENT
argument_list|(
name|hdr
operator|->
name|s_flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|section
operator|->
name|alignment_power
operator|=
name|i
expr_stmt|;
ifdef|#
directive|ifdef
name|coff_set_section_load_page
name|coff_set_section_load_page
argument_list|(
name|section
argument_list|,
name|hdr
operator|->
name|s_page
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! COFF_ALIGN_IN_SECTION_HEADER */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|COFF_WITH_PE
end_ifdef

begin_comment
comment|/* a couple of macros to help setting the alignment power field */
end_comment

begin_define
define|#
directive|define
name|ALIGN_SET
parameter_list|(
name|field
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|)
define|\
value|if (((field)& IMAGE_SCN_ALIGN_64BYTES) == x )\   {\      section->alignment_power = y;\   }
end_define

begin_define
define|#
directive|define
name|ELIFALIGN_SET
parameter_list|(
name|field
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|)
define|\
value|else if (( (field)& IMAGE_SCN_ALIGN_64BYTES) == x ) \   {\      section->alignment_power = y;\   }
end_define

begin_decl_stmt
specifier|static
name|void
name|coff_set_alignment_hook
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|coff_set_alignment_hook
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|scnhdr
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|PTR
name|scnhdr
decl_stmt|;
block|{
name|struct
name|internal_scnhdr
modifier|*
name|hdr
init|=
operator|(
expr|struct
name|internal_scnhdr
operator|*
operator|)
name|scnhdr
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|ALIGN_SET
argument_list|(
argument|hdr->s_flags
argument_list|,
argument|IMAGE_SCN_ALIGN_64BYTES
argument_list|,
literal|6
argument_list|)
name|ELIFALIGN_SET
argument_list|(
argument|hdr->s_flags
argument_list|,
argument|IMAGE_SCN_ALIGN_32BYTES
argument_list|,
literal|5
argument_list|)
name|ELIFALIGN_SET
argument_list|(
argument|hdr->s_flags
argument_list|,
argument|IMAGE_SCN_ALIGN_16BYTES
argument_list|,
literal|4
argument_list|)
name|ELIFALIGN_SET
argument_list|(
argument|hdr->s_flags
argument_list|,
argument|IMAGE_SCN_ALIGN_8BYTES
argument_list|,
literal|3
argument_list|)
name|ELIFALIGN_SET
argument_list|(
argument|hdr->s_flags
argument_list|,
argument|IMAGE_SCN_ALIGN_4BYTES
argument_list|,
literal|2
argument_list|)
name|ELIFALIGN_SET
argument_list|(
argument|hdr->s_flags
argument_list|,
argument|IMAGE_SCN_ALIGN_2BYTES
argument_list|,
literal|1
argument_list|)
name|ELIFALIGN_SET
argument_list|(
argument|hdr->s_flags
argument_list|,
argument|IMAGE_SCN_ALIGN_1BYTES
argument_list|,
literal|0
argument_list|)
comment|/* In a PE image file, the s_paddr field holds the virtual size of a      section, while the s_size field holds the raw size.  We also keep      the original section flag value, since not every bit can be      mapped onto a generic BFD section bit.  */
if|if
condition|(
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|coff_section_tdata
argument_list|)
expr_stmt|;
name|section
operator|->
name|used_by_bfd
operator|=
operator|(
name|PTR
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|section
operator|->
name|used_by_bfd
operator|==
name|NULL
condition|)
block|{
comment|/* FIXME: Return error.  */
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pei_section_data
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|pei_section_tdata
argument_list|)
expr_stmt|;
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
operator|->
name|tdata
operator|=
operator|(
name|PTR
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
operator|->
name|tdata
operator|==
name|NULL
condition|)
block|{
comment|/* FIXME: Return error.  */
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
name|pei_section_data
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
operator|->
name|virt_size
operator|=
name|hdr
operator|->
name|s_paddr
expr_stmt|;
name|pei_section_data
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
operator|->
name|pe_flags
operator|=
name|hdr
operator|->
name|s_flags
expr_stmt|;
name|section
operator|->
name|lma
operator|=
name|hdr
operator|->
name|s_vaddr
expr_stmt|;
comment|/* check for extended relocs */
if|if
condition|(
name|hdr
operator|->
name|s_flags
operator|&
name|IMAGE_SCN_LNK_NRELOC_OVFL
condition|)
block|{
name|struct
name|external_reloc
name|dst
decl_stmt|;
name|struct
name|internal_reloc
name|n
decl_stmt|;
name|file_ptr
name|oldpos
init|=
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
name|hdr
operator|->
name|s_relptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_bread
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|dst
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|bfd_coff_relsz
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|abfd
argument_list|)
operator|!=
name|bfd_coff_relsz
argument_list|(
name|abfd
argument_list|)
condition|)
return|return;
name|coff_swap_reloc_in
argument_list|(
name|abfd
argument_list|,
operator|&
name|dst
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|oldpos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|section
operator|->
name|reloc_count
operator|=
name|hdr
operator|->
name|s_nreloc
operator|=
name|n
operator|.
name|r_vaddr
expr_stmt|;
block|}
block|}
end_function

begin_undef
undef|#
directive|undef
name|ALIGN_SET
end_undef

begin_undef
undef|#
directive|undef
name|ELIFALIGN_SET
end_undef

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! COFF_WITH_PE */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|RS6000COFF_C
end_ifdef

begin_comment
comment|/* We grossly abuse this function to handle XCOFF overflow headers.    When we see one, we correct the reloc and line number counts in the    real header, and remove the section we just created.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|coff_set_alignment_hook
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|coff_set_alignment_hook
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|scnhdr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|PTR
name|scnhdr
decl_stmt|;
block|{
name|struct
name|internal_scnhdr
modifier|*
name|hdr
init|=
operator|(
expr|struct
name|internal_scnhdr
operator|*
operator|)
name|scnhdr
decl_stmt|;
name|asection
modifier|*
name|real_sec
decl_stmt|;
name|asection
modifier|*
modifier|*
name|ps
decl_stmt|;
if|if
condition|(
operator|(
name|hdr
operator|->
name|s_flags
operator|&
name|STYP_OVRFLO
operator|)
operator|==
literal|0
condition|)
return|return;
name|real_sec
operator|=
name|coff_section_from_bfd_index
argument_list|(
name|abfd
argument_list|,
operator|(
name|int
operator|)
name|hdr
operator|->
name|s_nreloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|real_sec
operator|==
name|NULL
condition|)
return|return;
name|real_sec
operator|->
name|reloc_count
operator|=
name|hdr
operator|->
name|s_paddr
expr_stmt|;
name|real_sec
operator|->
name|lineno_count
operator|=
name|hdr
operator|->
name|s_vaddr
expr_stmt|;
for|for
control|(
name|ps
operator|=
operator|&
name|abfd
operator|->
name|sections
init|;
operator|*
name|ps
operator|!=
name|NULL
condition|;
name|ps
operator|=
operator|&
operator|(
operator|*
name|ps
operator|)
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|*
name|ps
operator|==
name|section
condition|)
block|{
name|bfd_section_list_remove
argument_list|(
name|abfd
argument_list|,
name|ps
argument_list|)
expr_stmt|;
operator|--
name|abfd
operator|->
name|section_count
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! RS6000COFF_C */
end_comment

begin_define
define|#
directive|define
name|coff_set_alignment_hook
define|\
value|((void (*) PARAMS ((bfd *, asection *, PTR))) bfd_void)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! RS6000COFF_C */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! COFF_WITH_PE */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! COFF_ALIGN_IN_SECTION_HEADER */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|coff_mkobject
end_ifndef

begin_decl_stmt
specifier|static
name|boolean
name|coff_mkobject
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|boolean
name|coff_mkobject
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|coff_data_type
modifier|*
name|coff
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
name|coff_data_type
argument_list|)
decl_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|coff_obj_data
operator|=
operator|(
expr|struct
name|coff_tdata
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|tdata
operator|.
name|coff_obj_data
operator|==
literal|0
condition|)
return|return
name|false
return|;
name|coff
operator|=
name|coff_data
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|coff
operator|->
name|symbols
operator|=
operator|(
name|coff_symbol_type
operator|*
operator|)
name|NULL
expr_stmt|;
name|coff
operator|->
name|conversion_table
operator|=
operator|(
name|unsigned
name|int
operator|*
operator|)
name|NULL
expr_stmt|;
name|coff
operator|->
name|raw_syments
operator|=
operator|(
expr|struct
name|coff_ptr_struct
operator|*
operator|)
name|NULL
expr_stmt|;
name|coff
operator|->
name|relocbase
operator|=
literal|0
expr_stmt|;
name|coff
operator|->
name|local_toc_sym_map
operator|=
literal|0
expr_stmt|;
comment|/*  make_abs_section(abfd);*/
return|return
name|true
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Create the COFF backend specific information.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|coff_mkobject_hook
end_ifndef

begin_function
specifier|static
name|PTR
name|coff_mkobject_hook
parameter_list|(
name|abfd
parameter_list|,
name|filehdr
parameter_list|,
name|aouthdr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|filehdr
decl_stmt|;
name|PTR
name|aouthdr
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|struct
name|internal_filehdr
modifier|*
name|internal_f
init|=
operator|(
expr|struct
name|internal_filehdr
operator|*
operator|)
name|filehdr
decl_stmt|;
name|coff_data_type
modifier|*
name|coff
decl_stmt|;
if|if
condition|(
name|coff_mkobject
argument_list|(
name|abfd
argument_list|)
operator|==
name|false
condition|)
return|return
name|NULL
return|;
name|coff
operator|=
name|coff_data
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|coff
operator|->
name|sym_filepos
operator|=
name|internal_f
operator|->
name|f_symptr
expr_stmt|;
comment|/* These members communicate important constants about the symbol      table to GDB's symbol-reading code.  These `constants'      unfortunately vary among coff implementations...  */
name|coff
operator|->
name|local_n_btmask
operator|=
name|N_BTMASK
expr_stmt|;
name|coff
operator|->
name|local_n_btshft
operator|=
name|N_BTSHFT
expr_stmt|;
name|coff
operator|->
name|local_n_tmask
operator|=
name|N_TMASK
expr_stmt|;
name|coff
operator|->
name|local_n_tshift
operator|=
name|N_TSHIFT
expr_stmt|;
name|coff
operator|->
name|local_symesz
operator|=
name|bfd_coff_symesz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|coff
operator|->
name|local_auxesz
operator|=
name|bfd_coff_auxesz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|coff
operator|->
name|local_linesz
operator|=
name|bfd_coff_linesz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|coff
operator|->
name|timestamp
operator|=
name|internal_f
operator|->
name|f_timdat
expr_stmt|;
name|obj_raw_syment_count
argument_list|(
name|abfd
argument_list|)
operator|=
name|obj_conv_table_size
argument_list|(
name|abfd
argument_list|)
operator|=
name|internal_f
operator|->
name|f_nsyms
expr_stmt|;
ifdef|#
directive|ifdef
name|RS6000COFF_C
if|if
condition|(
operator|(
name|internal_f
operator|->
name|f_flags
operator|&
name|F_SHROBJ
operator|)
operator|!=
literal|0
condition|)
name|abfd
operator|->
name|flags
operator||=
name|DYNAMIC
expr_stmt|;
if|if
condition|(
name|aouthdr
operator|!=
name|NULL
operator|&&
name|internal_f
operator|->
name|f_opthdr
operator|>=
name|bfd_coff_aoutsz
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|struct
name|internal_aouthdr
modifier|*
name|internal_a
init|=
operator|(
expr|struct
name|internal_aouthdr
operator|*
operator|)
name|aouthdr
decl_stmt|;
name|struct
name|xcoff_tdata
modifier|*
name|xcoff
decl_stmt|;
name|xcoff
operator|=
name|xcoff_data
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|U803XTOCMAGIC
name|xcoff
operator|->
name|xcoff64
operator|=
name|internal_f
operator|->
name|f_magic
operator|==
name|U803XTOCMAGIC
expr_stmt|;
else|#
directive|else
name|xcoff
operator|->
name|xcoff64
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|xcoff
operator|->
name|full_aouthdr
operator|=
name|true
expr_stmt|;
name|xcoff
operator|->
name|toc
operator|=
name|internal_a
operator|->
name|o_toc
expr_stmt|;
name|xcoff
operator|->
name|sntoc
operator|=
name|internal_a
operator|->
name|o_sntoc
expr_stmt|;
name|xcoff
operator|->
name|snentry
operator|=
name|internal_a
operator|->
name|o_snentry
expr_stmt|;
name|xcoff
operator|->
name|text_align_power
operator|=
name|internal_a
operator|->
name|o_algntext
expr_stmt|;
name|xcoff
operator|->
name|data_align_power
operator|=
name|internal_a
operator|->
name|o_algndata
expr_stmt|;
name|xcoff
operator|->
name|modtype
operator|=
name|internal_a
operator|->
name|o_modtype
expr_stmt|;
name|xcoff
operator|->
name|cputype
operator|=
name|internal_a
operator|->
name|o_cputype
expr_stmt|;
name|xcoff
operator|->
name|maxdata
operator|=
name|internal_a
operator|->
name|o_maxdata
expr_stmt|;
name|xcoff
operator|->
name|maxstack
operator|=
name|internal_a
operator|->
name|o_maxstack
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARM
comment|/* Set the flags field from the COFF header read in.  */
if|if
condition|(
operator|!
name|_bfd_coff_arm_set_private_flags
argument_list|(
name|abfd
argument_list|,
name|internal_f
operator|->
name|f_flags
argument_list|)
condition|)
name|coff
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|COFF_WITH_PE
comment|/* FIXME: I'm not sure this is ever executed, since peicode.h      defines coff_mkobject_hook.  */
if|if
condition|(
operator|(
name|internal_f
operator|->
name|f_flags
operator|&
name|IMAGE_FILE_DEBUG_STRIPPED
operator|)
operator|==
literal|0
condition|)
name|abfd
operator|->
name|flags
operator||=
name|HAS_DEBUG
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|PTR
operator|)
name|coff
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Determine the machine architecture and type.  FIXME: This is target    dependent because the magic numbers are defined in the target    dependent header files.  But there is no particular need for this.    If the magic numbers were moved to a separate file, this function    would be target independent and would also be much more successful    at linking together COFF files for different architectures.  */
end_comment

begin_function
specifier|static
name|boolean
name|coff_set_arch_mach_hook
parameter_list|(
name|abfd
parameter_list|,
name|filehdr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|filehdr
decl_stmt|;
block|{
name|unsigned
name|long
name|machine
decl_stmt|;
name|enum
name|bfd_architecture
name|arch
decl_stmt|;
name|struct
name|internal_filehdr
modifier|*
name|internal_f
init|=
operator|(
expr|struct
name|internal_filehdr
operator|*
operator|)
name|filehdr
decl_stmt|;
name|machine
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|internal_f
operator|->
name|f_magic
condition|)
block|{
ifdef|#
directive|ifdef
name|OR32_MAGIC_BIG
case|case
name|OR32_MAGIC_BIG
case|:
case|case
name|OR32_MAGIC_LITTLE
case|:
name|arch
operator|=
name|bfd_arch_or32
expr_stmt|;
name|machine
operator|=
literal|0
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PPCMAGIC
case|case
name|PPCMAGIC
case|:
name|arch
operator|=
name|bfd_arch_powerpc
expr_stmt|;
name|machine
operator|=
literal|0
expr_stmt|;
comment|/* what does this mean? (krk) */
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|I386MAGIC
case|case
name|I386MAGIC
case|:
case|case
name|I386PTXMAGIC
case|:
case|case
name|I386AIXMAGIC
case|:
comment|/* Danbury PS/2 AIX C Compiler */
case|case
name|LYNXCOFFMAGIC
case|:
comment|/* shadows the m68k Lynx number below, sigh */
name|arch
operator|=
name|bfd_arch_i386
expr_stmt|;
name|machine
operator|=
literal|0
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IA64MAGIC
case|case
name|IA64MAGIC
case|:
name|arch
operator|=
name|bfd_arch_ia64
expr_stmt|;
name|machine
operator|=
literal|0
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|A29K_MAGIC_BIG
case|case
name|A29K_MAGIC_BIG
case|:
case|case
name|A29K_MAGIC_LITTLE
case|:
name|arch
operator|=
name|bfd_arch_a29k
expr_stmt|;
name|machine
operator|=
literal|0
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARMMAGIC
case|case
name|ARMMAGIC
case|:
case|case
name|ARMPEMAGIC
case|:
case|case
name|THUMBPEMAGIC
case|:
name|arch
operator|=
name|bfd_arch_arm
expr_stmt|;
switch|switch
condition|(
name|internal_f
operator|->
name|f_flags
operator|&
name|F_ARM_ARCHITECTURE_MASK
condition|)
block|{
case|case
name|F_ARM_2
case|:
name|machine
operator|=
name|bfd_mach_arm_2
expr_stmt|;
break|break;
case|case
name|F_ARM_2a
case|:
name|machine
operator|=
name|bfd_mach_arm_2a
expr_stmt|;
break|break;
case|case
name|F_ARM_3
case|:
name|machine
operator|=
name|bfd_mach_arm_3
expr_stmt|;
break|break;
default|default:
case|case
name|F_ARM_3M
case|:
name|machine
operator|=
name|bfd_mach_arm_3M
expr_stmt|;
break|break;
case|case
name|F_ARM_4
case|:
name|machine
operator|=
name|bfd_mach_arm_4
expr_stmt|;
break|break;
case|case
name|F_ARM_4T
case|:
name|machine
operator|=
name|bfd_mach_arm_4T
expr_stmt|;
break|break;
comment|/* The COFF header does not have enough bits available 	     to cover all the different ARM architectures.  So 	     we interpret F_ARM_5, the highest flag value to mean 	     "the highest ARM architecture known to BFD" which is 	     currently the XScale.  */
case|case
name|F_ARM_5
case|:
name|machine
operator|=
name|bfd_mach_arm_XScale
expr_stmt|;
break|break;
block|}
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MC68MAGIC
case|case
name|MC68MAGIC
case|:
case|case
name|M68MAGIC
case|:
ifdef|#
directive|ifdef
name|MC68KBCSMAGIC
case|case
name|MC68KBCSMAGIC
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|APOLLOM68KMAGIC
case|case
name|APOLLOM68KMAGIC
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LYNXCOFFMAGIC
case|case
name|LYNXCOFFMAGIC
case|:
endif|#
directive|endif
name|arch
operator|=
name|bfd_arch_m68k
expr_stmt|;
name|machine
operator|=
name|bfd_mach_m68020
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MC88MAGIC
case|case
name|MC88MAGIC
case|:
case|case
name|MC88DMAGIC
case|:
case|case
name|MC88OMAGIC
case|:
name|arch
operator|=
name|bfd_arch_m88k
expr_stmt|;
name|machine
operator|=
literal|88100
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|Z8KMAGIC
case|case
name|Z8KMAGIC
case|:
name|arch
operator|=
name|bfd_arch_z8k
expr_stmt|;
switch|switch
condition|(
name|internal_f
operator|->
name|f_flags
operator|&
name|F_MACHMASK
condition|)
block|{
case|case
name|F_Z8001
case|:
name|machine
operator|=
name|bfd_mach_z8001
expr_stmt|;
break|break;
case|case
name|F_Z8002
case|:
name|machine
operator|=
name|bfd_mach_z8002
expr_stmt|;
break|break;
default|default:
return|return
name|false
return|;
block|}
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|I860
case|case
name|I860MAGIC
case|:
name|arch
operator|=
name|bfd_arch_i860
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|I960
ifdef|#
directive|ifdef
name|I960ROMAGIC
case|case
name|I960ROMAGIC
case|:
case|case
name|I960RWMAGIC
case|:
name|arch
operator|=
name|bfd_arch_i960
expr_stmt|;
switch|switch
condition|(
name|F_I960TYPE
operator|&
name|internal_f
operator|->
name|f_flags
condition|)
block|{
default|default:
case|case
name|F_I960CORE
case|:
name|machine
operator|=
name|bfd_mach_i960_core
expr_stmt|;
break|break;
case|case
name|F_I960KB
case|:
name|machine
operator|=
name|bfd_mach_i960_kb_sb
expr_stmt|;
break|break;
case|case
name|F_I960MC
case|:
name|machine
operator|=
name|bfd_mach_i960_mc
expr_stmt|;
break|break;
case|case
name|F_I960XA
case|:
name|machine
operator|=
name|bfd_mach_i960_xa
expr_stmt|;
break|break;
case|case
name|F_I960CA
case|:
name|machine
operator|=
name|bfd_mach_i960_ca
expr_stmt|;
break|break;
case|case
name|F_I960KA
case|:
name|machine
operator|=
name|bfd_mach_i960_ka_sa
expr_stmt|;
break|break;
case|case
name|F_I960JX
case|:
name|machine
operator|=
name|bfd_mach_i960_jx
expr_stmt|;
break|break;
case|case
name|F_I960HX
case|:
name|machine
operator|=
name|bfd_mach_i960_hx
expr_stmt|;
break|break;
block|}
break|break;
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RS6000COFF_C
ifdef|#
directive|ifdef
name|XCOFF64
case|case
name|U803XTOCMAGIC
case|:
else|#
directive|else
case|case
name|U802ROMAGIC
case|:
case|case
name|U802WRMAGIC
case|:
case|case
name|U802TOCMAGIC
case|:
endif|#
directive|endif
block|{
name|int
name|cputype
decl_stmt|;
if|if
condition|(
name|xcoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|cputype
operator|!=
operator|-
literal|1
condition|)
name|cputype
operator|=
name|xcoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|cputype
operator|&
literal|0xff
expr_stmt|;
else|else
block|{
comment|/* We did not get a value from the a.out header.  If the 	       file has not been stripped, we may be able to get the 	       architecture information from the first symbol, if it 	       is a .file symbol.  */
if|if
condition|(
name|obj_raw_syment_count
argument_list|(
name|abfd
argument_list|)
operator|==
literal|0
condition|)
name|cputype
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|bfd_byte
modifier|*
name|buf
decl_stmt|;
name|struct
name|internal_syment
name|sym
decl_stmt|;
name|bfd_size_type
name|amt
init|=
name|bfd_coff_symesz
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|buf
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|obj_sym_filepos
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bread
argument_list|(
name|buf
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|bfd_coff_swap_sym_in
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|buf
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|.
name|n_sclass
operator|==
name|C_FILE
condition|)
name|cputype
operator|=
name|sym
operator|.
name|n_type
operator|&
literal|0xff
expr_stmt|;
else|else
name|cputype
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* FIXME: We don't handle all cases here.  */
switch|switch
condition|(
name|cputype
condition|)
block|{
default|default:
case|case
literal|0
case|:
name|arch
operator|=
name|bfd_xcoff_architecture
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|machine
operator|=
name|bfd_xcoff_machine
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|arch
operator|=
name|bfd_arch_powerpc
expr_stmt|;
name|machine
operator|=
name|bfd_mach_ppc_601
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* 64 bit PowerPC */
name|arch
operator|=
name|bfd_arch_powerpc
expr_stmt|;
name|machine
operator|=
name|bfd_mach_ppc_620
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|arch
operator|=
name|bfd_arch_powerpc
expr_stmt|;
name|machine
operator|=
name|bfd_mach_ppc
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|arch
operator|=
name|bfd_arch_rs6000
expr_stmt|;
name|machine
operator|=
name|bfd_mach_rs6k
expr_stmt|;
break|break;
block|}
block|}
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|WE32KMAGIC
case|case
name|WE32KMAGIC
case|:
name|arch
operator|=
name|bfd_arch_we32k
expr_stmt|;
name|machine
operator|=
literal|0
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|H8300MAGIC
case|case
name|H8300MAGIC
case|:
name|arch
operator|=
name|bfd_arch_h8300
expr_stmt|;
name|machine
operator|=
name|bfd_mach_h8300
expr_stmt|;
comment|/* !! FIXME this probably isn't the right place for this */
name|abfd
operator|->
name|flags
operator||=
name|BFD_IS_RELAXABLE
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|H8300HMAGIC
case|case
name|H8300HMAGIC
case|:
name|arch
operator|=
name|bfd_arch_h8300
expr_stmt|;
name|machine
operator|=
name|bfd_mach_h8300h
expr_stmt|;
comment|/* !! FIXME this probably isn't the right place for this */
name|abfd
operator|->
name|flags
operator||=
name|BFD_IS_RELAXABLE
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|H8300SMAGIC
case|case
name|H8300SMAGIC
case|:
name|arch
operator|=
name|bfd_arch_h8300
expr_stmt|;
name|machine
operator|=
name|bfd_mach_h8300s
expr_stmt|;
comment|/* !! FIXME this probably isn't the right place for this */
name|abfd
operator|->
name|flags
operator||=
name|BFD_IS_RELAXABLE
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SH_ARCH_MAGIC_BIG
case|case
name|SH_ARCH_MAGIC_BIG
case|:
case|case
name|SH_ARCH_MAGIC_LITTLE
case|:
ifdef|#
directive|ifdef
name|COFF_WITH_PE
case|case
name|SH_ARCH_MAGIC_WINCE
case|:
endif|#
directive|endif
name|arch
operator|=
name|bfd_arch_sh
expr_stmt|;
name|machine
operator|=
literal|0
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MIPS_ARCH_MAGIC_WINCE
case|case
name|MIPS_ARCH_MAGIC_WINCE
case|:
name|arch
operator|=
name|bfd_arch_mips
expr_stmt|;
name|machine
operator|=
literal|0
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|H8500MAGIC
case|case
name|H8500MAGIC
case|:
name|arch
operator|=
name|bfd_arch_h8500
expr_stmt|;
name|machine
operator|=
literal|0
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SPARCMAGIC
case|case
name|SPARCMAGIC
case|:
ifdef|#
directive|ifdef
name|LYNXCOFFMAGIC
case|case
name|LYNXCOFFMAGIC
case|:
endif|#
directive|endif
name|arch
operator|=
name|bfd_arch_sparc
expr_stmt|;
name|machine
operator|=
literal|0
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TIC30MAGIC
case|case
name|TIC30MAGIC
case|:
name|arch
operator|=
name|bfd_arch_tic30
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TICOFF0MAGIC
ifdef|#
directive|ifdef
name|TICOFF_TARGET_ARCH
comment|/* this TI COFF section should be used by all new TI COFF v0 targets */
case|case
name|TICOFF0MAGIC
case|:
name|arch
operator|=
name|TICOFF_TARGET_ARCH
expr_stmt|;
break|break;
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TICOFF1MAGIC
comment|/* this TI COFF section should be used by all new TI COFF v1/2 targets */
comment|/* TI COFF1 and COFF2 use the target_id field to specify which arch */
case|case
name|TICOFF1MAGIC
case|:
case|case
name|TICOFF2MAGIC
case|:
switch|switch
condition|(
name|internal_f
operator|->
name|f_target_id
condition|)
block|{
ifdef|#
directive|ifdef
name|TI_TARGET_ID
case|case
name|TI_TARGET_ID
case|:
name|arch
operator|=
name|TICOFF_TARGET_ARCH
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|arch
operator|=
name|bfd_arch_obscure
expr_stmt|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Unrecognized TI COFF target id '0x%x'"
argument_list|)
argument_list|,
name|internal_f
operator|->
name|f_target_id
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TIC80_ARCH_MAGIC
case|case
name|TIC80_ARCH_MAGIC
case|:
name|arch
operator|=
name|bfd_arch_tic80
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MCOREMAGIC
case|case
name|MCOREMAGIC
case|:
name|arch
operator|=
name|bfd_arch_mcore
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
comment|/* Unreadable input file type */
name|arch
operator|=
name|bfd_arch_obscure
expr_stmt|;
break|break;
block|}
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|arch
argument_list|,
name|machine
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SYMNAME_IN_DEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|boolean
name|symname_in_debug_hook
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|internal_syment
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|boolean
name|symname_in_debug_hook
parameter_list|(
name|abfd
parameter_list|,
name|sym
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|internal_syment
modifier|*
name|sym
decl_stmt|;
block|{
return|return
name|SYMNAME_IN_DEBUG
argument_list|(
name|sym
argument_list|)
condition|?
name|true
else|:
name|false
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|symname_in_debug_hook
define|\
value|(boolean (*) PARAMS ((bfd *, struct internal_syment *))) bfd_false
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|RS6000COFF_C
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|XCOFF64
end_ifdef

begin_define
define|#
directive|define
name|FORCE_SYMNAMES_IN_STRINGS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Handle the csect auxent of a C_EXT or C_HIDEXT symbol.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|coff_pointerize_aux_hook
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|combined_entry_type
operator|*
operator|,
name|combined_entry_type
operator|*
operator|,
name|unsigned
name|int
operator|,
name|combined_entry_type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|boolean
name|coff_pointerize_aux_hook
parameter_list|(
name|abfd
parameter_list|,
name|table_base
parameter_list|,
name|symbol
parameter_list|,
name|indaux
parameter_list|,
name|aux
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|combined_entry_type
modifier|*
name|table_base
decl_stmt|;
name|combined_entry_type
modifier|*
name|symbol
decl_stmt|;
name|unsigned
name|int
name|indaux
decl_stmt|;
name|combined_entry_type
modifier|*
name|aux
decl_stmt|;
block|{
name|int
name|class
init|=
name|symbol
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
decl_stmt|;
if|if
condition|(
operator|(
name|class
operator|==
name|C_EXT
operator|||
name|class
operator|==
name|C_HIDEXT
operator|)
operator|&&
name|indaux
operator|+
literal|1
operator|==
name|symbol
operator|->
name|u
operator|.
name|syment
operator|.
name|n_numaux
condition|)
block|{
if|if
condition|(
name|SMTYP_SMTYP
argument_list|(
name|aux
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_csect
operator|.
name|x_smtyp
argument_list|)
operator|==
name|XTY_LD
condition|)
block|{
name|aux
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_csect
operator|.
name|x_scnlen
operator|.
name|p
operator|=
name|table_base
operator|+
name|aux
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_csect
operator|.
name|x_scnlen
operator|.
name|l
expr_stmt|;
name|aux
operator|->
name|fix_scnlen
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Return true to indicate that the caller should not do any          further work on this auxent.  */
return|return
name|true
return|;
block|}
comment|/* Return false to indicate that this auxent should be handled by      the caller.  */
return|return
name|false
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|I960
end_ifdef

begin_comment
comment|/* We don't want to pointerize bal entries.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|coff_pointerize_aux_hook
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|combined_entry_type
operator|*
operator|,
name|combined_entry_type
operator|*
operator|,
name|unsigned
name|int
operator|,
name|combined_entry_type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|boolean
name|coff_pointerize_aux_hook
parameter_list|(
name|abfd
parameter_list|,
name|table_base
parameter_list|,
name|symbol
parameter_list|,
name|indaux
parameter_list|,
name|aux
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|combined_entry_type
modifier|*
name|table_base
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|combined_entry_type
modifier|*
name|symbol
decl_stmt|;
name|unsigned
name|int
name|indaux
decl_stmt|;
name|combined_entry_type
modifier|*
name|aux
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* Return true if we don't want to pointerize this aux entry, which      is the case for the lastfirst aux entry for a C_LEAFPROC symbol.  */
return|return
operator|(
name|indaux
operator|==
literal|1
operator|&&
operator|(
name|symbol
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
operator|==
name|C_LEAFPROC
operator|||
name|symbol
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
operator|==
name|C_LEAFSTAT
operator|||
name|symbol
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
operator|==
name|C_LEAFEXT
operator|)
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! I960 */
end_comment

begin_define
define|#
directive|define
name|coff_pointerize_aux_hook
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! I960 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! RS6000COFF_C */
end_comment

begin_comment
comment|/* Print an aux entry.  This returns true if it has printed it.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|coff_print_aux
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|FILE
operator|*
operator|,
name|combined_entry_type
operator|*
operator|,
name|combined_entry_type
operator|*
operator|,
name|combined_entry_type
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|boolean
name|coff_print_aux
parameter_list|(
name|abfd
parameter_list|,
name|file
parameter_list|,
name|table_base
parameter_list|,
name|symbol
parameter_list|,
name|aux
parameter_list|,
name|indaux
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|FILE
modifier|*
name|file
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|combined_entry_type
modifier|*
name|table_base
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|combined_entry_type
modifier|*
name|symbol
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|combined_entry_type
modifier|*
name|aux
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|unsigned
name|int
name|indaux
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|RS6000COFF_C
if|if
condition|(
operator|(
name|symbol
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
operator|==
name|C_EXT
operator|||
name|symbol
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
operator|==
name|C_HIDEXT
operator|)
operator|&&
name|indaux
operator|+
literal|1
operator|==
name|symbol
operator|->
name|u
operator|.
name|syment
operator|.
name|n_numaux
condition|)
block|{
comment|/* This is a csect entry.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"AUX "
argument_list|)
expr_stmt|;
if|if
condition|(
name|SMTYP_SMTYP
argument_list|(
name|aux
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_csect
operator|.
name|x_smtyp
argument_list|)
operator|!=
name|XTY_LD
condition|)
block|{
name|BFD_ASSERT
argument_list|(
operator|!
name|aux
operator|->
name|fix_scnlen
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|XCOFF64
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"val %5lld"
argument_list|,
name|aux
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_csect
operator|.
name|x_scnlen
operator|.
name|l
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"val %5ld"
argument_list|,
operator|(
name|long
operator|)
name|aux
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_csect
operator|.
name|x_scnlen
operator|.
name|l
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"indx "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|aux
operator|->
name|fix_scnlen
condition|)
ifdef|#
directive|ifdef
name|XCOFF64
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%4lld"
argument_list|,
name|aux
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_csect
operator|.
name|x_scnlen
operator|.
name|l
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%4ld"
argument_list|,
operator|(
name|long
operator|)
name|aux
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_csect
operator|.
name|x_scnlen
operator|.
name|l
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%4ld"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|aux
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_csect
operator|.
name|x_scnlen
operator|.
name|p
operator|-
name|table_base
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" prmhsh %ld snhsh %u typ %d algn %d clss %u stb %ld snstb %u"
argument_list|,
name|aux
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_csect
operator|.
name|x_parmhash
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|aux
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_csect
operator|.
name|x_snhash
argument_list|,
name|SMTYP_SMTYP
argument_list|(
name|aux
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_csect
operator|.
name|x_smtyp
argument_list|)
argument_list|,
name|SMTYP_ALIGN
argument_list|(
name|aux
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_csect
operator|.
name|x_smtyp
argument_list|)
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|aux
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_csect
operator|.
name|x_smclas
argument_list|,
name|aux
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_csect
operator|.
name|x_stab
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|aux
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_csect
operator|.
name|x_snstab
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
endif|#
directive|endif
comment|/* Return false to indicate that no special action was taken.  */
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* SUBSUBSECTION 	Writing relocations  	To write relocations, the back end steps though the 	canonical relocation table and create an 	@code{internal_reloc}. The symbol index to use is removed from 	the @code{offset} field in the symbol table supplied.  The 	address comes directly from the sum of the section base 	address and the relocation offset; the type is dug directly 	from the howto field.  Then the @code{internal_reloc} is 	swapped into the shape of an @code{external_reloc} and written 	out to disk.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TARG_AUX
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|compare_arelent_ptr
name|PARAMS
argument_list|(
operator|(
specifier|const
name|PTR
operator|,
specifier|const
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* AUX's ld wants relocations to be sorted */
end_comment

begin_function
specifier|static
name|int
name|compare_arelent_ptr
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
specifier|const
name|PTR
name|x
decl_stmt|;
specifier|const
name|PTR
name|y
decl_stmt|;
block|{
specifier|const
name|arelent
modifier|*
modifier|*
name|a
init|=
operator|(
specifier|const
name|arelent
operator|*
operator|*
operator|)
name|x
decl_stmt|;
specifier|const
name|arelent
modifier|*
modifier|*
name|b
init|=
operator|(
specifier|const
name|arelent
operator|*
operator|*
operator|)
name|y
decl_stmt|;
name|bfd_size_type
name|aadr
init|=
operator|(
operator|*
name|a
operator|)
operator|->
name|address
decl_stmt|;
name|bfd_size_type
name|badr
init|=
operator|(
operator|*
name|b
operator|)
operator|->
name|address
decl_stmt|;
return|return
operator|(
name|aadr
operator|<
name|badr
condition|?
operator|-
literal|1
else|:
name|badr
operator|<
name|aadr
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TARG_AUX */
end_comment

begin_function
specifier|static
name|boolean
name|coff_write_relocs
parameter_list|(
name|abfd
parameter_list|,
name|first_undef
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|int
name|first_undef
decl_stmt|;
block|{
name|asection
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|external_reloc
name|dst
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|p
decl_stmt|;
ifndef|#
directive|ifndef
name|TARG_AUX
name|p
operator|=
name|s
operator|->
name|orelocation
expr_stmt|;
else|#
directive|else
block|{
comment|/* sort relocations before we write them out */
name|bfd_size_type
name|amt
decl_stmt|;
name|amt
operator|=
name|s
operator|->
name|reloc_count
expr_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|arelent
operator|*
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|&&
name|s
operator|->
name|reloc_count
operator|>
literal|0
condition|)
return|return
name|false
return|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|s
operator|->
name|orelocation
argument_list|,
operator|(
name|size_t
operator|)
name|amt
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|p
argument_list|,
name|s
operator|->
name|reloc_count
argument_list|,
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
argument_list|,
name|compare_arelent_ptr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|s
operator|->
name|rel_filepos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
ifdef|#
directive|ifdef
name|COFF_WITH_PE
if|if
condition|(
name|s
operator|->
name|reloc_count
operator|>
literal|0xffff
condition|)
block|{
comment|/* encode real count here as first reloc */
name|struct
name|internal_reloc
name|n
decl_stmt|;
name|memset
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|n
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
comment|/* add one to count *this* reloc (grr) */
name|n
operator|.
name|r_vaddr
operator|=
name|s
operator|->
name|reloc_count
operator|+
literal|1
expr_stmt|;
name|coff_swap_reloc_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|n
argument_list|,
operator|&
name|dst
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|dst
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|bfd_coff_relsz
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|abfd
argument_list|)
operator|!=
name|bfd_coff_relsz
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
block|}
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|s
operator|->
name|reloc_count
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|internal_reloc
name|n
decl_stmt|;
name|arelent
modifier|*
name|q
init|=
name|p
index|[
name|i
index|]
decl_stmt|;
name|memset
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|n
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now we've renumbered the symbols we know where the 	     undefined symbols live in the table.  Check the reloc 	     entries for symbols who's output bfd isn't the right one. 	     This is because the symbol was undefined (which means 	     that all the pointers are never made to point to the same 	     place). This is a bad thing,'cause the symbols attached 	     to the output bfd are indexed, so that the relocation 	     entries know which symbol index they point to.  So we 	     have to look up the output symbol here.  */
if|if
condition|(
name|q
operator|->
name|sym_ptr_ptr
index|[
literal|0
index|]
operator|->
name|the_bfd
operator|!=
name|abfd
condition|)
block|{
name|int
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|sname
init|=
name|q
operator|->
name|sym_ptr_ptr
index|[
literal|0
index|]
operator|->
name|name
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|outsyms
init|=
name|abfd
operator|->
name|outsymbols
decl_stmt|;
for|for
control|(
name|j
operator|=
name|first_undef
init|;
name|outsyms
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|intable
init|=
name|outsyms
index|[
name|j
index|]
operator|->
name|name
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|intable
argument_list|,
name|sname
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* got a hit, so repoint the reloc */
name|q
operator|->
name|sym_ptr_ptr
operator|=
name|outsyms
operator|+
name|j
expr_stmt|;
break|break;
block|}
block|}
block|}
name|n
operator|.
name|r_vaddr
operator|=
name|q
operator|->
name|address
operator|+
name|s
operator|->
name|vma
expr_stmt|;
ifdef|#
directive|ifdef
name|R_IHCONST
comment|/* The 29k const/consth reloc pair is a real kludge.  The consth 	     part doesn't have a symbol; it has an offset.  So rebuilt 	     that here.  */
if|if
condition|(
name|q
operator|->
name|howto
operator|->
name|type
operator|==
name|R_IHCONST
condition|)
name|n
operator|.
name|r_symndx
operator|=
name|q
operator|->
name|addend
expr_stmt|;
elseif|else
endif|#
directive|endif
if|if
condition|(
name|q
operator|->
name|sym_ptr_ptr
condition|)
block|{
ifdef|#
directive|ifdef
name|SECTION_RELATIVE_ABSOLUTE_SYMBOL_P
if|if
condition|(
name|SECTION_RELATIVE_ABSOLUTE_SYMBOL_P
argument_list|(
name|q
argument_list|,
name|s
argument_list|)
condition|)
else|#
directive|else
if|if
condition|(
name|q
operator|->
name|sym_ptr_ptr
operator|==
name|bfd_abs_section_ptr
operator|->
name|symbol_ptr_ptr
condition|)
endif|#
directive|endif
comment|/* This is a relocation relative to the absolute symbol.  */
name|n
operator|.
name|r_symndx
operator|=
operator|-
literal|1
expr_stmt|;
else|else
block|{
name|n
operator|.
name|r_symndx
operator|=
name|get_index
argument_list|(
operator|(
operator|*
operator|(
name|q
operator|->
name|sym_ptr_ptr
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Take notice if the symbol reloc points to a symbol 		       we don't have in our symbol table.  What should we 		       do for this??  */
if|if
condition|(
name|n
operator|.
name|r_symndx
operator|>
name|obj_conv_table_size
argument_list|(
name|abfd
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|SWAP_OUT_RELOC_OFFSET
name|n
operator|.
name|r_offset
operator|=
name|q
operator|->
name|addend
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SELECT_RELOC
comment|/* Work out reloc type from what is required */
name|SELECT_RELOC
argument_list|(
name|n
argument_list|,
name|q
operator|->
name|howto
argument_list|)
expr_stmt|;
else|#
directive|else
name|n
operator|.
name|r_type
operator|=
name|q
operator|->
name|howto
operator|->
name|type
expr_stmt|;
endif|#
directive|endif
name|coff_swap_reloc_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|n
argument_list|,
operator|&
name|dst
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|dst
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|bfd_coff_relsz
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|abfd
argument_list|)
operator|!=
name|bfd_coff_relsz
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
block|}
ifdef|#
directive|ifdef
name|TARG_AUX
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Set flags and magic number of a coff file from architecture and machine    type.  Result is true if we can represent the arch&type, false if not.  */
end_comment

begin_function
specifier|static
name|boolean
name|coff_set_flags
parameter_list|(
name|abfd
parameter_list|,
name|magicp
parameter_list|,
name|flagsp
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|unsigned
name|int
modifier|*
name|magicp
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|unsigned
name|short
modifier|*
name|flagsp
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
switch|switch
condition|(
name|bfd_get_arch
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|Z8KMAGIC
case|case
name|bfd_arch_z8k
case|:
operator|*
name|magicp
operator|=
name|Z8KMAGIC
expr_stmt|;
switch|switch
condition|(
name|bfd_get_mach
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
case|case
name|bfd_mach_z8001
case|:
operator|*
name|flagsp
operator|=
name|F_Z8001
expr_stmt|;
break|break;
case|case
name|bfd_mach_z8002
case|:
operator|*
name|flagsp
operator|=
name|F_Z8002
expr_stmt|;
break|break;
default|default:
return|return
name|false
return|;
block|}
return|return
name|true
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|I960ROMAGIC
case|case
name|bfd_arch_i960
case|:
block|{
name|unsigned
name|flags
decl_stmt|;
operator|*
name|magicp
operator|=
name|I960ROMAGIC
expr_stmt|;
comment|/* 	  ((bfd_get_file_flags(abfd)& WP_TEXT) ? I960ROMAGIC : 	  I960RWMAGIC);   FIXME??? 	  */
switch|switch
condition|(
name|bfd_get_mach
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
case|case
name|bfd_mach_i960_core
case|:
name|flags
operator|=
name|F_I960CORE
expr_stmt|;
break|break;
case|case
name|bfd_mach_i960_kb_sb
case|:
name|flags
operator|=
name|F_I960KB
expr_stmt|;
break|break;
case|case
name|bfd_mach_i960_mc
case|:
name|flags
operator|=
name|F_I960MC
expr_stmt|;
break|break;
case|case
name|bfd_mach_i960_xa
case|:
name|flags
operator|=
name|F_I960XA
expr_stmt|;
break|break;
case|case
name|bfd_mach_i960_ca
case|:
name|flags
operator|=
name|F_I960CA
expr_stmt|;
break|break;
case|case
name|bfd_mach_i960_ka_sa
case|:
name|flags
operator|=
name|F_I960KA
expr_stmt|;
break|break;
case|case
name|bfd_mach_i960_jx
case|:
name|flags
operator|=
name|F_I960JX
expr_stmt|;
break|break;
case|case
name|bfd_mach_i960_hx
case|:
name|flags
operator|=
name|F_I960HX
expr_stmt|;
break|break;
default|default:
return|return
name|false
return|;
block|}
operator|*
name|flagsp
operator|=
name|flags
expr_stmt|;
return|return
name|true
return|;
block|}
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TIC30MAGIC
case|case
name|bfd_arch_tic30
case|:
operator|*
name|magicp
operator|=
name|TIC30MAGIC
expr_stmt|;
return|return
name|true
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TICOFF_DEFAULT_MAGIC
case|case
name|TICOFF_TARGET_ARCH
case|:
comment|/* if there's no indication of which version we want, use the default */
if|if
condition|(
operator|!
name|abfd
operator|->
name|xvec
condition|)
operator|*
name|magicp
operator|=
name|TICOFF_DEFAULT_MAGIC
expr_stmt|;
else|else
block|{
comment|/* we may want to output in a different COFF version */
switch|switch
condition|(
name|abfd
operator|->
name|xvec
operator|->
name|name
index|[
literal|4
index|]
condition|)
block|{
case|case
literal|'0'
case|:
operator|*
name|magicp
operator|=
name|TICOFF0MAGIC
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
operator|*
name|magicp
operator|=
name|TICOFF1MAGIC
expr_stmt|;
break|break;
case|case
literal|'2'
case|:
operator|*
name|magicp
operator|=
name|TICOFF2MAGIC
expr_stmt|;
break|break;
default|default:
return|return
name|false
return|;
block|}
block|}
return|return
name|true
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TIC80_ARCH_MAGIC
case|case
name|bfd_arch_tic80
case|:
operator|*
name|magicp
operator|=
name|TIC80_ARCH_MAGIC
expr_stmt|;
return|return
name|true
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARMMAGIC
case|case
name|bfd_arch_arm
case|:
ifdef|#
directive|ifdef
name|ARM_WINCE
operator|*
name|magicp
operator|=
name|ARMPEMAGIC
expr_stmt|;
else|#
directive|else
operator|*
name|magicp
operator|=
name|ARMMAGIC
expr_stmt|;
endif|#
directive|endif
operator|*
name|flagsp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|APCS_SET
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
if|if
condition|(
name|APCS_26_FLAG
argument_list|(
name|abfd
argument_list|)
condition|)
operator|*
name|flagsp
operator||=
name|F_APCS26
expr_stmt|;
if|if
condition|(
name|APCS_FLOAT_FLAG
argument_list|(
name|abfd
argument_list|)
condition|)
operator|*
name|flagsp
operator||=
name|F_APCS_FLOAT
expr_stmt|;
if|if
condition|(
name|PIC_FLAG
argument_list|(
name|abfd
argument_list|)
condition|)
operator|*
name|flagsp
operator||=
name|F_PIC
expr_stmt|;
block|}
if|if
condition|(
name|INTERWORK_SET
argument_list|(
name|abfd
argument_list|)
operator|&&
name|INTERWORK_FLAG
argument_list|(
name|abfd
argument_list|)
condition|)
operator|*
name|flagsp
operator||=
name|F_INTERWORK
expr_stmt|;
switch|switch
condition|(
name|bfd_get_mach
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
case|case
name|bfd_mach_arm_2
case|:
operator|*
name|flagsp
operator||=
name|F_ARM_2
expr_stmt|;
break|break;
case|case
name|bfd_mach_arm_2a
case|:
operator|*
name|flagsp
operator||=
name|F_ARM_2a
expr_stmt|;
break|break;
case|case
name|bfd_mach_arm_3
case|:
operator|*
name|flagsp
operator||=
name|F_ARM_3
expr_stmt|;
break|break;
case|case
name|bfd_mach_arm_3M
case|:
operator|*
name|flagsp
operator||=
name|F_ARM_3M
expr_stmt|;
break|break;
case|case
name|bfd_mach_arm_4
case|:
operator|*
name|flagsp
operator||=
name|F_ARM_4
expr_stmt|;
break|break;
case|case
name|bfd_mach_arm_4T
case|:
operator|*
name|flagsp
operator||=
name|F_ARM_4T
expr_stmt|;
break|break;
case|case
name|bfd_mach_arm_5
case|:
operator|*
name|flagsp
operator||=
name|F_ARM_5
expr_stmt|;
break|break;
comment|/* FIXME: we do not have F_ARM vaues greater than F_ARM_5. 	     See also the comment in coff_set_arch_mach_hook().  */
case|case
name|bfd_mach_arm_5T
case|:
operator|*
name|flagsp
operator||=
name|F_ARM_5
expr_stmt|;
break|break;
case|case
name|bfd_mach_arm_5TE
case|:
operator|*
name|flagsp
operator||=
name|F_ARM_5
expr_stmt|;
break|break;
case|case
name|bfd_mach_arm_XScale
case|:
operator|*
name|flagsp
operator||=
name|F_ARM_5
expr_stmt|;
break|break;
block|}
return|return
name|true
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PPCMAGIC
case|case
name|bfd_arch_powerpc
case|:
operator|*
name|magicp
operator|=
name|PPCMAGIC
expr_stmt|;
return|return
name|true
return|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|I386MAGIC
case|case
name|bfd_arch_i386
case|:
operator|*
name|magicp
operator|=
name|I386MAGIC
expr_stmt|;
ifdef|#
directive|ifdef
name|LYNXOS
comment|/* Just overwrite the usual value if we're doing Lynx.  */
operator|*
name|magicp
operator|=
name|LYNXCOFFMAGIC
expr_stmt|;
endif|#
directive|endif
return|return
name|true
return|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|I860MAGIC
case|case
name|bfd_arch_i860
case|:
operator|*
name|magicp
operator|=
name|I860MAGIC
expr_stmt|;
return|return
name|true
return|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IA64MAGIC
case|case
name|bfd_arch_ia64
case|:
operator|*
name|magicp
operator|=
name|IA64MAGIC
expr_stmt|;
return|return
name|true
return|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MC68MAGIC
case|case
name|bfd_arch_m68k
case|:
ifdef|#
directive|ifdef
name|APOLLOM68KMAGIC
operator|*
name|magicp
operator|=
name|APOLLO_COFF_VERSION_NUMBER
expr_stmt|;
else|#
directive|else
comment|/* NAMES_HAVE_UNDERSCORE may be defined by coff-u68k.c.  */
ifdef|#
directive|ifdef
name|NAMES_HAVE_UNDERSCORE
operator|*
name|magicp
operator|=
name|MC68KBCSMAGIC
expr_stmt|;
else|#
directive|else
operator|*
name|magicp
operator|=
name|MC68MAGIC
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LYNXOS
comment|/* Just overwrite the usual value if we're doing Lynx.  */
operator|*
name|magicp
operator|=
name|LYNXCOFFMAGIC
expr_stmt|;
endif|#
directive|endif
return|return
name|true
return|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MC88MAGIC
case|case
name|bfd_arch_m88k
case|:
operator|*
name|magicp
operator|=
name|MC88OMAGIC
expr_stmt|;
return|return
name|true
return|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|H8300MAGIC
case|case
name|bfd_arch_h8300
case|:
switch|switch
condition|(
name|bfd_get_mach
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
case|case
name|bfd_mach_h8300
case|:
operator|*
name|magicp
operator|=
name|H8300MAGIC
expr_stmt|;
return|return
name|true
return|;
case|case
name|bfd_mach_h8300h
case|:
operator|*
name|magicp
operator|=
name|H8300HMAGIC
expr_stmt|;
return|return
name|true
return|;
case|case
name|bfd_mach_h8300s
case|:
operator|*
name|magicp
operator|=
name|H8300SMAGIC
expr_stmt|;
return|return
name|true
return|;
block|}
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SH_ARCH_MAGIC_BIG
case|case
name|bfd_arch_sh
case|:
ifdef|#
directive|ifdef
name|COFF_IMAGE_WITH_PE
operator|*
name|magicp
operator|=
name|SH_ARCH_MAGIC_WINCE
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|bfd_big_endian
argument_list|(
name|abfd
argument_list|)
condition|)
operator|*
name|magicp
operator|=
name|SH_ARCH_MAGIC_BIG
expr_stmt|;
else|else
operator|*
name|magicp
operator|=
name|SH_ARCH_MAGIC_LITTLE
expr_stmt|;
endif|#
directive|endif
return|return
name|true
return|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MIPS_ARCH_MAGIC_WINCE
case|case
name|bfd_arch_mips
case|:
operator|*
name|magicp
operator|=
name|MIPS_ARCH_MAGIC_WINCE
expr_stmt|;
return|return
name|true
return|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SPARCMAGIC
case|case
name|bfd_arch_sparc
case|:
operator|*
name|magicp
operator|=
name|SPARCMAGIC
expr_stmt|;
ifdef|#
directive|ifdef
name|LYNXOS
comment|/* Just overwrite the usual value if we're doing Lynx.  */
operator|*
name|magicp
operator|=
name|LYNXCOFFMAGIC
expr_stmt|;
endif|#
directive|endif
return|return
name|true
return|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|H8500MAGIC
case|case
name|bfd_arch_h8500
case|:
operator|*
name|magicp
operator|=
name|H8500MAGIC
expr_stmt|;
return|return
name|true
return|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|A29K_MAGIC_BIG
case|case
name|bfd_arch_a29k
case|:
if|if
condition|(
name|bfd_big_endian
argument_list|(
name|abfd
argument_list|)
condition|)
operator|*
name|magicp
operator|=
name|A29K_MAGIC_BIG
expr_stmt|;
else|else
operator|*
name|magicp
operator|=
name|A29K_MAGIC_LITTLE
expr_stmt|;
return|return
name|true
return|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|WE32KMAGIC
case|case
name|bfd_arch_we32k
case|:
operator|*
name|magicp
operator|=
name|WE32KMAGIC
expr_stmt|;
return|return
name|true
return|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RS6000COFF_C
case|case
name|bfd_arch_rs6000
case|:
ifndef|#
directive|ifndef
name|PPCMAGIC
case|case
name|bfd_arch_powerpc
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XCOFF64
if|if
condition|(
name|bfd_get_mach
argument_list|(
name|abfd
argument_list|)
operator|==
name|bfd_mach_ppc_620
operator|&&
operator|!
name|strncmp
argument_list|(
name|abfd
operator|->
name|xvec
operator|->
name|name
argument_list|,
literal|"aix"
argument_list|,
literal|3
argument_list|)
condition|)
operator|*
name|magicp
operator|=
name|U803XTOCMAGIC
expr_stmt|;
else|else
else|#
directive|else
operator|*
name|magicp
operator|=
name|U802TOCMAGIC
expr_stmt|;
endif|#
directive|endif
return|return
name|true
return|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MCOREMAGIC
case|case
name|bfd_arch_mcore
case|:
operator|*
name|magicp
operator|=
name|MCOREMAGIC
expr_stmt|;
return|return
name|true
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|W65MAGIC
case|case
name|bfd_arch_w65
case|:
operator|*
name|magicp
operator|=
name|W65MAGIC
expr_stmt|;
return|return
name|true
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OR32_MAGIC_BIG
case|case
name|bfd_arch_or32
case|:
if|if
condition|(
name|bfd_big_endian
argument_list|(
name|abfd
argument_list|)
condition|)
operator|*
name|magicp
operator|=
name|OR32_MAGIC_BIG
expr_stmt|;
else|else
operator|*
name|magicp
operator|=
name|OR32_MAGIC_LITTLE
expr_stmt|;
return|return
name|true
return|;
endif|#
directive|endif
default|default:
comment|/* Unknown architecture.  */
comment|/* Fall through to "return false" below, to avoid 	 "statement never reached" errors on the one below.  */
break|break;
block|}
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|coff_set_arch_mach
parameter_list|(
name|abfd
parameter_list|,
name|arch
parameter_list|,
name|machine
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|enum
name|bfd_architecture
name|arch
decl_stmt|;
name|unsigned
name|long
name|machine
decl_stmt|;
block|{
name|unsigned
name|dummy1
decl_stmt|;
name|unsigned
name|short
name|dummy2
decl_stmt|;
if|if
condition|(
operator|!
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|arch
argument_list|,
name|machine
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|arch
operator|!=
name|bfd_arch_unknown
operator|&&
name|coff_set_flags
argument_list|(
name|abfd
argument_list|,
operator|&
name|dummy1
argument_list|,
operator|&
name|dummy2
argument_list|)
operator|!=
name|true
condition|)
return|return
name|false
return|;
comment|/* We can't represent this type */
return|return
name|true
return|;
comment|/* We're easy ...  */
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|COFF_IMAGE_WITH_PE
end_ifdef

begin_comment
comment|/* This is used to sort sections by VMA, as required by PE image    files.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sort_by_secaddr
name|PARAMS
argument_list|(
operator|(
specifier|const
name|PTR
operator|,
specifier|const
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|sort_by_secaddr
parameter_list|(
name|arg1
parameter_list|,
name|arg2
parameter_list|)
specifier|const
name|PTR
name|arg1
decl_stmt|;
specifier|const
name|PTR
name|arg2
decl_stmt|;
block|{
specifier|const
name|asection
modifier|*
name|a
init|=
operator|*
operator|(
specifier|const
name|asection
operator|*
operator|*
operator|)
name|arg1
decl_stmt|;
specifier|const
name|asection
modifier|*
name|b
init|=
operator|*
operator|(
specifier|const
name|asection
operator|*
operator|*
operator|)
name|arg2
decl_stmt|;
if|if
condition|(
name|a
operator|->
name|vma
operator|<
name|b
operator|->
name|vma
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|a
operator|->
name|vma
operator|>
name|b
operator|->
name|vma
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* COFF_IMAGE_WITH_PE */
end_comment

begin_comment
comment|/* Calculate the file position for each section.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|I960
end_ifndef

begin_define
define|#
directive|define
name|ALIGN_SECTIONS_IN_FILE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TIC80COFF
argument_list|)
operator|||
name|defined
argument_list|(
name|TICOFF
argument_list|)
end_if

begin_undef
undef|#
directive|undef
name|ALIGN_SECTIONS_IN_FILE
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|boolean
name|coff_compute_section_file_positions
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|asection
modifier|*
name|current
decl_stmt|;
name|asection
modifier|*
name|previous
init|=
operator|(
name|asection
operator|*
operator|)
name|NULL
decl_stmt|;
name|file_ptr
name|sofar
init|=
name|bfd_coff_filhsz
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|boolean
name|align_adjust
decl_stmt|;
ifdef|#
directive|ifdef
name|ALIGN_SECTIONS_IN_FILE
name|file_ptr
name|old_sofar
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RS6000COFF_C
comment|/* On XCOFF, if we have symbols, set up the .debug section.  */
if|if
condition|(
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|>
literal|0
condition|)
block|{
name|bfd_size_type
name|sz
decl_stmt|;
name|bfd_size_type
name|i
decl_stmt|,
name|symcount
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symp
decl_stmt|;
name|sz
operator|=
literal|0
expr_stmt|;
name|symcount
operator|=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
for|for
control|(
name|symp
operator|=
name|abfd
operator|->
name|outsymbols
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|symcount
condition|;
name|symp
operator|++
operator|,
name|i
operator|++
control|)
block|{
name|coff_symbol_type
modifier|*
name|cf
decl_stmt|;
name|cf
operator|=
name|coff_symbol_from
argument_list|(
name|abfd
argument_list|,
operator|*
name|symp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cf
operator|!=
name|NULL
operator|&&
name|cf
operator|->
name|native
operator|!=
name|NULL
operator|&&
name|SYMNAME_IN_DEBUG
argument_list|(
operator|&
name|cf
operator|->
name|native
operator|->
name|u
operator|.
name|syment
argument_list|)
condition|)
block|{
name|size_t
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|bfd_asymbol_name
argument_list|(
operator|*
name|symp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|SYMNMLEN
operator|||
name|bfd_coff_force_symnames_in_strings
argument_list|(
name|abfd
argument_list|)
condition|)
name|sz
operator|+=
name|len
operator|+
literal|1
operator|+
name|bfd_coff_debug_string_prefix_length
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sz
operator|>
literal|0
condition|)
block|{
name|asection
modifier|*
name|dsec
decl_stmt|;
name|dsec
operator|=
name|bfd_make_section_old_way
argument_list|(
name|abfd
argument_list|,
literal|".debug"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsec
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|dsec
operator|->
name|_raw_size
operator|=
name|sz
expr_stmt|;
name|dsec
operator|->
name|flags
operator||=
name|SEC_HAS_CONTENTS
expr_stmt|;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|COFF_IMAGE_WITH_PE
name|int
name|page_size
decl_stmt|;
if|if
condition|(
name|coff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|link_info
condition|)
block|{
name|page_size
operator|=
name|pe_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|pe_opthdr
operator|.
name|FileAlignment
expr_stmt|;
block|}
else|else
name|page_size
operator|=
name|PE_DEF_FILE_ALIGNMENT
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|COFF_PAGE_SIZE
name|int
name|page_size
init|=
name|COFF_PAGE_SIZE
decl_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|bfd_get_start_address
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
comment|/*  A start address may have been added to the original file. In this 	  case it will need an optional header to record it.  */
name|abfd
operator|->
name|flags
operator||=
name|EXEC_P
expr_stmt|;
block|}
if|if
condition|(
name|abfd
operator|->
name|flags
operator|&
name|EXEC_P
condition|)
name|sofar
operator|+=
name|bfd_coff_aoutsz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RS6000COFF_C
elseif|else
if|if
condition|(
name|xcoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|full_aouthdr
condition|)
name|sofar
operator|+=
name|bfd_coff_aoutsz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
else|else
name|sofar
operator|+=
name|SMALL_AOUTSZ
expr_stmt|;
endif|#
directive|endif
name|sofar
operator|+=
name|abfd
operator|->
name|section_count
operator|*
name|bfd_coff_scnhsz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RS6000COFF_C
comment|/* XCOFF handles overflows in the reloc and line number count fields      by allocating a new section header to hold the correct counts.  */
for|for
control|(
name|current
operator|=
name|abfd
operator|->
name|sections
init|;
name|current
operator|!=
name|NULL
condition|;
name|current
operator|=
name|current
operator|->
name|next
control|)
if|if
condition|(
name|current
operator|->
name|reloc_count
operator|>=
literal|0xffff
operator|||
name|current
operator|->
name|lineno_count
operator|>=
literal|0xffff
condition|)
name|sofar
operator|+=
name|bfd_coff_scnhsz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|COFF_IMAGE_WITH_PE
block|{
comment|/* PE requires the sections to be in memory order when listed in        the section headers.  It also does not like empty loadable        sections.  The sections apparently do not have to be in the        right order in the image file itself, but we do need to get the        target_index values right.  */
name|unsigned
name|int
name|count
decl_stmt|;
name|asection
modifier|*
modifier|*
name|section_list
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|int
name|target_index
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|current
operator|=
name|abfd
operator|->
name|sections
init|;
name|current
operator|!=
name|NULL
condition|;
name|current
operator|=
name|current
operator|->
name|next
control|)
operator|++
name|count
expr_stmt|;
comment|/* We allocate an extra cell to simplify the final loop.  */
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|asection
operator|*
argument_list|)
operator|*
operator|(
name|count
operator|+
literal|1
operator|)
expr_stmt|;
name|section_list
operator|=
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|section_list
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|current
operator|=
name|abfd
operator|->
name|sections
init|;
name|current
operator|!=
name|NULL
condition|;
name|current
operator|=
name|current
operator|->
name|next
control|)
block|{
name|section_list
index|[
name|i
index|]
operator|=
name|current
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
name|section_list
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|qsort
argument_list|(
name|section_list
argument_list|,
name|count
argument_list|,
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
argument_list|,
name|sort_by_secaddr
argument_list|)
expr_stmt|;
comment|/* Rethread the linked list into sorted order; at the same time,        assign target_index values.  */
name|target_index
operator|=
literal|1
expr_stmt|;
name|abfd
operator|->
name|sections
operator|=
name|section_list
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|current
operator|=
name|section_list
index|[
name|i
index|]
expr_stmt|;
name|current
operator|->
name|next
operator|=
name|section_list
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
comment|/* Later, if the section has zero size, we'll be throwing it 	   away, so we don't want to number it now.  Note that having 	   a zero size and having real contents are different 	   concepts: .bss has no contents, but (usually) non-zero 	   size.  */
if|if
condition|(
name|current
operator|->
name|_raw_size
operator|==
literal|0
condition|)
block|{
comment|/* Discard.  However, it still might have (valid) symbols 	       in it, so arbitrarily set it to section 1 (indexing is 	       1-based here; usually .text).  __end__ and other 	       contents of .endsection really have this happen. 	       FIXME: This seems somewhat dubious.  */
name|current
operator|->
name|target_index
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|current
operator|->
name|target_index
operator|=
name|target_index
operator|++
expr_stmt|;
block|}
name|free
argument_list|(
name|section_list
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* ! COFF_IMAGE_WITH_PE */
block|{
comment|/* Set the target_index field.  */
name|int
name|target_index
decl_stmt|;
name|target_index
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|current
operator|=
name|abfd
operator|->
name|sections
init|;
name|current
operator|!=
name|NULL
condition|;
name|current
operator|=
name|current
operator|->
name|next
control|)
name|current
operator|->
name|target_index
operator|=
name|target_index
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* ! COFF_IMAGE_WITH_PE */
name|align_adjust
operator|=
name|false
expr_stmt|;
for|for
control|(
name|current
operator|=
name|abfd
operator|->
name|sections
init|;
name|current
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|;
name|current
operator|=
name|current
operator|->
name|next
control|)
block|{
ifdef|#
directive|ifdef
name|COFF_IMAGE_WITH_PE
comment|/* With PE we have to pad each section to be a multiple of its 	 page size too, and remember both sizes.  */
if|if
condition|(
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|current
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|coff_section_tdata
argument_list|)
decl_stmt|;
name|current
operator|->
name|used_by_bfd
operator|=
operator|(
name|PTR
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|->
name|used_by_bfd
operator|==
name|NULL
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|pei_section_data
argument_list|(
name|abfd
argument_list|,
name|current
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|pei_section_tdata
argument_list|)
decl_stmt|;
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|current
argument_list|)
operator|->
name|tdata
operator|=
operator|(
name|PTR
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|current
argument_list|)
operator|->
name|tdata
operator|==
name|NULL
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|pei_section_data
argument_list|(
name|abfd
argument_list|,
name|current
argument_list|)
operator|->
name|virt_size
operator|==
literal|0
condition|)
name|pei_section_data
argument_list|(
name|abfd
argument_list|,
name|current
argument_list|)
operator|->
name|virt_size
operator|=
name|current
operator|->
name|_raw_size
expr_stmt|;
endif|#
directive|endif
comment|/* Only deal with sections which have contents.  */
if|if
condition|(
operator|!
operator|(
name|current
operator|->
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|COFF_IMAGE_WITH_PE
comment|/* Make sure we skip empty sections in a PE image.  */
if|if
condition|(
name|current
operator|->
name|_raw_size
operator|==
literal|0
condition|)
continue|continue;
endif|#
directive|endif
comment|/* Align the sections in the file to the same boundary on 	 which they are aligned in virtual memory.  I960 doesn't 	 do this (FIXME) so we can stay in sync with Intel.  960 	 doesn't yet page from files...  */
ifdef|#
directive|ifdef
name|ALIGN_SECTIONS_IN_FILE
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|EXEC_P
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* make sure this section is aligned on the right boundary - by 	     padding the previous section up if necessary */
name|old_sofar
operator|=
name|sofar
expr_stmt|;
ifdef|#
directive|ifdef
name|RS6000COFF_C
comment|/* AIX loader checks the text section alignment of (vma - filepos) 	     So even though the filepos may be aligned wrt the o_algntext, for 	     AIX executables, this check fails. This shows up when an native  	     AIX executable is stripped with gnu strip because the default vma 	     of native is 0x10000150 but default for gnu is 0x10000140.  Gnu 	     stripped gnu excutable passes this check because the filepos is  	     0x0140. */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|current
operator|->
name|name
argument_list|,
name|_TEXT
argument_list|)
condition|)
block|{
name|bfd_vma
name|pad
decl_stmt|;
name|bfd_vma
name|align
decl_stmt|;
name|sofar
operator|=
name|BFD_ALIGN
argument_list|(
name|sofar
argument_list|,
literal|1
operator|<<
name|current
operator|->
name|alignment_power
argument_list|)
expr_stmt|;
name|align
operator|=
literal|1
operator|<<
name|current
operator|->
name|alignment_power
expr_stmt|;
name|pad
operator|=
name|abs
argument_list|(
name|current
operator|->
name|vma
operator|-
name|sofar
argument_list|)
operator|%
name|align
expr_stmt|;
if|if
condition|(
name|pad
condition|)
block|{
name|pad
operator|=
name|align
operator|-
name|pad
expr_stmt|;
name|sofar
operator|+=
name|pad
expr_stmt|;
block|}
block|}
else|else
else|#
directive|else
block|{
name|sofar
operator|=
name|BFD_ALIGN
argument_list|(
name|sofar
argument_list|,
literal|1
operator|<<
name|current
operator|->
name|alignment_power
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|previous
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
block|{
name|previous
operator|->
name|_raw_size
operator|+=
name|sofar
operator|-
name|old_sofar
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* In demand paged files the low order bits of the file offset 	 must match the low order bits of the virtual address.  */
ifdef|#
directive|ifdef
name|COFF_PAGE_SIZE
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|D_PAGED
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|current
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
name|sofar
operator|+=
operator|(
name|current
operator|->
name|vma
operator|-
name|sofar
operator|)
operator|%
name|page_size
expr_stmt|;
endif|#
directive|endif
name|current
operator|->
name|filepos
operator|=
name|sofar
expr_stmt|;
ifdef|#
directive|ifdef
name|COFF_IMAGE_WITH_PE
comment|/* Set the padded size.  */
name|current
operator|->
name|_raw_size
operator|=
operator|(
name|current
operator|->
name|_raw_size
operator|+
name|page_size
operator|-
literal|1
operator|)
operator|&
operator|-
name|page_size
expr_stmt|;
endif|#
directive|endif
name|sofar
operator|+=
name|current
operator|->
name|_raw_size
expr_stmt|;
ifdef|#
directive|ifdef
name|ALIGN_SECTIONS_IN_FILE
comment|/* make sure that this section is of the right size too */
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|EXEC_P
operator|)
operator|==
literal|0
condition|)
block|{
name|bfd_size_type
name|old_size
decl_stmt|;
name|old_size
operator|=
name|current
operator|->
name|_raw_size
expr_stmt|;
name|current
operator|->
name|_raw_size
operator|=
name|BFD_ALIGN
argument_list|(
name|current
operator|->
name|_raw_size
argument_list|,
literal|1
operator|<<
name|current
operator|->
name|alignment_power
argument_list|)
expr_stmt|;
name|align_adjust
operator|=
name|current
operator|->
name|_raw_size
operator|!=
name|old_size
expr_stmt|;
name|sofar
operator|+=
name|current
operator|->
name|_raw_size
operator|-
name|old_size
expr_stmt|;
block|}
else|else
block|{
name|old_sofar
operator|=
name|sofar
expr_stmt|;
name|sofar
operator|=
name|BFD_ALIGN
argument_list|(
name|sofar
argument_list|,
literal|1
operator|<<
name|current
operator|->
name|alignment_power
argument_list|)
expr_stmt|;
name|align_adjust
operator|=
name|sofar
operator|!=
name|old_sofar
expr_stmt|;
name|current
operator|->
name|_raw_size
operator|+=
name|sofar
operator|-
name|old_sofar
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|COFF_IMAGE_WITH_PE
comment|/* For PE we need to make sure we pad out to the aligned          _raw_size, in case the caller only writes out data to the          unaligned _raw_size.  */
if|if
condition|(
name|pei_section_data
argument_list|(
name|abfd
argument_list|,
name|current
argument_list|)
operator|->
name|virt_size
operator|<
name|current
operator|->
name|_raw_size
condition|)
name|align_adjust
operator|=
name|true
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|_LIB
comment|/* Force .lib sections to start at zero.  The vma is then 	 incremented in coff_set_section_contents.  This is right for 	 SVR3.2.  */
if|if
condition|(
name|strcmp
argument_list|(
name|current
operator|->
name|name
argument_list|,
name|_LIB
argument_list|)
operator|==
literal|0
condition|)
name|bfd_set_section_vma
argument_list|(
name|abfd
argument_list|,
name|current
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|previous
operator|=
name|current
expr_stmt|;
block|}
comment|/* It is now safe to write to the output file.  If we needed an      alignment adjustment for the last section, then make sure that      there is a byte at offset sofar.  If there are no symbols and no      relocs, then nothing follows the last section.  If we don't force      the last byte out, then the file may appear to be truncated.  */
if|if
condition|(
name|align_adjust
condition|)
block|{
name|bfd_byte
name|b
decl_stmt|;
name|b
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|sofar
operator|-
literal|1
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bwrite
argument_list|(
operator|&
name|b
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|1
condition|)
return|return
name|false
return|;
block|}
comment|/* Make sure the relocations are aligned.  We don't need to make      sure that this byte exists, because it will only matter if there      really are relocs.  */
name|sofar
operator|=
name|BFD_ALIGN
argument_list|(
name|sofar
argument_list|,
literal|1
operator|<<
name|COFF_DEFAULT_SECTION_ALIGNMENT_POWER
argument_list|)
expr_stmt|;
name|obj_relocbase
argument_list|(
name|abfd
argument_list|)
operator|=
name|sofar
expr_stmt|;
name|abfd
operator|->
name|output_has_begun
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* This can never work, because it is called too late--after the    section positions have been set.  I can't figure out what it is    for, so I am going to disable it--Ian Taylor 20 March 1996.  */
end_comment

begin_comment
comment|/* If .file, .text, .data, .bss symbols are missing, add them.  */
end_comment

begin_comment
comment|/* @@ Should we only be adding missing symbols, or overriding the aux    values for existing section symbols?  */
end_comment

begin_comment
unit|static boolean coff_add_missing_symbols (abfd)      bfd *abfd; {   unsigned int nsyms = bfd_get_symcount (abfd);   asymbol **sympp = abfd->outsymbols;   asymbol **sympp2;   unsigned int i;   int need_text = 1, need_data = 1, need_bss = 1, need_file = 1;   bfd_size_type amt;    for (i = 0; i< nsyms; i++)     {       coff_symbol_type *csym = coff_symbol_from (abfd, sympp[i]);       const char *name;       if (csym) 	{
comment|/* only do this if there is a coff representation of the input 	   symbol */
end_comment

begin_ifdef
unit|if (csym->native&& csym->native->u.syment.n_sclass == C_FILE) 	    { 	      need_file = 0; 	      continue; 	    } 	  name = csym->symbol.name; 	  if (!name) 	    continue; 	  if (!strcmp (name, _TEXT)) 	    need_text = 0;
ifdef|#
directive|ifdef
name|APOLLO_M68
end_ifdef

begin_endif
unit|else if (!strcmp (name, ".wtext")) 	    need_text = 0;
endif|#
directive|endif
end_endif

begin_comment
unit|else if (!strcmp (name, _DATA)) 	    need_data = 0; 	  else if (!strcmp (name, _BSS)) 	    need_bss = 0; 	}     }
comment|/* Now i == bfd_get_symcount (abfd).  */
end_comment

begin_comment
comment|/* @@ For now, don't deal with .file symbol.  */
end_comment

begin_comment
unit|need_file = 0;    if (!need_text&& !need_data&& !need_bss&& !need_file)     return true;   nsyms += need_text + need_data + need_bss + need_file;   amt = nsyms;   amt *= sizeof (asymbol *);   sympp2 = (asymbol **) bfd_alloc (abfd, amt);   if (!sympp2)     return false;   memcpy (sympp2, sympp, i * sizeof (asymbol *));   if (need_file)     {
comment|/* @@ Generate fake .file symbol, in sympp2[i], and increment i.  */
end_comment

begin_endif
unit|abort ();     }   if (need_text)     sympp2[i++] = coff_section_symbol (abfd, _TEXT);   if (need_data)     sympp2[i++] = coff_section_symbol (abfd, _DATA);   if (need_bss)     sympp2[i++] = coff_section_symbol (abfd, _BSS);   BFD_ASSERT (i == nsyms);   bfd_set_symtab (abfd, sympp2, nsyms);   return true; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_comment
comment|/* SUPPRESS 558 */
end_comment

begin_comment
comment|/* SUPPRESS 529 */
end_comment

begin_function
specifier|static
name|boolean
name|coff_write_object_contents
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|asection
modifier|*
name|current
decl_stmt|;
name|boolean
name|hasrelocs
init|=
name|false
decl_stmt|;
name|boolean
name|haslinno
init|=
name|false
decl_stmt|;
name|boolean
name|hasdebug
init|=
name|false
decl_stmt|;
name|file_ptr
name|scn_base
decl_stmt|;
name|file_ptr
name|reloc_base
decl_stmt|;
name|file_ptr
name|lineno_base
decl_stmt|;
name|file_ptr
name|sym_base
decl_stmt|;
name|unsigned
name|long
name|reloc_size
init|=
literal|0
decl_stmt|,
name|reloc_count
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|lnno_size
init|=
literal|0
decl_stmt|;
name|boolean
name|long_section_names
decl_stmt|;
name|asection
modifier|*
name|text_sec
init|=
name|NULL
decl_stmt|;
name|asection
modifier|*
name|data_sec
init|=
name|NULL
decl_stmt|;
name|asection
modifier|*
name|bss_sec
init|=
name|NULL
decl_stmt|;
name|struct
name|internal_filehdr
name|internal_f
decl_stmt|;
name|struct
name|internal_aouthdr
name|internal_a
decl_stmt|;
ifdef|#
directive|ifdef
name|COFF_LONG_SECTION_NAMES
name|size_t
name|string_size
init|=
name|STRING_SIZE_SIZE
decl_stmt|;
endif|#
directive|endif
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
comment|/* Make a pass through the symbol table to count line number entries and      put them into the correct asections */
name|lnno_size
operator|=
name|coff_count_linenumbers
argument_list|(
name|abfd
argument_list|)
operator|*
name|bfd_coff_linesz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|output_has_begun
operator|==
name|false
condition|)
block|{
if|if
condition|(
operator|!
name|coff_compute_section_file_positions
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
block|}
name|reloc_base
operator|=
name|obj_relocbase
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* Work out the size of the reloc and linno areas */
for|for
control|(
name|current
operator|=
name|abfd
operator|->
name|sections
init|;
name|current
operator|!=
name|NULL
condition|;
name|current
operator|=
name|current
operator|->
name|next
control|)
block|{
ifdef|#
directive|ifdef
name|COFF_WITH_PE
comment|/* we store the actual reloc count in the first reloc's addr */
if|if
condition|(
name|current
operator|->
name|reloc_count
operator|>
literal|0xffff
condition|)
name|reloc_count
operator|++
expr_stmt|;
endif|#
directive|endif
name|reloc_count
operator|+=
name|current
operator|->
name|reloc_count
expr_stmt|;
block|}
name|reloc_size
operator|=
name|reloc_count
operator|*
name|bfd_coff_relsz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|lineno_base
operator|=
name|reloc_base
operator|+
name|reloc_size
expr_stmt|;
name|sym_base
operator|=
name|lineno_base
operator|+
name|lnno_size
expr_stmt|;
comment|/* Indicate in each section->line_filepos its actual file address */
for|for
control|(
name|current
operator|=
name|abfd
operator|->
name|sections
init|;
name|current
operator|!=
name|NULL
condition|;
name|current
operator|=
name|current
operator|->
name|next
control|)
block|{
if|if
condition|(
name|current
operator|->
name|lineno_count
condition|)
block|{
name|current
operator|->
name|line_filepos
operator|=
name|lineno_base
expr_stmt|;
name|current
operator|->
name|moving_line_filepos
operator|=
name|lineno_base
expr_stmt|;
name|lineno_base
operator|+=
name|current
operator|->
name|lineno_count
operator|*
name|bfd_coff_linesz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|current
operator|->
name|line_filepos
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|current
operator|->
name|reloc_count
condition|)
block|{
name|current
operator|->
name|rel_filepos
operator|=
name|reloc_base
expr_stmt|;
name|reloc_base
operator|+=
name|current
operator|->
name|reloc_count
operator|*
name|bfd_coff_relsz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COFF_WITH_PE
comment|/* extra reloc to hold real count */
if|if
condition|(
name|current
operator|->
name|reloc_count
operator|>
literal|0xffff
condition|)
name|reloc_base
operator|+=
name|bfd_coff_relsz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|current
operator|->
name|rel_filepos
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Write section headers to the file.  */
name|internal_f
operator|.
name|f_nscns
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|EXEC_P
operator|)
operator|!=
literal|0
condition|)
name|scn_base
operator|=
name|bfd_coff_filhsz
argument_list|(
name|abfd
argument_list|)
operator|+
name|bfd_coff_aoutsz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
else|else
block|{
name|scn_base
operator|=
name|bfd_coff_filhsz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RS6000COFF_C
ifndef|#
directive|ifndef
name|XCOFF64
if|if
condition|(
name|xcoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|full_aouthdr
condition|)
name|scn_base
operator|+=
name|bfd_coff_aoutsz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
else|else
name|scn_base
operator|+=
name|SMALL_AOUTSZ
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|scn_base
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
name|long_section_names
operator|=
name|false
expr_stmt|;
for|for
control|(
name|current
operator|=
name|abfd
operator|->
name|sections
init|;
name|current
operator|!=
name|NULL
condition|;
name|current
operator|=
name|current
operator|->
name|next
control|)
block|{
name|struct
name|internal_scnhdr
name|section
decl_stmt|;
name|boolean
name|is_reloc_section
init|=
name|false
decl_stmt|;
ifdef|#
directive|ifdef
name|COFF_IMAGE_WITH_PE
if|if
condition|(
name|strcmp
argument_list|(
name|current
operator|->
name|name
argument_list|,
literal|".reloc"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|is_reloc_section
operator|=
name|true
expr_stmt|;
name|hasrelocs
operator|=
name|true
expr_stmt|;
name|pe_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|has_reloc_section
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
name|internal_f
operator|.
name|f_nscns
operator|++
expr_stmt|;
name|strncpy
argument_list|(
name|section
operator|.
name|s_name
argument_list|,
name|current
operator|->
name|name
argument_list|,
name|SCNNMLEN
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COFF_LONG_SECTION_NAMES
comment|/* Handle long section names as in PE.  This must be compatible          with the code in coff_write_symbols and _bfd_coff_final_link.  */
block|{
name|size_t
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|current
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|SCNNMLEN
condition|)
block|{
name|memset
argument_list|(
name|section
operator|.
name|s_name
argument_list|,
literal|0
argument_list|,
name|SCNNMLEN
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|section
operator|.
name|s_name
argument_list|,
literal|"/%lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|string_size
argument_list|)
expr_stmt|;
name|string_size
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
name|long_section_names
operator|=
name|true
expr_stmt|;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|_LIB
comment|/* Always set s_vaddr of .lib to 0.  This is right for SVR3.2 	 Ian Taylor<ian@cygnus.com>.  */
if|if
condition|(
name|strcmp
argument_list|(
name|current
operator|->
name|name
argument_list|,
name|_LIB
argument_list|)
operator|==
literal|0
condition|)
name|section
operator|.
name|s_vaddr
operator|=
literal|0
expr_stmt|;
else|else
endif|#
directive|endif
name|section
operator|.
name|s_vaddr
operator|=
name|current
operator|->
name|vma
expr_stmt|;
name|section
operator|.
name|s_paddr
operator|=
name|current
operator|->
name|lma
expr_stmt|;
name|section
operator|.
name|s_size
operator|=
name|current
operator|->
name|_raw_size
expr_stmt|;
ifdef|#
directive|ifdef
name|coff_get_section_load_page
name|section
operator|.
name|s_page
operator|=
name|coff_get_section_load_page
argument_list|(
name|current
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|COFF_WITH_PE
name|section
operator|.
name|s_paddr
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|COFF_IMAGE_WITH_PE
comment|/* Reminder: s_paddr holds the virtual size of the section.  */
if|if
condition|(
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|current
argument_list|)
operator|!=
name|NULL
operator|&&
name|pei_section_data
argument_list|(
name|abfd
argument_list|,
name|current
argument_list|)
operator|!=
name|NULL
condition|)
name|section
operator|.
name|s_paddr
operator|=
name|pei_section_data
argument_list|(
name|abfd
argument_list|,
name|current
argument_list|)
operator|->
name|virt_size
expr_stmt|;
else|else
name|section
operator|.
name|s_paddr
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* 	 If this section has no size or is unloadable then the scnptr 	 will be 0 too 	 */
if|if
condition|(
name|current
operator|->
name|_raw_size
operator|==
literal|0
operator|||
operator|(
name|current
operator|->
name|flags
operator|&
operator|(
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|section
operator|.
name|s_scnptr
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|section
operator|.
name|s_scnptr
operator|=
name|current
operator|->
name|filepos
expr_stmt|;
block|}
name|section
operator|.
name|s_relptr
operator|=
name|current
operator|->
name|rel_filepos
expr_stmt|;
name|section
operator|.
name|s_lnnoptr
operator|=
name|current
operator|->
name|line_filepos
expr_stmt|;
name|section
operator|.
name|s_nreloc
operator|=
name|current
operator|->
name|reloc_count
expr_stmt|;
name|section
operator|.
name|s_nlnno
operator|=
name|current
operator|->
name|lineno_count
expr_stmt|;
ifndef|#
directive|ifndef
name|COFF_IMAGE_WITH_PE
comment|/* In PEI, relocs come in the .reloc section.  */
if|if
condition|(
name|current
operator|->
name|reloc_count
operator|!=
literal|0
condition|)
name|hasrelocs
operator|=
name|true
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|current
operator|->
name|lineno_count
operator|!=
literal|0
condition|)
name|haslinno
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|(
name|current
operator|->
name|flags
operator|&
name|SEC_DEBUGGING
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|is_reloc_section
condition|)
name|hasdebug
operator|=
name|true
expr_stmt|;
ifdef|#
directive|ifdef
name|RS6000COFF_C
ifndef|#
directive|ifndef
name|XCOFF64
comment|/* Indicate the use of an XCOFF overflow section header.  */
if|if
condition|(
name|current
operator|->
name|reloc_count
operator|>=
literal|0xffff
operator|||
name|current
operator|->
name|lineno_count
operator|>=
literal|0xffff
condition|)
block|{
name|section
operator|.
name|s_nreloc
operator|=
literal|0xffff
expr_stmt|;
name|section
operator|.
name|s_nlnno
operator|=
literal|0xffff
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
name|section
operator|.
name|s_flags
operator|=
name|sec_to_styp_flags
argument_list|(
name|current
operator|->
name|name
argument_list|,
name|current
operator|->
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|current
operator|->
name|name
argument_list|,
name|_TEXT
argument_list|)
condition|)
block|{
name|text_sec
operator|=
name|current
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|current
operator|->
name|name
argument_list|,
name|_DATA
argument_list|)
condition|)
block|{
name|data_sec
operator|=
name|current
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|current
operator|->
name|name
argument_list|,
name|_BSS
argument_list|)
condition|)
block|{
name|bss_sec
operator|=
name|current
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|I960
name|section
operator|.
name|s_align
operator|=
operator|(
name|current
operator|->
name|alignment_power
condition|?
literal|1
operator|<<
name|current
operator|->
name|alignment_power
else|:
literal|0
operator|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TIC80COFF
comment|/* TI COFF puts the alignment power in bits 8-11 of the flags */
name|section
operator|.
name|s_flags
operator||=
operator|(
name|current
operator|->
name|alignment_power
operator|&
literal|0xF
operator|)
operator|<<
literal|8
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|COFF_ENCODE_ALIGNMENT
name|COFF_ENCODE_ALIGNMENT
argument_list|(
name|section
argument_list|,
name|current
operator|->
name|alignment_power
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|COFF_IMAGE_WITH_PE
comment|/* Suppress output of the sections if they are null.  ld 	 includes the bss and data sections even if there is no size 	 assigned to them.  NT loader doesn't like it if these section 	 headers are included if the sections themselves are not 	 needed.  See also coff_compute_section_file_positions.  */
if|if
condition|(
name|section
operator|.
name|s_size
operator|==
literal|0
condition|)
name|internal_f
operator|.
name|f_nscns
operator|--
expr_stmt|;
else|else
endif|#
directive|endif
block|{
name|SCNHDR
name|buff
decl_stmt|;
name|bfd_size_type
name|amt
init|=
name|bfd_coff_scnhsz
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
if|if
condition|(
name|coff_swap_scnhdr_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|section
argument_list|,
operator|&
name|buff
argument_list|)
operator|==
literal|0
operator|||
name|bfd_bwrite
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|buff
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
return|return
name|false
return|;
block|}
ifdef|#
directive|ifdef
name|COFF_WITH_PE
comment|/* PE stores COMDAT section information in the symbol table.  If          this section is supposed to have some COMDAT info, track down          the symbol in the symbol table and modify it.  */
if|if
condition|(
operator|(
name|current
operator|->
name|flags
operator|&
name|SEC_LINK_ONCE
operator|)
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|count
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|psym
decl_stmt|;
name|coff_symbol_type
modifier|*
name|csym
init|=
name|NULL
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|psymsec
decl_stmt|;
name|psymsec
operator|=
name|NULL
expr_stmt|;
name|count
operator|=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|psym
operator|=
name|abfd
operator|->
name|outsymbols
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|psym
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|psym
operator|)
operator|->
name|section
operator|!=
name|current
condition|)
continue|continue;
comment|/* Remember the location of the first symbol in this                  section.  */
if|if
condition|(
name|psymsec
operator|==
name|NULL
condition|)
name|psymsec
operator|=
name|psym
expr_stmt|;
comment|/* See if this is the section symbol.  */
if|if
condition|(
name|strcmp
argument_list|(
operator|(
operator|*
name|psym
operator|)
operator|->
name|name
argument_list|,
name|current
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|csym
operator|=
name|coff_symbol_from
argument_list|(
name|abfd
argument_list|,
operator|*
name|psym
argument_list|)
expr_stmt|;
if|if
condition|(
name|csym
operator|==
name|NULL
operator|||
name|csym
operator|->
name|native
operator|==
name|NULL
operator|||
name|csym
operator|->
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_numaux
operator|<
literal|1
operator|||
name|csym
operator|->
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
operator|!=
name|C_STAT
operator|||
name|csym
operator|->
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_type
operator|!=
name|T_NULL
condition|)
continue|continue;
comment|/* Here *PSYM is the section symbol for CURRENT.  */
break|break;
block|}
block|}
comment|/* Did we find it? 	     Note that we might not if we're converting the file from 	     some other object file format.  */
if|if
condition|(
name|i
operator|<
name|count
condition|)
block|{
name|combined_entry_type
modifier|*
name|aux
decl_stmt|;
comment|/* We don't touch the x_checksum field.  The 		 x_associated field is not currently supported.  */
name|aux
operator|=
name|csym
operator|->
name|native
operator|+
literal|1
expr_stmt|;
switch|switch
condition|(
name|current
operator|->
name|flags
operator|&
name|SEC_LINK_DUPLICATES
condition|)
block|{
case|case
name|SEC_LINK_DUPLICATES_DISCARD
case|:
name|aux
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_scn
operator|.
name|x_comdat
operator|=
name|IMAGE_COMDAT_SELECT_ANY
expr_stmt|;
break|break;
case|case
name|SEC_LINK_DUPLICATES_ONE_ONLY
case|:
name|aux
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_scn
operator|.
name|x_comdat
operator|=
name|IMAGE_COMDAT_SELECT_NODUPLICATES
expr_stmt|;
break|break;
case|case
name|SEC_LINK_DUPLICATES_SAME_SIZE
case|:
name|aux
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_scn
operator|.
name|x_comdat
operator|=
name|IMAGE_COMDAT_SELECT_SAME_SIZE
expr_stmt|;
break|break;
case|case
name|SEC_LINK_DUPLICATES_SAME_CONTENTS
case|:
name|aux
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_scn
operator|.
name|x_comdat
operator|=
name|IMAGE_COMDAT_SELECT_EXACT_MATCH
expr_stmt|;
break|break;
block|}
comment|/* The COMDAT symbol must be the first symbol from this                  section in the symbol table.  In order to make this                  work, we move the COMDAT symbol before the first                  symbol we found in the search above.  It's OK to                  rearrange the symbol table at this point, because                  coff_renumber_symbols is going to rearrange it                  further and fix up all the aux entries.  */
if|if
condition|(
name|psym
operator|!=
name|psymsec
condition|)
block|{
name|asymbol
modifier|*
name|hold
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|pcopy
decl_stmt|;
name|hold
operator|=
operator|*
name|psym
expr_stmt|;
for|for
control|(
name|pcopy
operator|=
name|psym
init|;
name|pcopy
operator|>
name|psymsec
condition|;
name|pcopy
operator|--
control|)
name|pcopy
index|[
literal|0
index|]
operator|=
name|pcopy
index|[
operator|-
literal|1
index|]
expr_stmt|;
operator|*
name|psymsec
operator|=
name|hold
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* COFF_WITH_PE */
block|}
ifdef|#
directive|ifdef
name|RS6000COFF_C
ifndef|#
directive|ifndef
name|XCOFF64
comment|/* XCOFF handles overflows in the reloc and line number count fields      by creating a new section header to hold the correct values.  */
for|for
control|(
name|current
operator|=
name|abfd
operator|->
name|sections
init|;
name|current
operator|!=
name|NULL
condition|;
name|current
operator|=
name|current
operator|->
name|next
control|)
block|{
if|if
condition|(
name|current
operator|->
name|reloc_count
operator|>=
literal|0xffff
operator|||
name|current
operator|->
name|lineno_count
operator|>=
literal|0xffff
condition|)
block|{
name|struct
name|internal_scnhdr
name|scnhdr
decl_stmt|;
name|SCNHDR
name|buff
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|internal_f
operator|.
name|f_nscns
operator|++
expr_stmt|;
name|strncpy
argument_list|(
operator|&
operator|(
name|scnhdr
operator|.
name|s_name
index|[
literal|0
index|]
operator|)
argument_list|,
name|current
operator|->
name|name
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|scnhdr
operator|.
name|s_paddr
operator|=
name|current
operator|->
name|reloc_count
expr_stmt|;
name|scnhdr
operator|.
name|s_vaddr
operator|=
name|current
operator|->
name|lineno_count
expr_stmt|;
name|scnhdr
operator|.
name|s_size
operator|=
literal|0
expr_stmt|;
name|scnhdr
operator|.
name|s_scnptr
operator|=
literal|0
expr_stmt|;
name|scnhdr
operator|.
name|s_relptr
operator|=
name|current
operator|->
name|rel_filepos
expr_stmt|;
name|scnhdr
operator|.
name|s_lnnoptr
operator|=
name|current
operator|->
name|line_filepos
expr_stmt|;
name|scnhdr
operator|.
name|s_nreloc
operator|=
name|current
operator|->
name|target_index
expr_stmt|;
name|scnhdr
operator|.
name|s_nlnno
operator|=
name|current
operator|->
name|target_index
expr_stmt|;
name|scnhdr
operator|.
name|s_flags
operator|=
name|STYP_OVRFLO
expr_stmt|;
name|amt
operator|=
name|bfd_coff_scnhsz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|coff_swap_scnhdr_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|scnhdr
argument_list|,
operator|&
name|buff
argument_list|)
operator|==
literal|0
operator|||
name|bfd_bwrite
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|buff
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
return|return
name|false
return|;
block|}
block|}
endif|#
directive|endif
endif|#
directive|endif
comment|/* OK, now set up the filehdr...  */
comment|/* Don't include the internal abs section in the section count */
comment|/*      We will NOT put a fucking timestamp in the header here. Every time you      put it back, I will come in and take it out again.  I'm sorry.  This      field does not belong here.  We fill it with a 0 so it compares the      same but is not a reasonable time. -- gnu@cygnus.com      */
name|internal_f
operator|.
name|f_timdat
operator|=
literal|0
expr_stmt|;
name|internal_f
operator|.
name|f_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|flags
operator|&
name|EXEC_P
condition|)
name|internal_f
operator|.
name|f_opthdr
operator|=
name|bfd_coff_aoutsz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
else|else
block|{
name|internal_f
operator|.
name|f_opthdr
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|RS6000COFF_C
ifndef|#
directive|ifndef
name|XCOFF64
if|if
condition|(
name|xcoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|full_aouthdr
condition|)
name|internal_f
operator|.
name|f_opthdr
operator|=
name|bfd_coff_aoutsz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
else|else
name|internal_f
operator|.
name|f_opthdr
operator|=
name|SMALL_AOUTSZ
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
if|if
condition|(
operator|!
name|hasrelocs
condition|)
name|internal_f
operator|.
name|f_flags
operator||=
name|F_RELFLG
expr_stmt|;
if|if
condition|(
operator|!
name|haslinno
condition|)
name|internal_f
operator|.
name|f_flags
operator||=
name|F_LNNO
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|flags
operator|&
name|EXEC_P
condition|)
name|internal_f
operator|.
name|f_flags
operator||=
name|F_EXEC
expr_stmt|;
ifdef|#
directive|ifdef
name|COFF_IMAGE_WITH_PE
if|if
condition|(
operator|!
name|hasdebug
condition|)
name|internal_f
operator|.
name|f_flags
operator||=
name|IMAGE_FILE_DEBUG_STRIPPED
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|COFF_WITH_PE
if|if
condition|(
name|bfd_little_endian
argument_list|(
name|abfd
argument_list|)
condition|)
name|internal_f
operator|.
name|f_flags
operator||=
name|F_AR32WR
expr_stmt|;
else|else
name|internal_f
operator|.
name|f_flags
operator||=
name|F_AR32W
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TI_TARGET_ID
comment|/* target id is used in TI COFF v1 and later; COFF0 won't use this field,      but it doesn't hurt to set it internally */
name|internal_f
operator|.
name|f_target_id
operator|=
name|TI_TARGET_ID
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TIC80_TARGET_ID
name|internal_f
operator|.
name|f_target_id
operator|=
name|TIC80_TARGET_ID
expr_stmt|;
endif|#
directive|endif
comment|/*      FIXME, should do something about the other byte orders and      architectures.      */
ifdef|#
directive|ifdef
name|RS6000COFF_C
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
condition|)
name|internal_f
operator|.
name|f_flags
operator||=
name|F_SHROBJ
expr_stmt|;
if|if
condition|(
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|_LOADER
argument_list|)
operator|!=
name|NULL
condition|)
name|internal_f
operator|.
name|f_flags
operator||=
name|F_DYNLOAD
expr_stmt|;
endif|#
directive|endif
name|memset
argument_list|(
operator|&
name|internal_a
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|internal_a
argument_list|)
expr_stmt|;
comment|/* Set up architecture-dependent stuff */
block|{
name|unsigned
name|int
name|magic
init|=
literal|0
decl_stmt|;
name|unsigned
name|short
name|flags
init|=
literal|0
decl_stmt|;
name|coff_set_flags
argument_list|(
name|abfd
argument_list|,
operator|&
name|magic
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
name|internal_f
operator|.
name|f_magic
operator|=
name|magic
expr_stmt|;
name|internal_f
operator|.
name|f_flags
operator||=
name|flags
expr_stmt|;
comment|/* ...and the "opt"hdr...  */
ifdef|#
directive|ifdef
name|A29K
ifdef|#
directive|ifdef
name|ULTRA3
comment|/* NYU's machine */
comment|/* FIXME: This is a bogus check.  I really want to see if there      * is a .shbss or a .shdata section, if so then set the magic      * number to indicate a shared data executable.      */
if|if
condition|(
name|internal_f
operator|.
name|f_nscns
operator|>=
literal|7
condition|)
name|internal_a
operator|.
name|magic
operator|=
name|SHMAGIC
expr_stmt|;
comment|/* Shared magic */
else|else
endif|#
directive|endif
comment|/* ULTRA3 */
name|internal_a
operator|.
name|magic
operator|=
name|NMAGIC
expr_stmt|;
comment|/* Assume separate i/d */
define|#
directive|define
name|__A_MAGIC_SET__
endif|#
directive|endif
comment|/* A29K */
ifdef|#
directive|ifdef
name|TICOFF_AOUT_MAGIC
name|internal_a
operator|.
name|magic
operator|=
name|TICOFF_AOUT_MAGIC
expr_stmt|;
define|#
directive|define
name|__A_MAGIC_SET__
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TIC80COFF
name|internal_a
operator|.
name|magic
operator|=
name|TIC80_ARCH_MAGIC
expr_stmt|;
define|#
directive|define
name|__A_MAGIC_SET__
endif|#
directive|endif
comment|/* TIC80 */
ifdef|#
directive|ifdef
name|I860
comment|/* FIXME: What are the a.out magic numbers for the i860?  */
name|internal_a
operator|.
name|magic
operator|=
literal|0
expr_stmt|;
define|#
directive|define
name|__A_MAGIC_SET__
endif|#
directive|endif
comment|/* I860 */
ifdef|#
directive|ifdef
name|I960
name|internal_a
operator|.
name|magic
operator|=
operator|(
name|magic
operator|==
name|I960ROMAGIC
condition|?
name|NMAGIC
else|:
name|OMAGIC
operator|)
expr_stmt|;
define|#
directive|define
name|__A_MAGIC_SET__
endif|#
directive|endif
comment|/* I960 */
if|#
directive|if
name|M88
define|#
directive|define
name|__A_MAGIC_SET__
name|internal_a
operator|.
name|magic
operator|=
name|PAGEMAGICBCS
expr_stmt|;
endif|#
directive|endif
comment|/* M88 */
if|#
directive|if
name|APOLLO_M68
define|#
directive|define
name|__A_MAGIC_SET__
name|internal_a
operator|.
name|magic
operator|=
name|APOLLO_COFF_VERSION_NUMBER
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|M68
argument_list|)
operator|||
name|defined
argument_list|(
name|WE32K
argument_list|)
operator|||
name|defined
argument_list|(
name|M68K
argument_list|)
define|#
directive|define
name|__A_MAGIC_SET__
if|#
directive|if
name|defined
argument_list|(
name|LYNXOS
argument_list|)
name|internal_a
operator|.
name|magic
operator|=
name|LYNXCOFFMAGIC
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|TARG_AUX
argument_list|)
name|internal_a
operator|.
name|magic
operator|=
operator|(
name|abfd
operator|->
name|flags
operator|&
name|D_PAGED
condition|?
name|PAGEMAGICPEXECPAGED
else|:
name|abfd
operator|->
name|flags
operator|&
name|WP_TEXT
condition|?
name|PAGEMAGICPEXECSWAPPED
else|:
name|PAGEMAGICEXECSWAPPED
operator|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|PAGEMAGICPEXECPAGED
argument_list|)
name|internal_a
operator|.
name|magic
operator|=
name|PAGEMAGICPEXECPAGED
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* TARG_AUX */
endif|#
directive|endif
comment|/* LYNXOS */
endif|#
directive|endif
comment|/* M68 || WE32K || M68K */
if|#
directive|if
name|defined
argument_list|(
name|ARM
argument_list|)
define|#
directive|define
name|__A_MAGIC_SET__
name|internal_a
operator|.
name|magic
operator|=
name|ZMAGIC
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PPC_PE
argument_list|)
define|#
directive|define
name|__A_MAGIC_SET__
name|internal_a
operator|.
name|magic
operator|=
name|IMAGE_NT_OPTIONAL_HDR_MAGIC
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
name|MCORE_PE
define|#
directive|define
name|__A_MAGIC_SET__
name|internal_a
operator|.
name|magic
operator|=
name|IMAGE_NT_OPTIONAL_HDR_MAGIC
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|I386
argument_list|)
define|#
directive|define
name|__A_MAGIC_SET__
if|#
directive|if
name|defined
argument_list|(
name|LYNXOS
argument_list|)
name|internal_a
operator|.
name|magic
operator|=
name|LYNXCOFFMAGIC
expr_stmt|;
else|#
directive|else
comment|/* LYNXOS */
name|internal_a
operator|.
name|magic
operator|=
name|ZMAGIC
expr_stmt|;
endif|#
directive|endif
comment|/* LYNXOS */
endif|#
directive|endif
comment|/* I386 */
if|#
directive|if
name|defined
argument_list|(
name|IA64
argument_list|)
define|#
directive|define
name|__A_MAGIC_SET__
name|internal_a
operator|.
name|magic
operator|=
name|ZMAGIC
expr_stmt|;
endif|#
directive|endif
comment|/* IA64 */
if|#
directive|if
name|defined
argument_list|(
name|SPARC
argument_list|)
define|#
directive|define
name|__A_MAGIC_SET__
if|#
directive|if
name|defined
argument_list|(
name|LYNXOS
argument_list|)
name|internal_a
operator|.
name|magic
operator|=
name|LYNXCOFFMAGIC
expr_stmt|;
endif|#
directive|endif
comment|/* LYNXOS */
endif|#
directive|endif
comment|/* SPARC */
ifdef|#
directive|ifdef
name|RS6000COFF_C
define|#
directive|define
name|__A_MAGIC_SET__
name|internal_a
operator|.
name|magic
operator|=
operator|(
name|abfd
operator|->
name|flags
operator|&
name|D_PAGED
operator|)
condition|?
name|RS6K_AOUTHDR_ZMAGIC
else|:
operator|(
name|abfd
operator|->
name|flags
operator|&
name|WP_TEXT
operator|)
condition|?
name|RS6K_AOUTHDR_NMAGIC
else|:
name|RS6K_AOUTHDR_OMAGIC
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SH
argument_list|)
operator|&&
name|defined
argument_list|(
name|COFF_WITH_PE
argument_list|)
define|#
directive|define
name|__A_MAGIC_SET__
name|internal_a
operator|.
name|magic
operator|=
name|SH_PE_MAGIC
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|MIPS
argument_list|)
operator|&&
name|defined
argument_list|(
name|COFF_WITH_PE
argument_list|)
define|#
directive|define
name|__A_MAGIC_SET__
name|internal_a
operator|.
name|magic
operator|=
name|MIPS_PE_MAGIC
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OR32
define|#
directive|define
name|__A_MAGIC_SET__
name|internal_a
operator|.
name|magic
operator|=
name|NMAGIC
expr_stmt|;
comment|/* Assume separate i/d.  */
endif|#
directive|endif
ifndef|#
directive|ifndef
name|__A_MAGIC_SET__
include|#
directive|include
file|"Your aouthdr magic number is not being set!"
else|#
directive|else
undef|#
directive|undef
name|__A_MAGIC_SET__
endif|#
directive|endif
block|}
comment|/* FIXME: Does anybody ever set this to another value?  */
name|internal_a
operator|.
name|vstamp
operator|=
literal|0
expr_stmt|;
comment|/* Now should write relocs, strings, syms */
name|obj_sym_filepos
argument_list|(
name|abfd
argument_list|)
operator|=
name|sym_base
expr_stmt|;
if|if
condition|(
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|int
name|firstundef
decl_stmt|;
if|#
directive|if
literal|0
block|if (!coff_add_missing_symbols (abfd)) 	return false;
endif|#
directive|endif
if|if
condition|(
operator|!
name|coff_renumber_symbols
argument_list|(
name|abfd
argument_list|,
operator|&
name|firstundef
argument_list|)
condition|)
return|return
name|false
return|;
name|coff_mangle_symbols
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|coff_write_symbols
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|coff_write_linenumbers
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|coff_write_relocs
argument_list|(
name|abfd
argument_list|,
name|firstundef
argument_list|)
condition|)
return|return
name|false
return|;
block|}
ifdef|#
directive|ifdef
name|COFF_LONG_SECTION_NAMES
elseif|else
if|if
condition|(
name|long_section_names
operator|&&
operator|!
name|obj_coff_strings_written
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
comment|/* If we have long section names we have to write out the string          table even if there are no symbols.  */
if|if
condition|(
operator|!
name|coff_write_symbols
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|COFF_IMAGE_WITH_PE
ifdef|#
directive|ifdef
name|PPC_PE
elseif|else
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|EXEC_P
operator|)
operator|!=
literal|0
condition|)
block|{
name|bfd_byte
name|b
decl_stmt|;
comment|/* PowerPC PE appears to require that all executable files be          rounded up to the page size.  */
name|b
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
name|BFD_ALIGN
argument_list|(
name|sym_base
argument_list|,
name|COFF_PAGE_SIZE
argument_list|)
operator|-
literal|1
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bwrite
argument_list|(
operator|&
name|b
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|1
condition|)
return|return
name|false
return|;
block|}
endif|#
directive|endif
endif|#
directive|endif
comment|/* If bfd_get_symcount (abfd) != 0, then we are not using the COFF      backend linker, and obj_raw_syment_count is not valid until after      coff_write_symbols is called.  */
if|if
condition|(
name|obj_raw_syment_count
argument_list|(
name|abfd
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|internal_f
operator|.
name|f_symptr
operator|=
name|sym_base
expr_stmt|;
ifdef|#
directive|ifdef
name|RS6000COFF_C
comment|/* AIX appears to require that F_RELFLG not be set if there are          local symbols but no relocations.  */
name|internal_f
operator|.
name|f_flags
operator|&=
operator|~
name|F_RELFLG
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|if
condition|(
name|long_section_names
condition|)
name|internal_f
operator|.
name|f_symptr
operator|=
name|sym_base
expr_stmt|;
else|else
name|internal_f
operator|.
name|f_symptr
operator|=
literal|0
expr_stmt|;
name|internal_f
operator|.
name|f_flags
operator||=
name|F_LSYMS
expr_stmt|;
block|}
if|if
condition|(
name|text_sec
condition|)
block|{
name|internal_a
operator|.
name|tsize
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|text_sec
argument_list|)
expr_stmt|;
name|internal_a
operator|.
name|text_start
operator|=
name|internal_a
operator|.
name|tsize
condition|?
name|text_sec
operator|->
name|vma
else|:
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|data_sec
condition|)
block|{
name|internal_a
operator|.
name|dsize
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|data_sec
argument_list|)
expr_stmt|;
name|internal_a
operator|.
name|data_start
operator|=
name|internal_a
operator|.
name|dsize
condition|?
name|data_sec
operator|->
name|vma
else|:
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|bss_sec
condition|)
block|{
name|internal_a
operator|.
name|bsize
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|bss_sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_a
operator|.
name|bsize
operator|&&
name|bss_sec
operator|->
name|vma
operator|<
name|internal_a
operator|.
name|data_start
condition|)
name|internal_a
operator|.
name|data_start
operator|=
name|bss_sec
operator|->
name|vma
expr_stmt|;
block|}
name|internal_a
operator|.
name|entry
operator|=
name|bfd_get_start_address
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|internal_f
operator|.
name|f_nsyms
operator|=
name|obj_raw_syment_count
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RS6000COFF_C
if|if
condition|(
name|xcoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|full_aouthdr
condition|)
block|{
name|bfd_vma
name|toc
decl_stmt|;
name|asection
modifier|*
name|loader_sec
decl_stmt|;
name|internal_a
operator|.
name|vstamp
operator|=
literal|1
expr_stmt|;
name|internal_a
operator|.
name|o_snentry
operator|=
name|xcoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|snentry
expr_stmt|;
if|if
condition|(
name|internal_a
operator|.
name|o_snentry
operator|==
literal|0
condition|)
name|internal_a
operator|.
name|entry
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|text_sec
operator|!=
name|NULL
condition|)
block|{
name|internal_a
operator|.
name|o_sntext
operator|=
name|text_sec
operator|->
name|target_index
expr_stmt|;
name|internal_a
operator|.
name|o_algntext
operator|=
name|bfd_get_section_alignment
argument_list|(
name|abfd
argument_list|,
name|text_sec
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|internal_a
operator|.
name|o_sntext
operator|=
literal|0
expr_stmt|;
name|internal_a
operator|.
name|o_algntext
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|data_sec
operator|!=
name|NULL
condition|)
block|{
name|internal_a
operator|.
name|o_sndata
operator|=
name|data_sec
operator|->
name|target_index
expr_stmt|;
name|internal_a
operator|.
name|o_algndata
operator|=
name|bfd_get_section_alignment
argument_list|(
name|abfd
argument_list|,
name|data_sec
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|internal_a
operator|.
name|o_sndata
operator|=
literal|0
expr_stmt|;
name|internal_a
operator|.
name|o_algndata
operator|=
literal|0
expr_stmt|;
block|}
name|loader_sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".loader"
argument_list|)
expr_stmt|;
if|if
condition|(
name|loader_sec
operator|!=
name|NULL
condition|)
name|internal_a
operator|.
name|o_snloader
operator|=
name|loader_sec
operator|->
name|target_index
expr_stmt|;
else|else
name|internal_a
operator|.
name|o_snloader
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bss_sec
operator|!=
name|NULL
condition|)
name|internal_a
operator|.
name|o_snbss
operator|=
name|bss_sec
operator|->
name|target_index
expr_stmt|;
else|else
name|internal_a
operator|.
name|o_snbss
operator|=
literal|0
expr_stmt|;
name|toc
operator|=
name|xcoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|toc
expr_stmt|;
name|internal_a
operator|.
name|o_toc
operator|=
name|toc
expr_stmt|;
name|internal_a
operator|.
name|o_sntoc
operator|=
name|xcoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|sntoc
expr_stmt|;
name|internal_a
operator|.
name|o_modtype
operator|=
name|xcoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|modtype
expr_stmt|;
if|if
condition|(
name|xcoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|cputype
operator|!=
operator|-
literal|1
condition|)
name|internal_a
operator|.
name|o_cputype
operator|=
name|xcoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|cputype
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|bfd_get_arch
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
case|case
name|bfd_arch_rs6000
case|:
name|internal_a
operator|.
name|o_cputype
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|bfd_arch_powerpc
case|:
if|if
condition|(
name|bfd_get_mach
argument_list|(
name|abfd
argument_list|)
operator|==
literal|0
condition|)
name|internal_a
operator|.
name|o_cputype
operator|=
literal|3
expr_stmt|;
else|else
name|internal_a
operator|.
name|o_cputype
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
name|internal_a
operator|.
name|o_maxstack
operator|=
name|xcoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|maxstack
expr_stmt|;
name|internal_a
operator|.
name|o_maxdata
operator|=
name|xcoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|maxdata
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* now write them */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
block|{
name|char
modifier|*
name|buff
decl_stmt|;
name|bfd_size_type
name|amount
init|=
name|bfd_coff_filhsz
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|buff
operator|=
name|bfd_malloc
argument_list|(
name|amount
argument_list|)
expr_stmt|;
if|if
condition|(
name|buff
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|bfd_coff_swap_filehdr_out
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|internal_f
argument_list|,
operator|(
name|PTR
operator|)
name|buff
argument_list|)
expr_stmt|;
name|amount
operator|=
name|bfd_bwrite
argument_list|(
operator|(
name|PTR
operator|)
name|buff
argument_list|,
name|amount
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buff
argument_list|)
expr_stmt|;
if|if
condition|(
name|amount
operator|!=
name|bfd_coff_filhsz
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|abfd
operator|->
name|flags
operator|&
name|EXEC_P
condition|)
block|{
comment|/* Note that peicode.h fills in a PEAOUTHDR, not an AOUTHDR. 	 include/coff/pe.h sets AOUTSZ == sizeof (PEAOUTHDR)) */
name|char
modifier|*
name|buff
decl_stmt|;
name|bfd_size_type
name|amount
init|=
name|bfd_coff_aoutsz
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|buff
operator|=
name|bfd_malloc
argument_list|(
name|amount
argument_list|)
expr_stmt|;
if|if
condition|(
name|buff
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|coff_swap_aouthdr_out
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|internal_a
argument_list|,
operator|(
name|PTR
operator|)
name|buff
argument_list|)
expr_stmt|;
name|amount
operator|=
name|bfd_bwrite
argument_list|(
operator|(
name|PTR
operator|)
name|buff
argument_list|,
name|amount
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buff
argument_list|)
expr_stmt|;
if|if
condition|(
name|amount
operator|!=
name|bfd_coff_aoutsz
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
block|}
ifdef|#
directive|ifdef
name|RS6000COFF_C
else|else
block|{
name|AOUTHDR
name|buff
decl_stmt|;
name|size_t
name|size
decl_stmt|;
comment|/* XCOFF seems to always write at least a small a.out header.  */
name|coff_swap_aouthdr_out
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|internal_a
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|buff
argument_list|)
expr_stmt|;
if|if
condition|(
name|xcoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|full_aouthdr
condition|)
name|size
operator|=
name|bfd_coff_aoutsz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
else|else
name|size
operator|=
name|SMALL_AOUTSZ
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|buff
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|size
condition|)
return|return
name|false
return|;
block|}
endif|#
directive|endif
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|coff_set_section_contents
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|location
parameter_list|,
name|offset
parameter_list|,
name|count
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|sec_ptr
name|section
decl_stmt|;
name|PTR
name|location
decl_stmt|;
name|file_ptr
name|offset
decl_stmt|;
name|bfd_size_type
name|count
decl_stmt|;
block|{
if|if
condition|(
name|abfd
operator|->
name|output_has_begun
operator|==
name|false
condition|)
comment|/* set by bfd.c handler */
block|{
if|if
condition|(
operator|!
name|coff_compute_section_file_positions
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|_LIB
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|TARG_AUX
argument_list|)
comment|/* The physical address field of a .lib section is used to hold the       number of shared libraries in the section.  This code counts the       number of sections being written, and increments the lma field       with the number.        I have found no documentation on the contents of this section.       Experimentation indicates that the section contains zero or more       records, each of which has the following structure:        - a (four byte) word holding the length of this record, in words,       - a word that always seems to be set to "2",       - the path to a shared library, null-terminated and then padded         to a whole word boundary.        bfd_assert calls have been added to alert if an attempt is made       to write a section which doesn't follow these assumptions.  The       code has been tested on ISC 4.1 by me, and on SCO by Robert Lipe<robertl@arnet.com> (Thanks!).        Gvran Uddeborg<gvran@uddeborg.pp.se> */
if|if
condition|(
name|strcmp
argument_list|(
name|section
operator|->
name|name
argument_list|,
name|_LIB
argument_list|)
operator|==
literal|0
condition|)
block|{
name|bfd_byte
modifier|*
name|rec
decl_stmt|,
modifier|*
name|recend
decl_stmt|;
name|rec
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|location
expr_stmt|;
name|recend
operator|=
name|rec
operator|+
name|count
expr_stmt|;
while|while
condition|(
name|rec
operator|<
name|recend
condition|)
block|{
operator|++
name|section
operator|->
name|lma
expr_stmt|;
name|rec
operator|+=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|rec
argument_list|)
operator|*
literal|4
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
name|rec
operator|==
name|recend
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Don't write out bss sections - one way to do this is to        see if the filepos has not been set.  */
if|if
condition|(
name|section
operator|->
name|filepos
operator|==
literal|0
condition|)
return|return
name|true
return|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|section
operator|->
name|filepos
operator|+
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
name|true
return|;
return|return
name|bfd_bwrite
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|abfd
argument_list|)
operator|==
name|count
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static boolean coff_close_and_cleanup (abfd)      bfd *abfd; {   if (!bfd_read_p (abfd))     switch (abfd->format)       {       case bfd_archive: 	if (!_bfd_write_archive_contents (abfd)) 	  return false; 	break;       case bfd_object: 	if (!coff_write_object_contents (abfd)) 	  return false; 	break;       default: 	bfd_set_error (bfd_error_invalid_operation); 	return false;       }
comment|/* We depend on bfd_close to free all the memory on the objalloc.  */
end_comment

begin_endif
unit|return true; }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|PTR
name|buy_and_read
parameter_list|(
name|abfd
parameter_list|,
name|where
parameter_list|,
name|size
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|file_ptr
name|where
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
block|{
name|PTR
name|area
init|=
operator|(
name|PTR
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|area
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|where
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bread
argument_list|(
name|area
argument_list|,
name|size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|size
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|area
operator|)
return|;
block|}
end_function

begin_comment
comment|/* buy_and_read() */
end_comment

begin_comment
comment|/* SUBSUBSECTION 	Reading linenumbers  	Creating the linenumber table is done by reading in the entire 	coff linenumber table, and creating another table for internal use.  	A coff linenumber table is structured so that each function 	is marked as having a line number of 0. Each line within the 	function is an offset from the first line in the function. The 	base of the line number information for the table is stored in 	the symbol associated with the function.  	Note: The PE format uses line number 0 for a flag indicating a 	new source file.  	The information is copied from the external to the internal 	table, and each symbol which marks a function is marked by 	pointing its...  	How does this work ?  */
end_comment

begin_function
specifier|static
name|boolean
name|coff_slurp_line_table
parameter_list|(
name|abfd
parameter_list|,
name|asect
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|asect
decl_stmt|;
block|{
name|LINENO
modifier|*
name|native_lineno
decl_stmt|;
name|alent
modifier|*
name|lineno_cache
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|asect
operator|->
name|lineno
operator|==
operator|(
name|alent
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|amt
operator|=
operator|(
name|bfd_size_type
operator|)
name|bfd_coff_linesz
argument_list|(
name|abfd
argument_list|)
operator|*
name|asect
operator|->
name|lineno_count
expr_stmt|;
name|native_lineno
operator|=
operator|(
name|LINENO
operator|*
operator|)
name|buy_and_read
argument_list|(
name|abfd
argument_list|,
name|asect
operator|->
name|line_filepos
argument_list|,
name|amt
argument_list|)
expr_stmt|;
name|amt
operator|=
operator|(
operator|(
name|bfd_size_type
operator|)
name|asect
operator|->
name|lineno_count
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|alent
argument_list|)
expr_stmt|;
name|lineno_cache
operator|=
operator|(
name|alent
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|lineno_cache
operator|==
name|NULL
condition|)
return|return
name|false
return|;
else|else
block|{
name|unsigned
name|int
name|counter
init|=
literal|0
decl_stmt|;
name|alent
modifier|*
name|cache_ptr
init|=
name|lineno_cache
decl_stmt|;
name|LINENO
modifier|*
name|src
init|=
name|native_lineno
decl_stmt|;
while|while
condition|(
name|counter
operator|<
name|asect
operator|->
name|lineno_count
condition|)
block|{
name|struct
name|internal_lineno
name|dst
decl_stmt|;
name|bfd_coff_swap_lineno_in
argument_list|(
name|abfd
argument_list|,
name|src
argument_list|,
operator|&
name|dst
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|line_number
operator|=
name|dst
operator|.
name|l_lnno
expr_stmt|;
if|if
condition|(
name|cache_ptr
operator|->
name|line_number
operator|==
literal|0
condition|)
block|{
name|boolean
name|warned
decl_stmt|;
name|bfd_signed_vma
name|symndx
decl_stmt|;
name|coff_symbol_type
modifier|*
name|sym
decl_stmt|;
name|warned
operator|=
name|false
expr_stmt|;
name|symndx
operator|=
name|dst
operator|.
name|l_addr
operator|.
name|l_symndx
expr_stmt|;
if|if
condition|(
name|symndx
operator|<
literal|0
operator|||
operator|(
name|bfd_vma
operator|)
name|symndx
operator|>=
name|obj_raw_syment_count
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: warning: illegal symbol index %ld in line numbers"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|dst
operator|.
name|l_addr
operator|.
name|l_symndx
argument_list|)
expr_stmt|;
name|symndx
operator|=
literal|0
expr_stmt|;
name|warned
operator|=
name|true
expr_stmt|;
block|}
comment|/* FIXME: We should not be casting between ints and                  pointers like this.  */
name|sym
operator|=
operator|(
operator|(
name|coff_symbol_type
operator|*
operator|)
operator|(
operator|(
name|symndx
operator|+
name|obj_raw_syments
argument_list|(
name|abfd
argument_list|)
operator|)
operator|->
name|u
operator|.
name|syment
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_zeroes
operator|)
operator|)
expr_stmt|;
name|cache_ptr
operator|->
name|u
operator|.
name|sym
operator|=
operator|(
name|asymbol
operator|*
operator|)
name|sym
expr_stmt|;
if|if
condition|(
name|sym
operator|->
name|lineno
operator|!=
name|NULL
operator|&&
operator|!
name|warned
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: warning: duplicate line number information for `%s'"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|bfd_asymbol_name
argument_list|(
operator|&
name|sym
operator|->
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sym
operator|->
name|lineno
operator|=
name|cache_ptr
expr_stmt|;
block|}
else|else
block|{
name|cache_ptr
operator|->
name|u
operator|.
name|offset
operator|=
name|dst
operator|.
name|l_addr
operator|.
name|l_paddr
operator|-
name|bfd_section_vma
argument_list|(
name|abfd
argument_list|,
name|asect
argument_list|)
expr_stmt|;
block|}
comment|/* If no linenumber expect a symbol index */
name|cache_ptr
operator|++
expr_stmt|;
name|src
operator|++
expr_stmt|;
name|counter
operator|++
expr_stmt|;
block|}
name|cache_ptr
operator|->
name|line_number
operator|=
literal|0
expr_stmt|;
block|}
name|asect
operator|->
name|lineno
operator|=
name|lineno_cache
expr_stmt|;
comment|/* FIXME, free native_lineno here, or use alloca or something.  */
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Slurp in the symbol table, converting it to generic form.  Note    that if coff_relocate_section is defined, the linker will read    symbols via coff_link_add_symbols, rather than via this routine.  */
end_comment

begin_function
specifier|static
name|boolean
name|coff_slurp_symbol_table
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|combined_entry_type
modifier|*
name|native_symbols
decl_stmt|;
name|coff_symbol_type
modifier|*
name|cached_area
decl_stmt|;
name|unsigned
name|int
modifier|*
name|table_ptr
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|unsigned
name|int
name|number_of_symbols
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|obj_symbols
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* Read in the symbol table */
if|if
condition|(
operator|(
name|native_symbols
operator|=
name|coff_get_normalized_symtab
argument_list|(
name|abfd
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|false
operator|)
return|;
block|}
comment|/* on error */
comment|/* Allocate enough room for all the symbols in cached form */
name|amt
operator|=
name|obj_raw_syment_count
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
name|coff_symbol_type
argument_list|)
expr_stmt|;
name|cached_area
operator|=
operator|(
name|coff_symbol_type
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|cached_area
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|amt
operator|=
name|obj_raw_syment_count
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|amt
operator|*=
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
expr_stmt|;
name|table_ptr
operator|=
operator|(
name|unsigned
name|int
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|table_ptr
operator|==
name|NULL
condition|)
return|return
name|false
return|;
else|else
block|{
name|coff_symbol_type
modifier|*
name|dst
init|=
name|cached_area
decl_stmt|;
name|unsigned
name|int
name|last_native_index
init|=
name|obj_raw_syment_count
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|this_index
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|this_index
operator|<
name|last_native_index
condition|)
block|{
name|combined_entry_type
modifier|*
name|src
init|=
name|native_symbols
operator|+
name|this_index
decl_stmt|;
name|table_ptr
index|[
name|this_index
index|]
operator|=
name|number_of_symbols
expr_stmt|;
name|dst
operator|->
name|symbol
operator|.
name|the_bfd
operator|=
name|abfd
expr_stmt|;
name|dst
operator|->
name|symbol
operator|.
name|name
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
operator|)
expr_stmt|;
comment|/* We use the native name field to point to the cached field.  */
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_zeroes
operator|=
operator|(
name|long
operator|)
name|dst
expr_stmt|;
name|dst
operator|->
name|symbol
operator|.
name|section
operator|=
name|coff_section_from_bfd_index
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_scnum
argument_list|)
expr_stmt|;
name|dst
operator|->
name|symbol
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|dst
operator|->
name|done_lineno
operator|=
name|false
expr_stmt|;
switch|switch
condition|(
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
condition|)
block|{
ifdef|#
directive|ifdef
name|I960
case|case
name|C_LEAFEXT
case|:
if|#
directive|if
literal|0
block|dst->symbol.value = src->u.syment.n_value - dst->symbol.section->vma; 	      dst->symbol.flags = BSF_EXPORT | BSF_GLOBAL; 	      dst->symbol.flags |= BSF_NOT_AT_END | BSF_FUNCTION;
endif|#
directive|endif
comment|/* Fall through to next case */
endif|#
directive|endif
case|case
name|C_EXT
case|:
case|case
name|C_WEAKEXT
case|:
if|#
directive|if
name|defined
name|ARM
case|case
name|C_THUMBEXT
case|:
case|case
name|C_THUMBEXTFUNC
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RS6000COFF_C
case|case
name|C_HIDEXT
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|C_SYSTEM
case|case
name|C_SYSTEM
case|:
comment|/* System Wide variable */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|COFF_WITH_PE
comment|/* In PE, 0x68 (104) denotes a section symbol */
case|case
name|C_SECTION
case|:
comment|/* In PE, 0x69 (105) denotes a weak external symbol.  */
case|case
name|C_NT_WEAK
case|:
endif|#
directive|endif
switch|switch
condition|(
name|coff_classify_symbol
argument_list|(
name|abfd
argument_list|,
operator|&
name|src
operator|->
name|u
operator|.
name|syment
argument_list|)
condition|)
block|{
case|case
name|COFF_SYMBOL_GLOBAL
case|:
name|dst
operator|->
name|symbol
operator|.
name|flags
operator|=
name|BSF_EXPORT
operator||
name|BSF_GLOBAL
expr_stmt|;
if|#
directive|if
name|defined
name|COFF_WITH_PE
comment|/* PE sets the symbol to a value relative to the                      start of the section.  */
name|dst
operator|->
name|symbol
operator|.
name|value
operator|=
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
expr_stmt|;
else|#
directive|else
name|dst
operator|->
name|symbol
operator|.
name|value
operator|=
operator|(
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
operator|-
name|dst
operator|->
name|symbol
operator|.
name|section
operator|->
name|vma
operator|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ISFCN
argument_list|(
operator|(
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_type
operator|)
argument_list|)
condition|)
block|{
comment|/* A function ext does not go at the end of a 			 file.  */
name|dst
operator|->
name|symbol
operator|.
name|flags
operator||=
name|BSF_NOT_AT_END
operator||
name|BSF_FUNCTION
expr_stmt|;
block|}
break|break;
case|case
name|COFF_SYMBOL_COMMON
case|:
name|dst
operator|->
name|symbol
operator|.
name|section
operator|=
name|bfd_com_section_ptr
expr_stmt|;
name|dst
operator|->
name|symbol
operator|.
name|value
operator|=
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
expr_stmt|;
break|break;
case|case
name|COFF_SYMBOL_UNDEFINED
case|:
name|dst
operator|->
name|symbol
operator|.
name|section
operator|=
name|bfd_und_section_ptr
expr_stmt|;
name|dst
operator|->
name|symbol
operator|.
name|value
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|COFF_SYMBOL_PE_SECTION
case|:
name|dst
operator|->
name|symbol
operator|.
name|flags
operator||=
name|BSF_EXPORT
operator||
name|BSF_SECTION_SYM
expr_stmt|;
name|dst
operator|->
name|symbol
operator|.
name|value
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|COFF_SYMBOL_LOCAL
case|:
name|dst
operator|->
name|symbol
operator|.
name|flags
operator|=
name|BSF_LOCAL
expr_stmt|;
if|#
directive|if
name|defined
name|COFF_WITH_PE
comment|/* PE sets the symbol to a value relative to the                      start of the section.  */
name|dst
operator|->
name|symbol
operator|.
name|value
operator|=
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
expr_stmt|;
else|#
directive|else
name|dst
operator|->
name|symbol
operator|.
name|value
operator|=
operator|(
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
operator|-
name|dst
operator|->
name|symbol
operator|.
name|section
operator|->
name|vma
operator|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ISFCN
argument_list|(
operator|(
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_type
operator|)
argument_list|)
condition|)
name|dst
operator|->
name|symbol
operator|.
name|flags
operator||=
name|BSF_NOT_AT_END
operator||
name|BSF_FUNCTION
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|RS6000COFF_C
comment|/* A symbol with a csect entry should not go at the end.  */
if|if
condition|(
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_numaux
operator|>
literal|0
condition|)
name|dst
operator|->
name|symbol
operator|.
name|flags
operator||=
name|BSF_NOT_AT_END
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|COFF_WITH_PE
if|if
condition|(
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
operator|==
name|C_NT_WEAK
condition|)
name|dst
operator|->
name|symbol
operator|.
name|flags
operator||=
name|BSF_WEAK
expr_stmt|;
if|if
condition|(
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
operator|==
name|C_SECTION
operator|&&
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_scnum
operator|>
literal|0
condition|)
name|dst
operator|->
name|symbol
operator|.
name|flags
operator|=
name|BSF_LOCAL
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
operator|==
name|C_WEAKEXT
condition|)
name|dst
operator|->
name|symbol
operator|.
name|flags
operator||=
name|BSF_WEAK
expr_stmt|;
break|break;
case|case
name|C_STAT
case|:
comment|/* static			 */
ifdef|#
directive|ifdef
name|I960
case|case
name|C_LEAFSTAT
case|:
comment|/* static leaf procedure        */
endif|#
directive|endif
if|#
directive|if
name|defined
name|ARM
case|case
name|C_THUMBSTAT
case|:
comment|/* Thumb static                  */
case|case
name|C_THUMBLABEL
case|:
comment|/* Thumb label                   */
case|case
name|C_THUMBSTATFUNC
case|:
comment|/* Thumb static function        */
endif|#
directive|endif
case|case
name|C_LABEL
case|:
comment|/* label			 */
if|if
condition|(
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_scnum
operator|==
name|N_DEBUG
condition|)
name|dst
operator|->
name|symbol
operator|.
name|flags
operator|=
name|BSF_DEBUGGING
expr_stmt|;
else|else
name|dst
operator|->
name|symbol
operator|.
name|flags
operator|=
name|BSF_LOCAL
expr_stmt|;
comment|/* Base the value as an index from the base of the 		 section, if there is one.  */
if|if
condition|(
name|dst
operator|->
name|symbol
operator|.
name|section
condition|)
block|{
if|#
directive|if
name|defined
name|COFF_WITH_PE
comment|/* PE sets the symbol to a value relative to the                      start of the section.  */
name|dst
operator|->
name|symbol
operator|.
name|value
operator|=
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
expr_stmt|;
else|#
directive|else
name|dst
operator|->
name|symbol
operator|.
name|value
operator|=
operator|(
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
operator|-
name|dst
operator|->
name|symbol
operator|.
name|section
operator|->
name|vma
operator|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|dst
operator|->
name|symbol
operator|.
name|value
operator|=
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
expr_stmt|;
break|break;
case|case
name|C_MOS
case|:
comment|/* member of structure	 */
case|case
name|C_EOS
case|:
comment|/* end of structure		 */
ifdef|#
directive|ifdef
name|NOTDEF
comment|/* C_AUTOARG has the same value */
ifdef|#
directive|ifdef
name|C_GLBLREG
case|case
name|C_GLBLREG
case|:
comment|/* A29k-specific storage class */
endif|#
directive|endif
endif|#
directive|endif
case|case
name|C_REGPARM
case|:
comment|/* register parameter		 */
case|case
name|C_REG
case|:
comment|/* register variable		 */
comment|/* C_AUTOARG conflictes with TI COFF C_UEXT */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|TIC80COFF
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|TICOFF
argument_list|)
ifdef|#
directive|ifdef
name|C_AUTOARG
case|case
name|C_AUTOARG
case|:
comment|/* 960-specific storage class */
endif|#
directive|endif
endif|#
directive|endif
case|case
name|C_TPDEF
case|:
comment|/* type definition		 */
case|case
name|C_ARG
case|:
case|case
name|C_AUTO
case|:
comment|/* automatic variable */
case|case
name|C_FIELD
case|:
comment|/* bit field */
case|case
name|C_ENTAG
case|:
comment|/* enumeration tag		 */
case|case
name|C_MOE
case|:
comment|/* member of enumeration	 */
case|case
name|C_MOU
case|:
comment|/* member of union		 */
case|case
name|C_UNTAG
case|:
comment|/* union tag			 */
name|dst
operator|->
name|symbol
operator|.
name|flags
operator|=
name|BSF_DEBUGGING
expr_stmt|;
name|dst
operator|->
name|symbol
operator|.
name|value
operator|=
operator|(
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
operator|)
expr_stmt|;
break|break;
case|case
name|C_FILE
case|:
comment|/* file name			 */
case|case
name|C_STRTAG
case|:
comment|/* structure tag		 */
ifdef|#
directive|ifdef
name|RS6000COFF_C
case|case
name|C_GSYM
case|:
case|case
name|C_LSYM
case|:
case|case
name|C_PSYM
case|:
case|case
name|C_RSYM
case|:
case|case
name|C_RPSYM
case|:
case|case
name|C_STSYM
case|:
case|case
name|C_BCOMM
case|:
case|case
name|C_ECOMM
case|:
case|case
name|C_DECL
case|:
case|case
name|C_ENTRY
case|:
case|case
name|C_FUN
case|:
case|case
name|C_ESTAT
case|:
endif|#
directive|endif
name|dst
operator|->
name|symbol
operator|.
name|flags
operator|=
name|BSF_DEBUGGING
expr_stmt|;
name|dst
operator|->
name|symbol
operator|.
name|value
operator|=
operator|(
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
operator|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|RS6000COFF_C
case|case
name|C_BINCL
case|:
comment|/* beginning of include file     */
case|case
name|C_EINCL
case|:
comment|/* ending of include file        */
comment|/* The value is actually a pointer into the line numbers                  of the file.  We locate the line number entry, and                  set the section to the section which contains it, and                  the value to the index in that section.  */
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|dst
operator|->
name|symbol
operator|.
name|flags
operator|=
name|BSF_DEBUGGING
expr_stmt|;
for|for
control|(
name|sec
operator|=
name|abfd
operator|->
name|sections
init|;
name|sec
operator|!=
name|NULL
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
if|if
condition|(
name|sec
operator|->
name|line_filepos
operator|<=
operator|(
name|file_ptr
operator|)
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
operator|&&
operator|(
call|(
name|file_ptr
call|)
argument_list|(
name|sec
operator|->
name|line_filepos
operator|+
name|sec
operator|->
name|lineno_count
operator|*
name|bfd_coff_linesz
argument_list|(
name|abfd
argument_list|)
argument_list|)
operator|>
operator|(
name|file_ptr
operator|)
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
operator|)
condition|)
break|break;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
name|dst
operator|->
name|symbol
operator|.
name|value
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|dst
operator|->
name|symbol
operator|.
name|section
operator|=
name|sec
expr_stmt|;
name|dst
operator|->
name|symbol
operator|.
name|value
operator|=
operator|(
operator|(
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
operator|-
name|sec
operator|->
name|line_filepos
operator|)
operator|/
name|bfd_coff_linesz
argument_list|(
name|abfd
argument_list|)
operator|)
expr_stmt|;
name|src
operator|->
name|fix_line
operator|=
literal|1
expr_stmt|;
block|}
block|}
break|break;
case|case
name|C_BSTAT
case|:
name|dst
operator|->
name|symbol
operator|.
name|flags
operator|=
name|BSF_DEBUGGING
expr_stmt|;
comment|/* The value is actually a symbol index.  Save a pointer 		 to the symbol instead of the index.  FIXME: This 		 should use a union.  */
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
operator|=
call|(
name|long
call|)
argument_list|(
name|native_symbols
operator|+
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
argument_list|)
expr_stmt|;
name|dst
operator|->
name|symbol
operator|.
name|value
operator|=
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
expr_stmt|;
name|src
operator|->
name|fix_value
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|C_BLOCK
case|:
comment|/* ".bb" or ".eb"		 */
case|case
name|C_FCN
case|:
comment|/* ".bf" or ".ef" (or PE ".lf")  */
case|case
name|C_EFCN
case|:
comment|/* physical end of function	 */
if|#
directive|if
name|defined
name|COFF_WITH_PE
comment|/* PE sets the symbol to a value relative to the start 		 of the section.  */
name|dst
operator|->
name|symbol
operator|.
name|value
operator|=
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|dst
operator|->
name|symbol
operator|.
name|name
argument_list|,
literal|".bf"
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* PE uses funny values for .ef and .lf; don't                      relocate them.  */
name|dst
operator|->
name|symbol
operator|.
name|flags
operator|=
name|BSF_DEBUGGING
expr_stmt|;
block|}
else|else
name|dst
operator|->
name|symbol
operator|.
name|flags
operator|=
name|BSF_DEBUGGING
operator||
name|BSF_DEBUGGING_RELOC
expr_stmt|;
else|#
directive|else
comment|/* Base the value as an index from the base of the 		 section.  */
name|dst
operator|->
name|symbol
operator|.
name|flags
operator|=
name|BSF_LOCAL
expr_stmt|;
name|dst
operator|->
name|symbol
operator|.
name|value
operator|=
operator|(
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
operator|-
name|dst
operator|->
name|symbol
operator|.
name|section
operator|->
name|vma
operator|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|C_STATLAB
case|:
comment|/* Static load time label */
name|dst
operator|->
name|symbol
operator|.
name|value
operator|=
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
expr_stmt|;
name|dst
operator|->
name|symbol
operator|.
name|flags
operator|=
name|BSF_GLOBAL
expr_stmt|;
break|break;
case|case
name|C_NULL
case|:
comment|/* PE DLLs sometimes have zeroed out symbols for some                  reason.  Just ignore them without a warning.  */
if|if
condition|(
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_type
operator|==
literal|0
operator|&&
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
operator|==
literal|0
operator|&&
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_scnum
operator|==
literal|0
condition|)
break|break;
comment|/* Fall through.  */
case|case
name|C_EXTDEF
case|:
comment|/* external definition		 */
case|case
name|C_ULABEL
case|:
comment|/* undefined label		 */
case|case
name|C_USTATIC
case|:
comment|/* undefined static		 */
ifndef|#
directive|ifndef
name|COFF_WITH_PE
comment|/* C_LINE in regular coff is 0x68.  NT has taken over this storage                class to represent a section symbol */
case|case
name|C_LINE
case|:
comment|/* line # reformatted as symbol table entry */
comment|/* NT uses 0x67 for a weak symbol, not C_ALIAS.  */
case|case
name|C_ALIAS
case|:
comment|/* duplicate tag		 */
endif|#
directive|endif
comment|/* New storage classes for TI COFF */
if|#
directive|if
name|defined
argument_list|(
name|TIC80COFF
argument_list|)
operator|||
name|defined
argument_list|(
name|TICOFF
argument_list|)
case|case
name|C_UEXT
case|:
comment|/* Tentative external definition */
endif|#
directive|endif
case|case
name|C_EXTLAB
case|:
comment|/* External load time label */
case|case
name|C_HIDDEN
case|:
comment|/* ext symbol in dmert public lib */
default|default:
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: Unrecognized storage class %d for %s symbol `%s'"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
argument_list|,
name|dst
operator|->
name|symbol
operator|.
name|section
operator|->
name|name
argument_list|,
name|dst
operator|->
name|symbol
operator|.
name|name
argument_list|)
expr_stmt|;
name|dst
operator|->
name|symbol
operator|.
name|flags
operator|=
name|BSF_DEBUGGING
expr_stmt|;
name|dst
operator|->
name|symbol
operator|.
name|value
operator|=
operator|(
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
operator|)
expr_stmt|;
break|break;
block|}
comment|/*      BFD_ASSERT(dst->symbol.flags != 0);*/
name|dst
operator|->
name|native
operator|=
name|src
expr_stmt|;
name|dst
operator|->
name|symbol
operator|.
name|udata
operator|.
name|i
operator|=
literal|0
expr_stmt|;
name|dst
operator|->
name|lineno
operator|=
operator|(
name|alent
operator|*
operator|)
name|NULL
expr_stmt|;
name|this_index
operator|+=
operator|(
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_numaux
operator|)
operator|+
literal|1
expr_stmt|;
name|dst
operator|++
expr_stmt|;
name|number_of_symbols
operator|++
expr_stmt|;
block|}
comment|/* walk the native symtab */
block|}
comment|/* bfdize the native symtab */
name|obj_symbols
argument_list|(
name|abfd
argument_list|)
operator|=
name|cached_area
expr_stmt|;
name|obj_raw_syments
argument_list|(
name|abfd
argument_list|)
operator|=
name|native_symbols
expr_stmt|;
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|=
name|number_of_symbols
expr_stmt|;
name|obj_convert
argument_list|(
name|abfd
argument_list|)
operator|=
name|table_ptr
expr_stmt|;
comment|/* Slurp the line tables for each section too */
block|{
name|asection
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|abfd
operator|->
name|sections
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|coff_slurp_line_table
argument_list|(
name|abfd
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* coff_slurp_symbol_table() */
end_comment

begin_comment
comment|/* Classify a COFF symbol.  A couple of targets have globally visible    symbols which are not class C_EXT, and this handles those.  It also    recognizes some special PE cases.  */
end_comment

begin_function
specifier|static
name|enum
name|coff_symbol_classification
name|coff_classify_symbol
parameter_list|(
name|abfd
parameter_list|,
name|syment
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|internal_syment
modifier|*
name|syment
decl_stmt|;
block|{
comment|/* FIXME: This partially duplicates the switch in      coff_slurp_symbol_table.  */
switch|switch
condition|(
name|syment
operator|->
name|n_sclass
condition|)
block|{
case|case
name|C_EXT
case|:
case|case
name|C_WEAKEXT
case|:
ifdef|#
directive|ifdef
name|I960
case|case
name|C_LEAFEXT
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARM
case|case
name|C_THUMBEXT
case|:
case|case
name|C_THUMBEXTFUNC
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|C_SYSTEM
case|case
name|C_SYSTEM
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|COFF_WITH_PE
case|case
name|C_NT_WEAK
case|:
endif|#
directive|endif
if|if
condition|(
name|syment
operator|->
name|n_scnum
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|syment
operator|->
name|n_value
operator|==
literal|0
condition|)
return|return
name|COFF_SYMBOL_UNDEFINED
return|;
else|else
return|return
name|COFF_SYMBOL_COMMON
return|;
block|}
return|return
name|COFF_SYMBOL_GLOBAL
return|;
default|default:
break|break;
block|}
ifdef|#
directive|ifdef
name|COFF_WITH_PE
if|if
condition|(
name|syment
operator|->
name|n_sclass
operator|==
name|C_STAT
condition|)
block|{
if|if
condition|(
name|syment
operator|->
name|n_scnum
operator|==
literal|0
condition|)
block|{
comment|/* The Microsoft compiler sometimes generates these if a              small static function is inlined every time it is used.              The function is discarded, but the symbol table entry              remains.  */
return|return
name|COFF_SYMBOL_LOCAL
return|;
block|}
ifdef|#
directive|ifdef
name|STRICT_PE_FORMAT
comment|/* This is correct for Microsoft generated objects, but it          breaks gas generated objects.  */
if|if
condition|(
name|syment
operator|->
name|n_value
operator|==
literal|0
condition|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|char
name|buf
index|[
name|SYMNMLEN
operator|+
literal|1
index|]
decl_stmt|;
name|sec
operator|=
name|coff_section_from_bfd_index
argument_list|(
name|abfd
argument_list|,
name|syment
operator|->
name|n_scnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|!=
name|NULL
operator|&&
operator|(
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|,
name|_bfd_coff_internal_syment_name
argument_list|(
name|abfd
argument_list|,
name|syment
argument_list|,
name|buf
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
name|COFF_SYMBOL_PE_SECTION
return|;
block|}
endif|#
directive|endif
return|return
name|COFF_SYMBOL_LOCAL
return|;
block|}
if|if
condition|(
name|syment
operator|->
name|n_sclass
operator|==
name|C_SECTION
condition|)
block|{
comment|/* In some cases in a DLL generated by the Microsoft linker, the          n_value field will contain garbage.  FIXME: This should          probably be handled by the swapping function instead.  */
name|syment
operator|->
name|n_value
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|syment
operator|->
name|n_scnum
operator|==
literal|0
condition|)
return|return
name|COFF_SYMBOL_UNDEFINED
return|;
return|return
name|COFF_SYMBOL_PE_SECTION
return|;
block|}
endif|#
directive|endif
comment|/* COFF_WITH_PE */
comment|/* If it is not a global symbol, we presume it is a local symbol.  */
if|if
condition|(
name|syment
operator|->
name|n_scnum
operator|==
literal|0
condition|)
block|{
name|char
name|buf
index|[
name|SYMNMLEN
operator|+
literal|1
index|]
decl_stmt|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"warning: %s: local symbol `%s' has no section"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|_bfd_coff_internal_syment_name
argument_list|(
name|abfd
argument_list|,
name|syment
argument_list|,
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|COFF_SYMBOL_LOCAL
return|;
block|}
end_function

begin_comment
comment|/* SUBSUBSECTION 	Reading relocations  	Coff relocations are easily transformed into the internal BFD form 	(@code{arelent}).  	Reading a coff relocation table is done in the following stages:  	o Read the entire coff relocation table into memory.  	o Process each relocation in turn; first swap it from the 	external to the internal form.  	o Turn the symbol referenced in the relocation's symbol index 	into a pointer into the canonical symbol table. 	This table is the same as the one returned by a call to 	@code{bfd_canonicalize_symtab}. The back end will call that 	routine and save the result if a canonicalization hasn't been done.  	o The reloc index is turned into a pointer to a howto 	structure, in a back end specific way. For instance, the 386 	and 960 use the @code{r_type} to directly produce an index 	into a howto table vector; the 88k subtracts a number from the 	@code{r_type} field and creates an addend field.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CALC_ADDEND
end_ifndef

begin_define
define|#
directive|define
name|CALC_ADDEND
parameter_list|(
name|abfd
parameter_list|,
name|ptr
parameter_list|,
name|reloc
parameter_list|,
name|cache_ptr
parameter_list|)
define|\
value|{                                                             \     coff_symbol_type *coffsym = (coff_symbol_type *) NULL;      \     if (ptr&& bfd_asymbol_bfd (ptr) != abfd)                   \       coffsym = (obj_symbols (abfd)                             \                  + (cache_ptr->sym_ptr_ptr - symbols));         \     else if (ptr)                                               \       coffsym = coff_symbol_from (abfd, ptr);                   \     if (coffsym != (coff_symbol_type *) NULL                    \&& coffsym->native->u.syment.n_scnum == 0)              \       cache_ptr->addend = 0;                                    \     else if (ptr&& bfd_asymbol_bfd (ptr) == abfd               \&& ptr->section != (asection *) NULL)              \       cache_ptr->addend = - (ptr->section->vma + ptr->value);   \     else                                                        \       cache_ptr->addend = 0;                                    \   }
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|boolean
name|coff_slurp_reloc_table
parameter_list|(
name|abfd
parameter_list|,
name|asect
parameter_list|,
name|symbols
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|sec_ptr
name|asect
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
block|{
name|RELOC
modifier|*
name|native_relocs
decl_stmt|;
name|arelent
modifier|*
name|reloc_cache
decl_stmt|;
name|arelent
modifier|*
name|cache_ptr
decl_stmt|;
name|unsigned
name|int
name|idx
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
if|if
condition|(
name|asect
operator|->
name|relocation
condition|)
return|return
name|true
return|;
if|if
condition|(
name|asect
operator|->
name|reloc_count
operator|==
literal|0
condition|)
return|return
name|true
return|;
if|if
condition|(
name|asect
operator|->
name|flags
operator|&
name|SEC_CONSTRUCTOR
condition|)
return|return
name|true
return|;
if|if
condition|(
operator|!
name|coff_slurp_symbol_table
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
name|amt
operator|=
operator|(
name|bfd_size_type
operator|)
name|bfd_coff_relsz
argument_list|(
name|abfd
argument_list|)
operator|*
name|asect
operator|->
name|reloc_count
expr_stmt|;
name|native_relocs
operator|=
operator|(
name|RELOC
operator|*
operator|)
name|buy_and_read
argument_list|(
name|abfd
argument_list|,
name|asect
operator|->
name|rel_filepos
argument_list|,
name|amt
argument_list|)
expr_stmt|;
name|amt
operator|=
operator|(
name|bfd_size_type
operator|)
name|asect
operator|->
name|reloc_count
operator|*
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
expr_stmt|;
name|reloc_cache
operator|=
operator|(
name|arelent
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc_cache
operator|==
name|NULL
condition|)
return|return
name|false
return|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|asect
operator|->
name|reloc_count
condition|;
name|idx
operator|++
control|)
block|{
name|struct
name|internal_reloc
name|dst
decl_stmt|;
name|struct
name|external_reloc
modifier|*
name|src
decl_stmt|;
ifndef|#
directive|ifndef
name|RELOC_PROCESSING
name|asymbol
modifier|*
name|ptr
decl_stmt|;
endif|#
directive|endif
name|cache_ptr
operator|=
name|reloc_cache
operator|+
name|idx
expr_stmt|;
name|src
operator|=
name|native_relocs
operator|+
name|idx
expr_stmt|;
name|coff_swap_reloc_in
argument_list|(
name|abfd
argument_list|,
name|src
argument_list|,
operator|&
name|dst
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RELOC_PROCESSING
name|RELOC_PROCESSING
argument_list|(
name|cache_ptr
argument_list|,
operator|&
name|dst
argument_list|,
name|symbols
argument_list|,
name|abfd
argument_list|,
name|asect
argument_list|)
expr_stmt|;
else|#
directive|else
name|cache_ptr
operator|->
name|address
operator|=
name|dst
operator|.
name|r_vaddr
expr_stmt|;
if|if
condition|(
name|dst
operator|.
name|r_symndx
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|dst
operator|.
name|r_symndx
operator|<
literal|0
operator|||
name|dst
operator|.
name|r_symndx
operator|>=
name|obj_conv_table_size
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: warning: illegal symbol index %ld in relocs"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|dst
operator|.
name|r_symndx
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|sym_ptr_ptr
operator|=
name|bfd_abs_section_ptr
operator|->
name|symbol_ptr_ptr
expr_stmt|;
name|ptr
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|cache_ptr
operator|->
name|sym_ptr_ptr
operator|=
operator|(
name|symbols
operator|+
name|obj_convert
argument_list|(
name|abfd
argument_list|)
index|[
name|dst
operator|.
name|r_symndx
index|]
operator|)
expr_stmt|;
name|ptr
operator|=
operator|*
operator|(
name|cache_ptr
operator|->
name|sym_ptr_ptr
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|cache_ptr
operator|->
name|sym_ptr_ptr
operator|=
name|bfd_abs_section_ptr
operator|->
name|symbol_ptr_ptr
expr_stmt|;
name|ptr
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* The symbols definitions that we have read in have been 	 relocated as if their sections started at 0. But the offsets 	 refering to the symbols in the raw data have not been 	 modified, so we have to have a negative addend to compensate.  	 Note that symbols which used to be common must be left alone */
comment|/* Calculate any reloc addend by looking at the symbol */
name|CALC_ADDEND
argument_list|(
name|abfd
argument_list|,
name|ptr
argument_list|,
name|dst
argument_list|,
name|cache_ptr
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|address
operator|-=
name|asect
operator|->
name|vma
expr_stmt|;
comment|/* !!     cache_ptr->section = (asection *) NULL;*/
comment|/* Fill in the cache_ptr->howto field from dst.r_type */
name|RTYPE2HOWTO
argument_list|(
name|cache_ptr
argument_list|,
operator|&
name|dst
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RELOC_PROCESSING */
if|if
condition|(
name|cache_ptr
operator|->
name|howto
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: illegal relocation type %d at address 0x%lx"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|dst
operator|.
name|r_type
argument_list|,
operator|(
name|long
operator|)
name|dst
operator|.
name|r_vaddr
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
name|asect
operator|->
name|relocation
operator|=
name|reloc_cache
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|coff_rtype_to_howto
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|RTYPE2HOWTO
end_ifdef

begin_comment
comment|/* Get the howto structure for a reloc.  This is only used if the file    including this one defines coff_relocate_section to be    _bfd_coff_generic_relocate_section, so it is OK if it does not    always work.  It is the responsibility of the including file to    make sure it is reasonable if it is needed.  */
end_comment

begin_decl_stmt
specifier|static
name|reloc_howto_type
modifier|*
name|coff_rtype_to_howto
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
expr|struct
name|internal_reloc
operator|*
operator|,
expr|struct
name|coff_link_hash_entry
operator|*
operator|,
expr|struct
name|internal_syment
operator|*
operator|,
name|bfd_vma
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|coff_rtype_to_howto
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|rel
parameter_list|,
name|h
parameter_list|,
name|sym
parameter_list|,
name|addendp
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|sec
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|rel
decl_stmt|;
name|struct
name|coff_link_hash_entry
modifier|*
name|h
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|internal_syment
modifier|*
name|sym
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd_vma
modifier|*
name|addendp
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|arelent
name|genrel
decl_stmt|;
name|RTYPE2HOWTO
argument_list|(
operator|&
name|genrel
argument_list|,
name|rel
argument_list|)
expr_stmt|;
return|return
name|genrel
operator|.
name|howto
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! defined (RTYPE2HOWTO) */
end_comment

begin_define
define|#
directive|define
name|coff_rtype_to_howto
value|NULL
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! defined (RTYPE2HOWTO) */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! defined (coff_rtype_to_howto) */
end_comment

begin_comment
comment|/* This is stupid.  This function should be a boolean predicate.  */
end_comment

begin_function
specifier|static
name|long
name|coff_canonicalize_reloc
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|relptr
parameter_list|,
name|symbols
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|sec_ptr
name|section
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|relptr
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
block|{
name|arelent
modifier|*
name|tblptr
init|=
name|section
operator|->
name|relocation
decl_stmt|;
name|unsigned
name|int
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|section
operator|->
name|flags
operator|&
name|SEC_CONSTRUCTOR
condition|)
block|{
comment|/* this section has relocs made up by us, they are not in the        file, so take them out of their chain and place them into        the data area provided */
name|arelent_chain
modifier|*
name|chain
init|=
name|section
operator|->
name|constructor_chain
decl_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|section
operator|->
name|reloc_count
condition|;
name|count
operator|++
control|)
block|{
operator|*
name|relptr
operator|++
operator|=
operator|&
name|chain
operator|->
name|relent
expr_stmt|;
name|chain
operator|=
name|chain
operator|->
name|next
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|coff_slurp_reloc_table
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|symbols
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|tblptr
operator|=
name|section
operator|->
name|relocation
expr_stmt|;
for|for
control|(
init|;
name|count
operator|++
operator|<
name|section
operator|->
name|reloc_count
condition|;
control|)
operator|*
name|relptr
operator|++
operator|=
name|tblptr
operator|++
expr_stmt|;
block|}
operator|*
name|relptr
operator|=
literal|0
expr_stmt|;
return|return
name|section
operator|->
name|reloc_count
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|GNU960
end_ifdef

begin_function
name|file_ptr
name|coff_sym_filepos
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
return|return
name|obj_sym_filepos
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|coff_reloc16_estimate
end_ifndef

begin_define
define|#
directive|define
name|coff_reloc16_estimate
value|dummy_reloc16_estimate
end_define

begin_decl_stmt
specifier|static
name|int
name|dummy_reloc16_estimate
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|arelent
operator|*
operator|,
name|unsigned
name|int
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|dummy_reloc16_estimate
parameter_list|(
name|abfd
parameter_list|,
name|input_section
parameter_list|,
name|reloc
parameter_list|,
name|shrink
parameter_list|,
name|link_info
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|input_section
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|arelent
modifier|*
name|reloc
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|unsigned
name|int
name|shrink
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|link_info
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|abort
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|coff_reloc16_extra_cases
end_ifndef

begin_define
define|#
directive|define
name|coff_reloc16_extra_cases
value|dummy_reloc16_extra_cases
end_define

begin_comment
comment|/* This works even if abort is not declared in any header file.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|dummy_reloc16_extra_cases
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|bfd_link_order
operator|*
operator|,
name|arelent
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|unsigned
name|int
operator|*
operator|,
name|unsigned
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|dummy_reloc16_extra_cases
parameter_list|(
name|abfd
parameter_list|,
name|link_info
parameter_list|,
name|link_order
parameter_list|,
name|reloc
parameter_list|,
name|data
parameter_list|,
name|src_ptr
parameter_list|,
name|dst_ptr
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|link_info
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|bfd_link_order
modifier|*
name|link_order
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|arelent
modifier|*
name|reloc
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd_byte
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|unsigned
name|int
modifier|*
name|src_ptr
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|unsigned
name|int
modifier|*
name|dst_ptr
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If coff_relocate_section is defined, we can use the optimized COFF    backend linker.  Otherwise we must continue to use the old linker.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|coff_relocate_section
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|coff_bfd_link_hash_table_create
end_ifndef

begin_define
define|#
directive|define
name|coff_bfd_link_hash_table_create
value|_bfd_coff_link_hash_table_create
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|coff_bfd_link_add_symbols
end_ifndef

begin_define
define|#
directive|define
name|coff_bfd_link_add_symbols
value|_bfd_coff_link_add_symbols
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|coff_bfd_final_link
end_ifndef

begin_define
define|#
directive|define
name|coff_bfd_final_link
value|_bfd_coff_final_link
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! defined (coff_relocate_section) */
end_comment

begin_define
define|#
directive|define
name|coff_relocate_section
value|NULL
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|coff_bfd_link_hash_table_create
end_ifndef

begin_define
define|#
directive|define
name|coff_bfd_link_hash_table_create
value|_bfd_generic_link_hash_table_create
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|coff_bfd_link_add_symbols
end_ifndef

begin_define
define|#
directive|define
name|coff_bfd_link_add_symbols
value|_bfd_generic_link_add_symbols
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|coff_bfd_final_link
value|_bfd_generic_final_link
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! defined (coff_relocate_section) */
end_comment

begin_define
define|#
directive|define
name|coff_bfd_link_split_section
value|_bfd_generic_link_split_section
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|coff_start_final_link
end_ifndef

begin_define
define|#
directive|define
name|coff_start_final_link
value|NULL
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|coff_adjust_symndx
end_ifndef

begin_define
define|#
directive|define
name|coff_adjust_symndx
value|NULL
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|coff_link_add_one_symbol
end_ifndef

begin_define
define|#
directive|define
name|coff_link_add_one_symbol
value|_bfd_generic_link_add_one_symbol
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|coff_link_output_has_begun
end_ifndef

begin_decl_stmt
specifier|static
name|boolean
name|coff_link_output_has_begun
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|coff_final_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|boolean
name|coff_link_output_has_begun
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|coff_final_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|abfd
operator|->
name|output_has_begun
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|coff_final_link_postscript
end_ifndef

begin_decl_stmt
specifier|static
name|boolean
name|coff_final_link_postscript
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|coff_final_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|boolean
name|coff_final_link_postscript
parameter_list|(
name|abfd
parameter_list|,
name|pfinfo
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|coff_final_link_info
modifier|*
name|pfinfo
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|true
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|coff_SWAP_aux_in
end_ifndef

begin_define
define|#
directive|define
name|coff_SWAP_aux_in
value|coff_swap_aux_in
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|coff_SWAP_sym_in
end_ifndef

begin_define
define|#
directive|define
name|coff_SWAP_sym_in
value|coff_swap_sym_in
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|coff_SWAP_lineno_in
end_ifndef

begin_define
define|#
directive|define
name|coff_SWAP_lineno_in
value|coff_swap_lineno_in
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|coff_SWAP_aux_out
end_ifndef

begin_define
define|#
directive|define
name|coff_SWAP_aux_out
value|coff_swap_aux_out
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|coff_SWAP_sym_out
end_ifndef

begin_define
define|#
directive|define
name|coff_SWAP_sym_out
value|coff_swap_sym_out
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|coff_SWAP_lineno_out
end_ifndef

begin_define
define|#
directive|define
name|coff_SWAP_lineno_out
value|coff_swap_lineno_out
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|coff_SWAP_reloc_out
end_ifndef

begin_define
define|#
directive|define
name|coff_SWAP_reloc_out
value|coff_swap_reloc_out
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|coff_SWAP_filehdr_out
end_ifndef

begin_define
define|#
directive|define
name|coff_SWAP_filehdr_out
value|coff_swap_filehdr_out
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|coff_SWAP_aouthdr_out
end_ifndef

begin_define
define|#
directive|define
name|coff_SWAP_aouthdr_out
value|coff_swap_aouthdr_out
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|coff_SWAP_scnhdr_out
end_ifndef

begin_define
define|#
directive|define
name|coff_SWAP_scnhdr_out
value|coff_swap_scnhdr_out
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|coff_SWAP_reloc_in
end_ifndef

begin_define
define|#
directive|define
name|coff_SWAP_reloc_in
value|coff_swap_reloc_in
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|coff_SWAP_filehdr_in
end_ifndef

begin_define
define|#
directive|define
name|coff_SWAP_filehdr_in
value|coff_swap_filehdr_in
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|coff_SWAP_aouthdr_in
end_ifndef

begin_define
define|#
directive|define
name|coff_SWAP_aouthdr_in
value|coff_swap_aouthdr_in
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|coff_SWAP_scnhdr_in
end_ifndef

begin_define
define|#
directive|define
name|coff_SWAP_scnhdr_in
value|coff_swap_scnhdr_in
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|bfd_coff_backend_data
name|bfd_coff_std_swap_table
init|=
block|{
name|coff_SWAP_aux_in
block|,
name|coff_SWAP_sym_in
block|,
name|coff_SWAP_lineno_in
block|,
name|coff_SWAP_aux_out
block|,
name|coff_SWAP_sym_out
block|,
name|coff_SWAP_lineno_out
block|,
name|coff_SWAP_reloc_out
block|,
name|coff_SWAP_filehdr_out
block|,
name|coff_SWAP_aouthdr_out
block|,
name|coff_SWAP_scnhdr_out
block|,
name|FILHSZ
block|,
name|AOUTSZ
block|,
name|SCNHSZ
block|,
name|SYMESZ
block|,
name|AUXESZ
block|,
name|RELSZ
block|,
name|LINESZ
block|,
name|FILNMLEN
block|,
ifdef|#
directive|ifdef
name|COFF_LONG_FILENAMES
name|true
block|,
else|#
directive|else
name|false
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|COFF_LONG_SECTION_NAMES
name|true
block|,
else|#
directive|else
name|false
block|,
endif|#
directive|endif
name|COFF_DEFAULT_SECTION_ALIGNMENT_POWER
block|,
ifdef|#
directive|ifdef
name|COFF_FORCE_SYMBOLS_IN_STRINGS
name|true
block|,
else|#
directive|else
name|false
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|COFF_DEBUG_STRING_WIDE_PREFIX
literal|4
block|,
else|#
directive|else
literal|2
block|,
endif|#
directive|endif
name|coff_SWAP_filehdr_in
block|,
name|coff_SWAP_aouthdr_in
block|,
name|coff_SWAP_scnhdr_in
block|,
name|coff_SWAP_reloc_in
block|,
name|coff_bad_format_hook
block|,
name|coff_set_arch_mach_hook
block|,
name|coff_mkobject_hook
block|,
name|styp_to_sec_flags
block|,
name|coff_set_alignment_hook
block|,
name|coff_slurp_symbol_table
block|,
name|symname_in_debug_hook
block|,
name|coff_pointerize_aux_hook
block|,
name|coff_print_aux
block|,
name|coff_reloc16_extra_cases
block|,
name|coff_reloc16_estimate
block|,
name|coff_classify_symbol
block|,
name|coff_compute_section_file_positions
block|,
name|coff_start_final_link
block|,
name|coff_relocate_section
block|,
name|coff_rtype_to_howto
block|,
name|coff_adjust_symndx
block|,
name|coff_link_add_one_symbol
block|,
name|coff_link_output_has_begun
block|,
name|coff_final_link_postscript
block|}
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|coff_close_and_cleanup
end_ifndef

begin_define
define|#
directive|define
name|coff_close_and_cleanup
value|_bfd_generic_close_and_cleanup
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|coff_bfd_free_cached_info
end_ifndef

begin_define
define|#
directive|define
name|coff_bfd_free_cached_info
value|_bfd_generic_bfd_free_cached_info
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|coff_get_section_contents
end_ifndef

begin_define
define|#
directive|define
name|coff_get_section_contents
value|_bfd_generic_get_section_contents
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|coff_bfd_copy_private_symbol_data
end_ifndef

begin_define
define|#
directive|define
name|coff_bfd_copy_private_symbol_data
value|_bfd_generic_bfd_copy_private_symbol_data
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|coff_bfd_copy_private_section_data
end_ifndef

begin_define
define|#
directive|define
name|coff_bfd_copy_private_section_data
value|_bfd_generic_bfd_copy_private_section_data
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|coff_bfd_copy_private_bfd_data
end_ifndef

begin_define
define|#
directive|define
name|coff_bfd_copy_private_bfd_data
value|_bfd_generic_bfd_copy_private_bfd_data
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|coff_bfd_merge_private_bfd_data
end_ifndef

begin_define
define|#
directive|define
name|coff_bfd_merge_private_bfd_data
value|_bfd_generic_bfd_merge_private_bfd_data
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|coff_bfd_set_private_flags
end_ifndef

begin_define
define|#
directive|define
name|coff_bfd_set_private_flags
value|_bfd_generic_bfd_set_private_flags
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|coff_bfd_print_private_bfd_data
end_ifndef

begin_define
define|#
directive|define
name|coff_bfd_print_private_bfd_data
value|_bfd_generic_bfd_print_private_bfd_data
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|coff_bfd_is_local_label_name
end_ifndef

begin_define
define|#
directive|define
name|coff_bfd_is_local_label_name
value|_bfd_coff_is_local_label_name
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|coff_read_minisymbols
end_ifndef

begin_define
define|#
directive|define
name|coff_read_minisymbols
value|_bfd_generic_read_minisymbols
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|coff_minisymbol_to_symbol
end_ifndef

begin_define
define|#
directive|define
name|coff_minisymbol_to_symbol
value|_bfd_generic_minisymbol_to_symbol
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The reloc lookup routine must be supplied by each individual COFF    backend.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|coff_bfd_reloc_type_lookup
end_ifndef

begin_define
define|#
directive|define
name|coff_bfd_reloc_type_lookup
value|_bfd_norelocs_bfd_reloc_type_lookup
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|coff_bfd_get_relocated_section_contents
end_ifndef

begin_define
define|#
directive|define
name|coff_bfd_get_relocated_section_contents
define|\
value|bfd_generic_get_relocated_section_contents
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|coff_bfd_relax_section
end_ifndef

begin_define
define|#
directive|define
name|coff_bfd_relax_section
value|bfd_generic_relax_section
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|coff_bfd_gc_sections
end_ifndef

begin_define
define|#
directive|define
name|coff_bfd_gc_sections
value|bfd_generic_gc_sections
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|coff_bfd_merge_sections
end_ifndef

begin_define
define|#
directive|define
name|coff_bfd_merge_sections
value|bfd_generic_merge_sections
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CREATE_BIG_COFF_TARGET_VEC
parameter_list|(
name|VAR
parameter_list|,
name|NAME
parameter_list|,
name|EXTRA_O_FLAGS
parameter_list|,
name|EXTRA_S_FLAGS
parameter_list|,
name|UNDER
parameter_list|,
name|ALTERNATIVE
parameter_list|)
define|\
value|const bfd_target VAR =							\ {									\   NAME ,								\   bfd_target_coff_flavour,						\   BFD_ENDIAN_BIG,
comment|/* data byte order is big */
value|\   BFD_ENDIAN_BIG,
comment|/* header byte order is big */
value|\
comment|/* object flags */
value|\   (HAS_RELOC | EXEC_P | HAS_LINENO | HAS_DEBUG |			\    HAS_SYMS | HAS_LOCALS | WP_TEXT | EXTRA_O_FLAGS),			\
comment|/* section flags */
value|\   (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC | EXTRA_S_FLAGS),\   UNDER,
comment|/* leading symbol underscore */
value|\   '/',
comment|/* ar_pad_char */
value|\   15,
comment|/* ar_max_namelen */
value|\   									\
comment|/* Data conversion functions.  */
value|\   bfd_getb64, bfd_getb_signed_64, bfd_putb64,				\   bfd_getb32, bfd_getb_signed_32, bfd_putb32,				\   bfd_getb16, bfd_getb_signed_16, bfd_putb16,				\   									\
comment|/* Header conversion functions.  */
value|\   bfd_getb64, bfd_getb_signed_64, bfd_putb64,				\   bfd_getb32, bfd_getb_signed_32, bfd_putb32,				\   bfd_getb16, bfd_getb_signed_16, bfd_putb16,				\ 									\
comment|/* bfd_check_format */
value|\   { _bfd_dummy_target, coff_object_p, bfd_generic_archive_p,		\     _bfd_dummy_target },						\
comment|/* bfd_set_format */
value|\   { bfd_false, coff_mkobject, _bfd_generic_mkarchive, bfd_false },	\
comment|/* bfd_write_contents */
value|\   { bfd_false, coff_write_object_contents, _bfd_write_archive_contents,	\     bfd_false },							\ 									\   BFD_JUMP_TABLE_GENERIC (coff),					\   BFD_JUMP_TABLE_COPY (coff),						\   BFD_JUMP_TABLE_CORE (_bfd_nocore),					\   BFD_JUMP_TABLE_ARCHIVE (_bfd_archive_coff),				\   BFD_JUMP_TABLE_SYMBOLS (coff),					\   BFD_JUMP_TABLE_RELOCS (coff),						\   BFD_JUMP_TABLE_WRITE (coff),						\   BFD_JUMP_TABLE_LINK (coff),						\   BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),				\   									\   ALTERNATIVE,								\   									\   COFF_SWAP_TABLE							\ };
end_define

begin_define
define|#
directive|define
name|CREATE_LITTLE_COFF_TARGET_VEC
parameter_list|(
name|VAR
parameter_list|,
name|NAME
parameter_list|,
name|EXTRA_O_FLAGS
parameter_list|,
name|EXTRA_S_FLAGS
parameter_list|,
name|UNDER
parameter_list|,
name|ALTERNATIVE
parameter_list|)
define|\
value|const bfd_target VAR =							\ {									\   NAME ,								\   bfd_target_coff_flavour,						\   BFD_ENDIAN_LITTLE,
comment|/* data byte order is little */
value|\   BFD_ENDIAN_LITTLE,
comment|/* header byte order is little */
value|\
comment|/* object flags */
value|\   (HAS_RELOC | EXEC_P | HAS_LINENO | HAS_DEBUG |			\    HAS_SYMS | HAS_LOCALS | WP_TEXT | EXTRA_O_FLAGS),			\
comment|/* section flags */
value|\   (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC | EXTRA_S_FLAGS),\   UNDER,
comment|/* leading symbol underscore */
value|\   '/',
comment|/* ar_pad_char */
value|\   15,
comment|/* ar_max_namelen */
value|\ 									\
comment|/* Data conversion functions.  */
value|\   bfd_getl64, bfd_getl_signed_64, bfd_putl64,				\   bfd_getl32, bfd_getl_signed_32, bfd_putl32,				\   bfd_getl16, bfd_getl_signed_16, bfd_putl16,				\
comment|/* Header conversion functions.  */
value|\   bfd_getl64, bfd_getl_signed_64, bfd_putl64,				\   bfd_getl32, bfd_getl_signed_32, bfd_putl32,				\   bfd_getl16, bfd_getl_signed_16, bfd_putl16,				\
comment|/* bfd_check_format */
value|\   { _bfd_dummy_target, coff_object_p, bfd_generic_archive_p,		\     _bfd_dummy_target },						\
comment|/* bfd_set_format */
value|\   { bfd_false, coff_mkobject, _bfd_generic_mkarchive, bfd_false },	\
comment|/* bfd_write_contents */
value|\   { bfd_false, coff_write_object_contents, _bfd_write_archive_contents,	\     bfd_false },							\ 									\   BFD_JUMP_TABLE_GENERIC (coff),					\   BFD_JUMP_TABLE_COPY (coff),						\   BFD_JUMP_TABLE_CORE (_bfd_nocore),					\   BFD_JUMP_TABLE_ARCHIVE (_bfd_archive_coff),				\   BFD_JUMP_TABLE_SYMBOLS (coff),					\   BFD_JUMP_TABLE_RELOCS (coff),						\   BFD_JUMP_TABLE_WRITE (coff),						\   BFD_JUMP_TABLE_LINK (coff),						\   BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),				\ 									\   ALTERNATIVE,								\   									\   COFF_SWAP_TABLE							\ };
end_define

end_unit

