begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Low-level I/O routines for BFDs.     Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007    Free Software Foundation, Inc.     Written by Cygnus Support.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|S_IXUSR
end_ifndef

begin_define
define|#
directive|define
name|S_IXUSR
value|0100
end_define

begin_comment
comment|/* Execute by owner.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|S_IXGRP
end_ifndef

begin_define
define|#
directive|define
name|S_IXGRP
value|0010
end_define

begin_comment
comment|/* Execute by group.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|S_IXOTH
end_ifndef

begin_define
define|#
directive|define
name|S_IXOTH
value|0001
end_define

begin_comment
comment|/* Execute by others.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|file_ptr
name|real_ftell
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|HAVE_FTELLO64
argument_list|)
return|return
name|ftello64
argument_list|(
name|file
argument_list|)
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_FTELLO
argument_list|)
return|return
name|ftello
argument_list|(
name|file
argument_list|)
return|;
else|#
directive|else
return|return
name|ftell
argument_list|(
name|file
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|real_fseek
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|file_ptr
name|offset
parameter_list|,
name|int
name|whence
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|HAVE_FSEEKO64
argument_list|)
return|return
name|fseeko64
argument_list|(
name|file
argument_list|,
name|offset
argument_list|,
name|whence
argument_list|)
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_FSEEKO
argument_list|)
return|return
name|fseeko
argument_list|(
name|file
argument_list|,
name|offset
argument_list|,
name|whence
argument_list|)
return|;
else|#
directive|else
return|return
name|fseek
argument_list|(
name|file
argument_list|,
name|offset
argument_list|,
name|whence
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|FILE
modifier|*
name|real_fopen
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
specifier|const
name|char
modifier|*
name|modes
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|HAVE_FOPEN64
argument_list|)
return|return
name|fopen64
argument_list|(
name|filename
argument_list|,
name|modes
argument_list|)
return|;
else|#
directive|else
return|return
name|fopen
argument_list|(
name|filename
argument_list|,
name|modes
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* INTERNAL_DEFINITION 	struct bfd_iovec  DESCRIPTION  	The<<struct bfd_iovec>> contains the internal file I/O class. 	Each<<BFD>> has an instance of this class and all file I/O is 	routed through it (it is assumed that the instance implements 	all methods listed below).  .struct bfd_iovec .{ .  {* To avoid problems with macros, a "b" rather than "f" .     prefix is prepended to each method name.  *} .  {* Attempt to read/write NBYTES on ABFD's IOSTREAM storing/fetching .     bytes starting at PTR.  Return the number of bytes actually .     transfered (a read past end-of-file returns less than NBYTES), .     or -1 (setting<<bfd_error>>) if an error occurs.  *} .  file_ptr (*bread) (struct bfd *abfd, void *ptr, file_ptr nbytes); .  file_ptr (*bwrite) (struct bfd *abfd, const void *ptr, .                      file_ptr nbytes); .  {* Return the current IOSTREAM file offset, or -1 (setting<<bfd_error>> .     if an error occurs.  *} .  file_ptr (*btell) (struct bfd *abfd); .  {* For the following, on successful completion a value of 0 is returned. .     Otherwise, a value of -1 is returned (and<<bfd_error>> is set).  *} .  int (*bseek) (struct bfd *abfd, file_ptr offset, int whence); .  int (*bclose) (struct bfd *abfd); .  int (*bflush) (struct bfd *abfd); .  int (*bstat) (struct bfd *abfd, struct stat *sb); .};  */
end_comment

begin_comment
comment|/* Return value is amount read.  */
end_comment

begin_function
name|bfd_size_type
name|bfd_bread
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|bfd_size_type
name|size
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|size_t
name|nread
decl_stmt|;
comment|/* If this is an archive element, don't read past the end of      this element.  */
if|if
condition|(
name|abfd
operator|->
name|arelt_data
operator|!=
name|NULL
condition|)
block|{
name|size_t
name|maxbytes
init|=
operator|(
operator|(
expr|struct
name|areltdata
operator|*
operator|)
name|abfd
operator|->
name|arelt_data
operator|)
operator|->
name|parsed_size
decl_stmt|;
if|if
condition|(
name|size
operator|>
name|maxbytes
condition|)
name|size
operator|=
name|maxbytes
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|BFD_IN_MEMORY
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|bfd_in_memory
modifier|*
name|bim
decl_stmt|;
name|bfd_size_type
name|get
decl_stmt|;
name|bim
operator|=
name|abfd
operator|->
name|iostream
expr_stmt|;
name|get
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|where
operator|+
name|get
operator|>
name|bim
operator|->
name|size
condition|)
block|{
if|if
condition|(
name|bim
operator|->
name|size
operator|<
operator|(
name|bfd_size_type
operator|)
name|abfd
operator|->
name|where
condition|)
name|get
operator|=
literal|0
expr_stmt|;
else|else
name|get
operator|=
name|bim
operator|->
name|size
operator|-
name|abfd
operator|->
name|where
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_file_truncated
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|ptr
argument_list|,
name|bim
operator|->
name|buffer
operator|+
name|abfd
operator|->
name|where
argument_list|,
operator|(
name|size_t
operator|)
name|get
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|where
operator|+=
name|get
expr_stmt|;
return|return
name|get
return|;
block|}
if|if
condition|(
name|abfd
operator|->
name|iovec
condition|)
name|nread
operator|=
name|abfd
operator|->
name|iovec
operator|->
name|bread
argument_list|(
name|abfd
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
name|nread
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nread
operator|!=
operator|(
name|size_t
operator|)
operator|-
literal|1
condition|)
name|abfd
operator|->
name|where
operator|+=
name|nread
expr_stmt|;
return|return
name|nread
return|;
block|}
end_function

begin_function
name|bfd_size_type
name|bfd_bwrite
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
name|bfd_size_type
name|size
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|size_t
name|nwrote
decl_stmt|;
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|BFD_IN_MEMORY
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|bfd_in_memory
modifier|*
name|bim
init|=
name|abfd
operator|->
name|iostream
decl_stmt|;
name|size
operator|=
operator|(
name|size_t
operator|)
name|size
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|where
operator|+
name|size
operator|>
name|bim
operator|->
name|size
condition|)
block|{
name|bfd_size_type
name|newsize
decl_stmt|,
name|oldsize
decl_stmt|;
name|oldsize
operator|=
operator|(
name|bim
operator|->
name|size
operator|+
literal|127
operator|)
operator|&
operator|~
operator|(
name|bfd_size_type
operator|)
literal|127
expr_stmt|;
name|bim
operator|->
name|size
operator|=
name|abfd
operator|->
name|where
operator|+
name|size
expr_stmt|;
comment|/* Round up to cut down on memory fragmentation */
name|newsize
operator|=
operator|(
name|bim
operator|->
name|size
operator|+
literal|127
operator|)
operator|&
operator|~
operator|(
name|bfd_size_type
operator|)
literal|127
expr_stmt|;
if|if
condition|(
name|newsize
operator|>
name|oldsize
condition|)
block|{
name|bim
operator|->
name|buffer
operator|=
name|bfd_realloc
argument_list|(
name|bim
operator|->
name|buffer
argument_list|,
name|newsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|bim
operator|->
name|buffer
operator|==
literal|0
condition|)
block|{
name|bim
operator|->
name|size
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
name|memcpy
argument_list|(
name|bim
operator|->
name|buffer
operator|+
name|abfd
operator|->
name|where
argument_list|,
name|ptr
argument_list|,
operator|(
name|size_t
operator|)
name|size
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|where
operator|+=
name|size
expr_stmt|;
return|return
name|size
return|;
block|}
if|if
condition|(
name|abfd
operator|->
name|iovec
condition|)
name|nwrote
operator|=
name|abfd
operator|->
name|iovec
operator|->
name|bwrite
argument_list|(
name|abfd
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
name|nwrote
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nwrote
operator|!=
operator|(
name|size_t
operator|)
operator|-
literal|1
condition|)
name|abfd
operator|->
name|where
operator|+=
name|nwrote
expr_stmt|;
if|if
condition|(
name|nwrote
operator|!=
name|size
condition|)
block|{
ifdef|#
directive|ifdef
name|ENOSPC
name|errno
operator|=
name|ENOSPC
expr_stmt|;
endif|#
directive|endif
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
block|}
return|return
name|nwrote
return|;
block|}
end_function

begin_function
name|file_ptr
name|bfd_tell
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|file_ptr
name|ptr
decl_stmt|;
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|BFD_IN_MEMORY
operator|)
operator|!=
literal|0
condition|)
return|return
name|abfd
operator|->
name|where
return|;
if|if
condition|(
name|abfd
operator|->
name|iovec
condition|)
block|{
name|ptr
operator|=
name|abfd
operator|->
name|iovec
operator|->
name|btell
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|my_archive
condition|)
name|ptr
operator|-=
name|abfd
operator|->
name|origin
expr_stmt|;
block|}
else|else
name|ptr
operator|=
literal|0
expr_stmt|;
name|abfd
operator|->
name|where
operator|=
name|ptr
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
name|int
name|bfd_flush
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|BFD_IN_MEMORY
operator|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|abfd
operator|->
name|iovec
condition|)
return|return
name|abfd
operator|->
name|iovec
operator|->
name|bflush
argument_list|(
name|abfd
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns 0 for success, negative value for failure (in which case    bfd_get_error can retrieve the error code).  */
end_comment

begin_function
name|int
name|bfd_stat
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|stat
modifier|*
name|statbuf
parameter_list|)
block|{
name|int
name|result
decl_stmt|;
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|BFD_IN_MEMORY
operator|)
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|iovec
condition|)
name|result
operator|=
name|abfd
operator|->
name|iovec
operator|->
name|bstat
argument_list|(
name|abfd
argument_list|,
name|statbuf
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Returns 0 for success, nonzero for failure (in which case bfd_get_error    can retrieve the error code).  */
end_comment

begin_function
name|int
name|bfd_seek
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|file_ptr
name|position
parameter_list|,
name|int
name|direction
parameter_list|)
block|{
name|int
name|result
decl_stmt|;
name|file_ptr
name|file_position
decl_stmt|;
comment|/* For the time being, a BFD may not seek to it's end.  The problem      is that we don't easily have a way to recognize the end of an      element in an archive.  */
name|BFD_ASSERT
argument_list|(
name|direction
operator|==
name|SEEK_SET
operator|||
name|direction
operator|==
name|SEEK_CUR
argument_list|)
expr_stmt|;
if|if
condition|(
name|direction
operator|==
name|SEEK_CUR
operator|&&
name|position
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|BFD_IN_MEMORY
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|bfd_in_memory
modifier|*
name|bim
decl_stmt|;
name|bim
operator|=
name|abfd
operator|->
name|iostream
expr_stmt|;
if|if
condition|(
name|direction
operator|==
name|SEEK_SET
condition|)
name|abfd
operator|->
name|where
operator|=
name|position
expr_stmt|;
else|else
name|abfd
operator|->
name|where
operator|+=
name|position
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|where
operator|>
name|bim
operator|->
name|size
condition|)
block|{
if|if
condition|(
operator|(
name|abfd
operator|->
name|direction
operator|==
name|write_direction
operator|)
operator|||
operator|(
name|abfd
operator|->
name|direction
operator|==
name|both_direction
operator|)
condition|)
block|{
name|bfd_size_type
name|newsize
decl_stmt|,
name|oldsize
decl_stmt|;
name|oldsize
operator|=
operator|(
name|bim
operator|->
name|size
operator|+
literal|127
operator|)
operator|&
operator|~
operator|(
name|bfd_size_type
operator|)
literal|127
expr_stmt|;
name|bim
operator|->
name|size
operator|=
name|abfd
operator|->
name|where
expr_stmt|;
comment|/* Round up to cut down on memory fragmentation */
name|newsize
operator|=
operator|(
name|bim
operator|->
name|size
operator|+
literal|127
operator|)
operator|&
operator|~
operator|(
name|bfd_size_type
operator|)
literal|127
expr_stmt|;
if|if
condition|(
name|newsize
operator|>
name|oldsize
condition|)
block|{
name|bim
operator|->
name|buffer
operator|=
name|bfd_realloc
argument_list|(
name|bim
operator|->
name|buffer
argument_list|,
name|newsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|bim
operator|->
name|buffer
operator|==
literal|0
condition|)
block|{
name|bim
operator|->
name|size
operator|=
literal|0
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
block|}
else|else
block|{
name|abfd
operator|->
name|where
operator|=
name|bim
operator|->
name|size
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_file_truncated
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
if|if
condition|(
name|abfd
operator|->
name|format
operator|!=
name|bfd_archive
operator|&&
name|abfd
operator|->
name|my_archive
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|direction
operator|==
name|SEEK_SET
operator|&&
operator|(
name|bfd_vma
operator|)
name|position
operator|==
name|abfd
operator|->
name|where
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* We need something smarter to optimize access to archives. 	 Currently, anything inside an archive is read via the file 	 handle for the archive.  Which means that a bfd_seek on one 	 component affects the `current position' in the archive, as 	 well as in any other component.  	 It might be sufficient to put a spike through the cache 	 abstraction, and look to the archive for the file position, 	 but I think we should try for something cleaner.  	 In the meantime, no optimization for archives.  */
block|}
name|file_position
operator|=
name|position
expr_stmt|;
if|if
condition|(
name|direction
operator|==
name|SEEK_SET
operator|&&
name|abfd
operator|->
name|my_archive
operator|!=
name|NULL
condition|)
name|file_position
operator|+=
name|abfd
operator|->
name|origin
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|iovec
condition|)
name|result
operator|=
name|abfd
operator|->
name|iovec
operator|->
name|bseek
argument_list|(
name|abfd
argument_list|,
name|file_position
argument_list|,
name|direction
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
name|int
name|hold_errno
init|=
name|errno
decl_stmt|;
comment|/* Force redetermination of `where' field.  */
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* An EINVAL error probably means that the file offset was          absurd.  */
if|if
condition|(
name|hold_errno
operator|==
name|EINVAL
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_file_truncated
argument_list|)
expr_stmt|;
else|else
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
name|errno
operator|=
name|hold_errno
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Adjust `where' field.  */
if|if
condition|(
name|direction
operator|==
name|SEEK_SET
condition|)
name|abfd
operator|->
name|where
operator|=
name|position
expr_stmt|;
else|else
name|abfd
operator|->
name|where
operator|+=
name|position
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* FUNCTION 	bfd_get_mtime  SYNOPSIS 	time_t bfd_get_mtime (bfd *abfd);  DESCRIPTION 	Return the file modification time (as read from the file system, or 	from the archive header for archive members).  */
end_comment

begin_function
name|time_t
name|bfd_get_mtime
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|struct
name|stat
name|buf
decl_stmt|;
if|if
condition|(
name|abfd
operator|->
name|mtime_set
condition|)
return|return
name|abfd
operator|->
name|mtime
return|;
if|if
condition|(
name|abfd
operator|->
name|iovec
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|abfd
operator|->
name|iovec
operator|->
name|bstat
argument_list|(
name|abfd
argument_list|,
operator|&
name|buf
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|abfd
operator|->
name|mtime
operator|=
name|buf
operator|.
name|st_mtime
expr_stmt|;
comment|/* Save value in case anyone wants it */
return|return
name|buf
operator|.
name|st_mtime
return|;
block|}
end_function

begin_comment
comment|/* FUNCTION 	bfd_get_size  SYNOPSIS 	file_ptr bfd_get_size (bfd *abfd);  DESCRIPTION 	Return the file size (as read from file system) for the file 	associated with BFD @var{abfd}.  	The initial motivation for, and use of, this routine is not 	so we can get the exact size of the object the BFD applies to, since 	that might not be generally possible (archive members for example). 	It would be ideal if someone could eventually modify 	it so that such results were guaranteed.  	Instead, we want to ask questions like "is this NNN byte sized 	object I'm about to try read from file offset YYY reasonable?" 	As as example of where we might do this, some object formats 	use string tables for which the first<<sizeof (long)>> bytes of the 	table contain the size of the table itself, including the size bytes. 	If an application tries to read what it thinks is one of these 	string tables, without some way to validate the size, and for 	some reason the size is wrong (byte swapping error, wrong location 	for the string table, etc.), the only clue is likely to be a read 	error when it tries to read the table, or a "virtual memory 	exhausted" error when it tries to allocate 15 bazillon bytes 	of space for the 15 bazillon byte table it is about to read. 	This function at least allows us to answer the question, "is the 	size reasonable?". */
end_comment

begin_function
name|file_ptr
name|bfd_get_size
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|struct
name|stat
name|buf
decl_stmt|;
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|BFD_IN_MEMORY
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|(
expr|struct
name|bfd_in_memory
operator|*
operator|)
name|abfd
operator|->
name|iostream
operator|)
operator|->
name|size
return|;
if|if
condition|(
name|abfd
operator|->
name|iovec
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|abfd
operator|->
name|iovec
operator|->
name|bstat
argument_list|(
name|abfd
argument_list|,
operator|&
name|buf
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|buf
operator|.
name|st_size
return|;
block|}
end_function

end_unit

