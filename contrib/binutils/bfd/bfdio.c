begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Low-level I/O routines for BFDs.     Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.     Written by Cygnus Support.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|S_IXUSR
end_ifndef

begin_define
define|#
directive|define
name|S_IXUSR
value|0100
end_define

begin_comment
comment|/* Execute by owner.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|S_IXGRP
end_ifndef

begin_define
define|#
directive|define
name|S_IXGRP
value|0010
end_define

begin_comment
comment|/* Execute by group.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|S_IXOTH
end_ifndef

begin_define
define|#
directive|define
name|S_IXOTH
value|0001
end_define

begin_comment
comment|/* Execute by others.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|file_ptr
name|real_ftell
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|HAVE_FTELLO64
argument_list|)
return|return
name|ftello64
argument_list|(
name|file
argument_list|)
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_FTELLO
argument_list|)
return|return
name|ftello
argument_list|(
name|file
argument_list|)
return|;
else|#
directive|else
return|return
name|ftell
argument_list|(
name|file
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|real_fseek
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|file_ptr
name|offset
parameter_list|,
name|int
name|whence
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|HAVE_FSEEKO64
argument_list|)
return|return
name|fseeko64
argument_list|(
name|file
argument_list|,
name|offset
argument_list|,
name|whence
argument_list|)
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_FSEEKO
argument_list|)
return|return
name|fseeko
argument_list|(
name|file
argument_list|,
name|offset
argument_list|,
name|whence
argument_list|)
return|;
else|#
directive|else
return|return
name|fseek
argument_list|(
name|file
argument_list|,
name|offset
argument_list|,
name|whence
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Note that archive entries don't have streams; they share their parent's.    This allows someone to play with the iostream behind BFD's back.     Also, note that the origin pointer points to the beginning of a file's    contents (0 for non-archive elements).  For archive entries this is the    first octet in the file, NOT the beginning of the archive header.  */
end_comment

begin_function
specifier|static
name|size_t
name|real_read
parameter_list|(
name|void
modifier|*
name|where
parameter_list|,
name|size_t
name|a
parameter_list|,
name|size_t
name|b
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|)
block|{
comment|/* FIXME - this looks like an optimization, but it's really to cover      up for a feature of some OSs (not solaris - sigh) that      ld/pe-dll.c takes advantage of (apparently) when it creates BFDs      internally and tries to link against them.  BFD seems to be smart      enough to realize there are no symbol records in the "file" that      doesn't exist but attempts to read them anyway.  On Solaris,      attempting to read zero bytes from a NULL file results in a core      dump, but on other platforms it just returns zero bytes read.      This makes it to something reasonable. - DJ */
if|if
condition|(
name|a
operator|==
literal|0
operator|||
name|b
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|#
directive|if
name|defined
argument_list|(
name|__VAX
argument_list|)
operator|&&
name|defined
argument_list|(
name|VMS
argument_list|)
comment|/* Apparently fread on Vax VMS does not keep the record length      information.  */
return|return
name|read
argument_list|(
name|fileno
argument_list|(
name|file
argument_list|)
argument_list|,
name|where
argument_list|,
name|a
operator|*
name|b
argument_list|)
return|;
else|#
directive|else
return|return
name|fread
argument_list|(
name|where
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|file
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Return value is amount read.  */
end_comment

begin_function
name|bfd_size_type
name|bfd_bread
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|bfd_size_type
name|size
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|size_t
name|nread
decl_stmt|;
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|BFD_IN_MEMORY
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|bfd_in_memory
modifier|*
name|bim
decl_stmt|;
name|bfd_size_type
name|get
decl_stmt|;
name|bim
operator|=
name|abfd
operator|->
name|iostream
expr_stmt|;
name|get
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|where
operator|+
name|get
operator|>
name|bim
operator|->
name|size
condition|)
block|{
if|if
condition|(
name|bim
operator|->
name|size
operator|<
operator|(
name|bfd_size_type
operator|)
name|abfd
operator|->
name|where
condition|)
name|get
operator|=
literal|0
expr_stmt|;
else|else
name|get
operator|=
name|bim
operator|->
name|size
operator|-
name|abfd
operator|->
name|where
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_file_truncated
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|ptr
argument_list|,
name|bim
operator|->
name|buffer
operator|+
name|abfd
operator|->
name|where
argument_list|,
operator|(
name|size_t
operator|)
name|get
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|where
operator|+=
name|get
expr_stmt|;
return|return
name|get
return|;
block|}
name|nread
operator|=
name|real_read
argument_list|(
name|ptr
argument_list|,
literal|1
argument_list|,
operator|(
name|size_t
operator|)
name|size
argument_list|,
name|bfd_cache_lookup
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nread
operator|!=
operator|(
name|size_t
operator|)
operator|-
literal|1
condition|)
name|abfd
operator|->
name|where
operator|+=
name|nread
expr_stmt|;
comment|/* Set bfd_error if we did not read as much data as we expected.       If the read failed due to an error set the bfd_error_system_call,      else set bfd_error_file_truncated.       A BFD backend may wish to override bfd_error_file_truncated to      provide something more useful (eg. no_symbols or wrong_format).  */
if|if
condition|(
name|nread
operator|!=
name|size
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|bfd_cache_lookup
argument_list|(
name|abfd
argument_list|)
argument_list|)
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
else|else
name|bfd_set_error
argument_list|(
name|bfd_error_file_truncated
argument_list|)
expr_stmt|;
block|}
return|return
name|nread
return|;
block|}
end_function

begin_function
name|bfd_size_type
name|bfd_bwrite
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
name|bfd_size_type
name|size
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|size_t
name|nwrote
decl_stmt|;
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|BFD_IN_MEMORY
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|bfd_in_memory
modifier|*
name|bim
init|=
name|abfd
operator|->
name|iostream
decl_stmt|;
name|size
operator|=
operator|(
name|size_t
operator|)
name|size
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|where
operator|+
name|size
operator|>
name|bim
operator|->
name|size
condition|)
block|{
name|bfd_size_type
name|newsize
decl_stmt|,
name|oldsize
decl_stmt|;
name|oldsize
operator|=
operator|(
name|bim
operator|->
name|size
operator|+
literal|127
operator|)
operator|&
operator|~
operator|(
name|bfd_size_type
operator|)
literal|127
expr_stmt|;
name|bim
operator|->
name|size
operator|=
name|abfd
operator|->
name|where
operator|+
name|size
expr_stmt|;
comment|/* Round up to cut down on memory fragmentation */
name|newsize
operator|=
operator|(
name|bim
operator|->
name|size
operator|+
literal|127
operator|)
operator|&
operator|~
operator|(
name|bfd_size_type
operator|)
literal|127
expr_stmt|;
if|if
condition|(
name|newsize
operator|>
name|oldsize
condition|)
block|{
name|bim
operator|->
name|buffer
operator|=
name|bfd_realloc
argument_list|(
name|bim
operator|->
name|buffer
argument_list|,
name|newsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|bim
operator|->
name|buffer
operator|==
literal|0
condition|)
block|{
name|bim
operator|->
name|size
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
name|memcpy
argument_list|(
name|bim
operator|->
name|buffer
operator|+
name|abfd
operator|->
name|where
argument_list|,
name|ptr
argument_list|,
operator|(
name|size_t
operator|)
name|size
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|where
operator|+=
name|size
expr_stmt|;
return|return
name|size
return|;
block|}
name|nwrote
operator|=
name|fwrite
argument_list|(
name|ptr
argument_list|,
literal|1
argument_list|,
operator|(
name|size_t
operator|)
name|size
argument_list|,
name|bfd_cache_lookup
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nwrote
operator|!=
operator|(
name|size_t
operator|)
operator|-
literal|1
condition|)
name|abfd
operator|->
name|where
operator|+=
name|nwrote
expr_stmt|;
if|if
condition|(
name|nwrote
operator|!=
name|size
condition|)
block|{
ifdef|#
directive|ifdef
name|ENOSPC
name|errno
operator|=
name|ENOSPC
expr_stmt|;
endif|#
directive|endif
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
block|}
return|return
name|nwrote
return|;
block|}
end_function

begin_function
name|file_ptr
name|bfd_tell
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|file_ptr
name|ptr
decl_stmt|;
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|BFD_IN_MEMORY
operator|)
operator|!=
literal|0
condition|)
return|return
name|abfd
operator|->
name|where
return|;
name|ptr
operator|=
name|real_ftell
argument_list|(
name|bfd_cache_lookup
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|my_archive
condition|)
name|ptr
operator|-=
name|abfd
operator|->
name|origin
expr_stmt|;
name|abfd
operator|->
name|where
operator|=
name|ptr
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
name|int
name|bfd_flush
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|BFD_IN_MEMORY
operator|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|fflush
argument_list|(
name|bfd_cache_lookup
argument_list|(
name|abfd
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns 0 for success, negative value for failure (in which case    bfd_get_error can retrieve the error code).  */
end_comment

begin_function
name|int
name|bfd_stat
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|stat
modifier|*
name|statbuf
parameter_list|)
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|int
name|result
decl_stmt|;
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|BFD_IN_MEMORY
operator|)
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|f
operator|=
name|bfd_cache_lookup
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|result
operator|=
name|fstat
argument_list|(
name|fileno
argument_list|(
name|f
argument_list|)
argument_list|,
name|statbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Returns 0 for success, nonzero for failure (in which case bfd_get_error    can retrieve the error code).  */
end_comment

begin_function
name|int
name|bfd_seek
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|file_ptr
name|position
parameter_list|,
name|int
name|direction
parameter_list|)
block|{
name|int
name|result
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|file_ptr
name|file_position
decl_stmt|;
comment|/* For the time being, a BFD may not seek to it's end.  The problem      is that we don't easily have a way to recognize the end of an      element in an archive.  */
name|BFD_ASSERT
argument_list|(
name|direction
operator|==
name|SEEK_SET
operator|||
name|direction
operator|==
name|SEEK_CUR
argument_list|)
expr_stmt|;
if|if
condition|(
name|direction
operator|==
name|SEEK_CUR
operator|&&
name|position
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|BFD_IN_MEMORY
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|bfd_in_memory
modifier|*
name|bim
decl_stmt|;
name|bim
operator|=
name|abfd
operator|->
name|iostream
expr_stmt|;
if|if
condition|(
name|direction
operator|==
name|SEEK_SET
condition|)
name|abfd
operator|->
name|where
operator|=
name|position
expr_stmt|;
else|else
name|abfd
operator|->
name|where
operator|+=
name|position
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|where
operator|>
name|bim
operator|->
name|size
condition|)
block|{
if|if
condition|(
operator|(
name|abfd
operator|->
name|direction
operator|==
name|write_direction
operator|)
operator|||
operator|(
name|abfd
operator|->
name|direction
operator|==
name|both_direction
operator|)
condition|)
block|{
name|bfd_size_type
name|newsize
decl_stmt|,
name|oldsize
decl_stmt|;
name|oldsize
operator|=
operator|(
name|bim
operator|->
name|size
operator|+
literal|127
operator|)
operator|&
operator|~
operator|(
name|bfd_size_type
operator|)
literal|127
expr_stmt|;
name|bim
operator|->
name|size
operator|=
name|abfd
operator|->
name|where
expr_stmt|;
comment|/* Round up to cut down on memory fragmentation */
name|newsize
operator|=
operator|(
name|bim
operator|->
name|size
operator|+
literal|127
operator|)
operator|&
operator|~
operator|(
name|bfd_size_type
operator|)
literal|127
expr_stmt|;
if|if
condition|(
name|newsize
operator|>
name|oldsize
condition|)
block|{
name|bim
operator|->
name|buffer
operator|=
name|bfd_realloc
argument_list|(
name|bim
operator|->
name|buffer
argument_list|,
name|newsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|bim
operator|->
name|buffer
operator|==
literal|0
condition|)
block|{
name|bim
operator|->
name|size
operator|=
literal|0
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
block|}
else|else
block|{
name|abfd
operator|->
name|where
operator|=
name|bim
operator|->
name|size
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_file_truncated
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
if|if
condition|(
name|abfd
operator|->
name|format
operator|!=
name|bfd_archive
operator|&&
name|abfd
operator|->
name|my_archive
operator|==
literal|0
condition|)
block|{
if|#
directive|if
literal|0
comment|/* Explanation for this code: I'm only about 95+% sure that the above 	 conditions are sufficient and that all i/o calls are properly 	 adjusting the `where' field.  So this is sort of an `assert' 	 that the `where' field is correct.  If we can go a while without 	 tripping the abort, we can probably safely disable this code, 	 so that the real optimizations happen.  */
block|file_ptr where_am_i_now;       where_am_i_now = real_ftell (bfd_cache_lookup (abfd));       if (abfd->my_archive) 	where_am_i_now -= abfd->origin;       if (where_am_i_now != abfd->where) 	abort ();
endif|#
directive|endif
if|if
condition|(
name|direction
operator|==
name|SEEK_SET
operator|&&
operator|(
name|bfd_vma
operator|)
name|position
operator|==
name|abfd
operator|->
name|where
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* We need something smarter to optimize access to archives. 	 Currently, anything inside an archive is read via the file 	 handle for the archive.  Which means that a bfd_seek on one 	 component affects the `current position' in the archive, as 	 well as in any other component.  	 It might be sufficient to put a spike through the cache 	 abstraction, and look to the archive for the file position, 	 but I think we should try for something cleaner.  	 In the meantime, no optimization for archives.  */
block|}
name|f
operator|=
name|bfd_cache_lookup
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|file_position
operator|=
name|position
expr_stmt|;
if|if
condition|(
name|direction
operator|==
name|SEEK_SET
operator|&&
name|abfd
operator|->
name|my_archive
operator|!=
name|NULL
condition|)
name|file_position
operator|+=
name|abfd
operator|->
name|origin
expr_stmt|;
name|result
operator|=
name|real_fseek
argument_list|(
name|f
argument_list|,
name|file_position
argument_list|,
name|direction
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
name|int
name|hold_errno
init|=
name|errno
decl_stmt|;
comment|/* Force redetermination of `where' field.  */
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* An EINVAL error probably means that the file offset was          absurd.  */
if|if
condition|(
name|hold_errno
operator|==
name|EINVAL
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_file_truncated
argument_list|)
expr_stmt|;
else|else
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
name|errno
operator|=
name|hold_errno
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Adjust `where' field.  */
if|if
condition|(
name|direction
operator|==
name|SEEK_SET
condition|)
name|abfd
operator|->
name|where
operator|=
name|position
expr_stmt|;
else|else
name|abfd
operator|->
name|where
operator|+=
name|position
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* FUNCTION 	bfd_get_mtime  SYNOPSIS 	long bfd_get_mtime (bfd *abfd);  DESCRIPTION 	Return the file modification time (as read from the file system, or 	from the archive header for archive members).  */
end_comment

begin_function
name|long
name|bfd_get_mtime
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|struct
name|stat
name|buf
decl_stmt|;
if|if
condition|(
name|abfd
operator|->
name|mtime_set
condition|)
return|return
name|abfd
operator|->
name|mtime
return|;
name|fp
operator|=
name|bfd_cache_lookup
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|!=
name|fstat
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
operator|&
name|buf
argument_list|)
condition|)
return|return
literal|0
return|;
name|abfd
operator|->
name|mtime
operator|=
name|buf
operator|.
name|st_mtime
expr_stmt|;
comment|/* Save value in case anyone wants it */
return|return
name|buf
operator|.
name|st_mtime
return|;
block|}
end_function

begin_comment
comment|/* FUNCTION 	bfd_get_size  SYNOPSIS 	long bfd_get_size (bfd *abfd);  DESCRIPTION 	Return the file size (as read from file system) for the file 	associated with BFD @var{abfd}.  	The initial motivation for, and use of, this routine is not 	so we can get the exact size of the object the BFD applies to, since 	that might not be generally possible (archive members for example). 	It would be ideal if someone could eventually modify 	it so that such results were guaranteed.  	Instead, we want to ask questions like "is this NNN byte sized 	object I'm about to try read from file offset YYY reasonable?" 	As as example of where we might do this, some object formats 	use string tables for which the first<<sizeof (long)>> bytes of the 	table contain the size of the table itself, including the size bytes. 	If an application tries to read what it thinks is one of these 	string tables, without some way to validate the size, and for 	some reason the size is wrong (byte swapping error, wrong location 	for the string table, etc.), the only clue is likely to be a read 	error when it tries to read the table, or a "virtual memory 	exhausted" error when it tries to allocate 15 bazillon bytes 	of space for the 15 bazillon byte table it is about to read. 	This function at least allows us to answer the question, "is the 	size reasonable?". */
end_comment

begin_function
name|long
name|bfd_get_size
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|struct
name|stat
name|buf
decl_stmt|;
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|BFD_IN_MEMORY
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|(
expr|struct
name|bfd_in_memory
operator|*
operator|)
name|abfd
operator|->
name|iostream
operator|)
operator|->
name|size
return|;
name|fp
operator|=
name|bfd_cache_lookup
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|!=
name|fstat
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
operator|&
name|buf
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|buf
operator|.
name|st_size
return|;
block|}
end_function

end_unit

