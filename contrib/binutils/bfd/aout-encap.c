begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD back-end for a.out files encapsulated with COFF headers.    Copyright 1990, 1991, 1994, 1995, 2000 Free Software Foundation, Inc.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* THIS MODULE IS NOT FINISHED.  IT PROBABLY DOESN'T EVEN COMPILE.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|TARGET_PAGE_SIZE
value|4096
end_define

begin_define
define|#
directive|define
name|SEGMENT_SIZE
value|TARGET_PAGE_SIZE
end_define

begin_define
define|#
directive|define
name|TEXT_START_ADDR
value|0
end_define

begin_define
define|#
directive|define
name|BYTES_IN_WORD
value|4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|<sysdep.h>
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|<aout/aout64.h>
end_include

begin_include
include|#
directive|include
file|"aout/stab_gnu.h"
end_include

begin_include
include|#
directive|include
file|"aout/ar.h"
end_include

begin_include
include|#
directive|include
file|"libaout.h"
end_include

begin_comment
comment|/* BFD a.out internal data structures */
end_comment

begin_function_decl
specifier|const
name|bfd_target
modifier|*
name|encap_real_callback
parameter_list|()
function_decl|;
end_function_decl

begin_function
specifier|const
name|bfd_target
modifier|*
name|encap_object_p
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|unsigned
name|char
name|magicbuf
index|[
literal|4
index|]
decl_stmt|;
comment|/* Raw bytes of magic number from file */
name|unsigned
name|long
name|magic
decl_stmt|;
comment|/* Swapped magic number */
name|short
name|coff_magic
decl_stmt|;
name|struct
name|external_exec
name|exec_bytes
decl_stmt|;
name|struct
name|internal_exec
name|exec
decl_stmt|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|magicbuf
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|magicbuf
argument_list|)
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|magicbuf
argument_list|)
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_system_call
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|coff_magic
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
name|magicbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|coff_magic
operator|!=
name|COFF_MAGIC
condition|)
return|return
literal|0
return|;
comment|/* Not an encap coff file */
name|__header_offset_temp
operator|==
name|COFF_MAGIC
condition|?
sizeof|sizeof
argument_list|(
expr|struct
name|coffheader
argument_list|)
else|:
literal|0
block|)
parameter_list|(
function|fseek
parameter_list|(
function|(f
end_function

begin_operator
unit|)
operator|,
end_operator

begin_expr_stmt
name|HEADER_OFFSET
argument_list|(
operator|(
name|f
operator|)
argument_list|)
operator|,
literal|1
end_expr_stmt

begin_expr_stmt
unit|))
name|magic
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|magicbuf
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|N_BADMAG
argument_list|(
operator|*
operator|(
operator|(
expr|struct
name|internal_exec
operator|*
operator|)
operator|&
name|magic
operator|)
argument_list|)
condition|)
return|return
literal|0
return|;
end_if

begin_decl_stmt
name|struct
name|external_exec
name|exec_bytes
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|exec_bytes
argument_list|,
literal|1
argument_list|,
name|EXEC_BYTES_SIZE
argument_list|,
name|abfd
argument_list|)
operator|!=
name|EXEC_BYTES_SIZE
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_system_call
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_if

begin_expr_stmt
name|NAME
argument_list|(
name|aout
argument_list|,
name|swap_exec_header_in
argument_list|)
argument_list|(
name|abfd
argument_list|,
operator|&
name|exec_bytes
argument_list|,
operator|&
name|exec
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|aout_32_some_aout_object_p
argument_list|(
name|abfd
argument_list|,
operator|&
name|exec
argument_list|,
name|encap_realcallback
argument_list|)
return|;
end_return

begin_comment
unit|}
comment|/* Finish up the reading of a encapsulated-coff a.out file header */
end_comment

begin_function
unit|const
name|bfd_target
modifier|*
name|encap_real_callback
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|internal_exec
modifier|*
name|execp
init|=
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|MY
function_decl|(
name|callback
function_decl|)
parameter_list|(
name|abfd
parameter_list|,
name|execp
parameter_list|)
function_decl|;
comment|/* If we have a coff header, it can give us better values for      text_start and exec_data_start.  This is particularly useful      for remote debugging of embedded systems.  */
if|if
condition|(
name|N_FLAGS
argument_list|(
name|exec_aouthdr
argument_list|)
operator|&
name|N_FLAGS_COFF_ENCAPSULATE
condition|)
block|{
name|struct
name|coffheader
name|ch
decl_stmt|;
name|int
name|val
decl_stmt|;
name|val
operator|=
name|lseek
argument_list|(
name|execchan
argument_list|,
operator|-
operator|(
sizeof|sizeof
argument_list|(
name|AOUTHDR
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|ch
argument_list|)
operator|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
operator|-
literal|1
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|val
operator|=
name|myread
argument_list|(
name|execchan
argument_list|,
operator|&
name|ch
argument_list|,
sizeof|sizeof
argument_list|(
name|ch
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|text_start
operator|=
name|ch
operator|.
name|text_start
expr_stmt|;
name|exec_data_start
operator|=
name|ch
operator|.
name|data_start
expr_stmt|;
block|}
else|else
block|{
name|text_start
operator|=
name|IS_OBJECT_FILE
argument_list|(
name|exec_aouthdr
argument_list|)
condition|?
literal|0
else|:
name|N_TXTADDR
argument_list|(
name|exec_aouthdr
argument_list|)
expr_stmt|;
name|exec_data_start
operator|=
name|IS_OBJECT_FILE
argument_list|(
name|exec_aouthdr
argument_list|)
condition|?
name|exec_aouthdr
operator|.
name|a_text
else|:
name|N_DATADDR
argument_list|(
name|exec_aouthdr
argument_list|)
expr_stmt|;
block|}
comment|/* Determine the architecture and machine type of the object file.  */
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_m68k
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* FIXME */
return|return
name|abfd
operator|->
name|xvec
return|;
block|}
end_function

begin_comment
comment|/* Write an object file in Encapsulated COFF format.    Section contents have already been written.  We write the    file header, symbols, and relocation.  */
end_comment

begin_function
name|boolean
name|encap_write_object_contents
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|bfd_size_type
name|data_pad
init|=
literal|0
decl_stmt|;
name|struct
name|external_exec
name|exec_bytes
decl_stmt|;
name|struct
name|internal_exec
modifier|*
name|execp
init|=
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
comment|/****** FIXME:  Fragments from the old GNU LD program for dealing with         encap coff.  */
name|struct
name|coffheader
name|coffheader
decl_stmt|;
name|int
name|need_coff_header
decl_stmt|;
comment|/* Determine whether to count the header as part of      the text size, and initialize the text size accordingly.      This depends on the kind of system and on the output format selected.  */
name|N_SET_MAGIC
argument_list|(
name|outheader
argument_list|,
name|magic
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INITIALIZE_HEADER
name|INITIALIZE_HEADER
expr_stmt|;
endif|#
directive|endif
name|text_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|exec
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COFF_ENCAPSULATE
if|if
condition|(
name|relocatable_output
operator|==
literal|0
operator|&&
name|file_table
index|[
literal|0
index|]
operator|.
name|just_syms_flag
operator|==
literal|0
condition|)
block|{
name|need_coff_header
operator|=
literal|1
expr_stmt|;
comment|/* set this flag now, since it will change the values of N_TXTOFF, etc */
name|N_SET_FLAGS
argument_list|(
name|outheader
argument_list|,
name|aout_backend_info
argument_list|(
name|abfd
argument_list|)
operator|->
name|exec_hdr_flags
argument_list|)
expr_stmt|;
name|text_size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|coffheader
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|COFF_ENCAPSULATE
if|if
condition|(
name|need_coff_header
condition|)
block|{
comment|/* We are encapsulating BSD format within COFF format.  */
name|struct
name|coffscn
modifier|*
name|tp
decl_stmt|,
modifier|*
name|dp
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
name|tp
operator|=
operator|&
name|coffheader
operator|.
name|scns
index|[
literal|0
index|]
expr_stmt|;
name|dp
operator|=
operator|&
name|coffheader
operator|.
name|scns
index|[
literal|1
index|]
expr_stmt|;
name|bp
operator|=
operator|&
name|coffheader
operator|.
name|scns
index|[
literal|2
index|]
expr_stmt|;
name|strcpy
argument_list|(
name|tp
operator|->
name|s_name
argument_list|,
literal|".text"
argument_list|)
expr_stmt|;
name|tp
operator|->
name|s_paddr
operator|=
name|text_start
expr_stmt|;
name|tp
operator|->
name|s_vaddr
operator|=
name|text_start
expr_stmt|;
name|tp
operator|->
name|s_size
operator|=
name|text_size
expr_stmt|;
name|tp
operator|->
name|s_scnptr
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|coffheader
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|exec
argument_list|)
expr_stmt|;
name|tp
operator|->
name|s_relptr
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|s_lnnoptr
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|s_nreloc
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|s_nlnno
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|s_flags
operator|=
literal|0x20
expr_stmt|;
name|strcpy
argument_list|(
name|dp
operator|->
name|s_name
argument_list|,
literal|".data"
argument_list|)
expr_stmt|;
name|dp
operator|->
name|s_paddr
operator|=
name|data_start
expr_stmt|;
name|dp
operator|->
name|s_vaddr
operator|=
name|data_start
expr_stmt|;
name|dp
operator|->
name|s_size
operator|=
name|data_size
expr_stmt|;
name|dp
operator|->
name|s_scnptr
operator|=
name|tp
operator|->
name|s_scnptr
operator|+
name|tp
operator|->
name|s_size
expr_stmt|;
name|dp
operator|->
name|s_relptr
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|s_lnnoptr
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|s_nreloc
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|s_nlnno
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|s_flags
operator|=
literal|0x40
expr_stmt|;
name|strcpy
argument_list|(
name|bp
operator|->
name|s_name
argument_list|,
literal|".bss"
argument_list|)
expr_stmt|;
name|bp
operator|->
name|s_paddr
operator|=
name|dp
operator|->
name|s_vaddr
operator|+
name|dp
operator|->
name|s_size
expr_stmt|;
name|bp
operator|->
name|s_vaddr
operator|=
name|bp
operator|->
name|s_paddr
expr_stmt|;
name|bp
operator|->
name|s_size
operator|=
name|bss_size
expr_stmt|;
name|bp
operator|->
name|s_scnptr
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|s_relptr
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|s_lnnoptr
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|s_nreloc
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|s_nlnno
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|s_flags
operator|=
literal|0x80
expr_stmt|;
name|coffheader
operator|.
name|f_magic
operator|=
name|COFF_MAGIC
expr_stmt|;
name|coffheader
operator|.
name|f_nscns
operator|=
literal|3
expr_stmt|;
comment|/* store an unlikely time so programs can        * tell that there is a bsd header        */
name|coffheader
operator|.
name|f_timdat
operator|=
literal|1
expr_stmt|;
name|coffheader
operator|.
name|f_symptr
operator|=
literal|0
expr_stmt|;
name|coffheader
operator|.
name|f_nsyms
operator|=
literal|0
expr_stmt|;
name|coffheader
operator|.
name|f_opthdr
operator|=
literal|28
expr_stmt|;
name|coffheader
operator|.
name|f_flags
operator|=
literal|0x103
expr_stmt|;
comment|/* aouthdr */
name|coffheader
operator|.
name|magic
operator|=
name|ZMAGIC
expr_stmt|;
name|coffheader
operator|.
name|vstamp
operator|=
literal|0
expr_stmt|;
name|coffheader
operator|.
name|tsize
operator|=
name|tp
operator|->
name|s_size
expr_stmt|;
name|coffheader
operator|.
name|dsize
operator|=
name|dp
operator|->
name|s_size
expr_stmt|;
name|coffheader
operator|.
name|bsize
operator|=
name|bp
operator|->
name|s_size
expr_stmt|;
name|coffheader
operator|.
name|entry
operator|=
name|outheader
operator|.
name|a_entry
expr_stmt|;
name|coffheader
operator|.
name|text_start
operator|=
name|tp
operator|->
name|s_vaddr
expr_stmt|;
name|coffheader
operator|.
name|data_start
operator|=
name|dp
operator|->
name|s_vaddr
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|COFF_ENCAPSULATE
if|if
condition|(
name|need_coff_header
condition|)
name|mywrite
argument_list|(
operator|&
name|coffheader
argument_list|,
sizeof|sizeof
name|coffheader
argument_list|,
literal|1
argument_list|,
name|outdesc
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|COFF_ENCAPSULATE
name|padfile
argument_list|(
name|N_TXTOFF
argument_list|(
name|outheader
argument_list|)
operator|-
sizeof|sizeof
name|outheader
argument_list|,
name|outdesc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|text_size
operator|-=
name|N_TXTOFF
argument_list|(
name|outheader
argument_list|)
expr_stmt|;
name|WRITE_HEADERS
argument_list|(
name|abfd
argument_list|,
name|execp
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MY_write_object_content
value|encap_write_object_contents
end_define

begin_define
define|#
directive|define
name|MY_object_p
value|encap_object_p
end_define

begin_define
define|#
directive|define
name|MY_exec_hdr_flags
value|N_FLAGS_COFF_ENCAPSULATE
end_define

begin_include
include|#
directive|include
file|"aout-target.h"
end_include

end_unit

