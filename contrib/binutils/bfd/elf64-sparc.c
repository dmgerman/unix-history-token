begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* SPARC-specific support for 64-bit ELF    Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,    2003, 2004, 2005, 2007 Free Software Foundation, Inc.     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf/sparc.h"
end_include

begin_include
include|#
directive|include
file|"opcode/sparc.h"
end_include

begin_include
include|#
directive|include
file|"elfxx-sparc.h"
end_include

begin_comment
comment|/* In case we're on a 32-bit machine, construct a 64-bit "-1" value.  */
end_comment

begin_define
define|#
directive|define
name|MINUS_ONE
value|(~ (bfd_vma) 0)
end_define

begin_comment
comment|/* Due to the way how we handle R_SPARC_OLO10, each entry in a SHT_RELA    section can represent up to two relocs, we must tell the user to allocate    more space.  */
end_comment

begin_function
specifier|static
name|long
name|elf64_sparc_get_reloc_upper_bound
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|)
block|{
return|return
operator|(
name|sec
operator|->
name|reloc_count
operator|*
literal|2
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|elf64_sparc_get_dynamic_reloc_upper_bound
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
return|return
name|_bfd_elf_get_dynamic_reloc_upper_bound
argument_list|(
name|abfd
argument_list|)
operator|*
literal|2
return|;
block|}
end_function

begin_comment
comment|/* Read  relocations for ASECT from REL_HDR.  There are RELOC_COUNT of    them.  We cannot use generic elf routines for this,  because R_SPARC_OLO10    has secondary addend in ELF64_R_TYPE_DATA.  We handle it as two relocations    for the same location,  R_SPARC_LO10 and R_SPARC_13.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf64_sparc_slurp_one_reloc_table
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|asect
parameter_list|,
name|Elf_Internal_Shdr
modifier|*
name|rel_hdr
parameter_list|,
name|asymbol
modifier|*
modifier|*
name|symbols
parameter_list|,
name|bfd_boolean
name|dynamic
parameter_list|)
block|{
name|PTR
name|allocated
init|=
name|NULL
decl_stmt|;
name|bfd_byte
modifier|*
name|native_relocs
decl_stmt|;
name|arelent
modifier|*
name|relent
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|int
name|entsize
decl_stmt|;
name|bfd_size_type
name|count
decl_stmt|;
name|arelent
modifier|*
name|relents
decl_stmt|;
name|allocated
operator|=
operator|(
name|PTR
operator|)
name|bfd_malloc
argument_list|(
name|rel_hdr
operator|->
name|sh_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|allocated
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|rel_hdr
operator|->
name|sh_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bread
argument_list|(
name|allocated
argument_list|,
name|rel_hdr
operator|->
name|sh_size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|rel_hdr
operator|->
name|sh_size
condition|)
goto|goto
name|error_return
goto|;
name|native_relocs
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|allocated
expr_stmt|;
name|relents
operator|=
name|asect
operator|->
name|relocation
operator|+
name|canon_reloc_count
argument_list|(
name|asect
argument_list|)
expr_stmt|;
name|entsize
operator|=
name|rel_hdr
operator|->
name|sh_entsize
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|entsize
operator|==
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
argument_list|)
expr_stmt|;
name|count
operator|=
name|rel_hdr
operator|->
name|sh_size
operator|/
name|entsize
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|relent
operator|=
name|relents
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|relent
operator|++
operator|,
name|native_relocs
operator|+=
name|entsize
control|)
block|{
name|Elf_Internal_Rela
name|rela
decl_stmt|;
name|unsigned
name|int
name|r_type
decl_stmt|;
name|bfd_elf64_swap_reloca_in
argument_list|(
name|abfd
argument_list|,
name|native_relocs
argument_list|,
operator|&
name|rela
argument_list|)
expr_stmt|;
comment|/* The address of an ELF reloc is section relative for an object 	 file, and absolute for an executable file or shared library. 	 The address of a normal BFD reloc is always section relative, 	 and the address of a dynamic reloc is absolute..  */
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
operator|(
name|EXEC_P
operator||
name|DYNAMIC
operator|)
operator|)
operator|==
literal|0
operator|||
name|dynamic
condition|)
name|relent
operator|->
name|address
operator|=
name|rela
operator|.
name|r_offset
expr_stmt|;
else|else
name|relent
operator|->
name|address
operator|=
name|rela
operator|.
name|r_offset
operator|-
name|asect
operator|->
name|vma
expr_stmt|;
if|if
condition|(
name|ELF64_R_SYM
argument_list|(
name|rela
operator|.
name|r_info
argument_list|)
operator|==
literal|0
condition|)
name|relent
operator|->
name|sym_ptr_ptr
operator|=
name|bfd_abs_section_ptr
operator|->
name|symbol_ptr_ptr
expr_stmt|;
else|else
block|{
name|asymbol
modifier|*
modifier|*
name|ps
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|ps
operator|=
name|symbols
operator|+
name|ELF64_R_SYM
argument_list|(
name|rela
operator|.
name|r_info
argument_list|)
operator|-
literal|1
expr_stmt|;
name|s
operator|=
operator|*
name|ps
expr_stmt|;
comment|/* Canonicalize ELF section symbols.  FIXME: Why?  */
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|==
literal|0
condition|)
name|relent
operator|->
name|sym_ptr_ptr
operator|=
name|ps
expr_stmt|;
else|else
name|relent
operator|->
name|sym_ptr_ptr
operator|=
name|s
operator|->
name|section
operator|->
name|symbol_ptr_ptr
expr_stmt|;
block|}
name|relent
operator|->
name|addend
operator|=
name|rela
operator|.
name|r_addend
expr_stmt|;
name|r_type
operator|=
name|ELF64_R_TYPE_ID
argument_list|(
name|rela
operator|.
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_SPARC_OLO10
condition|)
block|{
name|relent
operator|->
name|howto
operator|=
name|_bfd_sparc_elf_info_to_howto_ptr
argument_list|(
name|R_SPARC_LO10
argument_list|)
expr_stmt|;
name|relent
index|[
literal|1
index|]
operator|.
name|address
operator|=
name|relent
operator|->
name|address
expr_stmt|;
name|relent
operator|++
expr_stmt|;
name|relent
operator|->
name|sym_ptr_ptr
operator|=
name|bfd_abs_section_ptr
operator|->
name|symbol_ptr_ptr
expr_stmt|;
name|relent
operator|->
name|addend
operator|=
name|ELF64_R_TYPE_DATA
argument_list|(
name|rela
operator|.
name|r_info
argument_list|)
expr_stmt|;
name|relent
operator|->
name|howto
operator|=
name|_bfd_sparc_elf_info_to_howto_ptr
argument_list|(
name|R_SPARC_13
argument_list|)
expr_stmt|;
block|}
else|else
name|relent
operator|->
name|howto
operator|=
name|_bfd_sparc_elf_info_to_howto_ptr
argument_list|(
name|r_type
argument_list|)
expr_stmt|;
block|}
name|canon_reloc_count
argument_list|(
name|asect
argument_list|)
operator|+=
name|relent
operator|-
name|relents
expr_stmt|;
if|if
condition|(
name|allocated
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|allocated
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
name|error_return
label|:
if|if
condition|(
name|allocated
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|allocated
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Read in and swap the external relocs.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf64_sparc_slurp_reloc_table
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|asect
parameter_list|,
name|asymbol
modifier|*
modifier|*
name|symbols
parameter_list|,
name|bfd_boolean
name|dynamic
parameter_list|)
block|{
name|struct
name|bfd_elf_section_data
modifier|*
specifier|const
name|d
init|=
name|elf_section_data
argument_list|(
name|asect
argument_list|)
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|rel_hdr
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|rel_hdr2
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
if|if
condition|(
name|asect
operator|->
name|relocation
operator|!=
name|NULL
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
operator|!
name|dynamic
condition|)
block|{
if|if
condition|(
operator|(
name|asect
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
operator|||
name|asect
operator|->
name|reloc_count
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
name|rel_hdr
operator|=
operator|&
name|d
operator|->
name|rel_hdr
expr_stmt|;
name|rel_hdr2
operator|=
name|d
operator|->
name|rel_hdr2
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|asect
operator|->
name|rel_filepos
operator|==
name|rel_hdr
operator|->
name|sh_offset
operator|||
operator|(
name|rel_hdr2
operator|&&
name|asect
operator|->
name|rel_filepos
operator|==
name|rel_hdr2
operator|->
name|sh_offset
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Note that ASECT->RELOC_COUNT tends not to be accurate in this 	 case because relocations against this section may use the 	 dynamic symbol table, and in that case bfd_section_from_shdr 	 in elf.c does not update the RELOC_COUNT.  */
if|if
condition|(
name|asect
operator|->
name|size
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
name|rel_hdr
operator|=
operator|&
name|d
operator|->
name|this_hdr
expr_stmt|;
name|asect
operator|->
name|reloc_count
operator|=
name|NUM_SHDR_ENTRIES
argument_list|(
name|rel_hdr
argument_list|)
expr_stmt|;
name|rel_hdr2
operator|=
name|NULL
expr_stmt|;
block|}
name|amt
operator|=
name|asect
operator|->
name|reloc_count
expr_stmt|;
name|amt
operator|*=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
expr_stmt|;
name|asect
operator|->
name|relocation
operator|=
operator|(
name|arelent
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|asect
operator|->
name|relocation
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* The elf64_sparc_slurp_one_reloc_table routine increments      canon_reloc_count.  */
name|canon_reloc_count
argument_list|(
name|asect
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|elf64_sparc_slurp_one_reloc_table
argument_list|(
name|abfd
argument_list|,
name|asect
argument_list|,
name|rel_hdr
argument_list|,
name|symbols
argument_list|,
name|dynamic
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|rel_hdr2
operator|&&
operator|!
name|elf64_sparc_slurp_one_reloc_table
argument_list|(
name|abfd
argument_list|,
name|asect
argument_list|,
name|rel_hdr2
argument_list|,
name|symbols
argument_list|,
name|dynamic
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Canonicalize the relocs.  */
end_comment

begin_function
specifier|static
name|long
name|elf64_sparc_canonicalize_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|sec_ptr
name|section
parameter_list|,
name|arelent
modifier|*
modifier|*
name|relptr
parameter_list|,
name|asymbol
modifier|*
modifier|*
name|symbols
parameter_list|)
block|{
name|arelent
modifier|*
name|tblptr
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|bed
operator|->
name|s
operator|->
name|slurp_reloc_table
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|symbols
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|tblptr
operator|=
name|section
operator|->
name|relocation
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|canon_reloc_count
argument_list|(
name|section
argument_list|)
condition|;
name|i
operator|++
control|)
operator|*
name|relptr
operator|++
operator|=
name|tblptr
operator|++
expr_stmt|;
operator|*
name|relptr
operator|=
name|NULL
expr_stmt|;
return|return
name|canon_reloc_count
argument_list|(
name|section
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Canonicalize the dynamic relocation entries.  Note that we return    the dynamic relocations as a single block, although they are    actually associated with particular sections; the interface, which    was designed for SunOS style shared libraries, expects that there    is only one set of dynamic relocs.  Any section that was actually    installed in the BFD, and has type SHT_REL or SHT_RELA, and uses    the dynamic symbol table, is considered to be a dynamic reloc    section.  */
end_comment

begin_function
specifier|static
name|long
name|elf64_sparc_canonicalize_dynamic_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|arelent
modifier|*
modifier|*
name|storage
parameter_list|,
name|asymbol
modifier|*
modifier|*
name|syms
parameter_list|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|long
name|ret
decl_stmt|;
if|if
condition|(
name|elf_dynsymtab
argument_list|(
name|abfd
argument_list|)
operator|==
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|ret
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_link
operator|==
name|elf_dynsymtab
argument_list|(
name|abfd
argument_list|)
operator|&&
operator|(
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_type
operator|==
name|SHT_RELA
operator|)
condition|)
block|{
name|arelent
modifier|*
name|p
decl_stmt|;
name|long
name|count
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|elf64_sparc_slurp_reloc_table
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|syms
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|count
operator|=
name|canon_reloc_count
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|p
operator|=
name|s
operator|->
name|relocation
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
operator|*
name|storage
operator|++
operator|=
name|p
operator|++
expr_stmt|;
name|ret
operator|+=
name|count
expr_stmt|;
block|}
block|}
operator|*
name|storage
operator|=
name|NULL
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Write out the relocs.  */
end_comment

begin_function
specifier|static
name|void
name|elf64_sparc_write_relocs
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|PTR
name|data
parameter_list|)
block|{
name|bfd_boolean
modifier|*
name|failedp
init|=
operator|(
name|bfd_boolean
operator|*
operator|)
name|data
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|rela_hdr
decl_stmt|;
name|bfd_vma
name|addr_offset
decl_stmt|;
name|Elf64_External_Rela
modifier|*
name|outbound_relocas
decl_stmt|,
modifier|*
name|src_rela
decl_stmt|;
name|unsigned
name|int
name|idx
decl_stmt|,
name|count
decl_stmt|;
name|asymbol
modifier|*
name|last_sym
init|=
literal|0
decl_stmt|;
name|int
name|last_sym_idx
init|=
literal|0
decl_stmt|;
comment|/* If we have already failed, don't do anything.  */
if|if
condition|(
operator|*
name|failedp
condition|)
return|return;
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
condition|)
return|return;
comment|/* The linker backend writes the relocs out itself, and sets the      reloc_count field to zero to inhibit writing them here.  Also,      sometimes the SEC_RELOC flag gets set even when there aren't any      relocs.  */
if|if
condition|(
name|sec
operator|->
name|reloc_count
operator|==
literal|0
condition|)
return|return;
comment|/* We can combine two relocs that refer to the same address      into R_SPARC_OLO10 if first one is R_SPARC_LO10 and the      latter is R_SPARC_13 with no associated symbol.  */
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|sec
operator|->
name|reloc_count
condition|;
name|idx
operator|++
control|)
block|{
name|bfd_vma
name|addr
decl_stmt|;
operator|++
name|count
expr_stmt|;
name|addr
operator|=
name|sec
operator|->
name|orelocation
index|[
name|idx
index|]
operator|->
name|address
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|orelocation
index|[
name|idx
index|]
operator|->
name|howto
operator|->
name|type
operator|==
name|R_SPARC_LO10
operator|&&
name|idx
operator|<
name|sec
operator|->
name|reloc_count
operator|-
literal|1
condition|)
block|{
name|arelent
modifier|*
name|r
init|=
name|sec
operator|->
name|orelocation
index|[
name|idx
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|r
operator|->
name|howto
operator|->
name|type
operator|==
name|R_SPARC_13
operator|&&
name|r
operator|->
name|address
operator|==
name|addr
operator|&&
name|bfd_is_abs_section
argument_list|(
operator|(
operator|*
name|r
operator|->
name|sym_ptr_ptr
operator|)
operator|->
name|section
argument_list|)
operator|&&
operator|(
operator|*
name|r
operator|->
name|sym_ptr_ptr
operator|)
operator|->
name|value
operator|==
literal|0
condition|)
operator|++
name|idx
expr_stmt|;
block|}
block|}
name|rela_hdr
operator|=
operator|&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|rel_hdr
expr_stmt|;
name|rela_hdr
operator|->
name|sh_size
operator|=
name|rela_hdr
operator|->
name|sh_entsize
operator|*
name|count
expr_stmt|;
name|rela_hdr
operator|->
name|contents
operator|=
operator|(
name|PTR
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|rela_hdr
operator|->
name|sh_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|rela_hdr
operator|->
name|contents
operator|==
name|NULL
condition|)
block|{
operator|*
name|failedp
operator|=
name|TRUE
expr_stmt|;
return|return;
block|}
comment|/* Figure out whether the relocations are RELA or REL relocations.  */
if|if
condition|(
name|rela_hdr
operator|->
name|sh_type
operator|!=
name|SHT_RELA
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* The address of an ELF reloc is section relative for an object      file, and absolute for an executable file or shared library.      The address of a BFD reloc is always section relative.  */
name|addr_offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
operator|(
name|EXEC_P
operator||
name|DYNAMIC
operator|)
operator|)
operator|!=
literal|0
condition|)
name|addr_offset
operator|=
name|sec
operator|->
name|vma
expr_stmt|;
comment|/* orelocation has the data, reloc_count has the count...  */
name|outbound_relocas
operator|=
operator|(
name|Elf64_External_Rela
operator|*
operator|)
name|rela_hdr
operator|->
name|contents
expr_stmt|;
name|src_rela
operator|=
name|outbound_relocas
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|sec
operator|->
name|reloc_count
condition|;
name|idx
operator|++
control|)
block|{
name|Elf_Internal_Rela
name|dst_rela
decl_stmt|;
name|arelent
modifier|*
name|ptr
decl_stmt|;
name|asymbol
modifier|*
name|sym
decl_stmt|;
name|int
name|n
decl_stmt|;
name|ptr
operator|=
name|sec
operator|->
name|orelocation
index|[
name|idx
index|]
expr_stmt|;
name|sym
operator|=
operator|*
name|ptr
operator|->
name|sym_ptr_ptr
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|last_sym
condition|)
name|n
operator|=
name|last_sym_idx
expr_stmt|;
elseif|else
if|if
condition|(
name|bfd_is_abs_section
argument_list|(
name|sym
operator|->
name|section
argument_list|)
operator|&&
name|sym
operator|->
name|value
operator|==
literal|0
condition|)
name|n
operator|=
name|STN_UNDEF
expr_stmt|;
else|else
block|{
name|last_sym
operator|=
name|sym
expr_stmt|;
name|n
operator|=
name|_bfd_elf_symbol_from_bfd_symbol
argument_list|(
name|abfd
argument_list|,
operator|&
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
operator|*
name|failedp
operator|=
name|TRUE
expr_stmt|;
return|return;
block|}
name|last_sym_idx
operator|=
name|n
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|ptr
operator|->
name|sym_ptr_ptr
operator|)
operator|->
name|the_bfd
operator|!=
name|NULL
operator|&&
operator|(
operator|*
name|ptr
operator|->
name|sym_ptr_ptr
operator|)
operator|->
name|the_bfd
operator|->
name|xvec
operator|!=
name|abfd
operator|->
name|xvec
operator|&&
operator|!
name|_bfd_elf_validate_reloc
argument_list|(
name|abfd
argument_list|,
name|ptr
argument_list|)
condition|)
block|{
operator|*
name|failedp
operator|=
name|TRUE
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ptr
operator|->
name|howto
operator|->
name|type
operator|==
name|R_SPARC_LO10
operator|&&
name|idx
operator|<
name|sec
operator|->
name|reloc_count
operator|-
literal|1
condition|)
block|{
name|arelent
modifier|*
name|r
init|=
name|sec
operator|->
name|orelocation
index|[
name|idx
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|r
operator|->
name|howto
operator|->
name|type
operator|==
name|R_SPARC_13
operator|&&
name|r
operator|->
name|address
operator|==
name|ptr
operator|->
name|address
operator|&&
name|bfd_is_abs_section
argument_list|(
operator|(
operator|*
name|r
operator|->
name|sym_ptr_ptr
operator|)
operator|->
name|section
argument_list|)
operator|&&
operator|(
operator|*
name|r
operator|->
name|sym_ptr_ptr
operator|)
operator|->
name|value
operator|==
literal|0
condition|)
block|{
name|idx
operator|++
expr_stmt|;
name|dst_rela
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|n
argument_list|,
name|ELF64_R_TYPE_INFO
argument_list|(
name|r
operator|->
name|addend
argument_list|,
name|R_SPARC_OLO10
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|dst_rela
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|n
argument_list|,
name|R_SPARC_LO10
argument_list|)
expr_stmt|;
block|}
else|else
name|dst_rela
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|n
argument_list|,
name|ptr
operator|->
name|howto
operator|->
name|type
argument_list|)
expr_stmt|;
name|dst_rela
operator|.
name|r_offset
operator|=
name|ptr
operator|->
name|address
operator|+
name|addr_offset
expr_stmt|;
name|dst_rela
operator|.
name|r_addend
operator|=
name|ptr
operator|->
name|addend
expr_stmt|;
name|bfd_elf64_swap_reloca_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|dst_rela
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src_rela
argument_list|)
expr_stmt|;
operator|++
name|src_rela
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Hook called by the linker routine which adds symbols from an object    file.  We use it for STT_REGISTER symbols.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf64_sparc_add_symbol_hook
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|namep
parameter_list|,
name|flagword
modifier|*
name|flagsp
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
modifier|*
name|secp
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd_vma
modifier|*
name|valp
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|stt_types
index|[]
init|=
block|{
literal|"NOTYPE"
block|,
literal|"OBJECT"
block|,
literal|"FUNCTION"
block|}
decl_stmt|;
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_REGISTER
condition|)
block|{
name|int
name|reg
decl_stmt|;
name|struct
name|_bfd_sparc_elf_app_reg
modifier|*
name|p
decl_stmt|;
name|reg
operator|=
operator|(
name|int
operator|)
name|sym
operator|->
name|st_value
expr_stmt|;
switch|switch
condition|(
name|reg
operator|&
operator|~
literal|1
condition|)
block|{
case|case
literal|2
case|:
name|reg
operator|-=
literal|2
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|reg
operator|-=
literal|4
expr_stmt|;
break|break;
default|default:
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: Only registers %%g[2367] can be declared using STT_REGISTER"
argument_list|)
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|info
operator|->
name|hash
operator|->
name|creator
operator|!=
name|abfd
operator|->
name|xvec
operator|||
operator|(
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* STT_REGISTER only works when linking an elf64_sparc object. 	     If STT_REGISTER comes from a dynamic object, don't put it into 	     the output bfd.  The dynamic linker will recheck it.  */
operator|*
name|namep
operator|=
name|NULL
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|p
operator|=
name|_bfd_sparc_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|app_regs
operator|+
name|reg
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|name
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|p
operator|->
name|name
argument_list|,
operator|*
name|namep
argument_list|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Register %%g%d used incompatibly: %s in %B, previously %s in %B"
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|p
operator|->
name|abfd
argument_list|,
operator|(
name|int
operator|)
name|sym
operator|->
name|st_value
argument_list|,
operator|*
operator|*
name|namep
condition|?
operator|*
name|namep
else|:
literal|"#scratch"
argument_list|,
operator|*
name|p
operator|->
name|name
condition|?
name|p
operator|->
name|name
else|:
literal|"#scratch"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|p
operator|->
name|name
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
operator|*
name|namep
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|bfd_link_hash_lookup
argument_list|(
name|info
operator|->
name|hash
argument_list|,
operator|*
name|namep
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|char
name|type
init|=
name|h
operator|->
name|type
decl_stmt|;
if|if
condition|(
name|type
operator|>
name|STT_FUNC
condition|)
name|type
operator|=
literal|0
expr_stmt|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Symbol `%s' has differing types: REGISTER in %B, previously %s in %B"
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|p
operator|->
name|abfd
argument_list|,
operator|*
name|namep
argument_list|,
name|stt_types
index|[
name|type
index|]
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|p
operator|->
name|name
operator|=
name|bfd_hash_allocate
argument_list|(
operator|&
name|info
operator|->
name|hash
operator|->
name|table
argument_list|,
name|strlen
argument_list|(
operator|*
name|namep
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|->
name|name
condition|)
return|return
name|FALSE
return|;
name|strcpy
argument_list|(
name|p
operator|->
name|name
argument_list|,
operator|*
name|namep
argument_list|)
expr_stmt|;
block|}
else|else
name|p
operator|->
name|name
operator|=
literal|""
expr_stmt|;
name|p
operator|->
name|bind
operator|=
name|ELF_ST_BIND
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
expr_stmt|;
name|p
operator|->
name|abfd
operator|=
name|abfd
expr_stmt|;
name|p
operator|->
name|shndx
operator|=
name|sym
operator|->
name|st_shndx
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|p
operator|->
name|bind
operator|==
name|STB_WEAK
operator|&&
name|ELF_ST_BIND
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STB_GLOBAL
condition|)
block|{
name|p
operator|->
name|bind
operator|=
name|STB_GLOBAL
expr_stmt|;
name|p
operator|->
name|abfd
operator|=
name|abfd
expr_stmt|;
block|}
block|}
operator|*
name|namep
operator|=
name|NULL
expr_stmt|;
return|return
name|TRUE
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|namep
operator|&&
operator|*
operator|*
name|namep
operator|&&
name|info
operator|->
name|hash
operator|->
name|creator
operator|==
name|abfd
operator|->
name|xvec
condition|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|_bfd_sparc_elf_app_reg
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|_bfd_sparc_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|app_regs
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
if|if
condition|(
name|p
operator|->
name|name
operator|!=
name|NULL
operator|&&
operator|!
name|strcmp
argument_list|(
name|p
operator|->
name|name
argument_list|,
operator|*
name|namep
argument_list|)
condition|)
block|{
name|unsigned
name|char
name|type
init|=
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|>
name|STT_FUNC
condition|)
name|type
operator|=
literal|0
expr_stmt|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Symbol `%s' has differing types: %s in %B, previously REGISTER in %B"
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|p
operator|->
name|abfd
argument_list|,
operator|*
name|namep
argument_list|,
name|stt_types
index|[
name|type
index|]
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* This function takes care of emitting STT_REGISTER symbols    which we cannot easily keep in the symbol hash table.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf64_sparc_output_arch_syms
parameter_list|(
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|PTR
name|finfo
parameter_list|,
name|bfd_boolean
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|PTR
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|Elf_Internal_Sym
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
parameter_list|)
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|struct
name|_bfd_sparc_elf_app_reg
modifier|*
name|app_regs
init|=
name|_bfd_sparc_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|app_regs
decl_stmt|;
name|Elf_Internal_Sym
name|sym
decl_stmt|;
comment|/* We arranged in size_dynamic_sections to put the STT_REGISTER entries      at the end of the dynlocal list, so they came at the end of the local      symbols in the symtab.  Except that they aren't STB_LOCAL, so we need      to back up symtab->sh_info.  */
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynlocal
condition|)
block|{
name|bfd
modifier|*
name|dynobj
init|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|dynsymsec
init|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynsym"
argument_list|)
decl_stmt|;
name|struct
name|elf_link_local_dynamic_entry
modifier|*
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynlocal
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next
control|)
if|if
condition|(
name|e
operator|->
name|input_indx
operator|==
operator|-
literal|1
condition|)
break|break;
if|if
condition|(
name|e
condition|)
block|{
name|elf_section_data
argument_list|(
name|dynsymsec
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_info
operator|=
name|e
operator|->
name|dynindx
expr_stmt|;
block|}
block|}
if|if
condition|(
name|info
operator|->
name|strip
operator|==
name|strip_all
condition|)
return|return
name|TRUE
return|;
for|for
control|(
name|reg
operator|=
literal|0
init|;
name|reg
operator|<
literal|4
condition|;
name|reg
operator|++
control|)
if|if
condition|(
name|app_regs
index|[
name|reg
index|]
operator|.
name|name
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|strip
operator|==
name|strip_some
operator|&&
name|bfd_hash_lookup
argument_list|(
name|info
operator|->
name|keep_hash
argument_list|,
name|app_regs
index|[
name|reg
index|]
operator|.
name|name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
operator|==
name|NULL
condition|)
continue|continue;
name|sym
operator|.
name|st_value
operator|=
name|reg
operator|<
literal|2
condition|?
name|reg
operator|+
literal|2
else|:
name|reg
operator|+
literal|4
expr_stmt|;
name|sym
operator|.
name|st_size
operator|=
literal|0
expr_stmt|;
name|sym
operator|.
name|st_other
operator|=
literal|0
expr_stmt|;
name|sym
operator|.
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|app_regs
index|[
name|reg
index|]
operator|.
name|bind
argument_list|,
name|STT_REGISTER
argument_list|)
expr_stmt|;
name|sym
operator|.
name|st_shndx
operator|=
name|app_regs
index|[
name|reg
index|]
operator|.
name|shndx
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|func
call|)
argument_list|(
name|finfo
argument_list|,
name|app_regs
index|[
name|reg
index|]
operator|.
name|name
argument_list|,
operator|&
name|sym
argument_list|,
name|sym
operator|.
name|st_shndx
operator|==
name|SHN_ABS
condition|?
name|bfd_abs_section_ptr
else|:
name|bfd_und_section_ptr
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|elf64_sparc_get_symbol_type
parameter_list|(
name|Elf_Internal_Sym
modifier|*
name|elf_sym
parameter_list|,
name|int
name|type
parameter_list|)
block|{
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|elf_sym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_REGISTER
condition|)
return|return
name|STT_REGISTER
return|;
else|else
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* A STB_GLOBAL,STT_REGISTER symbol should be BSF_GLOBAL    even in SHN_UNDEF section.  */
end_comment

begin_function
specifier|static
name|void
name|elf64_sparc_symbol_processing
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asymbol
modifier|*
name|asym
parameter_list|)
block|{
name|elf_symbol_type
modifier|*
name|elfsym
decl_stmt|;
name|elfsym
operator|=
operator|(
name|elf_symbol_type
operator|*
operator|)
name|asym
expr_stmt|;
if|if
condition|(
name|elfsym
operator|->
name|internal_elf_sym
operator|.
name|st_info
operator|==
name|ELF_ST_INFO
argument_list|(
name|STB_GLOBAL
argument_list|,
name|STT_REGISTER
argument_list|)
condition|)
block|{
name|asym
operator|->
name|flags
operator||=
name|BSF_GLOBAL
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Functions for dealing with the e_flags field.  */
end_comment

begin_comment
comment|/* Merge backend specific data from an object file to the output    object file when linking.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf64_sparc_merge_private_bfd_data
parameter_list|(
name|bfd
modifier|*
name|ibfd
parameter_list|,
name|bfd
modifier|*
name|obfd
parameter_list|)
block|{
name|bfd_boolean
name|error
decl_stmt|;
name|flagword
name|new_flags
decl_stmt|,
name|old_flags
decl_stmt|;
name|int
name|new_mm
decl_stmt|,
name|old_mm
decl_stmt|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|ibfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
operator|||
name|bfd_get_flavour
argument_list|(
name|obfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
return|return
name|TRUE
return|;
name|new_flags
operator|=
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
name|old_flags
operator|=
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
if|if
condition|(
operator|!
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
condition|)
comment|/* First call, no flags set */
block|{
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
operator|=
name|TRUE
expr_stmt|;
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|=
name|new_flags
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|new_flags
operator|==
name|old_flags
condition|)
comment|/* Compatible flags are ok */
empty_stmt|;
else|else
comment|/* Incompatible flags */
block|{
name|error
operator|=
name|FALSE
expr_stmt|;
define|#
directive|define
name|EF_SPARC_ISA_EXTENSIONS
define|\
value|(EF_SPARC_SUN_US1 | EF_SPARC_SUN_US3 | EF_SPARC_HAL_R1)
if|if
condition|(
operator|(
name|ibfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* We don't want dynamic objects memory ordering and 	     architecture to have any role. That's what dynamic linker 	     should do.  */
name|new_flags
operator|&=
operator|~
operator|(
name|EF_SPARCV9_MM
operator||
name|EF_SPARC_ISA_EXTENSIONS
operator|)
expr_stmt|;
name|new_flags
operator||=
operator|(
name|old_flags
operator|&
operator|(
name|EF_SPARCV9_MM
operator||
name|EF_SPARC_ISA_EXTENSIONS
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Choose the highest architecture requirements.  */
name|old_flags
operator||=
operator|(
name|new_flags
operator|&
name|EF_SPARC_ISA_EXTENSIONS
operator|)
expr_stmt|;
name|new_flags
operator||=
operator|(
name|old_flags
operator|&
name|EF_SPARC_ISA_EXTENSIONS
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|old_flags
operator|&
operator|(
name|EF_SPARC_SUN_US1
operator||
name|EF_SPARC_SUN_US3
operator|)
operator|)
operator|&&
operator|(
name|old_flags
operator|&
name|EF_SPARC_HAL_R1
operator|)
condition|)
block|{
name|error
operator|=
name|TRUE
expr_stmt|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: linking UltraSPARC specific with HAL specific code"
argument_list|)
argument_list|,
name|ibfd
argument_list|)
expr_stmt|;
block|}
comment|/* Choose the most restrictive memory ordering.  */
name|old_mm
operator|=
operator|(
name|old_flags
operator|&
name|EF_SPARCV9_MM
operator|)
expr_stmt|;
name|new_mm
operator|=
operator|(
name|new_flags
operator|&
name|EF_SPARCV9_MM
operator|)
expr_stmt|;
name|old_flags
operator|&=
operator|~
name|EF_SPARCV9_MM
expr_stmt|;
name|new_flags
operator|&=
operator|~
name|EF_SPARCV9_MM
expr_stmt|;
if|if
condition|(
name|new_mm
operator|<
name|old_mm
condition|)
name|old_mm
operator|=
name|new_mm
expr_stmt|;
name|old_flags
operator||=
name|old_mm
expr_stmt|;
name|new_flags
operator||=
name|old_mm
expr_stmt|;
block|}
comment|/* Warn about any other mismatches */
if|if
condition|(
name|new_flags
operator|!=
name|old_flags
condition|)
block|{
name|error
operator|=
name|TRUE
expr_stmt|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: uses different e_flags (0x%lx) fields than previous modules (0x%lx)"
argument_list|)
argument_list|,
name|ibfd
argument_list|,
operator|(
name|long
operator|)
name|new_flags
argument_list|,
operator|(
name|long
operator|)
name|old_flags
argument_list|)
expr_stmt|;
block|}
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|=
name|old_flags
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* MARCO: Set the correct entry size for the .stab section.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf64_sparc_fake_sections
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|Elf_Internal_Shdr
modifier|*
name|hdr
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".stab"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Even in the 64bit case the stab entries are only 12 bytes long.  */
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
operator|=
literal|12
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print a STT_REGISTER symbol to file FILE.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|elf64_sparc_print_symbol_all
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|PTR
name|filep
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|)
block|{
name|FILE
modifier|*
name|file
init|=
operator|(
name|FILE
operator|*
operator|)
name|filep
decl_stmt|;
name|int
name|reg
decl_stmt|,
name|type
decl_stmt|;
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
operator|(
operator|(
name|elf_symbol_type
operator|*
operator|)
name|symbol
operator|)
operator|->
name|internal_elf_sym
operator|.
name|st_info
argument_list|)
operator|!=
name|STT_REGISTER
condition|)
return|return
name|NULL
return|;
name|reg
operator|=
operator|(
operator|(
name|elf_symbol_type
operator|*
operator|)
name|symbol
operator|)
operator|->
name|internal_elf_sym
operator|.
name|st_value
expr_stmt|;
name|type
operator|=
name|symbol
operator|->
name|flags
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"REG_%c%c%11s%c%c    R"
argument_list|,
literal|"GOLI"
index|[
name|reg
operator|/
literal|8
index|]
argument_list|,
literal|'0'
operator|+
operator|(
name|reg
operator|&
literal|7
operator|)
argument_list|,
literal|""
argument_list|,
operator|(
operator|(
name|type
operator|&
name|BSF_LOCAL
operator|)
condition|?
operator|(
name|type
operator|&
name|BSF_GLOBAL
operator|)
condition|?
literal|'!'
else|:
literal|'l'
else|:
operator|(
name|type
operator|&
name|BSF_GLOBAL
operator|)
condition|?
literal|'g'
else|:
literal|' '
operator|)
argument_list|,
operator|(
name|type
operator|&
name|BSF_WEAK
operator|)
condition|?
literal|'w'
else|:
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbol
operator|->
name|name
operator|==
name|NULL
operator|||
name|symbol
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
literal|"#scratch"
return|;
else|else
return|return
name|symbol
operator|->
name|name
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|enum
name|elf_reloc_type_class
name|elf64_sparc_reloc_type_class
parameter_list|(
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rela
parameter_list|)
block|{
switch|switch
condition|(
operator|(
name|int
operator|)
name|ELF64_R_TYPE
argument_list|(
name|rela
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_SPARC_RELATIVE
case|:
return|return
name|reloc_class_relative
return|;
case|case
name|R_SPARC_JMP_SLOT
case|:
return|return
name|reloc_class_plt
return|;
case|case
name|R_SPARC_COPY
case|:
return|return
name|reloc_class_copy
return|;
default|default:
return|return
name|reloc_class_normal
return|;
block|}
block|}
end_function

begin_comment
comment|/* Relocations in the 64 bit SPARC ELF ABI are more complex than in    standard ELF, because R_SPARC_OLO10 has secondary addend in    ELF64_R_TYPE_DATA field.  This structure is used to redirect the    relocation handling routines.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|elf_size_info
name|elf64_sparc_size_info
init|=
block|{
sizeof|sizeof
argument_list|(
name|Elf64_External_Ehdr
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|Elf64_External_Phdr
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|Elf64_External_Shdr
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|Elf64_External_Rel
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|Elf64_External_Sym
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|Elf64_External_Dyn
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|Elf_External_Note
argument_list|)
block|,
literal|4
block|,
comment|/* hash-table entry size.  */
comment|/* Internal relocations per external relocations.      For link purposes we use just 1 internal per      1 external, for assembly and slurp symbol table      we use 2.  */
literal|1
block|,
literal|64
block|,
comment|/* arch_size.  */
literal|3
block|,
comment|/* log_file_align.  */
name|ELFCLASS64
block|,
name|EV_CURRENT
block|,
name|bfd_elf64_write_out_phdrs
block|,
name|bfd_elf64_write_shdrs_and_ehdr
block|,
name|elf64_sparc_write_relocs
block|,
name|bfd_elf64_swap_symbol_in
block|,
name|bfd_elf64_swap_symbol_out
block|,
name|elf64_sparc_slurp_reloc_table
block|,
name|bfd_elf64_slurp_symbol_table
block|,
name|bfd_elf64_swap_dyn_in
block|,
name|bfd_elf64_swap_dyn_out
block|,
name|bfd_elf64_swap_reloc_in
block|,
name|bfd_elf64_swap_reloc_out
block|,
name|bfd_elf64_swap_reloca_in
block|,
name|bfd_elf64_swap_reloca_out
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TARGET_BIG_SYM
value|bfd_elf64_sparc_vec
end_define

begin_define
define|#
directive|define
name|TARGET_BIG_NAME
value|"elf64-sparc"
end_define

begin_define
define|#
directive|define
name|ELF_ARCH
value|bfd_arch_sparc
end_define

begin_define
define|#
directive|define
name|ELF_MAXPAGESIZE
value|0x100000
end_define

begin_define
define|#
directive|define
name|ELF_COMMONPAGESIZE
value|0x2000
end_define

begin_comment
comment|/* This is the official ABI value.  */
end_comment

begin_define
define|#
directive|define
name|ELF_MACHINE_CODE
value|EM_SPARCV9
end_define

begin_comment
comment|/* This is the value that we used before the ABI was released.  */
end_comment

begin_define
define|#
directive|define
name|ELF_MACHINE_ALT1
value|EM_OLD_SPARCV9
end_define

begin_define
define|#
directive|define
name|elf_backend_reloc_type_class
define|\
value|elf64_sparc_reloc_type_class
end_define

begin_define
define|#
directive|define
name|bfd_elf64_get_reloc_upper_bound
define|\
value|elf64_sparc_get_reloc_upper_bound
end_define

begin_define
define|#
directive|define
name|bfd_elf64_get_dynamic_reloc_upper_bound
define|\
value|elf64_sparc_get_dynamic_reloc_upper_bound
end_define

begin_define
define|#
directive|define
name|bfd_elf64_canonicalize_reloc
define|\
value|elf64_sparc_canonicalize_reloc
end_define

begin_define
define|#
directive|define
name|bfd_elf64_canonicalize_dynamic_reloc
define|\
value|elf64_sparc_canonicalize_dynamic_reloc
end_define

begin_define
define|#
directive|define
name|elf_backend_add_symbol_hook
define|\
value|elf64_sparc_add_symbol_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_get_symbol_type
define|\
value|elf64_sparc_get_symbol_type
end_define

begin_define
define|#
directive|define
name|elf_backend_symbol_processing
define|\
value|elf64_sparc_symbol_processing
end_define

begin_define
define|#
directive|define
name|elf_backend_print_symbol_all
define|\
value|elf64_sparc_print_symbol_all
end_define

begin_define
define|#
directive|define
name|elf_backend_output_arch_syms
define|\
value|elf64_sparc_output_arch_syms
end_define

begin_define
define|#
directive|define
name|bfd_elf64_bfd_merge_private_bfd_data
define|\
value|elf64_sparc_merge_private_bfd_data
end_define

begin_define
define|#
directive|define
name|elf_backend_fake_sections
define|\
value|elf64_sparc_fake_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_size_info
define|\
value|elf64_sparc_size_info
end_define

begin_define
define|#
directive|define
name|elf_backend_plt_sym_val
define|\
value|_bfd_sparc_elf_plt_sym_val
end_define

begin_define
define|#
directive|define
name|bfd_elf64_bfd_link_hash_table_create
define|\
value|_bfd_sparc_elf_link_hash_table_create
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto
define|\
value|_bfd_sparc_elf_info_to_howto
end_define

begin_define
define|#
directive|define
name|elf_backend_copy_indirect_symbol
define|\
value|_bfd_sparc_elf_copy_indirect_symbol
end_define

begin_define
define|#
directive|define
name|bfd_elf64_bfd_reloc_type_lookup
define|\
value|_bfd_sparc_elf_reloc_type_lookup
end_define

begin_define
define|#
directive|define
name|bfd_elf64_bfd_reloc_name_lookup
define|\
value|_bfd_sparc_elf_reloc_name_lookup
end_define

begin_define
define|#
directive|define
name|bfd_elf64_bfd_relax_section
define|\
value|_bfd_sparc_elf_relax_section
end_define

begin_define
define|#
directive|define
name|bfd_elf64_new_section_hook
define|\
value|_bfd_sparc_elf_new_section_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_create_dynamic_sections
define|\
value|_bfd_sparc_elf_create_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_relocs_compatible
define|\
value|_bfd_elf_relocs_compatible
end_define

begin_define
define|#
directive|define
name|elf_backend_check_relocs
define|\
value|_bfd_sparc_elf_check_relocs
end_define

begin_define
define|#
directive|define
name|elf_backend_adjust_dynamic_symbol
define|\
value|_bfd_sparc_elf_adjust_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_omit_section_dynsym
define|\
value|_bfd_sparc_elf_omit_section_dynsym
end_define

begin_define
define|#
directive|define
name|elf_backend_size_dynamic_sections
define|\
value|_bfd_sparc_elf_size_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_relocate_section
define|\
value|_bfd_sparc_elf_relocate_section
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_symbol
define|\
value|_bfd_sparc_elf_finish_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_sections
define|\
value|_bfd_sparc_elf_finish_dynamic_sections
end_define

begin_define
define|#
directive|define
name|bfd_elf64_mkobject
define|\
value|_bfd_sparc_elf_mkobject
end_define

begin_define
define|#
directive|define
name|elf_backend_object_p
define|\
value|_bfd_sparc_elf_object_p
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_mark_hook
define|\
value|_bfd_sparc_elf_gc_mark_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_sweep_hook
define|\
value|_bfd_sparc_elf_gc_sweep_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_init_index_section
define|\
value|_bfd_elf_init_1_index_section
end_define

begin_define
define|#
directive|define
name|elf_backend_can_gc_sections
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_can_refcount
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_want_got_plt
value|0
end_define

begin_define
define|#
directive|define
name|elf_backend_plt_readonly
value|0
end_define

begin_define
define|#
directive|define
name|elf_backend_want_plt_sym
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_got_header_size
value|8
end_define

begin_define
define|#
directive|define
name|elf_backend_rela_normal
value|1
end_define

begin_comment
comment|/* Section 5.2.4 of the ABI specifies a 256-byte boundary for the table.  */
end_comment

begin_define
define|#
directive|define
name|elf_backend_plt_alignment
value|8
end_define

begin_include
include|#
directive|include
file|"elf64-target.h"
end_include

begin_comment
comment|/* FreeBSD support */
end_comment

begin_undef
undef|#
directive|undef
name|TARGET_BIG_SYM
end_undef

begin_define
define|#
directive|define
name|TARGET_BIG_SYM
value|bfd_elf64_sparc_freebsd_vec
end_define

begin_undef
undef|#
directive|undef
name|TARGET_BIG_NAME
end_undef

begin_define
define|#
directive|define
name|TARGET_BIG_NAME
value|"elf64-sparc-freebsd"
end_define

begin_undef
undef|#
directive|undef
name|ELF_OSABI
end_undef

begin_define
define|#
directive|define
name|ELF_OSABI
value|ELFOSABI_FREEBSD
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_post_process_headers
end_undef

begin_define
define|#
directive|define
name|elf_backend_post_process_headers
value|_bfd_elf_set_osabi
end_define

begin_undef
undef|#
directive|undef
name|elf64_bed
end_undef

begin_define
define|#
directive|define
name|elf64_bed
value|elf64_sparc_fbsd_bed
end_define

begin_include
include|#
directive|include
file|"elf64-target.h"
end_include

end_unit

