begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* SPARC-specific support for 64-bit ELF    Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002    Free Software Foundation, Inc.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"opcode/sparc.h"
end_include

begin_comment
comment|/* This is defined if one wants to build upward compatible binaries    with the original sparc64-elf toolchain.  The support is kept in for    now but is turned off by default.  dje 970930  */
end_comment

begin_comment
comment|/*#define SPARC64_OLD_RELOCS*/
end_comment

begin_include
include|#
directive|include
file|"elf/sparc.h"
end_include

begin_comment
comment|/* In case we're on a 32-bit machine, construct a 64-bit "-1" value.  */
end_comment

begin_define
define|#
directive|define
name|MINUS_ONE
value|(~ (bfd_vma) 0)
end_define

begin_decl_stmt
specifier|static
name|struct
name|bfd_link_hash_table
modifier|*
name|sparc64_elf_bfd_link_hash_table_create
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|init_insn_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|bfd_vma
operator|*
operator|,
name|bfd_vma
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
modifier|*
name|sparc64_elf_reloc_type_lookup
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd_reloc_code_real_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sparc64_elf_info_to_howto
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sparc64_elf_build_plt
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|unsigned
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|sparc64_elf_plt_entry_offset
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|sparc64_elf_plt_ptr_offset
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|sparc64_elf_check_relocs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|asection
operator|*
name|sec
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|sparc64_elf_adjust_dynamic_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|sparc64_elf_size_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sparc64_elf_get_symbol_type
name|PARAMS
argument_list|(
operator|(
name|Elf_Internal_Sym
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|sparc64_elf_add_symbol_hook
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
specifier|const
name|Elf_Internal_Sym
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|flagword
operator|*
operator|,
name|asection
operator|*
operator|*
operator|,
name|bfd_vma
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|sparc64_elf_output_arch_syms
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|PTR
operator|,
name|boolean
argument_list|(
operator|*
argument_list|)
argument_list|(
name|PTR
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|Elf_Internal_Sym
operator|*
argument_list|,
name|asection
operator|*
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sparc64_elf_symbol_processing
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|sparc64_elf_merge_private_bfd_data
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|sparc64_elf_fake_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf32_Internal_Shdr
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|sparc64_elf_print_symbol_all
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|asymbol
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|sparc64_elf_relax_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|boolean
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|sparc64_elf_relocate_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|,
name|asection
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|sparc64_elf_finish_dynamic_symbol
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|sparc64_elf_finish_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|sparc64_elf_object_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|sparc64_elf_get_reloc_upper_bound
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|sparc64_elf_get_dynamic_reloc_upper_bound
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|sparc64_elf_slurp_one_reloc_table
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|Elf_Internal_Shdr
operator|*
operator|,
name|asymbol
operator|*
operator|*
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|sparc64_elf_slurp_reloc_table
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|asymbol
operator|*
operator|*
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|sparc64_elf_canonicalize_dynamic_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|*
operator|,
name|asymbol
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sparc64_elf_write_relocs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|elf_reloc_type_class
name|sparc64_elf_reloc_type_class
name|PARAMS
argument_list|(
operator|(
specifier|const
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* The relocation "howto" table.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|sparc_elf_notsup_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|sparc_elf_wdisp16_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|sparc_elf_hix22_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|sparc_elf_lox10_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|sparc64_elf_howto_table
index|[]
init|=
block|{
name|HOWTO
argument_list|(
name|R_SPARC_NONE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_NONE"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x00000000
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_8
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_8"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x000000ff
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_16
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_16"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x0000ffff
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_32
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_32"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_DISP8
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_DISP8"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x000000ff
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_DISP16
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_DISP16"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x0000ffff
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_DISP32
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_DISP32"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_WDISP30
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|30
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_WDISP30"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x3fffffff
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_WDISP22
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|22
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_WDISP22"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x003fffff
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_HI22
argument_list|,
literal|10
argument_list|,
literal|2
argument_list|,
literal|22
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_HI22"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x003fffff
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_22
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|22
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_22"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x003fffff
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_13
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|13
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_13"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x00001fff
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_LO10
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_LO10"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x000003ff
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_GOT10
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_GOT10"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x000003ff
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_GOT13
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|13
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_GOT13"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x00001fff
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_GOT22
argument_list|,
literal|10
argument_list|,
literal|2
argument_list|,
literal|22
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_GOT22"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x003fffff
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_PC10
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_PC10"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x000003ff
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_PC22
argument_list|,
literal|10
argument_list|,
literal|2
argument_list|,
literal|22
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_PC22"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x003fffff
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_WPLT30
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|30
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_WPLT30"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x3fffffff
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_COPY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|00
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_COPY"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x00000000
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_GLOB_DAT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|00
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_GLOB_DAT"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x00000000
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_JMP_SLOT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|00
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_JMP_SLOT"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x00000000
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_RELATIVE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|00
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_RELATIVE"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x00000000
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_UA32
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_UA32"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
name|true
argument_list|)
block|,
ifndef|#
directive|ifndef
name|SPARC64_OLD_RELOCS
name|HOWTO
argument_list|(
name|R_SPARC_PLT32
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_PLT32"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
name|true
argument_list|)
block|,
comment|/* These aren't implemented yet.  */
name|HOWTO
argument_list|(
name|R_SPARC_HIPLT22
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|00
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|sparc_elf_notsup_reloc
argument_list|,
literal|"R_SPARC_HIPLT22"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x00000000
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_LOPLT10
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|00
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|sparc_elf_notsup_reloc
argument_list|,
literal|"R_SPARC_LOPLT10"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x00000000
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_PCPLT32
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|00
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|sparc_elf_notsup_reloc
argument_list|,
literal|"R_SPARC_PCPLT32"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x00000000
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_PCPLT22
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|00
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|sparc_elf_notsup_reloc
argument_list|,
literal|"R_SPARC_PCPLT22"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x00000000
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_PCPLT10
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|00
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|sparc_elf_notsup_reloc
argument_list|,
literal|"R_SPARC_PCPLT10"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x00000000
argument_list|,
name|true
argument_list|)
block|,
endif|#
directive|endif
name|HOWTO
argument_list|(
name|R_SPARC_10
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_10"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x000003ff
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_11
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|11
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_11"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x000007ff
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_64
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|,
literal|64
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_64"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|MINUS_ONE
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_OLO10
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|13
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
name|sparc_elf_notsup_reloc
argument_list|,
literal|"R_SPARC_OLO10"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x00001fff
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_HH22
argument_list|,
literal|42
argument_list|,
literal|2
argument_list|,
literal|22
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_unsigned
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_HH22"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x003fffff
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_HM10
argument_list|,
literal|32
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_HM10"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x000003ff
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_LM22
argument_list|,
literal|10
argument_list|,
literal|2
argument_list|,
literal|22
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_LM22"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x003fffff
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_PC_HH22
argument_list|,
literal|42
argument_list|,
literal|2
argument_list|,
literal|22
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_unsigned
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_PC_HH22"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x003fffff
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_PC_HM10
argument_list|,
literal|32
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_PC_HM10"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x000003ff
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_PC_LM22
argument_list|,
literal|10
argument_list|,
literal|2
argument_list|,
literal|22
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_PC_LM22"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x003fffff
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_WDISP16
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|16
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
name|sparc_elf_wdisp16_reloc
argument_list|,
literal|"R_SPARC_WDISP16"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x00000000
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_WDISP19
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|19
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_WDISP19"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x0007ffff
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_UNUSED_42
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_UNUSED_42"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x00000000
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_7
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|7
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_7"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x0000007f
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_5
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|5
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_5"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x0000001f
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_6
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|6
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_6"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x0000003f
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_DISP64
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|,
literal|64
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_DISP64"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|MINUS_ONE
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_PLT64
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|,
literal|64
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_PLT64"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|MINUS_ONE
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_HIX22
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|sparc_elf_hix22_reloc
argument_list|,
literal|"R_SPARC_HIX22"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|MINUS_ONE
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_LOX10
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|sparc_elf_lox10_reloc
argument_list|,
literal|"R_SPARC_LOX10"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|MINUS_ONE
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_H44
argument_list|,
literal|22
argument_list|,
literal|2
argument_list|,
literal|22
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_unsigned
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_H44"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x003fffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_M44
argument_list|,
literal|12
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_M44"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x000003ff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_L44
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|13
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_L44"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x00000fff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_REGISTER
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|sparc_elf_notsup_reloc
argument_list|,
literal|"R_SPARC_REGISTER"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|MINUS_ONE
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_UA64
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|,
literal|64
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_UA64"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|MINUS_ONE
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
argument|R_SPARC_UA16
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
argument|false
argument_list|,
literal|0
argument_list|,
argument|complain_overflow_bitfield
argument_list|,
argument|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_UA16"
argument_list|,
argument|false
argument_list|,
literal|0
argument_list|,
literal|0x0000ffff
argument_list|,
argument|true
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|elf_reloc_map
block|{
name|bfd_reloc_code_real_type
name|bfd_reloc_val
decl_stmt|;
name|unsigned
name|char
name|elf_reloc_val
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|elf_reloc_map
name|sparc_reloc_map
index|[]
init|=
block|{
block|{
name|BFD_RELOC_NONE
block|,
name|R_SPARC_NONE
block|, }
block|,
block|{
name|BFD_RELOC_16
block|,
name|R_SPARC_16
block|, }
block|,
block|{
name|BFD_RELOC_16_PCREL
block|,
name|R_SPARC_DISP16
block|}
block|,
block|{
name|BFD_RELOC_8
block|,
name|R_SPARC_8
block|}
block|,
block|{
name|BFD_RELOC_8_PCREL
block|,
name|R_SPARC_DISP8
block|}
block|,
block|{
name|BFD_RELOC_CTOR
block|,
name|R_SPARC_64
block|}
block|,
block|{
name|BFD_RELOC_32
block|,
name|R_SPARC_32
block|}
block|,
block|{
name|BFD_RELOC_32_PCREL
block|,
name|R_SPARC_DISP32
block|}
block|,
block|{
name|BFD_RELOC_HI22
block|,
name|R_SPARC_HI22
block|}
block|,
block|{
name|BFD_RELOC_LO10
block|,
name|R_SPARC_LO10
block|, }
block|,
block|{
name|BFD_RELOC_32_PCREL_S2
block|,
name|R_SPARC_WDISP30
block|}
block|,
block|{
name|BFD_RELOC_64_PCREL
block|,
name|R_SPARC_DISP64
block|}
block|,
block|{
name|BFD_RELOC_SPARC22
block|,
name|R_SPARC_22
block|}
block|,
block|{
name|BFD_RELOC_SPARC13
block|,
name|R_SPARC_13
block|}
block|,
block|{
name|BFD_RELOC_SPARC_GOT10
block|,
name|R_SPARC_GOT10
block|}
block|,
block|{
name|BFD_RELOC_SPARC_GOT13
block|,
name|R_SPARC_GOT13
block|}
block|,
block|{
name|BFD_RELOC_SPARC_GOT22
block|,
name|R_SPARC_GOT22
block|}
block|,
block|{
name|BFD_RELOC_SPARC_PC10
block|,
name|R_SPARC_PC10
block|}
block|,
block|{
name|BFD_RELOC_SPARC_PC22
block|,
name|R_SPARC_PC22
block|}
block|,
block|{
name|BFD_RELOC_SPARC_WPLT30
block|,
name|R_SPARC_WPLT30
block|}
block|,
block|{
name|BFD_RELOC_SPARC_COPY
block|,
name|R_SPARC_COPY
block|}
block|,
block|{
name|BFD_RELOC_SPARC_GLOB_DAT
block|,
name|R_SPARC_GLOB_DAT
block|}
block|,
block|{
name|BFD_RELOC_SPARC_JMP_SLOT
block|,
name|R_SPARC_JMP_SLOT
block|}
block|,
block|{
name|BFD_RELOC_SPARC_RELATIVE
block|,
name|R_SPARC_RELATIVE
block|}
block|,
block|{
name|BFD_RELOC_SPARC_WDISP22
block|,
name|R_SPARC_WDISP22
block|}
block|,
block|{
name|BFD_RELOC_SPARC_UA16
block|,
name|R_SPARC_UA16
block|}
block|,
block|{
name|BFD_RELOC_SPARC_UA32
block|,
name|R_SPARC_UA32
block|}
block|,
block|{
name|BFD_RELOC_SPARC_UA64
block|,
name|R_SPARC_UA64
block|}
block|,
block|{
name|BFD_RELOC_SPARC_10
block|,
name|R_SPARC_10
block|}
block|,
block|{
name|BFD_RELOC_SPARC_11
block|,
name|R_SPARC_11
block|}
block|,
block|{
name|BFD_RELOC_SPARC_64
block|,
name|R_SPARC_64
block|}
block|,
block|{
name|BFD_RELOC_SPARC_OLO10
block|,
name|R_SPARC_OLO10
block|}
block|,
block|{
name|BFD_RELOC_SPARC_HH22
block|,
name|R_SPARC_HH22
block|}
block|,
block|{
name|BFD_RELOC_SPARC_HM10
block|,
name|R_SPARC_HM10
block|}
block|,
block|{
name|BFD_RELOC_SPARC_LM22
block|,
name|R_SPARC_LM22
block|}
block|,
block|{
name|BFD_RELOC_SPARC_PC_HH22
block|,
name|R_SPARC_PC_HH22
block|}
block|,
block|{
name|BFD_RELOC_SPARC_PC_HM10
block|,
name|R_SPARC_PC_HM10
block|}
block|,
block|{
name|BFD_RELOC_SPARC_PC_LM22
block|,
name|R_SPARC_PC_LM22
block|}
block|,
block|{
name|BFD_RELOC_SPARC_WDISP16
block|,
name|R_SPARC_WDISP16
block|}
block|,
block|{
name|BFD_RELOC_SPARC_WDISP19
block|,
name|R_SPARC_WDISP19
block|}
block|,
block|{
name|BFD_RELOC_SPARC_7
block|,
name|R_SPARC_7
block|}
block|,
block|{
name|BFD_RELOC_SPARC_5
block|,
name|R_SPARC_5
block|}
block|,
block|{
name|BFD_RELOC_SPARC_6
block|,
name|R_SPARC_6
block|}
block|,
block|{
name|BFD_RELOC_SPARC_DISP64
block|,
name|R_SPARC_DISP64
block|}
block|,
ifndef|#
directive|ifndef
name|SPARC64_OLD_RELOCS
block|{
name|BFD_RELOC_SPARC_PLT32
block|,
name|R_SPARC_PLT32
block|}
block|,
endif|#
directive|endif
block|{
name|BFD_RELOC_SPARC_PLT64
block|,
name|R_SPARC_PLT64
block|}
block|,
block|{
name|BFD_RELOC_SPARC_HIX22
block|,
name|R_SPARC_HIX22
block|}
block|,
block|{
name|BFD_RELOC_SPARC_LOX10
block|,
name|R_SPARC_LOX10
block|}
block|,
block|{
name|BFD_RELOC_SPARC_H44
block|,
name|R_SPARC_H44
block|}
block|,
block|{
name|BFD_RELOC_SPARC_M44
block|,
name|R_SPARC_M44
block|}
block|,
block|{
name|BFD_RELOC_SPARC_L44
block|,
name|R_SPARC_L44
block|}
block|,
block|{
name|BFD_RELOC_SPARC_REGISTER
block|,
name|R_SPARC_REGISTER
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|sparc64_elf_reloc_type_lookup
parameter_list|(
name|abfd
parameter_list|,
name|code
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|sparc_reloc_map
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|elf_reloc_map
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sparc_reloc_map
index|[
name|i
index|]
operator|.
name|bfd_reloc_val
operator|==
name|code
condition|)
return|return
operator|&
name|sparc64_elf_howto_table
index|[
operator|(
name|int
operator|)
name|sparc_reloc_map
index|[
name|i
index|]
operator|.
name|elf_reloc_val
index|]
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sparc64_elf_info_to_howto
parameter_list|(
name|abfd
parameter_list|,
name|cache_ptr
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|arelent
modifier|*
name|cache_ptr
decl_stmt|;
name|Elf64_Internal_Rela
modifier|*
name|dst
decl_stmt|;
block|{
name|BFD_ASSERT
argument_list|(
name|ELF64_R_TYPE_ID
argument_list|(
name|dst
operator|->
name|r_info
argument_list|)
operator|<
operator|(
name|unsigned
name|int
operator|)
name|R_SPARC_max_std
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|howto
operator|=
operator|&
name|sparc64_elf_howto_table
index|[
name|ELF64_R_TYPE_ID
argument_list|(
name|dst
operator|->
name|r_info
argument_list|)
index|]
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Due to the way how we handle R_SPARC_OLO10, each entry in a SHT_RELA    section can represent up to two relocs, we must tell the user to allocate    more space.  */
end_comment

begin_function
specifier|static
name|long
name|sparc64_elf_get_reloc_upper_bound
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
block|{
return|return
operator|(
name|sec
operator|->
name|reloc_count
operator|*
literal|2
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|sparc64_elf_get_dynamic_reloc_upper_bound
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
return|return
name|_bfd_elf_get_dynamic_reloc_upper_bound
argument_list|(
name|abfd
argument_list|)
operator|*
literal|2
return|;
block|}
end_function

begin_comment
comment|/* Read  relocations for ASECT from REL_HDR.  There are RELOC_COUNT of    them.  We cannot use generic elf routines for this,  because R_SPARC_OLO10    has secondary addend in ELF64_R_TYPE_DATA.  We handle it as two relocations    for the same location,  R_SPARC_LO10 and R_SPARC_13.  */
end_comment

begin_function
specifier|static
name|boolean
name|sparc64_elf_slurp_one_reloc_table
parameter_list|(
name|abfd
parameter_list|,
name|asect
parameter_list|,
name|rel_hdr
parameter_list|,
name|symbols
parameter_list|,
name|dynamic
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|asect
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|rel_hdr
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
name|boolean
name|dynamic
decl_stmt|;
block|{
name|PTR
name|allocated
init|=
name|NULL
decl_stmt|;
name|bfd_byte
modifier|*
name|native_relocs
decl_stmt|;
name|arelent
modifier|*
name|relent
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|int
name|entsize
decl_stmt|;
name|bfd_size_type
name|count
decl_stmt|;
name|arelent
modifier|*
name|relents
decl_stmt|;
name|allocated
operator|=
operator|(
name|PTR
operator|)
name|bfd_malloc
argument_list|(
name|rel_hdr
operator|->
name|sh_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|allocated
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|rel_hdr
operator|->
name|sh_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bread
argument_list|(
name|allocated
argument_list|,
name|rel_hdr
operator|->
name|sh_size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|rel_hdr
operator|->
name|sh_size
condition|)
goto|goto
name|error_return
goto|;
name|native_relocs
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|allocated
expr_stmt|;
name|relents
operator|=
name|asect
operator|->
name|relocation
operator|+
name|asect
operator|->
name|reloc_count
expr_stmt|;
name|entsize
operator|=
name|rel_hdr
operator|->
name|sh_entsize
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|entsize
operator|==
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
argument_list|)
expr_stmt|;
name|count
operator|=
name|rel_hdr
operator|->
name|sh_size
operator|/
name|entsize
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|relent
operator|=
name|relents
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|relent
operator|++
operator|,
name|native_relocs
operator|+=
name|entsize
control|)
block|{
name|Elf_Internal_Rela
name|rela
decl_stmt|;
name|bfd_elf64_swap_reloca_in
argument_list|(
name|abfd
argument_list|,
operator|(
name|Elf64_External_Rela
operator|*
operator|)
name|native_relocs
argument_list|,
operator|&
name|rela
argument_list|)
expr_stmt|;
comment|/* The address of an ELF reloc is section relative for an object 	 file, and absolute for an executable file or shared library. 	 The address of a normal BFD reloc is always section relative, 	 and the address of a dynamic reloc is absolute..  */
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
operator|(
name|EXEC_P
operator||
name|DYNAMIC
operator|)
operator|)
operator|==
literal|0
operator|||
name|dynamic
condition|)
name|relent
operator|->
name|address
operator|=
name|rela
operator|.
name|r_offset
expr_stmt|;
else|else
name|relent
operator|->
name|address
operator|=
name|rela
operator|.
name|r_offset
operator|-
name|asect
operator|->
name|vma
expr_stmt|;
if|if
condition|(
name|ELF64_R_SYM
argument_list|(
name|rela
operator|.
name|r_info
argument_list|)
operator|==
literal|0
condition|)
name|relent
operator|->
name|sym_ptr_ptr
operator|=
name|bfd_abs_section_ptr
operator|->
name|symbol_ptr_ptr
expr_stmt|;
else|else
block|{
name|asymbol
modifier|*
modifier|*
name|ps
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|ps
operator|=
name|symbols
operator|+
name|ELF64_R_SYM
argument_list|(
name|rela
operator|.
name|r_info
argument_list|)
operator|-
literal|1
expr_stmt|;
name|s
operator|=
operator|*
name|ps
expr_stmt|;
comment|/* Canonicalize ELF section symbols.  FIXME: Why?  */
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|==
literal|0
condition|)
name|relent
operator|->
name|sym_ptr_ptr
operator|=
name|ps
expr_stmt|;
else|else
name|relent
operator|->
name|sym_ptr_ptr
operator|=
name|s
operator|->
name|section
operator|->
name|symbol_ptr_ptr
expr_stmt|;
block|}
name|relent
operator|->
name|addend
operator|=
name|rela
operator|.
name|r_addend
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|ELF64_R_TYPE_ID
argument_list|(
name|rela
operator|.
name|r_info
argument_list|)
operator|<
operator|(
name|unsigned
name|int
operator|)
name|R_SPARC_max_std
argument_list|)
expr_stmt|;
if|if
condition|(
name|ELF64_R_TYPE_ID
argument_list|(
name|rela
operator|.
name|r_info
argument_list|)
operator|==
name|R_SPARC_OLO10
condition|)
block|{
name|relent
operator|->
name|howto
operator|=
operator|&
name|sparc64_elf_howto_table
index|[
name|R_SPARC_LO10
index|]
expr_stmt|;
name|relent
index|[
literal|1
index|]
operator|.
name|address
operator|=
name|relent
operator|->
name|address
expr_stmt|;
name|relent
operator|++
expr_stmt|;
name|relent
operator|->
name|sym_ptr_ptr
operator|=
name|bfd_abs_section_ptr
operator|->
name|symbol_ptr_ptr
expr_stmt|;
name|relent
operator|->
name|addend
operator|=
name|ELF64_R_TYPE_DATA
argument_list|(
name|rela
operator|.
name|r_info
argument_list|)
expr_stmt|;
name|relent
operator|->
name|howto
operator|=
operator|&
name|sparc64_elf_howto_table
index|[
name|R_SPARC_13
index|]
expr_stmt|;
block|}
else|else
name|relent
operator|->
name|howto
operator|=
operator|&
name|sparc64_elf_howto_table
index|[
name|ELF64_R_TYPE_ID
argument_list|(
name|rela
operator|.
name|r_info
argument_list|)
index|]
expr_stmt|;
block|}
name|asect
operator|->
name|reloc_count
operator|+=
name|relent
operator|-
name|relents
expr_stmt|;
if|if
condition|(
name|allocated
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|allocated
argument_list|)
expr_stmt|;
return|return
name|true
return|;
name|error_return
label|:
if|if
condition|(
name|allocated
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|allocated
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Read in and swap the external relocs.  */
end_comment

begin_function
specifier|static
name|boolean
name|sparc64_elf_slurp_reloc_table
parameter_list|(
name|abfd
parameter_list|,
name|asect
parameter_list|,
name|symbols
parameter_list|,
name|dynamic
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|asect
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
name|boolean
name|dynamic
decl_stmt|;
block|{
name|struct
name|bfd_elf_section_data
modifier|*
specifier|const
name|d
init|=
name|elf_section_data
argument_list|(
name|asect
argument_list|)
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|rel_hdr
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|rel_hdr2
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
if|if
condition|(
name|asect
operator|->
name|relocation
operator|!=
name|NULL
condition|)
return|return
name|true
return|;
if|if
condition|(
operator|!
name|dynamic
condition|)
block|{
if|if
condition|(
operator|(
name|asect
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
operator|||
name|asect
operator|->
name|reloc_count
operator|==
literal|0
condition|)
return|return
name|true
return|;
name|rel_hdr
operator|=
operator|&
name|d
operator|->
name|rel_hdr
expr_stmt|;
name|rel_hdr2
operator|=
name|d
operator|->
name|rel_hdr2
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|asect
operator|->
name|rel_filepos
operator|==
name|rel_hdr
operator|->
name|sh_offset
operator|||
operator|(
name|rel_hdr2
operator|&&
name|asect
operator|->
name|rel_filepos
operator|==
name|rel_hdr2
operator|->
name|sh_offset
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Note that ASECT->RELOC_COUNT tends not to be accurate in this 	 case because relocations against this section may use the 	 dynamic symbol table, and in that case bfd_section_from_shdr 	 in elf.c does not update the RELOC_COUNT.  */
if|if
condition|(
name|asect
operator|->
name|_raw_size
operator|==
literal|0
condition|)
return|return
name|true
return|;
name|rel_hdr
operator|=
operator|&
name|d
operator|->
name|this_hdr
expr_stmt|;
name|asect
operator|->
name|reloc_count
operator|=
name|NUM_SHDR_ENTRIES
argument_list|(
name|rel_hdr
argument_list|)
expr_stmt|;
name|rel_hdr2
operator|=
name|NULL
expr_stmt|;
block|}
name|amt
operator|=
name|asect
operator|->
name|reloc_count
expr_stmt|;
name|amt
operator|*=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
expr_stmt|;
name|asect
operator|->
name|relocation
operator|=
operator|(
name|arelent
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|asect
operator|->
name|relocation
operator|==
name|NULL
condition|)
return|return
name|false
return|;
comment|/* The sparc64_elf_slurp_one_reloc_table routine increments reloc_count.  */
name|asect
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|sparc64_elf_slurp_one_reloc_table
argument_list|(
name|abfd
argument_list|,
name|asect
argument_list|,
name|rel_hdr
argument_list|,
name|symbols
argument_list|,
name|dynamic
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|rel_hdr2
operator|&&
operator|!
name|sparc64_elf_slurp_one_reloc_table
argument_list|(
name|abfd
argument_list|,
name|asect
argument_list|,
name|rel_hdr2
argument_list|,
name|symbols
argument_list|,
name|dynamic
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Canonicalize the dynamic relocation entries.  Note that we return    the dynamic relocations as a single block, although they are    actually associated with particular sections; the interface, which    was designed for SunOS style shared libraries, expects that there    is only one set of dynamic relocs.  Any section that was actually    installed in the BFD, and has type SHT_REL or SHT_RELA, and uses    the dynamic symbol table, is considered to be a dynamic reloc    section.  */
end_comment

begin_function
specifier|static
name|long
name|sparc64_elf_canonicalize_dynamic_reloc
parameter_list|(
name|abfd
parameter_list|,
name|storage
parameter_list|,
name|syms
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|storage
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|syms
decl_stmt|;
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|long
name|ret
decl_stmt|;
if|if
condition|(
name|elf_dynsymtab
argument_list|(
name|abfd
argument_list|)
operator|==
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|ret
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_link
operator|==
name|elf_dynsymtab
argument_list|(
name|abfd
argument_list|)
operator|&&
operator|(
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_type
operator|==
name|SHT_RELA
operator|)
condition|)
block|{
name|arelent
modifier|*
name|p
decl_stmt|;
name|long
name|count
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|sparc64_elf_slurp_reloc_table
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|syms
argument_list|,
name|true
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|count
operator|=
name|s
operator|->
name|reloc_count
expr_stmt|;
name|p
operator|=
name|s
operator|->
name|relocation
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
operator|*
name|storage
operator|++
operator|=
name|p
operator|++
expr_stmt|;
name|ret
operator|+=
name|count
expr_stmt|;
block|}
block|}
operator|*
name|storage
operator|=
name|NULL
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Write out the relocs.  */
end_comment

begin_function
specifier|static
name|void
name|sparc64_elf_write_relocs
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|data
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
name|boolean
modifier|*
name|failedp
init|=
operator|(
name|boolean
operator|*
operator|)
name|data
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|rela_hdr
decl_stmt|;
name|Elf64_External_Rela
modifier|*
name|outbound_relocas
decl_stmt|,
modifier|*
name|src_rela
decl_stmt|;
name|unsigned
name|int
name|idx
decl_stmt|,
name|count
decl_stmt|;
name|asymbol
modifier|*
name|last_sym
init|=
literal|0
decl_stmt|;
name|int
name|last_sym_idx
init|=
literal|0
decl_stmt|;
comment|/* If we have already failed, don't do anything.  */
if|if
condition|(
operator|*
name|failedp
condition|)
return|return;
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
condition|)
return|return;
comment|/* The linker backend writes the relocs out itself, and sets the      reloc_count field to zero to inhibit writing them here.  Also,      sometimes the SEC_RELOC flag gets set even when there aren't any      relocs.  */
if|if
condition|(
name|sec
operator|->
name|reloc_count
operator|==
literal|0
condition|)
return|return;
comment|/* We can combine two relocs that refer to the same address      into R_SPARC_OLO10 if first one is R_SPARC_LO10 and the      latter is R_SPARC_13 with no associated symbol.  */
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|sec
operator|->
name|reloc_count
condition|;
name|idx
operator|++
control|)
block|{
name|bfd_vma
name|addr
decl_stmt|;
operator|++
name|count
expr_stmt|;
name|addr
operator|=
name|sec
operator|->
name|orelocation
index|[
name|idx
index|]
operator|->
name|address
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|orelocation
index|[
name|idx
index|]
operator|->
name|howto
operator|->
name|type
operator|==
name|R_SPARC_LO10
operator|&&
name|idx
operator|<
name|sec
operator|->
name|reloc_count
operator|-
literal|1
condition|)
block|{
name|arelent
modifier|*
name|r
init|=
name|sec
operator|->
name|orelocation
index|[
name|idx
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|r
operator|->
name|howto
operator|->
name|type
operator|==
name|R_SPARC_13
operator|&&
name|r
operator|->
name|address
operator|==
name|addr
operator|&&
name|bfd_is_abs_section
argument_list|(
operator|(
operator|*
name|r
operator|->
name|sym_ptr_ptr
operator|)
operator|->
name|section
argument_list|)
operator|&&
operator|(
operator|*
name|r
operator|->
name|sym_ptr_ptr
operator|)
operator|->
name|value
operator|==
literal|0
condition|)
operator|++
name|idx
expr_stmt|;
block|}
block|}
name|rela_hdr
operator|=
operator|&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|rel_hdr
expr_stmt|;
name|rela_hdr
operator|->
name|sh_size
operator|=
name|rela_hdr
operator|->
name|sh_entsize
operator|*
name|count
expr_stmt|;
name|rela_hdr
operator|->
name|contents
operator|=
operator|(
name|PTR
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|rela_hdr
operator|->
name|sh_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|rela_hdr
operator|->
name|contents
operator|==
name|NULL
condition|)
block|{
operator|*
name|failedp
operator|=
name|true
expr_stmt|;
return|return;
block|}
comment|/* Figure out whether the relocations are RELA or REL relocations.  */
if|if
condition|(
name|rela_hdr
operator|->
name|sh_type
operator|!=
name|SHT_RELA
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* orelocation has the data, reloc_count has the count...  */
name|outbound_relocas
operator|=
operator|(
name|Elf64_External_Rela
operator|*
operator|)
name|rela_hdr
operator|->
name|contents
expr_stmt|;
name|src_rela
operator|=
name|outbound_relocas
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|sec
operator|->
name|reloc_count
condition|;
name|idx
operator|++
control|)
block|{
name|Elf_Internal_Rela
name|dst_rela
decl_stmt|;
name|arelent
modifier|*
name|ptr
decl_stmt|;
name|asymbol
modifier|*
name|sym
decl_stmt|;
name|int
name|n
decl_stmt|;
name|ptr
operator|=
name|sec
operator|->
name|orelocation
index|[
name|idx
index|]
expr_stmt|;
comment|/* The address of an ELF reloc is section relative for an object 	 file, and absolute for an executable file or shared library. 	 The address of a BFD reloc is always section relative.  */
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
operator|(
name|EXEC_P
operator||
name|DYNAMIC
operator|)
operator|)
operator|==
literal|0
condition|)
name|dst_rela
operator|.
name|r_offset
operator|=
name|ptr
operator|->
name|address
expr_stmt|;
else|else
name|dst_rela
operator|.
name|r_offset
operator|=
name|ptr
operator|->
name|address
operator|+
name|sec
operator|->
name|vma
expr_stmt|;
name|sym
operator|=
operator|*
name|ptr
operator|->
name|sym_ptr_ptr
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|last_sym
condition|)
name|n
operator|=
name|last_sym_idx
expr_stmt|;
elseif|else
if|if
condition|(
name|bfd_is_abs_section
argument_list|(
name|sym
operator|->
name|section
argument_list|)
operator|&&
name|sym
operator|->
name|value
operator|==
literal|0
condition|)
name|n
operator|=
name|STN_UNDEF
expr_stmt|;
else|else
block|{
name|last_sym
operator|=
name|sym
expr_stmt|;
name|n
operator|=
name|_bfd_elf_symbol_from_bfd_symbol
argument_list|(
name|abfd
argument_list|,
operator|&
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
operator|*
name|failedp
operator|=
name|true
expr_stmt|;
return|return;
block|}
name|last_sym_idx
operator|=
name|n
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|ptr
operator|->
name|sym_ptr_ptr
operator|)
operator|->
name|the_bfd
operator|!=
name|NULL
operator|&&
operator|(
operator|*
name|ptr
operator|->
name|sym_ptr_ptr
operator|)
operator|->
name|the_bfd
operator|->
name|xvec
operator|!=
name|abfd
operator|->
name|xvec
operator|&&
operator|!
name|_bfd_elf_validate_reloc
argument_list|(
name|abfd
argument_list|,
name|ptr
argument_list|)
condition|)
block|{
operator|*
name|failedp
operator|=
name|true
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ptr
operator|->
name|howto
operator|->
name|type
operator|==
name|R_SPARC_LO10
operator|&&
name|idx
operator|<
name|sec
operator|->
name|reloc_count
operator|-
literal|1
condition|)
block|{
name|arelent
modifier|*
name|r
init|=
name|sec
operator|->
name|orelocation
index|[
name|idx
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|r
operator|->
name|howto
operator|->
name|type
operator|==
name|R_SPARC_13
operator|&&
name|r
operator|->
name|address
operator|==
name|ptr
operator|->
name|address
operator|&&
name|bfd_is_abs_section
argument_list|(
operator|(
operator|*
name|r
operator|->
name|sym_ptr_ptr
operator|)
operator|->
name|section
argument_list|)
operator|&&
operator|(
operator|*
name|r
operator|->
name|sym_ptr_ptr
operator|)
operator|->
name|value
operator|==
literal|0
condition|)
block|{
name|idx
operator|++
expr_stmt|;
name|dst_rela
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|n
argument_list|,
name|ELF64_R_TYPE_INFO
argument_list|(
name|r
operator|->
name|addend
argument_list|,
name|R_SPARC_OLO10
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|dst_rela
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|n
argument_list|,
name|R_SPARC_LO10
argument_list|)
expr_stmt|;
block|}
else|else
name|dst_rela
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|n
argument_list|,
name|ptr
operator|->
name|howto
operator|->
name|type
argument_list|)
expr_stmt|;
name|dst_rela
operator|.
name|r_addend
operator|=
name|ptr
operator|->
name|addend
expr_stmt|;
name|bfd_elf64_swap_reloca_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|dst_rela
argument_list|,
name|src_rela
argument_list|)
expr_stmt|;
operator|++
name|src_rela
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Sparc64 ELF linker hash table.  */
end_comment

begin_struct
struct|struct
name|sparc64_elf_app_reg
block|{
name|unsigned
name|char
name|bind
decl_stmt|;
name|unsigned
name|short
name|shndx
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|sparc64_elf_link_hash_table
block|{
name|struct
name|elf_link_hash_table
name|root
decl_stmt|;
name|struct
name|sparc64_elf_app_reg
name|app_regs
index|[
literal|4
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Get the Sparc64 ELF linker hash table from a link_info structure.  */
end_comment

begin_define
define|#
directive|define
name|sparc64_elf_hash_table
parameter_list|(
name|p
parameter_list|)
define|\
value|((struct sparc64_elf_link_hash_table *) ((p)->hash))
end_define

begin_comment
comment|/* Create a Sparc64 ELF linker hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_link_hash_table
modifier|*
name|sparc64_elf_bfd_link_hash_table_create
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|sparc64_elf_link_hash_table
modifier|*
name|ret
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|sparc64_elf_link_hash_table
argument_list|)
decl_stmt|;
name|ret
operator|=
operator|(
expr|struct
name|sparc64_elf_link_hash_table
operator|*
operator|)
name|bfd_zmalloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|sparc64_elf_link_hash_table
operator|*
operator|)
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|_bfd_elf_link_hash_table_init
argument_list|(
operator|&
name|ret
operator|->
name|root
argument_list|,
name|abfd
argument_list|,
name|_bfd_elf_link_hash_newfunc
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
operator|&
name|ret
operator|->
name|root
operator|.
name|root
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Utility for performing the standard initial work of an instruction    relocation.    *PRELOCATION will contain the relocated item.    *PINSN will contain the instruction from the input stream.    If the result is `bfd_reloc_other' the caller can continue with    performing the relocation.  Otherwise it must stop and return the    value to its caller.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|init_insn_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|prelocation
parameter_list|,
name|pinsn
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|bfd_vma
modifier|*
name|prelocation
decl_stmt|;
name|bfd_vma
modifier|*
name|pinsn
decl_stmt|;
block|{
name|bfd_vma
name|relocation
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
init|=
name|reloc_entry
operator|->
name|howto
decl_stmt|;
if|if
condition|(
name|output_bfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
operator|&&
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|!
name|howto
operator|->
name|partial_inplace
operator|||
name|reloc_entry
operator|->
name|addend
operator|==
literal|0
operator|)
condition|)
block|{
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
comment|/* This works because partial_inplace is false.  */
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
condition|)
return|return
name|bfd_reloc_continue
return|;
if|if
condition|(
name|reloc_entry
operator|->
name|address
operator|>
name|input_section
operator|->
name|_cooked_size
condition|)
return|return
name|bfd_reloc_outofrange
return|;
name|relocation
operator|=
operator|(
name|symbol
operator|->
name|value
operator|+
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|symbol
operator|->
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|relocation
operator|+=
name|reloc_entry
operator|->
name|addend
expr_stmt|;
if|if
condition|(
name|howto
operator|->
name|pc_relative
condition|)
block|{
name|relocation
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|relocation
operator|-=
name|reloc_entry
operator|->
name|address
expr_stmt|;
block|}
operator|*
name|prelocation
operator|=
name|relocation
expr_stmt|;
operator|*
name|pinsn
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_other
return|;
block|}
end_function

begin_comment
comment|/* For unsupported relocs.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|sparc_elf_notsup_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asymbol
modifier|*
name|symbol
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|PTR
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|input_section
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|bfd_reloc_notsupported
return|;
block|}
end_function

begin_comment
comment|/* Handle the WDISP16 reloc.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|sparc_elf_wdisp16_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_vma
name|insn
decl_stmt|;
name|bfd_reloc_status_type
name|status
decl_stmt|;
name|status
operator|=
name|init_insn_reloc
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
argument_list|,
name|symbol
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
operator|&
name|relocation
argument_list|,
operator|&
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|bfd_reloc_other
condition|)
return|return
name|status
return|;
name|insn
operator|&=
operator|~
operator|(
name|bfd_vma
operator|)
literal|0x303fff
expr_stmt|;
name|insn
operator||=
operator|(
operator|(
operator|(
name|relocation
operator|>>
literal|2
operator|)
operator|&
literal|0xc000
operator|)
operator|<<
literal|6
operator|)
operator||
operator|(
operator|(
name|relocation
operator|>>
literal|2
operator|)
operator|&
literal|0x3fff
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|insn
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bfd_signed_vma
operator|)
name|relocation
operator|<
operator|-
literal|0x40000
operator|||
operator|(
name|bfd_signed_vma
operator|)
name|relocation
operator|>
literal|0x3ffff
condition|)
return|return
name|bfd_reloc_overflow
return|;
else|else
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_comment
comment|/* Handle the HIX22 reloc.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|sparc_elf_hix22_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_vma
name|insn
decl_stmt|;
name|bfd_reloc_status_type
name|status
decl_stmt|;
name|status
operator|=
name|init_insn_reloc
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
argument_list|,
name|symbol
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
operator|&
name|relocation
argument_list|,
operator|&
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|bfd_reloc_other
condition|)
return|return
name|status
return|;
name|relocation
operator|^=
name|MINUS_ONE
expr_stmt|;
name|insn
operator|=
operator|(
name|insn
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
literal|0x3fffff
operator|)
operator||
operator|(
operator|(
name|relocation
operator|>>
literal|10
operator|)
operator|&
literal|0x3fffff
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|insn
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|relocation
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
literal|0xffffffff
operator|)
operator|!=
literal|0
condition|)
return|return
name|bfd_reloc_overflow
return|;
else|else
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_comment
comment|/* Handle the LOX10 reloc.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|sparc_elf_lox10_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_vma
name|insn
decl_stmt|;
name|bfd_reloc_status_type
name|status
decl_stmt|;
name|status
operator|=
name|init_insn_reloc
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
argument_list|,
name|symbol
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
operator|&
name|relocation
argument_list|,
operator|&
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|bfd_reloc_other
condition|)
return|return
name|status
return|;
name|insn
operator|=
operator|(
name|insn
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
literal|0x1fff
operator|)
operator||
literal|0x1c00
operator||
operator|(
name|relocation
operator|&
literal|0x3ff
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|insn
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* PLT/GOT stuff */
end_comment

begin_comment
comment|/* Both the headers and the entries are icache aligned.  */
end_comment

begin_define
define|#
directive|define
name|PLT_ENTRY_SIZE
value|32
end_define

begin_define
define|#
directive|define
name|PLT_HEADER_SIZE
value|(4 * PLT_ENTRY_SIZE)
end_define

begin_define
define|#
directive|define
name|LARGE_PLT_THRESHOLD
value|32768
end_define

begin_define
define|#
directive|define
name|GOT_RESERVED_ENTRIES
value|1
end_define

begin_define
define|#
directive|define
name|ELF_DYNAMIC_INTERPRETER
value|"/usr/lib/sparcv9/ld.so.1"
end_define

begin_comment
comment|/* Fill in the .plt section.  */
end_comment

begin_function
specifier|static
name|void
name|sparc64_elf_build_plt
parameter_list|(
name|output_bfd
parameter_list|,
name|contents
parameter_list|,
name|nentries
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|unsigned
name|char
modifier|*
name|contents
decl_stmt|;
name|int
name|nentries
decl_stmt|;
block|{
specifier|const
name|unsigned
name|int
name|nop
init|=
literal|0x01000000
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* The first four entries are reserved, and are initially undefined.      We fill them with `illtrap 0' to force ld.so to do something.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PLT_HEADER_SIZE
operator|/
literal|4
condition|;
operator|++
name|i
control|)
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|contents
operator|+
name|i
operator|*
literal|4
argument_list|)
expr_stmt|;
comment|/* The first 32768 entries are close enough to plt1 to get there via      a straight branch.  */
for|for
control|(
name|i
operator|=
literal|4
init|;
name|i
operator|<
name|LARGE_PLT_THRESHOLD
operator|&&
name|i
operator|<
name|nentries
condition|;
operator|++
name|i
control|)
block|{
name|unsigned
name|char
modifier|*
name|entry
init|=
name|contents
operator|+
name|i
operator|*
name|PLT_ENTRY_SIZE
decl_stmt|;
name|unsigned
name|int
name|sethi
decl_stmt|,
name|ba
decl_stmt|;
comment|/* sethi (. - plt0), %g1 */
name|sethi
operator|=
literal|0x03000000
operator||
operator|(
name|i
operator|*
name|PLT_ENTRY_SIZE
operator|)
expr_stmt|;
comment|/* ba,a,pt %xcc, plt1 */
name|ba
operator|=
literal|0x30680000
operator||
operator|(
operator|(
operator|(
name|contents
operator|+
name|PLT_ENTRY_SIZE
operator|)
operator|-
operator|(
name|entry
operator|+
literal|4
operator|)
operator|)
operator|/
literal|4
operator|&
literal|0x7ffff
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|sethi
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|ba
argument_list|,
name|entry
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|nop
argument_list|,
name|entry
operator|+
literal|8
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|nop
argument_list|,
name|entry
operator|+
literal|12
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|nop
argument_list|,
name|entry
operator|+
literal|16
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|nop
argument_list|,
name|entry
operator|+
literal|20
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|nop
argument_list|,
name|entry
operator|+
literal|24
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|nop
argument_list|,
name|entry
operator|+
literal|28
argument_list|)
expr_stmt|;
block|}
comment|/* Now the tricky bit.  Entries 32768 and higher are grouped in blocks of      160: 160 entries and 160 pointers.  This is to separate code from data,      which is much friendlier on the cache.  */
for|for
control|(
init|;
name|i
operator|<
name|nentries
condition|;
name|i
operator|+=
literal|160
control|)
block|{
name|int
name|block
init|=
operator|(
name|i
operator|+
literal|160
operator|<=
name|nentries
condition|?
literal|160
else|:
name|nentries
operator|-
name|i
operator|)
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|block
condition|;
operator|++
name|j
control|)
block|{
name|unsigned
name|char
modifier|*
name|entry
decl_stmt|,
modifier|*
name|ptr
decl_stmt|;
name|unsigned
name|int
name|ldx
decl_stmt|;
name|entry
operator|=
name|contents
operator|+
name|i
operator|*
name|PLT_ENTRY_SIZE
operator|+
name|j
operator|*
literal|4
operator|*
literal|6
expr_stmt|;
name|ptr
operator|=
name|contents
operator|+
name|i
operator|*
name|PLT_ENTRY_SIZE
operator|+
name|block
operator|*
literal|4
operator|*
literal|6
operator|+
name|j
operator|*
literal|8
expr_stmt|;
comment|/* ldx [%o7 + ptr - (entry+4)], %g1 */
name|ldx
operator|=
literal|0xc25be000
operator||
operator|(
operator|(
name|ptr
operator|-
operator|(
name|entry
operator|+
literal|4
operator|)
operator|)
operator|&
literal|0x1fff
operator|)
expr_stmt|;
comment|/* mov %o7,%g5 	     call .+8 	     nop 	     ldx [%o7+P],%g1 	     jmpl %o7+%g1,%g1 	     mov %g5,%o7  */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0x8a10000f
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0x40000002
argument_list|,
name|entry
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|nop
argument_list|,
name|entry
operator|+
literal|8
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|ldx
argument_list|,
name|entry
operator|+
literal|12
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0x83c3c001
argument_list|,
name|entry
operator|+
literal|16
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0x9e100005
argument_list|,
name|entry
operator|+
literal|20
argument_list|)
expr_stmt|;
name|bfd_put_64
argument_list|(
name|output_bfd
argument_list|,
call|(
name|bfd_vma
call|)
argument_list|(
name|contents
operator|-
operator|(
name|entry
operator|+
literal|4
operator|)
argument_list|)
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Return the offset of a particular plt entry within the .plt section.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|sparc64_elf_plt_entry_offset
parameter_list|(
name|index
parameter_list|)
name|bfd_vma
name|index
decl_stmt|;
block|{
name|bfd_vma
name|block
decl_stmt|,
name|ofs
decl_stmt|;
if|if
condition|(
name|index
operator|<
name|LARGE_PLT_THRESHOLD
condition|)
return|return
name|index
operator|*
name|PLT_ENTRY_SIZE
return|;
comment|/* See above for details.  */
name|block
operator|=
operator|(
name|index
operator|-
name|LARGE_PLT_THRESHOLD
operator|)
operator|/
literal|160
expr_stmt|;
name|ofs
operator|=
operator|(
name|index
operator|-
name|LARGE_PLT_THRESHOLD
operator|)
operator|%
literal|160
expr_stmt|;
return|return
operator|(
name|LARGE_PLT_THRESHOLD
operator|+
name|block
operator|*
literal|160
operator|)
operator|*
name|PLT_ENTRY_SIZE
operator|+
name|ofs
operator|*
literal|6
operator|*
literal|4
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_vma
name|sparc64_elf_plt_ptr_offset
parameter_list|(
name|index
parameter_list|,
name|max
parameter_list|)
name|bfd_vma
name|index
decl_stmt|;
name|bfd_vma
name|max
decl_stmt|;
block|{
name|bfd_vma
name|block
decl_stmt|,
name|ofs
decl_stmt|,
name|last
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|index
operator|>=
name|LARGE_PLT_THRESHOLD
argument_list|)
expr_stmt|;
comment|/* See above for details.  */
name|block
operator|=
operator|(
operator|(
operator|(
name|index
operator|-
name|LARGE_PLT_THRESHOLD
operator|)
operator|/
literal|160
operator|)
operator|*
literal|160
operator|)
operator|+
name|LARGE_PLT_THRESHOLD
expr_stmt|;
name|ofs
operator|=
name|index
operator|-
name|block
expr_stmt|;
if|if
condition|(
name|block
operator|+
literal|160
operator|>
name|max
condition|)
name|last
operator|=
operator|(
name|max
operator|-
name|LARGE_PLT_THRESHOLD
operator|)
operator|%
literal|160
expr_stmt|;
else|else
name|last
operator|=
literal|160
expr_stmt|;
return|return
operator|(
name|block
operator|*
name|PLT_ENTRY_SIZE
operator|+
name|last
operator|*
literal|6
operator|*
literal|4
operator|+
name|ofs
operator|*
literal|8
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Look through the relocs for a section during the first phase, and    allocate space in the global offset table or procedure linkage    table.  */
end_comment

begin_function
specifier|static
name|boolean
name|sparc64_elf_check_relocs
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|sec
parameter_list|,
name|relocs
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|;
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|bfd_vma
modifier|*
name|local_got_offsets
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel_end
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
name|asection
modifier|*
name|srelgot
decl_stmt|;
name|asection
modifier|*
name|sreloc
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocateable
operator|||
operator|!
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
condition|)
return|return
name|true
return|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|local_got_offsets
operator|=
name|elf_local_got_offsets
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|sgot
operator|=
name|NULL
expr_stmt|;
name|srelgot
operator|=
name|NULL
expr_stmt|;
name|sreloc
operator|=
name|NULL
expr_stmt|;
name|rel_end
operator|=
name|relocs
operator|+
name|NUM_SHDR_ENTRIES
argument_list|(
operator|&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|rel_hdr
argument_list|)
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|rel_end
condition|;
name|rel
operator|++
control|)
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|r_symndx
operator|=
name|ELF64_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
name|h
operator|=
name|NULL
expr_stmt|;
else|else
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
switch|switch
condition|(
name|ELF64_R_TYPE_ID
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_SPARC_GOT10
case|:
case|case
name|R_SPARC_GOT13
case|:
case|case
name|R_SPARC_GOT22
case|:
comment|/* This symbol requires a global offset table entry.  */
if|if
condition|(
name|dynobj
operator|==
name|NULL
condition|)
block|{
comment|/* Create the .got section.  */
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
operator|=
name|dynobj
operator|=
name|abfd
expr_stmt|;
if|if
condition|(
operator|!
name|_bfd_elf_create_got_section
argument_list|(
name|dynobj
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|sgot
operator|==
name|NULL
condition|)
block|{
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|srelgot
operator|==
name|NULL
operator|&&
operator|(
name|h
operator|!=
name|NULL
operator|||
name|info
operator|->
name|shared
operator|)
condition|)
block|{
name|srelgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
if|if
condition|(
name|srelgot
operator|==
name|NULL
condition|)
block|{
name|srelgot
operator|=
name|bfd_make_section
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
if|if
condition|(
name|srelgot
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|dynobj
argument_list|,
name|srelgot
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_READONLY
operator|)
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|srelgot
argument_list|,
literal|3
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
comment|/* We have already allocated space in the .got.  */
break|break;
block|}
name|h
operator|->
name|got
operator|.
name|offset
operator|=
name|sgot
operator|->
name|_raw_size
expr_stmt|;
comment|/* Make sure this symbol is output as a dynamic symbol.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf64_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|false
return|;
block|}
name|srelgot
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This is a global offset table entry for a local                  symbol.  */
if|if
condition|(
name|local_got_offsets
operator|==
name|NULL
condition|)
block|{
name|bfd_size_type
name|size
decl_stmt|;
specifier|register
name|unsigned
name|int
name|i
decl_stmt|;
name|size
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|size
operator|*=
sizeof|sizeof
argument_list|(
name|bfd_vma
argument_list|)
expr_stmt|;
name|local_got_offsets
operator|=
operator|(
name|bfd_vma
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_got_offsets
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|elf_local_got_offsets
argument_list|(
name|abfd
argument_list|)
operator|=
name|local_got_offsets
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|;
name|i
operator|++
control|)
name|local_got_offsets
index|[
name|i
index|]
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|local_got_offsets
index|[
name|r_symndx
index|]
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
comment|/* We have already allocated space in the .got.  */
break|break;
block|}
name|local_got_offsets
index|[
name|r_symndx
index|]
operator|=
name|sgot
operator|->
name|_raw_size
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
comment|/* If we are generating a shared object, we need to                      output a R_SPARC_RELATIVE reloc so that the                      dynamic linker can adjust this GOT entry.  */
name|srelgot
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
block|}
block|}
name|sgot
operator|->
name|_raw_size
operator|+=
literal|8
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Doesn't work for 64-bit -fPIC, since sethi/or builds 	     unsigned numbers.  If we permit ourselves to modify 	     code so we get sethi/xor, this could work. 	     Question: do we consider conditionally re-enabling              this for -fpic, once we know about object code models?  */
comment|/* If the .got section is more than 0x1000 bytes, we add 	     0x1000 to the value of _GLOBAL_OFFSET_TABLE_, so that 13 	     bit relocations have a greater chance of working.  */
block|if (sgot->_raw_size>= 0x1000&& elf_hash_table (info)->hgot->root.u.def.value == 0) 	    elf_hash_table (info)->hgot->root.u.def.value = 0x1000;
endif|#
directive|endif
break|break;
case|case
name|R_SPARC_WPLT30
case|:
case|case
name|R_SPARC_PLT32
case|:
case|case
name|R_SPARC_HIPLT22
case|:
case|case
name|R_SPARC_LOPLT10
case|:
case|case
name|R_SPARC_PCPLT32
case|:
case|case
name|R_SPARC_PCPLT22
case|:
case|case
name|R_SPARC_PCPLT10
case|:
case|case
name|R_SPARC_PLT64
case|:
comment|/* This symbol requires a procedure linkage table entry.  We              actually build the entry in adjust_dynamic_symbol,              because this might be a case of linking PIC code without              linking in any dynamic objects, in which case we don't              need to generate a procedure linkage table after all.  */
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
block|{
comment|/* It does not make sense to have a procedure linkage                  table entry for a local symbol.  */
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Make sure this symbol is output as a dynamic symbol.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf64_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|false
return|;
block|}
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_NEEDS_PLT
expr_stmt|;
if|if
condition|(
name|ELF64_R_TYPE_ID
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|!=
name|R_SPARC_PLT32
operator|&&
name|ELF64_R_TYPE_ID
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|!=
name|R_SPARC_PLT64
condition|)
break|break;
comment|/* Fall through.  */
case|case
name|R_SPARC_PC10
case|:
case|case
name|R_SPARC_PC22
case|:
case|case
name|R_SPARC_PC_HH22
case|:
case|case
name|R_SPARC_PC_HM10
case|:
case|case
name|R_SPARC_PC_LM22
case|:
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|)
operator|==
literal|0
condition|)
break|break;
comment|/* Fall through.  */
case|case
name|R_SPARC_DISP8
case|:
case|case
name|R_SPARC_DISP16
case|:
case|case
name|R_SPARC_DISP32
case|:
case|case
name|R_SPARC_DISP64
case|:
case|case
name|R_SPARC_WDISP30
case|:
case|case
name|R_SPARC_WDISP22
case|:
case|case
name|R_SPARC_WDISP19
case|:
case|case
name|R_SPARC_WDISP16
case|:
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
break|break;
comment|/* Fall through.  */
case|case
name|R_SPARC_8
case|:
case|case
name|R_SPARC_16
case|:
case|case
name|R_SPARC_32
case|:
case|case
name|R_SPARC_HI22
case|:
case|case
name|R_SPARC_22
case|:
case|case
name|R_SPARC_13
case|:
case|case
name|R_SPARC_LO10
case|:
case|case
name|R_SPARC_UA32
case|:
case|case
name|R_SPARC_10
case|:
case|case
name|R_SPARC_11
case|:
case|case
name|R_SPARC_64
case|:
case|case
name|R_SPARC_OLO10
case|:
case|case
name|R_SPARC_HH22
case|:
case|case
name|R_SPARC_HM10
case|:
case|case
name|R_SPARC_LM22
case|:
case|case
name|R_SPARC_7
case|:
case|case
name|R_SPARC_5
case|:
case|case
name|R_SPARC_6
case|:
case|case
name|R_SPARC_HIX22
case|:
case|case
name|R_SPARC_LOX10
case|:
case|case
name|R_SPARC_H44
case|:
case|case
name|R_SPARC_M44
case|:
case|case
name|R_SPARC_L44
case|:
case|case
name|R_SPARC_UA64
case|:
case|case
name|R_SPARC_UA16
case|:
comment|/* When creating a shared object, we must copy these relocs 	     into the output file.  We create a reloc section in 	     dynobj and make room for the reloc.  	     But don't do this for debugging sections -- this shows up 	     with DWARF2 -- first because they are not loaded, and 	     second because DWARF sez the debug info is not to be 	     biased by the load address.  */
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
condition|)
block|{
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
operator|(
name|bfd_elf_string_from_elf_section
argument_list|(
name|abfd
argument_list|,
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_shstrndx
argument_list|,
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|rel_hdr
operator|.
name|sh_name
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|BFD_ASSERT
argument_list|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".rela"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|,
name|name
operator|+
literal|5
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|sreloc
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
block|{
name|flagword
name|flags
decl_stmt|;
name|sreloc
operator|=
name|bfd_make_section
argument_list|(
name|dynobj
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|flags
operator|=
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_READONLY
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
name|flags
operator||=
name|SEC_ALLOC
operator||
name|SEC_LOAD
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|dynobj
argument_list|,
name|sreloc
argument_list|,
name|flags
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|sreloc
argument_list|,
literal|3
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|sec
operator|->
name|flags
operator|&
name|SEC_READONLY
condition|)
name|info
operator|->
name|flags
operator||=
name|DF_TEXTREL
expr_stmt|;
block|}
name|sreloc
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|R_SPARC_REGISTER
case|:
comment|/* Nothing to do.  */
break|break;
default|default:
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: check_relocs: unhandled reloc type %d"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|ELF64_R_TYPE_ID
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Hook called by the linker routine which adds symbols from an object    file.  We use it for STT_REGISTER symbols.  */
end_comment

begin_function
specifier|static
name|boolean
name|sparc64_elf_add_symbol_hook
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|sym
parameter_list|,
name|namep
parameter_list|,
name|flagsp
parameter_list|,
name|secp
parameter_list|,
name|valp
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
specifier|const
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|namep
decl_stmt|;
name|flagword
modifier|*
name|flagsp
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
modifier|*
name|secp
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd_vma
modifier|*
name|valp
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|stt_types
index|[]
init|=
block|{
literal|"NOTYPE"
block|,
literal|"OBJECT"
block|,
literal|"FUNCTION"
block|}
decl_stmt|;
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_REGISTER
condition|)
block|{
name|int
name|reg
decl_stmt|;
name|struct
name|sparc64_elf_app_reg
modifier|*
name|p
decl_stmt|;
name|reg
operator|=
operator|(
name|int
operator|)
name|sym
operator|->
name|st_value
expr_stmt|;
switch|switch
condition|(
name|reg
operator|&
operator|~
literal|1
condition|)
block|{
case|case
literal|2
case|:
name|reg
operator|-=
literal|2
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|reg
operator|-=
literal|4
expr_stmt|;
break|break;
default|default:
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: Only registers %%g[2367] can be declared using STT_REGISTER"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|info
operator|->
name|hash
operator|->
name|creator
operator|!=
name|abfd
operator|->
name|xvec
operator|||
operator|(
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* STT_REGISTER only works when linking an elf64_sparc object. 	     If STT_REGISTER comes from a dynamic object, don't put it into 	     the output bfd.  The dynamic linker will recheck it.  */
operator|*
name|namep
operator|=
name|NULL
expr_stmt|;
return|return
name|true
return|;
block|}
name|p
operator|=
name|sparc64_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|app_regs
operator|+
name|reg
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|name
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|p
operator|->
name|name
argument_list|,
operator|*
name|namep
argument_list|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Register %%g%d used incompatibly: %s in %s, previously %s in %s"
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|sym
operator|->
name|st_value
argument_list|,
operator|*
operator|*
name|namep
condition|?
operator|*
name|namep
else|:
literal|"#scratch"
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
operator|*
name|p
operator|->
name|name
condition|?
name|p
operator|->
name|name
else|:
literal|"#scratch"
argument_list|,
name|bfd_archive_filename
argument_list|(
name|p
operator|->
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|p
operator|->
name|name
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
operator|*
name|namep
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|bfd_link_hash_lookup
argument_list|(
name|info
operator|->
name|hash
argument_list|,
operator|*
name|namep
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|char
name|type
init|=
name|h
operator|->
name|type
decl_stmt|;
if|if
condition|(
name|type
operator|>
name|STT_FUNC
condition|)
name|type
operator|=
literal|0
expr_stmt|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Symbol `%s' has differing types: REGISTER in %s, previously %s in %s"
argument_list|)
argument_list|,
operator|*
name|namep
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|stt_types
index|[
name|type
index|]
argument_list|,
name|bfd_archive_filename
argument_list|(
name|p
operator|->
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|p
operator|->
name|name
operator|=
name|bfd_hash_allocate
argument_list|(
operator|&
name|info
operator|->
name|hash
operator|->
name|table
argument_list|,
name|strlen
argument_list|(
operator|*
name|namep
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|->
name|name
condition|)
return|return
name|false
return|;
name|strcpy
argument_list|(
name|p
operator|->
name|name
argument_list|,
operator|*
name|namep
argument_list|)
expr_stmt|;
block|}
else|else
name|p
operator|->
name|name
operator|=
literal|""
expr_stmt|;
name|p
operator|->
name|bind
operator|=
name|ELF_ST_BIND
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
expr_stmt|;
name|p
operator|->
name|abfd
operator|=
name|abfd
expr_stmt|;
name|p
operator|->
name|shndx
operator|=
name|sym
operator|->
name|st_shndx
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|p
operator|->
name|bind
operator|==
name|STB_WEAK
operator|&&
name|ELF_ST_BIND
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STB_GLOBAL
condition|)
block|{
name|p
operator|->
name|bind
operator|=
name|STB_GLOBAL
expr_stmt|;
name|p
operator|->
name|abfd
operator|=
name|abfd
expr_stmt|;
block|}
block|}
operator|*
name|namep
operator|=
name|NULL
expr_stmt|;
return|return
name|true
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|namep
operator|&&
operator|*
operator|*
name|namep
operator|&&
name|info
operator|->
name|hash
operator|->
name|creator
operator|==
name|abfd
operator|->
name|xvec
condition|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|sparc64_elf_app_reg
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|sparc64_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|app_regs
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
if|if
condition|(
name|p
operator|->
name|name
operator|!=
name|NULL
operator|&&
operator|!
name|strcmp
argument_list|(
name|p
operator|->
name|name
argument_list|,
operator|*
name|namep
argument_list|)
condition|)
block|{
name|unsigned
name|char
name|type
init|=
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|>
name|STT_FUNC
condition|)
name|type
operator|=
literal|0
expr_stmt|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Symbol `%s' has differing types: %s in %s, previously REGISTER in %s"
argument_list|)
argument_list|,
operator|*
name|namep
argument_list|,
name|stt_types
index|[
name|type
index|]
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|p
operator|->
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* This function takes care of emiting STT_REGISTER symbols    which we cannot easily keep in the symbol hash table.  */
end_comment

begin_function_decl
specifier|static
name|boolean
name|sparc64_elf_output_arch_syms
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|finfo
parameter_list|,
name|func
parameter_list|)
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|PTR
name|finfo
decl_stmt|;
function_decl|boolean
parameter_list|(
function_decl|*func
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
specifier|const
name|char
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|reg
decl_stmt|;
name|struct
name|sparc64_elf_app_reg
modifier|*
name|app_regs
init|=
name|sparc64_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|app_regs
decl_stmt|;
name|Elf_Internal_Sym
name|sym
decl_stmt|;
comment|/* We arranged in size_dynamic_sections to put the STT_REGISTER entries      at the end of the dynlocal list, so they came at the end of the local      symbols in the symtab.  Except that they aren't STB_LOCAL, so we need      to back up symtab->sh_info.  */
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynlocal
condition|)
block|{
name|bfd
modifier|*
name|dynobj
init|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|dynsymsec
init|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynsym"
argument_list|)
decl_stmt|;
name|struct
name|elf_link_local_dynamic_entry
modifier|*
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynlocal
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next
control|)
if|if
condition|(
name|e
operator|->
name|input_indx
operator|==
operator|-
literal|1
condition|)
break|break;
if|if
condition|(
name|e
condition|)
block|{
name|elf_section_data
argument_list|(
name|dynsymsec
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_info
operator|=
name|e
operator|->
name|dynindx
expr_stmt|;
block|}
block|}
if|if
condition|(
name|info
operator|->
name|strip
operator|==
name|strip_all
condition|)
return|return
name|true
return|;
for|for
control|(
name|reg
operator|=
literal|0
init|;
name|reg
operator|<
literal|4
condition|;
name|reg
operator|++
control|)
if|if
condition|(
name|app_regs
index|[
name|reg
index|]
operator|.
name|name
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|strip
operator|==
name|strip_some
operator|&&
name|bfd_hash_lookup
argument_list|(
name|info
operator|->
name|keep_hash
argument_list|,
name|app_regs
index|[
name|reg
index|]
operator|.
name|name
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
operator|==
name|NULL
condition|)
continue|continue;
name|sym
operator|.
name|st_value
operator|=
name|reg
operator|<
literal|2
condition|?
name|reg
operator|+
literal|2
else|:
name|reg
operator|+
literal|4
expr_stmt|;
name|sym
operator|.
name|st_size
operator|=
literal|0
expr_stmt|;
name|sym
operator|.
name|st_other
operator|=
literal|0
expr_stmt|;
name|sym
operator|.
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|app_regs
index|[
name|reg
index|]
operator|.
name|bind
argument_list|,
name|STT_REGISTER
argument_list|)
expr_stmt|;
name|sym
operator|.
name|st_shndx
operator|=
name|app_regs
index|[
name|reg
index|]
operator|.
name|shndx
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|func
call|)
argument_list|(
name|finfo
argument_list|,
name|app_regs
index|[
name|reg
index|]
operator|.
name|name
argument_list|,
operator|&
name|sym
argument_list|,
name|sym
operator|.
name|st_shndx
operator|==
name|SHN_ABS
condition|?
name|bfd_abs_section_ptr
else|:
name|bfd_und_section_ptr
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_block

begin_function
specifier|static
name|int
name|sparc64_elf_get_symbol_type
parameter_list|(
name|elf_sym
parameter_list|,
name|type
parameter_list|)
name|Elf_Internal_Sym
modifier|*
name|elf_sym
decl_stmt|;
name|int
name|type
decl_stmt|;
block|{
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|elf_sym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_REGISTER
condition|)
return|return
name|STT_REGISTER
return|;
else|else
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* A STB_GLOBAL,STT_REGISTER symbol should be BSF_GLOBAL    even in SHN_UNDEF section.  */
end_comment

begin_function
specifier|static
name|void
name|sparc64_elf_symbol_processing
parameter_list|(
name|abfd
parameter_list|,
name|asym
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asymbol
modifier|*
name|asym
decl_stmt|;
block|{
name|elf_symbol_type
modifier|*
name|elfsym
decl_stmt|;
name|elfsym
operator|=
operator|(
name|elf_symbol_type
operator|*
operator|)
name|asym
expr_stmt|;
if|if
condition|(
name|elfsym
operator|->
name|internal_elf_sym
operator|.
name|st_info
operator|==
name|ELF_ST_INFO
argument_list|(
name|STB_GLOBAL
argument_list|,
name|STT_REGISTER
argument_list|)
condition|)
block|{
name|asym
operator|->
name|flags
operator||=
name|BSF_GLOBAL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Adjust a symbol defined by a dynamic object and referenced by a    regular object.  The current definition is in some section of the    dynamic object, but we're not including those sections.  We have to    change the definition to something the rest of the link can    understand.  */
end_comment

begin_function
specifier|static
name|boolean
name|sparc64_elf_adjust_dynamic_symbol
parameter_list|(
name|info
parameter_list|,
name|h
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|unsigned
name|int
name|power_of_two
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
comment|/* Make sure we know what is going on here.  */
name|BFD_ASSERT
argument_list|(
name|dynobj
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_NEEDS_PLT
operator|)
operator|||
name|h
operator|->
name|weakdef
operator|!=
name|NULL
operator|||
operator|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_REF_REGULAR
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* If this is a function, put it in the procedure linkage table.  We      will fill in the contents of the procedure linkage table later      (although we could actually do it here).  The STT_NOTYPE      condition is a hack specifically for the Oracle libraries      delivered for Solaris; for some inexplicable reason, they define      some of their functions as STT_NOTYPE when they really should be      STT_FUNC.  */
if|if
condition|(
name|h
operator|->
name|type
operator|==
name|STT_FUNC
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_NEEDS_PLT
operator|)
operator|!=
literal|0
operator|||
operator|(
name|h
operator|->
name|type
operator|==
name|STT_NOTYPE
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|flags
operator|&
name|SEC_CODE
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
comment|/* This case can occur if we saw a WPLT30 reloc in an input              file, but none of the input files were dynamic objects.              In such a case, we don't actually need to build a              procedure linkage table, and we can just do a WDISP30              reloc instead.  */
name|BFD_ASSERT
argument_list|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_NEEDS_PLT
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* The first four bit in .plt is reserved.  */
if|if
condition|(
name|s
operator|->
name|_raw_size
operator|==
literal|0
condition|)
name|s
operator|->
name|_raw_size
operator|=
name|PLT_HEADER_SIZE
expr_stmt|;
comment|/* To simplify matters later, just store the plt index here.  */
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
name|s
operator|->
name|_raw_size
operator|/
name|PLT_ENTRY_SIZE
expr_stmt|;
comment|/* If this symbol is not defined in a regular file, and we are 	 not generating a shared library, then set the symbol to this 	 location in the .plt.  This is required to make function 	 pointers compare as equal between the normal executable and 	 the shared library.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
condition|)
block|{
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|s
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|sparc64_elf_plt_entry_offset
argument_list|(
name|h
operator|->
name|plt
operator|.
name|offset
argument_list|)
expr_stmt|;
block|}
comment|/* Make room for this entry.  */
name|s
operator|->
name|_raw_size
operator|+=
name|PLT_ENTRY_SIZE
expr_stmt|;
comment|/* We also need to make an entry in the .rela.plt section.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.plt"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
comment|/* The procedure linkage table size is bounded by the magnitude 	 of the offset we can describe in the entry.  */
if|if
condition|(
name|s
operator|->
name|_raw_size
operator|>=
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
literal|32
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
comment|/* If this is a weak symbol, and there is a real definition, the      processor independent code will have arranged for us to see the      real definition first, and we can just use the same value.  */
if|if
condition|(
name|h
operator|->
name|weakdef
operator|!=
name|NULL
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
argument_list|)
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* This is a reference to a symbol defined by a dynamic object which      is not a function.  */
comment|/* If we are creating a shared library, we must presume that the      only references to the symbol are via the global offset table.      For such cases we need not do anything here; the relocations will      be handled correctly by relocate_section.  */
if|if
condition|(
name|info
operator|->
name|shared
condition|)
return|return
name|true
return|;
comment|/* We must allocate the symbol in our .dynbss section, which will      become part of the .bss section of the executable.  There will be      an entry for this symbol in the .dynsym section.  The dynamic      object will contain position independent code, so all references      from the dynamic object to this symbol will go through the global      offset table.  The dynamic linker will use the .dynsym entry to      determine the address it must put in the global offset table, so      both the dynamic object and the regular object will refer to the      same memory location for the variable.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynbss"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* We must generate a R_SPARC_COPY reloc to tell the dynamic linker      to copy the initial value out of the dynamic object and into the      runtime process image.  We need to remember the offset into the      .rel.bss section we are going to use.  */
if|if
condition|(
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
name|asection
modifier|*
name|srel
decl_stmt|;
name|srel
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.bss"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|srel
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|srel
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_NEEDS_COPY
expr_stmt|;
block|}
comment|/* We need to figure out the alignment required for this symbol.  I      have no idea how ELF linkers handle this.  16-bytes is the size      of the largest type that requires hard alignment -- long double.  */
name|power_of_two
operator|=
name|bfd_log2
argument_list|(
name|h
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|power_of_two
operator|>
literal|4
condition|)
name|power_of_two
operator|=
literal|4
expr_stmt|;
comment|/* Apply the required alignment.  */
name|s
operator|->
name|_raw_size
operator|=
name|BFD_ALIGN
argument_list|(
name|s
operator|->
name|_raw_size
argument_list|,
call|(
name|bfd_size_type
call|)
argument_list|(
literal|1
operator|<<
name|power_of_two
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|power_of_two
operator|>
name|bfd_get_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|,
name|power_of_two
argument_list|)
condition|)
return|return
name|false
return|;
block|}
comment|/* Define the symbol as being at this point in the section.  */
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|s
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
comment|/* Increment the section size to make room for the symbol.  */
name|s
operator|->
name|_raw_size
operator|+=
name|h
operator|->
name|size
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Set the sizes of the dynamic sections.  */
end_comment

begin_function
specifier|static
name|boolean
name|sparc64_elf_size_dynamic_sections
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|boolean
name|relplt
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|dynobj
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
comment|/* Set the contents of the .interp section to the interpreter.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".interp"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|=
sizeof|sizeof
name|ELF_DYNAMIC_INTERPRETER
expr_stmt|;
name|s
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ELF_DYNAMIC_INTERPRETER
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* We may have created entries in the .rela.got section.          However, if we are not creating the dynamic sections, we will          not actually use these entries.  Reset the size of .rela.got,          which will cause it to get stripped from the output file          below.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|s
operator|->
name|_raw_size
operator|=
literal|0
expr_stmt|;
block|}
comment|/* The check_relocs and adjust_dynamic_symbol entry points have      determined the sizes of the various dynamic sections.  Allocate      memory for them.  */
name|relplt
operator|=
name|false
expr_stmt|;
for|for
control|(
name|s
operator|=
name|dynobj
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|boolean
name|strip
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LINKER_CREATED
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* It's OK to base decisions on the section name, because none 	 of the dynobj section names depend upon the input files.  */
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|strip
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".rela"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|_raw_size
operator|==
literal|0
condition|)
block|{
comment|/* If we don't need this section, strip it from the 		 output file.  This is to handle .rela.bss and 		 .rel.plt.  We must create it in 		 create_dynamic_sections, because it must be created 		 before the linker maps input sections to output 		 sections.  The linker does that before 		 adjust_dynamic_symbol is called, and it is that 		 function which decides whether anything needs to go 		 into these sections.  */
name|strip
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".rela.plt"
argument_list|)
operator|==
literal|0
condition|)
name|relplt
operator|=
name|true
expr_stmt|;
comment|/* We use the reloc_count field as a counter if we need 		 to copy relocs into the output file.  */
name|s
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".plt"
argument_list|)
operator|!=
literal|0
operator|&&
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".got"
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* It's not one of our sections, so don't allocate space.  */
continue|continue;
block|}
if|if
condition|(
name|strip
condition|)
block|{
name|_bfd_strip_section_from_output
argument_list|(
name|info
argument_list|,
name|s
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Allocate memory for the section contents.  Zero the memory 	 for the benefit of .rela.plt, which has 4 unused entries 	 at the beginning, and we don't want garbage.  */
name|s
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|dynobj
argument_list|,
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|contents
operator|==
name|NULL
operator|&&
name|s
operator|->
name|_raw_size
operator|!=
literal|0
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
comment|/* Add some entries to the .dynamic section.  We fill in the 	 values later, in sparc64_elf_finish_dynamic_sections, but we 	 must add the entries now so that we get the correct size for 	 the .dynamic section.  The DT_DEBUG entry is filled in by the 	 dynamic linker and used by the debugger.  */
define|#
directive|define
name|add_dynamic_entry
parameter_list|(
name|TAG
parameter_list|,
name|VAL
parameter_list|)
define|\
value|bfd_elf64_add_dynamic_entry (info, (bfd_vma) (TAG), (bfd_vma) (VAL))
name|int
name|reg
decl_stmt|;
name|struct
name|sparc64_elf_app_reg
modifier|*
name|app_regs
decl_stmt|;
name|struct
name|elf_strtab_hash
modifier|*
name|dynstr
decl_stmt|;
name|struct
name|elf_link_hash_table
modifier|*
name|eht
init|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_DEBUG
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|relplt
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PLTGOT
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PLTRELSZ
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PLTREL
argument_list|,
name|DT_RELA
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_JMPREL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELA
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELASZ
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELAENT
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|info
operator|->
name|flags
operator|&
name|DF_TEXTREL
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_TEXTREL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
block|}
comment|/* Add dynamic STT_REGISTER symbols and corresponding DT_SPARC_REGISTER 	 entries if needed.  */
name|app_regs
operator|=
name|sparc64_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|app_regs
expr_stmt|;
name|dynstr
operator|=
name|eht
operator|->
name|dynstr
expr_stmt|;
for|for
control|(
name|reg
operator|=
literal|0
init|;
name|reg
operator|<
literal|4
condition|;
name|reg
operator|++
control|)
if|if
condition|(
name|app_regs
index|[
name|reg
index|]
operator|.
name|name
operator|!=
name|NULL
condition|)
block|{
name|struct
name|elf_link_local_dynamic_entry
modifier|*
name|entry
decl_stmt|,
modifier|*
name|e
decl_stmt|;
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_SPARC_REGISTER
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
name|entry
operator|=
operator|(
expr|struct
name|elf_link_local_dynamic_entry
operator|*
operator|)
name|bfd_hash_allocate
argument_list|(
operator|&
name|info
operator|->
name|hash
operator|->
name|table
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
return|return
name|false
return|;
comment|/* We cheat here a little bit: the symbol will not be local, so we 	       put it at the end of the dynlocal linked list.  We will fix it 	       later on, as we have to fix other fields anyway.  */
name|entry
operator|->
name|isym
operator|.
name|st_value
operator|=
name|reg
operator|<
literal|2
condition|?
name|reg
operator|+
literal|2
else|:
name|reg
operator|+
literal|4
expr_stmt|;
name|entry
operator|->
name|isym
operator|.
name|st_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|app_regs
index|[
name|reg
index|]
operator|.
name|name
operator|!=
literal|'\0'
condition|)
name|entry
operator|->
name|isym
operator|.
name|st_name
operator|=
name|_bfd_elf_strtab_add
argument_list|(
name|dynstr
argument_list|,
name|app_regs
index|[
name|reg
index|]
operator|.
name|name
argument_list|,
name|false
argument_list|)
expr_stmt|;
else|else
name|entry
operator|->
name|isym
operator|.
name|st_name
operator|=
literal|0
expr_stmt|;
name|entry
operator|->
name|isym
operator|.
name|st_other
operator|=
literal|0
expr_stmt|;
name|entry
operator|->
name|isym
operator|.
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|app_regs
index|[
name|reg
index|]
operator|.
name|bind
argument_list|,
name|STT_REGISTER
argument_list|)
expr_stmt|;
name|entry
operator|->
name|isym
operator|.
name|st_shndx
operator|=
name|app_regs
index|[
name|reg
index|]
operator|.
name|shndx
expr_stmt|;
name|entry
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|entry
operator|->
name|input_bfd
operator|=
name|output_bfd
expr_stmt|;
name|entry
operator|->
name|input_indx
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|eht
operator|->
name|dynlocal
operator|==
name|NULL
condition|)
name|eht
operator|->
name|dynlocal
operator|=
name|entry
expr_stmt|;
else|else
block|{
for|for
control|(
name|e
operator|=
name|eht
operator|->
name|dynlocal
init|;
name|e
operator|->
name|next
condition|;
name|e
operator|=
name|e
operator|->
name|next
control|)
empty_stmt|;
name|e
operator|->
name|next
operator|=
name|entry
expr_stmt|;
block|}
name|eht
operator|->
name|dynsymcount
operator|++
expr_stmt|;
block|}
block|}
undef|#
directive|undef
name|add_dynamic_entry
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|SET_SEC_DO_RELAX
parameter_list|(
name|section
parameter_list|)
value|do { elf_section_data(section)->tdata = (void *)1; } while (0)
end_define

begin_define
define|#
directive|define
name|SEC_DO_RELAX
parameter_list|(
name|section
parameter_list|)
value|(elf_section_data(section)->tdata == (void *)1)
end_define

begin_function
specifier|static
name|boolean
name|sparc64_elf_relax_section
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|link_info
parameter_list|,
name|again
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|section
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|link_info
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|boolean
modifier|*
name|again
decl_stmt|;
block|{
operator|*
name|again
operator|=
name|false
expr_stmt|;
name|SET_SEC_DO_RELAX
argument_list|(
name|section
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This is the condition under which finish_dynamic_symbol will be called    from elflink.h.  If elflink.h doesn't call our finish_dynamic_symbol    routine, we'll need to do something about initializing any .plt and    .got entries in relocate_section.  */
end_comment

begin_define
define|#
directive|define
name|WILL_CALL_FINISH_DYNAMIC_SYMBOL
parameter_list|(
name|DYN
parameter_list|,
name|INFO
parameter_list|,
name|H
parameter_list|)
define|\
value|((DYN)								\&& ((INFO)->shared							\        || ((H)->elf_link_hash_flags& ELF_LINK_FORCED_LOCAL) == 0)	\&& ((H)->dynindx != -1						\        || ((H)->elf_link_hash_flags& ELF_LINK_FORCED_LOCAL) != 0))
end_define

begin_comment
comment|/* Relocate a SPARC64 ELF section.  */
end_comment

begin_function
specifier|static
name|boolean
name|sparc64_elf_relocate_section
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|contents
parameter_list|,
name|relocs
parameter_list|,
name|local_syms
parameter_list|,
name|local_sections
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|local_syms
decl_stmt|;
name|asection
modifier|*
modifier|*
name|local_sections
decl_stmt|;
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|bfd_vma
modifier|*
name|local_got_offsets
decl_stmt|;
name|bfd_vma
name|got_base
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
name|asection
modifier|*
name|splt
decl_stmt|;
name|asection
modifier|*
name|sreloc
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relend
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|local_got_offsets
operator|=
name|elf_local_got_offsets
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|hgot
operator|==
name|NULL
condition|)
name|got_base
operator|=
literal|0
expr_stmt|;
else|else
name|got_base
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|hgot
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
name|sgot
operator|=
name|splt
operator|=
name|sreloc
operator|=
name|NULL
expr_stmt|;
name|rel
operator|=
name|relocs
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|NUM_SHDR_ENTRIES
argument_list|(
operator|&
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|rel_hdr
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|int
name|r_type
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|,
name|off
decl_stmt|;
name|bfd_reloc_status_type
name|r
decl_stmt|;
name|boolean
name|is_plt
init|=
name|false
decl_stmt|;
name|boolean
name|unresolved_reloc
decl_stmt|;
name|r_type
operator|=
name|ELF64_R_TYPE_ID
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|<
literal|0
operator|||
name|r_type
operator|>=
operator|(
name|int
operator|)
name|R_SPARC_max_std
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|howto
operator|=
name|sparc64_elf_howto_table
operator|+
name|r_type
expr_stmt|;
name|r_symndx
operator|=
name|ELF64_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|relocateable
condition|)
block|{
comment|/* This is a relocateable link.  We don't have to change 	     anything, unless the reloc is against a section symbol, 	     in which case we have to adjust according to where the 	     section symbol winds up in the output section.  */
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_SECTION
condition|)
block|{
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|rel
operator|->
name|r_addend
operator|+=
name|sec
operator|->
name|output_offset
operator|+
name|sym
operator|->
name|st_value
expr_stmt|;
block|}
block|}
continue|continue;
block|}
comment|/* This is a final link.  */
name|h
operator|=
name|NULL
expr_stmt|;
name|sym
operator|=
name|NULL
expr_stmt|;
name|sec
operator|=
name|NULL
expr_stmt|;
name|unresolved_reloc
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|relocation
operator|=
name|_bfd_elf_rela_local_sym
argument_list|(
name|output_bfd
argument_list|,
name|sym
argument_list|,
name|sec
argument_list|,
name|rel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|relocation
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
block|{
name|sec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|output_section
operator|==
name|NULL
condition|)
comment|/* Set a flag that will be cleared later if we find a 		   relocation value for this symbol.  output_section 		   is typically NULL for symbols satisfied by a shared 		   library.  */
name|unresolved_reloc
operator|=
name|true
expr_stmt|;
else|else
name|relocation
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
operator|(
operator|!
name|info
operator|->
name|symbolic
operator|||
name|info
operator|->
name|allow_shlib_undefined
operator|)
operator|&&
operator|!
name|info
operator|->
name|no_undefined
operator|&&
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_DEFAULT
condition|)
empty_stmt|;
else|else
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
operator|(
operator|!
name|info
operator|->
name|shared
operator|||
name|info
operator|->
name|no_undefined
operator|||
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|)
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
comment|/* To avoid generating warning messages about truncated 		 relocations, set the relocation's address to be the same as 		 the start of this section.  */
if|if
condition|(
name|input_section
operator|->
name|output_section
operator|!=
name|NULL
condition|)
name|relocation
operator|=
name|input_section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
else|else
name|relocation
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|do_dynreloc
label|:
comment|/* When generating a shared object, these relocations are copied 	 into the output file to be resolved at run time.  */
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
name|r_symndx
operator|!=
literal|0
operator|&&
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
condition|)
block|{
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_SPARC_PC10
case|:
case|case
name|R_SPARC_PC22
case|:
case|case
name|R_SPARC_PC_HH22
case|:
case|case
name|R_SPARC_PC_HM10
case|:
case|case
name|R_SPARC_PC_LM22
case|:
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|!
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|)
condition|)
break|break;
comment|/* Fall through.  */
case|case
name|R_SPARC_DISP8
case|:
case|case
name|R_SPARC_DISP16
case|:
case|case
name|R_SPARC_DISP32
case|:
case|case
name|R_SPARC_DISP64
case|:
case|case
name|R_SPARC_WDISP30
case|:
case|case
name|R_SPARC_WDISP22
case|:
case|case
name|R_SPARC_WDISP19
case|:
case|case
name|R_SPARC_WDISP16
case|:
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
break|break;
comment|/* Fall through.  */
case|case
name|R_SPARC_8
case|:
case|case
name|R_SPARC_16
case|:
case|case
name|R_SPARC_32
case|:
case|case
name|R_SPARC_HI22
case|:
case|case
name|R_SPARC_22
case|:
case|case
name|R_SPARC_13
case|:
case|case
name|R_SPARC_LO10
case|:
case|case
name|R_SPARC_UA32
case|:
case|case
name|R_SPARC_10
case|:
case|case
name|R_SPARC_11
case|:
case|case
name|R_SPARC_64
case|:
case|case
name|R_SPARC_OLO10
case|:
case|case
name|R_SPARC_HH22
case|:
case|case
name|R_SPARC_HM10
case|:
case|case
name|R_SPARC_LM22
case|:
case|case
name|R_SPARC_7
case|:
case|case
name|R_SPARC_5
case|:
case|case
name|R_SPARC_6
case|:
case|case
name|R_SPARC_HIX22
case|:
case|case
name|R_SPARC_LOX10
case|:
case|case
name|R_SPARC_H44
case|:
case|case
name|R_SPARC_M44
case|:
case|case
name|R_SPARC_L44
case|:
case|case
name|R_SPARC_UA64
case|:
case|case
name|R_SPARC_UA16
case|:
block|{
name|Elf_Internal_Rela
name|outrel
decl_stmt|;
name|boolean
name|skip
decl_stmt|,
name|relocate
decl_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
operator|(
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|elf_elfheader
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|e_shstrndx
argument_list|,
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|rel_hdr
operator|.
name|sh_name
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|BFD_ASSERT
argument_list|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".rela"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
argument_list|,
name|name
operator|+
literal|5
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|sreloc
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sreloc
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
name|skip
operator|=
name|false
expr_stmt|;
name|relocate
operator|=
name|false
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|=
name|_bfd_elf_section_offset
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|outrel
operator|.
name|r_offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
name|skip
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|outrel
operator|.
name|r_offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|2
condition|)
name|skip
operator|=
name|true
operator|,
name|relocate
operator|=
name|true
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|+=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
comment|/* Optimize unaligned reloc usage now that we know where 		   it finally resides.  */
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_SPARC_16
case|:
if|if
condition|(
name|outrel
operator|.
name|r_offset
operator|&
literal|1
condition|)
name|r_type
operator|=
name|R_SPARC_UA16
expr_stmt|;
break|break;
case|case
name|R_SPARC_UA16
case|:
if|if
condition|(
operator|!
operator|(
name|outrel
operator|.
name|r_offset
operator|&
literal|1
operator|)
condition|)
name|r_type
operator|=
name|R_SPARC_16
expr_stmt|;
break|break;
case|case
name|R_SPARC_32
case|:
if|if
condition|(
name|outrel
operator|.
name|r_offset
operator|&
literal|3
condition|)
name|r_type
operator|=
name|R_SPARC_UA32
expr_stmt|;
break|break;
case|case
name|R_SPARC_UA32
case|:
if|if
condition|(
operator|!
operator|(
name|outrel
operator|.
name|r_offset
operator|&
literal|3
operator|)
condition|)
name|r_type
operator|=
name|R_SPARC_32
expr_stmt|;
break|break;
case|case
name|R_SPARC_64
case|:
if|if
condition|(
name|outrel
operator|.
name|r_offset
operator|&
literal|7
condition|)
name|r_type
operator|=
name|R_SPARC_UA64
expr_stmt|;
break|break;
case|case
name|R_SPARC_UA64
case|:
if|if
condition|(
operator|!
operator|(
name|outrel
operator|.
name|r_offset
operator|&
literal|7
operator|)
condition|)
name|r_type
operator|=
name|R_SPARC_64
expr_stmt|;
break|break;
case|case
name|R_SPARC_DISP8
case|:
case|case
name|R_SPARC_DISP16
case|:
case|case
name|R_SPARC_DISP32
case|:
case|case
name|R_SPARC_DISP64
case|:
comment|/* If the symbol is not dynamic, we should not keep 		       a dynamic relocation.  But an .rela.* slot has been 		       allocated for it, output R_SPARC_NONE. 		       FIXME: Add code tracking needed dynamic relocs as 		       e.g. i386 has.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
name|skip
operator|=
name|true
operator|,
name|relocate
operator|=
name|true
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|skip
condition|)
name|memset
argument_list|(
operator|&
name|outrel
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|outrel
argument_list|)
expr_stmt|;
comment|/* h->dynindx may be -1 if the symbol was marked to 		   become local.  */
elseif|else
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|!
name|is_plt
operator|&&
operator|(
operator|(
operator|!
name|info
operator|->
name|symbolic
operator|&&
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|)
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|ELF64_R_TYPE_INFO
argument_list|(
name|ELF64_R_TYPE_DATA
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
argument_list|,
name|r_type
argument_list|)
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
name|rel
operator|->
name|r_addend
expr_stmt|;
block|}
else|else
block|{
name|outrel
operator|.
name|r_addend
operator|=
name|relocation
operator|+
name|rel
operator|->
name|r_addend
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_SPARC_64
condition|)
name|outrel
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_SPARC_RELATIVE
argument_list|)
expr_stmt|;
else|else
block|{
name|long
name|indx
decl_stmt|;
if|if
condition|(
name|is_plt
condition|)
name|sec
operator|=
name|splt
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
else|else
block|{
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
argument_list|)
expr_stmt|;
name|sec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
block|}
if|if
condition|(
name|sec
operator|!=
name|NULL
operator|&&
name|bfd_is_abs_section
argument_list|(
name|sec
argument_list|)
condition|)
name|indx
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|sec
operator|==
name|NULL
operator|||
name|sec
operator|->
name|owner
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
else|else
block|{
name|asection
modifier|*
name|osec
decl_stmt|;
name|osec
operator|=
name|sec
operator|->
name|output_section
expr_stmt|;
name|indx
operator|=
name|elf_section_data
argument_list|(
name|osec
argument_list|)
operator|->
name|dynindx
expr_stmt|;
comment|/* We are turning this relocation into one 			       against a section symbol, so subtract out 			       the output section's address but not the 			       offset of the input section in the output 			       section.  */
name|outrel
operator|.
name|r_addend
operator|-=
name|osec
operator|->
name|vma
expr_stmt|;
comment|/* FIXME: we really should be able to link non-pic 			       shared libraries.  */
if|if
condition|(
name|indx
operator|==
literal|0
condition|)
block|{
name|BFD_FAIL
argument_list|()
expr_stmt|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: probably compiled without -fPIC?"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
name|outrel
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|indx
argument_list|,
name|ELF64_R_TYPE_INFO
argument_list|(
name|ELF64_R_TYPE_DATA
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
argument_list|,
name|r_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|bfd_elf64_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
operator|(
operator|(
operator|(
name|Elf64_External_Rela
operator|*
operator|)
name|sreloc
operator|->
name|contents
operator|)
operator|+
name|sreloc
operator|->
name|reloc_count
operator|)
argument_list|)
expr_stmt|;
operator|++
name|sreloc
operator|->
name|reloc_count
expr_stmt|;
comment|/* This reloc will be computed at runtime, so there's no 		   need to do anything now.  */
if|if
condition|(
operator|!
name|relocate
condition|)
continue|continue;
block|}
break|break;
block|}
block|}
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_SPARC_GOT10
case|:
case|case
name|R_SPARC_GOT13
case|:
case|case
name|R_SPARC_GOT22
case|:
comment|/* Relocation is to the entry for this symbol in the global 	     offset table.  */
if|if
condition|(
name|sgot
operator|==
name|NULL
condition|)
block|{
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|boolean
name|dyn
decl_stmt|;
name|off
operator|=
name|h
operator|->
name|got
operator|.
name|offset
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|off
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|dyn
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
expr_stmt|;
if|if
condition|(
operator|!
name|WILL_CALL_FINISH_DYNAMIC_SYMBOL
argument_list|(
name|dyn
argument_list|,
name|info
argument_list|,
name|h
argument_list|)
operator|||
operator|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|info
operator|->
name|symbolic
operator|||
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_FORCED_LOCAL
operator|)
operator|)
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|)
condition|)
block|{
comment|/* This is actually a static link, or it is a -Bsymbolic 		     link and the symbol is defined locally, or the symbol 		     was forced to be local because of a version file.  We 		     must initialize this entry in the global offset table. 		     Since the offset must always be a multiple of 8, we 		     use the least significant bit to record whether we 		     have initialized it already.  		     When doing a dynamic link, we create a .rela.got 		     relocation entry to initialize the value.  This is 		     done in the finish_dynamic_symbol routine.  */
if|if
condition|(
operator|(
name|off
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|off
operator|&=
operator|~
literal|1
expr_stmt|;
else|else
block|{
name|bfd_put_64
argument_list|(
name|output_bfd
argument_list|,
name|relocation
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|off
argument_list|)
expr_stmt|;
name|h
operator|->
name|got
operator|.
name|offset
operator||=
literal|1
expr_stmt|;
block|}
block|}
else|else
name|unresolved_reloc
operator|=
name|false
expr_stmt|;
block|}
else|else
block|{
name|BFD_ASSERT
argument_list|(
name|local_got_offsets
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|off
operator|=
name|local_got_offsets
index|[
name|r_symndx
index|]
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|off
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* The offset must always be a multiple of 8.  We use 		 the least significant bit to record whether we have 		 already processed this entry.  */
if|if
condition|(
operator|(
name|off
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|off
operator|&=
operator|~
literal|1
expr_stmt|;
else|else
block|{
name|local_got_offsets
index|[
name|r_symndx
index|]
operator||=
literal|1
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
name|asection
modifier|*
name|srelgot
decl_stmt|;
name|Elf_Internal_Rela
name|outrel
decl_stmt|;
comment|/* The Solaris 2.7 64-bit linker adds the contents 			 of the location to the value of the reloc. 			 Note this is different behaviour to the 			 32-bit linker, which both adds the contents 			 and ignores the addend.  So clear the location.  */
name|bfd_put_64
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|off
argument_list|)
expr_stmt|;
comment|/* We need to generate a R_SPARC_RELATIVE reloc 			 for the dynamic linker.  */
name|srelgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|srelgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|=
operator|(
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
name|off
operator|)
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_SPARC_RELATIVE
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
name|relocation
expr_stmt|;
name|bfd_elf64_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
operator|(
operator|(
operator|(
name|Elf64_External_Rela
operator|*
operator|)
name|srelgot
operator|->
name|contents
operator|)
operator|+
name|srelgot
operator|->
name|reloc_count
operator|)
argument_list|)
expr_stmt|;
operator|++
name|srelgot
operator|->
name|reloc_count
expr_stmt|;
block|}
else|else
name|bfd_put_64
argument_list|(
name|output_bfd
argument_list|,
name|relocation
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|off
argument_list|)
expr_stmt|;
block|}
block|}
name|relocation
operator|=
name|sgot
operator|->
name|output_offset
operator|+
name|off
operator|-
name|got_base
expr_stmt|;
goto|goto
name|do_default
goto|;
case|case
name|R_SPARC_WPLT30
case|:
case|case
name|R_SPARC_PLT32
case|:
case|case
name|R_SPARC_HIPLT22
case|:
case|case
name|R_SPARC_LOPLT10
case|:
case|case
name|R_SPARC_PCPLT32
case|:
case|case
name|R_SPARC_PCPLT22
case|:
case|case
name|R_SPARC_PCPLT10
case|:
case|case
name|R_SPARC_PLT64
case|:
comment|/* Relocation is to the entry for this symbol in the              procedure linkage table.  */
name|BFD_ASSERT
argument_list|(
name|h
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
comment|/* We didn't make a PLT entry for this symbol.  This 		 happens when statically linking PIC code, or when 		 using -Bsymbolic.  */
goto|goto
name|do_default
goto|;
block|}
if|if
condition|(
name|splt
operator|==
name|NULL
condition|)
block|{
name|splt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|splt
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
name|relocation
operator|=
operator|(
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|splt
operator|->
name|output_offset
operator|+
name|sparc64_elf_plt_entry_offset
argument_list|(
name|h
operator|->
name|plt
operator|.
name|offset
argument_list|)
operator|)
expr_stmt|;
name|unresolved_reloc
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_SPARC_WPLT30
condition|)
goto|goto
name|do_wplt30
goto|;
if|if
condition|(
name|r_type
operator|==
name|R_SPARC_PLT32
operator|||
name|r_type
operator|==
name|R_SPARC_PLT64
condition|)
block|{
name|r_type
operator|=
name|r_type
operator|==
name|R_SPARC_PLT32
condition|?
name|R_SPARC_32
else|:
name|R_SPARC_64
expr_stmt|;
name|is_plt
operator|=
name|true
expr_stmt|;
goto|goto
name|do_dynreloc
goto|;
block|}
goto|goto
name|do_default
goto|;
case|case
name|R_SPARC_OLO10
case|:
block|{
name|bfd_vma
name|x
decl_stmt|;
name|relocation
operator|+=
name|rel
operator|->
name|r_addend
expr_stmt|;
name|relocation
operator|=
operator|(
name|relocation
operator|&
literal|0x3ff
operator|)
operator|+
name|ELF64_R_TYPE_DATA
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|x
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
literal|0x1fff
operator|)
operator||
operator|(
name|relocation
operator|&
literal|0x1fff
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|r
operator|=
name|bfd_check_overflow
argument_list|(
name|howto
operator|->
name|complain_on_overflow
argument_list|,
name|howto
operator|->
name|bitsize
argument_list|,
name|howto
operator|->
name|rightshift
argument_list|,
name|bfd_arch_bits_per_address
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|relocation
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|R_SPARC_WDISP16
case|:
block|{
name|bfd_vma
name|x
decl_stmt|;
name|relocation
operator|+=
name|rel
operator|->
name|r_addend
expr_stmt|;
comment|/* Adjust for pc-relative-ness.  */
name|relocation
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|relocation
operator|-=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|x
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|x
operator|&=
operator|~
operator|(
name|bfd_vma
operator|)
literal|0x303fff
expr_stmt|;
name|x
operator||=
operator|(
operator|(
operator|(
operator|(
name|relocation
operator|>>
literal|2
operator|)
operator|&
literal|0xc000
operator|)
operator|<<
literal|6
operator|)
operator||
operator|(
operator|(
name|relocation
operator|>>
literal|2
operator|)
operator|&
literal|0x3fff
operator|)
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|r
operator|=
name|bfd_check_overflow
argument_list|(
name|howto
operator|->
name|complain_on_overflow
argument_list|,
name|howto
operator|->
name|bitsize
argument_list|,
name|howto
operator|->
name|rightshift
argument_list|,
name|bfd_arch_bits_per_address
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|relocation
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|R_SPARC_HIX22
case|:
block|{
name|bfd_vma
name|x
decl_stmt|;
name|relocation
operator|+=
name|rel
operator|->
name|r_addend
expr_stmt|;
name|relocation
operator|=
name|relocation
operator|^
name|MINUS_ONE
expr_stmt|;
name|x
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
literal|0x3fffff
operator|)
operator||
operator|(
operator|(
name|relocation
operator|>>
literal|10
operator|)
operator|&
literal|0x3fffff
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|r
operator|=
name|bfd_check_overflow
argument_list|(
name|howto
operator|->
name|complain_on_overflow
argument_list|,
name|howto
operator|->
name|bitsize
argument_list|,
name|howto
operator|->
name|rightshift
argument_list|,
name|bfd_arch_bits_per_address
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|relocation
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|R_SPARC_LOX10
case|:
block|{
name|bfd_vma
name|x
decl_stmt|;
name|relocation
operator|+=
name|rel
operator|->
name|r_addend
expr_stmt|;
name|relocation
operator|=
operator|(
name|relocation
operator|&
literal|0x3ff
operator|)
operator||
literal|0x1c00
expr_stmt|;
name|x
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
literal|0x1fff
operator|)
operator||
name|relocation
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|r
operator|=
name|bfd_reloc_ok
expr_stmt|;
block|}
break|break;
case|case
name|R_SPARC_WDISP30
case|:
name|do_wplt30
label|:
if|if
condition|(
name|SEC_DO_RELAX
argument_list|(
name|input_section
argument_list|)
operator|&&
name|rel
operator|->
name|r_offset
operator|+
literal|4
operator|<
name|input_section
operator|->
name|_raw_size
condition|)
block|{
define|#
directive|define
name|G0
value|0
define|#
directive|define
name|O7
value|15
define|#
directive|define
name|XCC
value|(2<< 20)
define|#
directive|define
name|COND
parameter_list|(
name|x
parameter_list|)
value|(((x)&0xf)<<25)
define|#
directive|define
name|CONDA
value|COND(0x8)
define|#
directive|define
name|INSN_BPA
value|(F2(0,1) | CONDA | BPRED | XCC)
define|#
directive|define
name|INSN_BA
value|(F2(0,2) | CONDA)
define|#
directive|define
name|INSN_OR
value|F3(2, 0x2, 0)
define|#
directive|define
name|INSN_NOP
value|F2(0,4)
name|bfd_vma
name|x
decl_stmt|,
name|y
decl_stmt|;
comment|/* If the instruction is a call with either: 		 restore 		 arithmetic instruction with rd == %o7 		 where rs1 != %o7 and rs2 if it is register != %o7 		 then we can optimize if the call destination is near 		 by changing the call into a branch always.  */
name|x
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|y
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|&
name|OP
argument_list|(
operator|~
literal|0
argument_list|)
operator|)
operator|==
name|OP
argument_list|(
literal|1
argument_list|)
operator|&&
operator|(
name|y
operator|&
name|OP
argument_list|(
operator|~
literal|0
argument_list|)
operator|)
operator|==
name|OP
argument_list|(
literal|2
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|y
operator|&
name|OP3
argument_list|(
operator|~
literal|0
argument_list|)
operator|)
operator|==
name|OP3
argument_list|(
literal|0x3d
argument_list|)
comment|/* restore */
operator|||
operator|(
operator|(
name|y
operator|&
name|OP3
argument_list|(
literal|0x28
argument_list|)
operator|)
operator|==
literal|0
comment|/* arithmetic */
operator|&&
operator|(
name|y
operator|&
name|RD
argument_list|(
operator|~
literal|0
argument_list|)
operator|)
operator|==
name|RD
argument_list|(
name|O7
argument_list|)
operator|)
operator|)
operator|&&
operator|(
name|y
operator|&
name|RS1
argument_list|(
operator|~
literal|0
argument_list|)
operator|)
operator|!=
name|RS1
argument_list|(
name|O7
argument_list|)
operator|&&
operator|(
operator|(
name|y
operator|&
name|F3I
argument_list|(
operator|~
literal|0
argument_list|)
operator|)
operator|||
operator|(
name|y
operator|&
name|RS2
argument_list|(
operator|~
literal|0
argument_list|)
operator|)
operator|!=
name|RS2
argument_list|(
name|O7
argument_list|)
operator|)
condition|)
block|{
name|bfd_vma
name|reloc
decl_stmt|;
name|reloc
operator|=
name|relocation
operator|+
name|rel
operator|->
name|r_addend
operator|-
name|rel
operator|->
name|r_offset
expr_stmt|;
name|reloc
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
if|if
condition|(
name|reloc
operator|&
literal|3
condition|)
goto|goto
name|do_default
goto|;
comment|/* Ensure the branch fits into simm22.  */
if|if
condition|(
operator|(
name|reloc
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
literal|0x7fffff
operator|)
operator|&&
operator|(
operator|(
name|reloc
operator||
literal|0x7fffff
operator|)
operator|!=
name|MINUS_ONE
operator|)
condition|)
goto|goto
name|do_default
goto|;
name|reloc
operator|>>=
literal|2
expr_stmt|;
comment|/* Check whether it fits into simm19.  */
if|if
condition|(
operator|(
name|reloc
operator|&
literal|0x3c0000
operator|)
operator|==
literal|0
operator|||
operator|(
name|reloc
operator|&
literal|0x3c0000
operator|)
operator|==
literal|0x3c0000
condition|)
name|x
operator|=
name|INSN_BPA
operator||
operator|(
name|reloc
operator|&
literal|0x7ffff
operator|)
expr_stmt|;
comment|/* ba,pt %xcc */
else|else
name|x
operator|=
name|INSN_BA
operator||
operator|(
name|reloc
operator|&
literal|0x3fffff
operator|)
expr_stmt|;
comment|/* ba */
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|r
operator|=
name|bfd_reloc_ok
expr_stmt|;
if|if
condition|(
name|rel
operator|->
name|r_offset
operator|>=
literal|4
operator|&&
operator|(
name|y
operator|&
operator|(
literal|0xffffffff
operator|^
name|RS1
argument_list|(
operator|~
literal|0
argument_list|)
operator|)
operator|)
operator|==
operator|(
name|INSN_OR
operator||
name|RD
argument_list|(
name|O7
argument_list|)
operator||
name|RS2
argument_list|(
name|G0
argument_list|)
operator|)
condition|)
block|{
name|bfd_vma
name|z
decl_stmt|;
name|unsigned
name|int
name|reg
decl_stmt|;
name|z
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|-
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|z
operator|&
operator|(
literal|0xffffffff
operator|^
name|RD
argument_list|(
operator|~
literal|0
argument_list|)
operator|)
operator|)
operator|!=
operator|(
name|INSN_OR
operator||
name|RS1
argument_list|(
name|O7
argument_list|)
operator||
name|RS2
argument_list|(
name|G0
argument_list|)
operator|)
condition|)
break|break;
comment|/* The sequence was 			     or %o7, %g0, %rN 			     call foo 			     or %rN, %g0, %o7  			     If call foo was replaced with ba, replace 			     or %rN, %g0, %o7 with nop.  */
name|reg
operator|=
operator|(
name|y
operator|&
name|RS1
argument_list|(
operator|~
literal|0
argument_list|)
operator|)
operator|>>
literal|14
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
operator|(
operator|(
name|z
operator|&
name|RD
argument_list|(
operator|~
literal|0
argument_list|)
operator|)
operator|>>
literal|25
operator|)
operator|||
name|reg
operator|==
name|G0
operator|||
name|reg
operator|==
name|O7
condition|)
break|break;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|INSN_NOP
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
comment|/* FALLTHROUGH */
default|default:
name|do_default
label|:
name|r
operator|=
name|_bfd_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|relocation
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Dynamic relocs are not propagated for SEC_DEBUGGING sections 	 because such sections are not SEC_ALLOC and thus ld.so will 	 not process them.  */
if|if
condition|(
name|unresolved_reloc
operator|&&
operator|!
operator|(
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_DEBUGGING
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|)
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s(%s+0x%lx): unresolvable relocation against symbol `%s'"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|bfd_get_section_name
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|rel
operator|->
name|r_offset
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|bfd_reloc_ok
case|:
break|break;
default|default:
case|case
name|bfd_reloc_outofrange
case|:
name|abort
argument_list|()
expr_stmt|;
case|case
name|bfd_reloc_overflow
case|:
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* The Solaris native linker silently disregards 	       overflows.  We don't, but this breaks stabs debugging 	       info, whose relocations are only 32-bits wide.  Ignore 	       overflows in this case.  */
if|if
condition|(
name|r_type
operator|==
name|R_SPARC_32
operator|&&
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_DEBUGGING
operator|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|bfd_section_name
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
argument_list|,
literal|".stab"
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|&&
name|howto
operator|->
name|pc_relative
condition|)
block|{
comment|/* Assume this is a call protected by other code that 		       detect the symbol is undefined.  If this is the case, 		       we can safely ignore the overflow.  If not, the 		       program is hosed anyway, and a little warning isn't 		       going to help.  */
break|break;
block|}
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
block|}
else|else
block|{
name|name
operator|=
operator|(
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_link
argument_list|,
name|sym
operator|->
name|st_name
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'\0'
condition|)
name|name
operator|=
name|bfd_section_name
argument_list|(
name|input_bfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|info
argument_list|,
name|name
argument_list|,
name|howto
operator|->
name|name
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
block|}
break|break;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Finish up dynamic symbol handling.  We set the contents of various    dynamic sections here.  */
end_comment

begin_function
specifier|static
name|boolean
name|sparc64_elf_finish_dynamic_symbol
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|h
parameter_list|,
name|sym
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
name|asection
modifier|*
name|splt
decl_stmt|;
name|asection
modifier|*
name|srela
decl_stmt|;
name|Elf_Internal_Rela
name|rela
decl_stmt|;
comment|/* This symbol has an entry in the PLT.  Set it up.  */
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|splt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
name|srela
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.plt"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|splt
operator|!=
name|NULL
operator|&&
name|srela
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Fill in the entry in the .rela.plt section.  */
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|<
name|LARGE_PLT_THRESHOLD
condition|)
block|{
name|rela
operator|.
name|r_offset
operator|=
name|sparc64_elf_plt_entry_offset
argument_list|(
name|h
operator|->
name|plt
operator|.
name|offset
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|bfd_vma
name|max
init|=
name|splt
operator|->
name|_raw_size
operator|/
name|PLT_ENTRY_SIZE
decl_stmt|;
name|rela
operator|.
name|r_offset
operator|=
name|sparc64_elf_plt_ptr_offset
argument_list|(
name|h
operator|->
name|plt
operator|.
name|offset
argument_list|,
name|max
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_addend
operator|=
operator|-
operator|(
name|sparc64_elf_plt_entry_offset
argument_list|(
name|h
operator|->
name|plt
operator|.
name|offset
argument_list|)
operator|+
literal|4
operator|)
operator|-
operator|(
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|splt
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
name|rela
operator|.
name|r_offset
operator|+=
operator|(
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|splt
operator|->
name|output_offset
operator|)
expr_stmt|;
name|rela
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_SPARC_JMP_SLOT
argument_list|)
expr_stmt|;
comment|/* Adjust for the first 4 reserved elements in the .plt section 	 when setting the offset in the .rela.plt section. 	 Sun forgot to read their own ABI and copied elf32-sparc behaviour, 	 thus .plt[4] has corresponding .rela.plt[0] and so on.  */
name|bfd_elf64_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rela
argument_list|,
operator|(
operator|(
name|Elf64_External_Rela
operator|*
operator|)
name|srela
operator|->
name|contents
operator|+
operator|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|-
literal|4
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Mark the symbol as undefined, rather than as defined in 	     the .plt section.  Leave the value alone.  */
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_UNDEF
expr_stmt|;
comment|/* If the symbol is weak, we do need to clear the value. 	     Otherwise, the PLT entry would provide a definition for 	     the symbol even if the symbol wasn't defined anywhere, 	     and so the symbol would never be NULL.  */
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_REF_REGULAR_NONWEAK
operator|)
operator|==
literal|0
condition|)
name|sym
operator|->
name|st_value
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
name|asection
modifier|*
name|sgot
decl_stmt|;
name|asection
modifier|*
name|srela
decl_stmt|;
name|Elf_Internal_Rela
name|rela
decl_stmt|;
comment|/* This symbol has an entry in the GOT.  Set it up.  */
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
name|srela
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
operator|&&
name|srela
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_offset
operator|=
operator|(
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
operator|(
name|h
operator|->
name|got
operator|.
name|offset
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
literal|1
operator|)
operator|)
expr_stmt|;
comment|/* If this is a -Bsymbolic link, and the symbol is defined 	 locally, we just want to emit a RELATIVE reloc.  Likewise if 	 the symbol was forced to be local because of a version file. 	 The entry in the global offset table will already have been 	 initialized in the relocate_section function.  */
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|info
operator|->
name|symbolic
operator|||
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
condition|)
block|{
name|asection
modifier|*
name|sec
init|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
decl_stmt|;
name|rela
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_SPARC_RELATIVE
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_addend
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
else|else
block|{
name|bfd_put_64
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|h
operator|->
name|got
operator|.
name|offset
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_SPARC_GLOB_DAT
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
block|}
name|bfd_elf64_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rela
argument_list|,
operator|(
operator|(
name|Elf64_External_Rela
operator|*
operator|)
name|srela
operator|->
name|contents
operator|+
name|srela
operator|->
name|reloc_count
operator|)
argument_list|)
expr_stmt|;
operator|++
name|srela
operator|->
name|reloc_count
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_NEEDS_COPY
operator|)
operator|!=
literal|0
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|Elf_Internal_Rela
name|rela
decl_stmt|;
comment|/* This symbols needs a copy reloc.  Set it up.  */
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
argument_list|,
literal|".rela.bss"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_offset
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|rela
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_SPARC_COPY
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
name|bfd_elf64_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rela
argument_list|,
operator|(
operator|(
name|Elf64_External_Rela
operator|*
operator|)
name|s
operator|->
name|contents
operator|+
name|s
operator|->
name|reloc_count
operator|)
argument_list|)
expr_stmt|;
operator|++
name|s
operator|->
name|reloc_count
expr_stmt|;
block|}
comment|/* Mark some specially defined symbols as absolute.  */
if|if
condition|(
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_DYNAMIC"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_PROCEDURE_LINKAGE_TABLE_"
argument_list|)
operator|==
literal|0
condition|)
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_ABS
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Finish up the dynamic sections.  */
end_comment

begin_function
specifier|static
name|boolean
name|sparc64_elf_finish_dynamic_sections
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|int
name|stt_regidx
init|=
operator|-
literal|1
decl_stmt|;
name|asection
modifier|*
name|sdyn
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|sdyn
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
name|asection
modifier|*
name|splt
decl_stmt|;
name|Elf64_External_Dyn
modifier|*
name|dyncon
decl_stmt|,
modifier|*
name|dynconend
decl_stmt|;
name|splt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|splt
operator|!=
name|NULL
operator|&&
name|sdyn
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dyncon
operator|=
operator|(
name|Elf64_External_Dyn
operator|*
operator|)
name|sdyn
operator|->
name|contents
expr_stmt|;
name|dynconend
operator|=
operator|(
name|Elf64_External_Dyn
operator|*
operator|)
operator|(
name|sdyn
operator|->
name|contents
operator|+
name|sdyn
operator|->
name|_raw_size
operator|)
expr_stmt|;
for|for
control|(
init|;
name|dyncon
operator|<
name|dynconend
condition|;
name|dyncon
operator|++
control|)
block|{
name|Elf_Internal_Dyn
name|dyn
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|boolean
name|size
decl_stmt|;
name|bfd_elf64_swap_dyn_in
argument_list|(
name|dynobj
argument_list|,
name|dyncon
argument_list|,
operator|&
name|dyn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dyn
operator|.
name|d_tag
condition|)
block|{
case|case
name|DT_PLTGOT
case|:
name|name
operator|=
literal|".plt"
expr_stmt|;
name|size
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|DT_PLTRELSZ
case|:
name|name
operator|=
literal|".rela.plt"
expr_stmt|;
name|size
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|DT_JMPREL
case|:
name|name
operator|=
literal|".rela.plt"
expr_stmt|;
name|size
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|DT_SPARC_REGISTER
case|:
if|if
condition|(
name|stt_regidx
operator|==
operator|-
literal|1
condition|)
block|{
name|stt_regidx
operator|=
name|_bfd_elf_link_lookup_local_dynindx
argument_list|(
name|info
argument_list|,
name|output_bfd
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|stt_regidx
operator|==
operator|-
literal|1
condition|)
return|return
name|false
return|;
block|}
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|stt_regidx
operator|++
expr_stmt|;
name|bfd_elf64_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
comment|/* fallthrough */
default|default:
name|name
operator|=
name|NULL
expr_stmt|;
name|size
operator|=
name|false
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|size
condition|)
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|s
operator|->
name|vma
expr_stmt|;
else|else
block|{
if|if
condition|(
name|s
operator|->
name|_cooked_size
operator|!=
literal|0
condition|)
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|s
operator|->
name|_cooked_size
expr_stmt|;
else|else
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
block|}
block|}
name|bfd_elf64_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Initialize the contents of the .plt section.  */
if|if
condition|(
name|splt
operator|->
name|_raw_size
operator|>
literal|0
condition|)
block|{
name|sparc64_elf_build_plt
argument_list|(
name|output_bfd
argument_list|,
name|splt
operator|->
name|contents
argument_list|,
call|(
name|int
call|)
argument_list|(
name|splt
operator|->
name|_raw_size
operator|/
name|PLT_ENTRY_SIZE
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|elf_section_data
argument_list|(
name|splt
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
operator|=
name|PLT_ENTRY_SIZE
expr_stmt|;
block|}
comment|/* Set the first entry in the global offset table to the address of      the dynamic section.  */
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sgot
operator|->
name|_raw_size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|sdyn
operator|==
name|NULL
condition|)
name|bfd_put_64
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|sgot
operator|->
name|contents
argument_list|)
expr_stmt|;
else|else
name|bfd_put_64
argument_list|(
name|output_bfd
argument_list|,
name|sdyn
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sdyn
operator|->
name|output_offset
argument_list|,
name|sgot
operator|->
name|contents
argument_list|)
expr_stmt|;
block|}
name|elf_section_data
argument_list|(
name|sgot
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
operator|=
literal|8
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|elf_reloc_type_class
name|sparc64_elf_reloc_type_class
parameter_list|(
name|rela
parameter_list|)
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rela
decl_stmt|;
block|{
switch|switch
condition|(
operator|(
name|int
operator|)
name|ELF64_R_TYPE
argument_list|(
name|rela
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_SPARC_RELATIVE
case|:
return|return
name|reloc_class_relative
return|;
case|case
name|R_SPARC_JMP_SLOT
case|:
return|return
name|reloc_class_plt
return|;
case|case
name|R_SPARC_COPY
case|:
return|return
name|reloc_class_copy
return|;
default|default:
return|return
name|reloc_class_normal
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Functions for dealing with the e_flags field.  */
end_comment

begin_comment
comment|/* Merge backend specific data from an object file to the output    object file when linking.  */
end_comment

begin_function
specifier|static
name|boolean
name|sparc64_elf_merge_private_bfd_data
parameter_list|(
name|ibfd
parameter_list|,
name|obfd
parameter_list|)
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|bfd
modifier|*
name|obfd
decl_stmt|;
block|{
name|boolean
name|error
decl_stmt|;
name|flagword
name|new_flags
decl_stmt|,
name|old_flags
decl_stmt|;
name|int
name|new_mm
decl_stmt|,
name|old_mm
decl_stmt|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|ibfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
operator|||
name|bfd_get_flavour
argument_list|(
name|obfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
return|return
name|true
return|;
name|new_flags
operator|=
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
name|old_flags
operator|=
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
if|if
condition|(
operator|!
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
condition|)
comment|/* First call, no flags set */
block|{
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
operator|=
name|true
expr_stmt|;
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|=
name|new_flags
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|new_flags
operator|==
name|old_flags
condition|)
comment|/* Compatible flags are ok */
empty_stmt|;
else|else
comment|/* Incompatible flags */
block|{
name|error
operator|=
name|false
expr_stmt|;
define|#
directive|define
name|EF_SPARC_ISA_EXTENSIONS
define|\
value|(EF_SPARC_SUN_US1 | EF_SPARC_SUN_US3 | EF_SPARC_HAL_R1)
if|if
condition|(
operator|(
name|ibfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* We don't want dynamic objects memory ordering and 	     architecture to have any role. That's what dynamic linker 	     should do.  */
name|new_flags
operator|&=
operator|~
operator|(
name|EF_SPARCV9_MM
operator||
name|EF_SPARC_ISA_EXTENSIONS
operator|)
expr_stmt|;
name|new_flags
operator||=
operator|(
name|old_flags
operator|&
operator|(
name|EF_SPARCV9_MM
operator||
name|EF_SPARC_ISA_EXTENSIONS
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Choose the highest architecture requirements.  */
name|old_flags
operator||=
operator|(
name|new_flags
operator|&
name|EF_SPARC_ISA_EXTENSIONS
operator|)
expr_stmt|;
name|new_flags
operator||=
operator|(
name|old_flags
operator|&
name|EF_SPARC_ISA_EXTENSIONS
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|old_flags
operator|&
operator|(
name|EF_SPARC_SUN_US1
operator||
name|EF_SPARC_SUN_US3
operator|)
operator|)
operator|&&
operator|(
name|old_flags
operator|&
name|EF_SPARC_HAL_R1
operator|)
condition|)
block|{
name|error
operator|=
name|true
expr_stmt|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: linking UltraSPARC specific with HAL specific code"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Choose the most restrictive memory ordering.  */
name|old_mm
operator|=
operator|(
name|old_flags
operator|&
name|EF_SPARCV9_MM
operator|)
expr_stmt|;
name|new_mm
operator|=
operator|(
name|new_flags
operator|&
name|EF_SPARCV9_MM
operator|)
expr_stmt|;
name|old_flags
operator|&=
operator|~
name|EF_SPARCV9_MM
expr_stmt|;
name|new_flags
operator|&=
operator|~
name|EF_SPARCV9_MM
expr_stmt|;
if|if
condition|(
name|new_mm
operator|<
name|old_mm
condition|)
name|old_mm
operator|=
name|new_mm
expr_stmt|;
name|old_flags
operator||=
name|old_mm
expr_stmt|;
name|new_flags
operator||=
name|old_mm
expr_stmt|;
block|}
comment|/* Warn about any other mismatches */
if|if
condition|(
name|new_flags
operator|!=
name|old_flags
condition|)
block|{
name|error
operator|=
name|true
expr_stmt|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: uses different e_flags (0x%lx) fields than previous modules (0x%lx)"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|new_flags
argument_list|,
operator|(
name|long
operator|)
name|old_flags
argument_list|)
expr_stmt|;
block|}
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|=
name|old_flags
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* MARCO: Set the correct entry size for the .stab section.  */
end_comment

begin_function
specifier|static
name|boolean
name|sparc64_elf_fake_sections
parameter_list|(
name|abfd
parameter_list|,
name|hdr
parameter_list|,
name|sec
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|Elf32_Internal_Shdr
modifier|*
name|hdr
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".stab"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Even in the 64bit case the stab entries are only 12 bytes long.  */
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
operator|=
literal|12
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print a STT_REGISTER symbol to file FILE.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|sparc64_elf_print_symbol_all
parameter_list|(
name|abfd
parameter_list|,
name|filep
parameter_list|,
name|symbol
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|PTR
name|filep
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
block|{
name|FILE
modifier|*
name|file
init|=
operator|(
name|FILE
operator|*
operator|)
name|filep
decl_stmt|;
name|int
name|reg
decl_stmt|,
name|type
decl_stmt|;
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
operator|(
operator|(
name|elf_symbol_type
operator|*
operator|)
name|symbol
operator|)
operator|->
name|internal_elf_sym
operator|.
name|st_info
argument_list|)
operator|!=
name|STT_REGISTER
condition|)
return|return
name|NULL
return|;
name|reg
operator|=
operator|(
operator|(
name|elf_symbol_type
operator|*
operator|)
name|symbol
operator|)
operator|->
name|internal_elf_sym
operator|.
name|st_value
expr_stmt|;
name|type
operator|=
name|symbol
operator|->
name|flags
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"REG_%c%c%11s%c%c    R"
argument_list|,
literal|"GOLI"
index|[
name|reg
operator|/
literal|8
index|]
argument_list|,
literal|'0'
operator|+
operator|(
name|reg
operator|&
literal|7
operator|)
argument_list|,
literal|""
argument_list|,
operator|(
operator|(
name|type
operator|&
name|BSF_LOCAL
operator|)
condition|?
operator|(
name|type
operator|&
name|BSF_GLOBAL
operator|)
condition|?
literal|'!'
else|:
literal|'l'
else|:
operator|(
name|type
operator|&
name|BSF_GLOBAL
operator|)
condition|?
literal|'g'
else|:
literal|' '
operator|)
argument_list|,
operator|(
name|type
operator|&
name|BSF_WEAK
operator|)
condition|?
literal|'w'
else|:
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbol
operator|->
name|name
operator|==
name|NULL
operator|||
name|symbol
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
literal|"#scratch"
return|;
else|else
return|return
name|symbol
operator|->
name|name
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set the right machine number for a SPARC64 ELF file.  */
end_comment

begin_function
specifier|static
name|boolean
name|sparc64_elf_object_p
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|unsigned
name|long
name|mach
init|=
name|bfd_mach_sparc_v9
decl_stmt|;
if|if
condition|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_SPARC_SUN_US3
condition|)
name|mach
operator|=
name|bfd_mach_sparc_v9b
expr_stmt|;
elseif|else
if|if
condition|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_SPARC_SUN_US1
condition|)
name|mach
operator|=
name|bfd_mach_sparc_v9a
expr_stmt|;
return|return
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_sparc
argument_list|,
name|mach
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Relocations in the 64 bit SPARC ELF ABI are more complex than in    standard ELF, because R_SPARC_OLO10 has secondary addend in    ELF64_R_TYPE_DATA field.  This structure is used to redirect the    relocation handling routines.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|elf_size_info
name|sparc64_elf_size_info
init|=
block|{
sizeof|sizeof
argument_list|(
name|Elf64_External_Ehdr
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|Elf64_External_Phdr
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|Elf64_External_Shdr
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|Elf64_External_Rel
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|Elf64_External_Sym
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|Elf64_External_Dyn
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|Elf_External_Note
argument_list|)
block|,
literal|4
block|,
comment|/* hash-table entry size */
comment|/* internal relocations per external relocations.      For link purposes we use just 1 internal per      1 external, for assembly and slurp symbol table      we use 2.  */
literal|1
block|,
literal|64
block|,
comment|/* arch_size */
literal|8
block|,
comment|/* file_align */
name|ELFCLASS64
block|,
name|EV_CURRENT
block|,
name|bfd_elf64_write_out_phdrs
block|,
name|bfd_elf64_write_shdrs_and_ehdr
block|,
name|sparc64_elf_write_relocs
block|,
name|bfd_elf64_swap_symbol_in
block|,
name|bfd_elf64_swap_symbol_out
block|,
name|sparc64_elf_slurp_reloc_table
block|,
name|bfd_elf64_slurp_symbol_table
block|,
name|bfd_elf64_swap_dyn_in
block|,
name|bfd_elf64_swap_dyn_out
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TARGET_BIG_SYM
value|bfd_elf64_sparc_vec
end_define

begin_define
define|#
directive|define
name|TARGET_BIG_NAME
value|"elf64-sparc"
end_define

begin_define
define|#
directive|define
name|ELF_ARCH
value|bfd_arch_sparc
end_define

begin_define
define|#
directive|define
name|ELF_MAXPAGESIZE
value|0x100000
end_define

begin_comment
comment|/* This is the official ABI value.  */
end_comment

begin_define
define|#
directive|define
name|ELF_MACHINE_CODE
value|EM_SPARCV9
end_define

begin_comment
comment|/* This is the value that we used before the ABI was released.  */
end_comment

begin_define
define|#
directive|define
name|ELF_MACHINE_ALT1
value|EM_OLD_SPARCV9
end_define

begin_define
define|#
directive|define
name|bfd_elf64_bfd_link_hash_table_create
define|\
value|sparc64_elf_bfd_link_hash_table_create
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto
define|\
value|sparc64_elf_info_to_howto
end_define

begin_define
define|#
directive|define
name|bfd_elf64_get_reloc_upper_bound
define|\
value|sparc64_elf_get_reloc_upper_bound
end_define

begin_define
define|#
directive|define
name|bfd_elf64_get_dynamic_reloc_upper_bound
define|\
value|sparc64_elf_get_dynamic_reloc_upper_bound
end_define

begin_define
define|#
directive|define
name|bfd_elf64_canonicalize_dynamic_reloc
define|\
value|sparc64_elf_canonicalize_dynamic_reloc
end_define

begin_define
define|#
directive|define
name|bfd_elf64_bfd_reloc_type_lookup
define|\
value|sparc64_elf_reloc_type_lookup
end_define

begin_define
define|#
directive|define
name|bfd_elf64_bfd_relax_section
define|\
value|sparc64_elf_relax_section
end_define

begin_define
define|#
directive|define
name|elf_backend_create_dynamic_sections
define|\
value|_bfd_elf_create_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_add_symbol_hook
define|\
value|sparc64_elf_add_symbol_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_get_symbol_type
define|\
value|sparc64_elf_get_symbol_type
end_define

begin_define
define|#
directive|define
name|elf_backend_symbol_processing
define|\
value|sparc64_elf_symbol_processing
end_define

begin_define
define|#
directive|define
name|elf_backend_check_relocs
define|\
value|sparc64_elf_check_relocs
end_define

begin_define
define|#
directive|define
name|elf_backend_adjust_dynamic_symbol
define|\
value|sparc64_elf_adjust_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_size_dynamic_sections
define|\
value|sparc64_elf_size_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_relocate_section
define|\
value|sparc64_elf_relocate_section
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_symbol
define|\
value|sparc64_elf_finish_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_sections
define|\
value|sparc64_elf_finish_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_print_symbol_all
define|\
value|sparc64_elf_print_symbol_all
end_define

begin_define
define|#
directive|define
name|elf_backend_output_arch_syms
define|\
value|sparc64_elf_output_arch_syms
end_define

begin_define
define|#
directive|define
name|bfd_elf64_bfd_merge_private_bfd_data
define|\
value|sparc64_elf_merge_private_bfd_data
end_define

begin_define
define|#
directive|define
name|elf_backend_fake_sections
define|\
value|sparc64_elf_fake_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_size_info
define|\
value|sparc64_elf_size_info
end_define

begin_define
define|#
directive|define
name|elf_backend_object_p
define|\
value|sparc64_elf_object_p
end_define

begin_define
define|#
directive|define
name|elf_backend_reloc_type_class
define|\
value|sparc64_elf_reloc_type_class
end_define

begin_define
define|#
directive|define
name|elf_backend_want_got_plt
value|0
end_define

begin_define
define|#
directive|define
name|elf_backend_plt_readonly
value|0
end_define

begin_define
define|#
directive|define
name|elf_backend_want_plt_sym
value|1
end_define

begin_comment
comment|/* Section 5.2.4 of the ABI specifies a 256-byte boundary for the table.  */
end_comment

begin_define
define|#
directive|define
name|elf_backend_plt_alignment
value|8
end_define

begin_define
define|#
directive|define
name|elf_backend_got_header_size
value|8
end_define

begin_define
define|#
directive|define
name|elf_backend_plt_header_size
value|PLT_HEADER_SIZE
end_define

begin_include
include|#
directive|include
file|"elf64-target.h"
end_include

end_unit

