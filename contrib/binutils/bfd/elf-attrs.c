begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ELF attributes support (based on ARM EABI attributes).    Copyright 2005, 2006, 2007    Free Software Foundation, Inc.     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_comment
comment|/* Return the number of bytes needed by I in uleb128 format.  */
end_comment

begin_function
specifier|static
name|int
name|uleb128_size
parameter_list|(
name|unsigned
name|int
name|i
parameter_list|)
block|{
name|int
name|size
decl_stmt|;
name|size
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|i
operator|>=
literal|0x80
condition|)
block|{
name|i
operator|>>=
literal|7
expr_stmt|;
name|size
operator|++
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if the attribute has the default value (0/"").  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|is_default_attr
parameter_list|(
name|obj_attribute
modifier|*
name|attr
parameter_list|)
block|{
if|if
condition|(
operator|(
name|attr
operator|->
name|type
operator|&
literal|1
operator|)
operator|&&
name|attr
operator|->
name|i
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|(
name|attr
operator|->
name|type
operator|&
literal|2
operator|)
operator|&&
name|attr
operator|->
name|s
operator|&&
operator|*
name|attr
operator|->
name|s
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return the size of a single attribute.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|obj_attr_size
parameter_list|(
name|int
name|tag
parameter_list|,
name|obj_attribute
modifier|*
name|attr
parameter_list|)
block|{
name|bfd_vma
name|size
decl_stmt|;
if|if
condition|(
name|is_default_attr
argument_list|(
name|attr
argument_list|)
condition|)
return|return
literal|0
return|;
name|size
operator|=
name|uleb128_size
argument_list|(
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
operator|->
name|type
operator|&
literal|1
condition|)
name|size
operator|+=
name|uleb128_size
argument_list|(
name|attr
operator|->
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
operator|->
name|type
operator|&
literal|2
condition|)
name|size
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|attr
operator|->
name|s
argument_list|)
operator|+
literal|1
expr_stmt|;
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/* Return the vendor name for a given object attributes section.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|vendor_obj_attr_name
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|int
name|vendor
parameter_list|)
block|{
return|return
operator|(
name|vendor
operator|==
name|OBJ_ATTR_PROC
condition|?
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|obj_attrs_vendor
else|:
literal|"gnu"
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the size of the object attributes section for VENDOR    (OBJ_ATTR_PROC or OBJ_ATTR_GNU), or 0 if there are no attributes    for that vendor to record and the vendor is OBJ_ATTR_GNU.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|vendor_obj_attr_size
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|int
name|vendor
parameter_list|)
block|{
name|bfd_vma
name|size
decl_stmt|;
name|obj_attribute
modifier|*
name|attr
decl_stmt|;
name|obj_attribute_list
modifier|*
name|list
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|vendor_name
init|=
name|vendor_obj_attr_name
argument_list|(
name|abfd
argument_list|,
name|vendor
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|vendor_name
condition|)
return|return
literal|0
return|;
name|attr
operator|=
name|elf_known_obj_attributes
argument_list|(
name|abfd
argument_list|)
index|[
name|vendor
index|]
expr_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|4
init|;
name|i
operator|<
name|NUM_KNOWN_OBJ_ATTRIBUTES
condition|;
name|i
operator|++
control|)
name|size
operator|+=
name|obj_attr_size
argument_list|(
name|i
argument_list|,
operator|&
name|attr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|list
operator|=
name|elf_other_obj_attributes
argument_list|(
name|abfd
argument_list|)
index|[
name|vendor
index|]
init|;
name|list
condition|;
name|list
operator|=
name|list
operator|->
name|next
control|)
name|size
operator|+=
name|obj_attr_size
argument_list|(
name|list
operator|->
name|tag
argument_list|,
operator|&
name|list
operator|->
name|attr
argument_list|)
expr_stmt|;
comment|/*<size><vendor_name> NUL 0x1<size> */
return|return
operator|(
operator|(
name|size
operator|||
name|vendor
operator|==
name|OBJ_ATTR_PROC
operator|)
condition|?
name|size
operator|+
literal|10
operator|+
name|strlen
argument_list|(
name|vendor_name
argument_list|)
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the size of the object attributes section.  */
end_comment

begin_function
name|bfd_vma
name|bfd_elf_obj_attr_size
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|bfd_vma
name|size
decl_stmt|;
name|size
operator|=
name|vendor_obj_attr_size
argument_list|(
name|abfd
argument_list|,
name|OBJ_ATTR_PROC
argument_list|)
expr_stmt|;
name|size
operator|+=
name|vendor_obj_attr_size
argument_list|(
name|abfd
argument_list|,
name|OBJ_ATTR_GNU
argument_list|)
expr_stmt|;
comment|/* 'A'<sections for each vendor> */
return|return
operator|(
name|size
condition|?
name|size
operator|+
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Write VAL in uleb128 format to P, returning a pointer to the    following byte.  */
end_comment

begin_function
specifier|static
name|bfd_byte
modifier|*
name|write_uleb128
parameter_list|(
name|bfd_byte
modifier|*
name|p
parameter_list|,
name|unsigned
name|int
name|val
parameter_list|)
block|{
name|bfd_byte
name|c
decl_stmt|;
do|do
block|{
name|c
operator|=
name|val
operator|&
literal|0x7f
expr_stmt|;
name|val
operator|>>=
literal|7
expr_stmt|;
if|if
condition|(
name|val
condition|)
name|c
operator||=
literal|0x80
expr_stmt|;
operator|*
operator|(
name|p
operator|++
operator|)
operator|=
name|c
expr_stmt|;
block|}
do|while
condition|(
name|val
condition|)
do|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Write attribute ATTR to butter P, and return a pointer to the following    byte.  */
end_comment

begin_function
specifier|static
name|bfd_byte
modifier|*
name|write_obj_attribute
parameter_list|(
name|bfd_byte
modifier|*
name|p
parameter_list|,
name|int
name|tag
parameter_list|,
name|obj_attribute
modifier|*
name|attr
parameter_list|)
block|{
comment|/* Suppress default entries.  */
if|if
condition|(
name|is_default_attr
argument_list|(
name|attr
argument_list|)
condition|)
return|return
name|p
return|;
name|p
operator|=
name|write_uleb128
argument_list|(
name|p
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
operator|->
name|type
operator|&
literal|1
condition|)
name|p
operator|=
name|write_uleb128
argument_list|(
name|p
argument_list|,
name|attr
operator|->
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
operator|->
name|type
operator|&
literal|2
condition|)
block|{
name|int
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|attr
operator|->
name|s
argument_list|)
operator|+
literal|1
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|attr
operator|->
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|p
operator|+=
name|len
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Write the contents of the object attributes section (length SIZE)    for VENDOR to CONTENTS.  */
end_comment

begin_function
specifier|static
name|void
name|vendor_set_obj_attr_contents
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|bfd_vma
name|size
parameter_list|,
name|int
name|vendor
parameter_list|)
block|{
name|bfd_byte
modifier|*
name|p
decl_stmt|;
name|obj_attribute
modifier|*
name|attr
decl_stmt|;
name|obj_attribute_list
modifier|*
name|list
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|vendor_name
init|=
name|vendor_obj_attr_name
argument_list|(
name|abfd
argument_list|,
name|vendor
argument_list|)
decl_stmt|;
name|size_t
name|vendor_length
init|=
name|strlen
argument_list|(
name|vendor_name
argument_list|)
operator|+
literal|1
decl_stmt|;
name|p
operator|=
name|contents
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|vendor_name
argument_list|,
name|vendor_length
argument_list|)
expr_stmt|;
name|p
operator|+=
name|vendor_length
expr_stmt|;
operator|*
operator|(
name|p
operator|++
operator|)
operator|=
name|Tag_File
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|size
operator|-
literal|4
operator|-
name|vendor_length
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|attr
operator|=
name|elf_known_obj_attributes
argument_list|(
name|abfd
argument_list|)
index|[
name|vendor
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|4
init|;
name|i
operator|<
name|NUM_KNOWN_OBJ_ATTRIBUTES
condition|;
name|i
operator|++
control|)
name|p
operator|=
name|write_obj_attribute
argument_list|(
name|p
argument_list|,
name|i
argument_list|,
operator|&
name|attr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|list
operator|=
name|elf_other_obj_attributes
argument_list|(
name|abfd
argument_list|)
index|[
name|vendor
index|]
init|;
name|list
condition|;
name|list
operator|=
name|list
operator|->
name|next
control|)
name|p
operator|=
name|write_obj_attribute
argument_list|(
name|p
argument_list|,
name|list
operator|->
name|tag
argument_list|,
operator|&
name|list
operator|->
name|attr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write the contents of the object attributes section to CONTENTS.  */
end_comment

begin_function
name|void
name|bfd_elf_set_obj_attr_contents
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|bfd_vma
name|size
parameter_list|)
block|{
name|bfd_byte
modifier|*
name|p
decl_stmt|;
name|int
name|vendor
decl_stmt|;
name|bfd_vma
name|my_size
decl_stmt|;
name|p
operator|=
name|contents
expr_stmt|;
operator|*
operator|(
name|p
operator|++
operator|)
operator|=
literal|'A'
expr_stmt|;
name|my_size
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|vendor
operator|=
name|OBJ_ATTR_FIRST
init|;
name|vendor
operator|<=
name|OBJ_ATTR_LAST
condition|;
name|vendor
operator|++
control|)
block|{
name|bfd_vma
name|vendor_size
init|=
name|vendor_obj_attr_size
argument_list|(
name|abfd
argument_list|,
name|vendor
argument_list|)
decl_stmt|;
if|if
condition|(
name|vendor_size
condition|)
name|vendor_set_obj_attr_contents
argument_list|(
name|abfd
argument_list|,
name|p
argument_list|,
name|vendor_size
argument_list|,
name|vendor
argument_list|)
expr_stmt|;
name|p
operator|+=
name|vendor_size
expr_stmt|;
name|my_size
operator|+=
name|vendor_size
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|!=
name|my_size
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocate/find an object attribute.  */
end_comment

begin_function
specifier|static
name|obj_attribute
modifier|*
name|elf_new_obj_attr
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|int
name|vendor
parameter_list|,
name|int
name|tag
parameter_list|)
block|{
name|obj_attribute
modifier|*
name|attr
decl_stmt|;
name|obj_attribute_list
modifier|*
name|list
decl_stmt|;
name|obj_attribute_list
modifier|*
name|p
decl_stmt|;
name|obj_attribute_list
modifier|*
modifier|*
name|lastp
decl_stmt|;
if|if
condition|(
name|tag
operator|<
name|NUM_KNOWN_OBJ_ATTRIBUTES
condition|)
block|{
comment|/* Knwon tags are preallocated.  */
name|attr
operator|=
operator|&
name|elf_known_obj_attributes
argument_list|(
name|abfd
argument_list|)
index|[
name|vendor
index|]
index|[
name|tag
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* Create a new tag.  */
name|list
operator|=
operator|(
name|obj_attribute_list
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|obj_attribute_list
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|list
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|obj_attribute_list
argument_list|)
argument_list|)
expr_stmt|;
name|list
operator|->
name|tag
operator|=
name|tag
expr_stmt|;
comment|/* Keep the tag list in order.  */
name|lastp
operator|=
operator|&
name|elf_other_obj_attributes
argument_list|(
name|abfd
argument_list|)
index|[
name|vendor
index|]
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|*
name|lastp
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|tag
operator|<
name|p
operator|->
name|tag
condition|)
break|break;
name|lastp
operator|=
operator|&
name|p
operator|->
name|next
expr_stmt|;
block|}
name|list
operator|->
name|next
operator|=
operator|*
name|lastp
expr_stmt|;
operator|*
name|lastp
operator|=
name|list
expr_stmt|;
name|attr
operator|=
operator|&
name|list
operator|->
name|attr
expr_stmt|;
block|}
return|return
name|attr
return|;
block|}
end_function

begin_comment
comment|/* Return the value of an integer object attribute.  */
end_comment

begin_function
name|int
name|bfd_elf_get_obj_attr_int
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|int
name|vendor
parameter_list|,
name|int
name|tag
parameter_list|)
block|{
name|obj_attribute_list
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|tag
operator|<
name|NUM_KNOWN_OBJ_ATTRIBUTES
condition|)
block|{
comment|/* Knwon tags are preallocated.  */
return|return
name|elf_known_obj_attributes
argument_list|(
name|abfd
argument_list|)
index|[
name|vendor
index|]
index|[
name|tag
index|]
operator|.
name|i
return|;
block|}
else|else
block|{
for|for
control|(
name|p
operator|=
name|elf_other_obj_attributes
argument_list|(
name|abfd
argument_list|)
index|[
name|vendor
index|]
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|tag
operator|==
name|p
operator|->
name|tag
condition|)
return|return
name|p
operator|->
name|attr
operator|.
name|i
return|;
if|if
condition|(
name|tag
operator|<
name|p
operator|->
name|tag
condition|)
break|break;
block|}
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Add an integer object attribute.  */
end_comment

begin_function
name|void
name|bfd_elf_add_obj_attr_int
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|int
name|vendor
parameter_list|,
name|int
name|tag
parameter_list|,
name|unsigned
name|int
name|i
parameter_list|)
block|{
name|obj_attribute
modifier|*
name|attr
decl_stmt|;
name|attr
operator|=
name|elf_new_obj_attr
argument_list|(
name|abfd
argument_list|,
name|vendor
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|attr
operator|->
name|type
operator|=
literal|1
expr_stmt|;
name|attr
operator|->
name|i
operator|=
name|i
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Duplicate an object attribute string value.  */
end_comment

begin_function
name|char
modifier|*
name|_bfd_elf_attr_strdup
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|memcpy
argument_list|(
name|p
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Add a string object attribute.  */
end_comment

begin_function
name|void
name|bfd_elf_add_obj_attr_string
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|int
name|vendor
parameter_list|,
name|int
name|tag
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|obj_attribute
modifier|*
name|attr
decl_stmt|;
name|attr
operator|=
name|elf_new_obj_attr
argument_list|(
name|abfd
argument_list|,
name|vendor
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|attr
operator|->
name|type
operator|=
literal|2
expr_stmt|;
name|attr
operator|->
name|s
operator|=
name|_bfd_elf_attr_strdup
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a Tag_compatibility object attribute.  */
end_comment

begin_function
name|void
name|bfd_elf_add_obj_attr_compat
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|int
name|vendor
parameter_list|,
name|unsigned
name|int
name|i
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|obj_attribute_list
modifier|*
name|list
decl_stmt|;
name|obj_attribute_list
modifier|*
name|p
decl_stmt|;
name|obj_attribute_list
modifier|*
modifier|*
name|lastp
decl_stmt|;
name|list
operator|=
operator|(
name|obj_attribute_list
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|obj_attribute_list
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|list
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|obj_attribute_list
argument_list|)
argument_list|)
expr_stmt|;
name|list
operator|->
name|tag
operator|=
name|Tag_compatibility
expr_stmt|;
name|list
operator|->
name|attr
operator|.
name|type
operator|=
literal|3
expr_stmt|;
name|list
operator|->
name|attr
operator|.
name|i
operator|=
name|i
expr_stmt|;
name|list
operator|->
name|attr
operator|.
name|s
operator|=
name|_bfd_elf_attr_strdup
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|lastp
operator|=
operator|&
name|elf_other_obj_attributes
argument_list|(
name|abfd
argument_list|)
index|[
name|vendor
index|]
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|*
name|lastp
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|int
name|cmp
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|tag
operator|!=
name|Tag_compatibility
condition|)
break|break;
name|cmp
operator|=
name|strcmp
argument_list|(
name|s
argument_list|,
name|p
operator|->
name|attr
operator|.
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
operator|||
operator|(
name|cmp
operator|==
literal|0
operator|&&
name|i
operator|<
name|p
operator|->
name|attr
operator|.
name|i
operator|)
condition|)
break|break;
name|lastp
operator|=
operator|&
name|p
operator|->
name|next
expr_stmt|;
block|}
name|list
operator|->
name|next
operator|=
operator|*
name|lastp
expr_stmt|;
operator|*
name|lastp
operator|=
name|list
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy the object attributes from IBFD to OBFD.  */
end_comment

begin_function
name|void
name|_bfd_elf_copy_obj_attributes
parameter_list|(
name|bfd
modifier|*
name|ibfd
parameter_list|,
name|bfd
modifier|*
name|obfd
parameter_list|)
block|{
name|obj_attribute
modifier|*
name|in_attr
decl_stmt|;
name|obj_attribute
modifier|*
name|out_attr
decl_stmt|;
name|obj_attribute_list
modifier|*
name|list
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|vendor
decl_stmt|;
for|for
control|(
name|vendor
operator|=
name|OBJ_ATTR_FIRST
init|;
name|vendor
operator|<=
name|OBJ_ATTR_LAST
condition|;
name|vendor
operator|++
control|)
block|{
name|in_attr
operator|=
operator|&
name|elf_known_obj_attributes
argument_list|(
name|ibfd
argument_list|)
index|[
name|vendor
index|]
index|[
literal|4
index|]
expr_stmt|;
name|out_attr
operator|=
operator|&
name|elf_known_obj_attributes
argument_list|(
name|obfd
argument_list|)
index|[
name|vendor
index|]
index|[
literal|4
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|4
init|;
name|i
operator|<
name|NUM_KNOWN_OBJ_ATTRIBUTES
condition|;
name|i
operator|++
control|)
block|{
name|out_attr
operator|->
name|type
operator|=
name|in_attr
operator|->
name|type
expr_stmt|;
name|out_attr
operator|->
name|i
operator|=
name|in_attr
operator|->
name|i
expr_stmt|;
if|if
condition|(
name|in_attr
operator|->
name|s
operator|&&
operator|*
name|in_attr
operator|->
name|s
condition|)
name|out_attr
operator|->
name|s
operator|=
name|_bfd_elf_attr_strdup
argument_list|(
name|obfd
argument_list|,
name|in_attr
operator|->
name|s
argument_list|)
expr_stmt|;
name|in_attr
operator|++
expr_stmt|;
name|out_attr
operator|++
expr_stmt|;
block|}
for|for
control|(
name|list
operator|=
name|elf_other_obj_attributes
argument_list|(
name|ibfd
argument_list|)
index|[
name|vendor
index|]
init|;
name|list
condition|;
name|list
operator|=
name|list
operator|->
name|next
control|)
block|{
name|in_attr
operator|=
operator|&
name|list
operator|->
name|attr
expr_stmt|;
switch|switch
condition|(
name|in_attr
operator|->
name|type
condition|)
block|{
case|case
literal|1
case|:
name|bfd_elf_add_obj_attr_int
argument_list|(
name|obfd
argument_list|,
name|vendor
argument_list|,
name|list
operator|->
name|tag
argument_list|,
name|in_attr
operator|->
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|bfd_elf_add_obj_attr_string
argument_list|(
name|obfd
argument_list|,
name|vendor
argument_list|,
name|list
operator|->
name|tag
argument_list|,
name|in_attr
operator|->
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|bfd_elf_add_obj_attr_compat
argument_list|(
name|obfd
argument_list|,
name|vendor
argument_list|,
name|in_attr
operator|->
name|i
argument_list|,
name|in_attr
operator|->
name|s
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Determine whether a GNU object attribute tag takes an integer, a    string or both.  */
end_comment

begin_function
specifier|static
name|int
name|gnu_obj_attrs_arg_type
parameter_list|(
name|int
name|tag
parameter_list|)
block|{
comment|/* Except for Tag_compatibility, for GNU attributes we follow the      same rule ARM ones> 32 follow: odd-numbered tags take strings      and even-numbered tags take integers.  In addition, tag& 2 is      nonzero for architecture-independent tags and zero for      architecture-dependent ones.  */
if|if
condition|(
name|tag
operator|==
name|Tag_compatibility
condition|)
return|return
literal|3
return|;
else|else
return|return
operator|(
name|tag
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|?
literal|2
else|:
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Determine what arguments an attribute tag takes.  */
end_comment

begin_function
name|int
name|_bfd_elf_obj_attrs_arg_type
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|int
name|vendor
parameter_list|,
name|int
name|tag
parameter_list|)
block|{
switch|switch
condition|(
name|vendor
condition|)
block|{
case|case
name|OBJ_ATTR_PROC
case|:
return|return
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|obj_attrs_arg_type
argument_list|(
name|tag
argument_list|)
return|;
break|break;
case|case
name|OBJ_ATTR_GNU
case|:
return|return
name|gnu_obj_attrs_arg_type
argument_list|(
name|tag
argument_list|)
return|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Parse an object attributes section.  */
end_comment

begin_function
name|void
name|_bfd_elf_parse_attributes
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Shdr
modifier|*
name|hdr
parameter_list|)
block|{
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|bfd_byte
modifier|*
name|p
decl_stmt|;
name|bfd_vma
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|std_section
decl_stmt|;
name|contents
operator|=
name|bfd_malloc
argument_list|(
name|hdr
operator|->
name|sh_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|contents
condition|)
return|return;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|bfd_section
argument_list|,
name|contents
argument_list|,
literal|0
argument_list|,
name|hdr
operator|->
name|sh_size
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
return|return;
block|}
name|p
operator|=
name|contents
expr_stmt|;
name|std_section
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|obj_attrs_vendor
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|p
operator|++
operator|)
operator|==
literal|'A'
condition|)
block|{
name|len
operator|=
name|hdr
operator|->
name|sh_size
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|int
name|namelen
decl_stmt|;
name|bfd_vma
name|section_len
decl_stmt|;
name|int
name|vendor
decl_stmt|;
name|section_len
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|section_len
operator|>
name|len
condition|)
name|section_len
operator|=
name|len
expr_stmt|;
name|len
operator|-=
name|section_len
expr_stmt|;
name|namelen
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
operator|+
literal|1
expr_stmt|;
name|section_len
operator|-=
name|namelen
operator|+
literal|4
expr_stmt|;
if|if
condition|(
name|std_section
operator|&&
name|strcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|,
name|std_section
argument_list|)
operator|==
literal|0
condition|)
name|vendor
operator|=
name|OBJ_ATTR_PROC
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|,
literal|"gnu"
argument_list|)
operator|==
literal|0
condition|)
name|vendor
operator|=
name|OBJ_ATTR_GNU
expr_stmt|;
else|else
block|{
comment|/* Other vendor section.  Ignore it.  */
name|p
operator|+=
name|namelen
operator|+
name|section_len
expr_stmt|;
continue|continue;
block|}
name|p
operator|+=
name|namelen
expr_stmt|;
while|while
condition|(
name|section_len
operator|>
literal|0
condition|)
block|{
name|int
name|tag
decl_stmt|;
name|unsigned
name|int
name|n
decl_stmt|;
name|unsigned
name|int
name|val
decl_stmt|;
name|bfd_vma
name|subsection_len
decl_stmt|;
name|bfd_byte
modifier|*
name|end
decl_stmt|;
name|tag
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|p
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|p
operator|+=
name|n
expr_stmt|;
name|subsection_len
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|subsection_len
operator|>
name|section_len
condition|)
name|subsection_len
operator|=
name|section_len
expr_stmt|;
name|section_len
operator|-=
name|subsection_len
expr_stmt|;
name|subsection_len
operator|-=
name|n
operator|+
literal|4
expr_stmt|;
name|end
operator|=
name|p
operator|+
name|subsection_len
expr_stmt|;
switch|switch
condition|(
name|tag
condition|)
block|{
case|case
name|Tag_File
case|:
while|while
condition|(
name|p
operator|<
name|end
condition|)
block|{
name|int
name|type
decl_stmt|;
name|tag
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|p
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|p
operator|+=
name|n
expr_stmt|;
name|type
operator|=
name|_bfd_elf_obj_attrs_arg_type
argument_list|(
name|abfd
argument_list|,
name|vendor
argument_list|,
name|tag
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|3
case|:
name|val
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|p
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|p
operator|+=
name|n
expr_stmt|;
name|bfd_elf_add_obj_attr_compat
argument_list|(
name|abfd
argument_list|,
name|vendor
argument_list|,
name|val
argument_list|,
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
operator|+
literal|1
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|bfd_elf_add_obj_attr_string
argument_list|(
name|abfd
argument_list|,
name|vendor
argument_list|,
name|tag
argument_list|,
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
operator|+
literal|1
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|val
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|p
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|p
operator|+=
name|n
expr_stmt|;
name|bfd_elf_add_obj_attr_int
argument_list|(
name|abfd
argument_list|,
name|vendor
argument_list|,
name|tag
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
break|break;
case|case
name|Tag_Section
case|:
case|case
name|Tag_Symbol
case|:
comment|/* Don't have anywhere convenient to attach these. 		     Fall through for now.  */
default|default:
comment|/* Ignore things we don't kow about.  */
name|p
operator|+=
name|subsection_len
expr_stmt|;
name|subsection_len
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Merge common object attributes from IBFD into OBFD.  Raise an error    if there are conflicting attributes.  Any processor-specific    attributes have already been merged.  This must be called from the    bfd_elfNN_bfd_merge_private_bfd_data hook for each individual    target, along with any target-specific merging.  Because there are    no common attributes other than Tag_compatibility at present, and    non-"gnu" Tag_compatibility is not expected in "gnu" sections, this    is not presently called for targets without their own    attributes.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_elf_merge_object_attributes
parameter_list|(
name|bfd
modifier|*
name|ibfd
parameter_list|,
name|bfd
modifier|*
name|obfd
parameter_list|)
block|{
name|obj_attribute
modifier|*
name|in_attr
decl_stmt|;
name|obj_attribute
modifier|*
name|out_attr
decl_stmt|;
name|obj_attribute_list
modifier|*
name|in_list
decl_stmt|;
name|obj_attribute_list
modifier|*
name|out_list
decl_stmt|;
name|int
name|vendor
decl_stmt|;
comment|/* The only common attribute is currently Tag_compatibility,      accepted in both processor and "gnu" sections.  */
for|for
control|(
name|vendor
operator|=
name|OBJ_ATTR_FIRST
init|;
name|vendor
operator|<=
name|OBJ_ATTR_LAST
condition|;
name|vendor
operator|++
control|)
block|{
name|in_list
operator|=
name|elf_other_obj_attributes
argument_list|(
name|ibfd
argument_list|)
index|[
name|vendor
index|]
expr_stmt|;
name|out_list
operator|=
name|elf_other_obj_attributes
argument_list|(
name|ibfd
argument_list|)
index|[
name|vendor
index|]
expr_stmt|;
while|while
condition|(
name|in_list
operator|&&
name|in_list
operator|->
name|tag
operator|==
name|Tag_compatibility
condition|)
block|{
name|in_attr
operator|=
operator|&
name|in_list
operator|->
name|attr
expr_stmt|;
if|if
condition|(
name|in_attr
operator|->
name|i
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|in_attr
operator|->
name|i
operator|==
literal|1
operator|&&
name|strcmp
argument_list|(
name|in_attr
operator|->
name|s
argument_list|,
literal|"gnu"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"ERROR: %B: Must be processed by '%s' toolchain"
argument_list|)
argument_list|,
name|ibfd
argument_list|,
name|in_attr
operator|->
name|s
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|out_list
operator|||
name|out_list
operator|->
name|tag
operator|!=
name|Tag_compatibility
operator|||
name|strcmp
argument_list|(
name|in_attr
operator|->
name|s
argument_list|,
name|out_list
operator|->
name|attr
operator|.
name|s
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Add this compatibility tag to the output.  */
name|bfd_elf_add_proc_attr_compat
argument_list|(
name|obfd
argument_list|,
name|in_attr
operator|->
name|i
argument_list|,
name|in_attr
operator|->
name|s
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|out_attr
operator|=
operator|&
name|out_list
operator|->
name|attr
expr_stmt|;
comment|/* Check all the input tags with the same identifier.  */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|out_list
operator|->
name|tag
operator|!=
name|Tag_compatibility
operator|||
name|in_attr
operator|->
name|i
operator|!=
name|out_attr
operator|->
name|i
operator|||
name|strcmp
argument_list|(
name|in_attr
operator|->
name|s
argument_list|,
name|out_attr
operator|->
name|s
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"ERROR: %B: Incompatible object tag '%s':%d"
argument_list|)
argument_list|,
name|ibfd
argument_list|,
name|in_attr
operator|->
name|s
argument_list|,
name|in_attr
operator|->
name|i
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|in_list
operator|=
name|in_list
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|in_list
operator|->
name|tag
operator|!=
name|Tag_compatibility
operator|||
name|strcmp
argument_list|(
name|in_attr
operator|->
name|s
argument_list|,
name|in_list
operator|->
name|attr
operator|.
name|s
argument_list|)
operator|!=
literal|0
condition|)
break|break;
name|in_attr
operator|=
operator|&
name|in_list
operator|->
name|attr
expr_stmt|;
name|out_list
operator|=
name|out_list
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|out_list
condition|)
name|out_attr
operator|=
operator|&
name|out_list
operator|->
name|attr
expr_stmt|;
block|}
comment|/* Check the output doesn't have extra tags with this identifier.  */
if|if
condition|(
name|out_list
operator|&&
name|out_list
operator|->
name|tag
operator|==
name|Tag_compatibility
operator|&&
name|strcmp
argument_list|(
name|in_attr
operator|->
name|s
argument_list|,
name|out_list
operator|->
name|attr
operator|.
name|s
argument_list|)
operator|==
literal|0
condition|)
block|{
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"ERROR: %B: Incompatible object tag '%s':%d"
argument_list|)
argument_list|,
name|ibfd
argument_list|,
name|in_attr
operator|->
name|s
argument_list|,
name|out_list
operator|->
name|attr
operator|.
name|i
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

end_unit

