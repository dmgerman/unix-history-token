begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* COFF specific linker code.    Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,    2004, 2005, 2006, 2007 Free Software Foundation, Inc.    Written by Ian Lance Taylor, Cygnus Support.     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* This file contains the COFF backend linker code.  */
end_comment

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"coff/internal.h"
end_include

begin_include
include|#
directive|include
file|"libcoff.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_function_decl
specifier|static
name|bfd_boolean
name|coff_link_add_object_symbols
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|coff_link_check_archive_element
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd_boolean
modifier|*
name|pneeded
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|coff_link_add_symbols
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Return TRUE if SYM is a weak, external symbol.  */
end_comment

begin_define
define|#
directive|define
name|IS_WEAK_EXTERNAL
parameter_list|(
name|abfd
parameter_list|,
name|sym
parameter_list|)
define|\
value|((sym).n_sclass == C_WEAKEXT				\    || (obj_pe (abfd)&& (sym).n_sclass == C_NT_WEAK))
end_define

begin_comment
comment|/* Return TRUE if SYM is an external symbol.  */
end_comment

begin_define
define|#
directive|define
name|IS_EXTERNAL
parameter_list|(
name|abfd
parameter_list|,
name|sym
parameter_list|)
define|\
value|((sym).n_sclass == C_EXT || IS_WEAK_EXTERNAL (abfd, sym))
end_define

begin_comment
comment|/* Define macros so that the ISFCN, et. al., macros work correctly.    These macros are defined in include/coff/internal.h in terms of    N_TMASK, etc.  These definitions require a user to define local    variables with the appropriate names, and with values from the    coff_data (abfd) structure.  */
end_comment

begin_define
define|#
directive|define
name|N_TMASK
value|n_tmask
end_define

begin_define
define|#
directive|define
name|N_BTSHFT
value|n_btshft
end_define

begin_define
define|#
directive|define
name|N_BTMASK
value|n_btmask
end_define

begin_comment
comment|/* Create an entry in a COFF linker hash table.  */
end_comment

begin_function
name|struct
name|bfd_hash_entry
modifier|*
name|_bfd_coff_link_hash_newfunc
parameter_list|(
name|struct
name|bfd_hash_entry
modifier|*
name|entry
parameter_list|,
name|struct
name|bfd_hash_table
modifier|*
name|table
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|struct
name|coff_link_hash_entry
modifier|*
name|ret
init|=
operator|(
expr|struct
name|coff_link_hash_entry
operator|*
operator|)
name|entry
decl_stmt|;
comment|/* Allocate the structure if it has not already been allocated by a      subclass.  */
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|coff_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
name|ret
operator|=
operator|(
operator|(
expr|struct
name|coff_link_hash_entry
operator|*
operator|)
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|coff_link_hash_entry
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|coff_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
comment|/* Call the allocation method of the superclass.  */
name|ret
operator|=
operator|(
operator|(
expr|struct
name|coff_link_hash_entry
operator|*
operator|)
name|_bfd_link_hash_newfunc
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
operator|(
expr|struct
name|coff_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* Set local fields.  */
name|ret
operator|->
name|indx
operator|=
operator|-
literal|1
expr_stmt|;
name|ret
operator|->
name|type
operator|=
name|T_NULL
expr_stmt|;
name|ret
operator|->
name|class
operator|=
name|C_NULL
expr_stmt|;
name|ret
operator|->
name|numaux
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|auxbfd
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Initialize a COFF linker hash table.  */
end_comment

begin_decl_stmt
name|bfd_boolean
name|_bfd_coff_link_hash_table_init
argument_list|(
expr|struct
name|coff_link_hash_table
operator|*
name|table
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|,
expr|struct
name|bfd_hash_entry
operator|*
call|(
modifier|*
name|newfunc
call|)
argument_list|(
expr|struct
name|bfd_hash_entry
operator|*
argument_list|,
expr|struct
name|bfd_hash_table
operator|*
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|,
name|unsigned
name|int
name|entsize
argument_list|)
block|{
name|memset
argument_list|(
operator|&
name|table
operator|->
name|stab_info
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|table
operator|->
name|stab_info
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|_bfd_link_hash_table_init
argument_list|(
operator|&
name|table
operator|->
name|root
argument_list|,
name|abfd
argument_list|,
name|newfunc
argument_list|,
name|entsize
argument_list|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Create a COFF linker hash table.  */
end_comment

begin_function
name|struct
name|bfd_link_hash_table
modifier|*
name|_bfd_coff_link_hash_table_create
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|struct
name|coff_link_hash_table
modifier|*
name|ret
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|coff_link_hash_table
argument_list|)
decl_stmt|;
name|ret
operator|=
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|_bfd_coff_link_hash_table_init
argument_list|(
name|ret
argument_list|,
name|abfd
argument_list|,
name|_bfd_coff_link_hash_newfunc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|coff_link_hash_entry
argument_list|)
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|bfd_link_hash_table
operator|*
operator|)
name|NULL
return|;
block|}
return|return
operator|&
name|ret
operator|->
name|root
return|;
block|}
end_function

begin_comment
comment|/* Create an entry in a COFF debug merge hash table.  */
end_comment

begin_function
name|struct
name|bfd_hash_entry
modifier|*
name|_bfd_coff_debug_merge_hash_newfunc
parameter_list|(
name|struct
name|bfd_hash_entry
modifier|*
name|entry
parameter_list|,
name|struct
name|bfd_hash_table
modifier|*
name|table
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|struct
name|coff_debug_merge_hash_entry
modifier|*
name|ret
init|=
operator|(
expr|struct
name|coff_debug_merge_hash_entry
operator|*
operator|)
name|entry
decl_stmt|;
comment|/* Allocate the structure if it has not already been allocated by a      subclass.  */
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|coff_debug_merge_hash_entry
operator|*
operator|)
name|NULL
condition|)
name|ret
operator|=
operator|(
operator|(
expr|struct
name|coff_debug_merge_hash_entry
operator|*
operator|)
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|coff_debug_merge_hash_entry
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|coff_debug_merge_hash_entry
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
comment|/* Call the allocation method of the superclass.  */
name|ret
operator|=
operator|(
operator|(
expr|struct
name|coff_debug_merge_hash_entry
operator|*
operator|)
name|bfd_hash_newfunc
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
operator|(
expr|struct
name|coff_debug_merge_hash_entry
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* Set local fields.  */
name|ret
operator|->
name|types
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Given a COFF BFD, add symbols to the global hash table as    appropriate.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_coff_link_add_symbols
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
switch|switch
condition|(
name|bfd_get_format
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
case|case
name|bfd_object
case|:
return|return
name|coff_link_add_object_symbols
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
return|;
case|case
name|bfd_archive
case|:
return|return
name|_bfd_generic_link_add_archive_symbols
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|coff_link_check_archive_element
argument_list|)
return|;
default|default:
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
end_function

begin_comment
comment|/* Add symbols from a COFF object file.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|coff_link_add_object_symbols
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
if|if
condition|(
operator|!
name|_bfd_coff_get_external_symbols
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|coff_link_add_symbols
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|info
operator|->
name|keep_memory
operator|&&
operator|!
name|_bfd_coff_free_symbols
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Look through the symbols to see if this object file should be    included in the link.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|coff_link_check_ar_symbols
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd_boolean
modifier|*
name|pneeded
parameter_list|)
block|{
name|bfd_size_type
name|symesz
decl_stmt|;
name|bfd_byte
modifier|*
name|esym
decl_stmt|;
name|bfd_byte
modifier|*
name|esym_end
decl_stmt|;
operator|*
name|pneeded
operator|=
name|FALSE
expr_stmt|;
name|symesz
operator|=
name|bfd_coff_symesz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|esym
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|obj_coff_external_syms
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|esym_end
operator|=
name|esym
operator|+
name|obj_raw_syment_count
argument_list|(
name|abfd
argument_list|)
operator|*
name|symesz
expr_stmt|;
while|while
condition|(
name|esym
operator|<
name|esym_end
condition|)
block|{
name|struct
name|internal_syment
name|sym
decl_stmt|;
name|enum
name|coff_symbol_classification
name|classification
decl_stmt|;
name|bfd_coff_swap_sym_in
argument_list|(
name|abfd
argument_list|,
name|esym
argument_list|,
operator|&
name|sym
argument_list|)
expr_stmt|;
name|classification
operator|=
name|bfd_coff_classify_symbol
argument_list|(
name|abfd
argument_list|,
operator|&
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|classification
operator|==
name|COFF_SYMBOL_GLOBAL
operator|||
name|classification
operator|==
name|COFF_SYMBOL_COMMON
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|buf
index|[
name|SYMNMLEN
operator|+
literal|1
index|]
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
comment|/* This symbol is externally visible, and is defined by this              object file.  */
name|name
operator|=
name|_bfd_coff_internal_syment_name
argument_list|(
name|abfd
argument_list|,
operator|&
name|sym
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|h
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|info
operator|->
name|hash
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* Auto import.  */
if|if
condition|(
operator|!
name|h
operator|&&
name|info
operator|->
name|pei386_auto_import
operator|&&
name|CONST_STRNEQ
argument_list|(
name|name
argument_list|,
literal|"__imp_"
argument_list|)
condition|)
name|h
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|info
operator|->
name|hash
argument_list|,
name|name
operator|+
literal|6
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* We are only interested in symbols that are currently 	     undefined.  If a symbol is currently known to be common, 	     COFF linkers do not bring in an object file which defines 	     it.  */
if|if
condition|(
name|h
operator|!=
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|)
name|NULL
operator|&&
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_undefined
condition|)
block|{
if|if
condition|(
operator|!
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|add_archive_element
call|)
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|FALSE
return|;
operator|*
name|pneeded
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
name|esym
operator|+=
operator|(
name|sym
operator|.
name|n_numaux
operator|+
literal|1
operator|)
operator|*
name|symesz
expr_stmt|;
block|}
comment|/* We do not need this object file.  */
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Check a single archive element to see if we need to include it in    the link.  *PNEEDED is set according to whether this element is    needed in the link or not.  This is called via    _bfd_generic_link_add_archive_symbols.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|coff_link_check_archive_element
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd_boolean
modifier|*
name|pneeded
parameter_list|)
block|{
if|if
condition|(
operator|!
name|_bfd_coff_get_external_symbols
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|coff_link_check_ar_symbols
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|pneeded
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|*
name|pneeded
operator|&&
operator|!
name|coff_link_add_symbols
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|(
operator|!
name|info
operator|->
name|keep_memory
operator|||
operator|!
operator|*
name|pneeded
operator|)
operator|&&
operator|!
name|_bfd_coff_free_symbols
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Add all the symbols from an object file to the hash table.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|coff_link_add_symbols
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|unsigned
name|int
name|n_tmask
init|=
name|coff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|local_n_tmask
decl_stmt|;
name|unsigned
name|int
name|n_btshft
init|=
name|coff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|local_n_btshft
decl_stmt|;
name|unsigned
name|int
name|n_btmask
init|=
name|coff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|local_n_btmask
decl_stmt|;
name|bfd_boolean
name|keep_syms
decl_stmt|;
name|bfd_boolean
name|default_copy
decl_stmt|;
name|bfd_size_type
name|symcount
decl_stmt|;
name|struct
name|coff_link_hash_entry
modifier|*
modifier|*
name|sym_hash
decl_stmt|;
name|bfd_size_type
name|symesz
decl_stmt|;
name|bfd_byte
modifier|*
name|esym
decl_stmt|;
name|bfd_byte
modifier|*
name|esym_end
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
comment|/* Keep the symbols during this function, in case the linker needs      to read the generic symbols in order to report an error message.  */
name|keep_syms
operator|=
name|obj_coff_keep_syms
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|obj_coff_keep_syms
argument_list|(
name|abfd
argument_list|)
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|keep_memory
condition|)
name|default_copy
operator|=
name|FALSE
expr_stmt|;
else|else
name|default_copy
operator|=
name|TRUE
expr_stmt|;
name|symcount
operator|=
name|obj_raw_syment_count
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* We keep a list of the linker hash table entries that correspond      to particular symbols.  */
name|amt
operator|=
name|symcount
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|coff_link_hash_entry
operator|*
argument_list|)
expr_stmt|;
name|sym_hash
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_hash
operator|==
name|NULL
operator|&&
name|symcount
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
name|obj_coff_sym_hashes
argument_list|(
name|abfd
argument_list|)
operator|=
name|sym_hash
expr_stmt|;
name|symesz
operator|=
name|bfd_coff_symesz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|symesz
operator|==
name|bfd_coff_auxesz
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|esym
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|obj_coff_external_syms
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|esym_end
operator|=
name|esym
operator|+
name|symcount
operator|*
name|symesz
expr_stmt|;
while|while
condition|(
name|esym
operator|<
name|esym_end
condition|)
block|{
name|struct
name|internal_syment
name|sym
decl_stmt|;
name|enum
name|coff_symbol_classification
name|classification
decl_stmt|;
name|bfd_boolean
name|copy
decl_stmt|;
name|bfd_coff_swap_sym_in
argument_list|(
name|abfd
argument_list|,
name|esym
argument_list|,
operator|&
name|sym
argument_list|)
expr_stmt|;
name|classification
operator|=
name|bfd_coff_classify_symbol
argument_list|(
name|abfd
argument_list|,
operator|&
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|classification
operator|!=
name|COFF_SYMBOL_LOCAL
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|buf
index|[
name|SYMNMLEN
operator|+
literal|1
index|]
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
name|bfd_boolean
name|addit
decl_stmt|;
comment|/* This symbol is externally visible.  */
name|name
operator|=
name|_bfd_coff_internal_syment_name
argument_list|(
name|abfd
argument_list|,
operator|&
name|sym
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
comment|/* We must copy the name into memory if we got it from the              syment itself, rather than the string table.  */
name|copy
operator|=
name|default_copy
expr_stmt|;
if|if
condition|(
name|sym
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_zeroes
operator|!=
literal|0
operator|||
name|sym
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
operator|==
literal|0
condition|)
name|copy
operator|=
name|TRUE
expr_stmt|;
name|value
operator|=
name|sym
operator|.
name|n_value
expr_stmt|;
switch|switch
condition|(
name|classification
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|COFF_SYMBOL_GLOBAL
case|:
name|flags
operator|=
name|BSF_EXPORT
operator||
name|BSF_GLOBAL
expr_stmt|;
name|section
operator|=
name|coff_section_from_bfd_index
argument_list|(
name|abfd
argument_list|,
name|sym
operator|.
name|n_scnum
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|obj_pe
argument_list|(
name|abfd
argument_list|)
condition|)
name|value
operator|-=
name|section
operator|->
name|vma
expr_stmt|;
break|break;
case|case
name|COFF_SYMBOL_UNDEFINED
case|:
name|flags
operator|=
literal|0
expr_stmt|;
name|section
operator|=
name|bfd_und_section_ptr
expr_stmt|;
break|break;
case|case
name|COFF_SYMBOL_COMMON
case|:
name|flags
operator|=
name|BSF_GLOBAL
expr_stmt|;
name|section
operator|=
name|bfd_com_section_ptr
expr_stmt|;
break|break;
case|case
name|COFF_SYMBOL_PE_SECTION
case|:
name|flags
operator|=
name|BSF_SECTION_SYM
operator||
name|BSF_GLOBAL
expr_stmt|;
name|section
operator|=
name|coff_section_from_bfd_index
argument_list|(
name|abfd
argument_list|,
name|sym
operator|.
name|n_scnum
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|IS_WEAK_EXTERNAL
argument_list|(
name|abfd
argument_list|,
name|sym
argument_list|)
condition|)
name|flags
operator|=
name|BSF_WEAK
expr_stmt|;
name|addit
operator|=
name|TRUE
expr_stmt|;
comment|/* In the PE format, section symbols actually refer to the              start of the output section.  We handle them specially              here.  */
if|if
condition|(
name|obj_pe
argument_list|(
name|abfd
argument_list|)
operator|&&
operator|(
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|sym_hash
operator|=
name|coff_link_hash_lookup
argument_list|(
name|coff_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|,
name|copy
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|sym_hash
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|coff_link_hash_flags
operator|&
name|COFF_LINK_HASH_PE_SECTION_SYMBOL
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefined
operator|&&
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefweak
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"Warning: symbol `%s' is both section and non-section"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|addit
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
comment|/* The Microsoft Visual C compiler does string pooling by 	     hashing the constants to an internal symbol name, and 	     relying on the linker comdat support to discard 	     duplicate names.  However, if one string is a literal and 	     one is a data initializer, one will end up in the .data 	     section and one will end up in the .rdata section.  The 	     Microsoft linker will combine them into the .data 	     section, which seems to be wrong since it might cause the 	     literal to change.  	     As long as there are no external references to the 	     symbols, which there shouldn't be, we can treat the .data 	     and .rdata instances as separate symbols.  The comdat 	     code in the linker will do the appropriate merging.  Here 	     we avoid getting a multiple definition error for one of 	     these special symbols.  	     FIXME: I don't think this will work in the case where 	     there are two object files which use the constants as a 	     literal and two object files which use it as a data 	     initializer.  One or the other of the second object files 	     is going to wind up with an inappropriate reference.  */
if|if
condition|(
name|obj_pe
argument_list|(
name|abfd
argument_list|)
operator|&&
operator|(
name|classification
operator|==
name|COFF_SYMBOL_GLOBAL
operator|||
name|classification
operator|==
name|COFF_SYMBOL_PE_SECTION
operator|)
operator|&&
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
operator|!=
name|NULL
operator|&&
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
operator|->
name|comdat
operator|!=
name|NULL
operator|&&
name|CONST_STRNEQ
argument_list|(
name|name
argument_list|,
literal|"??_"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
operator|->
name|comdat
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|sym_hash
operator|==
name|NULL
condition|)
operator|*
name|sym_hash
operator|=
name|coff_link_hash_lookup
argument_list|(
name|coff_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|,
name|copy
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|sym_hash
operator|!=
name|NULL
operator|&&
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|&&
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
argument_list|)
operator|->
name|comdat
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
argument_list|)
operator|->
name|comdat
operator|->
name|name
argument_list|,
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
operator|->
name|comdat
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
name|addit
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|addit
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|bfd_coff_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
name|name
argument_list|,
name|flags
argument_list|,
name|section
argument_list|,
name|value
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|copy
argument_list|,
name|FALSE
argument_list|,
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|*
operator|)
name|sym_hash
argument_list|)
operator|)
condition|)
goto|goto
name|error_return
goto|;
block|}
if|if
condition|(
name|obj_pe
argument_list|(
name|abfd
argument_list|)
operator|&&
operator|(
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|!=
literal|0
condition|)
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|coff_link_hash_flags
operator||=
name|COFF_LINK_HASH_PE_SECTION_SYMBOL
expr_stmt|;
comment|/* Limit the alignment of a common symbol to the possible              alignment of a section.  There is no point to permitting              a higher alignment for a common symbol: we can not              guarantee it, and it may cause us to allocate extra space              in the common section.  */
if|if
condition|(
name|section
operator|==
name|bfd_com_section_ptr
operator|&&
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_common
operator|&&
operator|(
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|alignment_power
operator|>
name|bfd_coff_default_section_alignment_power
argument_list|(
name|abfd
argument_list|)
operator|)
condition|)
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|alignment_power
operator|=
name|bfd_coff_default_section_alignment_power
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|hash
operator|->
name|creator
operator|->
name|flavour
operator|==
name|bfd_get_flavour
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
comment|/* If we don't have any symbol information currently in                  the hash table, or if we are looking at a symbol                  definition, then update the symbol class and type in                  the hash table.  */
if|if
condition|(
operator|(
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|class
operator|==
name|C_NULL
operator|&&
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|type
operator|==
name|T_NULL
operator|)
operator|||
name|sym
operator|.
name|n_scnum
operator|!=
literal|0
operator|||
operator|(
name|sym
operator|.
name|n_value
operator|!=
literal|0
operator|&&
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defined
operator|&&
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
operator|)
condition|)
block|{
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|class
operator|=
name|sym
operator|.
name|n_sclass
expr_stmt|;
if|if
condition|(
name|sym
operator|.
name|n_type
operator|!=
name|T_NULL
condition|)
block|{
comment|/* We want to warn if the type changed, but not   			 if it changed from an unspecified type.   			 Testing the whole type byte may work, but the   			 change from (e.g.) a function of unspecified   			 type to function of known type also wants to   			 skip the warning.  */
if|if
condition|(
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|type
operator|!=
name|T_NULL
operator|&&
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|type
operator|!=
name|sym
operator|.
name|n_type
operator|&&
operator|!
operator|(
name|DTYPE
argument_list|(
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|type
argument_list|)
operator|==
name|DTYPE
argument_list|(
name|sym
operator|.
name|n_type
argument_list|)
operator|&&
operator|(
name|BTYPE
argument_list|(
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|type
argument_list|)
operator|==
name|T_NULL
operator|||
name|BTYPE
argument_list|(
name|sym
operator|.
name|n_type
argument_list|)
operator|==
name|T_NULL
operator|)
operator|)
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Warning: type of symbol `%s' changed from %d to %d in %B"
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|name
argument_list|,
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|type
argument_list|,
name|sym
operator|.
name|n_type
argument_list|)
expr_stmt|;
comment|/* We don't want to change from a meaningful   			 base type to a null one, but if we know   			 nothing, take what little we might now know.  */
if|if
condition|(
name|BTYPE
argument_list|(
name|sym
operator|.
name|n_type
argument_list|)
operator|!=
name|T_NULL
operator|||
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|type
operator|==
name|T_NULL
condition|)
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|type
operator|=
name|sym
operator|.
name|n_type
expr_stmt|;
block|}
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|auxbfd
operator|=
name|abfd
expr_stmt|;
if|if
condition|(
name|sym
operator|.
name|n_numaux
operator|!=
literal|0
condition|)
block|{
name|union
name|internal_auxent
modifier|*
name|alloc
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|bfd_byte
modifier|*
name|eaux
decl_stmt|;
name|union
name|internal_auxent
modifier|*
name|iaux
decl_stmt|;
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|numaux
operator|=
name|sym
operator|.
name|n_numaux
expr_stmt|;
name|alloc
operator|=
operator|(
operator|(
expr|union
name|internal_auxent
operator|*
operator|)
name|bfd_hash_allocate
argument_list|(
operator|&
name|info
operator|->
name|hash
operator|->
name|table
argument_list|,
operator|(
name|sym
operator|.
name|n_numaux
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|alloc
argument_list|)
operator|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|alloc
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|eaux
operator|=
name|esym
operator|+
name|symesz
operator|,
name|iaux
operator|=
name|alloc
init|;
name|i
operator|<
name|sym
operator|.
name|n_numaux
condition|;
name|i
operator|++
operator|,
name|eaux
operator|+=
name|symesz
operator|,
name|iaux
operator|++
control|)
name|bfd_coff_swap_aux_in
argument_list|(
name|abfd
argument_list|,
name|eaux
argument_list|,
name|sym
operator|.
name|n_type
argument_list|,
name|sym
operator|.
name|n_sclass
argument_list|,
operator|(
name|int
operator|)
name|i
argument_list|,
name|sym
operator|.
name|n_numaux
argument_list|,
name|iaux
argument_list|)
expr_stmt|;
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|aux
operator|=
name|alloc
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|classification
operator|==
name|COFF_SYMBOL_PE_SECTION
operator|&&
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|numaux
operator|!=
literal|0
condition|)
block|{
comment|/* Some PE sections (such as .bss) have a zero size in                  the section header, but a non-zero size in the AUX                  record.  Correct that here.  		 FIXME: This is not at all the right place to do this. 		 For example, it won't help objdump.  This needs to be 		 done when we swap in the section header.  */
name|BFD_ASSERT
argument_list|(
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|numaux
operator|==
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|section
operator|->
name|size
operator|==
literal|0
condition|)
name|section
operator|->
name|size
operator|=
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|aux
index|[
literal|0
index|]
operator|.
name|x_scn
operator|.
name|x_scnlen
expr_stmt|;
comment|/* FIXME: We could test whether the section sizes                  matches the size in the aux entry, but apparently                  that sometimes fails unexpectedly.  */
block|}
block|}
name|esym
operator|+=
operator|(
name|sym
operator|.
name|n_numaux
operator|+
literal|1
operator|)
operator|*
name|symesz
expr_stmt|;
name|sym_hash
operator|+=
name|sym
operator|.
name|n_numaux
operator|+
literal|1
expr_stmt|;
block|}
comment|/* If this is a non-traditional, non-relocatable link, try to      optimize the handling of any .stab/.stabstr sections.  */
if|if
condition|(
operator|!
name|info
operator|->
name|relocatable
operator|&&
operator|!
name|info
operator|->
name|traditional_format
operator|&&
name|info
operator|->
name|hash
operator|->
name|creator
operator|->
name|flavour
operator|==
name|bfd_get_flavour
argument_list|(
name|abfd
argument_list|)
operator|&&
operator|(
name|info
operator|->
name|strip
operator|!=
name|strip_all
operator|&&
name|info
operator|->
name|strip
operator|!=
name|strip_debugger
operator|)
condition|)
block|{
name|asection
modifier|*
name|stabstr
decl_stmt|;
name|stabstr
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".stabstr"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stabstr
operator|!=
name|NULL
condition|)
block|{
name|bfd_size_type
name|string_offset
init|=
literal|0
decl_stmt|;
name|asection
modifier|*
name|stab
decl_stmt|;
for|for
control|(
name|stab
operator|=
name|abfd
operator|->
name|sections
init|;
name|stab
condition|;
name|stab
operator|=
name|stab
operator|->
name|next
control|)
if|if
condition|(
name|CONST_STRNEQ
argument_list|(
name|stab
operator|->
name|name
argument_list|,
literal|".stab"
argument_list|)
operator|&&
operator|(
operator|!
name|stab
operator|->
name|name
index|[
literal|5
index|]
operator|||
operator|(
name|stab
operator|->
name|name
index|[
literal|5
index|]
operator|==
literal|'.'
operator|&&
name|ISDIGIT
argument_list|(
name|stab
operator|->
name|name
index|[
literal|6
index|]
argument_list|)
operator|)
operator|)
condition|)
block|{
name|struct
name|coff_link_hash_table
modifier|*
name|table
decl_stmt|;
name|struct
name|coff_section_tdata
modifier|*
name|secdata
init|=
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|stab
argument_list|)
decl_stmt|;
if|if
condition|(
name|secdata
operator|==
name|NULL
condition|)
block|{
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|coff_section_tdata
argument_list|)
expr_stmt|;
name|stab
operator|->
name|used_by_bfd
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|stab
operator|->
name|used_by_bfd
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|secdata
operator|=
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|stab
argument_list|)
expr_stmt|;
block|}
name|table
operator|=
name|coff_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|_bfd_link_section_stabs
argument_list|(
name|abfd
argument_list|,
operator|&
name|table
operator|->
name|stab_info
argument_list|,
name|stab
argument_list|,
name|stabstr
argument_list|,
operator|&
name|secdata
operator|->
name|stab_info
argument_list|,
operator|&
name|string_offset
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
block|}
block|}
name|obj_coff_keep_syms
argument_list|(
name|abfd
argument_list|)
operator|=
name|keep_syms
expr_stmt|;
return|return
name|TRUE
return|;
name|error_return
label|:
name|obj_coff_keep_syms
argument_list|(
name|abfd
argument_list|)
operator|=
name|keep_syms
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Do the final link step.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_coff_final_link
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|bfd_size_type
name|symesz
decl_stmt|;
name|struct
name|coff_final_link_info
name|finfo
decl_stmt|;
name|bfd_boolean
name|debug_merge_allocated
decl_stmt|;
name|bfd_boolean
name|long_section_names
decl_stmt|;
name|asection
modifier|*
name|o
decl_stmt|;
name|struct
name|bfd_link_order
modifier|*
name|p
decl_stmt|;
name|bfd_size_type
name|max_sym_count
decl_stmt|;
name|bfd_size_type
name|max_lineno_count
decl_stmt|;
name|bfd_size_type
name|max_reloc_count
decl_stmt|;
name|bfd_size_type
name|max_output_reloc_count
decl_stmt|;
name|bfd_size_type
name|max_contents_size
decl_stmt|;
name|file_ptr
name|rel_filepos
decl_stmt|;
name|unsigned
name|int
name|relsz
decl_stmt|;
name|file_ptr
name|line_filepos
decl_stmt|;
name|unsigned
name|int
name|linesz
decl_stmt|;
name|bfd
modifier|*
name|sub
decl_stmt|;
name|bfd_byte
modifier|*
name|external_relocs
init|=
name|NULL
decl_stmt|;
name|char
name|strbuf
index|[
name|STRING_SIZE_SIZE
index|]
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|symesz
operator|=
name|bfd_coff_symesz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|info
operator|=
name|info
expr_stmt|;
name|finfo
operator|.
name|output_bfd
operator|=
name|abfd
expr_stmt|;
name|finfo
operator|.
name|strtab
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|section_info
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|last_file_index
operator|=
operator|-
literal|1
expr_stmt|;
name|finfo
operator|.
name|last_bf_index
operator|=
operator|-
literal|1
expr_stmt|;
name|finfo
operator|.
name|internal_syms
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|sec_ptrs
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|sym_indices
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|outsyms
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|linenos
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|contents
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|external_relocs
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|internal_relocs
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|global_to_static
operator|=
name|FALSE
expr_stmt|;
name|debug_merge_allocated
operator|=
name|FALSE
expr_stmt|;
name|coff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|link_info
operator|=
name|info
expr_stmt|;
name|finfo
operator|.
name|strtab
operator|=
name|_bfd_stringtab_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|strtab
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|coff_debug_merge_hash_table_init
argument_list|(
operator|&
name|finfo
operator|.
name|debug_merge
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
name|debug_merge_allocated
operator|=
name|TRUE
expr_stmt|;
comment|/* Compute the file positions for all the sections.  */
if|if
condition|(
operator|!
name|abfd
operator|->
name|output_has_begun
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_coff_compute_section_file_positions
argument_list|(
name|abfd
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
comment|/* Count the line numbers and relocation entries required for the      output file.  Set the file positions for the relocs.  */
name|rel_filepos
operator|=
name|obj_relocbase
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|relsz
operator|=
name|bfd_coff_relsz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|max_contents_size
operator|=
literal|0
expr_stmt|;
name|max_lineno_count
operator|=
literal|0
expr_stmt|;
name|max_reloc_count
operator|=
literal|0
expr_stmt|;
name|long_section_names
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
name|o
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
name|o
operator|->
name|lineno_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|o
operator|->
name|map_head
operator|.
name|link_order
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_indirect_link_order
condition|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|sec
operator|=
name|p
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
expr_stmt|;
comment|/* Mark all sections which are to be included in the 		 link.  This will normally be every section.  We need 		 to do this so that we can identify any sections which 		 the linker has decided to not include.  */
name|sec
operator|->
name|linker_mark
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|strip
operator|==
name|strip_none
operator|||
name|info
operator|->
name|strip
operator|==
name|strip_some
condition|)
name|o
operator|->
name|lineno_count
operator|+=
name|sec
operator|->
name|lineno_count
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
name|o
operator|->
name|reloc_count
operator|+=
name|sec
operator|->
name|reloc_count
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|rawsize
operator|>
name|max_contents_size
condition|)
name|max_contents_size
operator|=
name|sec
operator|->
name|rawsize
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|size
operator|>
name|max_contents_size
condition|)
name|max_contents_size
operator|=
name|sec
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|lineno_count
operator|>
name|max_lineno_count
condition|)
name|max_lineno_count
operator|=
name|sec
operator|->
name|lineno_count
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|reloc_count
operator|>
name|max_reloc_count
condition|)
name|max_reloc_count
operator|=
name|sec
operator|->
name|reloc_count
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|info
operator|->
name|relocatable
operator|&&
operator|(
name|p
operator|->
name|type
operator|==
name|bfd_section_reloc_link_order
operator|||
name|p
operator|->
name|type
operator|==
name|bfd_symbol_reloc_link_order
operator|)
condition|)
operator|++
name|o
operator|->
name|reloc_count
expr_stmt|;
block|}
if|if
condition|(
name|o
operator|->
name|reloc_count
operator|==
literal|0
condition|)
name|o
operator|->
name|rel_filepos
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|o
operator|->
name|flags
operator||=
name|SEC_RELOC
expr_stmt|;
name|o
operator|->
name|rel_filepos
operator|=
name|rel_filepos
expr_stmt|;
name|rel_filepos
operator|+=
name|o
operator|->
name|reloc_count
operator|*
name|relsz
expr_stmt|;
comment|/* In PE COFF, if there are at least 0xffff relocations an 	     extra relocation will be written out to encode the count.  */
if|if
condition|(
name|obj_pe
argument_list|(
name|abfd
argument_list|)
operator|&&
name|o
operator|->
name|reloc_count
operator|>=
literal|0xffff
condition|)
name|rel_filepos
operator|+=
name|relsz
expr_stmt|;
block|}
if|if
condition|(
name|bfd_coff_long_section_names
argument_list|(
name|abfd
argument_list|)
operator|&&
name|strlen
argument_list|(
name|o
operator|->
name|name
argument_list|)
operator|>
name|SCNNMLEN
condition|)
block|{
comment|/* This section has a long name which must go in the string              table.  This must correspond to the code in              coff_write_object_contents which puts the string index              into the s_name field of the section header.  That is why              we pass hash as FALSE.  */
if|if
condition|(
name|_bfd_stringtab_add
argument_list|(
name|finfo
operator|.
name|strtab
argument_list|,
name|o
operator|->
name|name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
operator|==
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
condition|)
goto|goto
name|error_return
goto|;
name|long_section_names
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
comment|/* If doing a relocatable link, allocate space for the pointers we      need to keep.  */
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* We use section_count + 1, rather than section_count, because          the target_index fields are 1 based.  */
name|amt
operator|=
name|abfd
operator|->
name|section_count
operator|+
literal|1
expr_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
expr|struct
name|coff_link_section_info
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|section_info
operator|=
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|section_info
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|abfd
operator|->
name|section_count
condition|;
name|i
operator|++
control|)
block|{
name|finfo
operator|.
name|section_info
index|[
name|i
index|]
operator|.
name|relocs
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|section_info
index|[
name|i
index|]
operator|.
name|rel_hashes
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* We now know the size of the relocs, so we can determine the file      positions of the line numbers.  */
name|line_filepos
operator|=
name|rel_filepos
expr_stmt|;
name|linesz
operator|=
name|bfd_coff_linesz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|max_output_reloc_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
if|if
condition|(
name|o
operator|->
name|lineno_count
operator|==
literal|0
condition|)
name|o
operator|->
name|line_filepos
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|o
operator|->
name|line_filepos
operator|=
name|line_filepos
expr_stmt|;
name|line_filepos
operator|+=
name|o
operator|->
name|lineno_count
operator|*
name|linesz
expr_stmt|;
block|}
if|if
condition|(
name|o
operator|->
name|reloc_count
operator|!=
literal|0
condition|)
block|{
comment|/* We don't know the indices of global symbols until we have              written out all the local symbols.  For each section in              the output file, we keep an array of pointers to hash              table entries.  Each entry in the array corresponds to a              reloc.  When we find a reloc against a global symbol, we              set the corresponding entry in this array so that we can              fix up the symbol index after we have written out all the              local symbols.  	     Because of this problem, we also keep the relocs in 	     memory until the end of the link.  This wastes memory, 	     but only when doing a relocatable link, which is not the 	     common case.  */
name|BFD_ASSERT
argument_list|(
name|info
operator|->
name|relocatable
argument_list|)
expr_stmt|;
name|amt
operator|=
name|o
operator|->
name|reloc_count
expr_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
expr|struct
name|internal_reloc
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|section_info
index|[
name|o
operator|->
name|target_index
index|]
operator|.
name|relocs
operator|=
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
name|amt
operator|=
name|o
operator|->
name|reloc_count
expr_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
expr|struct
name|coff_link_hash_entry
operator|*
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|section_info
index|[
name|o
operator|->
name|target_index
index|]
operator|.
name|rel_hashes
operator|=
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|section_info
index|[
name|o
operator|->
name|target_index
index|]
operator|.
name|relocs
operator|==
name|NULL
operator|||
name|finfo
operator|.
name|section_info
index|[
name|o
operator|->
name|target_index
index|]
operator|.
name|rel_hashes
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|o
operator|->
name|reloc_count
operator|>
name|max_output_reloc_count
condition|)
name|max_output_reloc_count
operator|=
name|o
operator|->
name|reloc_count
expr_stmt|;
block|}
comment|/* Reset the reloc and lineno counts, so that we can use them to 	 count the number of entries we have output so far.  */
name|o
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
name|o
operator|->
name|lineno_count
operator|=
literal|0
expr_stmt|;
block|}
name|obj_sym_filepos
argument_list|(
name|abfd
argument_list|)
operator|=
name|line_filepos
expr_stmt|;
comment|/* Figure out the largest number of symbols in an input BFD.  Take      the opportunity to clear the output_has_begun fields of all the      input BFD's.  */
name|max_sym_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|sub
operator|=
name|info
operator|->
name|input_bfds
init|;
name|sub
operator|!=
name|NULL
condition|;
name|sub
operator|=
name|sub
operator|->
name|link_next
control|)
block|{
name|size_t
name|sz
decl_stmt|;
name|sub
operator|->
name|output_has_begun
operator|=
name|FALSE
expr_stmt|;
name|sz
operator|=
name|obj_raw_syment_count
argument_list|(
name|sub
argument_list|)
expr_stmt|;
if|if
condition|(
name|sz
operator|>
name|max_sym_count
condition|)
name|max_sym_count
operator|=
name|sz
expr_stmt|;
block|}
comment|/* Allocate some buffers used while linking.  */
name|amt
operator|=
name|max_sym_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|internal_syment
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|internal_syms
operator|=
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
name|amt
operator|=
name|max_sym_count
operator|*
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|sec_ptrs
operator|=
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
name|amt
operator|=
name|max_sym_count
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|sym_indices
operator|=
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|outsyms
operator|=
name|bfd_malloc
argument_list|(
operator|(
name|max_sym_count
operator|+
literal|1
operator|)
operator|*
name|symesz
argument_list|)
expr_stmt|;
name|amt
operator|=
name|max_lineno_count
operator|*
name|bfd_coff_linesz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|linenos
operator|=
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|contents
operator|=
name|bfd_malloc
argument_list|(
name|max_contents_size
argument_list|)
expr_stmt|;
name|amt
operator|=
name|max_reloc_count
operator|*
name|relsz
expr_stmt|;
name|finfo
operator|.
name|external_relocs
operator|=
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|relocatable
condition|)
block|{
name|amt
operator|=
name|max_reloc_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|internal_reloc
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|internal_relocs
operator|=
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|finfo
operator|.
name|internal_syms
operator|==
name|NULL
operator|&&
name|max_sym_count
operator|>
literal|0
operator|)
operator|||
operator|(
name|finfo
operator|.
name|sec_ptrs
operator|==
name|NULL
operator|&&
name|max_sym_count
operator|>
literal|0
operator|)
operator|||
operator|(
name|finfo
operator|.
name|sym_indices
operator|==
name|NULL
operator|&&
name|max_sym_count
operator|>
literal|0
operator|)
operator|||
name|finfo
operator|.
name|outsyms
operator|==
name|NULL
operator|||
operator|(
name|finfo
operator|.
name|linenos
operator|==
name|NULL
operator|&&
name|max_lineno_count
operator|>
literal|0
operator|)
operator|||
operator|(
name|finfo
operator|.
name|contents
operator|==
name|NULL
operator|&&
name|max_contents_size
operator|>
literal|0
operator|)
operator|||
operator|(
name|finfo
operator|.
name|external_relocs
operator|==
name|NULL
operator|&&
name|max_reloc_count
operator|>
literal|0
operator|)
operator|||
operator|(
operator|!
name|info
operator|->
name|relocatable
operator|&&
name|finfo
operator|.
name|internal_relocs
operator|==
name|NULL
operator|&&
name|max_reloc_count
operator|>
literal|0
operator|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* We now know the position of everything in the file, except that      we don't know the size of the symbol table and therefore we don't      know where the string table starts.  We just build the string      table in memory as we go along.  We process all the relocations      for a single input file at once.  */
name|obj_raw_syment_count
argument_list|(
name|abfd
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|coff_backend_info
argument_list|(
name|abfd
argument_list|)
operator|->
name|_bfd_coff_start_final_link
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_coff_start_final_link
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
for|for
control|(
name|p
operator|=
name|o
operator|->
name|map_head
operator|.
name|link_order
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_indirect_link_order
operator|&&
name|bfd_family_coff
argument_list|(
name|p
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
operator|->
name|owner
argument_list|)
condition|)
block|{
name|sub
operator|=
name|p
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
operator|->
name|owner
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_coff_link_output_has_begun
argument_list|(
name|sub
argument_list|,
operator|&
name|finfo
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|_bfd_coff_link_input_bfd
argument_list|(
operator|&
name|finfo
argument_list|,
name|sub
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
name|sub
operator|->
name|output_has_begun
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_section_reloc_link_order
operator|||
name|p
operator|->
name|type
operator|==
name|bfd_symbol_reloc_link_order
condition|)
block|{
if|if
condition|(
operator|!
name|_bfd_coff_reloc_link_order
argument_list|(
name|abfd
argument_list|,
operator|&
name|finfo
argument_list|,
name|o
argument_list|,
name|p
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|_bfd_default_link_order
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|o
argument_list|,
name|p
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|bfd_coff_final_link_postscript
argument_list|(
name|abfd
argument_list|,
operator|&
name|finfo
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* Free up the buffers used by _bfd_coff_link_input_bfd.  */
name|coff_debug_merge_hash_table_free
argument_list|(
operator|&
name|finfo
operator|.
name|debug_merge
argument_list|)
expr_stmt|;
name|debug_merge_allocated
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|internal_syms
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|finfo
operator|.
name|internal_syms
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|internal_syms
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|finfo
operator|.
name|sec_ptrs
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|finfo
operator|.
name|sec_ptrs
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|sec_ptrs
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|finfo
operator|.
name|sym_indices
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|finfo
operator|.
name|sym_indices
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|sym_indices
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|finfo
operator|.
name|linenos
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|finfo
operator|.
name|linenos
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|linenos
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|finfo
operator|.
name|contents
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|finfo
operator|.
name|contents
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|contents
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|finfo
operator|.
name|external_relocs
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|finfo
operator|.
name|external_relocs
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|external_relocs
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|finfo
operator|.
name|internal_relocs
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|finfo
operator|.
name|internal_relocs
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|internal_relocs
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* The value of the last C_FILE symbol is supposed to be the symbol      index of the first external symbol.  Write it out again if      necessary.  */
if|if
condition|(
name|finfo
operator|.
name|last_file_index
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|unsigned
name|int
operator|)
name|finfo
operator|.
name|last_file
operator|.
name|n_value
operator|!=
name|obj_raw_syment_count
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|file_ptr
name|pos
decl_stmt|;
name|finfo
operator|.
name|last_file
operator|.
name|n_value
operator|=
name|obj_raw_syment_count
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|bfd_coff_swap_sym_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|finfo
operator|.
name|last_file
argument_list|,
name|finfo
operator|.
name|outsyms
argument_list|)
expr_stmt|;
name|pos
operator|=
name|obj_sym_filepos
argument_list|(
name|abfd
argument_list|)
operator|+
name|finfo
operator|.
name|last_file_index
operator|*
name|symesz
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|pos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bwrite
argument_list|(
name|finfo
operator|.
name|outsyms
argument_list|,
name|symesz
argument_list|,
name|abfd
argument_list|)
operator|!=
name|symesz
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* If doing task linking (ld --task-link) then make a pass through the      global symbols, writing out any that are defined, and making them      static.  */
if|if
condition|(
name|info
operator|->
name|task_link
condition|)
block|{
name|finfo
operator|.
name|failed
operator|=
name|FALSE
expr_stmt|;
name|coff_link_hash_traverse
argument_list|(
name|coff_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|_bfd_coff_write_task_globals
argument_list|,
operator|&
name|finfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|failed
condition|)
goto|goto
name|error_return
goto|;
block|}
comment|/* Write out the global symbols.  */
name|finfo
operator|.
name|failed
operator|=
name|FALSE
expr_stmt|;
name|coff_link_hash_traverse
argument_list|(
name|coff_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|_bfd_coff_write_global_sym
argument_list|,
operator|&
name|finfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|failed
condition|)
goto|goto
name|error_return
goto|;
comment|/* The outsyms buffer is used by _bfd_coff_write_global_sym.  */
if|if
condition|(
name|finfo
operator|.
name|outsyms
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|finfo
operator|.
name|outsyms
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|outsyms
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|relocatable
operator|&&
name|max_output_reloc_count
operator|>
literal|0
condition|)
block|{
comment|/* Now that we have written out all the global symbols, we know 	 the symbol indices to use for relocs against them, and we can 	 finally write out the relocs.  */
name|amt
operator|=
name|max_output_reloc_count
operator|*
name|relsz
expr_stmt|;
name|external_relocs
operator|=
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|external_relocs
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
name|struct
name|internal_reloc
modifier|*
name|irel
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|irelend
decl_stmt|;
name|struct
name|coff_link_hash_entry
modifier|*
modifier|*
name|rel_hash
decl_stmt|;
name|bfd_byte
modifier|*
name|erel
decl_stmt|;
if|if
condition|(
name|o
operator|->
name|reloc_count
operator|==
literal|0
condition|)
continue|continue;
name|irel
operator|=
name|finfo
operator|.
name|section_info
index|[
name|o
operator|->
name|target_index
index|]
operator|.
name|relocs
expr_stmt|;
name|irelend
operator|=
name|irel
operator|+
name|o
operator|->
name|reloc_count
expr_stmt|;
name|rel_hash
operator|=
name|finfo
operator|.
name|section_info
index|[
name|o
operator|->
name|target_index
index|]
operator|.
name|rel_hashes
expr_stmt|;
name|erel
operator|=
name|external_relocs
expr_stmt|;
for|for
control|(
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
operator|,
name|rel_hash
operator|++
operator|,
name|erel
operator|+=
name|relsz
control|)
block|{
if|if
condition|(
operator|*
name|rel_hash
operator|!=
name|NULL
condition|)
block|{
name|BFD_ASSERT
argument_list|(
operator|(
operator|*
name|rel_hash
operator|)
operator|->
name|indx
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|irel
operator|->
name|r_symndx
operator|=
operator|(
operator|*
name|rel_hash
operator|)
operator|->
name|indx
expr_stmt|;
block|}
name|bfd_coff_swap_reloc_out
argument_list|(
name|abfd
argument_list|,
name|irel
argument_list|,
name|erel
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|o
operator|->
name|rel_filepos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|obj_pe
argument_list|(
name|abfd
argument_list|)
operator|&&
name|o
operator|->
name|reloc_count
operator|>=
literal|0xffff
condition|)
block|{
comment|/* In PE COFF, write the count of relocs as the first 		 reloc.  The header overflow bit will be set 		 elsewhere. */
name|struct
name|internal_reloc
name|incount
decl_stmt|;
name|bfd_byte
modifier|*
name|excount
init|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|relsz
argument_list|)
decl_stmt|;
name|memset
argument_list|(
operator|&
name|incount
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|incount
argument_list|)
argument_list|)
expr_stmt|;
name|incount
operator|.
name|r_vaddr
operator|=
name|o
operator|->
name|reloc_count
operator|+
literal|1
expr_stmt|;
name|bfd_coff_swap_reloc_out
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|incount
argument_list|,
operator|(
name|PTR
operator|)
name|excount
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
name|excount
argument_list|,
name|relsz
argument_list|,
name|abfd
argument_list|)
operator|!=
name|relsz
condition|)
comment|/* We'll leak, but it's an error anyway. */
goto|goto
name|error_return
goto|;
name|free
argument_list|(
name|excount
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bfd_bwrite
argument_list|(
name|external_relocs
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|relsz
operator|*
name|o
operator|->
name|reloc_count
argument_list|,
name|abfd
argument_list|)
operator|!=
operator|(
name|bfd_size_type
operator|)
name|relsz
operator|*
name|o
operator|->
name|reloc_count
condition|)
goto|goto
name|error_return
goto|;
block|}
name|free
argument_list|(
name|external_relocs
argument_list|)
expr_stmt|;
name|external_relocs
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Free up the section information.  */
if|if
condition|(
name|finfo
operator|.
name|section_info
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|abfd
operator|->
name|section_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|finfo
operator|.
name|section_info
index|[
name|i
index|]
operator|.
name|relocs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|section_info
index|[
name|i
index|]
operator|.
name|relocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|section_info
index|[
name|i
index|]
operator|.
name|rel_hashes
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|section_info
index|[
name|i
index|]
operator|.
name|rel_hashes
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|finfo
operator|.
name|section_info
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|section_info
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* If we have optimized stabs strings, output them.  */
if|if
condition|(
name|coff_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|stab_info
operator|.
name|stabstr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|_bfd_write_stab_strings
argument_list|(
name|abfd
argument_list|,
operator|&
name|coff_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|stab_info
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Write out the string table.  */
if|if
condition|(
name|obj_raw_syment_count
argument_list|(
name|abfd
argument_list|)
operator|!=
literal|0
operator|||
name|long_section_names
condition|)
block|{
name|file_ptr
name|pos
decl_stmt|;
name|pos
operator|=
name|obj_sym_filepos
argument_list|(
name|abfd
argument_list|)
operator|+
name|obj_raw_syment_count
argument_list|(
name|abfd
argument_list|)
operator|*
name|symesz
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|pos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
if|#
directive|if
name|STRING_SIZE_SIZE
operator|==
literal|4
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|_bfd_stringtab_size
argument_list|(
name|finfo
operator|.
name|strtab
argument_list|)
operator|+
name|STRING_SIZE_SIZE
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
else|#
directive|else
error|#
directive|error
error|Change H_PUT_32 above
endif|#
directive|endif
if|if
condition|(
name|bfd_bwrite
argument_list|(
name|strbuf
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|STRING_SIZE_SIZE
argument_list|,
name|abfd
argument_list|)
operator|!=
name|STRING_SIZE_SIZE
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|_bfd_stringtab_emit
argument_list|(
name|abfd
argument_list|,
name|finfo
operator|.
name|strtab
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|obj_coff_strings_written
argument_list|(
name|abfd
argument_list|)
operator|=
name|TRUE
expr_stmt|;
block|}
name|_bfd_stringtab_free
argument_list|(
name|finfo
operator|.
name|strtab
argument_list|)
expr_stmt|;
comment|/* Setting bfd_get_symcount to 0 will cause write_object_contents to      not try to write out the symbols.  */
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|TRUE
return|;
name|error_return
label|:
if|if
condition|(
name|debug_merge_allocated
condition|)
name|coff_debug_merge_hash_table_free
argument_list|(
operator|&
name|finfo
operator|.
name|debug_merge
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|strtab
operator|!=
name|NULL
condition|)
name|_bfd_stringtab_free
argument_list|(
name|finfo
operator|.
name|strtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|section_info
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|abfd
operator|->
name|section_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|finfo
operator|.
name|section_info
index|[
name|i
index|]
operator|.
name|relocs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|section_info
index|[
name|i
index|]
operator|.
name|relocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|section_info
index|[
name|i
index|]
operator|.
name|rel_hashes
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|section_info
index|[
name|i
index|]
operator|.
name|rel_hashes
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|finfo
operator|.
name|section_info
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|finfo
operator|.
name|internal_syms
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|internal_syms
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|sec_ptrs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|sec_ptrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|sym_indices
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|sym_indices
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|outsyms
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|outsyms
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|linenos
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|linenos
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|contents
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|contents
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|external_relocs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|external_relocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|internal_relocs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|internal_relocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|external_relocs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|external_relocs
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Parse out a -heap<reserved>,<commit> line.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|dores_com
parameter_list|(
name|char
modifier|*
name|ptr
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|int
name|heap
parameter_list|)
block|{
if|if
condition|(
name|coff_data
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|pe
condition|)
block|{
name|int
name|val
init|=
name|strtoul
argument_list|(
name|ptr
argument_list|,
operator|&
name|ptr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|heap
condition|)
name|pe_data
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|pe_opthdr
operator|.
name|SizeOfHeapReserve
operator|=
name|val
expr_stmt|;
else|else
name|pe_data
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|pe_opthdr
operator|.
name|SizeOfStackReserve
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|ptr
index|[
literal|0
index|]
operator|==
literal|','
condition|)
block|{
name|val
operator|=
name|strtoul
argument_list|(
name|ptr
operator|+
literal|1
argument_list|,
operator|&
name|ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|heap
condition|)
name|pe_data
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|pe_opthdr
operator|.
name|SizeOfHeapCommit
operator|=
name|val
expr_stmt|;
else|else
name|pe_data
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|pe_opthdr
operator|.
name|SizeOfStackCommit
operator|=
name|val
expr_stmt|;
block|}
block|}
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|get_name
parameter_list|(
name|char
modifier|*
name|ptr
parameter_list|,
name|char
modifier|*
modifier|*
name|dst
parameter_list|)
block|{
while|while
condition|(
operator|*
name|ptr
operator|==
literal|' '
condition|)
name|ptr
operator|++
expr_stmt|;
operator|*
name|dst
operator|=
name|ptr
expr_stmt|;
while|while
condition|(
operator|*
name|ptr
operator|&&
operator|*
name|ptr
operator|!=
literal|' '
condition|)
name|ptr
operator|++
expr_stmt|;
operator|*
name|ptr
operator|=
literal|0
expr_stmt|;
return|return
name|ptr
operator|+
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Process any magic embedded commands in a section called .drectve.  */
end_comment

begin_function
specifier|static
name|int
name|process_embedded_commands
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|asection
modifier|*
name|sec
init|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".drectve"
argument_list|)
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|e
decl_stmt|;
name|bfd_byte
modifier|*
name|copy
decl_stmt|;
if|if
condition|(
operator|!
name|sec
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|bfd_malloc_and_get_section
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
operator|&
name|copy
argument_list|)
condition|)
block|{
if|if
condition|(
name|copy
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|copy
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|e
operator|=
operator|(
name|char
operator|*
operator|)
name|copy
operator|+
name|sec
operator|->
name|size
expr_stmt|;
for|for
control|(
name|s
operator|=
operator|(
name|char
operator|*
operator|)
name|copy
init|;
name|s
operator|<
name|e
condition|;
control|)
block|{
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|!=
literal|'-'
condition|)
block|{
name|s
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|CONST_STRNEQ
argument_list|(
name|s
argument_list|,
literal|"-attr"
argument_list|)
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|attribs
decl_stmt|;
name|asection
modifier|*
name|asec
decl_stmt|;
name|int
name|loop
init|=
literal|1
decl_stmt|;
name|int
name|had_write
init|=
literal|0
decl_stmt|;
name|int
name|had_exec
init|=
literal|0
decl_stmt|;
name|s
operator|+=
literal|5
expr_stmt|;
name|s
operator|=
name|get_name
argument_list|(
name|s
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
name|s
operator|=
name|get_name
argument_list|(
name|s
argument_list|,
operator|&
name|attribs
argument_list|)
expr_stmt|;
while|while
condition|(
name|loop
condition|)
block|{
switch|switch
condition|(
operator|*
name|attribs
operator|++
condition|)
block|{
case|case
literal|'W'
case|:
name|had_write
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
break|break;
case|case
literal|'S'
case|:
break|break;
case|case
literal|'X'
case|:
name|had_exec
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|loop
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|asec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|asec
condition|)
block|{
if|if
condition|(
name|had_exec
condition|)
name|asec
operator|->
name|flags
operator||=
name|SEC_CODE
expr_stmt|;
if|if
condition|(
operator|!
name|had_write
condition|)
name|asec
operator|->
name|flags
operator||=
name|SEC_READONLY
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|CONST_STRNEQ
argument_list|(
name|s
argument_list|,
literal|"-heap"
argument_list|)
condition|)
name|s
operator|=
name|dores_com
argument_list|(
name|s
operator|+
literal|5
argument_list|,
name|output_bfd
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CONST_STRNEQ
argument_list|(
name|s
argument_list|,
literal|"-stack"
argument_list|)
condition|)
name|s
operator|=
name|dores_com
argument_list|(
name|s
operator|+
literal|6
argument_list|,
name|output_bfd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|s
operator|++
expr_stmt|;
block|}
name|free
argument_list|(
name|copy
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Place a marker against all symbols which are used by relocations.    This marker can be picked up by the 'do we skip this symbol ?'    loop in _bfd_coff_link_input_bfd() and used to prevent skipping    that symbol.  */
end_comment

begin_function
specifier|static
name|void
name|mark_relocs
parameter_list|(
name|struct
name|coff_final_link_info
modifier|*
name|finfo
parameter_list|,
name|bfd
modifier|*
name|input_bfd
parameter_list|)
block|{
name|asection
modifier|*
name|a
decl_stmt|;
if|if
condition|(
operator|(
name|bfd_get_file_flags
argument_list|(
name|input_bfd
argument_list|)
operator|&
name|HAS_SYMS
operator|)
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|a
operator|=
name|input_bfd
operator|->
name|sections
init|;
name|a
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|;
name|a
operator|=
name|a
operator|->
name|next
control|)
block|{
name|struct
name|internal_reloc
modifier|*
name|internal_relocs
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|irel
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|irelend
decl_stmt|;
if|if
condition|(
operator|(
name|a
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
operator|||
name|a
operator|->
name|reloc_count
operator|<
literal|1
condition|)
continue|continue;
comment|/* Don't mark relocs in excluded sections.  */
if|if
condition|(
name|a
operator|->
name|output_section
operator|==
name|bfd_abs_section_ptr
condition|)
continue|continue;
comment|/* Read in the relocs.  */
name|internal_relocs
operator|=
name|_bfd_coff_read_internal_relocs
argument_list|(
name|input_bfd
argument_list|,
name|a
argument_list|,
name|FALSE
argument_list|,
name|finfo
operator|->
name|external_relocs
argument_list|,
name|finfo
operator|->
name|info
operator|->
name|relocatable
argument_list|,
operator|(
name|finfo
operator|->
name|info
operator|->
name|relocatable
condition|?
operator|(
name|finfo
operator|->
name|section_info
index|[
name|a
operator|->
name|output_section
operator|->
name|target_index
index|]
operator|.
name|relocs
operator|+
name|a
operator|->
name|output_section
operator|->
name|reloc_count
operator|)
else|:
name|finfo
operator|->
name|internal_relocs
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
continue|continue;
name|irel
operator|=
name|internal_relocs
expr_stmt|;
name|irelend
operator|=
name|irel
operator|+
name|a
operator|->
name|reloc_count
expr_stmt|;
comment|/* Place a mark in the sym_indices array (whose entries have 	 been initialised to 0) for all of the symbols that are used 	 in the relocation table.  This will then be picked up in the 	 skip/don't-skip pass.  */
for|for
control|(
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
control|)
name|finfo
operator|->
name|sym_indices
index|[
name|irel
operator|->
name|r_symndx
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Link an input file into the linker output file.  This function    handles all the sections and relocations of the input file at once.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_coff_link_input_bfd
parameter_list|(
name|struct
name|coff_final_link_info
modifier|*
name|finfo
parameter_list|,
name|bfd
modifier|*
name|input_bfd
parameter_list|)
block|{
name|unsigned
name|int
name|n_tmask
init|=
name|coff_data
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|local_n_tmask
decl_stmt|;
name|unsigned
name|int
name|n_btshft
init|=
name|coff_data
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|local_n_btshft
decl_stmt|;
name|bfd_boolean
function_decl|(
modifier|*
name|adjust_symndx
function_decl|)
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|struct
name|internal_reloc
modifier|*
parameter_list|,
name|bfd_boolean
modifier|*
parameter_list|)
function_decl|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
specifier|const
name|char
modifier|*
name|strings
decl_stmt|;
name|bfd_size_type
name|syment_base
decl_stmt|;
name|bfd_boolean
name|copy
decl_stmt|,
name|hash
decl_stmt|;
name|bfd_size_type
name|isymesz
decl_stmt|;
name|bfd_size_type
name|osymesz
decl_stmt|;
name|bfd_size_type
name|linesz
decl_stmt|;
name|bfd_byte
modifier|*
name|esym
decl_stmt|;
name|bfd_byte
modifier|*
name|esym_end
decl_stmt|;
name|struct
name|internal_syment
modifier|*
name|isymp
decl_stmt|;
name|asection
modifier|*
modifier|*
name|secpp
decl_stmt|;
name|long
modifier|*
name|indexp
decl_stmt|;
name|unsigned
name|long
name|output_index
decl_stmt|;
name|bfd_byte
modifier|*
name|outsym
decl_stmt|;
name|struct
name|coff_link_hash_entry
modifier|*
modifier|*
name|sym_hash
decl_stmt|;
name|asection
modifier|*
name|o
decl_stmt|;
comment|/* Move all the symbols to the output file.  */
name|output_bfd
operator|=
name|finfo
operator|->
name|output_bfd
expr_stmt|;
name|strings
operator|=
name|NULL
expr_stmt|;
name|syment_base
operator|=
name|obj_raw_syment_count
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
name|isymesz
operator|=
name|bfd_coff_symesz
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|osymesz
operator|=
name|bfd_coff_symesz
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
name|linesz
operator|=
name|bfd_coff_linesz
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|linesz
operator|==
name|bfd_coff_linesz
argument_list|(
name|output_bfd
argument_list|)
argument_list|)
expr_stmt|;
name|copy
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|finfo
operator|->
name|info
operator|->
name|keep_memory
condition|)
name|copy
operator|=
name|TRUE
expr_stmt|;
name|hash
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|(
name|output_bfd
operator|->
name|flags
operator|&
name|BFD_TRADITIONAL_FORMAT
operator|)
operator|!=
literal|0
condition|)
name|hash
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|_bfd_coff_get_external_symbols
argument_list|(
name|input_bfd
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|esym
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|obj_coff_external_syms
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|esym_end
operator|=
name|esym
operator|+
name|obj_raw_syment_count
argument_list|(
name|input_bfd
argument_list|)
operator|*
name|isymesz
expr_stmt|;
name|isymp
operator|=
name|finfo
operator|->
name|internal_syms
expr_stmt|;
name|secpp
operator|=
name|finfo
operator|->
name|sec_ptrs
expr_stmt|;
name|indexp
operator|=
name|finfo
operator|->
name|sym_indices
expr_stmt|;
name|output_index
operator|=
name|syment_base
expr_stmt|;
name|outsym
operator|=
name|finfo
operator|->
name|outsyms
expr_stmt|;
if|if
condition|(
name|coff_data
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|pe
operator|&&
operator|!
name|process_embedded_commands
argument_list|(
name|output_bfd
argument_list|,
name|finfo
operator|->
name|info
argument_list|,
name|input_bfd
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* If we are going to perform relocations and also strip/discard some      symbols then we must make sure that we do not strip/discard those      symbols that are going to be involved in the relocations.  */
if|if
condition|(
operator|(
name|finfo
operator|->
name|info
operator|->
name|strip
operator|!=
name|strip_none
operator|||
name|finfo
operator|->
name|info
operator|->
name|discard
operator|!=
name|discard_none
operator|)
operator|&&
name|finfo
operator|->
name|info
operator|->
name|relocatable
condition|)
block|{
comment|/* Mark the symbol array as 'not-used'.  */
name|memset
argument_list|(
name|indexp
argument_list|,
literal|0
argument_list|,
name|obj_raw_syment_count
argument_list|(
name|input_bfd
argument_list|)
operator|*
sizeof|sizeof
expr|*
name|indexp
argument_list|)
expr_stmt|;
name|mark_relocs
argument_list|(
name|finfo
argument_list|,
name|input_bfd
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|esym
operator|<
name|esym_end
condition|)
block|{
name|struct
name|internal_syment
name|isym
decl_stmt|;
name|enum
name|coff_symbol_classification
name|classification
decl_stmt|;
name|bfd_boolean
name|skip
decl_stmt|;
name|bfd_boolean
name|global
decl_stmt|;
name|bfd_boolean
name|dont_skip_symbol
decl_stmt|;
name|int
name|add
decl_stmt|;
name|bfd_coff_swap_sym_in
argument_list|(
name|input_bfd
argument_list|,
name|esym
argument_list|,
name|isymp
argument_list|)
expr_stmt|;
comment|/* Make a copy of *isymp so that the relocate_section function 	 always sees the original values.  This is more reliable than 	 always recomputing the symbol value even if we are stripping 	 the symbol.  */
name|isym
operator|=
operator|*
name|isymp
expr_stmt|;
name|classification
operator|=
name|bfd_coff_classify_symbol
argument_list|(
name|input_bfd
argument_list|,
operator|&
name|isym
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|classification
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|COFF_SYMBOL_GLOBAL
case|:
case|case
name|COFF_SYMBOL_PE_SECTION
case|:
case|case
name|COFF_SYMBOL_LOCAL
case|:
operator|*
name|secpp
operator|=
name|coff_section_from_bfd_index
argument_list|(
name|input_bfd
argument_list|,
name|isym
operator|.
name|n_scnum
argument_list|)
expr_stmt|;
break|break;
case|case
name|COFF_SYMBOL_COMMON
case|:
operator|*
name|secpp
operator|=
name|bfd_com_section_ptr
expr_stmt|;
break|break;
case|case
name|COFF_SYMBOL_UNDEFINED
case|:
operator|*
name|secpp
operator|=
name|bfd_und_section_ptr
expr_stmt|;
break|break;
block|}
comment|/* Extract the flag indicating if this symbol is used by a          relocation.  */
if|if
condition|(
operator|(
name|finfo
operator|->
name|info
operator|->
name|strip
operator|!=
name|strip_none
operator|||
name|finfo
operator|->
name|info
operator|->
name|discard
operator|!=
name|discard_none
operator|)
operator|&&
name|finfo
operator|->
name|info
operator|->
name|relocatable
condition|)
name|dont_skip_symbol
operator|=
operator|*
name|indexp
expr_stmt|;
else|else
name|dont_skip_symbol
operator|=
name|FALSE
expr_stmt|;
operator|*
name|indexp
operator|=
operator|-
literal|1
expr_stmt|;
name|skip
operator|=
name|FALSE
expr_stmt|;
name|global
operator|=
name|FALSE
expr_stmt|;
name|add
operator|=
literal|1
operator|+
name|isym
operator|.
name|n_numaux
expr_stmt|;
comment|/* If we are stripping all symbols, we want to skip this one.  */
if|if
condition|(
name|finfo
operator|->
name|info
operator|->
name|strip
operator|==
name|strip_all
operator|&&
operator|!
name|dont_skip_symbol
condition|)
name|skip
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|skip
condition|)
block|{
switch|switch
condition|(
name|classification
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|COFF_SYMBOL_GLOBAL
case|:
case|case
name|COFF_SYMBOL_COMMON
case|:
case|case
name|COFF_SYMBOL_PE_SECTION
case|:
comment|/* This is a global symbol.  Global symbols come at the 		 end of the symbol table, so skip them for now. 		 Locally defined function symbols, however, are an 		 exception, and are not moved to the end.  */
name|global
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|ISFCN
argument_list|(
name|isym
operator|.
name|n_type
argument_list|)
condition|)
name|skip
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|COFF_SYMBOL_UNDEFINED
case|:
comment|/* Undefined symbols are left for the end.  */
name|global
operator|=
name|TRUE
expr_stmt|;
name|skip
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|COFF_SYMBOL_LOCAL
case|:
comment|/* This is a local symbol.  Skip it if we are discarding                  local symbols.  */
if|if
condition|(
name|finfo
operator|->
name|info
operator|->
name|discard
operator|==
name|discard_all
operator|&&
operator|!
name|dont_skip_symbol
condition|)
name|skip
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
ifndef|#
directive|ifndef
name|COFF_WITH_PE
comment|/* Skip section symbols for sections which are not going to be 	 emitted.  */
if|if
condition|(
operator|!
name|skip
operator|&&
name|dont_skip_symbol
operator|==
literal|0
operator|&&
name|isym
operator|.
name|n_sclass
operator|==
name|C_STAT
operator|&&
name|isym
operator|.
name|n_type
operator|==
name|T_NULL
operator|&&
name|isym
operator|.
name|n_numaux
operator|>
literal|0
operator|&&
operator|(
operator|*
name|secpp
operator|)
operator|->
name|output_section
operator|==
name|bfd_abs_section_ptr
condition|)
name|skip
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
comment|/* If we stripping debugging symbols, and this is a debugging          symbol, then skip it.  FIXME: gas sets the section to N_ABS          for some types of debugging symbols; I don't know if this is          a bug or not.  In any case, we handle it here.  */
if|if
condition|(
operator|!
name|skip
operator|&&
name|finfo
operator|->
name|info
operator|->
name|strip
operator|==
name|strip_debugger
operator|&&
operator|!
name|dont_skip_symbol
operator|&&
operator|(
name|isym
operator|.
name|n_scnum
operator|==
name|N_DEBUG
operator|||
operator|(
name|isym
operator|.
name|n_scnum
operator|==
name|N_ABS
operator|&&
operator|(
name|isym
operator|.
name|n_sclass
operator|==
name|C_AUTO
operator|||
name|isym
operator|.
name|n_sclass
operator|==
name|C_REG
operator|||
name|isym
operator|.
name|n_sclass
operator|==
name|C_MOS
operator|||
name|isym
operator|.
name|n_sclass
operator|==
name|C_MOE
operator|||
name|isym
operator|.
name|n_sclass
operator|==
name|C_MOU
operator|||
name|isym
operator|.
name|n_sclass
operator|==
name|C_ARG
operator|||
name|isym
operator|.
name|n_sclass
operator|==
name|C_REGPARM
operator|||
name|isym
operator|.
name|n_sclass
operator|==
name|C_FIELD
operator|||
name|isym
operator|.
name|n_sclass
operator|==
name|C_EOS
operator|)
operator|)
operator|)
condition|)
name|skip
operator|=
name|TRUE
expr_stmt|;
comment|/* If some symbols are stripped based on the name, work out the 	 name and decide whether to skip this symbol.  */
if|if
condition|(
operator|!
name|skip
operator|&&
operator|(
name|finfo
operator|->
name|info
operator|->
name|strip
operator|==
name|strip_some
operator|||
name|finfo
operator|->
name|info
operator|->
name|discard
operator|==
name|discard_l
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|buf
index|[
name|SYMNMLEN
operator|+
literal|1
index|]
decl_stmt|;
name|name
operator|=
name|_bfd_coff_internal_syment_name
argument_list|(
name|input_bfd
argument_list|,
operator|&
name|isym
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|dont_skip_symbol
operator|&&
operator|(
operator|(
name|finfo
operator|->
name|info
operator|->
name|strip
operator|==
name|strip_some
operator|&&
operator|(
name|bfd_hash_lookup
argument_list|(
name|finfo
operator|->
name|info
operator|->
name|keep_hash
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
operator|==
name|NULL
operator|)
operator|)
operator|||
operator|(
operator|!
name|global
operator|&&
name|finfo
operator|->
name|info
operator|->
name|discard
operator|==
name|discard_l
operator|&&
name|bfd_is_local_label_name
argument_list|(
name|input_bfd
argument_list|,
name|name
argument_list|)
operator|)
operator|)
condition|)
name|skip
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* If this is an enum, struct, or union tag, see if we have          already output an identical type.  */
if|if
condition|(
operator|!
name|skip
operator|&&
operator|(
name|finfo
operator|->
name|output_bfd
operator|->
name|flags
operator|&
name|BFD_TRADITIONAL_FORMAT
operator|)
operator|==
literal|0
operator|&&
operator|(
name|isym
operator|.
name|n_sclass
operator|==
name|C_ENTAG
operator|||
name|isym
operator|.
name|n_sclass
operator|==
name|C_STRTAG
operator|||
name|isym
operator|.
name|n_sclass
operator|==
name|C_UNTAG
operator|)
operator|&&
name|isym
operator|.
name|n_numaux
operator|==
literal|1
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|buf
index|[
name|SYMNMLEN
operator|+
literal|1
index|]
decl_stmt|;
name|struct
name|coff_debug_merge_hash_entry
modifier|*
name|mh
decl_stmt|;
name|struct
name|coff_debug_merge_type
modifier|*
name|mt
decl_stmt|;
name|union
name|internal_auxent
name|aux
decl_stmt|;
name|struct
name|coff_debug_merge_element
modifier|*
modifier|*
name|epp
decl_stmt|;
name|bfd_byte
modifier|*
name|esl
decl_stmt|,
modifier|*
name|eslend
decl_stmt|;
name|struct
name|internal_syment
modifier|*
name|islp
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|name
operator|=
name|_bfd_coff_internal_syment_name
argument_list|(
name|input_bfd
argument_list|,
operator|&
name|isym
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* Ignore fake names invented by compiler; treat them all as              the same name.  */
if|if
condition|(
operator|*
name|name
operator|==
literal|'~'
operator|||
operator|*
name|name
operator|==
literal|'.'
operator|||
operator|*
name|name
operator|==
literal|'$'
operator|||
operator|(
operator|*
name|name
operator|==
name|bfd_get_symbol_leading_char
argument_list|(
name|input_bfd
argument_list|)
operator|&&
operator|(
name|name
index|[
literal|1
index|]
operator|==
literal|'~'
operator|||
name|name
index|[
literal|1
index|]
operator|==
literal|'.'
operator|||
name|name
index|[
literal|1
index|]
operator|==
literal|'$'
operator|)
operator|)
condition|)
name|name
operator|=
literal|""
expr_stmt|;
name|mh
operator|=
name|coff_debug_merge_hash_lookup
argument_list|(
operator|&
name|finfo
operator|->
name|debug_merge
argument_list|,
name|name
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mh
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* Allocate memory to hold type information.  If this turns              out to be a duplicate, we pass this address to              bfd_release.  */
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|coff_debug_merge_type
argument_list|)
expr_stmt|;
name|mt
operator|=
name|bfd_alloc
argument_list|(
name|input_bfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|mt
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|mt
operator|->
name|class
operator|=
name|isym
operator|.
name|n_sclass
expr_stmt|;
comment|/* Pick up the aux entry, which points to the end of the tag              entries.  */
name|bfd_coff_swap_aux_in
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|esym
operator|+
name|isymesz
operator|)
argument_list|,
name|isym
operator|.
name|n_type
argument_list|,
name|isym
operator|.
name|n_sclass
argument_list|,
literal|0
argument_list|,
name|isym
operator|.
name|n_numaux
argument_list|,
operator|&
name|aux
argument_list|)
expr_stmt|;
comment|/* Gather the elements.  */
name|epp
operator|=
operator|&
name|mt
operator|->
name|elements
expr_stmt|;
name|mt
operator|->
name|elements
operator|=
name|NULL
expr_stmt|;
name|islp
operator|=
name|isymp
operator|+
literal|2
expr_stmt|;
name|esl
operator|=
name|esym
operator|+
literal|2
operator|*
name|isymesz
expr_stmt|;
name|eslend
operator|=
operator|(
operator|(
name|bfd_byte
operator|*
operator|)
name|obj_coff_external_syms
argument_list|(
name|input_bfd
argument_list|)
operator|+
name|aux
operator|.
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_endndx
operator|.
name|l
operator|*
name|isymesz
operator|)
expr_stmt|;
while|while
condition|(
name|esl
operator|<
name|eslend
condition|)
block|{
specifier|const
name|char
modifier|*
name|elename
decl_stmt|;
name|char
name|elebuf
index|[
name|SYMNMLEN
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|name_copy
decl_stmt|;
name|bfd_coff_swap_sym_in
argument_list|(
name|input_bfd
argument_list|,
name|esl
argument_list|,
name|islp
argument_list|)
expr_stmt|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|coff_debug_merge_element
argument_list|)
expr_stmt|;
operator|*
name|epp
operator|=
name|bfd_alloc
argument_list|(
name|input_bfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|epp
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|elename
operator|=
name|_bfd_coff_internal_syment_name
argument_list|(
name|input_bfd
argument_list|,
name|islp
argument_list|,
name|elebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|elename
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|amt
operator|=
name|strlen
argument_list|(
name|elename
argument_list|)
operator|+
literal|1
expr_stmt|;
name|name_copy
operator|=
name|bfd_alloc
argument_list|(
name|input_bfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|name_copy
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|strcpy
argument_list|(
name|name_copy
argument_list|,
name|elename
argument_list|)
expr_stmt|;
operator|(
operator|*
name|epp
operator|)
operator|->
name|name
operator|=
name|name_copy
expr_stmt|;
operator|(
operator|*
name|epp
operator|)
operator|->
name|type
operator|=
name|islp
operator|->
name|n_type
expr_stmt|;
operator|(
operator|*
name|epp
operator|)
operator|->
name|tagndx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|islp
operator|->
name|n_numaux
operator|>=
literal|1
operator|&&
name|islp
operator|->
name|n_type
operator|!=
name|T_NULL
operator|&&
name|islp
operator|->
name|n_sclass
operator|!=
name|C_EOS
condition|)
block|{
name|union
name|internal_auxent
name|eleaux
decl_stmt|;
name|long
name|indx
decl_stmt|;
name|bfd_coff_swap_aux_in
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|esl
operator|+
name|isymesz
operator|)
argument_list|,
name|islp
operator|->
name|n_type
argument_list|,
name|islp
operator|->
name|n_sclass
argument_list|,
literal|0
argument_list|,
name|islp
operator|->
name|n_numaux
argument_list|,
operator|&
name|eleaux
argument_list|)
expr_stmt|;
name|indx
operator|=
name|eleaux
operator|.
name|x_sym
operator|.
name|x_tagndx
operator|.
name|l
expr_stmt|;
comment|/* FIXME: If this tagndx entry refers to a symbol 		     defined later in this file, we just ignore it. 		     Handling this correctly would be tedious, and may 		     not be required.  */
if|if
condition|(
name|indx
operator|>
literal|0
operator|&&
operator|(
name|indx
operator|<
operator|(
operator|(
name|esym
operator|-
operator|(
name|bfd_byte
operator|*
operator|)
name|obj_coff_external_syms
argument_list|(
name|input_bfd
argument_list|)
operator|)
operator|/
operator|(
name|long
operator|)
name|isymesz
operator|)
operator|)
condition|)
block|{
operator|(
operator|*
name|epp
operator|)
operator|->
name|tagndx
operator|=
name|finfo
operator|->
name|sym_indices
index|[
name|indx
index|]
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|epp
operator|)
operator|->
name|tagndx
operator|<
literal|0
condition|)
operator|(
operator|*
name|epp
operator|)
operator|->
name|tagndx
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|epp
operator|=
operator|&
operator|(
operator|*
name|epp
operator|)
operator|->
name|next
expr_stmt|;
operator|*
name|epp
operator|=
name|NULL
expr_stmt|;
name|esl
operator|+=
operator|(
name|islp
operator|->
name|n_numaux
operator|+
literal|1
operator|)
operator|*
name|isymesz
expr_stmt|;
name|islp
operator|+=
name|islp
operator|->
name|n_numaux
operator|+
literal|1
expr_stmt|;
block|}
comment|/* See if we already have a definition which matches this              type.  We always output the type if it has no elements,              for simplicity.  */
if|if
condition|(
name|mt
operator|->
name|elements
operator|==
name|NULL
condition|)
name|bfd_release
argument_list|(
name|input_bfd
argument_list|,
name|mt
argument_list|)
expr_stmt|;
else|else
block|{
name|struct
name|coff_debug_merge_type
modifier|*
name|mtl
decl_stmt|;
for|for
control|(
name|mtl
operator|=
name|mh
operator|->
name|types
init|;
name|mtl
operator|!=
name|NULL
condition|;
name|mtl
operator|=
name|mtl
operator|->
name|next
control|)
block|{
name|struct
name|coff_debug_merge_element
modifier|*
name|me
decl_stmt|,
modifier|*
name|mel
decl_stmt|;
if|if
condition|(
name|mtl
operator|->
name|class
operator|!=
name|mt
operator|->
name|class
condition|)
continue|continue;
for|for
control|(
name|me
operator|=
name|mt
operator|->
name|elements
operator|,
name|mel
operator|=
name|mtl
operator|->
name|elements
init|;
name|me
operator|!=
name|NULL
operator|&&
name|mel
operator|!=
name|NULL
condition|;
name|me
operator|=
name|me
operator|->
name|next
operator|,
name|mel
operator|=
name|mel
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|me
operator|->
name|name
argument_list|,
name|mel
operator|->
name|name
argument_list|)
operator|!=
literal|0
operator|||
name|me
operator|->
name|type
operator|!=
name|mel
operator|->
name|type
operator|||
name|me
operator|->
name|tagndx
operator|!=
name|mel
operator|->
name|tagndx
condition|)
break|break;
block|}
if|if
condition|(
name|me
operator|==
name|NULL
operator|&&
name|mel
operator|==
name|NULL
condition|)
break|break;
block|}
if|if
condition|(
name|mtl
operator|==
name|NULL
operator|||
operator|(
name|bfd_size_type
operator|)
name|mtl
operator|->
name|indx
operator|>=
name|syment_base
condition|)
block|{
comment|/* This is the first definition of this type.  */
name|mt
operator|->
name|indx
operator|=
name|output_index
expr_stmt|;
name|mt
operator|->
name|next
operator|=
name|mh
operator|->
name|types
expr_stmt|;
name|mh
operator|->
name|types
operator|=
name|mt
expr_stmt|;
block|}
else|else
block|{
comment|/* This is a redefinition which can be merged.  */
name|bfd_release
argument_list|(
name|input_bfd
argument_list|,
name|mt
argument_list|)
expr_stmt|;
operator|*
name|indexp
operator|=
name|mtl
operator|->
name|indx
expr_stmt|;
name|add
operator|=
operator|(
name|eslend
operator|-
name|esym
operator|)
operator|/
name|isymesz
expr_stmt|;
name|skip
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
comment|/* We now know whether we are to skip this symbol or not.  */
if|if
condition|(
operator|!
name|skip
condition|)
block|{
comment|/* Adjust the symbol in order to output it.  */
if|if
condition|(
name|isym
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_zeroes
operator|==
literal|0
operator|&&
name|isym
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
operator|!=
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bfd_size_type
name|indx
decl_stmt|;
comment|/* This symbol has a long name.  Enter it in the string 		 table we are building.  Note that we do not check 		 bfd_coff_symname_in_debug.  That is only true for 		 XCOFF, and XCOFF requires different linking code 		 anyhow.  */
name|name
operator|=
name|_bfd_coff_internal_syment_name
argument_list|(
name|input_bfd
argument_list|,
operator|&
name|isym
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|indx
operator|=
name|_bfd_stringtab_add
argument_list|(
name|finfo
operator|->
name|strtab
argument_list|,
name|name
argument_list|,
name|hash
argument_list|,
name|copy
argument_list|)
expr_stmt|;
if|if
condition|(
name|indx
operator|==
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
condition|)
return|return
name|FALSE
return|;
name|isym
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
operator|=
name|STRING_SIZE_SIZE
operator|+
name|indx
expr_stmt|;
block|}
switch|switch
condition|(
name|isym
operator|.
name|n_sclass
condition|)
block|{
case|case
name|C_AUTO
case|:
case|case
name|C_MOS
case|:
case|case
name|C_EOS
case|:
case|case
name|C_MOE
case|:
case|case
name|C_MOU
case|:
case|case
name|C_UNTAG
case|:
case|case
name|C_STRTAG
case|:
case|case
name|C_ENTAG
case|:
case|case
name|C_TPDEF
case|:
case|case
name|C_ARG
case|:
case|case
name|C_USTATIC
case|:
case|case
name|C_REG
case|:
case|case
name|C_REGPARM
case|:
case|case
name|C_FIELD
case|:
comment|/* The symbol value should not be modified.  */
break|break;
case|case
name|C_FCN
case|:
if|if
condition|(
name|obj_pe
argument_list|(
name|input_bfd
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|isym
operator|.
name|n_name
argument_list|,
literal|".bf"
argument_list|)
operator|!=
literal|0
operator|&&
name|isym
operator|.
name|n_scnum
operator|>
literal|0
condition|)
block|{
comment|/* For PE, .lf and .ef get their value left alone, 		     while .bf gets relocated.  However, they all have 		     "real" section numbers, and need to be moved into 		     the new section.  */
name|isym
operator|.
name|n_scnum
operator|=
operator|(
operator|*
name|secpp
operator|)
operator|->
name|output_section
operator|->
name|target_index
expr_stmt|;
break|break;
block|}
comment|/* Fall through.  */
default|default:
case|case
name|C_LABEL
case|:
comment|/* Not completely sure about these 2 */
case|case
name|C_EXTDEF
case|:
case|case
name|C_BLOCK
case|:
case|case
name|C_EFCN
case|:
case|case
name|C_NULL
case|:
case|case
name|C_EXT
case|:
case|case
name|C_STAT
case|:
case|case
name|C_SECTION
case|:
case|case
name|C_NT_WEAK
case|:
comment|/* Compute new symbol location.  */
if|if
condition|(
name|isym
operator|.
name|n_scnum
operator|>
literal|0
condition|)
block|{
name|isym
operator|.
name|n_scnum
operator|=
operator|(
operator|*
name|secpp
operator|)
operator|->
name|output_section
operator|->
name|target_index
expr_stmt|;
name|isym
operator|.
name|n_value
operator|+=
operator|(
operator|*
name|secpp
operator|)
operator|->
name|output_offset
expr_stmt|;
if|if
condition|(
operator|!
name|obj_pe
argument_list|(
name|input_bfd
argument_list|)
condition|)
name|isym
operator|.
name|n_value
operator|-=
operator|(
operator|*
name|secpp
operator|)
operator|->
name|vma
expr_stmt|;
if|if
condition|(
operator|!
name|obj_pe
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|)
condition|)
name|isym
operator|.
name|n_value
operator|+=
operator|(
operator|*
name|secpp
operator|)
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
block|}
break|break;
case|case
name|C_FILE
case|:
comment|/* The value of a C_FILE symbol is the symbol index of 		 the next C_FILE symbol.  The value of the last C_FILE 		 symbol is the symbol index to the first external 		 symbol (actually, coff_renumber_symbols does not get 		 this right--it just sets the value of the last C_FILE 		 symbol to zero--and nobody has ever complained about 		 it).  We try to get this right, below, just before we 		 write the symbols out, but in the general case we may 		 have to write the symbol out twice.  */
if|if
condition|(
name|finfo
operator|->
name|last_file_index
operator|!=
operator|-
literal|1
operator|&&
name|finfo
operator|->
name|last_file
operator|.
name|n_value
operator|!=
operator|(
name|bfd_vma
operator|)
name|output_index
condition|)
block|{
comment|/* We must correct the value of the last C_FILE                      entry.  */
name|finfo
operator|->
name|last_file
operator|.
name|n_value
operator|=
name|output_index
expr_stmt|;
if|if
condition|(
operator|(
name|bfd_size_type
operator|)
name|finfo
operator|->
name|last_file_index
operator|>=
name|syment_base
condition|)
block|{
comment|/* The last C_FILE symbol is in this input file.  */
name|bfd_coff_swap_sym_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|finfo
operator|->
name|last_file
argument_list|,
operator|(
name|finfo
operator|->
name|outsyms
operator|+
operator|(
operator|(
name|finfo
operator|->
name|last_file_index
operator|-
name|syment_base
operator|)
operator|*
name|osymesz
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|file_ptr
name|pos
decl_stmt|;
comment|/* We have already written out the last C_FILE 			 symbol.  We need to write it out again.  We 			 borrow *outsym temporarily.  */
name|bfd_coff_swap_sym_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|finfo
operator|->
name|last_file
argument_list|,
name|outsym
argument_list|)
expr_stmt|;
name|pos
operator|=
name|obj_sym_filepos
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|finfo
operator|->
name|last_file_index
operator|*
name|osymesz
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|output_bfd
argument_list|,
name|pos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bwrite
argument_list|(
name|outsym
argument_list|,
name|osymesz
argument_list|,
name|output_bfd
argument_list|)
operator|!=
name|osymesz
condition|)
return|return
name|FALSE
return|;
block|}
block|}
name|finfo
operator|->
name|last_file_index
operator|=
name|output_index
expr_stmt|;
name|finfo
operator|->
name|last_file
operator|=
name|isym
expr_stmt|;
break|break;
block|}
comment|/* If doing task linking, convert normal global function symbols to 	     static functions.  */
if|if
condition|(
name|finfo
operator|->
name|info
operator|->
name|task_link
operator|&&
name|IS_EXTERNAL
argument_list|(
name|input_bfd
argument_list|,
name|isym
argument_list|)
condition|)
name|isym
operator|.
name|n_sclass
operator|=
name|C_STAT
expr_stmt|;
comment|/* Output the symbol.  */
name|bfd_coff_swap_sym_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|isym
argument_list|,
name|outsym
argument_list|)
expr_stmt|;
operator|*
name|indexp
operator|=
name|output_index
expr_stmt|;
if|if
condition|(
name|global
condition|)
block|{
name|long
name|indx
decl_stmt|;
name|struct
name|coff_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|indx
operator|=
operator|(
operator|(
name|esym
operator|-
operator|(
name|bfd_byte
operator|*
operator|)
name|obj_coff_external_syms
argument_list|(
name|input_bfd
argument_list|)
operator|)
operator|/
name|isymesz
operator|)
expr_stmt|;
name|h
operator|=
name|obj_coff_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
index|[
name|indx
index|]
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
block|{
comment|/* This can happen if there were errors earlier in                      the link.  */
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|h
operator|->
name|indx
operator|=
name|output_index
expr_stmt|;
block|}
name|output_index
operator|+=
name|add
expr_stmt|;
name|outsym
operator|+=
name|add
operator|*
name|osymesz
expr_stmt|;
block|}
name|esym
operator|+=
name|add
operator|*
name|isymesz
expr_stmt|;
name|isymp
operator|+=
name|add
expr_stmt|;
operator|++
name|secpp
expr_stmt|;
operator|++
name|indexp
expr_stmt|;
for|for
control|(
operator|--
name|add
init|;
name|add
operator|>
literal|0
condition|;
operator|--
name|add
control|)
block|{
operator|*
name|secpp
operator|++
operator|=
name|NULL
expr_stmt|;
operator|*
name|indexp
operator|++
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
comment|/* Fix up the aux entries.  This must be done in a separate pass,      because we don't know the correct symbol indices until we have      already decided which symbols we are going to keep.  */
name|esym
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|obj_coff_external_syms
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|esym_end
operator|=
name|esym
operator|+
name|obj_raw_syment_count
argument_list|(
name|input_bfd
argument_list|)
operator|*
name|isymesz
expr_stmt|;
name|isymp
operator|=
name|finfo
operator|->
name|internal_syms
expr_stmt|;
name|indexp
operator|=
name|finfo
operator|->
name|sym_indices
expr_stmt|;
name|sym_hash
operator|=
name|obj_coff_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|outsym
operator|=
name|finfo
operator|->
name|outsyms
expr_stmt|;
while|while
condition|(
name|esym
operator|<
name|esym_end
condition|)
block|{
name|int
name|add
decl_stmt|;
name|add
operator|=
literal|1
operator|+
name|isymp
operator|->
name|n_numaux
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|indexp
operator|<
literal|0
operator|||
operator|(
name|bfd_size_type
operator|)
operator|*
name|indexp
operator|<
name|syment_base
operator|)
operator|&&
operator|(
operator|*
name|sym_hash
operator|==
name|NULL
operator|||
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|auxbfd
operator|!=
name|input_bfd
operator|)
condition|)
name|esym
operator|+=
name|add
operator|*
name|isymesz
expr_stmt|;
else|else
block|{
name|struct
name|coff_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|int
name|i
decl_stmt|;
name|h
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|*
name|indexp
operator|<
literal|0
condition|)
block|{
name|h
operator|=
operator|*
name|sym_hash
expr_stmt|;
comment|/* The m68k-motorola-sysv assembler will sometimes                  generate two symbols with the same name, but only one                  will have aux entries.  */
name|BFD_ASSERT
argument_list|(
name|isymp
operator|->
name|n_numaux
operator|==
literal|0
operator|||
name|h
operator|->
name|numaux
operator|==
literal|0
operator|||
name|h
operator|->
name|numaux
operator|==
name|isymp
operator|->
name|n_numaux
argument_list|)
expr_stmt|;
block|}
name|esym
operator|+=
name|isymesz
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
name|outsym
operator|+=
name|osymesz
expr_stmt|;
comment|/* Handle the aux entries.  This handling is based on 	     coff_pointerize_aux.  I don't know if it always correct.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|isymp
operator|->
name|n_numaux
operator|&&
name|esym
operator|<
name|esym_end
condition|;
name|i
operator|++
control|)
block|{
name|union
name|internal_auxent
name|aux
decl_stmt|;
name|union
name|internal_auxent
modifier|*
name|auxp
decl_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|aux
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|numaux
operator|>
name|i
operator|)
condition|)
name|auxp
operator|=
name|h
operator|->
name|aux
operator|+
name|i
expr_stmt|;
else|else
block|{
name|bfd_coff_swap_aux_in
argument_list|(
name|input_bfd
argument_list|,
name|esym
argument_list|,
name|isymp
operator|->
name|n_type
argument_list|,
name|isymp
operator|->
name|n_sclass
argument_list|,
name|i
argument_list|,
name|isymp
operator|->
name|n_numaux
argument_list|,
operator|&
name|aux
argument_list|)
expr_stmt|;
name|auxp
operator|=
operator|&
name|aux
expr_stmt|;
block|}
if|if
condition|(
name|isymp
operator|->
name|n_sclass
operator|==
name|C_FILE
condition|)
block|{
comment|/* If this is a long filename, we must put it in the 		     string table.  */
if|if
condition|(
name|auxp
operator|->
name|x_file
operator|.
name|x_n
operator|.
name|x_zeroes
operator|==
literal|0
operator|&&
name|auxp
operator|->
name|x_file
operator|.
name|x_n
operator|.
name|x_offset
operator|!=
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|bfd_size_type
name|indx
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|auxp
operator|->
name|x_file
operator|.
name|x_n
operator|.
name|x_offset
operator|>=
name|STRING_SIZE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|strings
operator|==
name|NULL
condition|)
block|{
name|strings
operator|=
name|_bfd_coff_read_string_table
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|strings
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
name|filename
operator|=
name|strings
operator|+
name|auxp
operator|->
name|x_file
operator|.
name|x_n
operator|.
name|x_offset
expr_stmt|;
name|indx
operator|=
name|_bfd_stringtab_add
argument_list|(
name|finfo
operator|->
name|strtab
argument_list|,
name|filename
argument_list|,
name|hash
argument_list|,
name|copy
argument_list|)
expr_stmt|;
if|if
condition|(
name|indx
operator|==
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
condition|)
return|return
name|FALSE
return|;
name|auxp
operator|->
name|x_file
operator|.
name|x_n
operator|.
name|x_offset
operator|=
name|STRING_SIZE_SIZE
operator|+
name|indx
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|isymp
operator|->
name|n_sclass
operator|!=
name|C_STAT
operator|||
name|isymp
operator|->
name|n_type
operator|!=
name|T_NULL
operator|)
operator|&&
name|isymp
operator|->
name|n_sclass
operator|!=
name|C_NT_WEAK
condition|)
block|{
name|unsigned
name|long
name|indx
decl_stmt|;
if|if
condition|(
name|ISFCN
argument_list|(
name|isymp
operator|->
name|n_type
argument_list|)
operator|||
name|ISTAG
argument_list|(
name|isymp
operator|->
name|n_sclass
argument_list|)
operator|||
name|isymp
operator|->
name|n_sclass
operator|==
name|C_BLOCK
operator|||
name|isymp
operator|->
name|n_sclass
operator|==
name|C_FCN
condition|)
block|{
name|indx
operator|=
name|auxp
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_endndx
operator|.
name|l
expr_stmt|;
if|if
condition|(
name|indx
operator|>
literal|0
operator|&&
name|indx
operator|<
name|obj_raw_syment_count
argument_list|(
name|input_bfd
argument_list|)
condition|)
block|{
comment|/* We look forward through the symbol for                              the index of the next symbol we are going                              to include.  I don't know if this is                              entirely right.  */
while|while
condition|(
operator|(
name|finfo
operator|->
name|sym_indices
index|[
name|indx
index|]
operator|<
literal|0
operator|||
operator|(
operator|(
name|bfd_size_type
operator|)
name|finfo
operator|->
name|sym_indices
index|[
name|indx
index|]
operator|<
name|syment_base
operator|)
operator|)
operator|&&
name|indx
operator|<
name|obj_raw_syment_count
argument_list|(
name|input_bfd
argument_list|)
condition|)
operator|++
name|indx
expr_stmt|;
if|if
condition|(
name|indx
operator|>=
name|obj_raw_syment_count
argument_list|(
name|input_bfd
argument_list|)
condition|)
name|indx
operator|=
name|output_index
expr_stmt|;
else|else
name|indx
operator|=
name|finfo
operator|->
name|sym_indices
index|[
name|indx
index|]
expr_stmt|;
name|auxp
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_endndx
operator|.
name|l
operator|=
name|indx
expr_stmt|;
block|}
block|}
name|indx
operator|=
name|auxp
operator|->
name|x_sym
operator|.
name|x_tagndx
operator|.
name|l
expr_stmt|;
if|if
condition|(
name|indx
operator|>
literal|0
operator|&&
name|indx
operator|<
name|obj_raw_syment_count
argument_list|(
name|input_bfd
argument_list|)
condition|)
block|{
name|long
name|symindx
decl_stmt|;
name|symindx
operator|=
name|finfo
operator|->
name|sym_indices
index|[
name|indx
index|]
expr_stmt|;
if|if
condition|(
name|symindx
operator|<
literal|0
condition|)
name|auxp
operator|->
name|x_sym
operator|.
name|x_tagndx
operator|.
name|l
operator|=
literal|0
expr_stmt|;
else|else
name|auxp
operator|->
name|x_sym
operator|.
name|x_tagndx
operator|.
name|l
operator|=
name|symindx
expr_stmt|;
block|}
comment|/* The .bf symbols are supposed to be linked through 		     the endndx field.  We need to carry this list 		     across object files.  */
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
name|h
operator|==
name|NULL
operator|&&
name|isymp
operator|->
name|n_sclass
operator|==
name|C_FCN
operator|&&
operator|(
name|isymp
operator|->
name|_n
operator|.
name|_n_n
operator|.
name|_n_zeroes
operator|!=
literal|0
operator|||
name|isymp
operator|->
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
operator|==
literal|0
operator|)
operator|&&
name|isymp
operator|->
name|_n
operator|.
name|_n_name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|isymp
operator|->
name|_n
operator|.
name|_n_name
index|[
literal|1
index|]
operator|==
literal|'b'
operator|&&
name|isymp
operator|->
name|_n
operator|.
name|_n_name
index|[
literal|2
index|]
operator|==
literal|'f'
operator|&&
name|isymp
operator|->
name|_n
operator|.
name|_n_name
index|[
literal|3
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|finfo
operator|->
name|last_bf_index
operator|!=
operator|-
literal|1
condition|)
block|{
name|finfo
operator|->
name|last_bf
operator|.
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_endndx
operator|.
name|l
operator|=
operator|*
name|indexp
expr_stmt|;
if|if
condition|(
operator|(
name|bfd_size_type
operator|)
name|finfo
operator|->
name|last_bf_index
operator|>=
name|syment_base
condition|)
block|{
name|void
modifier|*
name|auxout
decl_stmt|;
comment|/* The last .bf symbol is in this input 				 file.  This will only happen if the 				 assembler did not set up the .bf 				 endndx symbols correctly.  */
name|auxout
operator|=
operator|(
name|finfo
operator|->
name|outsyms
operator|+
operator|(
operator|(
name|finfo
operator|->
name|last_bf_index
operator|-
name|syment_base
operator|)
operator|*
name|osymesz
operator|)
operator|)
expr_stmt|;
name|bfd_coff_swap_aux_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|finfo
operator|->
name|last_bf
argument_list|,
name|isymp
operator|->
name|n_type
argument_list|,
name|isymp
operator|->
name|n_sclass
argument_list|,
literal|0
argument_list|,
name|isymp
operator|->
name|n_numaux
argument_list|,
name|auxout
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|file_ptr
name|pos
decl_stmt|;
comment|/* We have already written out the last                                  .bf aux entry.  We need to write it                                  out again.  We borrow *outsym                                  temporarily.  FIXME: This case should                                  be made faster.  */
name|bfd_coff_swap_aux_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|finfo
operator|->
name|last_bf
argument_list|,
name|isymp
operator|->
name|n_type
argument_list|,
name|isymp
operator|->
name|n_sclass
argument_list|,
literal|0
argument_list|,
name|isymp
operator|->
name|n_numaux
argument_list|,
name|outsym
argument_list|)
expr_stmt|;
name|pos
operator|=
name|obj_sym_filepos
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|finfo
operator|->
name|last_bf_index
operator|*
name|osymesz
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|output_bfd
argument_list|,
name|pos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|bfd_bwrite
argument_list|(
name|outsym
argument_list|,
name|osymesz
argument_list|,
name|output_bfd
argument_list|)
operator|!=
name|osymesz
operator|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
if|if
condition|(
name|auxp
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_endndx
operator|.
name|l
operator|!=
literal|0
condition|)
name|finfo
operator|->
name|last_bf_index
operator|=
operator|-
literal|1
expr_stmt|;
else|else
block|{
comment|/* The endndx field of this aux entry must                              be updated with the symbol number of the                              next .bf symbol.  */
name|finfo
operator|->
name|last_bf
operator|=
operator|*
name|auxp
expr_stmt|;
name|finfo
operator|->
name|last_bf_index
operator|=
operator|(
operator|(
operator|(
name|outsym
operator|-
name|finfo
operator|->
name|outsyms
operator|)
operator|/
name|osymesz
operator|)
operator|+
name|syment_base
operator|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
block|{
name|bfd_coff_swap_aux_out
argument_list|(
name|output_bfd
argument_list|,
name|auxp
argument_list|,
name|isymp
operator|->
name|n_type
argument_list|,
name|isymp
operator|->
name|n_sclass
argument_list|,
name|i
argument_list|,
name|isymp
operator|->
name|n_numaux
argument_list|,
name|outsym
argument_list|)
expr_stmt|;
name|outsym
operator|+=
name|osymesz
expr_stmt|;
block|}
name|esym
operator|+=
name|isymesz
expr_stmt|;
block|}
block|}
name|indexp
operator|+=
name|add
expr_stmt|;
name|isymp
operator|+=
name|add
expr_stmt|;
name|sym_hash
operator|+=
name|add
expr_stmt|;
block|}
comment|/* Relocate the line numbers, unless we are stripping them.  */
if|if
condition|(
name|finfo
operator|->
name|info
operator|->
name|strip
operator|==
name|strip_none
operator|||
name|finfo
operator|->
name|info
operator|->
name|strip
operator|==
name|strip_some
condition|)
block|{
for|for
control|(
name|o
operator|=
name|input_bfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
name|bfd_vma
name|offset
decl_stmt|;
name|bfd_byte
modifier|*
name|eline
decl_stmt|;
name|bfd_byte
modifier|*
name|elineend
decl_stmt|;
name|bfd_byte
modifier|*
name|oeline
decl_stmt|;
name|bfd_boolean
name|skipping
decl_stmt|;
name|file_ptr
name|pos
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
comment|/* FIXME: If SEC_HAS_CONTENTS is not for the section, then 	     build_link_order in ldwrite.c will not have created a 	     link order, which means that we will not have seen this 	     input section in _bfd_coff_final_link, which means that 	     we will not have allocated space for the line numbers of 	     this section.  I don't think line numbers can be 	     meaningful for a section which does not have 	     SEC_HAS_CONTENTS set, but, if they do, this must be 	     changed.  */
if|if
condition|(
name|o
operator|->
name|lineno_count
operator|==
literal|0
operator|||
operator|(
name|o
operator|->
name|output_section
operator|->
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|bfd_seek
argument_list|(
name|input_bfd
argument_list|,
name|o
operator|->
name|line_filepos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bread
argument_list|(
name|finfo
operator|->
name|linenos
argument_list|,
name|linesz
operator|*
name|o
operator|->
name|lineno_count
argument_list|,
name|input_bfd
argument_list|)
operator|!=
name|linesz
operator|*
name|o
operator|->
name|lineno_count
condition|)
return|return
name|FALSE
return|;
name|offset
operator|=
name|o
operator|->
name|output_section
operator|->
name|vma
operator|+
name|o
operator|->
name|output_offset
operator|-
name|o
operator|->
name|vma
expr_stmt|;
name|eline
operator|=
name|finfo
operator|->
name|linenos
expr_stmt|;
name|oeline
operator|=
name|finfo
operator|->
name|linenos
expr_stmt|;
name|elineend
operator|=
name|eline
operator|+
name|linesz
operator|*
name|o
operator|->
name|lineno_count
expr_stmt|;
name|skipping
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
init|;
name|eline
operator|<
name|elineend
condition|;
name|eline
operator|+=
name|linesz
control|)
block|{
name|struct
name|internal_lineno
name|iline
decl_stmt|;
name|bfd_coff_swap_lineno_in
argument_list|(
name|input_bfd
argument_list|,
name|eline
argument_list|,
operator|&
name|iline
argument_list|)
expr_stmt|;
if|if
condition|(
name|iline
operator|.
name|l_lnno
operator|!=
literal|0
condition|)
name|iline
operator|.
name|l_addr
operator|.
name|l_paddr
operator|+=
name|offset
expr_stmt|;
elseif|else
if|if
condition|(
name|iline
operator|.
name|l_addr
operator|.
name|l_symndx
operator|>=
literal|0
operator|&&
operator|(
operator|(
name|unsigned
name|long
operator|)
name|iline
operator|.
name|l_addr
operator|.
name|l_symndx
operator|<
name|obj_raw_syment_count
argument_list|(
name|input_bfd
argument_list|)
operator|)
condition|)
block|{
name|long
name|indx
decl_stmt|;
name|indx
operator|=
name|finfo
operator|->
name|sym_indices
index|[
name|iline
operator|.
name|l_addr
operator|.
name|l_symndx
index|]
expr_stmt|;
if|if
condition|(
name|indx
operator|<
literal|0
condition|)
block|{
comment|/* These line numbers are attached to a symbol 			 which we are stripping.  We must discard the 			 line numbers because reading them back with 			 no associated symbol (or associating them all 			 with symbol #0) will fail.  We can't regain 			 the space in the output file, but at least 			 they're dense.  */
name|skipping
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|struct
name|internal_syment
name|is
decl_stmt|;
name|union
name|internal_auxent
name|ia
decl_stmt|;
comment|/* Fix up the lnnoptr field in the aux entry of 			 the symbol.  It turns out that we can't do 			 this when we modify the symbol aux entries, 			 because gas sometimes screws up the lnnoptr 			 field and makes it an offset from the start 			 of the line numbers rather than an absolute 			 file index.  */
name|bfd_coff_swap_sym_in
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|finfo
operator|->
name|outsyms
operator|+
operator|(
operator|(
name|indx
operator|-
name|syment_base
operator|)
operator|*
name|osymesz
operator|)
operator|)
argument_list|,
operator|&
name|is
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ISFCN
argument_list|(
name|is
operator|.
name|n_type
argument_list|)
operator|||
name|is
operator|.
name|n_sclass
operator|==
name|C_BLOCK
operator|)
operator|&&
name|is
operator|.
name|n_numaux
operator|>=
literal|1
condition|)
block|{
name|void
modifier|*
name|auxptr
decl_stmt|;
name|auxptr
operator|=
operator|(
name|finfo
operator|->
name|outsyms
operator|+
operator|(
operator|(
name|indx
operator|-
name|syment_base
operator|+
literal|1
operator|)
operator|*
name|osymesz
operator|)
operator|)
expr_stmt|;
name|bfd_coff_swap_aux_in
argument_list|(
name|output_bfd
argument_list|,
name|auxptr
argument_list|,
name|is
operator|.
name|n_type
argument_list|,
name|is
operator|.
name|n_sclass
argument_list|,
literal|0
argument_list|,
name|is
operator|.
name|n_numaux
argument_list|,
operator|&
name|ia
argument_list|)
expr_stmt|;
name|ia
operator|.
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_lnnoptr
operator|=
operator|(
name|o
operator|->
name|output_section
operator|->
name|line_filepos
operator|+
name|o
operator|->
name|output_section
operator|->
name|lineno_count
operator|*
name|linesz
operator|+
name|eline
operator|-
name|finfo
operator|->
name|linenos
operator|)
expr_stmt|;
name|bfd_coff_swap_aux_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|ia
argument_list|,
name|is
operator|.
name|n_type
argument_list|,
name|is
operator|.
name|n_sclass
argument_list|,
literal|0
argument_list|,
name|is
operator|.
name|n_numaux
argument_list|,
name|auxptr
argument_list|)
expr_stmt|;
block|}
name|skipping
operator|=
name|FALSE
expr_stmt|;
block|}
name|iline
operator|.
name|l_addr
operator|.
name|l_symndx
operator|=
name|indx
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|skipping
condition|)
block|{
name|bfd_coff_swap_lineno_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|iline
argument_list|,
name|oeline
argument_list|)
expr_stmt|;
name|oeline
operator|+=
name|linesz
expr_stmt|;
block|}
block|}
name|pos
operator|=
name|o
operator|->
name|output_section
operator|->
name|line_filepos
expr_stmt|;
name|pos
operator|+=
name|o
operator|->
name|output_section
operator|->
name|lineno_count
operator|*
name|linesz
expr_stmt|;
name|amt
operator|=
name|oeline
operator|-
name|finfo
operator|->
name|linenos
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|output_bfd
argument_list|,
name|pos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bwrite
argument_list|(
name|finfo
operator|->
name|linenos
argument_list|,
name|amt
argument_list|,
name|output_bfd
argument_list|)
operator|!=
name|amt
condition|)
return|return
name|FALSE
return|;
name|o
operator|->
name|output_section
operator|->
name|lineno_count
operator|+=
name|amt
operator|/
name|linesz
expr_stmt|;
block|}
block|}
comment|/* If we swapped out a C_FILE symbol, guess that the next C_FILE      symbol will be the first symbol in the next input file.  In the      normal case, this will save us from writing out the C_FILE symbol      again.  */
if|if
condition|(
name|finfo
operator|->
name|last_file_index
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|bfd_size_type
operator|)
name|finfo
operator|->
name|last_file_index
operator|>=
name|syment_base
condition|)
block|{
name|finfo
operator|->
name|last_file
operator|.
name|n_value
operator|=
name|output_index
expr_stmt|;
name|bfd_coff_swap_sym_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|finfo
operator|->
name|last_file
argument_list|,
operator|(
name|finfo
operator|->
name|outsyms
operator|+
operator|(
operator|(
name|finfo
operator|->
name|last_file_index
operator|-
name|syment_base
operator|)
operator|*
name|osymesz
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Write the modified symbols to the output file.  */
if|if
condition|(
name|outsym
operator|>
name|finfo
operator|->
name|outsyms
condition|)
block|{
name|file_ptr
name|pos
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|pos
operator|=
name|obj_sym_filepos
argument_list|(
name|output_bfd
argument_list|)
operator|+
name|syment_base
operator|*
name|osymesz
expr_stmt|;
name|amt
operator|=
name|outsym
operator|-
name|finfo
operator|->
name|outsyms
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|output_bfd
argument_list|,
name|pos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bwrite
argument_list|(
name|finfo
operator|->
name|outsyms
argument_list|,
name|amt
argument_list|,
name|output_bfd
argument_list|)
operator|!=
name|amt
condition|)
return|return
name|FALSE
return|;
name|BFD_ASSERT
argument_list|(
operator|(
name|obj_raw_syment_count
argument_list|(
name|output_bfd
argument_list|)
operator|+
operator|(
name|outsym
operator|-
name|finfo
operator|->
name|outsyms
operator|)
operator|/
name|osymesz
operator|)
operator|==
name|output_index
argument_list|)
expr_stmt|;
name|obj_raw_syment_count
argument_list|(
name|output_bfd
argument_list|)
operator|=
name|output_index
expr_stmt|;
block|}
comment|/* Relocate the contents of each section.  */
name|adjust_symndx
operator|=
name|coff_backend_info
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|_bfd_coff_adjust_symndx
expr_stmt|;
for|for
control|(
name|o
operator|=
name|input_bfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|struct
name|coff_section_tdata
modifier|*
name|secdata
decl_stmt|;
if|if
condition|(
operator|!
name|o
operator|->
name|linker_mark
condition|)
comment|/* This section was omitted from the link.  */
continue|continue;
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_LINKER_CREATED
operator|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|==
literal|0
operator|||
operator|(
name|o
operator|->
name|size
operator|==
literal|0
operator|&&
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|!=
literal|0
operator|&&
name|o
operator|->
name|reloc_count
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: relocs in section `%A', but it has no contents"
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|o
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_no_contents
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
continue|continue;
block|}
name|secdata
operator|=
name|coff_section_data
argument_list|(
name|input_bfd
argument_list|,
name|o
argument_list|)
expr_stmt|;
if|if
condition|(
name|secdata
operator|!=
name|NULL
operator|&&
name|secdata
operator|->
name|contents
operator|!=
name|NULL
condition|)
name|contents
operator|=
name|secdata
operator|->
name|contents
expr_stmt|;
else|else
block|{
name|bfd_size_type
name|x
init|=
name|o
operator|->
name|rawsize
condition|?
name|o
operator|->
name|rawsize
else|:
name|o
operator|->
name|size
decl_stmt|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|input_bfd
argument_list|,
name|o
argument_list|,
name|finfo
operator|->
name|contents
argument_list|,
literal|0
argument_list|,
name|x
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|contents
operator|=
name|finfo
operator|->
name|contents
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|!=
literal|0
condition|)
block|{
name|int
name|target_index
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|internal_relocs
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|irel
decl_stmt|;
comment|/* Read in the relocs.  */
name|target_index
operator|=
name|o
operator|->
name|output_section
operator|->
name|target_index
expr_stmt|;
name|internal_relocs
operator|=
operator|(
name|_bfd_coff_read_internal_relocs
argument_list|(
name|input_bfd
argument_list|,
name|o
argument_list|,
name|FALSE
argument_list|,
name|finfo
operator|->
name|external_relocs
argument_list|,
name|finfo
operator|->
name|info
operator|->
name|relocatable
argument_list|,
operator|(
name|finfo
operator|->
name|info
operator|->
name|relocatable
condition|?
operator|(
name|finfo
operator|->
name|section_info
index|[
name|target_index
index|]
operator|.
name|relocs
operator|+
name|o
operator|->
name|output_section
operator|->
name|reloc_count
operator|)
else|:
name|finfo
operator|->
name|internal_relocs
operator|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* Call processor specific code to relocate the section              contents.  */
if|if
condition|(
operator|!
name|bfd_coff_relocate_section
argument_list|(
name|output_bfd
argument_list|,
name|finfo
operator|->
name|info
argument_list|,
name|input_bfd
argument_list|,
name|o
argument_list|,
name|contents
argument_list|,
name|internal_relocs
argument_list|,
name|finfo
operator|->
name|internal_syms
argument_list|,
name|finfo
operator|->
name|sec_ptrs
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|finfo
operator|->
name|info
operator|->
name|relocatable
condition|)
block|{
name|bfd_vma
name|offset
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|irelend
decl_stmt|;
name|struct
name|coff_link_hash_entry
modifier|*
modifier|*
name|rel_hash
decl_stmt|;
name|offset
operator|=
name|o
operator|->
name|output_section
operator|->
name|vma
operator|+
name|o
operator|->
name|output_offset
operator|-
name|o
operator|->
name|vma
expr_stmt|;
name|irel
operator|=
name|internal_relocs
expr_stmt|;
name|irelend
operator|=
name|irel
operator|+
name|o
operator|->
name|reloc_count
expr_stmt|;
name|rel_hash
operator|=
operator|(
name|finfo
operator|->
name|section_info
index|[
name|target_index
index|]
operator|.
name|rel_hashes
operator|+
name|o
operator|->
name|output_section
operator|->
name|reloc_count
operator|)
expr_stmt|;
for|for
control|(
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
operator|,
name|rel_hash
operator|++
control|)
block|{
name|struct
name|coff_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|bfd_boolean
name|adjusted
decl_stmt|;
operator|*
name|rel_hash
operator|=
name|NULL
expr_stmt|;
comment|/* Adjust the reloc address and symbol index.  */
name|irel
operator|->
name|r_vaddr
operator|+=
name|offset
expr_stmt|;
if|if
condition|(
name|irel
operator|->
name|r_symndx
operator|==
operator|-
literal|1
condition|)
continue|continue;
if|if
condition|(
name|adjust_symndx
condition|)
block|{
if|if
condition|(
operator|!
call|(
modifier|*
name|adjust_symndx
call|)
argument_list|(
name|output_bfd
argument_list|,
name|finfo
operator|->
name|info
argument_list|,
name|input_bfd
argument_list|,
name|o
argument_list|,
name|irel
argument_list|,
operator|&
name|adjusted
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|adjusted
condition|)
continue|continue;
block|}
name|h
operator|=
name|obj_coff_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
index|[
name|irel
operator|->
name|r_symndx
index|]
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
comment|/* This is a global symbol.  */
if|if
condition|(
name|h
operator|->
name|indx
operator|>=
literal|0
condition|)
name|irel
operator|->
name|r_symndx
operator|=
name|h
operator|->
name|indx
expr_stmt|;
else|else
block|{
comment|/* This symbol is being written at the end 			     of the file, and we do not yet know the 			     symbol index.  We save the pointer to the 			     hash table entry in the rel_hash list. 			     We set the indx field to -2 to indicate 			     that this symbol must not be stripped.  */
operator|*
name|rel_hash
operator|=
name|h
expr_stmt|;
name|h
operator|->
name|indx
operator|=
operator|-
literal|2
expr_stmt|;
block|}
block|}
else|else
block|{
name|long
name|indx
decl_stmt|;
name|indx
operator|=
name|finfo
operator|->
name|sym_indices
index|[
name|irel
operator|->
name|r_symndx
index|]
expr_stmt|;
if|if
condition|(
name|indx
operator|!=
operator|-
literal|1
condition|)
name|irel
operator|->
name|r_symndx
operator|=
name|indx
expr_stmt|;
else|else
block|{
name|struct
name|internal_syment
modifier|*
name|is
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|buf
index|[
name|SYMNMLEN
operator|+
literal|1
index|]
decl_stmt|;
comment|/* This reloc is against a symbol we are                              stripping.  This should have been handled 			     by the 'dont_skip_symbol' code in the while 			     loop at the top of this function.  */
name|is
operator|=
name|finfo
operator|->
name|internal_syms
operator|+
name|irel
operator|->
name|r_symndx
expr_stmt|;
name|name
operator|=
operator|(
name|_bfd_coff_internal_syment_name
argument_list|(
name|input_bfd
argument_list|,
name|is
argument_list|,
name|buf
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|finfo
operator|->
name|info
operator|->
name|callbacks
operator|->
name|unattached_reloc
call|)
argument_list|(
name|finfo
operator|->
name|info
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|o
argument_list|,
name|irel
operator|->
name|r_vaddr
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
block|}
name|o
operator|->
name|output_section
operator|->
name|reloc_count
operator|+=
name|o
operator|->
name|reloc_count
expr_stmt|;
block|}
block|}
comment|/* Write out the modified section contents.  */
if|if
condition|(
name|secdata
operator|==
name|NULL
operator|||
name|secdata
operator|->
name|stab_info
operator|==
name|NULL
condition|)
block|{
name|file_ptr
name|loc
init|=
name|o
operator|->
name|output_offset
operator|*
name|bfd_octets_per_byte
argument_list|(
name|output_bfd
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|output_bfd
argument_list|,
name|o
operator|->
name|output_section
argument_list|,
name|contents
argument_list|,
name|loc
argument_list|,
name|o
operator|->
name|size
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|_bfd_write_section_stabs
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|coff_hash_table
argument_list|(
name|finfo
operator|->
name|info
argument_list|)
operator|->
name|stab_info
argument_list|,
name|o
argument_list|,
operator|&
name|secdata
operator|->
name|stab_info
argument_list|,
name|contents
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
if|if
condition|(
operator|!
name|finfo
operator|->
name|info
operator|->
name|keep_memory
operator|&&
operator|!
name|_bfd_coff_free_symbols
argument_list|(
name|input_bfd
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Write out a global symbol.  Called via coff_link_hash_traverse.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_coff_write_global_sym
parameter_list|(
name|struct
name|coff_link_hash_entry
modifier|*
name|h
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|coff_final_link_info
modifier|*
name|finfo
init|=
operator|(
expr|struct
name|coff_final_link_info
operator|*
operator|)
name|data
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|internal_syment
name|isym
decl_stmt|;
name|bfd_size_type
name|symesz
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|file_ptr
name|pos
decl_stmt|;
name|output_bfd
operator|=
name|finfo
operator|->
name|output_bfd
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
block|{
name|h
operator|=
operator|(
expr|struct
name|coff_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_new
condition|)
return|return
name|TRUE
return|;
block|}
if|if
condition|(
name|h
operator|->
name|indx
operator|>=
literal|0
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|h
operator|->
name|indx
operator|!=
operator|-
literal|2
operator|&&
operator|(
name|finfo
operator|->
name|info
operator|->
name|strip
operator|==
name|strip_all
operator|||
operator|(
name|finfo
operator|->
name|info
operator|->
name|strip
operator|==
name|strip_some
operator|&&
operator|(
name|bfd_hash_lookup
argument_list|(
name|finfo
operator|->
name|info
operator|->
name|keep_hash
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
operator|==
name|NULL
operator|)
operator|)
operator|)
condition|)
return|return
name|TRUE
return|;
switch|switch
condition|(
name|h
operator|->
name|root
operator|.
name|type
condition|)
block|{
default|default:
case|case
name|bfd_link_hash_new
case|:
case|case
name|bfd_link_hash_warning
case|:
name|abort
argument_list|()
expr_stmt|;
return|return
name|FALSE
return|;
case|case
name|bfd_link_hash_undefined
case|:
case|case
name|bfd_link_hash_undefweak
case|:
name|isym
operator|.
name|n_scnum
operator|=
name|N_UNDEF
expr_stmt|;
name|isym
operator|.
name|n_value
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|bfd_link_hash_defined
case|:
case|case
name|bfd_link_hash_defweak
case|:
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|sec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
expr_stmt|;
if|if
condition|(
name|bfd_is_abs_section
argument_list|(
name|sec
argument_list|)
condition|)
name|isym
operator|.
name|n_scnum
operator|=
name|N_ABS
expr_stmt|;
else|else
name|isym
operator|.
name|n_scnum
operator|=
name|sec
operator|->
name|target_index
expr_stmt|;
name|isym
operator|.
name|n_value
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|obj_pe
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|)
condition|)
name|isym
operator|.
name|n_value
operator|+=
name|sec
operator|->
name|vma
expr_stmt|;
block|}
break|break;
case|case
name|bfd_link_hash_common
case|:
name|isym
operator|.
name|n_scnum
operator|=
name|N_UNDEF
expr_stmt|;
name|isym
operator|.
name|n_value
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|size
expr_stmt|;
break|break;
case|case
name|bfd_link_hash_indirect
case|:
comment|/* Just ignore these.  They can't be handled anyhow.  */
return|return
name|TRUE
return|;
block|}
if|if
condition|(
name|strlen
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
operator|<=
name|SYMNMLEN
condition|)
name|strncpy
argument_list|(
name|isym
operator|.
name|_n
operator|.
name|_n_name
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|SYMNMLEN
argument_list|)
expr_stmt|;
else|else
block|{
name|bfd_boolean
name|hash
decl_stmt|;
name|bfd_size_type
name|indx
decl_stmt|;
name|hash
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|(
name|output_bfd
operator|->
name|flags
operator|&
name|BFD_TRADITIONAL_FORMAT
operator|)
operator|!=
literal|0
condition|)
name|hash
operator|=
name|FALSE
expr_stmt|;
name|indx
operator|=
name|_bfd_stringtab_add
argument_list|(
name|finfo
operator|->
name|strtab
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|hash
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|indx
operator|==
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
condition|)
block|{
name|finfo
operator|->
name|failed
operator|=
name|TRUE
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|isym
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_zeroes
operator|=
literal|0
expr_stmt|;
name|isym
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
operator|=
name|STRING_SIZE_SIZE
operator|+
name|indx
expr_stmt|;
block|}
name|isym
operator|.
name|n_sclass
operator|=
name|h
operator|->
name|class
expr_stmt|;
name|isym
operator|.
name|n_type
operator|=
name|h
operator|->
name|type
expr_stmt|;
if|if
condition|(
name|isym
operator|.
name|n_sclass
operator|==
name|C_NULL
condition|)
name|isym
operator|.
name|n_sclass
operator|=
name|C_EXT
expr_stmt|;
comment|/* If doing task linking and this is the pass where we convert      defined globals to statics, then do that conversion now.  If the      symbol is not being converted, just ignore it and it will be      output during a later pass.  */
if|if
condition|(
name|finfo
operator|->
name|global_to_static
condition|)
block|{
if|if
condition|(
operator|!
name|IS_EXTERNAL
argument_list|(
name|output_bfd
argument_list|,
name|isym
argument_list|)
condition|)
return|return
name|TRUE
return|;
name|isym
operator|.
name|n_sclass
operator|=
name|C_STAT
expr_stmt|;
block|}
comment|/* When a weak symbol is not overridden by a strong one,      turn it into an external symbol when not building a      shared or relocatable object.  */
if|if
condition|(
operator|!
name|finfo
operator|->
name|info
operator|->
name|shared
operator|&&
operator|!
name|finfo
operator|->
name|info
operator|->
name|relocatable
operator|&&
name|IS_WEAK_EXTERNAL
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|,
name|isym
argument_list|)
condition|)
name|isym
operator|.
name|n_sclass
operator|=
name|C_EXT
expr_stmt|;
name|isym
operator|.
name|n_numaux
operator|=
name|h
operator|->
name|numaux
expr_stmt|;
name|bfd_coff_swap_sym_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|isym
argument_list|,
name|finfo
operator|->
name|outsyms
argument_list|)
expr_stmt|;
name|symesz
operator|=
name|bfd_coff_symesz
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
name|pos
operator|=
name|obj_sym_filepos
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|obj_raw_syment_count
argument_list|(
name|output_bfd
argument_list|)
operator|*
name|symesz
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|output_bfd
argument_list|,
name|pos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bwrite
argument_list|(
name|finfo
operator|->
name|outsyms
argument_list|,
name|symesz
argument_list|,
name|output_bfd
argument_list|)
operator|!=
name|symesz
condition|)
block|{
name|finfo
operator|->
name|failed
operator|=
name|TRUE
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|h
operator|->
name|indx
operator|=
name|obj_raw_syment_count
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
operator|++
name|obj_raw_syment_count
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
comment|/* Write out any associated aux entries.  Most of the aux entries      will have been modified in _bfd_coff_link_input_bfd.  We have to      handle section aux entries here, now that we have the final      relocation and line number counts.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|isym
operator|.
name|n_numaux
condition|;
name|i
operator|++
control|)
block|{
name|union
name|internal_auxent
modifier|*
name|auxp
decl_stmt|;
name|auxp
operator|=
name|h
operator|->
name|aux
operator|+
name|i
expr_stmt|;
comment|/* Look for a section aux entry here using the same tests that          coff_swap_aux_out uses.  */
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
operator|(
name|isym
operator|.
name|n_sclass
operator|==
name|C_STAT
operator|||
name|isym
operator|.
name|n_sclass
operator|==
name|C_HIDDEN
operator|)
operator|&&
name|isym
operator|.
name|n_type
operator|==
name|T_NULL
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
condition|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|sec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
expr_stmt|;
if|if
condition|(
name|sec
operator|!=
name|NULL
condition|)
block|{
name|auxp
operator|->
name|x_scn
operator|.
name|x_scnlen
operator|=
name|sec
operator|->
name|size
expr_stmt|;
comment|/* For PE, an overflow on the final link reportedly does                  not matter.  FIXME: Why not?  */
if|if
condition|(
name|sec
operator|->
name|reloc_count
operator|>
literal|0xffff
operator|&&
operator|(
operator|!
name|obj_pe
argument_list|(
name|output_bfd
argument_list|)
operator|||
name|finfo
operator|->
name|info
operator|->
name|relocatable
operator|)
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: %s: reloc overflow: 0x%lx> 0xffff"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|output_bfd
argument_list|)
argument_list|,
name|bfd_get_section_name
argument_list|(
name|output_bfd
argument_list|,
name|sec
argument_list|)
argument_list|,
name|sec
operator|->
name|reloc_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|lineno_count
operator|>
literal|0xffff
operator|&&
operator|(
operator|!
name|obj_pe
argument_list|(
name|output_bfd
argument_list|)
operator|||
name|finfo
operator|->
name|info
operator|->
name|relocatable
operator|)
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: warning: %s: line number overflow: 0x%lx> 0xffff"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|output_bfd
argument_list|)
argument_list|,
name|bfd_get_section_name
argument_list|(
name|output_bfd
argument_list|,
name|sec
argument_list|)
argument_list|,
name|sec
operator|->
name|lineno_count
argument_list|)
expr_stmt|;
name|auxp
operator|->
name|x_scn
operator|.
name|x_nreloc
operator|=
name|sec
operator|->
name|reloc_count
expr_stmt|;
name|auxp
operator|->
name|x_scn
operator|.
name|x_nlinno
operator|=
name|sec
operator|->
name|lineno_count
expr_stmt|;
name|auxp
operator|->
name|x_scn
operator|.
name|x_checksum
operator|=
literal|0
expr_stmt|;
name|auxp
operator|->
name|x_scn
operator|.
name|x_associated
operator|=
literal|0
expr_stmt|;
name|auxp
operator|->
name|x_scn
operator|.
name|x_comdat
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|bfd_coff_swap_aux_out
argument_list|(
name|output_bfd
argument_list|,
name|auxp
argument_list|,
name|isym
operator|.
name|n_type
argument_list|,
name|isym
operator|.
name|n_sclass
argument_list|,
operator|(
name|int
operator|)
name|i
argument_list|,
name|isym
operator|.
name|n_numaux
argument_list|,
name|finfo
operator|->
name|outsyms
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
name|finfo
operator|->
name|outsyms
argument_list|,
name|symesz
argument_list|,
name|output_bfd
argument_list|)
operator|!=
name|symesz
condition|)
block|{
name|finfo
operator|->
name|failed
operator|=
name|TRUE
expr_stmt|;
return|return
name|FALSE
return|;
block|}
operator|++
name|obj_raw_syment_count
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Write out task global symbols, converting them to statics.  Called    via coff_link_hash_traverse.  Calls bfd_coff_write_global_sym to do    the dirty work, if the symbol we are processing needs conversion.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_coff_write_task_globals
parameter_list|(
name|struct
name|coff_link_hash_entry
modifier|*
name|h
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|coff_final_link_info
modifier|*
name|finfo
init|=
operator|(
expr|struct
name|coff_final_link_info
operator|*
operator|)
name|data
decl_stmt|;
name|bfd_boolean
name|rtnval
init|=
name|TRUE
decl_stmt|;
name|bfd_boolean
name|save_global_to_static
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|coff_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|indx
operator|<
literal|0
condition|)
block|{
switch|switch
condition|(
name|h
operator|->
name|root
operator|.
name|type
condition|)
block|{
case|case
name|bfd_link_hash_defined
case|:
case|case
name|bfd_link_hash_defweak
case|:
name|save_global_to_static
operator|=
name|finfo
operator|->
name|global_to_static
expr_stmt|;
name|finfo
operator|->
name|global_to_static
operator|=
name|TRUE
expr_stmt|;
name|rtnval
operator|=
name|_bfd_coff_write_global_sym
argument_list|(
name|h
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|finfo
operator|->
name|global_to_static
operator|=
name|save_global_to_static
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
return|return
operator|(
name|rtnval
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Handle a link order which is supposed to generate a reloc.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_coff_reloc_link_order
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|coff_final_link_info
modifier|*
name|finfo
parameter_list|,
name|asection
modifier|*
name|output_section
parameter_list|,
name|struct
name|bfd_link_order
modifier|*
name|link_order
parameter_list|)
block|{
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|irel
decl_stmt|;
name|struct
name|coff_link_hash_entry
modifier|*
modifier|*
name|rel_hash_ptr
decl_stmt|;
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|output_bfd
argument_list|,
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|reloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|howto
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|addend
operator|!=
literal|0
condition|)
block|{
name|bfd_size_type
name|size
decl_stmt|;
name|bfd_byte
modifier|*
name|buf
decl_stmt|;
name|bfd_reloc_status_type
name|rstat
decl_stmt|;
name|bfd_boolean
name|ok
decl_stmt|;
name|file_ptr
name|loc
decl_stmt|;
name|size
operator|=
name|bfd_get_reloc_size
argument_list|(
name|howto
argument_list|)
expr_stmt|;
name|buf
operator|=
name|bfd_zmalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|rstat
operator|=
name|_bfd_relocate_contents
argument_list|(
name|howto
argument_list|,
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|addend
argument_list|,\
name|buf
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rstat
condition|)
block|{
case|case
name|bfd_reloc_ok
case|:
break|break;
default|default:
case|case
name|bfd_reloc_outofrange
case|:
name|abort
argument_list|()
expr_stmt|;
case|case
name|bfd_reloc_overflow
case|:
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|finfo
operator|->
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|finfo
operator|->
name|info
argument_list|,
name|NULL
argument_list|,
operator|(
name|link_order
operator|->
name|type
operator|==
name|bfd_section_reloc_link_order
condition|?
name|bfd_section_name
argument_list|(
name|output_bfd
argument_list|,
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|u
operator|.
name|section
argument_list|)
else|:
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|u
operator|.
name|name
operator|)
argument_list|,
name|howto
operator|->
name|name
argument_list|,
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|addend
argument_list|,
operator|(
name|bfd
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|asection
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
operator|)
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
break|break;
block|}
name|loc
operator|=
name|link_order
operator|->
name|offset
operator|*
name|bfd_octets_per_byte
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
name|ok
operator|=
name|bfd_set_section_contents
argument_list|(
name|output_bfd
argument_list|,
name|output_section
argument_list|,
name|buf
argument_list|,
name|loc
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Store the reloc information in the right place.  It will get      swapped and written out at the end of the final_link routine.  */
name|irel
operator|=
operator|(
name|finfo
operator|->
name|section_info
index|[
name|output_section
operator|->
name|target_index
index|]
operator|.
name|relocs
operator|+
name|output_section
operator|->
name|reloc_count
operator|)
expr_stmt|;
name|rel_hash_ptr
operator|=
operator|(
name|finfo
operator|->
name|section_info
index|[
name|output_section
operator|->
name|target_index
index|]
operator|.
name|rel_hashes
operator|+
name|output_section
operator|->
name|reloc_count
operator|)
expr_stmt|;
name|memset
argument_list|(
name|irel
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|internal_reloc
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|rel_hash_ptr
operator|=
name|NULL
expr_stmt|;
name|irel
operator|->
name|r_vaddr
operator|=
name|output_section
operator|->
name|vma
operator|+
name|link_order
operator|->
name|offset
expr_stmt|;
if|if
condition|(
name|link_order
operator|->
name|type
operator|==
name|bfd_section_reloc_link_order
condition|)
block|{
comment|/* We need to somehow locate a symbol in the right section.  The          symbol must either have a value of zero, or we must adjust          the addend by the value of the symbol.  FIXME: Write this          when we need it.  The old linker couldn't handle this anyhow.  */
name|abort
argument_list|()
expr_stmt|;
operator|*
name|rel_hash_ptr
operator|=
name|NULL
expr_stmt|;
name|irel
operator|->
name|r_symndx
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|struct
name|coff_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
operator|(
operator|(
expr|struct
name|coff_link_hash_entry
operator|*
operator|)
name|bfd_wrapped_link_hash_lookup
argument_list|(
name|output_bfd
argument_list|,
name|finfo
operator|->
name|info
argument_list|,
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|u
operator|.
name|name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|indx
operator|>=
literal|0
condition|)
name|irel
operator|->
name|r_symndx
operator|=
name|h
operator|->
name|indx
expr_stmt|;
else|else
block|{
comment|/* Set the index to -2 to force this symbol to get 		 written out.  */
name|h
operator|->
name|indx
operator|=
operator|-
literal|2
expr_stmt|;
operator|*
name|rel_hash_ptr
operator|=
name|h
expr_stmt|;
name|irel
operator|->
name|r_symndx
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|finfo
operator|->
name|info
operator|->
name|callbacks
operator|->
name|unattached_reloc
call|)
argument_list|(
name|finfo
operator|->
name|info
argument_list|,
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|u
operator|.
name|name
argument_list|,
operator|(
name|bfd
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|asection
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
name|irel
operator|->
name|r_symndx
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* FIXME: Is this always right?  */
name|irel
operator|->
name|r_type
operator|=
name|howto
operator|->
name|type
expr_stmt|;
comment|/* r_size is only used on the RS/6000, which needs its own linker      routines anyhow.  r_extern is only used for ECOFF.  */
comment|/* FIXME: What is the right value for r_offset?  Is zero OK?  */
operator|++
name|output_section
operator|->
name|reloc_count
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* A basic reloc handling routine which may be used by processors with    simple relocs.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_coff_generic_relocate_section
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|struct
name|internal_reloc
modifier|*
name|relocs
parameter_list|,
name|struct
name|internal_syment
modifier|*
name|syms
parameter_list|,
name|asection
modifier|*
modifier|*
name|sections
parameter_list|)
block|{
name|struct
name|internal_reloc
modifier|*
name|rel
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|relend
decl_stmt|;
name|rel
operator|=
name|relocs
expr_stmt|;
name|relend
operator|=
name|rel
operator|+
name|input_section
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|long
name|symndx
decl_stmt|;
name|struct
name|coff_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|internal_syment
modifier|*
name|sym
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|bfd_reloc_status_type
name|rstat
decl_stmt|;
name|symndx
operator|=
name|rel
operator|->
name|r_symndx
expr_stmt|;
if|if
condition|(
name|symndx
operator|==
operator|-
literal|1
condition|)
block|{
name|h
operator|=
name|NULL
expr_stmt|;
name|sym
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|symndx
operator|<
literal|0
operator|||
operator|(
name|unsigned
name|long
operator|)
name|symndx
operator|>=
name|obj_raw_syment_count
argument_list|(
name|input_bfd
argument_list|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"%B: illegal symbol index %ld in relocs"
argument_list|,
name|input_bfd
argument_list|,
name|symndx
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
else|else
block|{
name|h
operator|=
name|obj_coff_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
index|[
name|symndx
index|]
expr_stmt|;
name|sym
operator|=
name|syms
operator|+
name|symndx
expr_stmt|;
block|}
comment|/* COFF treats common symbols in one of two ways.  Either the          size of the symbol is included in the section contents, or it          is not.  We assume that the size is not included, and force          the rtype_to_howto function to adjust the addend as needed.  */
if|if
condition|(
name|sym
operator|!=
name|NULL
operator|&&
name|sym
operator|->
name|n_scnum
operator|!=
literal|0
condition|)
name|addend
operator|=
operator|-
name|sym
operator|->
name|n_value
expr_stmt|;
else|else
name|addend
operator|=
literal|0
expr_stmt|;
name|howto
operator|=
name|bfd_coff_rtype_to_howto
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
argument_list|,
name|h
argument_list|,
name|sym
argument_list|,
operator|&
name|addend
argument_list|)
expr_stmt|;
if|if
condition|(
name|howto
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* If we are doing a relocatable link, then we can just ignore          a PC relative reloc that is pcrel_offset.  It will already          have the correct value.  If this is not a relocatable link,          then we should ignore the symbol value.  */
if|if
condition|(
name|howto
operator|->
name|pc_relative
operator|&&
name|howto
operator|->
name|pcrel_offset
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
continue|continue;
if|if
condition|(
name|sym
operator|!=
name|NULL
operator|&&
name|sym
operator|->
name|n_scnum
operator|!=
literal|0
condition|)
name|addend
operator|+=
name|sym
operator|->
name|n_value
expr_stmt|;
block|}
name|val
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
if|if
condition|(
name|symndx
operator|==
operator|-
literal|1
condition|)
block|{
name|sec
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|sec
operator|=
name|sections
index|[
name|symndx
index|]
expr_stmt|;
name|val
operator|=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|sym
operator|->
name|n_value
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|obj_pe
argument_list|(
name|input_bfd
argument_list|)
condition|)
name|val
operator|-=
name|sec
operator|->
name|vma
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
block|{
comment|/* Defined weak symbols are a GNU extension. */
name|asection
modifier|*
name|sec
decl_stmt|;
name|sec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|val
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|class
operator|==
name|C_NT_WEAK
operator|&&
name|h
operator|->
name|numaux
operator|==
literal|1
condition|)
block|{
comment|/* See _Microsoft Portable Executable and Common Object                      File Format Specification_, section 5.5.3. 		     Note that weak symbols without aux records are a GNU 		     extension. 		     FIXME: All weak externals are treated as having 		     characteristic IMAGE_WEAK_EXTERN_SEARCH_NOLIBRARY (1). 		     These behave as per SVR4 ABI:  A library member 		     will resolve a weak external only if a normal 		     external causes the library member to be linked. 		     See also linker.c: generic_link_check_archive_element. */
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|coff_link_hash_entry
modifier|*
name|h2
init|=
name|input_bfd
operator|->
name|tdata
operator|.
name|coff_obj_data
operator|->
name|sym_hashes
index|[
name|h
operator|->
name|aux
operator|->
name|x_sym
operator|.
name|x_tagndx
operator|.
name|l
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|h2
operator|||
name|h2
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
condition|)
block|{
name|sec
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|sec
operator|=
name|h2
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|val
operator|=
name|h2
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
expr_stmt|;
block|}
block|}
else|else
comment|/* This is a GNU extension.  */
name|val
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|info
operator|->
name|relocatable
condition|)
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
argument_list|,
name|TRUE
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
if|if
condition|(
name|info
operator|->
name|base_file
condition|)
block|{
comment|/* Emit a reloc if the backend thinks it needs it.  */
if|if
condition|(
name|sym
operator|&&
name|pe_data
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|in_reloc_p
argument_list|(
name|output_bfd
argument_list|,
name|howto
argument_list|)
condition|)
block|{
comment|/* Relocation to a symbol in a section which isn't 		 absolute.  We output the address here to a file. 		 This file is then read by dlltool when generating the 		 reloc section.  Note that the base file is not 		 portable between systems.  We write out a long here, 		 and dlltool reads in a long.  */
name|long
name|addr
init|=
operator|(
name|rel
operator|->
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|)
decl_stmt|;
if|if
condition|(
name|coff_data
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|pe
condition|)
name|addr
operator|-=
name|pe_data
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|pe_opthdr
operator|.
name|ImageBase
expr_stmt|;
if|if
condition|(
name|fwrite
argument_list|(
operator|&
name|addr
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|,
operator|(
name|FILE
operator|*
operator|)
name|info
operator|->
name|base_file
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
block|}
name|rstat
operator|=
name|_bfd_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
argument_list|,
name|val
argument_list|,
name|addend
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rstat
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|bfd_reloc_ok
case|:
break|break;
case|case
name|bfd_reloc_outofrange
case|:
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: bad reloc address 0x%lx in section `%A'"
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|rel
operator|->
name|r_vaddr
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
case|case
name|bfd_reloc_overflow
case|:
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|buf
index|[
name|SYMNMLEN
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|symndx
operator|==
operator|-
literal|1
condition|)
name|name
operator|=
literal|"*ABS*"
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|name
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|name
operator|=
name|_bfd_coff_internal_syment_name
argument_list|(
name|input_bfd
argument_list|,
name|sym
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|info
argument_list|,
operator|(
name|h
condition|?
operator|&
name|h
operator|->
name|root
else|:
name|NULL
operator|)
argument_list|,
name|name
argument_list|,
name|howto
operator|->
name|name
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

end_unit

