begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD back-end for IBM RS/6000 "XCOFF64" files.    Copyright 2000, 2001    Free Software Foundation, Inc.    Written Clinton Popetz.    Contributed by Cygnus Support.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"coff/internal.h"
end_include

begin_include
include|#
directive|include
file|"coff/xcoff.h"
end_include

begin_include
include|#
directive|include
file|"coff/rs6k64.h"
end_include

begin_include
include|#
directive|include
file|"libcoff.h"
end_include

begin_include
include|#
directive|include
file|"libxcoff.h"
end_include

begin_define
define|#
directive|define
name|GET_FILEHDR_SYMPTR
value|H_GET_64
end_define

begin_define
define|#
directive|define
name|PUT_FILEHDR_SYMPTR
value|H_PUT_64
end_define

begin_define
define|#
directive|define
name|GET_AOUTHDR_DATA_START
value|H_GET_64
end_define

begin_define
define|#
directive|define
name|PUT_AOUTHDR_DATA_START
value|H_PUT_64
end_define

begin_define
define|#
directive|define
name|GET_AOUTHDR_TEXT_START
value|H_GET_64
end_define

begin_define
define|#
directive|define
name|PUT_AOUTHDR_TEXT_START
value|H_PUT_64
end_define

begin_define
define|#
directive|define
name|GET_AOUTHDR_TSIZE
value|H_GET_64
end_define

begin_define
define|#
directive|define
name|PUT_AOUTHDR_TSIZE
value|H_PUT_64
end_define

begin_define
define|#
directive|define
name|GET_AOUTHDR_DSIZE
value|H_GET_64
end_define

begin_define
define|#
directive|define
name|PUT_AOUTHDR_DSIZE
value|H_PUT_64
end_define

begin_define
define|#
directive|define
name|GET_AOUTHDR_BSIZE
value|H_GET_64
end_define

begin_define
define|#
directive|define
name|PUT_AOUTHDR_BSIZE
value|H_PUT_64
end_define

begin_define
define|#
directive|define
name|GET_AOUTHDR_ENTRY
value|H_GET_64
end_define

begin_define
define|#
directive|define
name|PUT_AOUTHDR_ENTRY
value|H_PUT_64
end_define

begin_define
define|#
directive|define
name|GET_SCNHDR_PADDR
value|H_GET_64
end_define

begin_define
define|#
directive|define
name|PUT_SCNHDR_PADDR
value|H_PUT_64
end_define

begin_define
define|#
directive|define
name|GET_SCNHDR_VADDR
value|H_GET_64
end_define

begin_define
define|#
directive|define
name|PUT_SCNHDR_VADDR
value|H_PUT_64
end_define

begin_define
define|#
directive|define
name|GET_SCNHDR_SIZE
value|H_GET_64
end_define

begin_define
define|#
directive|define
name|PUT_SCNHDR_SIZE
value|H_PUT_64
end_define

begin_define
define|#
directive|define
name|GET_SCNHDR_SCNPTR
value|H_GET_64
end_define

begin_define
define|#
directive|define
name|PUT_SCNHDR_SCNPTR
value|H_PUT_64
end_define

begin_define
define|#
directive|define
name|GET_SCNHDR_RELPTR
value|H_GET_64
end_define

begin_define
define|#
directive|define
name|PUT_SCNHDR_RELPTR
value|H_PUT_64
end_define

begin_define
define|#
directive|define
name|GET_SCNHDR_LNNOPTR
value|H_GET_64
end_define

begin_define
define|#
directive|define
name|PUT_SCNHDR_LNNOPTR
value|H_PUT_64
end_define

begin_define
define|#
directive|define
name|GET_SCNHDR_NRELOC
value|H_GET_32
end_define

begin_define
define|#
directive|define
name|MAX_SCNHDR_NRELOC
value|0xffffffff
end_define

begin_define
define|#
directive|define
name|PUT_SCNHDR_NRELOC
value|H_PUT_32
end_define

begin_define
define|#
directive|define
name|GET_SCNHDR_NLNNO
value|H_GET_32
end_define

begin_define
define|#
directive|define
name|MAX_SCNHDR_NLNNO
value|0xffffffff
end_define

begin_define
define|#
directive|define
name|PUT_SCNHDR_NLNNO
value|H_PUT_32
end_define

begin_define
define|#
directive|define
name|GET_RELOC_VADDR
value|H_GET_64
end_define

begin_define
define|#
directive|define
name|PUT_RELOC_VADDR
value|H_PUT_64
end_define

begin_define
define|#
directive|define
name|COFF_FORCE_SYMBOLS_IN_STRINGS
end_define

begin_define
define|#
directive|define
name|COFF_DEBUG_STRING_WIDE_PREFIX
end_define

begin_define
define|#
directive|define
name|COFF_ADJUST_SCNHDR_OUT_POST
parameter_list|(
name|ABFD
parameter_list|,
name|INT
parameter_list|,
name|EXT
parameter_list|)
define|\
value|do									\     {									\       memset (((SCNHDR *) EXT)->s_pad, 0,				\ 	      sizeof (((SCNHDR *) EXT)->s_pad));			\     }									\   while (0)
end_define

begin_define
define|#
directive|define
name|NO_COFF_LINENOS
end_define

begin_define
define|#
directive|define
name|coff_SWAP_lineno_in
value|_bfd_xcoff64_swap_lineno_in
end_define

begin_define
define|#
directive|define
name|coff_SWAP_lineno_out
value|_bfd_xcoff64_swap_lineno_out
end_define

begin_decl_stmt
specifier|static
name|void
name|_bfd_xcoff64_swap_lineno_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|_bfd_xcoff64_swap_lineno_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|_bfd_xcoff64_put_ldsymbol_name
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|xcoff_loader_info
operator|*
operator|,
expr|struct
name|internal_ldsym
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|_bfd_xcoff64_swap_sym_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|_bfd_xcoff64_swap_sym_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|_bfd_xcoff64_swap_aux_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|_bfd_xcoff64_swap_aux_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_xcoff_mkobject
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_xcoff_copy_private_bfd_data
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_xcoff_is_local_label_name
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|xcoff64_rtype2howto
name|PARAMS
argument_list|(
operator|(
name|arelent
operator|*
operator|,
expr|struct
name|internal_reloc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|reloc_howto_type
modifier|*
name|xcoff64_reloc_type_lookup
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd_reloc_code_real_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_xcoff_slurp_armap
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|PTR
name|_bfd_xcoff_read_ar_hdr
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd
modifier|*
name|_bfd_xcoff_openr_next_archived_file
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|_bfd_xcoff_generic_stat_arch_elt
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|stat
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_xcoff_write_armap
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|unsigned
name|int
operator|,
expr|struct
name|orl
operator|*
operator|,
name|unsigned
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|_bfd_xcoff_write_archive_contents
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|_bfd_xcoff_sizeof_headers
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|_bfd_xcoff_swap_sym_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|int
name|_bfd_xcoff_swap_sym_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|_bfd_xcoff_swap_aux_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|int
name|_bfd_xcoff_swap_aux_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xcoff64_swap_ldhdr_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|PTR
operator|,
expr|struct
name|internal_ldhdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xcoff64_swap_ldhdr_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
expr|struct
name|internal_ldhdr
operator|*
operator|,
name|PTR
name|d
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xcoff64_swap_ldsym_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|PTR
operator|,
expr|struct
name|internal_ldsym
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xcoff64_swap_ldsym_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
expr|struct
name|internal_ldsym
operator|*
operator|,
name|PTR
name|d
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xcoff64_swap_ldrel_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|PTR
operator|,
expr|struct
name|internal_ldrel
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xcoff64_swap_ldrel_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
expr|struct
name|internal_ldrel
operator|*
operator|,
name|PTR
name|d
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|xcoff64_write_object_contents
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|xcoff64_ppc_relocate_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
expr|struct
name|internal_reloc
operator|*
operator|,
expr|struct
name|internal_syment
operator|*
operator|,
name|asection
operator|*
operator|*
name|sections
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|xcoff64_slurp_armap
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|bfd_target
modifier|*
name|xcoff64_archive_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd
modifier|*
name|xcoff64_openr_next_archived_file
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|xcoff64_sizeof_headers
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asection
modifier|*
name|xcoff64_create_csect_from_smclas
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|union
name|internal_auxent
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|xcoff64_is_lineno_count_overflow
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|xcoff64_is_reloc_count_overflow
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|xcoff64_loader_symbol_offset
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|internal_ldhdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|xcoff64_loader_reloc_offset
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|internal_ldhdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|xcoff64_generate_rtinit
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* coffcode.h needs these to be defined */
end_comment

begin_comment
comment|/* Internalcoff.h and coffcode.h modify themselves based on these flags.  */
end_comment

begin_define
define|#
directive|define
name|XCOFF64
end_define

begin_define
define|#
directive|define
name|RS6000COFF_C
value|1
end_define

begin_define
define|#
directive|define
name|SELECT_RELOC
parameter_list|(
name|internal
parameter_list|,
name|howto
parameter_list|)
define|\
value|{									\     internal.r_type = howto->type;					\     internal.r_size =							\       ((howto->complain_on_overflow == complain_overflow_signed		\ 	? 0x80								\ 	: 0)								\        | (howto->bitsize - 1));						\   }
end_define

begin_define
define|#
directive|define
name|COFF_DEFAULT_SECTION_ALIGNMENT_POWER
value|(3)
end_define

begin_define
define|#
directive|define
name|COFF_LONG_FILENAMES
end_define

begin_define
define|#
directive|define
name|NO_COFF_SYMBOLS
end_define

begin_define
define|#
directive|define
name|RTYPE2HOWTO
parameter_list|(
name|cache_ptr
parameter_list|,
name|dst
parameter_list|)
value|xcoff64_rtype2howto (cache_ptr, dst)
end_define

begin_define
define|#
directive|define
name|coff_mkobject
value|_bfd_xcoff_mkobject
end_define

begin_define
define|#
directive|define
name|coff_bfd_copy_private_bfd_data
value|_bfd_xcoff_copy_private_bfd_data
end_define

begin_define
define|#
directive|define
name|coff_bfd_is_local_label_name
value|_bfd_xcoff_is_local_label_name
end_define

begin_define
define|#
directive|define
name|coff_bfd_reloc_type_lookup
value|xcoff64_reloc_type_lookup
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|AIX_CORE
end_ifdef

begin_function_decl
specifier|extern
specifier|const
name|bfd_target
modifier|*
name|rs6000coff_core_p
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|boolean
name|rs6000coff_core_file_matches_executable_p
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|rs6000coff_core_file_failing_command
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|rs6000coff_core_file_failing_signal
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CORE_FILE_P
value|rs6000coff_core_p
end_define

begin_define
define|#
directive|define
name|coff_core_file_failing_command
define|\
value|rs6000coff_core_file_failing_command
end_define

begin_define
define|#
directive|define
name|coff_core_file_failing_signal
define|\
value|rs6000coff_core_file_failing_signal
end_define

begin_define
define|#
directive|define
name|coff_core_file_matches_executable_p
define|\
value|rs6000coff_core_file_matches_executable_p
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CORE_FILE_P
value|_bfd_dummy_target
end_define

begin_define
define|#
directive|define
name|coff_core_file_failing_command
define|\
value|_bfd_nocore_core_file_failing_command
end_define

begin_define
define|#
directive|define
name|coff_core_file_failing_signal
define|\
value|_bfd_nocore_core_file_failing_signal
end_define

begin_define
define|#
directive|define
name|coff_core_file_matches_executable_p
define|\
value|_bfd_nocore_core_file_matches_executable_p
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|coff_SWAP_sym_in
value|_bfd_xcoff64_swap_sym_in
end_define

begin_define
define|#
directive|define
name|coff_SWAP_sym_out
value|_bfd_xcoff64_swap_sym_out
end_define

begin_define
define|#
directive|define
name|coff_SWAP_aux_in
value|_bfd_xcoff64_swap_aux_in
end_define

begin_define
define|#
directive|define
name|coff_SWAP_aux_out
value|_bfd_xcoff64_swap_aux_out
end_define

begin_include
include|#
directive|include
file|"coffcode.h"
end_include

begin_comment
comment|/* For XCOFF64, the effective width of symndx changes depending on    whether we are the first entry.  Sigh.  */
end_comment

begin_function
specifier|static
name|void
name|_bfd_xcoff64_swap_lineno_in
parameter_list|(
name|abfd
parameter_list|,
name|ext1
parameter_list|,
name|in1
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|ext1
decl_stmt|;
name|PTR
name|in1
decl_stmt|;
block|{
name|LINENO
modifier|*
name|ext
init|=
operator|(
name|LINENO
operator|*
operator|)
name|ext1
decl_stmt|;
name|struct
name|internal_lineno
modifier|*
name|in
init|=
operator|(
expr|struct
name|internal_lineno
operator|*
operator|)
name|in1
decl_stmt|;
name|in
operator|->
name|l_lnno
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|ext
operator|->
name|l_lnno
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|->
name|l_lnno
operator|==
literal|0
condition|)
name|in
operator|->
name|l_addr
operator|.
name|l_symndx
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|l_addr
operator|.
name|l_symndx
argument_list|)
expr_stmt|;
else|else
name|in
operator|->
name|l_addr
operator|.
name|l_paddr
operator|=
name|H_GET_64
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|l_addr
operator|.
name|l_paddr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|_bfd_xcoff64_swap_lineno_out
parameter_list|(
name|abfd
parameter_list|,
name|inp
parameter_list|,
name|outp
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|inp
decl_stmt|;
name|PTR
name|outp
decl_stmt|;
block|{
name|struct
name|internal_lineno
modifier|*
name|in
init|=
operator|(
expr|struct
name|internal_lineno
operator|*
operator|)
name|inp
decl_stmt|;
name|struct
name|external_lineno
modifier|*
name|ext
init|=
operator|(
expr|struct
name|external_lineno
operator|*
operator|)
name|outp
decl_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|l_addr
operator|.
name|l_symndx
argument_list|,
name|ext
operator|->
name|l_addr
operator|.
name|l_symndx
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|l_lnno
argument_list|,
operator|(
name|ext
operator|->
name|l_lnno
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|->
name|l_lnno
operator|==
literal|0
condition|)
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|l_addr
operator|.
name|l_symndx
argument_list|,
name|ext
operator|->
name|l_addr
operator|.
name|l_symndx
argument_list|)
expr_stmt|;
else|else
name|H_PUT_64
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|l_addr
operator|.
name|l_paddr
argument_list|,
name|ext
operator|->
name|l_addr
operator|.
name|l_paddr
argument_list|)
expr_stmt|;
return|return
name|bfd_coff_linesz
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|_bfd_xcoff64_swap_sym_in
parameter_list|(
name|abfd
parameter_list|,
name|ext1
parameter_list|,
name|in1
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|ext1
decl_stmt|;
name|PTR
name|in1
decl_stmt|;
block|{
name|struct
name|external_syment
modifier|*
name|ext
init|=
operator|(
expr|struct
name|external_syment
operator|*
operator|)
name|ext1
decl_stmt|;
name|struct
name|internal_syment
modifier|*
name|in
init|=
operator|(
expr|struct
name|internal_syment
operator|*
operator|)
name|in1
decl_stmt|;
name|in
operator|->
name|_n
operator|.
name|_n_n
operator|.
name|_n_zeroes
operator|=
literal|0
expr_stmt|;
name|in
operator|->
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|e_offset
argument_list|)
expr_stmt|;
name|in
operator|->
name|n_value
operator|=
name|H_GET_64
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|e_value
argument_list|)
expr_stmt|;
name|in
operator|->
name|n_scnum
operator|=
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|e_scnum
argument_list|)
expr_stmt|;
name|in
operator|->
name|n_type
operator|=
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|e_type
argument_list|)
expr_stmt|;
name|in
operator|->
name|n_sclass
operator|=
name|H_GET_8
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|e_sclass
argument_list|)
expr_stmt|;
name|in
operator|->
name|n_numaux
operator|=
name|H_GET_8
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|e_numaux
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|_bfd_xcoff64_swap_sym_out
parameter_list|(
name|abfd
parameter_list|,
name|inp
parameter_list|,
name|extp
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|inp
decl_stmt|;
name|PTR
name|extp
decl_stmt|;
block|{
name|struct
name|internal_syment
modifier|*
name|in
init|=
operator|(
expr|struct
name|internal_syment
operator|*
operator|)
name|inp
decl_stmt|;
name|struct
name|external_syment
modifier|*
name|ext
init|=
operator|(
expr|struct
name|external_syment
operator|*
operator|)
name|extp
decl_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
argument_list|,
name|ext
operator|->
name|e_offset
argument_list|)
expr_stmt|;
name|H_PUT_64
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|n_value
argument_list|,
name|ext
operator|->
name|e_value
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|n_scnum
argument_list|,
name|ext
operator|->
name|e_scnum
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|n_type
argument_list|,
name|ext
operator|->
name|e_type
argument_list|)
expr_stmt|;
name|H_PUT_8
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|n_sclass
argument_list|,
name|ext
operator|->
name|e_sclass
argument_list|)
expr_stmt|;
name|H_PUT_8
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|n_numaux
argument_list|,
name|ext
operator|->
name|e_numaux
argument_list|)
expr_stmt|;
return|return
name|bfd_coff_symesz
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|_bfd_xcoff64_swap_aux_in
parameter_list|(
name|abfd
parameter_list|,
name|ext1
parameter_list|,
name|type
parameter_list|,
name|class
parameter_list|,
name|indx
parameter_list|,
name|numaux
parameter_list|,
name|in1
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|ext1
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|class
decl_stmt|;
name|int
name|indx
decl_stmt|;
name|int
name|numaux
decl_stmt|;
name|PTR
name|in1
decl_stmt|;
block|{
name|union
name|external_auxent
modifier|*
name|ext
init|=
operator|(
expr|union
name|external_auxent
operator|*
operator|)
name|ext1
decl_stmt|;
name|union
name|internal_auxent
modifier|*
name|in
init|=
operator|(
expr|union
name|internal_auxent
operator|*
operator|)
name|in1
decl_stmt|;
switch|switch
condition|(
name|class
condition|)
block|{
case|case
name|C_FILE
case|:
if|if
condition|(
name|ext
operator|->
name|x_file
operator|.
name|x_n
operator|.
name|x_zeroes
operator|==
literal|0
condition|)
block|{
name|in
operator|->
name|x_file
operator|.
name|x_n
operator|.
name|x_zeroes
operator|=
literal|0
expr_stmt|;
name|in
operator|->
name|x_file
operator|.
name|x_n
operator|.
name|x_offset
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|x_file
operator|.
name|x_n
operator|.
name|x_offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|in
operator|->
name|x_file
operator|.
name|x_fname
argument_list|,
name|ext
operator|->
name|x_file
operator|.
name|x_fname
argument_list|,
name|FILNMLEN
argument_list|)
expr_stmt|;
block|}
goto|goto
name|end
goto|;
comment|/* RS/6000 "csect" auxents */
case|case
name|C_EXT
case|:
case|case
name|C_HIDEXT
case|:
if|if
condition|(
name|indx
operator|+
literal|1
operator|==
name|numaux
condition|)
block|{
name|bfd_signed_vma
name|h
init|=
literal|0
decl_stmt|;
name|bfd_vma
name|l
init|=
literal|0
decl_stmt|;
name|h
operator|=
name|H_GET_S32
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|x_csect
operator|.
name|x_scnlen_hi
argument_list|)
expr_stmt|;
name|l
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|x_csect
operator|.
name|x_scnlen_lo
argument_list|)
expr_stmt|;
name|in
operator|->
name|x_csect
operator|.
name|x_scnlen
operator|.
name|l
operator|=
name|h
operator|<<
literal|32
operator||
operator|(
name|l
operator|&
literal|0xffffffff
operator|)
expr_stmt|;
name|in
operator|->
name|x_csect
operator|.
name|x_parmhash
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|x_csect
operator|.
name|x_parmhash
argument_list|)
expr_stmt|;
name|in
operator|->
name|x_csect
operator|.
name|x_snhash
operator|=
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|x_csect
operator|.
name|x_snhash
argument_list|)
expr_stmt|;
comment|/* We don't have to hack bitfields in x_smtyp because it's 	     defined by shifts-and-ands, which are equivalent on all 	     byte orders.  */
name|in
operator|->
name|x_csect
operator|.
name|x_smtyp
operator|=
name|H_GET_8
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|x_csect
operator|.
name|x_smtyp
argument_list|)
expr_stmt|;
name|in
operator|->
name|x_csect
operator|.
name|x_smclas
operator|=
name|H_GET_8
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|x_csect
operator|.
name|x_smclas
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
break|break;
case|case
name|C_STAT
case|:
case|case
name|C_LEAFSTAT
case|:
case|case
name|C_HIDDEN
case|:
if|if
condition|(
name|type
operator|==
name|T_NULL
condition|)
block|{
comment|/* PE defines some extra fields; we zero them out for 	     safety.  */
name|in
operator|->
name|x_scn
operator|.
name|x_checksum
operator|=
literal|0
expr_stmt|;
name|in
operator|->
name|x_scn
operator|.
name|x_associated
operator|=
literal|0
expr_stmt|;
name|in
operator|->
name|x_scn
operator|.
name|x_comdat
operator|=
literal|0
expr_stmt|;
goto|goto
name|end
goto|;
block|}
break|break;
block|}
if|if
condition|(
name|class
operator|==
name|C_BLOCK
operator|||
name|class
operator|==
name|C_FCN
operator|||
name|ISFCN
argument_list|(
name|type
argument_list|)
operator|||
name|ISTAG
argument_list|(
name|class
argument_list|)
condition|)
block|{
name|in
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_lnnoptr
operator|=
name|H_GET_64
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_lnnoptr
argument_list|)
expr_stmt|;
name|in
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_endndx
operator|.
name|l
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_endndx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ISFCN
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|in
operator|->
name|x_sym
operator|.
name|x_misc
operator|.
name|x_fsize
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_fsize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|in
operator|->
name|x_sym
operator|.
name|x_misc
operator|.
name|x_lnsz
operator|.
name|x_lnno
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_lnsz
operator|.
name|x_lnno
argument_list|)
expr_stmt|;
name|in
operator|->
name|x_sym
operator|.
name|x_misc
operator|.
name|x_lnsz
operator|.
name|x_size
operator|=
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_lnsz
operator|.
name|x_size
argument_list|)
expr_stmt|;
block|}
name|end
label|:
empty_stmt|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|_bfd_xcoff64_swap_aux_out
parameter_list|(
name|abfd
parameter_list|,
name|inp
parameter_list|,
name|type
parameter_list|,
name|class
parameter_list|,
name|indx
parameter_list|,
name|numaux
parameter_list|,
name|extp
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|inp
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|class
decl_stmt|;
name|int
name|indx
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|numaux
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|PTR
name|extp
decl_stmt|;
block|{
name|union
name|internal_auxent
modifier|*
name|in
init|=
operator|(
expr|union
name|internal_auxent
operator|*
operator|)
name|inp
decl_stmt|;
name|union
name|external_auxent
modifier|*
name|ext
init|=
operator|(
expr|union
name|external_auxent
operator|*
operator|)
name|extp
decl_stmt|;
name|memset
argument_list|(
operator|(
name|PTR
operator|)
name|ext
argument_list|,
literal|0
argument_list|,
name|bfd_coff_auxesz
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|class
condition|)
block|{
case|case
name|C_FILE
case|:
if|if
condition|(
name|ext
operator|->
name|x_file
operator|.
name|x_n
operator|.
name|x_zeroes
operator|==
literal|0
condition|)
block|{
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|,
name|ext
operator|->
name|x_file
operator|.
name|x_n
operator|.
name|x_zeroes
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_file
operator|.
name|x_n
operator|.
name|x_offset
argument_list|,
name|ext
operator|->
name|x_file
operator|.
name|x_n
operator|.
name|x_offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|ext
operator|->
name|x_file
operator|.
name|x_fname
argument_list|,
name|in
operator|->
name|x_file
operator|.
name|x_fname
argument_list|,
name|FILNMLEN
argument_list|)
expr_stmt|;
block|}
name|H_PUT_8
argument_list|(
name|abfd
argument_list|,
name|_AUX_FILE
argument_list|,
name|ext
operator|->
name|x_auxtype
operator|.
name|x_auxtype
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
comment|/* RS/6000 "csect" auxents */
case|case
name|C_EXT
case|:
case|case
name|C_HIDEXT
case|:
if|if
condition|(
name|indx
operator|+
literal|1
operator|==
name|numaux
condition|)
block|{
name|bfd_vma
name|temp
decl_stmt|;
name|temp
operator|=
name|in
operator|->
name|x_csect
operator|.
name|x_scnlen
operator|.
name|l
operator|&
literal|0xffffffff
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|temp
argument_list|,
name|ext
operator|->
name|x_csect
operator|.
name|x_scnlen_lo
argument_list|)
expr_stmt|;
name|temp
operator|=
name|in
operator|->
name|x_csect
operator|.
name|x_scnlen
operator|.
name|l
operator|>>
literal|32
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|temp
argument_list|,
name|ext
operator|->
name|x_csect
operator|.
name|x_scnlen_hi
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_csect
operator|.
name|x_parmhash
argument_list|,
name|ext
operator|->
name|x_csect
operator|.
name|x_parmhash
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_csect
operator|.
name|x_snhash
argument_list|,
name|ext
operator|->
name|x_csect
operator|.
name|x_snhash
argument_list|)
expr_stmt|;
comment|/* We don't have to hack bitfields in x_smtyp because it's 	     defined by shifts-and-ands, which are equivalent on all 	     byte orders.  */
name|H_PUT_8
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_csect
operator|.
name|x_smtyp
argument_list|,
name|ext
operator|->
name|x_csect
operator|.
name|x_smtyp
argument_list|)
expr_stmt|;
name|H_PUT_8
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_csect
operator|.
name|x_smclas
argument_list|,
name|ext
operator|->
name|x_csect
operator|.
name|x_smclas
argument_list|)
expr_stmt|;
name|H_PUT_8
argument_list|(
name|abfd
argument_list|,
name|_AUX_CSECT
argument_list|,
name|ext
operator|->
name|x_auxtype
operator|.
name|x_auxtype
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
break|break;
case|case
name|C_STAT
case|:
case|case
name|C_LEAFSTAT
case|:
case|case
name|C_HIDDEN
case|:
if|if
condition|(
name|type
operator|==
name|T_NULL
condition|)
block|{
goto|goto
name|end
goto|;
block|}
break|break;
block|}
if|if
condition|(
name|class
operator|==
name|C_BLOCK
operator|||
name|class
operator|==
name|C_FCN
operator|||
name|ISFCN
argument_list|(
name|type
argument_list|)
operator|||
name|ISTAG
argument_list|(
name|class
argument_list|)
condition|)
block|{
name|H_PUT_64
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_lnnoptr
argument_list|,
name|ext
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_lnnoptr
argument_list|)
expr_stmt|;
name|H_PUT_8
argument_list|(
name|abfd
argument_list|,
name|_AUX_FCN
argument_list|,
name|ext
operator|->
name|x_auxtype
operator|.
name|x_auxtype
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_endndx
operator|.
name|l
argument_list|,
name|ext
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_endndx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ISFCN
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_sym
operator|.
name|x_misc
operator|.
name|x_fsize
argument_list|,
name|ext
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_fsize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_sym
operator|.
name|x_misc
operator|.
name|x_lnsz
operator|.
name|x_lnno
argument_list|,
name|ext
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_lnsz
operator|.
name|x_lnno
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_sym
operator|.
name|x_misc
operator|.
name|x_lnsz
operator|.
name|x_size
argument_list|,
name|ext
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_lnsz
operator|.
name|x_size
argument_list|)
expr_stmt|;
block|}
name|end
label|:
return|return
name|bfd_coff_auxesz
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|_bfd_xcoff64_put_symbol_name
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_strtab_hash
modifier|*
name|strtab
parameter_list|,
name|struct
name|internal_syment
modifier|*
name|sym
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|boolean
name|hash
decl_stmt|;
name|bfd_size_type
name|indx
decl_stmt|;
name|hash
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|BFD_TRADITIONAL_FORMAT
operator|)
operator|!=
literal|0
condition|)
name|hash
operator|=
name|false
expr_stmt|;
name|indx
operator|=
name|_bfd_stringtab_add
argument_list|(
name|strtab
argument_list|,
name|name
argument_list|,
name|hash
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|indx
operator|==
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
condition|)
return|return
name|false
return|;
name|sym
operator|->
name|_n
operator|.
name|_n_n
operator|.
name|_n_zeroes
operator|=
literal|0
expr_stmt|;
name|sym
operator|->
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
operator|=
name|STRING_SIZE_SIZE
operator|+
name|indx
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|_bfd_xcoff64_put_ldsymbol_name
parameter_list|(
name|abfd
parameter_list|,
name|ldinfo
parameter_list|,
name|ldsym
parameter_list|,
name|name
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|xcoff_loader_info
modifier|*
name|ldinfo
decl_stmt|;
name|struct
name|internal_ldsym
modifier|*
name|ldsym
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|size_t
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ldinfo
operator|->
name|string_size
operator|+
name|len
operator|+
literal|3
operator|>
name|ldinfo
operator|->
name|string_alc
condition|)
block|{
name|bfd_size_type
name|newalc
decl_stmt|;
name|bfd_byte
modifier|*
name|newstrings
decl_stmt|;
name|newalc
operator|=
name|ldinfo
operator|->
name|string_alc
operator|*
literal|2
expr_stmt|;
if|if
condition|(
name|newalc
operator|==
literal|0
condition|)
name|newalc
operator|=
literal|32
expr_stmt|;
while|while
condition|(
name|ldinfo
operator|->
name|string_size
operator|+
name|len
operator|+
literal|3
operator|>
name|newalc
condition|)
name|newalc
operator|*=
literal|2
expr_stmt|;
name|newstrings
operator|=
operator|(
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_realloc
argument_list|(
operator|(
name|PTR
operator|)
name|ldinfo
operator|->
name|strings
argument_list|,
name|newalc
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|newstrings
operator|==
name|NULL
condition|)
block|{
name|ldinfo
operator|->
name|failed
operator|=
name|true
expr_stmt|;
return|return
name|false
return|;
block|}
name|ldinfo
operator|->
name|string_alc
operator|=
name|newalc
expr_stmt|;
name|ldinfo
operator|->
name|strings
operator|=
name|newstrings
expr_stmt|;
block|}
name|bfd_put_16
argument_list|(
name|ldinfo
operator|->
name|output_bfd
argument_list|,
call|(
name|bfd_vma
call|)
argument_list|(
name|len
operator|+
literal|1
argument_list|)
argument_list|,
name|ldinfo
operator|->
name|strings
operator|+
name|ldinfo
operator|->
name|string_size
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ldinfo
operator|->
name|strings
operator|+
name|ldinfo
operator|->
name|string_size
operator|+
literal|2
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|ldsym
operator|->
name|_l
operator|.
name|_l_l
operator|.
name|_l_zeroes
operator|=
literal|0
expr_stmt|;
name|ldsym
operator|->
name|_l
operator|.
name|_l_l
operator|.
name|_l_offset
operator|=
name|ldinfo
operator|->
name|string_size
operator|+
literal|2
expr_stmt|;
name|ldinfo
operator|->
name|string_size
operator|+=
name|len
operator|+
literal|3
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Routines to swap information in the XCOFF .loader section.  If we    ever need to write an XCOFF loader, this stuff will need to be    moved to another file shared by the linker (which XCOFF calls the    ``binder'') and the loader.  */
end_comment

begin_comment
comment|/* Swap in the ldhdr structure.  */
end_comment

begin_function
specifier|static
name|void
name|xcoff64_swap_ldhdr_in
parameter_list|(
name|abfd
parameter_list|,
name|s
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|PTR
name|s
decl_stmt|;
name|struct
name|internal_ldhdr
modifier|*
name|dst
decl_stmt|;
block|{
specifier|const
name|struct
name|external_ldhdr
modifier|*
name|src
init|=
operator|(
specifier|const
expr|struct
name|external_ldhdr
operator|*
operator|)
name|s
decl_stmt|;
name|dst
operator|->
name|l_version
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_version
argument_list|)
expr_stmt|;
name|dst
operator|->
name|l_nsyms
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_nsyms
argument_list|)
expr_stmt|;
name|dst
operator|->
name|l_nreloc
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_nreloc
argument_list|)
expr_stmt|;
name|dst
operator|->
name|l_istlen
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_istlen
argument_list|)
expr_stmt|;
name|dst
operator|->
name|l_nimpid
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_nimpid
argument_list|)
expr_stmt|;
name|dst
operator|->
name|l_stlen
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_stlen
argument_list|)
expr_stmt|;
name|dst
operator|->
name|l_impoff
operator|=
name|bfd_get_64
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_impoff
argument_list|)
expr_stmt|;
name|dst
operator|->
name|l_stoff
operator|=
name|bfd_get_64
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_stoff
argument_list|)
expr_stmt|;
name|dst
operator|->
name|l_symoff
operator|=
name|bfd_get_64
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_symoff
argument_list|)
expr_stmt|;
name|dst
operator|->
name|l_rldoff
operator|=
name|bfd_get_64
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_rldoff
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Swap out the ldhdr structure.  */
end_comment

begin_function
specifier|static
name|void
name|xcoff64_swap_ldhdr_out
parameter_list|(
name|abfd
parameter_list|,
name|src
parameter_list|,
name|d
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|struct
name|internal_ldhdr
modifier|*
name|src
decl_stmt|;
name|PTR
name|d
decl_stmt|;
block|{
name|struct
name|external_ldhdr
modifier|*
name|dst
init|=
operator|(
expr|struct
name|external_ldhdr
operator|*
operator|)
name|d
decl_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|src
operator|->
name|l_version
argument_list|,
name|dst
operator|->
name|l_version
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_nsyms
argument_list|,
name|dst
operator|->
name|l_nsyms
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_nreloc
argument_list|,
name|dst
operator|->
name|l_nreloc
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_istlen
argument_list|,
name|dst
operator|->
name|l_istlen
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_nimpid
argument_list|,
name|dst
operator|->
name|l_nimpid
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_stlen
argument_list|,
name|dst
operator|->
name|l_stlen
argument_list|)
expr_stmt|;
name|bfd_put_64
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_impoff
argument_list|,
name|dst
operator|->
name|l_impoff
argument_list|)
expr_stmt|;
name|bfd_put_64
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_stoff
argument_list|,
name|dst
operator|->
name|l_stoff
argument_list|)
expr_stmt|;
name|bfd_put_64
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_symoff
argument_list|,
name|dst
operator|->
name|l_symoff
argument_list|)
expr_stmt|;
name|bfd_put_64
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_rldoff
argument_list|,
name|dst
operator|->
name|l_rldoff
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Swap in the ldsym structure.  */
end_comment

begin_function
specifier|static
name|void
name|xcoff64_swap_ldsym_in
parameter_list|(
name|abfd
parameter_list|,
name|s
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|PTR
name|s
decl_stmt|;
name|struct
name|internal_ldsym
modifier|*
name|dst
decl_stmt|;
block|{
specifier|const
name|struct
name|external_ldsym
modifier|*
name|src
init|=
operator|(
specifier|const
expr|struct
name|external_ldsym
operator|*
operator|)
name|s
decl_stmt|;
comment|/* XCOFF64 does not use l_zeroes like XCOFF32      Set the internal l_zeroes to 0 so the common 32/64 code uses l_value      as an offset into the loader symbol table.  */
name|dst
operator|->
name|_l
operator|.
name|_l_l
operator|.
name|_l_zeroes
operator|=
literal|0
expr_stmt|;
name|dst
operator|->
name|_l
operator|.
name|_l_l
operator|.
name|_l_offset
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_offset
argument_list|)
expr_stmt|;
name|dst
operator|->
name|l_value
operator|=
name|bfd_get_64
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_value
argument_list|)
expr_stmt|;
name|dst
operator|->
name|l_scnum
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_scnum
argument_list|)
expr_stmt|;
name|dst
operator|->
name|l_smtype
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_smtype
argument_list|)
expr_stmt|;
name|dst
operator|->
name|l_smclas
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_smclas
argument_list|)
expr_stmt|;
name|dst
operator|->
name|l_ifile
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_ifile
argument_list|)
expr_stmt|;
name|dst
operator|->
name|l_parm
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_parm
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Swap out the ldsym structure.  */
end_comment

begin_function
specifier|static
name|void
name|xcoff64_swap_ldsym_out
parameter_list|(
name|abfd
parameter_list|,
name|src
parameter_list|,
name|d
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|struct
name|internal_ldsym
modifier|*
name|src
decl_stmt|;
name|PTR
name|d
decl_stmt|;
block|{
name|struct
name|external_ldsym
modifier|*
name|dst
init|=
operator|(
expr|struct
name|external_ldsym
operator|*
operator|)
name|d
decl_stmt|;
name|bfd_put_64
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_value
argument_list|,
name|dst
operator|->
name|l_value
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|src
operator|->
name|_l
operator|.
name|_l_l
operator|.
name|_l_offset
argument_list|,
name|dst
operator|->
name|l_offset
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|src
operator|->
name|l_scnum
argument_list|,
name|dst
operator|->
name|l_scnum
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_smtype
argument_list|,
name|dst
operator|->
name|l_smtype
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_smclas
argument_list|,
name|dst
operator|->
name|l_smclas
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_ifile
argument_list|,
name|dst
operator|->
name|l_ifile
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_parm
argument_list|,
name|dst
operator|->
name|l_parm
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Swap in the ldrel structure.  */
end_comment

begin_function
specifier|static
name|void
name|xcoff64_swap_ldrel_in
parameter_list|(
name|abfd
parameter_list|,
name|s
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|PTR
name|s
decl_stmt|;
name|struct
name|internal_ldrel
modifier|*
name|dst
decl_stmt|;
block|{
specifier|const
name|struct
name|external_ldrel
modifier|*
name|src
init|=
operator|(
specifier|const
expr|struct
name|external_ldrel
operator|*
operator|)
name|s
decl_stmt|;
name|dst
operator|->
name|l_vaddr
operator|=
name|bfd_get_64
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_vaddr
argument_list|)
expr_stmt|;
name|dst
operator|->
name|l_symndx
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_symndx
argument_list|)
expr_stmt|;
name|dst
operator|->
name|l_rtype
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_rtype
argument_list|)
expr_stmt|;
name|dst
operator|->
name|l_rsecnm
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_rsecnm
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Swap out the ldrel structure.  */
end_comment

begin_function
specifier|static
name|void
name|xcoff64_swap_ldrel_out
parameter_list|(
name|abfd
parameter_list|,
name|src
parameter_list|,
name|d
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|struct
name|internal_ldrel
modifier|*
name|src
decl_stmt|;
name|PTR
name|d
decl_stmt|;
block|{
name|struct
name|external_ldrel
modifier|*
name|dst
init|=
operator|(
expr|struct
name|external_ldrel
operator|*
operator|)
name|d
decl_stmt|;
name|bfd_put_64
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_vaddr
argument_list|,
name|dst
operator|->
name|l_vaddr
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|src
operator|->
name|l_rtype
argument_list|,
name|dst
operator|->
name|l_rtype
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|src
operator|->
name|l_rsecnm
argument_list|,
name|dst
operator|->
name|l_rsecnm
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_symndx
argument_list|,
name|dst
operator|->
name|l_symndx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|xcoff64_write_object_contents
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|asection
modifier|*
name|current
decl_stmt|;
name|boolean
name|hasrelocs
init|=
name|false
decl_stmt|;
name|boolean
name|haslinno
init|=
name|false
decl_stmt|;
name|file_ptr
name|scn_base
decl_stmt|;
name|file_ptr
name|reloc_base
decl_stmt|;
name|file_ptr
name|lineno_base
decl_stmt|;
name|file_ptr
name|sym_base
decl_stmt|;
name|unsigned
name|long
name|reloc_size
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|lnno_size
init|=
literal|0
decl_stmt|;
name|boolean
name|long_section_names
decl_stmt|;
name|asection
modifier|*
name|text_sec
init|=
operator|(
operator|(
name|void
operator|*
operator|)
literal|0
operator|)
decl_stmt|;
name|asection
modifier|*
name|data_sec
init|=
operator|(
operator|(
name|void
operator|*
operator|)
literal|0
operator|)
decl_stmt|;
name|asection
modifier|*
name|bss_sec
init|=
operator|(
operator|(
name|void
operator|*
operator|)
literal|0
operator|)
decl_stmt|;
name|struct
name|internal_filehdr
name|internal_f
decl_stmt|;
name|struct
name|internal_aouthdr
name|internal_a
decl_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|output_has_begun
operator|==
name|false
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_coff_compute_section_file_positions
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
block|}
comment|/* Work out the size of the reloc and linno areas */
name|reloc_base
operator|=
name|obj_relocbase
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
for|for
control|(
name|current
operator|=
name|abfd
operator|->
name|sections
init|;
name|current
operator|!=
name|NULL
condition|;
name|current
operator|=
name|current
operator|->
name|next
control|)
name|reloc_size
operator|+=
name|current
operator|->
name|reloc_count
operator|*
name|bfd_coff_relsz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|lineno_base
operator|=
name|reloc_base
operator|+
name|reloc_size
expr_stmt|;
comment|/* Make a pass through the symbol table to count line number entries and      put them into the correct asections */
name|lnno_size
operator|=
name|coff_count_linenumbers
argument_list|(
name|abfd
argument_list|)
operator|*
name|bfd_coff_linesz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|sym_base
operator|=
name|lineno_base
operator|+
name|lnno_size
expr_stmt|;
comment|/* Indicate in each section->line_filepos its actual file address */
for|for
control|(
name|current
operator|=
name|abfd
operator|->
name|sections
init|;
name|current
operator|!=
name|NULL
condition|;
name|current
operator|=
name|current
operator|->
name|next
control|)
block|{
if|if
condition|(
name|current
operator|->
name|lineno_count
condition|)
block|{
name|current
operator|->
name|line_filepos
operator|=
name|lineno_base
expr_stmt|;
name|current
operator|->
name|moving_line_filepos
operator|=
name|lineno_base
expr_stmt|;
name|lineno_base
operator|+=
name|current
operator|->
name|lineno_count
operator|*
name|bfd_coff_linesz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|current
operator|->
name|line_filepos
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|current
operator|->
name|reloc_count
condition|)
block|{
name|current
operator|->
name|rel_filepos
operator|=
name|reloc_base
expr_stmt|;
name|reloc_base
operator|+=
name|current
operator|->
name|reloc_count
operator|*
name|bfd_coff_relsz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|current
operator|->
name|rel_filepos
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|EXEC_P
operator|)
operator|!=
literal|0
condition|)
block|{
name|scn_base
operator|=
name|bfd_coff_filhsz
argument_list|(
name|abfd
argument_list|)
operator|+
name|bfd_coff_aoutsz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|internal_f
operator|.
name|f_opthdr
operator|=
name|bfd_coff_aoutsz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|scn_base
operator|=
name|bfd_coff_filhsz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|internal_f
operator|.
name|f_opthdr
operator|=
literal|0
expr_stmt|;
block|}
name|internal_f
operator|.
name|f_nscns
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|scn_base
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
name|long_section_names
operator|=
name|false
expr_stmt|;
for|for
control|(
name|current
operator|=
name|abfd
operator|->
name|sections
init|;
name|current
operator|!=
name|NULL
condition|;
name|current
operator|=
name|current
operator|->
name|next
control|)
block|{
name|struct
name|internal_scnhdr
name|section
decl_stmt|;
name|struct
name|external_scnhdr
name|buff
decl_stmt|;
name|bfd_size_type
name|amount
decl_stmt|;
name|internal_f
operator|.
name|f_nscns
operator|++
expr_stmt|;
name|strncpy
argument_list|(
name|section
operator|.
name|s_name
argument_list|,
name|current
operator|->
name|name
argument_list|,
name|SCNNMLEN
argument_list|)
expr_stmt|;
name|section
operator|.
name|s_vaddr
operator|=
name|current
operator|->
name|vma
expr_stmt|;
name|section
operator|.
name|s_paddr
operator|=
name|current
operator|->
name|lma
expr_stmt|;
name|section
operator|.
name|s_size
operator|=
name|current
operator|->
name|_raw_size
expr_stmt|;
comment|/* If this section has no size or is unloadable then the scnptr 	 will be 0 too.  */
if|if
condition|(
name|current
operator|->
name|_raw_size
operator|==
literal|0
operator|||
operator|(
name|current
operator|->
name|flags
operator|&
operator|(
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|section
operator|.
name|s_scnptr
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|section
operator|.
name|s_scnptr
operator|=
name|current
operator|->
name|filepos
expr_stmt|;
block|}
name|section
operator|.
name|s_relptr
operator|=
name|current
operator|->
name|rel_filepos
expr_stmt|;
name|section
operator|.
name|s_lnnoptr
operator|=
name|current
operator|->
name|line_filepos
expr_stmt|;
name|section
operator|.
name|s_nreloc
operator|=
name|current
operator|->
name|reloc_count
expr_stmt|;
name|section
operator|.
name|s_nlnno
operator|=
name|current
operator|->
name|lineno_count
expr_stmt|;
if|if
condition|(
name|current
operator|->
name|reloc_count
operator|!=
literal|0
condition|)
name|hasrelocs
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|current
operator|->
name|lineno_count
operator|!=
literal|0
condition|)
name|haslinno
operator|=
name|true
expr_stmt|;
name|section
operator|.
name|s_flags
operator|=
name|sec_to_styp_flags
argument_list|(
name|current
operator|->
name|name
argument_list|,
name|current
operator|->
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|current
operator|->
name|name
argument_list|,
name|_TEXT
argument_list|)
condition|)
block|{
name|text_sec
operator|=
name|current
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|current
operator|->
name|name
argument_list|,
name|_DATA
argument_list|)
condition|)
block|{
name|data_sec
operator|=
name|current
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|current
operator|->
name|name
argument_list|,
name|_BSS
argument_list|)
condition|)
block|{
name|bss_sec
operator|=
name|current
expr_stmt|;
block|}
name|amount
operator|=
name|bfd_coff_scnhsz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_coff_swap_scnhdr_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|section
argument_list|,
operator|&
name|buff
argument_list|)
operator|==
literal|0
operator|||
name|bfd_bwrite
argument_list|(
call|(
name|PTR
call|)
argument_list|(
operator|&
name|buff
argument_list|)
argument_list|,
name|amount
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amount
condition|)
return|return
name|false
return|;
block|}
name|internal_f
operator|.
name|f_timdat
operator|=
literal|0
expr_stmt|;
name|internal_f
operator|.
name|f_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|hasrelocs
condition|)
name|internal_f
operator|.
name|f_flags
operator||=
name|F_RELFLG
expr_stmt|;
if|if
condition|(
operator|!
name|haslinno
condition|)
name|internal_f
operator|.
name|f_flags
operator||=
name|F_LNNO
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|flags
operator|&
name|EXEC_P
condition|)
name|internal_f
operator|.
name|f_flags
operator||=
name|F_EXEC
expr_stmt|;
comment|/* FIXME: this is wrong for PPC_PE! */
if|if
condition|(
name|bfd_little_endian
argument_list|(
name|abfd
argument_list|)
condition|)
name|internal_f
operator|.
name|f_flags
operator||=
name|F_AR32WR
expr_stmt|;
else|else
name|internal_f
operator|.
name|f_flags
operator||=
name|F_AR32W
expr_stmt|;
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
condition|)
name|internal_f
operator|.
name|f_flags
operator||=
name|F_SHROBJ
expr_stmt|;
if|if
condition|(
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|_LOADER
argument_list|)
operator|!=
name|NULL
condition|)
name|internal_f
operator|.
name|f_flags
operator||=
name|F_DYNLOAD
expr_stmt|;
name|memset
argument_list|(
operator|&
name|internal_a
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|internal_a
argument_list|)
expr_stmt|;
comment|/* This can only be called from the xcoff64 backend so the magic #      must be for xcoff64.  */
name|internal_f
operator|.
name|f_magic
operator|=
literal|0757
expr_stmt|;
name|internal_a
operator|.
name|magic
operator|=
operator|(
name|abfd
operator|->
name|flags
operator|&
name|D_PAGED
operator|)
condition|?
name|RS6K_AOUTHDR_ZMAGIC
else|:
operator|(
name|abfd
operator|->
name|flags
operator|&
name|WP_TEXT
operator|)
condition|?
name|RS6K_AOUTHDR_NMAGIC
else|:
name|RS6K_AOUTHDR_OMAGIC
expr_stmt|;
comment|/* FIXME: Does anybody ever set this to another value?  */
name|internal_a
operator|.
name|vstamp
operator|=
literal|0
expr_stmt|;
comment|/* Now should write relocs, strings, syms */
name|obj_sym_filepos
argument_list|(
name|abfd
argument_list|)
operator|=
name|sym_base
expr_stmt|;
name|internal_f
operator|.
name|f_symptr
operator|=
literal|0
expr_stmt|;
name|internal_f
operator|.
name|f_nsyms
operator|=
literal|0
expr_stmt|;
comment|/* If bfd_get_symcount (abfd) != 0, then we are not using the COFF      backend linker, and obj_raw_syment_count is not valid until after      coff_write_symbols is called.  */
if|if
condition|(
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|int
name|firstundef
decl_stmt|;
if|if
condition|(
operator|!
name|coff_renumber_symbols
argument_list|(
name|abfd
argument_list|,
operator|&
name|firstundef
argument_list|)
condition|)
return|return
name|false
return|;
name|coff_mangle_symbols
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|coff_write_symbols
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|coff_write_linenumbers
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|coff_write_relocs
argument_list|(
name|abfd
argument_list|,
name|firstundef
argument_list|)
condition|)
return|return
name|false
return|;
name|internal_f
operator|.
name|f_symptr
operator|=
name|sym_base
expr_stmt|;
name|internal_f
operator|.
name|f_nsyms
operator|=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|obj_raw_syment_count
argument_list|(
name|abfd
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|internal_f
operator|.
name|f_symptr
operator|=
name|sym_base
expr_stmt|;
comment|/* AIX appears to require that F_RELFLG not be set if there are 	 local symbols but no relocations.  */
name|internal_f
operator|.
name|f_flags
operator|&=
operator|~
name|F_RELFLG
expr_stmt|;
block|}
else|else
block|{
name|internal_f
operator|.
name|f_flags
operator||=
name|F_LSYMS
expr_stmt|;
block|}
if|if
condition|(
name|text_sec
condition|)
block|{
name|internal_a
operator|.
name|tsize
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|text_sec
argument_list|)
expr_stmt|;
name|internal_a
operator|.
name|text_start
operator|=
name|internal_a
operator|.
name|tsize
condition|?
name|text_sec
operator|->
name|vma
else|:
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|data_sec
condition|)
block|{
name|internal_a
operator|.
name|dsize
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|data_sec
argument_list|)
expr_stmt|;
name|internal_a
operator|.
name|data_start
operator|=
name|internal_a
operator|.
name|dsize
condition|?
name|data_sec
operator|->
name|vma
else|:
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|bss_sec
condition|)
block|{
name|internal_a
operator|.
name|bsize
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|bss_sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_a
operator|.
name|bsize
operator|&&
name|bss_sec
operator|->
name|vma
operator|<
name|internal_a
operator|.
name|data_start
condition|)
name|internal_a
operator|.
name|data_start
operator|=
name|bss_sec
operator|->
name|vma
expr_stmt|;
block|}
name|internal_a
operator|.
name|entry
operator|=
name|bfd_get_start_address
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|internal_f
operator|.
name|f_nsyms
operator|=
name|obj_raw_syment_count
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|xcoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|full_aouthdr
condition|)
block|{
name|bfd_vma
name|toc
decl_stmt|;
name|asection
modifier|*
name|loader_sec
decl_stmt|;
name|internal_a
operator|.
name|vstamp
operator|=
literal|1
expr_stmt|;
name|internal_a
operator|.
name|o_snentry
operator|=
name|xcoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|snentry
expr_stmt|;
if|if
condition|(
name|internal_a
operator|.
name|o_snentry
operator|==
literal|0
condition|)
name|internal_a
operator|.
name|entry
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|text_sec
operator|!=
name|NULL
condition|)
block|{
name|internal_a
operator|.
name|o_sntext
operator|=
name|text_sec
operator|->
name|target_index
expr_stmt|;
name|internal_a
operator|.
name|o_algntext
operator|=
name|bfd_get_section_alignment
argument_list|(
name|abfd
argument_list|,
name|text_sec
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|internal_a
operator|.
name|o_sntext
operator|=
literal|0
expr_stmt|;
name|internal_a
operator|.
name|o_algntext
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|data_sec
operator|!=
name|NULL
condition|)
block|{
name|internal_a
operator|.
name|o_sndata
operator|=
name|data_sec
operator|->
name|target_index
expr_stmt|;
name|internal_a
operator|.
name|o_algndata
operator|=
name|bfd_get_section_alignment
argument_list|(
name|abfd
argument_list|,
name|data_sec
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|internal_a
operator|.
name|o_sndata
operator|=
literal|0
expr_stmt|;
name|internal_a
operator|.
name|o_algndata
operator|=
literal|0
expr_stmt|;
block|}
name|loader_sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".loader"
argument_list|)
expr_stmt|;
if|if
condition|(
name|loader_sec
operator|!=
name|NULL
condition|)
name|internal_a
operator|.
name|o_snloader
operator|=
name|loader_sec
operator|->
name|target_index
expr_stmt|;
else|else
name|internal_a
operator|.
name|o_snloader
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bss_sec
operator|!=
name|NULL
condition|)
name|internal_a
operator|.
name|o_snbss
operator|=
name|bss_sec
operator|->
name|target_index
expr_stmt|;
else|else
name|internal_a
operator|.
name|o_snbss
operator|=
literal|0
expr_stmt|;
name|toc
operator|=
name|xcoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|toc
expr_stmt|;
name|internal_a
operator|.
name|o_toc
operator|=
name|toc
expr_stmt|;
name|internal_a
operator|.
name|o_sntoc
operator|=
name|xcoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|sntoc
expr_stmt|;
name|internal_a
operator|.
name|o_modtype
operator|=
name|xcoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|modtype
expr_stmt|;
if|if
condition|(
name|xcoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|cputype
operator|!=
operator|-
literal|1
condition|)
name|internal_a
operator|.
name|o_cputype
operator|=
name|xcoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|cputype
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|bfd_get_arch
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
case|case
name|bfd_arch_rs6000
case|:
name|internal_a
operator|.
name|o_cputype
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|bfd_arch_powerpc
case|:
if|if
condition|(
name|bfd_get_mach
argument_list|(
name|abfd
argument_list|)
operator|==
literal|0
condition|)
name|internal_a
operator|.
name|o_cputype
operator|=
literal|3
expr_stmt|;
else|else
name|internal_a
operator|.
name|o_cputype
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
name|internal_a
operator|.
name|o_maxstack
operator|=
name|xcoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|maxstack
expr_stmt|;
name|internal_a
operator|.
name|o_maxdata
operator|=
name|xcoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|maxdata
expr_stmt|;
block|}
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
block|{
name|char
modifier|*
name|buff
decl_stmt|;
name|bfd_size_type
name|amount
init|=
name|bfd_coff_filhsz
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|buff
operator|=
name|bfd_malloc
argument_list|(
name|amount
argument_list|)
expr_stmt|;
if|if
condition|(
name|buff
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|bfd_coff_swap_filehdr_out
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|internal_f
argument_list|,
operator|(
name|PTR
operator|)
name|buff
argument_list|)
expr_stmt|;
name|amount
operator|=
name|bfd_bwrite
argument_list|(
operator|(
name|PTR
operator|)
name|buff
argument_list|,
name|amount
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buff
argument_list|)
expr_stmt|;
if|if
condition|(
name|amount
operator|!=
name|bfd_coff_filhsz
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|abfd
operator|->
name|flags
operator|&
name|EXEC_P
condition|)
block|{
name|char
modifier|*
name|buff
decl_stmt|;
name|bfd_size_type
name|amount
init|=
name|bfd_coff_aoutsz
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|buff
operator|=
name|bfd_malloc
argument_list|(
name|amount
argument_list|)
expr_stmt|;
if|if
condition|(
name|buff
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|bfd_coff_swap_aouthdr_out
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|internal_a
argument_list|,
operator|(
name|PTR
operator|)
name|buff
argument_list|)
expr_stmt|;
name|amount
operator|=
name|bfd_bwrite
argument_list|(
operator|(
name|PTR
operator|)
name|buff
argument_list|,
name|amount
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buff
argument_list|)
expr_stmt|;
if|if
condition|(
name|amount
operator|!=
name|bfd_coff_aoutsz
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* This is the relocation function for the RS/6000/POWER/PowerPC.    This is currently the only processor which uses XCOFF; I hope that    will never change.  */
end_comment

begin_function
specifier|static
name|boolean
name|xcoff64_ppc_relocate_section
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|contents
parameter_list|,
name|relocs
parameter_list|,
name|syms
parameter_list|,
name|sections
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|relocs
decl_stmt|;
name|struct
name|internal_syment
modifier|*
name|syms
decl_stmt|;
name|asection
modifier|*
modifier|*
name|sections
decl_stmt|;
block|{
name|struct
name|internal_reloc
modifier|*
name|rel
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|relend
decl_stmt|;
name|rel
operator|=
name|relocs
expr_stmt|;
name|relend
operator|=
name|rel
operator|+
name|input_section
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|long
name|symndx
decl_stmt|;
name|struct
name|xcoff_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|internal_syment
modifier|*
name|sym
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
name|struct
name|reloc_howto_struct
name|howto
decl_stmt|;
name|bfd_reloc_status_type
name|rstat
decl_stmt|;
comment|/* Relocation type R_REF is a special relocation type which is          merely used to prevent garbage collection from occurring for          the csect including the symbol which it references.  */
if|if
condition|(
name|rel
operator|->
name|r_type
operator|==
name|R_REF
condition|)
continue|continue;
name|symndx
operator|=
name|rel
operator|->
name|r_symndx
expr_stmt|;
if|if
condition|(
name|symndx
operator|==
operator|-
literal|1
condition|)
block|{
name|h
operator|=
name|NULL
expr_stmt|;
name|sym
operator|=
name|NULL
expr_stmt|;
name|addend
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|h
operator|=
name|obj_xcoff_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
index|[
name|symndx
index|]
expr_stmt|;
name|sym
operator|=
name|syms
operator|+
name|symndx
expr_stmt|;
name|addend
operator|=
operator|-
name|sym
operator|->
name|n_value
expr_stmt|;
block|}
comment|/* We build the howto information on the fly.  */
name|howto
operator|.
name|type
operator|=
name|rel
operator|->
name|r_type
expr_stmt|;
name|howto
operator|.
name|rightshift
operator|=
literal|0
expr_stmt|;
name|howto
operator|.
name|size
operator|=
literal|4
expr_stmt|;
name|howto
operator|.
name|bitsize
operator|=
operator|(
name|rel
operator|->
name|r_size
operator|&
literal|0x3f
operator|)
operator|+
literal|1
expr_stmt|;
name|howto
operator|.
name|pc_relative
operator|=
name|false
expr_stmt|;
name|howto
operator|.
name|bitpos
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|rel
operator|->
name|r_size
operator|&
literal|0x80
operator|)
operator|!=
literal|0
condition|)
name|howto
operator|.
name|complain_on_overflow
operator|=
name|complain_overflow_signed
expr_stmt|;
else|else
name|howto
operator|.
name|complain_on_overflow
operator|=
name|complain_overflow_bitfield
expr_stmt|;
name|howto
operator|.
name|special_function
operator|=
name|NULL
expr_stmt|;
name|howto
operator|.
name|name
operator|=
literal|"internal"
expr_stmt|;
name|howto
operator|.
name|partial_inplace
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|howto
operator|.
name|bitsize
operator|==
literal|64
condition|)
block|{
name|howto
operator|.
name|src_mask
operator|=
name|howto
operator|.
name|dst_mask
operator|=
name|MINUS_ONE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|howto
operator|.
name|bitsize
operator|==
literal|32
condition|)
block|{
name|howto
operator|.
name|src_mask
operator|=
name|howto
operator|.
name|dst_mask
operator|=
literal|0xffffffff
expr_stmt|;
block|}
else|else
block|{
name|howto
operator|.
name|src_mask
operator|=
name|howto
operator|.
name|dst_mask
operator|=
operator|(
literal|1
operator|<<
name|howto
operator|.
name|bitsize
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|howto
operator|.
name|bitsize
operator|==
literal|16
condition|)
name|howto
operator|.
name|size
operator|=
literal|1
expr_stmt|;
block|}
name|howto
operator|.
name|pcrel_offset
operator|=
name|false
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
if|if
condition|(
name|symndx
operator|==
operator|-
literal|1
condition|)
block|{
name|sec
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|sec
operator|=
name|sections
index|[
name|symndx
index|]
expr_stmt|;
comment|/* Hack to make sure we use the right TOC anchor value 		 if this reloc is against the TOC anchor.  */
if|if
condition|(
name|sec
operator|->
name|name
index|[
literal|3
index|]
operator|==
literal|'0'
operator|&&
name|strcmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
literal|".tc0"
argument_list|)
operator|==
literal|0
condition|)
name|val
operator|=
name|xcoff_data
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|toc
expr_stmt|;
else|else
name|val
operator|=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|sym
operator|->
name|n_value
operator|-
name|sec
operator|->
name|vma
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|sec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|val
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_common
condition|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|sec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
expr_stmt|;
name|val
operator|=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|h
operator|->
name|flags
operator|&
name|XCOFF_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|||
operator|(
name|h
operator|->
name|flags
operator|&
name|XCOFF_IMPORT
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Every symbol in a shared object is defined somewhere.  */
name|val
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|info
operator|->
name|relocateable
condition|)
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
argument_list|,
name|true
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
comment|/* Don't try to process the reloc.  It can't help, and 		 it may generate another error.  */
continue|continue;
block|}
block|}
comment|/* I took the relocation type definitions from two documents: 	 the PowerPC AIX Version 4 Application Binary Interface, First 	 Edition (April 1992), and the PowerOpen ABI, Big-Endian 	 32-Bit Hardware Implementation (June 30, 1994).  Differences 	 between the documents are noted below.  */
switch|switch
condition|(
name|rel
operator|->
name|r_type
condition|)
block|{
case|case
name|R_RTB
case|:
case|case
name|R_RRTBI
case|:
case|case
name|R_RRTBA
case|:
comment|/* These relocs are defined by the PowerPC ABI to be 	     relative branches which use half of the difference 	     between the symbol and the program counter.  I can't 	     quite figure out when this is useful.  These relocs are 	     not defined by the PowerOpen ABI.  */
default|default:
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: unsupported relocation type 0x%02x"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|rel
operator|->
name|r_type
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
name|R_POS
case|:
comment|/* Simple positive relocation.  */
break|break;
case|case
name|R_NEG
case|:
comment|/* Simple negative relocation.  */
name|val
operator|=
operator|-
name|val
expr_stmt|;
break|break;
case|case
name|R_REL
case|:
comment|/* Simple PC relative relocation.  */
name|howto
operator|.
name|pc_relative
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|R_TOC
case|:
comment|/* TOC relative relocation.  The value in the instruction in 	     the input file is the offset from the input file TOC to 	     the desired location.  We want the offset from the final 	     TOC to the desired location.  We have: 	     isym = iTOC + in 	     iinsn = in + o 	     osym = oTOC + on 	     oinsn = on + o 	     so we must change insn by on - in. 	  */
case|case
name|R_GL
case|:
comment|/* Global linkage relocation.  The value of this relocation 	     is the address of the entry in the TOC section.  */
case|case
name|R_TCL
case|:
comment|/* Local object TOC address.  I can't figure out the 	     difference between this and case R_GL.  */
case|case
name|R_TRL
case|:
comment|/* TOC relative relocation.  A TOC relative load instruction 	     which may be changed to a load address instruction. 	     FIXME: We don't currently implement this optimization.  */
case|case
name|R_TRLA
case|:
comment|/* TOC relative relocation.  This is a TOC relative load 	     address instruction which may be changed to a load 	     instruction.  FIXME: I don't know if this is the correct 	     implementation.  */
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|smclas
operator|!=
name|XMC_TD
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|toc_section
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: TOC reloc at 0x%x to symbol `%s' with no TOC entry"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|rel
operator|->
name|r_vaddr
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|BFD_ASSERT
argument_list|(
operator|(
name|h
operator|->
name|flags
operator|&
name|XCOFF_SET_TOC
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|h
operator|->
name|toc_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|toc_section
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
name|val
operator|=
operator|(
operator|(
name|val
operator|-
name|xcoff_data
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|toc
operator|)
operator|-
operator|(
name|sym
operator|->
name|n_value
operator|-
name|xcoff_data
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|toc
operator|)
operator|)
expr_stmt|;
name|addend
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|R_BA
case|:
comment|/* Absolute branch.  We don't want to mess with the lower 	     two bits of the instruction.  */
case|case
name|R_CAI
case|:
comment|/* The PowerPC ABI defines this as an absolute call which 	     may be modified to become a relative call.  The PowerOpen 	     ABI does not define this relocation type.  */
case|case
name|R_RBA
case|:
comment|/* Absolute branch which may be modified to become a 	     relative branch.  */
case|case
name|R_RBAC
case|:
comment|/* The PowerPC ABI defines this as an absolute branch to a 	     fixed address which may be modified to an absolute branch 	     to a symbol.  The PowerOpen ABI does not define this 	     relocation type.  */
case|case
name|R_RBRC
case|:
comment|/* The PowerPC ABI defines this as an absolute branch to a 	     fixed address which may be modified to a relative branch. 	     The PowerOpen ABI does not define this relocation type.  */
name|howto
operator|.
name|src_mask
operator|&=
operator|~
literal|3
expr_stmt|;
name|howto
operator|.
name|dst_mask
operator|=
name|howto
operator|.
name|src_mask
expr_stmt|;
break|break;
case|case
name|R_BR
case|:
comment|/* Relative branch.  We don't want to mess with the lower 	     two bits of the instruction.  */
case|case
name|R_CREL
case|:
comment|/* The PowerPC ABI defines this as a relative call which may 	     be modified to become an absolute call.  The PowerOpen 	     ABI does not define this relocation type.  */
case|case
name|R_RBR
case|:
comment|/* A relative branch which may be modified to become an 	     absolute branch.  FIXME: We don't implement this, 	     although we should for symbols of storage mapping class 	     XMC_XO.  */
name|howto
operator|.
name|pc_relative
operator|=
name|true
expr_stmt|;
name|howto
operator|.
name|src_mask
operator|&=
operator|~
literal|3
expr_stmt|;
name|howto
operator|.
name|dst_mask
operator|=
name|howto
operator|.
name|src_mask
expr_stmt|;
name|howto
operator|.
name|size
operator|=
literal|2
expr_stmt|;
name|howto
operator|.
name|complain_on_overflow
operator|=
name|complain_overflow_bitfield
expr_stmt|;
break|break;
case|case
name|R_RL
case|:
comment|/* The PowerPC AIX ABI describes this as a load which may be 	     changed to a load address.  The PowerOpen ABI says this 	     is the same as case R_POS.  */
break|break;
case|case
name|R_RLA
case|:
comment|/* The PowerPC AIX ABI describes this as a load address 	     which may be changed to a load.  The PowerOpen ABI says 	     this is the same as R_POS.  */
break|break;
block|}
comment|/* If we see an R_BR or R_RBR reloc which is jumping to global          linkage code, and it is followed by an appropriate cror nop          instruction, we replace the cror with ld r2,40(r1).  This          restores the TOC after the glink code.  Contrariwise, if the          call is followed by a ld r2,40(r1), but the call is not          going to global linkage code, we can replace the load with a          cror.  */
if|if
condition|(
operator|(
name|rel
operator|->
name|r_type
operator|==
name|R_BR
operator|||
name|rel
operator|->
name|r_type
operator|==
name|R_RBR
operator|)
operator|&&
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|&&
operator|(
name|rel
operator|->
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
operator|+
literal|8
operator|<=
name|input_section
operator|->
name|_cooked_size
operator|)
condition|)
block|{
name|bfd_byte
modifier|*
name|pnext
decl_stmt|;
name|unsigned
name|long
name|next
decl_stmt|;
name|pnext
operator|=
name|contents
operator|+
operator|(
name|rel
operator|->
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
operator|)
operator|+
literal|4
expr_stmt|;
name|next
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|pnext
argument_list|)
expr_stmt|;
comment|/* The _ptrgl function is magic.  It is used by the AIX 	   * compiler to call a function through a pointer. 	   * 	   * special case XMC_GL, global linkage 	   */
if|if
condition|(
name|h
operator|->
name|smclas
operator|==
name|XMC_GL
operator|||
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"._ptrgl"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|next
operator|==
literal|0x4def7b82
comment|/* cror 15,15,15 */
operator|||
name|next
operator|==
literal|0x4ffffb82
comment|/* cror 31,31,31 */
operator|||
name|next
operator|==
literal|0x60000000
comment|/* ori r0,r0,0 */
condition|)
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0xe8410028
comment|/* ld r2,40(r1) */
argument_list|,
name|pnext
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|next
operator|==
literal|0xe8410028
comment|/* ld r2,40(r1) */
condition|)
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0x60000000
comment|/* ori r0,r0,0 */
argument_list|,
name|pnext
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* A PC relative reloc includes the section address.  */
if|if
condition|(
name|howto
operator|.
name|pc_relative
condition|)
name|addend
operator|+=
name|input_section
operator|->
name|vma
expr_stmt|;
name|rstat
operator|=
name|_bfd_final_link_relocate
argument_list|(
operator|&
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
argument_list|,
name|val
argument_list|,
name|addend
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rstat
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|bfd_reloc_ok
case|:
break|break;
case|case
name|bfd_reloc_overflow
case|:
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|buf
index|[
name|SYMNMLEN
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|howto_name
index|[
literal|10
index|]
decl_stmt|;
if|if
condition|(
name|symndx
operator|==
operator|-
literal|1
condition|)
name|name
operator|=
literal|"*ABS*"
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
else|else
block|{
name|name
operator|=
name|_bfd_coff_internal_syment_name
argument_list|(
name|input_bfd
argument_list|,
name|sym
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|false
return|;
block|}
name|sprintf
argument_list|(
name|howto_name
argument_list|,
literal|"0x%02x"
argument_list|,
name|rel
operator|->
name|r_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|info
argument_list|,
name|name
argument_list|,
name|howto_name
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
block|}
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The XCOFF reloc table.  Actually, XCOFF relocations specify the    bitsize and whether they are signed or not, along with a    conventional type.  This table is for the types, which are used for    different algorithms for putting in the reloc.  Many of these    relocs need special_function entries, which I have not written.  */
end_comment

begin_decl_stmt
name|reloc_howto_type
name|xcoff64_howto_table
index|[]
init|=
block|{
comment|/* Standard 64 bit relocation.  */
name|HOWTO
argument_list|(
literal|0
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_POS"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
name|MINUS_ONE
argument_list|,
comment|/* src_mask */
name|MINUS_ONE
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 64 bit relocation, but store negative value.  */
name|HOWTO
argument_list|(
literal|1
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
operator|-
literal|4
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_NEG"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
name|MINUS_ONE
argument_list|,
comment|/* src_mask */
name|MINUS_ONE
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 32 bit PC relative relocation.  */
name|HOWTO
argument_list|(
literal|2
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_REL"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16 bit TOC relative relocation.  */
name|HOWTO
argument_list|(
literal|3
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_TOC"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* I don't really know what this is.	*/
name|HOWTO
argument_list|(
literal|4
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_RTB"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* External TOC relative symbol.  */
name|HOWTO
argument_list|(
literal|5
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_GL"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Local TOC relative symbol.	 */
name|HOWTO
argument_list|(
literal|6
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_TCL"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
name|EMPTY_HOWTO
argument_list|(
literal|7
argument_list|)
block|,
comment|/* Non modifiable absolute branch.  */
name|HOWTO
argument_list|(
literal|8
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|26
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_BA"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0x3fffffc
argument_list|,
comment|/* src_mask */
literal|0x3fffffc
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
name|EMPTY_HOWTO
argument_list|(
literal|9
argument_list|)
block|,
comment|/* Non modifiable relative branch.  */
name|HOWTO
argument_list|(
literal|0xa
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|26
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_BR"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0x3fffffc
argument_list|,
comment|/* src_mask */
literal|0x3fffffc
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
name|EMPTY_HOWTO
argument_list|(
literal|0xb
argument_list|)
block|,
comment|/* Indirect load.  */
name|HOWTO
argument_list|(
literal|0xc
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_RL"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Load address.  */
name|HOWTO
argument_list|(
literal|0xd
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_RLA"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
name|EMPTY_HOWTO
argument_list|(
literal|0xe
argument_list|)
block|,
comment|/* Non-relocating reference.	*/
name|HOWTO
argument_list|(
literal|0xf
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_REF"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
name|EMPTY_HOWTO
argument_list|(
literal|0x10
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|0x11
argument_list|)
block|,
comment|/* TOC relative indirect load.  */
name|HOWTO
argument_list|(
literal|0x12
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_TRL"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* TOC relative load address.	 */
name|HOWTO
argument_list|(
literal|0x13
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_TRLA"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Modifiable relative branch.  */
name|HOWTO
argument_list|(
literal|0x14
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_RRTBI"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Modifiable absolute branch.  */
name|HOWTO
argument_list|(
literal|0x15
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_RRTBA"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Modifiable call absolute indirect.	 */
name|HOWTO
argument_list|(
literal|0x16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_CAI"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Modifiable call relative.	*/
name|HOWTO
argument_list|(
literal|0x17
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_CREL"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Modifiable branch absolute.  */
name|HOWTO
argument_list|(
literal|0x18
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|26
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_RBA"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Modifiable branch absolute.  */
name|HOWTO
argument_list|(
literal|0x19
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_RBAC"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Modifiable branch relative.  */
name|HOWTO
argument_list|(
literal|0x1a
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|26
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_RBR"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Modifiable branch absolute.  */
name|HOWTO
argument_list|(
literal|0x1b
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_RBRC"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
literal|0
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
argument|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
argument|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_POS"
argument_list|,
comment|/* name */
argument|true
argument_list|,
comment|/* partial_inplace */
argument|MINUS_ONE
argument_list|,
comment|/* src_mask */
argument|MINUS_ONE
argument_list|,
comment|/* dst_mask */
argument|false
argument_list|)
comment|/* pcrel_offset */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|xcoff64_rtype2howto
parameter_list|(
name|relent
parameter_list|,
name|internal
parameter_list|)
name|arelent
modifier|*
name|relent
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|internal
decl_stmt|;
block|{
name|relent
operator|->
name|howto
operator|=
name|xcoff64_howto_table
operator|+
name|internal
operator|->
name|r_type
expr_stmt|;
comment|/* Check for relocs we don't know of.  */
if|if
condition|(
name|internal
operator|->
name|r_type
operator|>=
sizeof|sizeof
argument_list|(
name|xcoff64_howto_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|xcoff64_howto_table
index|[
literal|0
index|]
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|internal
operator|->
name|r_type
operator|!=
name|relent
operator|->
name|howto
operator|->
name|type
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* The r_size field of an XCOFF reloc encodes the bitsize of the      relocation, as well as indicating whether it is signed or not.      Doublecheck that the relocation information gathered from the      type matches this information.  The bitsize is not significant      for R_REF relocs.  */
if|if
condition|(
name|relent
operator|->
name|howto
operator|->
name|dst_mask
operator|!=
literal|0
operator|&&
operator|(
name|relent
operator|->
name|howto
operator|->
name|bitsize
operator|!=
operator|(
operator|(
name|unsigned
name|int
operator|)
name|internal
operator|->
name|r_size
operator|&
literal|0x3f
operator|)
operator|+
literal|1
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|#
directive|if
literal|0
block|if ((internal->r_size& 0x80) != 0       ? (relent->howto->complain_on_overflow != complain_overflow_signed)       : (relent->howto->complain_on_overflow != complain_overflow_bitfield))     abort ();
endif|#
directive|endif
block|}
end_function

begin_function
name|reloc_howto_type
modifier|*
name|xcoff64_reloc_type_lookup
parameter_list|(
name|abfd
parameter_list|,
name|code
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|BFD_RELOC_PPC_B26
case|:
return|return
operator|&
name|xcoff64_howto_table
index|[
literal|0xa
index|]
return|;
case|case
name|BFD_RELOC_PPC_BA26
case|:
return|return
operator|&
name|xcoff64_howto_table
index|[
literal|8
index|]
return|;
case|case
name|BFD_RELOC_PPC_TOC16
case|:
return|return
operator|&
name|xcoff64_howto_table
index|[
literal|3
index|]
return|;
case|case
name|BFD_RELOC_32
case|:
case|case
name|BFD_RELOC_CTOR
case|:
return|return
operator|&
name|xcoff64_howto_table
index|[
literal|0
index|]
return|;
case|case
name|BFD_RELOC_64
case|:
return|return
operator|&
name|xcoff64_howto_table
index|[
literal|0x1c
index|]
return|;
default|default:
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_comment
comment|/* Read in the armap of an XCOFF archive.  */
end_comment

begin_function
specifier|static
name|boolean
name|xcoff64_slurp_armap
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|file_ptr
name|off
decl_stmt|;
name|size_t
name|namlen
decl_stmt|;
name|bfd_size_type
name|sz
decl_stmt|,
name|amt
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|,
modifier|*
name|cend
decl_stmt|;
name|bfd_vma
name|c
decl_stmt|,
name|i
decl_stmt|;
name|carsym
modifier|*
name|arsym
decl_stmt|;
name|bfd_byte
modifier|*
name|p
decl_stmt|;
name|file_ptr
name|pos
decl_stmt|;
comment|/* This is for the new format.  */
name|struct
name|xcoff_ar_hdr_big
name|hdr
decl_stmt|;
if|if
condition|(
name|xcoff_ardata
argument_list|(
name|abfd
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|bfd_has_map
argument_list|(
name|abfd
argument_list|)
operator|=
name|false
expr_stmt|;
return|return
name|true
return|;
block|}
name|off
operator|=
name|strtol
argument_list|(
name|xcoff_ardata_big
argument_list|(
name|abfd
argument_list|)
operator|->
name|symoff64
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|off
operator|==
literal|0
condition|)
block|{
name|bfd_has_map
argument_list|(
name|abfd
argument_list|)
operator|=
name|false
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|off
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
comment|/* The symbol table starts with a normal archive header.  */
if|if
condition|(
name|bfd_bread
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|hdr
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|SIZEOF_AR_HDR_BIG
argument_list|,
name|abfd
argument_list|)
operator|!=
name|SIZEOF_AR_HDR_BIG
condition|)
return|return
name|false
return|;
comment|/* Skip the name (normally empty).  */
name|namlen
operator|=
name|strtol
argument_list|(
name|hdr
operator|.
name|namlen
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|pos
operator|=
operator|(
operator|(
name|namlen
operator|+
literal|1
operator|)
operator|&
operator|~
operator|(
name|size_t
operator|)
literal|1
operator|)
operator|+
name|SXCOFFARFMAG
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|pos
argument_list|,
name|SEEK_CUR
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
comment|/* XXX This actually has to be a call to strtoll (at least on 32-bit      machines) since the field width is 20 and there numbers with more      than 32 bits can be represented.  */
name|sz
operator|=
name|strtol
argument_list|(
name|hdr
operator|.
name|size
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* Read in the entire symbol table.  */
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bfd_bread
argument_list|(
operator|(
name|PTR
operator|)
name|contents
argument_list|,
name|sz
argument_list|,
name|abfd
argument_list|)
operator|!=
name|sz
condition|)
return|return
name|false
return|;
comment|/* The symbol table starts with an eight byte count.  */
name|c
operator|=
name|H_GET_64
argument_list|(
name|abfd
argument_list|,
name|contents
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|*
literal|8
operator|>=
name|sz
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|amt
operator|=
name|c
expr_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
name|carsym
argument_list|)
expr_stmt|;
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symdefs
operator|=
operator|(
name|carsym
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symdefs
operator|==
name|NULL
condition|)
return|return
name|false
return|;
comment|/* After the count comes a list of eight byte file offsets.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|arsym
operator|=
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symdefs
operator|,
name|p
operator|=
name|contents
operator|+
literal|8
init|;
name|i
operator|<
name|c
condition|;
operator|++
name|i
operator|,
operator|++
name|arsym
operator|,
name|p
operator|+=
literal|8
control|)
name|arsym
operator|->
name|file_offset
operator|=
name|H_GET_64
argument_list|(
name|abfd
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* After the file offsets come null terminated symbol names.  */
name|cend
operator|=
name|contents
operator|+
name|sz
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|arsym
operator|=
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symdefs
init|;
name|i
operator|<
name|c
condition|;
operator|++
name|i
operator|,
operator|++
name|arsym
operator|,
name|p
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
operator|+
literal|1
control|)
block|{
if|if
condition|(
name|p
operator|>=
name|cend
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|arsym
operator|->
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|p
expr_stmt|;
block|}
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symdef_count
operator|=
name|c
expr_stmt|;
name|bfd_has_map
argument_list|(
name|abfd
argument_list|)
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* See if this is an NEW XCOFF archive.  */
end_comment

begin_function
specifier|static
specifier|const
name|bfd_target
modifier|*
name|xcoff64_archive_p
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|char
name|magic
index|[
name|SXCOFFARMAG
index|]
decl_stmt|;
comment|/* This is the new format.  */
name|struct
name|xcoff_ar_file_hdr_big
name|hdr
decl_stmt|;
name|bfd_size_type
name|amt
init|=
name|SXCOFFARMAG
decl_stmt|;
if|if
condition|(
name|bfd_bread
argument_list|(
operator|(
name|PTR
operator|)
name|magic
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_system_call
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|magic
argument_list|,
name|XCOFFARMAGBIG
argument_list|,
name|SXCOFFARMAG
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* We are setting bfd_ardata(abfd) here, but since bfd_ardata      involves a cast, we can't do it as the left operand of      assignment.  */
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|artdata
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|aout_ar_data
operator|=
operator|(
expr|struct
name|artdata
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|==
operator|(
expr|struct
name|artdata
operator|*
operator|)
name|NULL
condition|)
return|return
name|NULL
return|;
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|cache
operator|=
name|NULL
expr_stmt|;
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|archive_head
operator|=
name|NULL
expr_stmt|;
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symdefs
operator|=
name|NULL
expr_stmt|;
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|extended_names
operator|=
name|NULL
expr_stmt|;
comment|/* Copy over the magic string.  */
name|memcpy
argument_list|(
name|hdr
operator|.
name|magic
argument_list|,
name|magic
argument_list|,
name|SXCOFFARMAG
argument_list|)
expr_stmt|;
comment|/* Now read the rest of the file header.  */
if|if
condition|(
name|bfd_bread
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|hdr
operator|.
name|memoff
argument_list|,
call|(
name|bfd_size_type
call|)
argument_list|(
name|SIZEOF_AR_FILE_HDR_BIG
operator|-
name|SXCOFFARMAG
argument_list|)
argument_list|,
name|abfd
argument_list|)
operator|!=
name|SIZEOF_AR_FILE_HDR_BIG
operator|-
name|SXCOFFARMAG
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_system_call
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* XXX This actually has to be a call to strtoll (at least on 32-bit      machines) since the field width is 20 and there numbers with more      than 32 bits can be represented.  */
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|first_file_filepos
operator|=
name|strtol
argument_list|(
name|hdr
operator|.
name|firstmemoff
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|amt
operator|=
name|SIZEOF_AR_FILE_HDR_BIG
expr_stmt|;
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|tdata
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|tdata
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|memcpy
argument_list|(
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|tdata
argument_list|,
operator|&
name|hdr
argument_list|,
name|SIZEOF_AR_FILE_HDR_BIG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xcoff64_slurp_armap
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|aout_ar_data
operator|=
operator|(
expr|struct
name|artdata
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|abfd
operator|->
name|xvec
return|;
block|}
end_function

begin_comment
comment|/* Open the next element in an XCOFF archive.  */
end_comment

begin_function
specifier|static
name|bfd
modifier|*
name|xcoff64_openr_next_archived_file
parameter_list|(
name|archive
parameter_list|,
name|last_file
parameter_list|)
name|bfd
modifier|*
name|archive
decl_stmt|;
name|bfd
modifier|*
name|last_file
decl_stmt|;
block|{
name|file_ptr
name|filestart
decl_stmt|;
if|if
condition|(
operator|(
name|xcoff_ardata
argument_list|(
name|archive
argument_list|)
operator|==
name|NULL
operator|)
operator|||
operator|!
name|xcoff_big_format_p
argument_list|(
name|archive
argument_list|)
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|last_file
operator|==
name|NULL
condition|)
block|{
name|filestart
operator|=
name|bfd_ardata
argument_list|(
name|archive
argument_list|)
operator|->
name|first_file_filepos
expr_stmt|;
block|}
else|else
block|{
comment|/* XXX These actually have to be a calls to strtoll (at least 	 on 32-bit machines) since the fields's width is 20 and 	 there numbers with more than 32 bits can be represented.  */
name|filestart
operator|=
name|strtol
argument_list|(
name|arch_xhdr_big
argument_list|(
name|last_file
argument_list|)
operator|->
name|nextoff
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
comment|/* XXX These actually have to be calls to strtoll (at least on 32-bit      machines) since the fields's width is 20 and there numbers with more      than 32 bits can be represented.  */
if|if
condition|(
name|filestart
operator|==
literal|0
operator|||
name|filestart
operator|==
name|strtol
argument_list|(
name|xcoff_ardata_big
argument_list|(
name|archive
argument_list|)
operator|->
name|memoff
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
operator|||
name|filestart
operator|==
name|strtol
argument_list|(
name|xcoff_ardata_big
argument_list|(
name|archive
argument_list|)
operator|->
name|symoff
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_more_archived_files
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|_bfd_get_elt_at_filepos
argument_list|(
name|archive
argument_list|,
name|filestart
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* We can't use the usual coff_sizeof_headers routine, because AIX    always uses an a.out header.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|xcoff64_sizeof_headers
parameter_list|(
name|abfd
parameter_list|,
name|reloc
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|boolean
name|reloc
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|size
decl_stmt|;
name|size
operator|=
name|bfd_coff_filhsz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* Don't think the small aout header can be used since some of the      old elements have been reordered past the end of the old coff      small aout size.  */
if|if
condition|(
name|xcoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|full_aouthdr
condition|)
name|size
operator|+=
name|bfd_coff_aoutsz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|size
operator|+=
name|abfd
operator|->
name|section_count
operator|*
name|bfd_coff_scnhsz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
return|return
name|size
return|;
block|}
end_function

begin_function
specifier|static
name|asection
modifier|*
name|xcoff64_create_csect_from_smclas
parameter_list|(
name|abfd
parameter_list|,
name|aux
parameter_list|,
name|symbol_name
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|union
name|internal_auxent
modifier|*
name|aux
decl_stmt|;
specifier|const
name|char
modifier|*
name|symbol_name
decl_stmt|;
block|{
name|asection
modifier|*
name|return_value
init|=
name|NULL
decl_stmt|;
comment|/* Changes from 32 :      .sv == 8, is only for 32 bit programs      .ti == 12 and .tb == 13 are now reserved.  */
specifier|static
specifier|const
name|char
modifier|*
name|names
index|[
literal|19
index|]
init|=
block|{
literal|".pr"
block|,
literal|".ro"
block|,
literal|".db"
block|,
literal|".tc"
block|,
literal|".ua"
block|,
literal|".rw"
block|,
literal|".gl"
block|,
literal|".xo"
block|,
name|NULL
block|,
literal|".bs"
block|,
literal|".ds"
block|,
literal|".uc"
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|".tc0"
block|,
literal|".td"
block|,
literal|".sv64"
block|,
literal|".sv3264"
block|}
decl_stmt|;
if|if
condition|(
operator|(
literal|19
operator|>=
name|aux
operator|->
name|x_csect
operator|.
name|x_smclas
operator|)
operator|&&
operator|(
name|NULL
operator|!=
name|names
index|[
name|aux
operator|->
name|x_csect
operator|.
name|x_smclas
index|]
operator|)
condition|)
block|{
name|return_value
operator|=
name|bfd_make_section_anyway
argument_list|(
name|abfd
argument_list|,
name|names
index|[
name|aux
operator|->
name|x_csect
operator|.
name|x_smclas
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: symbol `%s' has unrecognized smclas %d"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|symbol_name
argument_list|,
name|aux
operator|->
name|x_csect
operator|.
name|x_smclas
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
block|}
return|return
name|return_value
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|xcoff64_is_lineno_count_overflow
parameter_list|(
name|abfd
parameter_list|,
name|value
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd_vma
name|value
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|xcoff64_is_reloc_count_overflow
parameter_list|(
name|abfd
parameter_list|,
name|value
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd_vma
name|value
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_vma
name|xcoff64_loader_symbol_offset
parameter_list|(
name|abfd
parameter_list|,
name|ldhdr
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|internal_ldhdr
modifier|*
name|ldhdr
decl_stmt|;
block|{
return|return
operator|(
name|ldhdr
operator|->
name|l_symoff
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_vma
name|xcoff64_loader_reloc_offset
parameter_list|(
name|abfd
parameter_list|,
name|ldhdr
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|internal_ldhdr
modifier|*
name|ldhdr
decl_stmt|;
block|{
return|return
operator|(
name|ldhdr
operator|->
name|l_rldoff
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|xcoff64_generate_rtinit
parameter_list|(
name|abfd
parameter_list|,
name|init
parameter_list|,
name|fini
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|char
modifier|*
name|init
decl_stmt|;
specifier|const
name|char
modifier|*
name|fini
decl_stmt|;
block|{
name|bfd_byte
name|filehdr_ext
index|[
name|FILHSZ
index|]
decl_stmt|;
name|bfd_byte
name|scnhdr_ext
index|[
name|SCNHSZ
index|]
decl_stmt|;
name|bfd_byte
name|syment_ext
index|[
name|SYMESZ
operator|*
literal|8
index|]
decl_stmt|;
name|bfd_byte
name|reloc_ext
index|[
name|RELSZ
operator|*
literal|2
index|]
decl_stmt|;
name|bfd_byte
modifier|*
name|data_buffer
decl_stmt|;
name|bfd_size_type
name|data_buffer_size
decl_stmt|;
name|bfd_byte
modifier|*
name|string_table
decl_stmt|,
modifier|*
name|st_tmp
decl_stmt|;
name|bfd_size_type
name|string_table_size
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
name|size_t
name|initsz
decl_stmt|,
name|finisz
decl_stmt|;
name|struct
name|internal_filehdr
name|filehdr
decl_stmt|;
name|struct
name|internal_scnhdr
name|scnhdr
decl_stmt|;
name|struct
name|internal_syment
name|syment
decl_stmt|;
name|union
name|internal_auxent
name|auxent
decl_stmt|;
name|struct
name|internal_reloc
name|reloc
decl_stmt|;
name|char
modifier|*
name|data_name
init|=
literal|".data"
decl_stmt|;
name|char
modifier|*
name|rtinit_name
init|=
literal|"__rtinit"
decl_stmt|;
if|if
condition|(
operator|!
name|bfd_xcoff_rtinit_size
argument_list|(
name|abfd
argument_list|)
operator|||
operator|(
name|init
operator|==
name|NULL
operator|&&
name|fini
operator|==
name|NULL
operator|)
condition|)
return|return
name|false
return|;
name|initsz
operator|=
operator|(
name|init
operator|==
name|NULL
condition|?
literal|0
else|:
literal|1
operator|+
name|strlen
argument_list|(
name|init
argument_list|)
operator|)
expr_stmt|;
name|finisz
operator|=
operator|(
name|fini
operator|==
name|NULL
condition|?
literal|0
else|:
literal|1
operator|+
name|strlen
argument_list|(
name|fini
argument_list|)
operator|)
expr_stmt|;
comment|/* file header */
name|memset
argument_list|(
name|filehdr_ext
argument_list|,
literal|0
argument_list|,
name|FILHSZ
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|filehdr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|internal_filehdr
argument_list|)
argument_list|)
expr_stmt|;
name|filehdr
operator|.
name|f_magic
operator|=
name|bfd_xcoff_magic_number
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|filehdr
operator|.
name|f_nscns
operator|=
literal|1
expr_stmt|;
name|filehdr
operator|.
name|f_timdat
operator|=
literal|0
expr_stmt|;
name|filehdr
operator|.
name|f_nsyms
operator|=
literal|0
expr_stmt|;
comment|/* at least 6, no more than 8 */
name|filehdr
operator|.
name|f_symptr
operator|=
literal|0
expr_stmt|;
comment|/* set below */
name|filehdr
operator|.
name|f_opthdr
operator|=
literal|0
expr_stmt|;
name|filehdr
operator|.
name|f_flags
operator|=
literal|0
expr_stmt|;
comment|/* section header */
name|memset
argument_list|(
name|scnhdr_ext
argument_list|,
literal|0
argument_list|,
name|SCNHSZ
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|scnhdr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|internal_scnhdr
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|scnhdr
operator|.
name|s_name
argument_list|,
name|data_name
argument_list|,
name|strlen
argument_list|(
name|data_name
argument_list|)
argument_list|)
expr_stmt|;
name|scnhdr
operator|.
name|s_paddr
operator|=
literal|0
expr_stmt|;
name|scnhdr
operator|.
name|s_vaddr
operator|=
literal|0
expr_stmt|;
name|scnhdr
operator|.
name|s_size
operator|=
literal|0
expr_stmt|;
comment|/* set below */
name|scnhdr
operator|.
name|s_scnptr
operator|=
name|FILHSZ
operator|+
name|SCNHSZ
expr_stmt|;
name|scnhdr
operator|.
name|s_relptr
operator|=
literal|0
expr_stmt|;
comment|/* set below */
name|scnhdr
operator|.
name|s_lnnoptr
operator|=
literal|0
expr_stmt|;
name|scnhdr
operator|.
name|s_nreloc
operator|=
literal|0
expr_stmt|;
comment|/* either 1 or 2 */
name|scnhdr
operator|.
name|s_nlnno
operator|=
literal|0
expr_stmt|;
name|scnhdr
operator|.
name|s_flags
operator|=
name|STYP_DATA
expr_stmt|;
comment|/* .data       0x0000           0x00000000 : rtl      0x0004           0x00000000 :      0x0008           0x00000018 : offset to init, or 0      0x000C           0x00000038 : offset to fini, or 0      0x0010           0x00000010 : size of descriptor       0x0014           0x00000000 : pad      0x0018           0x00000000 : init, needs a reloc      0x001C           0x00000000 :      0x0020           0x00000058 : offset to init name      0x0024           0x00000000 : flags, padded to a word      0x0028           0x00000000 : empty init      0x002C           0x00000000 :      0x0030           0x00000000 :       0x0034           0x00000000 :       0x0038           0x00000000 : fini, needs a reloc      0x003C           0x00000000 :      0x0040           0x00000??? : offset to fini name      0x0044           0x00000000 : flags, padded to a word      0x0048           0x00000000 : empty fini      0x004C           0x00000000 :      0x0050           0x00000000 :       0x0054           0x00000000 :       0x0058           init name      0x0058 + initsz  fini name */
name|data_buffer_size
operator|=
literal|0x0058
operator|+
name|initsz
operator|+
name|finisz
expr_stmt|;
name|data_buffer_size
operator|+=
operator|(
name|data_buffer_size
operator|&
literal|7
operator|)
condition|?
literal|8
operator|-
operator|(
name|data_buffer_size
operator|&
literal|7
operator|)
else|:
literal|0
expr_stmt|;
name|data_buffer
operator|=
name|NULL
expr_stmt|;
name|data_buffer
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|data_buffer_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|data_buffer
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|memset
argument_list|(
name|data_buffer
argument_list|,
literal|0
argument_list|,
name|data_buffer_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|initsz
condition|)
block|{
name|val
operator|=
literal|0x18
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|val
argument_list|,
operator|&
name|data_buffer
index|[
literal|0x08
index|]
argument_list|)
expr_stmt|;
name|val
operator|=
literal|0x58
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|val
argument_list|,
operator|&
name|data_buffer
index|[
literal|0x20
index|]
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|data_buffer
index|[
name|val
index|]
argument_list|,
name|init
argument_list|,
name|initsz
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|finisz
condition|)
block|{
name|val
operator|=
literal|0x38
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|val
argument_list|,
operator|&
name|data_buffer
index|[
literal|0x0C
index|]
argument_list|)
expr_stmt|;
name|val
operator|=
literal|0x58
operator|+
name|initsz
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|val
argument_list|,
operator|&
name|data_buffer
index|[
literal|0x40
index|]
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|data_buffer
index|[
name|val
index|]
argument_list|,
name|fini
argument_list|,
name|finisz
argument_list|)
expr_stmt|;
block|}
name|val
operator|=
literal|0x10
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|val
argument_list|,
operator|&
name|data_buffer
index|[
literal|0x10
index|]
argument_list|)
expr_stmt|;
name|scnhdr
operator|.
name|s_size
operator|=
name|data_buffer_size
expr_stmt|;
comment|/* string table */
name|string_table_size
operator|=
literal|4
expr_stmt|;
name|string_table_size
operator|+=
name|strlen
argument_list|(
name|data_name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|string_table_size
operator|+=
name|strlen
argument_list|(
name|rtinit_name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|string_table_size
operator|+=
name|initsz
expr_stmt|;
name|string_table_size
operator|+=
name|finisz
expr_stmt|;
name|string_table
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|string_table_size
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|string_table
argument_list|,
literal|0
argument_list|,
name|string_table_size
argument_list|)
expr_stmt|;
name|val
operator|=
name|string_table_size
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|val
argument_list|,
operator|&
name|string_table
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|st_tmp
operator|=
name|string_table
operator|+
literal|4
expr_stmt|;
comment|/* symbols       0. .data csect      2. __rtinit      4. init function       6. fini function */
name|memset
argument_list|(
name|syment_ext
argument_list|,
literal|0
argument_list|,
literal|8
operator|*
name|SYMESZ
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|reloc_ext
argument_list|,
literal|0
argument_list|,
literal|2
operator|*
name|RELSZ
argument_list|)
expr_stmt|;
comment|/* .data csect */
name|memset
argument_list|(
operator|&
name|syment
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|internal_syment
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|auxent
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|internal_auxent
argument_list|)
argument_list|)
expr_stmt|;
name|syment
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
operator|=
name|st_tmp
operator|-
name|string_table
expr_stmt|;
name|memcpy
argument_list|(
name|st_tmp
argument_list|,
name|data_name
argument_list|,
name|strlen
argument_list|(
name|data_name
argument_list|)
argument_list|)
expr_stmt|;
name|st_tmp
operator|+=
name|strlen
argument_list|(
name|data_name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|syment
operator|.
name|n_scnum
operator|=
literal|1
expr_stmt|;
name|syment
operator|.
name|n_sclass
operator|=
name|C_HIDEXT
expr_stmt|;
name|syment
operator|.
name|n_numaux
operator|=
literal|1
expr_stmt|;
name|auxent
operator|.
name|x_csect
operator|.
name|x_scnlen
operator|.
name|l
operator|=
name|data_buffer_size
expr_stmt|;
name|auxent
operator|.
name|x_csect
operator|.
name|x_smtyp
operator|=
literal|3
operator|<<
literal|3
operator||
name|XTY_SD
expr_stmt|;
name|auxent
operator|.
name|x_csect
operator|.
name|x_smclas
operator|=
name|XMC_RW
expr_stmt|;
name|bfd_coff_swap_sym_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|syment
argument_list|,
operator|&
name|syment_ext
index|[
name|filehdr
operator|.
name|f_nsyms
operator|*
name|SYMESZ
index|]
argument_list|)
expr_stmt|;
name|bfd_coff_swap_aux_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|auxent
argument_list|,
name|syment
operator|.
name|n_type
argument_list|,
name|syment
operator|.
name|n_sclass
argument_list|,
literal|0
argument_list|,
name|syment
operator|.
name|n_numaux
argument_list|,
operator|&
name|syment_ext
index|[
operator|(
name|filehdr
operator|.
name|f_nsyms
operator|+
literal|1
operator|)
operator|*
name|SYMESZ
index|]
argument_list|)
expr_stmt|;
name|filehdr
operator|.
name|f_nsyms
operator|+=
literal|2
expr_stmt|;
comment|/* __rtinit */
name|memset
argument_list|(
operator|&
name|syment
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|internal_syment
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|auxent
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|internal_auxent
argument_list|)
argument_list|)
expr_stmt|;
name|syment
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
operator|=
name|st_tmp
operator|-
name|string_table
expr_stmt|;
name|memcpy
argument_list|(
name|st_tmp
argument_list|,
name|rtinit_name
argument_list|,
name|strlen
argument_list|(
name|rtinit_name
argument_list|)
argument_list|)
expr_stmt|;
name|st_tmp
operator|+=
name|strlen
argument_list|(
name|rtinit_name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|syment
operator|.
name|n_scnum
operator|=
literal|1
expr_stmt|;
name|syment
operator|.
name|n_sclass
operator|=
name|C_EXT
expr_stmt|;
name|syment
operator|.
name|n_numaux
operator|=
literal|1
expr_stmt|;
name|auxent
operator|.
name|x_csect
operator|.
name|x_smtyp
operator|=
name|XTY_LD
expr_stmt|;
name|auxent
operator|.
name|x_csect
operator|.
name|x_smclas
operator|=
name|XMC_RW
expr_stmt|;
name|bfd_coff_swap_sym_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|syment
argument_list|,
operator|&
name|syment_ext
index|[
name|filehdr
operator|.
name|f_nsyms
operator|*
name|SYMESZ
index|]
argument_list|)
expr_stmt|;
name|bfd_coff_swap_aux_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|auxent
argument_list|,
name|syment
operator|.
name|n_type
argument_list|,
name|syment
operator|.
name|n_sclass
argument_list|,
literal|0
argument_list|,
name|syment
operator|.
name|n_numaux
argument_list|,
operator|&
name|syment_ext
index|[
operator|(
name|filehdr
operator|.
name|f_nsyms
operator|+
literal|1
operator|)
operator|*
name|SYMESZ
index|]
argument_list|)
expr_stmt|;
name|filehdr
operator|.
name|f_nsyms
operator|+=
literal|2
expr_stmt|;
comment|/* init */
if|if
condition|(
name|initsz
condition|)
block|{
name|memset
argument_list|(
operator|&
name|syment
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|internal_syment
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|auxent
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|internal_auxent
argument_list|)
argument_list|)
expr_stmt|;
name|syment
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
operator|=
name|st_tmp
operator|-
name|string_table
expr_stmt|;
name|memcpy
argument_list|(
name|st_tmp
argument_list|,
name|init
argument_list|,
name|initsz
argument_list|)
expr_stmt|;
name|st_tmp
operator|+=
name|initsz
expr_stmt|;
name|syment
operator|.
name|n_sclass
operator|=
name|C_EXT
expr_stmt|;
name|syment
operator|.
name|n_numaux
operator|=
literal|1
expr_stmt|;
name|bfd_coff_swap_sym_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|syment
argument_list|,
operator|&
name|syment_ext
index|[
name|filehdr
operator|.
name|f_nsyms
operator|*
name|SYMESZ
index|]
argument_list|)
expr_stmt|;
name|bfd_coff_swap_aux_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|auxent
argument_list|,
name|syment
operator|.
name|n_type
argument_list|,
name|syment
operator|.
name|n_sclass
argument_list|,
literal|0
argument_list|,
name|syment
operator|.
name|n_numaux
argument_list|,
operator|&
name|syment_ext
index|[
operator|(
name|filehdr
operator|.
name|f_nsyms
operator|+
literal|1
operator|)
operator|*
name|SYMESZ
index|]
argument_list|)
expr_stmt|;
comment|/* reloc */
name|memset
argument_list|(
operator|&
name|reloc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|internal_reloc
argument_list|)
argument_list|)
expr_stmt|;
name|reloc
operator|.
name|r_vaddr
operator|=
literal|0x0018
expr_stmt|;
name|reloc
operator|.
name|r_symndx
operator|=
name|filehdr
operator|.
name|f_nsyms
expr_stmt|;
name|reloc
operator|.
name|r_type
operator|=
name|R_POS
expr_stmt|;
name|reloc
operator|.
name|r_size
operator|=
literal|63
expr_stmt|;
name|bfd_coff_swap_reloc_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|reloc
argument_list|,
operator|&
name|reloc_ext
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|filehdr
operator|.
name|f_nsyms
operator|+=
literal|2
expr_stmt|;
name|scnhdr
operator|.
name|s_nreloc
operator|+=
literal|1
expr_stmt|;
block|}
comment|/* finit */
if|if
condition|(
name|finisz
condition|)
block|{
name|memset
argument_list|(
operator|&
name|syment
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|internal_syment
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|auxent
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|internal_auxent
argument_list|)
argument_list|)
expr_stmt|;
name|syment
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
operator|=
name|st_tmp
operator|-
name|string_table
expr_stmt|;
name|memcpy
argument_list|(
name|st_tmp
argument_list|,
name|fini
argument_list|,
name|finisz
argument_list|)
expr_stmt|;
name|st_tmp
operator|+=
name|finisz
expr_stmt|;
name|syment
operator|.
name|n_sclass
operator|=
name|C_EXT
expr_stmt|;
name|syment
operator|.
name|n_numaux
operator|=
literal|1
expr_stmt|;
name|bfd_coff_swap_sym_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|syment
argument_list|,
operator|&
name|syment_ext
index|[
name|filehdr
operator|.
name|f_nsyms
operator|*
name|SYMESZ
index|]
argument_list|)
expr_stmt|;
name|bfd_coff_swap_aux_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|auxent
argument_list|,
name|syment
operator|.
name|n_type
argument_list|,
name|syment
operator|.
name|n_sclass
argument_list|,
literal|0
argument_list|,
name|syment
operator|.
name|n_numaux
argument_list|,
operator|&
name|syment_ext
index|[
operator|(
name|filehdr
operator|.
name|f_nsyms
operator|+
literal|1
operator|)
operator|*
name|SYMESZ
index|]
argument_list|)
expr_stmt|;
comment|/* reloc */
name|memset
argument_list|(
operator|&
name|reloc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|internal_reloc
argument_list|)
argument_list|)
expr_stmt|;
name|reloc
operator|.
name|r_vaddr
operator|=
literal|0x0038
expr_stmt|;
name|reloc
operator|.
name|r_symndx
operator|=
name|filehdr
operator|.
name|f_nsyms
expr_stmt|;
name|reloc
operator|.
name|r_type
operator|=
name|R_POS
expr_stmt|;
name|reloc
operator|.
name|r_size
operator|=
literal|63
expr_stmt|;
name|bfd_coff_swap_reloc_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|reloc
argument_list|,
operator|&
name|reloc_ext
index|[
name|scnhdr
operator|.
name|s_nreloc
operator|*
name|RELSZ
index|]
argument_list|)
expr_stmt|;
name|filehdr
operator|.
name|f_nsyms
operator|+=
literal|2
expr_stmt|;
name|scnhdr
operator|.
name|s_nreloc
operator|+=
literal|1
expr_stmt|;
block|}
name|scnhdr
operator|.
name|s_relptr
operator|=
name|scnhdr
operator|.
name|s_scnptr
operator|+
name|data_buffer_size
expr_stmt|;
name|filehdr
operator|.
name|f_symptr
operator|=
name|scnhdr
operator|.
name|s_relptr
operator|+
name|scnhdr
operator|.
name|s_nreloc
operator|*
name|RELSZ
expr_stmt|;
name|bfd_coff_swap_filehdr_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|filehdr
argument_list|,
name|filehdr_ext
argument_list|)
expr_stmt|;
name|bfd_bwrite
argument_list|(
name|filehdr_ext
argument_list|,
name|FILHSZ
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|bfd_coff_swap_scnhdr_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|scnhdr
argument_list|,
name|scnhdr_ext
argument_list|)
expr_stmt|;
name|bfd_bwrite
argument_list|(
name|scnhdr_ext
argument_list|,
name|SCNHSZ
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|bfd_bwrite
argument_list|(
name|data_buffer
argument_list|,
name|data_buffer_size
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|bfd_bwrite
argument_list|(
name|reloc_ext
argument_list|,
name|scnhdr
operator|.
name|s_nreloc
operator|*
name|RELSZ
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|bfd_bwrite
argument_list|(
name|syment_ext
argument_list|,
name|filehdr
operator|.
name|f_nsyms
operator|*
name|SYMESZ
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|bfd_bwrite
argument_list|(
name|string_table
argument_list|,
name|string_table_size
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data_buffer
argument_list|)
expr_stmt|;
name|data_buffer
operator|=
name|NULL
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* The typical dynamic reloc.  */
end_comment

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|xcoff64_dynamic_reloc
init|=
name|HOWTO
argument_list|(
literal|0
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_POS"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
name|MINUS_ONE
argument_list|,
comment|/* src_mask */
name|MINUS_ONE
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pcrel_offset */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|xcoff64_glink_code
index|[
literal|10
index|]
init|=
block|{
literal|0xe9820000
block|,
comment|/* ld r12,0(r2) */
literal|0xf8410028
block|,
comment|/* std r2,40(r1) */
literal|0xe80c0000
block|,
comment|/* ld r0,0(r12) */
literal|0xe84c0008
block|,
comment|/* ld r0,8(r12) */
literal|0x7c0903a6
block|,
comment|/* mtctr r0 */
literal|0x4e800420
block|,
comment|/* bctr */
literal|0x00000000
block|,
comment|/* start of traceback table */
literal|0x000ca000
block|,
comment|/* traceback table */
literal|0x00000000
block|,
comment|/* traceback table */
literal|0x00000018
block|,
comment|/* ??? */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|xcoff_backend_data_rec
name|bfd_xcoff_backend_data
init|=
block|{
block|{
comment|/* COFF backend, defined in libcoff.h */
name|_bfd_xcoff64_swap_aux_in
block|,
comment|/* _bfd_coff_swap_aux_in */
name|_bfd_xcoff64_swap_sym_in
block|,
comment|/* _bfd_coff_swap_sym_in */
name|_bfd_xcoff64_swap_lineno_in
block|,
comment|/* _bfd_coff_swap_lineno_in */
name|_bfd_xcoff64_swap_aux_out
block|,
comment|/* _bfd_swap_aux_out */
name|_bfd_xcoff64_swap_sym_out
block|,
comment|/* _bfd_swap_sym_out */
name|_bfd_xcoff64_swap_lineno_out
block|,
comment|/* _bfd_swap_lineno_out */
name|coff_swap_reloc_out
block|,
comment|/* _bfd_swap_reloc_out */
name|coff_swap_filehdr_out
block|,
comment|/* _bfd_swap_filehdr_out */
name|coff_swap_aouthdr_out
block|,
comment|/* _bfd_swap_aouthdr_out */
name|coff_swap_scnhdr_out
block|,
comment|/* _bfd_swap_scnhdr_out */
name|FILHSZ
block|,
comment|/* _bfd_filhsz */
name|AOUTSZ
block|,
comment|/* _bfd_aoutsz */
name|SCNHSZ
block|,
comment|/* _bfd_scnhsz */
name|SYMESZ
block|,
comment|/* _bfd_symesz */
name|AUXESZ
block|,
comment|/* _bfd_auxesz */
name|RELSZ
block|,
comment|/* _bfd_relsz */
name|LINESZ
block|,
comment|/* _bfd_linesz */
name|FILNMLEN
block|,
comment|/* _bfd_filnmlen */
name|true
block|,
comment|/* _bfd_coff_long_filenames */
name|false
block|,
comment|/* _bfd_coff_long_section_names */
operator|(
literal|3
operator|)
block|,
comment|/* _bfd_coff_default_section_alignment_power */
name|true
block|,
comment|/* _bfd_coff_force_symnames_in_strings */
literal|4
block|,
comment|/* _bfd_coff_debug_string_prefix_length */
name|coff_swap_filehdr_in
block|,
comment|/* _bfd_coff_swap_filehdr_in */
name|coff_swap_aouthdr_in
block|,
comment|/* _bfd_swap_aouthdr_in */
name|coff_swap_scnhdr_in
block|,
comment|/* _bfd_swap_scnhdr_in */
name|coff_swap_reloc_in
block|,
comment|/* _bfd_reloc_in */
name|coff_bad_format_hook
block|,
comment|/* _bfd_bad_format_hook */
name|coff_set_arch_mach_hook
block|,
comment|/* _bfd_set_arch_mach_hook */
name|coff_mkobject_hook
block|,
comment|/* _bfd_mkobject_hook */
name|styp_to_sec_flags
block|,
comment|/* _bfd_syp_to_sec_flags */
name|coff_set_alignment_hook
block|,
comment|/* _bfd_set_alignment_hook */
name|coff_slurp_symbol_table
block|,
comment|/* _bfd_coff_slurp_symbol_table */
name|symname_in_debug_hook
block|,
comment|/* _coff_symname_in_debug_hook */
name|coff_pointerize_aux_hook
block|,
comment|/* _bfd_coff_pointerize_aux_hook */
name|coff_print_aux
block|,
comment|/* bfd_coff_print_aux */
name|dummy_reloc16_extra_cases
block|,
comment|/* _bfd_coff_reloc16_extra_cases */
name|dummy_reloc16_estimate
block|,
comment|/* _bfd_coff_reloc16_estimate */
name|NULL
block|,
comment|/* bfd_coff_sym_is_global */
comment|/* _bfd_coff_compute_section_file_positions */
name|coff_compute_section_file_positions
block|,
name|NULL
block|,
comment|/* _bfd_coff_start_final_link */
name|xcoff64_ppc_relocate_section
block|,
comment|/* _bfd_coff_relocate_section */
name|coff_rtype_to_howto
block|,
comment|/* _bfd_coff_rtype_to_howto */
name|NULL
block|,
comment|/* _bfd_coff_addust_symndx */
name|_bfd_generic_link_add_one_symbol
block|,
comment|/* _bfd_coff_add_one_symbol */
name|coff_link_output_has_begun
block|,
comment|/* _bfd_coff_link_output_has_begun */
name|coff_final_link_postscript
comment|/* _bfd_coff_final_link_postscript */
block|}
block|,
literal|0x01EF
block|,
comment|/* magic number */
name|bfd_arch_powerpc
block|,
comment|/* architecture */
name|bfd_mach_ppc_620
block|,
comment|/* machine */
comment|/* function pointers to xcoff specific swap routines */
name|xcoff64_swap_ldhdr_in
block|,
comment|/* _xcoff_swap_ldhdr_in */
name|xcoff64_swap_ldhdr_out
block|,
comment|/* _xcoff_swap_ldhdr_out */
name|xcoff64_swap_ldsym_in
block|,
comment|/* _xcoff_swap_ldsym_in */
name|xcoff64_swap_ldsym_out
block|,
comment|/* _xcoff_swap_ldsym_out */
name|xcoff64_swap_ldrel_in
block|,
comment|/* _xcoff_swap_ldrel_in */
name|xcoff64_swap_ldrel_out
block|,
comment|/* _xcoff_swap_ldrel_out */
comment|/* sizes */
name|LDHDRSZ
block|,
comment|/* _xcoff_ldhdrsz */
name|LDSYMSZ
block|,
comment|/* _xcoff_ldsymsz */
name|LDRELSZ
block|,
comment|/* _xcoff_ldrelsz */
literal|24
block|,
comment|/* _xcoff_function_descriptor_size */
literal|0
block|,
comment|/* _xcoff_small_aout_header_size */
comment|/* versions */
literal|2
block|,
comment|/* _xcoff_ldhdr_version */
comment|/* xcoff vs xcoff64 putting symbol names */
name|_bfd_xcoff64_put_symbol_name
block|,
comment|/* _xcoff_put_symbol_name */
name|_bfd_xcoff64_put_ldsymbol_name
block|,
comment|/* _xcoff_put_ldsymbol_name */
comment|/* dynamic reloc howto */
operator|&
name|xcoff64_dynamic_reloc
block|,
name|xcoff64_create_csect_from_smclas
block|,
comment|/* lineno and reloc count overflow */
name|xcoff64_is_lineno_count_overflow
block|,
name|xcoff64_is_reloc_count_overflow
block|,
name|xcoff64_loader_symbol_offset
block|,
name|xcoff64_loader_reloc_offset
block|,
comment|/* glink */
operator|&
name|xcoff64_glink_code
index|[
literal|0
index|]
block|,
literal|40
block|,
comment|/* _xcoff_glink_size */
comment|/* rtinit */
literal|88
block|,
comment|/* _xcoff_rtinit_size */
name|xcoff64_generate_rtinit
block|,
comment|/* _xcoff_generate_rtinit */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The transfer vector that leads the outside world to all of the above. */
end_comment

begin_decl_stmt
specifier|const
name|bfd_target
name|rs6000coff64_vec
init|=
block|{
literal|"aixcoff64-rs6000"
block|,
name|bfd_target_xcoff_flavour
block|,
name|BFD_ENDIAN_BIG
block|,
comment|/* data byte order is big */
name|BFD_ENDIAN_BIG
block|,
comment|/* header byte order is big */
operator|(
name|HAS_RELOC
operator||
name|EXEC_P
operator||
comment|/* object flags */
name|HAS_LINENO
operator||
name|HAS_DEBUG
operator||
name|DYNAMIC
operator||
name|HAS_SYMS
operator||
name|HAS_LOCALS
operator||
name|WP_TEXT
operator|)
block|,
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator|)
block|,
comment|/* section flags */
literal|0
block|,
comment|/* leading char */
literal|'/'
block|,
comment|/* ar_pad_char */
literal|15
block|,
comment|/* ar_max_namelen??? FIXMEmgo */
comment|/* data */
name|bfd_getb64
block|,
comment|/* bfd_getx64 */
name|bfd_getb_signed_64
block|,
comment|/* bfd_getx_signed_64 */
name|bfd_putb64
block|,
comment|/* bfd_putx64 */
name|bfd_getb32
block|,
comment|/* bfd_getx32 */
name|bfd_getb_signed_32
block|,
comment|/* bfd_getx_signed_32 */
name|bfd_putb32
block|,
comment|/* bfd_putx32 */
name|bfd_getb16
block|,
comment|/* bfd_getx16 */
name|bfd_getb_signed_16
block|,
comment|/* bfd_getx_signed_16 */
name|bfd_putb16
block|,
comment|/* bfd_putx16 */
comment|/* hdrs */
name|bfd_getb64
block|,
comment|/* bfd_h_getx64 */
name|bfd_getb_signed_64
block|,
comment|/* bfd_h_getx_signed_64 */
name|bfd_putb64
block|,
comment|/* bfd_h_putx64 */
name|bfd_getb32
block|,
comment|/* bfd_h_getx32 */
name|bfd_getb_signed_32
block|,
comment|/* bfd_h_getx_signed_32 */
name|bfd_putb32
block|,
comment|/* bfd_h_putx32 */
name|bfd_getb16
block|,
comment|/* bfd_h_getx16 */
name|bfd_getb_signed_16
block|,
comment|/* bfd_h_getx_signed_16 */
name|bfd_putb16
block|,
comment|/* bfd_h_putx16 */
block|{
comment|/* bfd_check_format */
name|_bfd_dummy_target
block|,
name|coff_object_p
block|,
name|xcoff64_archive_p
block|,
name|CORE_FILE_P
block|}
block|,
block|{
comment|/* bfd_set_format */
name|bfd_false
block|,
name|coff_mkobject
block|,
name|_bfd_generic_mkarchive
block|,
name|bfd_false
block|}
block|,
block|{
comment|/* bfd_write_contents */
name|bfd_false
block|,
name|xcoff64_write_object_contents
block|,
name|_bfd_xcoff_write_archive_contents
block|,
name|bfd_false
block|}
block|,
comment|/* Generic */
name|bfd_true
block|,
comment|/* _close_and_cleanup */
name|bfd_true
block|,
comment|/* _bfd_free_cached_info */
name|coff_new_section_hook
block|,
comment|/* _new_section_hook */
name|_bfd_generic_get_section_contents
block|,
comment|/* _bfd_get_section_contents */
comment|/* _bfd_get_section_contents_in_window */
name|_bfd_generic_get_section_contents_in_window
block|,
comment|/* Copy */
name|_bfd_xcoff_copy_private_bfd_data
block|,
comment|/* _bfd_copy_private_bfd */
comment|/* _bfd_merge_private_bfd_data */
operator|(
operator|(
name|boolean
argument_list|(
operator|*
argument_list|)
argument_list|(
name|bfd
operator|*
argument_list|,
name|bfd
operator|*
argument_list|)
operator|)
name|bfd_true
operator|)
block|,
comment|/* _bfd_copy_pivate_section_data */
operator|(
operator|(
name|boolean
argument_list|(
operator|*
argument_list|)
argument_list|(
name|bfd
operator|*
argument_list|,
name|asection
operator|*
argument_list|,
name|bfd
operator|*
argument_list|,
name|asection
operator|*
argument_list|)
operator|)
name|bfd_true
operator|)
block|,
comment|/* _bfd_copy_private_symbol_data */
operator|(
operator|(
name|boolean
argument_list|(
operator|*
argument_list|)
argument_list|(
name|bfd
operator|*
argument_list|,
name|asymbol
operator|*
argument_list|,
name|bfd
operator|*
argument_list|,
name|asymbol
operator|*
argument_list|)
operator|)
name|bfd_true
operator|)
block|,
operator|(
operator|(
name|boolean
argument_list|(
operator|*
argument_list|)
argument_list|(
name|bfd
operator|*
argument_list|,
name|flagword
argument_list|)
operator|)
name|bfd_true
operator|)
block|,
comment|/* _bfd_set_private_flags */
operator|(
operator|(
name|boolean
argument_list|(
operator|*
argument_list|)
argument_list|(
name|bfd
operator|*
argument_list|,
name|void
operator|*
argument_list|)
operator|)
name|bfd_true
operator|)
block|,
comment|/* _bfd_print_private_bfd_data */
comment|/* Core */
name|coff_core_file_failing_command
block|,
comment|/* _core_file_failing_command */
name|coff_core_file_failing_signal
block|,
comment|/* _core_file_failing_signal */
comment|/* _core_file_matches_executable_p */
name|coff_core_file_matches_executable_p
block|,
comment|/* Archive */
name|xcoff64_slurp_armap
block|,
comment|/* _slurp_armap */
comment|/* XCOFF archives do not have      anything which corresponds to      an extended name table.  */
name|bfd_false
block|,
comment|/* _slurp_extended_name_table */
comment|/* _construct_extended_name_table */
operator|(
operator|(
name|boolean
argument_list|(
operator|*
argument_list|)
argument_list|(
name|bfd
operator|*
argument_list|,
name|char
operator|*
operator|*
argument_list|,
name|bfd_size_type
operator|*
argument_list|,
specifier|const
name|char
operator|*
operator|*
argument_list|)
operator|)
name|bfd_false
operator|)
block|,
name|bfd_dont_truncate_arname
block|,
comment|/* _truncate_arname */
name|_bfd_xcoff_write_armap
block|,
comment|/* _write_armap */
name|_bfd_xcoff_read_ar_hdr
block|,
comment|/* _read_ar_hdr */
name|xcoff64_openr_next_archived_file
block|,
comment|/* _openr_next_archived_file */
name|_bfd_generic_get_elt_at_index
block|,
comment|/* _get_elt_at_index */
name|_bfd_xcoff_generic_stat_arch_elt
block|,
comment|/* _generic_dtat_arch_elt */
comment|/* XCOFF archives do not have      a timestamp.  */
name|bfd_true
block|,
comment|/* _update_armap_timestamp */
comment|/* Symbols */
name|coff_get_symtab_upper_bound
block|,
comment|/* _get_symtab_upper_bound */
name|coff_get_symtab
block|,
comment|/* _get_symtab */
name|coff_make_empty_symbol
block|,
comment|/* _make_empty_symbol */
name|coff_print_symbol
block|,
comment|/* _print_symbol */
name|coff_get_symbol_info
block|,
comment|/* _get_symbol_info */
name|_bfd_xcoff_is_local_label_name
block|,
comment|/* _bfd_is_local_label_name */
name|coff_get_lineno
block|,
comment|/* _get_lineno */
name|coff_find_nearest_line
block|,
comment|/* _find_nearest_line */
name|coff_bfd_make_debug_symbol
block|,
comment|/* _bfd_make_debug_symbol */
name|_bfd_generic_read_minisymbols
block|,
comment|/* _read_minisymbols */
name|_bfd_generic_minisymbol_to_symbol
block|,
comment|/* _minsymbol_to_symbol */
comment|/* Reloc */
name|coff_get_reloc_upper_bound
block|,
comment|/* _get_reloc_upper_bound */
name|coff_canonicalize_reloc
block|,
comment|/* _cononicalize_reloc */
name|xcoff64_reloc_type_lookup
block|,
comment|/* _bfd_reloc_type_lookup */
comment|/* Write */
name|coff_set_arch_mach
block|,
comment|/* _set_arch_mach */
name|coff_set_section_contents
block|,
comment|/* _set_section_contents */
comment|/* Link */
name|xcoff64_sizeof_headers
block|,
comment|/* _sizeof_headers */
comment|/* _bfd_get_relocated_section_contents */
name|bfd_generic_get_relocated_section_contents
block|,
name|bfd_generic_relax_section
block|,
comment|/* _bfd_relax_section */
name|_bfd_xcoff_bfd_link_hash_table_create
block|,
comment|/* _bfd_link_hash_table_create */
name|_bfd_xcoff_bfd_link_add_symbols
block|,
comment|/* _bfd_link_add_symbols */
name|_bfd_xcoff_bfd_final_link
block|,
comment|/* _bfd_filnal_link */
name|_bfd_generic_link_split_section
block|,
comment|/* _bfd_link_split_section */
name|bfd_generic_gc_sections
block|,
comment|/* _bfd_gc_sections */
name|bfd_generic_merge_sections
block|,
comment|/* _bfd_merge_sections */
comment|/* Dynamic */
comment|/* _get_dynamic_symtab_upper_bound */
name|_bfd_xcoff_get_dynamic_symtab_upper_bound
block|,
name|_bfd_xcoff_canonicalize_dynamic_symtab
block|,
comment|/* _cononicalize_dynamic_symtab */
name|_bfd_xcoff_get_dynamic_reloc_upper_bound
block|,
comment|/* _get_dynamic_reloc_upper_bound */
name|_bfd_xcoff_canonicalize_dynamic_reloc
block|,
comment|/* _cononicalize_dynamic_reloc */
comment|/* Opposite endian version, none exists */
name|NULL
block|,
comment|/* back end data */
operator|(
name|void
operator|*
operator|)
operator|&
name|bfd_xcoff_backend_data
block|, }
decl_stmt|;
end_decl_stmt

end_unit

