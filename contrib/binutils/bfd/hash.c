begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* hash.c -- hash table routines for BFD    Copyright 1993, 1994, 1995, 1997, 1999, 2001, 2002, 2003, 2004, 2005,    2006, 2007 Free Software Foundation, Inc.    Written by Steve Chamberlain<sac@cygnus.com>     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"objalloc.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_comment
comment|/* SECTION 	Hash Tables  @cindex Hash tables 	BFD provides a simple set of hash table functions.  Routines 	are provided to initialize a hash table, to free a hash table, 	to look up a string in a hash table and optionally create an 	entry for it, and to traverse a hash table.  There is 	currently no routine to delete an string from a hash table.  	The basic hash table does not permit any data to be stored 	with a string.  However, a hash table is designed to present a 	base class from which other types of hash tables may be 	derived.  These derived types may store additional information 	with the string.  Hash tables were implemented in this way, 	rather than simply providing a data pointer in a hash table 	entry, because they were designed for use by the linker back 	ends.  The linker may create thousands of hash table entries, 	and the overhead of allocating private data and storing and 	following pointers becomes noticeable.  	The basic hash table code is in<<hash.c>>.  @menu @* Creating and Freeing a Hash Table:: @* Looking Up or Entering a String:: @* Traversing a Hash Table:: @* Deriving a New Hash Table Type:: @end menu  INODE Creating and Freeing a Hash Table, Looking Up or Entering a String, Hash Tables, Hash Tables SUBSECTION 	Creating and freeing a hash table  @findex bfd_hash_table_init @findex bfd_hash_table_init_n 	To create a hash table, create an instance of a<<struct 	bfd_hash_table>> (defined in<<bfd.h>>) and call<<bfd_hash_table_init>> (if you know approximately how many 	entries you will need, the function<<bfd_hash_table_init_n>>, 	which takes a @var{size} argument, may be used).<<bfd_hash_table_init>> returns<<FALSE>> if some sort of 	error occurs.  @findex bfd_hash_newfunc 	The function<<bfd_hash_table_init>> take as an argument a 	function to use to create new entries.  For a basic hash 	table, use the function<<bfd_hash_newfunc>>.  @xref{Deriving 	a New Hash Table Type}, for why you would want to use a 	different value for this argument.  @findex bfd_hash_allocate<<bfd_hash_table_init>> will create an objalloc which will be 	used to allocate new entries.  You may allocate memory on this 	objalloc using<<bfd_hash_allocate>>.  @findex bfd_hash_table_free 	Use<<bfd_hash_table_free>> to free up all the memory that has 	been allocated for a hash table.  This will not free up the<<struct bfd_hash_table>> itself, which you must provide.  @findex bfd_hash_set_default_size 	Use<<bfd_hash_set_default_size>> to set the default size of 	hash table to use.  INODE Looking Up or Entering a String, Traversing a Hash Table, Creating and Freeing a Hash Table, Hash Tables SUBSECTION 	Looking up or entering a string  @findex bfd_hash_lookup 	The function<<bfd_hash_lookup>> is used both to look up a 	string in the hash table and to create a new entry.  	If the @var{create} argument is<<FALSE>>,<<bfd_hash_lookup>> 	will look up a string.  If the string is found, it will 	returns a pointer to a<<struct bfd_hash_entry>>.  If the 	string is not found in the table<<bfd_hash_lookup>> will 	return<<NULL>>.  You should not modify any of the fields in 	the returns<<struct bfd_hash_entry>>.  	If the @var{create} argument is<<TRUE>>, the string will be 	entered into the hash table if it is not already there. 	Either way a pointer to a<<struct bfd_hash_entry>> will be 	returned, either to the existing structure or to a newly 	created one.  In this case, a<<NULL>> return means that an 	error occurred.  	If the @var{create} argument is<<TRUE>>, and a new entry is 	created, the @var{copy} argument is used to decide whether to 	copy the string onto the hash table objalloc or not.  If 	@var{copy} is passed as<<FALSE>>, you must be careful not to 	deallocate or modify the string as long as the hash table 	exists.  INODE Traversing a Hash Table, Deriving a New Hash Table Type, Looking Up or Entering a String, Hash Tables SUBSECTION 	Traversing a hash table  @findex bfd_hash_traverse 	The function<<bfd_hash_traverse>> may be used to traverse a 	hash table, calling a function on each element.  The traversal 	is done in a random order.<<bfd_hash_traverse>> takes as arguments a function and a 	generic<<void *>> pointer.  The function is called with a 	hash table entry (a<<struct bfd_hash_entry *>>) and the 	generic pointer passed to<<bfd_hash_traverse>>.  The function 	must return a<<boolean>> value, which indicates whether to 	continue traversing the hash table.  If the function returns<<FALSE>>,<<bfd_hash_traverse>> will stop the traversal and 	return immediately.  INODE Deriving a New Hash Table Type, , Traversing a Hash Table, Hash Tables SUBSECTION 	Deriving a new hash table type  	Many uses of hash tables want to store additional information 	which each entry in the hash table.  Some also find it 	convenient to store additional information with the hash table 	itself.  This may be done using a derived hash table.  	Since C is not an object oriented language, creating a derived 	hash table requires sticking together some boilerplate 	routines with a few differences specific to the type of hash 	table you want to create.  	An example of a derived hash table is the linker hash table. 	The structures for this are defined in<<bfdlink.h>>.  The 	functions are in<<linker.c>>.  	You may also derive a hash table from an already derived hash 	table.  For example, the a.out linker backend code uses a hash 	table derived from the linker hash table.  @menu @* Define the Derived Structures:: @* Write the Derived Creation Routine:: @* Write Other Derived Routines:: @end menu  INODE Define the Derived Structures, Write the Derived Creation Routine, Deriving a New Hash Table Type, Deriving a New Hash Table Type SUBSUBSECTION 	Define the derived structures  	You must define a structure for an entry in the hash table, 	and a structure for the hash table itself.  	The first field in the structure for an entry in the hash 	table must be of the type used for an entry in the hash table 	you are deriving from.  If you are deriving from a basic hash 	table this is<<struct bfd_hash_entry>>, which is defined in<<bfd.h>>.  The first field in the structure for the hash 	table itself must be of the type of the hash table you are 	deriving from itself.  If you are deriving from a basic hash 	table, this is<<struct bfd_hash_table>>.  	For example, the linker hash table defines<<struct 	bfd_link_hash_entry>> (in<<bfdlink.h>>).  The first field,<<root>>, is of type<<struct bfd_hash_entry>>.  Similarly, 	the first field in<<struct bfd_link_hash_table>>,<<table>>, 	is of type<<struct bfd_hash_table>>.  INODE Write the Derived Creation Routine, Write Other Derived Routines, Define the Derived Structures, Deriving a New Hash Table Type SUBSUBSECTION 	Write the derived creation routine  	You must write a routine which will create and initialize an 	entry in the hash table.  This routine is passed as the 	function argument to<<bfd_hash_table_init>>.  	In order to permit other hash tables to be derived from the 	hash table you are creating, this routine must be written in a 	standard way.  	The first argument to the creation routine is a pointer to a 	hash table entry.  This may be<<NULL>>, in which case the 	routine should allocate the right amount of space.  Otherwise 	the space has already been allocated by a hash table type 	derived from this one.  	After allocating space, the creation routine must call the 	creation routine of the hash table type it is derived from, 	passing in a pointer to the space it just allocated.  This 	will initialize any fields used by the base hash table.  	Finally the creation routine must initialize any local fields 	for the new hash table type.  	Here is a boilerplate example of a creation routine. 	@var{function_name} is the name of the routine. 	@var{entry_type} is the type of an entry in the hash table you 	are creating.  @var{base_newfunc} is the name of the creation 	routine of the hash table type your hash table is derived 	from.  EXAMPLE  .struct bfd_hash_entry * .@var{function_name} (struct bfd_hash_entry *entry, .                     struct bfd_hash_table *table, .                     const char *string) .{ .  struct @var{entry_type} *ret = (@var{entry_type} *) entry; . . {* Allocate the structure if it has not already been allocated by a .    derived class.  *} .  if (ret == NULL) .    { .      ret = bfd_hash_allocate (table, sizeof (* ret)); .      if (ret == NULL) .        return NULL; .    } . . {* Call the allocation method of the base class.  *} .  ret = ((@var{entry_type} *) .	 @var{base_newfunc} ((struct bfd_hash_entry *) ret, table, string)); . . {* Initialize the local fields here.  *} . .  return (struct bfd_hash_entry *) ret; .}  DESCRIPTION 	The creation routine for the linker hash table, which is in<<linker.c>>, looks just like this example. 	@var{function_name} is<<_bfd_link_hash_newfunc>>. 	@var{entry_type} is<<struct bfd_link_hash_entry>>. 	@var{base_newfunc} is<<bfd_hash_newfunc>>, the creation 	routine for a basic hash table.<<_bfd_link_hash_newfunc>> also initializes the local fields 	in a linker hash table entry:<<type>>,<<written>> and<<next>>.  INODE Write Other Derived Routines, , Write the Derived Creation Routine, Deriving a New Hash Table Type SUBSUBSECTION 	Write other derived routines  	You will want to write other routines for your new hash table, 	as well.  	You will want an initialization routine which calls the 	initialization routine of the hash table you are deriving from 	and initializes any other local fields.  For the linker hash 	table, this is<<_bfd_link_hash_table_init>> in<<linker.c>>.  	You will want a lookup routine which calls the lookup routine 	of the hash table you are deriving from and casts the result. 	The linker hash table uses<<bfd_link_hash_lookup>> in<<linker.c>> (this actually takes an additional argument which 	it uses to decide how to return the looked up value).  	You may want a traversal routine.  This should just call the 	traversal routine of the hash table you are deriving from with 	appropriate casts.  The linker hash table uses<<bfd_link_hash_traverse>> in<<linker.c>>.  	These routines may simply be defined as macros.  For example, 	the a.out backend linker hash table, which is derived from the 	linker hash table, uses macros for the lookup and traversal 	routines.  These are<<aout_link_hash_lookup>> and<<aout_link_hash_traverse>> in aoutx.h. */
end_comment

begin_comment
comment|/* The default number of entries to use when creating a hash table.  */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_SIZE
value|4051
end_define

begin_comment
comment|/* The following function returns a nearest prime number which is    greater than N, and near a power of two.  Copied from libiberty.    Returns zero for ridiculously large N to signify an error.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|higher_prime_number
parameter_list|(
name|unsigned
name|long
name|n
parameter_list|)
block|{
comment|/* These are primes that are near, but slightly smaller than, a      power of two.  */
specifier|static
specifier|const
name|unsigned
name|long
name|primes
index|[]
init|=
block|{
operator|(
name|unsigned
name|long
operator|)
literal|127
block|,
operator|(
name|unsigned
name|long
operator|)
literal|2039
block|,
operator|(
name|unsigned
name|long
operator|)
literal|32749
block|,
operator|(
name|unsigned
name|long
operator|)
literal|65521
block|,
operator|(
name|unsigned
name|long
operator|)
literal|131071
block|,
operator|(
name|unsigned
name|long
operator|)
literal|262139
block|,
operator|(
name|unsigned
name|long
operator|)
literal|524287
block|,
operator|(
name|unsigned
name|long
operator|)
literal|1048573
block|,
operator|(
name|unsigned
name|long
operator|)
literal|2097143
block|,
operator|(
name|unsigned
name|long
operator|)
literal|4194301
block|,
operator|(
name|unsigned
name|long
operator|)
literal|8388593
block|,
operator|(
name|unsigned
name|long
operator|)
literal|16777213
block|,
operator|(
name|unsigned
name|long
operator|)
literal|33554393
block|,
operator|(
name|unsigned
name|long
operator|)
literal|67108859
block|,
operator|(
name|unsigned
name|long
operator|)
literal|134217689
block|,
operator|(
name|unsigned
name|long
operator|)
literal|268435399
block|,
operator|(
name|unsigned
name|long
operator|)
literal|536870909
block|,
operator|(
name|unsigned
name|long
operator|)
literal|1073741789
block|,
operator|(
name|unsigned
name|long
operator|)
literal|2147483647
block|,
comment|/* 4294967291L */
operator|(
operator|(
name|unsigned
name|long
operator|)
literal|2147483647
operator|)
operator|+
operator|(
operator|(
name|unsigned
name|long
operator|)
literal|2147483644
operator|)
block|,   }
decl_stmt|;
specifier|const
name|unsigned
name|long
modifier|*
name|low
init|=
operator|&
name|primes
index|[
literal|0
index|]
decl_stmt|;
specifier|const
name|unsigned
name|long
modifier|*
name|high
init|=
operator|&
name|primes
index|[
sizeof|sizeof
argument_list|(
name|primes
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|primes
index|[
literal|0
index|]
argument_list|)
index|]
decl_stmt|;
while|while
condition|(
name|low
operator|!=
name|high
condition|)
block|{
specifier|const
name|unsigned
name|long
modifier|*
name|mid
init|=
name|low
operator|+
operator|(
name|high
operator|-
name|low
operator|)
operator|/
literal|2
decl_stmt|;
if|if
condition|(
name|n
operator|>=
operator|*
name|mid
condition|)
name|low
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
else|else
name|high
operator|=
name|mid
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|>=
operator|*
name|low
condition|)
return|return
literal|0
return|;
return|return
operator|*
name|low
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|size_t
name|bfd_default_hash_table_size
init|=
name|DEFAULT_SIZE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Create a new hash table, given a number of entries.  */
end_comment

begin_decl_stmt
name|bfd_boolean
name|bfd_hash_table_init_n
argument_list|(
expr|struct
name|bfd_hash_table
operator|*
name|table
argument_list|,
expr|struct
name|bfd_hash_entry
operator|*
call|(
modifier|*
name|newfunc
call|)
argument_list|(
expr|struct
name|bfd_hash_entry
operator|*
argument_list|,
expr|struct
name|bfd_hash_table
operator|*
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|,
name|unsigned
name|int
name|entsize
argument_list|,
name|unsigned
name|int
name|size
argument_list|)
block|{
name|unsigned
name|int
name|alloc
decl_stmt|;
name|alloc
operator|=
name|size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|bfd_hash_entry
operator|*
argument_list|)
expr_stmt|;
name|table
operator|->
name|memory
operator|=
operator|(
name|void
operator|*
operator|)
name|objalloc_create
argument_list|()
expr_stmt|;
if|if
condition|(
name|table
operator|->
name|memory
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|table
operator|->
name|table
operator|=
name|objalloc_alloc
argument_list|(
operator|(
expr|struct
name|objalloc
operator|*
operator|)
name|table
operator|->
name|memory
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|table
operator|->
name|table
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
name|table
operator|->
name|table
argument_list|,
literal|0
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
name|table
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|table
operator|->
name|entsize
operator|=
name|entsize
expr_stmt|;
name|table
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|table
operator|->
name|frozen
operator|=
literal|0
expr_stmt|;
name|table
operator|->
name|newfunc
operator|=
name|newfunc
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Create a new hash table with the default number of entries.  */
end_comment

begin_decl_stmt
name|bfd_boolean
name|bfd_hash_table_init
argument_list|(
expr|struct
name|bfd_hash_table
operator|*
name|table
argument_list|,
expr|struct
name|bfd_hash_entry
operator|*
call|(
modifier|*
name|newfunc
call|)
argument_list|(
expr|struct
name|bfd_hash_entry
operator|*
argument_list|,
expr|struct
name|bfd_hash_table
operator|*
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|,
name|unsigned
name|int
name|entsize
argument_list|)
block|{
return|return
name|bfd_hash_table_init_n
argument_list|(
name|table
argument_list|,
name|newfunc
argument_list|,
name|entsize
argument_list|,
name|bfd_default_hash_table_size
argument_list|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Free a hash table.  */
end_comment

begin_function
name|void
name|bfd_hash_table_free
parameter_list|(
name|struct
name|bfd_hash_table
modifier|*
name|table
parameter_list|)
block|{
name|objalloc_free
argument_list|(
name|table
operator|->
name|memory
argument_list|)
expr_stmt|;
name|table
operator|->
name|memory
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Look up a string in a hash table.  */
end_comment

begin_function
name|struct
name|bfd_hash_entry
modifier|*
name|bfd_hash_lookup
parameter_list|(
name|struct
name|bfd_hash_table
modifier|*
name|table
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|bfd_boolean
name|create
parameter_list|,
name|bfd_boolean
name|copy
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|s
decl_stmt|;
name|unsigned
name|long
name|hash
decl_stmt|;
name|unsigned
name|int
name|c
decl_stmt|;
name|struct
name|bfd_hash_entry
modifier|*
name|hashp
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
name|unsigned
name|int
name|index
decl_stmt|;
name|hash
operator|=
literal|0
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|s
operator|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|string
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|s
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
name|hash
operator|+=
name|c
operator|+
operator|(
name|c
operator|<<
literal|17
operator|)
expr_stmt|;
name|hash
operator|^=
name|hash
operator|>>
literal|2
expr_stmt|;
block|}
name|len
operator|=
operator|(
name|s
operator|-
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|string
operator|)
operator|-
literal|1
expr_stmt|;
name|hash
operator|+=
name|len
operator|+
operator|(
name|len
operator|<<
literal|17
operator|)
expr_stmt|;
name|hash
operator|^=
name|hash
operator|>>
literal|2
expr_stmt|;
name|index
operator|=
name|hash
operator|%
name|table
operator|->
name|size
expr_stmt|;
for|for
control|(
name|hashp
operator|=
name|table
operator|->
name|table
index|[
name|index
index|]
init|;
name|hashp
operator|!=
name|NULL
condition|;
name|hashp
operator|=
name|hashp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|hashp
operator|->
name|hash
operator|==
name|hash
operator|&&
name|strcmp
argument_list|(
name|hashp
operator|->
name|string
argument_list|,
name|string
argument_list|)
operator|==
literal|0
condition|)
return|return
name|hashp
return|;
block|}
if|if
condition|(
operator|!
name|create
condition|)
return|return
name|NULL
return|;
name|hashp
operator|=
call|(
modifier|*
name|table
operator|->
name|newfunc
call|)
argument_list|(
name|NULL
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|hashp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|copy
condition|)
block|{
name|char
modifier|*
name|new
decl_stmt|;
name|new
operator|=
name|objalloc_alloc
argument_list|(
operator|(
expr|struct
name|objalloc
operator|*
operator|)
name|table
operator|->
name|memory
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memcpy
argument_list|(
name|new
argument_list|,
name|string
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|string
operator|=
name|new
expr_stmt|;
block|}
name|hashp
operator|->
name|string
operator|=
name|string
expr_stmt|;
name|hashp
operator|->
name|hash
operator|=
name|hash
expr_stmt|;
name|hashp
operator|->
name|next
operator|=
name|table
operator|->
name|table
index|[
name|index
index|]
expr_stmt|;
name|table
operator|->
name|table
index|[
name|index
index|]
operator|=
name|hashp
expr_stmt|;
name|table
operator|->
name|count
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|table
operator|->
name|frozen
operator|&&
name|table
operator|->
name|count
operator|>
name|table
operator|->
name|size
operator|*
literal|3
operator|/
literal|4
condition|)
block|{
name|unsigned
name|long
name|newsize
init|=
name|higher_prime_number
argument_list|(
name|table
operator|->
name|size
argument_list|)
decl_stmt|;
name|struct
name|bfd_hash_entry
modifier|*
modifier|*
name|newtable
decl_stmt|;
name|unsigned
name|int
name|hi
decl_stmt|;
name|unsigned
name|long
name|alloc
init|=
name|newsize
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|bfd_hash_entry
operator|*
argument_list|)
decl_stmt|;
comment|/* If we can't find a higher prime, or we can't possibly alloc 	 that much memory, don't try to grow the table.  */
if|if
condition|(
name|newsize
operator|==
literal|0
operator|||
name|alloc
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|bfd_hash_entry
operator|*
argument_list|)
operator|!=
name|newsize
condition|)
block|{
name|table
operator|->
name|frozen
operator|=
literal|1
expr_stmt|;
return|return
name|hashp
return|;
block|}
name|newtable
operator|=
operator|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|*
operator|)
name|objalloc_alloc
argument_list|(
operator|(
expr|struct
name|objalloc
operator|*
operator|)
name|table
operator|->
name|memory
argument_list|,
name|alloc
argument_list|)
operator|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|PTR
operator|)
name|newtable
argument_list|,
literal|0
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
literal|0
init|;
name|hi
operator|<
name|table
operator|->
name|size
condition|;
name|hi
operator|++
control|)
while|while
condition|(
name|table
operator|->
name|table
index|[
name|hi
index|]
condition|)
block|{
name|struct
name|bfd_hash_entry
modifier|*
name|chain
init|=
name|table
operator|->
name|table
index|[
name|hi
index|]
decl_stmt|;
name|struct
name|bfd_hash_entry
modifier|*
name|chain_end
init|=
name|chain
decl_stmt|;
name|int
name|index
decl_stmt|;
while|while
condition|(
name|chain_end
operator|->
name|next
operator|&&
name|chain_end
operator|->
name|next
operator|->
name|hash
operator|==
name|chain
operator|->
name|hash
condition|)
name|chain_end
operator|=
name|chain_end
operator|->
name|next
expr_stmt|;
name|table
operator|->
name|table
index|[
name|hi
index|]
operator|=
name|chain_end
operator|->
name|next
expr_stmt|;
name|index
operator|=
name|chain
operator|->
name|hash
operator|%
name|newsize
expr_stmt|;
name|chain_end
operator|->
name|next
operator|=
name|newtable
index|[
name|index
index|]
expr_stmt|;
name|newtable
index|[
name|index
index|]
operator|=
name|chain
expr_stmt|;
block|}
name|table
operator|->
name|table
operator|=
name|newtable
expr_stmt|;
name|table
operator|->
name|size
operator|=
name|newsize
expr_stmt|;
block|}
return|return
name|hashp
return|;
block|}
end_function

begin_comment
comment|/* Replace an entry in a hash table.  */
end_comment

begin_function
name|void
name|bfd_hash_replace
parameter_list|(
name|struct
name|bfd_hash_table
modifier|*
name|table
parameter_list|,
name|struct
name|bfd_hash_entry
modifier|*
name|old
parameter_list|,
name|struct
name|bfd_hash_entry
modifier|*
name|nw
parameter_list|)
block|{
name|unsigned
name|int
name|index
decl_stmt|;
name|struct
name|bfd_hash_entry
modifier|*
modifier|*
name|pph
decl_stmt|;
name|index
operator|=
name|old
operator|->
name|hash
operator|%
name|table
operator|->
name|size
expr_stmt|;
for|for
control|(
name|pph
operator|=
operator|&
name|table
operator|->
name|table
index|[
name|index
index|]
init|;
operator|(
operator|*
name|pph
operator|)
operator|!=
name|NULL
condition|;
name|pph
operator|=
operator|&
operator|(
operator|*
name|pph
operator|)
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|*
name|pph
operator|==
name|old
condition|)
block|{
operator|*
name|pph
operator|=
name|nw
expr_stmt|;
return|return;
block|}
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocate space in a hash table.  */
end_comment

begin_function
name|void
modifier|*
name|bfd_hash_allocate
parameter_list|(
name|struct
name|bfd_hash_table
modifier|*
name|table
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
name|objalloc_alloc
argument_list|(
operator|(
expr|struct
name|objalloc
operator|*
operator|)
name|table
operator|->
name|memory
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
operator|&&
name|size
operator|!=
literal|0
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Base method for creating a new hash table entry.  */
end_comment

begin_function
name|struct
name|bfd_hash_entry
modifier|*
name|bfd_hash_newfunc
parameter_list|(
name|struct
name|bfd_hash_entry
modifier|*
name|entry
parameter_list|,
name|struct
name|bfd_hash_table
modifier|*
name|table
parameter_list|,
specifier|const
name|char
modifier|*
name|string
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
name|entry
operator|=
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|entry
return|;
block|}
end_function

begin_comment
comment|/* Traverse a hash table.  */
end_comment

begin_function
name|void
name|bfd_hash_traverse
parameter_list|(
name|struct
name|bfd_hash_table
modifier|*
name|table
parameter_list|,
name|bfd_boolean
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|struct
name|bfd_hash_entry
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|info
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|table
operator|->
name|frozen
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|table
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|bfd_hash_entry
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|table
operator|->
name|table
index|[
name|i
index|]
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
operator|!
call|(
modifier|*
name|func
call|)
argument_list|(
name|p
argument_list|,
name|info
argument_list|)
condition|)
goto|goto
name|out
goto|;
block|}
name|out
label|:
name|table
operator|->
name|frozen
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|bfd_hash_set_default_size
parameter_list|(
name|bfd_size_type
name|hash_size
parameter_list|)
block|{
comment|/* Extend this prime list if you want more granularity of hash table size.  */
specifier|static
specifier|const
name|bfd_size_type
name|hash_size_primes
index|[]
init|=
block|{
literal|251
block|,
literal|509
block|,
literal|1021
block|,
literal|2039
block|,
literal|4051
block|,
literal|8599
block|,
literal|16699
block|,
literal|32749
block|}
decl_stmt|;
name|size_t
name|index
decl_stmt|;
comment|/* Work out best prime number near the hash_size.  */
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|ARRAY_SIZE
argument_list|(
name|hash_size_primes
argument_list|)
operator|-
literal|1
condition|;
operator|++
name|index
control|)
if|if
condition|(
name|hash_size
operator|<=
name|hash_size_primes
index|[
name|index
index|]
condition|)
break|break;
name|bfd_default_hash_table_size
operator|=
name|hash_size_primes
index|[
name|index
index|]
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A few different object file formats (a.out, COFF, ELF) use a string    table.  These functions support adding strings to a string table,    returning the byte offset, and writing out the table.     Possible improvements:    + look for strings matching trailing substrings of other strings    + better data structures?  balanced trees?    + look at reducing memory use elsewhere -- maybe if we didn't have      to construct the entire symbol table at once, we could get by      with smaller amounts of VM?  (What effect does that have on the      string table reductions?)  */
end_comment

begin_comment
comment|/* An entry in the strtab hash table.  */
end_comment

begin_struct
struct|struct
name|strtab_hash_entry
block|{
name|struct
name|bfd_hash_entry
name|root
decl_stmt|;
comment|/* Index in string table.  */
name|bfd_size_type
name|index
decl_stmt|;
comment|/* Next string in strtab.  */
name|struct
name|strtab_hash_entry
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The strtab hash table.  */
end_comment

begin_struct
struct|struct
name|bfd_strtab_hash
block|{
name|struct
name|bfd_hash_table
name|table
decl_stmt|;
comment|/* Size of strtab--also next available index.  */
name|bfd_size_type
name|size
decl_stmt|;
comment|/* First string in strtab.  */
name|struct
name|strtab_hash_entry
modifier|*
name|first
decl_stmt|;
comment|/* Last string in strtab.  */
name|struct
name|strtab_hash_entry
modifier|*
name|last
decl_stmt|;
comment|/* Whether to precede strings with a two byte length, as in the      XCOFF .debug section.  */
name|bfd_boolean
name|xcoff
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Routine to create an entry in a strtab.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|strtab_hash_newfunc
parameter_list|(
name|struct
name|bfd_hash_entry
modifier|*
name|entry
parameter_list|,
name|struct
name|bfd_hash_table
modifier|*
name|table
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|struct
name|strtab_hash_entry
modifier|*
name|ret
init|=
operator|(
expr|struct
name|strtab_hash_entry
operator|*
operator|)
name|entry
decl_stmt|;
comment|/* Allocate the structure if it has not already been allocated by a      subclass.  */
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
name|ret
operator|=
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ret
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* Call the allocation method of the superclass.  */
name|ret
operator|=
operator|(
expr|struct
name|strtab_hash_entry
operator|*
operator|)
name|bfd_hash_newfunc
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
comment|/* Initialize the local fields.  */
name|ret
operator|->
name|index
operator|=
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
expr_stmt|;
name|ret
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Look up an entry in an strtab.  */
end_comment

begin_define
define|#
directive|define
name|strtab_hash_lookup
parameter_list|(
name|t
parameter_list|,
name|string
parameter_list|,
name|create
parameter_list|,
name|copy
parameter_list|)
define|\
value|((struct strtab_hash_entry *) \    bfd_hash_lookup (&(t)->table, (string), (create), (copy)))
end_define

begin_comment
comment|/* Create a new strtab.  */
end_comment

begin_function
name|struct
name|bfd_strtab_hash
modifier|*
name|_bfd_stringtab_init
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|bfd_strtab_hash
modifier|*
name|table
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
operator|*
name|table
argument_list|)
decl_stmt|;
name|table
operator|=
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|table
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|bfd_hash_table_init
argument_list|(
operator|&
name|table
operator|->
name|table
argument_list|,
name|strtab_hash_newfunc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|strtab_hash_entry
argument_list|)
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|table
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|table
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|table
operator|->
name|first
operator|=
name|NULL
expr_stmt|;
name|table
operator|->
name|last
operator|=
name|NULL
expr_stmt|;
name|table
operator|->
name|xcoff
operator|=
name|FALSE
expr_stmt|;
return|return
name|table
return|;
block|}
end_function

begin_comment
comment|/* Create a new strtab in which the strings are output in the format    used in the XCOFF .debug section: a two byte length precedes each    string.  */
end_comment

begin_function
name|struct
name|bfd_strtab_hash
modifier|*
name|_bfd_xcoff_stringtab_init
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|bfd_strtab_hash
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
name|_bfd_stringtab_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|NULL
condition|)
name|ret
operator|->
name|xcoff
operator|=
name|TRUE
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Free a strtab.  */
end_comment

begin_function
name|void
name|_bfd_stringtab_free
parameter_list|(
name|struct
name|bfd_strtab_hash
modifier|*
name|table
parameter_list|)
block|{
name|bfd_hash_table_free
argument_list|(
operator|&
name|table
operator|->
name|table
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|table
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get the index of a string in a strtab, adding it if it is not    already present.  If HASH is FALSE, we don't really use the hash    table, and we don't eliminate duplicate strings.  */
end_comment

begin_function
name|bfd_size_type
name|_bfd_stringtab_add
parameter_list|(
name|struct
name|bfd_strtab_hash
modifier|*
name|tab
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|bfd_boolean
name|hash
parameter_list|,
name|bfd_boolean
name|copy
parameter_list|)
block|{
name|struct
name|strtab_hash_entry
modifier|*
name|entry
decl_stmt|;
if|if
condition|(
name|hash
condition|)
block|{
name|entry
operator|=
name|strtab_hash_lookup
argument_list|(
name|tab
argument_list|,
name|str
argument_list|,
name|TRUE
argument_list|,
name|copy
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
return|return
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
return|;
block|}
else|else
block|{
name|entry
operator|=
name|bfd_hash_allocate
argument_list|(
operator|&
name|tab
operator|->
name|table
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
return|return
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|copy
condition|)
name|entry
operator|->
name|root
operator|.
name|string
operator|=
name|str
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|n
decl_stmt|;
name|n
operator|=
name|bfd_hash_allocate
argument_list|(
operator|&
name|tab
operator|->
name|table
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
return|;
name|entry
operator|->
name|root
operator|.
name|string
operator|=
name|n
expr_stmt|;
block|}
name|entry
operator|->
name|index
operator|=
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
expr_stmt|;
name|entry
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|entry
operator|->
name|index
operator|==
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
condition|)
block|{
name|entry
operator|->
name|index
operator|=
name|tab
operator|->
name|size
expr_stmt|;
name|tab
operator|->
name|size
operator|+=
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|tab
operator|->
name|xcoff
condition|)
block|{
name|entry
operator|->
name|index
operator|+=
literal|2
expr_stmt|;
name|tab
operator|->
name|size
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|tab
operator|->
name|first
operator|==
name|NULL
condition|)
name|tab
operator|->
name|first
operator|=
name|entry
expr_stmt|;
else|else
name|tab
operator|->
name|last
operator|->
name|next
operator|=
name|entry
expr_stmt|;
name|tab
operator|->
name|last
operator|=
name|entry
expr_stmt|;
block|}
return|return
name|entry
operator|->
name|index
return|;
block|}
end_function

begin_comment
comment|/* Get the number of bytes in a strtab.  */
end_comment

begin_function
name|bfd_size_type
name|_bfd_stringtab_size
parameter_list|(
name|struct
name|bfd_strtab_hash
modifier|*
name|tab
parameter_list|)
block|{
return|return
name|tab
operator|->
name|size
return|;
block|}
end_function

begin_comment
comment|/* Write out a strtab.  ABFD must already be at the right location in    the file.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_stringtab_emit
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_strtab_hash
modifier|*
name|tab
parameter_list|)
block|{
name|bfd_boolean
name|xcoff
decl_stmt|;
name|struct
name|strtab_hash_entry
modifier|*
name|entry
decl_stmt|;
name|xcoff
operator|=
name|tab
operator|->
name|xcoff
expr_stmt|;
for|for
control|(
name|entry
operator|=
name|tab
operator|->
name|first
init|;
name|entry
operator|!=
name|NULL
condition|;
name|entry
operator|=
name|entry
operator|->
name|next
control|)
block|{
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|str
operator|=
name|entry
operator|->
name|root
operator|.
name|string
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|xcoff
condition|)
block|{
name|bfd_byte
name|buf
index|[
literal|2
index|]
decl_stmt|;
comment|/* The output length includes the null byte.  */
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|len
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
operator|(
name|void
operator|*
operator|)
name|buf
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|2
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|2
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|bfd_bwrite
argument_list|(
operator|(
name|void
operator|*
operator|)
name|str
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|len
argument_list|,
name|abfd
argument_list|)
operator|!=
name|len
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

end_unit

