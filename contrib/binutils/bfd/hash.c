begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* hash.c -- hash table routines for BFD    Copyright 1993, 1994, 1995, 1997, 1999, 2001, 2002, 2003    Free Software Foundation, Inc.    Written by Steve Chamberlain<sac@cygnus.com>  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"objalloc.h"
end_include

begin_comment
comment|/* SECTION 	Hash Tables  @cindex Hash tables 	BFD provides a simple set of hash table functions.  Routines 	are provided to initialize a hash table, to free a hash table, 	to look up a string in a hash table and optionally create an 	entry for it, and to traverse a hash table.  There is 	currently no routine to delete an string from a hash table.  	The basic hash table does not permit any data to be stored 	with a string.  However, a hash table is designed to present a 	base class from which other types of hash tables may be 	derived.  These derived types may store additional information 	with the string.  Hash tables were implemented in this way, 	rather than simply providing a data pointer in a hash table 	entry, because they were designed for use by the linker back 	ends.  The linker may create thousands of hash table entries, 	and the overhead of allocating private data and storing and 	following pointers becomes noticeable.  	The basic hash table code is in<<hash.c>>.  @menu @* Creating and Freeing a Hash Table:: @* Looking Up or Entering a String:: @* Traversing a Hash Table:: @* Deriving a New Hash Table Type:: @end menu  INODE Creating and Freeing a Hash Table, Looking Up or Entering a String, Hash Tables, Hash Tables SUBSECTION 	Creating and freeing a hash table  @findex bfd_hash_table_init @findex bfd_hash_table_init_n 	To create a hash table, create an instance of a<<struct 	bfd_hash_table>> (defined in<<bfd.h>>) and call<<bfd_hash_table_init>> (if you know approximately how many 	entries you will need, the function<<bfd_hash_table_init_n>>, 	which takes a @var{size} argument, may be used).<<bfd_hash_table_init>> returns<<FALSE>> if some sort of 	error occurs.  @findex bfd_hash_newfunc 	The function<<bfd_hash_table_init>> take as an argument a 	function to use to create new entries.  For a basic hash 	table, use the function<<bfd_hash_newfunc>>.  @xref{Deriving 	a New Hash Table Type}, for why you would want to use a 	different value for this argument.  @findex bfd_hash_allocate<<bfd_hash_table_init>> will create an objalloc which will be 	used to allocate new entries.  You may allocate memory on this 	objalloc using<<bfd_hash_allocate>>.  @findex bfd_hash_table_free 	Use<<bfd_hash_table_free>> to free up all the memory that has 	been allocated for a hash table.  This will not free up the<<struct bfd_hash_table>> itself, which you must provide.  INODE Looking Up or Entering a String, Traversing a Hash Table, Creating and Freeing a Hash Table, Hash Tables SUBSECTION 	Looking up or entering a string  @findex bfd_hash_lookup 	The function<<bfd_hash_lookup>> is used both to look up a 	string in the hash table and to create a new entry.  	If the @var{create} argument is<<FALSE>>,<<bfd_hash_lookup>> 	will look up a string.  If the string is found, it will 	returns a pointer to a<<struct bfd_hash_entry>>.  If the 	string is not found in the table<<bfd_hash_lookup>> will 	return<<NULL>>.  You should not modify any of the fields in 	the returns<<struct bfd_hash_entry>>.  	If the @var{create} argument is<<TRUE>>, the string will be 	entered into the hash table if it is not already there. 	Either way a pointer to a<<struct bfd_hash_entry>> will be 	returned, either to the existing structure or to a newly 	created one.  In this case, a<<NULL>> return means that an 	error occurred.  	If the @var{create} argument is<<TRUE>>, and a new entry is 	created, the @var{copy} argument is used to decide whether to 	copy the string onto the hash table objalloc or not.  If 	@var{copy} is passed as<<FALSE>>, you must be careful not to 	deallocate or modify the string as long as the hash table 	exists.  INODE Traversing a Hash Table, Deriving a New Hash Table Type, Looking Up or Entering a String, Hash Tables SUBSECTION 	Traversing a hash table  @findex bfd_hash_traverse 	The function<<bfd_hash_traverse>> may be used to traverse a 	hash table, calling a function on each element.  The traversal 	is done in a random order.<<bfd_hash_traverse>> takes as arguments a function and a 	generic<<void *>> pointer.  The function is called with a 	hash table entry (a<<struct bfd_hash_entry *>>) and the 	generic pointer passed to<<bfd_hash_traverse>>.  The function 	must return a<<boolean>> value, which indicates whether to 	continue traversing the hash table.  If the function returns<<FALSE>>,<<bfd_hash_traverse>> will stop the traversal and 	return immediately.  INODE Deriving a New Hash Table Type, , Traversing a Hash Table, Hash Tables SUBSECTION 	Deriving a new hash table type  	Many uses of hash tables want to store additional information 	which each entry in the hash table.  Some also find it 	convenient to store additional information with the hash table 	itself.  This may be done using a derived hash table.  	Since C is not an object oriented language, creating a derived 	hash table requires sticking together some boilerplate 	routines with a few differences specific to the type of hash 	table you want to create.  	An example of a derived hash table is the linker hash table. 	The structures for this are defined in<<bfdlink.h>>.  The 	functions are in<<linker.c>>.  	You may also derive a hash table from an already derived hash 	table.  For example, the a.out linker backend code uses a hash 	table derived from the linker hash table.  @menu @* Define the Derived Structures:: @* Write the Derived Creation Routine:: @* Write Other Derived Routines:: @end menu  INODE Define the Derived Structures, Write the Derived Creation Routine, Deriving a New Hash Table Type, Deriving a New Hash Table Type SUBSUBSECTION 	Define the derived structures  	You must define a structure for an entry in the hash table, 	and a structure for the hash table itself.  	The first field in the structure for an entry in the hash 	table must be of the type used for an entry in the hash table 	you are deriving from.  If you are deriving from a basic hash 	table this is<<struct bfd_hash_entry>>, which is defined in<<bfd.h>>.  The first field in the structure for the hash 	table itself must be of the type of the hash table you are 	deriving from itself.  If you are deriving from a basic hash 	table, this is<<struct bfd_hash_table>>.  	For example, the linker hash table defines<<struct 	bfd_link_hash_entry>> (in<<bfdlink.h>>).  The first field,<<root>>, is of type<<struct bfd_hash_entry>>.  Similarly, 	the first field in<<struct bfd_link_hash_table>>,<<table>>, 	is of type<<struct bfd_hash_table>>.  INODE Write the Derived Creation Routine, Write Other Derived Routines, Define the Derived Structures, Deriving a New Hash Table Type SUBSUBSECTION 	Write the derived creation routine  	You must write a routine which will create and initialize an 	entry in the hash table.  This routine is passed as the 	function argument to<<bfd_hash_table_init>>.  	In order to permit other hash tables to be derived from the 	hash table you are creating, this routine must be written in a 	standard way.  	The first argument to the creation routine is a pointer to a 	hash table entry.  This may be<<NULL>>, in which case the 	routine should allocate the right amount of space.  Otherwise 	the space has already been allocated by a hash table type 	derived from this one.  	After allocating space, the creation routine must call the 	creation routine of the hash table type it is derived from, 	passing in a pointer to the space it just allocated.  This 	will initialize any fields used by the base hash table.  	Finally the creation routine must initialize any local fields 	for the new hash table type.  	Here is a boilerplate example of a creation routine. 	@var{function_name} is the name of the routine. 	@var{entry_type} is the type of an entry in the hash table you 	are creating.  @var{base_newfunc} is the name of the creation 	routine of the hash table type your hash table is derived 	from.  EXAMPLE  .struct bfd_hash_entry * .@var{function_name} (entry, table, string) .     struct bfd_hash_entry *entry; .     struct bfd_hash_table *table; .     const char *string; .{ .  struct @var{entry_type} *ret = (@var{entry_type} *) entry; . . {* Allocate the structure if it has not already been allocated by a .    derived class.  *} .  if (ret == (@var{entry_type} *) NULL) .    { .      ret = ((@var{entry_type} *) .	      bfd_hash_allocate (table, sizeof (@var{entry_type}))); .      if (ret == (@var{entry_type} *) NULL) .        return NULL; .    } . . {* Call the allocation method of the base class.  *} .  ret = ((@var{entry_type} *) .	 @var{base_newfunc} ((struct bfd_hash_entry *) ret, table, string)); . . {* Initialize the local fields here.  *} . .  return (struct bfd_hash_entry *) ret; .}  DESCRIPTION 	The creation routine for the linker hash table, which is in<<linker.c>>, looks just like this example. 	@var{function_name} is<<_bfd_link_hash_newfunc>>. 	@var{entry_type} is<<struct bfd_link_hash_entry>>. 	@var{base_newfunc} is<<bfd_hash_newfunc>>, the creation 	routine for a basic hash table.<<_bfd_link_hash_newfunc>> also initializes the local fields 	in a linker hash table entry:<<type>>,<<written>> and<<next>>.  INODE Write Other Derived Routines, , Write the Derived Creation Routine, Deriving a New Hash Table Type SUBSUBSECTION 	Write other derived routines  	You will want to write other routines for your new hash table, 	as well.  	You will want an initialization routine which calls the 	initialization routine of the hash table you are deriving from 	and initializes any other local fields.  For the linker hash 	table, this is<<_bfd_link_hash_table_init>> in<<linker.c>>.  	You will want a lookup routine which calls the lookup routine 	of the hash table you are deriving from and casts the result. 	The linker hash table uses<<bfd_link_hash_lookup>> in<<linker.c>> (this actually takes an additional argument which 	it uses to decide how to return the looked up value).  	You may want a traversal routine.  This should just call the 	traversal routine of the hash table you are deriving from with 	appropriate casts.  The linker hash table uses<<bfd_link_hash_traverse>> in<<linker.c>>.  	These routines may simply be defined as macros.  For example, 	the a.out backend linker hash table, which is derived from the 	linker hash table, uses macros for the lookup and traversal 	routines.  These are<<aout_link_hash_lookup>> and<<aout_link_hash_traverse>> in aoutx.h. */
end_comment

begin_comment
comment|/* The default number of entries to use when creating a hash table.  */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_SIZE
value|(4051)
end_define

begin_comment
comment|/* Create a new hash table, given a number of entries.  */
end_comment

begin_decl_stmt
name|bfd_boolean
name|bfd_hash_table_init_n
argument_list|(
name|table
argument_list|,
name|newfunc
argument_list|,
name|size
argument_list|)
decl|struct
name|bfd_hash_table
modifier|*
name|table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|bfd_hash_entry
modifier|*
argument_list|(
operator|*
name|newfunc
argument_list|)
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|,
expr|struct
name|bfd_hash_table
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unsigned
name|int
name|alloc
decl_stmt|;
name|alloc
operator|=
name|size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|bfd_hash_entry
operator|*
argument_list|)
expr_stmt|;
name|table
operator|->
name|memory
operator|=
operator|(
name|PTR
operator|)
name|objalloc_create
argument_list|()
expr_stmt|;
if|if
condition|(
name|table
operator|->
name|memory
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|table
operator|->
name|table
operator|=
operator|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|*
operator|)
name|objalloc_alloc
argument_list|(
operator|(
expr|struct
name|objalloc
operator|*
operator|)
name|table
operator|->
name|memory
argument_list|,
name|alloc
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|table
operator|->
name|table
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|memset
argument_list|(
operator|(
name|PTR
operator|)
name|table
operator|->
name|table
argument_list|,
literal|0
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
name|table
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|table
operator|->
name|newfunc
operator|=
name|newfunc
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_block

begin_comment
comment|/* Create a new hash table with the default number of entries.  */
end_comment

begin_decl_stmt
name|bfd_boolean
name|bfd_hash_table_init
argument_list|(
name|table
argument_list|,
name|newfunc
argument_list|)
decl|struct
name|bfd_hash_table
modifier|*
name|table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|bfd_hash_entry
modifier|*
argument_list|(
operator|*
name|newfunc
argument_list|)
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|,
expr|struct
name|bfd_hash_table
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
name|bfd_hash_table_init_n
argument_list|(
name|table
argument_list|,
name|newfunc
argument_list|,
name|DEFAULT_SIZE
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/* Free a hash table.  */
end_comment

begin_function
name|void
name|bfd_hash_table_free
parameter_list|(
name|table
parameter_list|)
name|struct
name|bfd_hash_table
modifier|*
name|table
decl_stmt|;
block|{
name|objalloc_free
argument_list|(
operator|(
expr|struct
name|objalloc
operator|*
operator|)
name|table
operator|->
name|memory
argument_list|)
expr_stmt|;
name|table
operator|->
name|memory
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Look up a string in a hash table.  */
end_comment

begin_function
name|struct
name|bfd_hash_entry
modifier|*
name|bfd_hash_lookup
parameter_list|(
name|table
parameter_list|,
name|string
parameter_list|,
name|create
parameter_list|,
name|copy
parameter_list|)
name|struct
name|bfd_hash_table
modifier|*
name|table
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
name|bfd_boolean
name|create
decl_stmt|;
name|bfd_boolean
name|copy
decl_stmt|;
block|{
specifier|register
specifier|const
name|unsigned
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|unsigned
name|long
name|hash
decl_stmt|;
specifier|register
name|unsigned
name|int
name|c
decl_stmt|;
name|struct
name|bfd_hash_entry
modifier|*
name|hashp
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
name|unsigned
name|int
name|index
decl_stmt|;
name|hash
operator|=
literal|0
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|s
operator|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|string
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|s
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
name|hash
operator|+=
name|c
operator|+
operator|(
name|c
operator|<<
literal|17
operator|)
expr_stmt|;
name|hash
operator|^=
name|hash
operator|>>
literal|2
expr_stmt|;
block|}
name|len
operator|=
operator|(
name|s
operator|-
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|string
operator|)
operator|-
literal|1
expr_stmt|;
name|hash
operator|+=
name|len
operator|+
operator|(
name|len
operator|<<
literal|17
operator|)
expr_stmt|;
name|hash
operator|^=
name|hash
operator|>>
literal|2
expr_stmt|;
name|index
operator|=
name|hash
operator|%
name|table
operator|->
name|size
expr_stmt|;
for|for
control|(
name|hashp
operator|=
name|table
operator|->
name|table
index|[
name|index
index|]
init|;
name|hashp
operator|!=
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|NULL
condition|;
name|hashp
operator|=
name|hashp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|hashp
operator|->
name|hash
operator|==
name|hash
operator|&&
name|strcmp
argument_list|(
name|hashp
operator|->
name|string
argument_list|,
name|string
argument_list|)
operator|==
literal|0
condition|)
return|return
name|hashp
return|;
block|}
if|if
condition|(
operator|!
name|create
condition|)
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|NULL
return|;
name|hashp
operator|=
call|(
modifier|*
name|table
operator|->
name|newfunc
call|)
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|NULL
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|hashp
operator|==
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|NULL
return|;
if|if
condition|(
name|copy
condition|)
block|{
name|char
modifier|*
name|new
decl_stmt|;
name|new
operator|=
operator|(
name|char
operator|*
operator|)
name|objalloc_alloc
argument_list|(
operator|(
expr|struct
name|objalloc
operator|*
operator|)
name|table
operator|->
name|memory
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|NULL
return|;
block|}
name|memcpy
argument_list|(
name|new
argument_list|,
name|string
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|string
operator|=
name|new
expr_stmt|;
block|}
name|hashp
operator|->
name|string
operator|=
name|string
expr_stmt|;
name|hashp
operator|->
name|hash
operator|=
name|hash
expr_stmt|;
name|hashp
operator|->
name|next
operator|=
name|table
operator|->
name|table
index|[
name|index
index|]
expr_stmt|;
name|table
operator|->
name|table
index|[
name|index
index|]
operator|=
name|hashp
expr_stmt|;
return|return
name|hashp
return|;
block|}
end_function

begin_comment
comment|/* Replace an entry in a hash table.  */
end_comment

begin_function
name|void
name|bfd_hash_replace
parameter_list|(
name|table
parameter_list|,
name|old
parameter_list|,
name|nw
parameter_list|)
name|struct
name|bfd_hash_table
modifier|*
name|table
decl_stmt|;
name|struct
name|bfd_hash_entry
modifier|*
name|old
decl_stmt|;
name|struct
name|bfd_hash_entry
modifier|*
name|nw
decl_stmt|;
block|{
name|unsigned
name|int
name|index
decl_stmt|;
name|struct
name|bfd_hash_entry
modifier|*
modifier|*
name|pph
decl_stmt|;
name|index
operator|=
name|old
operator|->
name|hash
operator|%
name|table
operator|->
name|size
expr_stmt|;
for|for
control|(
name|pph
operator|=
operator|&
name|table
operator|->
name|table
index|[
name|index
index|]
init|;
operator|(
operator|*
name|pph
operator|)
operator|!=
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|NULL
condition|;
name|pph
operator|=
operator|&
operator|(
operator|*
name|pph
operator|)
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|*
name|pph
operator|==
name|old
condition|)
block|{
operator|*
name|pph
operator|=
name|nw
expr_stmt|;
return|return;
block|}
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Base method for creating a new hash table entry.  */
end_comment

begin_function
name|struct
name|bfd_hash_entry
modifier|*
name|bfd_hash_newfunc
parameter_list|(
name|entry
parameter_list|,
name|table
parameter_list|,
name|string
parameter_list|)
name|struct
name|bfd_hash_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|bfd_hash_table
modifier|*
name|table
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|entry
operator|==
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|NULL
condition|)
name|entry
operator|=
operator|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bfd_hash_entry
argument_list|)
argument_list|)
operator|)
expr_stmt|;
return|return
name|entry
return|;
block|}
end_function

begin_comment
comment|/* Allocate space in a hash table.  */
end_comment

begin_function
name|PTR
name|bfd_hash_allocate
parameter_list|(
name|table
parameter_list|,
name|size
parameter_list|)
name|struct
name|bfd_hash_table
modifier|*
name|table
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
block|{
name|PTR
name|ret
decl_stmt|;
name|ret
operator|=
name|objalloc_alloc
argument_list|(
operator|(
expr|struct
name|objalloc
operator|*
operator|)
name|table
operator|->
name|memory
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
operator|&&
name|size
operator|!=
literal|0
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Traverse a hash table.  */
end_comment

begin_function_decl
name|void
name|bfd_hash_traverse
parameter_list|(
name|table
parameter_list|,
name|func
parameter_list|,
name|info
parameter_list|)
name|struct
name|bfd_hash_table
modifier|*
name|table
decl_stmt|;
function_decl|bfd_boolean
parameter_list|(
function_decl|*func
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|PTR
name|info
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|table
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|bfd_hash_entry
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|table
operator|->
name|table
index|[
name|i
index|]
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
call|(
modifier|*
name|func
call|)
argument_list|(
name|p
argument_list|,
name|info
argument_list|)
condition|)
return|return;
block|}
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* A few different object file formats (a.out, COFF, ELF) use a string    table.  These functions support adding strings to a string table,    returning the byte offset, and writing out the table.     Possible improvements:    + look for strings matching trailing substrings of other strings    + better data structures?  balanced trees?    + look at reducing memory use elsewhere -- maybe if we didn't have      to construct the entire symbol table at once, we could get by      with smaller amounts of VM?  (What effect does that have on the      string table reductions?)  */
end_comment

begin_comment
comment|/* An entry in the strtab hash table.  */
end_comment

begin_struct
struct|struct
name|strtab_hash_entry
block|{
name|struct
name|bfd_hash_entry
name|root
decl_stmt|;
comment|/* Index in string table.  */
name|bfd_size_type
name|index
decl_stmt|;
comment|/* Next string in strtab.  */
name|struct
name|strtab_hash_entry
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The strtab hash table.  */
end_comment

begin_struct
struct|struct
name|bfd_strtab_hash
block|{
name|struct
name|bfd_hash_table
name|table
decl_stmt|;
comment|/* Size of strtab--also next available index.  */
name|bfd_size_type
name|size
decl_stmt|;
comment|/* First string in strtab.  */
name|struct
name|strtab_hash_entry
modifier|*
name|first
decl_stmt|;
comment|/* Last string in strtab.  */
name|struct
name|strtab_hash_entry
modifier|*
name|last
decl_stmt|;
comment|/* Whether to precede strings with a two byte length, as in the      XCOFF .debug section.  */
name|bfd_boolean
name|xcoff
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|strtab_hash_newfunc
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|,
expr|struct
name|bfd_hash_table
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Routine to create an entry in a strtab.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|strtab_hash_newfunc
parameter_list|(
name|entry
parameter_list|,
name|table
parameter_list|,
name|string
parameter_list|)
name|struct
name|bfd_hash_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|bfd_hash_table
modifier|*
name|table
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|struct
name|strtab_hash_entry
modifier|*
name|ret
init|=
operator|(
expr|struct
name|strtab_hash_entry
operator|*
operator|)
name|entry
decl_stmt|;
comment|/* Allocate the structure if it has not already been allocated by a      subclass.  */
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|strtab_hash_entry
operator|*
operator|)
name|NULL
condition|)
name|ret
operator|=
operator|(
operator|(
expr|struct
name|strtab_hash_entry
operator|*
operator|)
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|strtab_hash_entry
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|strtab_hash_entry
operator|*
operator|)
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* Call the allocation method of the superclass.  */
name|ret
operator|=
operator|(
operator|(
expr|struct
name|strtab_hash_entry
operator|*
operator|)
name|bfd_hash_newfunc
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
comment|/* Initialize the local fields.  */
name|ret
operator|->
name|index
operator|=
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
expr_stmt|;
name|ret
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Look up an entry in an strtab.  */
end_comment

begin_define
define|#
directive|define
name|strtab_hash_lookup
parameter_list|(
name|t
parameter_list|,
name|string
parameter_list|,
name|create
parameter_list|,
name|copy
parameter_list|)
define|\
value|((struct strtab_hash_entry *) \    bfd_hash_lookup (&(t)->table, (string), (create), (copy)))
end_define

begin_comment
comment|/* Create a new strtab.  */
end_comment

begin_function
name|struct
name|bfd_strtab_hash
modifier|*
name|_bfd_stringtab_init
parameter_list|()
block|{
name|struct
name|bfd_strtab_hash
modifier|*
name|table
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|bfd_strtab_hash
argument_list|)
decl_stmt|;
name|table
operator|=
operator|(
expr|struct
name|bfd_strtab_hash
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|table
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|bfd_hash_table_init
argument_list|(
operator|&
name|table
operator|->
name|table
argument_list|,
name|strtab_hash_newfunc
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|table
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|table
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|table
operator|->
name|first
operator|=
name|NULL
expr_stmt|;
name|table
operator|->
name|last
operator|=
name|NULL
expr_stmt|;
name|table
operator|->
name|xcoff
operator|=
name|FALSE
expr_stmt|;
return|return
name|table
return|;
block|}
end_function

begin_comment
comment|/* Create a new strtab in which the strings are output in the format    used in the XCOFF .debug section: a two byte length precedes each    string.  */
end_comment

begin_function
name|struct
name|bfd_strtab_hash
modifier|*
name|_bfd_xcoff_stringtab_init
parameter_list|()
block|{
name|struct
name|bfd_strtab_hash
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
name|_bfd_stringtab_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|NULL
condition|)
name|ret
operator|->
name|xcoff
operator|=
name|TRUE
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Free a strtab.  */
end_comment

begin_function
name|void
name|_bfd_stringtab_free
parameter_list|(
name|table
parameter_list|)
name|struct
name|bfd_strtab_hash
modifier|*
name|table
decl_stmt|;
block|{
name|bfd_hash_table_free
argument_list|(
operator|&
name|table
operator|->
name|table
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|table
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get the index of a string in a strtab, adding it if it is not    already present.  If HASH is FALSE, we don't really use the hash    table, and we don't eliminate duplicate strings.  */
end_comment

begin_function
name|bfd_size_type
name|_bfd_stringtab_add
parameter_list|(
name|tab
parameter_list|,
name|str
parameter_list|,
name|hash
parameter_list|,
name|copy
parameter_list|)
name|struct
name|bfd_strtab_hash
modifier|*
name|tab
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|bfd_boolean
name|hash
decl_stmt|;
name|bfd_boolean
name|copy
decl_stmt|;
block|{
specifier|register
name|struct
name|strtab_hash_entry
modifier|*
name|entry
decl_stmt|;
if|if
condition|(
name|hash
condition|)
block|{
name|entry
operator|=
name|strtab_hash_lookup
argument_list|(
name|tab
argument_list|,
name|str
argument_list|,
name|TRUE
argument_list|,
name|copy
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
return|return
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
return|;
block|}
else|else
block|{
name|entry
operator|=
operator|(
operator|(
expr|struct
name|strtab_hash_entry
operator|*
operator|)
name|bfd_hash_allocate
argument_list|(
operator|&
name|tab
operator|->
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|strtab_hash_entry
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
return|return
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|copy
condition|)
name|entry
operator|->
name|root
operator|.
name|string
operator|=
name|str
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|n
decl_stmt|;
name|n
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_hash_allocate
argument_list|(
operator|&
name|tab
operator|->
name|table
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
return|;
name|entry
operator|->
name|root
operator|.
name|string
operator|=
name|n
expr_stmt|;
block|}
name|entry
operator|->
name|index
operator|=
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
expr_stmt|;
name|entry
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|entry
operator|->
name|index
operator|==
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
condition|)
block|{
name|entry
operator|->
name|index
operator|=
name|tab
operator|->
name|size
expr_stmt|;
name|tab
operator|->
name|size
operator|+=
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|tab
operator|->
name|xcoff
condition|)
block|{
name|entry
operator|->
name|index
operator|+=
literal|2
expr_stmt|;
name|tab
operator|->
name|size
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|tab
operator|->
name|first
operator|==
name|NULL
condition|)
name|tab
operator|->
name|first
operator|=
name|entry
expr_stmt|;
else|else
name|tab
operator|->
name|last
operator|->
name|next
operator|=
name|entry
expr_stmt|;
name|tab
operator|->
name|last
operator|=
name|entry
expr_stmt|;
block|}
return|return
name|entry
operator|->
name|index
return|;
block|}
end_function

begin_comment
comment|/* Get the number of bytes in a strtab.  */
end_comment

begin_function
name|bfd_size_type
name|_bfd_stringtab_size
parameter_list|(
name|tab
parameter_list|)
name|struct
name|bfd_strtab_hash
modifier|*
name|tab
decl_stmt|;
block|{
return|return
name|tab
operator|->
name|size
return|;
block|}
end_function

begin_comment
comment|/* Write out a strtab.  ABFD must already be at the right location in    the file.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_stringtab_emit
parameter_list|(
name|abfd
parameter_list|,
name|tab
parameter_list|)
specifier|register
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_strtab_hash
modifier|*
name|tab
decl_stmt|;
block|{
specifier|register
name|bfd_boolean
name|xcoff
decl_stmt|;
specifier|register
name|struct
name|strtab_hash_entry
modifier|*
name|entry
decl_stmt|;
name|xcoff
operator|=
name|tab
operator|->
name|xcoff
expr_stmt|;
for|for
control|(
name|entry
operator|=
name|tab
operator|->
name|first
init|;
name|entry
operator|!=
name|NULL
condition|;
name|entry
operator|=
name|entry
operator|->
name|next
control|)
block|{
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|str
operator|=
name|entry
operator|->
name|root
operator|.
name|string
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|xcoff
condition|)
block|{
name|bfd_byte
name|buf
index|[
literal|2
index|]
decl_stmt|;
comment|/* The output length includes the null byte.  */
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|len
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
operator|(
name|PTR
operator|)
name|buf
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|2
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|2
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|bfd_bwrite
argument_list|(
operator|(
name|PTR
operator|)
name|str
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|len
argument_list|,
name|abfd
argument_list|)
operator|!=
name|len
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

end_unit

