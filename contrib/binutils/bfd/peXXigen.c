begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Support for the generic parts of PE/PEI; the common executable parts.    Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002    Free Software Foundation, Inc.    Written by Cygnus Solutions.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Most of this hacked by Steve Chamberlain<sac@cygnus.com>.     PE/PEI rearrangement (and code added): Donn Terry 					  Softway Systems, Inc.  */
end_comment

begin_comment
comment|/* Hey look, some documentation [and in a place you expect to find it]!     The main reference for the pei format is "Microsoft Portable Executable    and Common Object File Format Specification 4.1".  Get it if you need to    do some serious hacking on this code.     Another reference:    "Peering Inside the PE: A Tour of the Win32 Portable Executable    File Format", MSJ 1994, Volume 9.     The *sole* difference between the pe format and the pei format is that the    latter has an MSDOS 2.0 .exe header on the front that prints the message    "This app must be run under Windows." (or some such).    (FIXME: Whether that statement is *really* true or not is unknown.    Are there more subtle differences between pe and pei formats?    For now assume there aren't.  If you find one, then for God sakes    document it here!)     The Microsoft docs use the word "image" instead of "executable" because    the former can also refer to a DLL (shared library).  Confusion can arise    because the `i' in `pei' also refers to "image".  The `pe' format can    also create images (i.e. executables), it's just that to run on a win32    system you need to use the pei format.     FIXME: Please add more docs here so the next poor fool that has to hack    on this code has a chance of getting something accomplished without    wasting too much time.  */
end_comment

begin_comment
comment|/* This expands into COFF_WITH_pe or COFF_WITH_pep depending on whether    we're compiling for straight PE or PE+.  */
end_comment

begin_define
define|#
directive|define
name|COFF_WITH_XX
end_define

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"coff/internal.h"
end_include

begin_comment
comment|/* NOTE: it's strange to be including an architecture specific header    in what's supposed to be general (to PE/PEI) code.  However, that's    where the definitions are, and they don't vary per architecture    within PE/PEI, so we get them from there.  FIXME: The lack of    variance is an assumption which may prove to be incorrect if new    PE/PEI targets are created.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|COFF_WITH_pep
end_ifdef

begin_include
include|#
directive|include
file|"coff/ia64.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"coff/i386.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"coff/pe.h"
end_include

begin_include
include|#
directive|include
file|"libcoff.h"
end_include

begin_include
include|#
directive|include
file|"libpei.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|COFF_WITH_pep
end_ifdef

begin_undef
undef|#
directive|undef
name|AOUTSZ
end_undef

begin_define
define|#
directive|define
name|AOUTSZ
value|PEPAOUTSZ
end_define

begin_define
define|#
directive|define
name|PEAOUTHDR
value|PEPAOUTHDR
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FIXME: This file has various tests of POWERPC_LE_PE.  Those tests    worked when the code was in peicode.h, but no longer work now that    the code is in peigen.c.  PowerPC NT is said to be dead.  If    anybody wants to revive the code, you will have to figure out how    to handle those issues.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|add_data_entry
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|internal_extra_pe_aouthdr
operator|*
operator|,
name|int
operator|,
name|char
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|pe_print_pdata
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|pe_print_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|pe_print_idata
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|pe_print_edata
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
name|void
name|_bfd_XXi_swap_sym_in
parameter_list|(
name|abfd
parameter_list|,
name|ext1
parameter_list|,
name|in1
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|ext1
decl_stmt|;
name|PTR
name|in1
decl_stmt|;
block|{
name|SYMENT
modifier|*
name|ext
init|=
operator|(
name|SYMENT
operator|*
operator|)
name|ext1
decl_stmt|;
name|struct
name|internal_syment
modifier|*
name|in
init|=
operator|(
expr|struct
name|internal_syment
operator|*
operator|)
name|in1
decl_stmt|;
if|if
condition|(
name|ext
operator|->
name|e
operator|.
name|e_name
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|in
operator|->
name|_n
operator|.
name|_n_n
operator|.
name|_n_zeroes
operator|=
literal|0
expr_stmt|;
name|in
operator|->
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|e
operator|.
name|e
operator|.
name|e_offset
argument_list|)
expr_stmt|;
block|}
else|else
name|memcpy
argument_list|(
name|in
operator|->
name|_n
operator|.
name|_n_name
argument_list|,
name|ext
operator|->
name|e
operator|.
name|e_name
argument_list|,
name|SYMNMLEN
argument_list|)
expr_stmt|;
name|in
operator|->
name|n_value
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|e_value
argument_list|)
expr_stmt|;
name|in
operator|->
name|n_scnum
operator|=
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|e_scnum
argument_list|)
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|ext
operator|->
name|e_type
argument_list|)
operator|==
literal|2
condition|)
name|in
operator|->
name|n_type
operator|=
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|e_type
argument_list|)
expr_stmt|;
else|else
name|in
operator|->
name|n_type
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|e_type
argument_list|)
expr_stmt|;
name|in
operator|->
name|n_sclass
operator|=
name|H_GET_8
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|e_sclass
argument_list|)
expr_stmt|;
name|in
operator|->
name|n_numaux
operator|=
name|H_GET_8
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|e_numaux
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|STRICT_PE_FORMAT
comment|/* This is for Gnu-created DLLs.  */
comment|/* The section symbols for the .idata$ sections have class 0x68      (C_SECTION), which MS documentation indicates is a section      symbol.  Unfortunately, the value field in the symbol is simply a      copy of the .idata section's flags rather than something useful.      When these symbols are encountered, change the value to 0 so that      they will be handled somewhat correctly in the bfd code.  */
if|if
condition|(
name|in
operator|->
name|n_sclass
operator|==
name|C_SECTION
condition|)
block|{
name|in
operator|->
name|n_value
operator|=
literal|0x0
expr_stmt|;
if|#
directive|if
literal|0
comment|/* FIXME: This is clearly wrong.  The problem seems to be that          undefined C_SECTION symbols appear in the first object of a          MS generated .lib file, and the symbols are not defined          anywhere.  */
block|in->n_scnum = 1;
comment|/* I have tried setting the class to 3 and using the following 	 to set the section number.  This will put the address of the 	 pointer to the string kernel32.dll at addresses 0 and 0x10 	 off start of idata section which is not correct.  */
if|#
directive|if
literal|0
block|if (strcmp (in->_n._n_name, ".idata$4") == 0) 	in->n_scnum = 3;       else 	in->n_scnum = 2;
endif|#
directive|endif
else|#
directive|else
comment|/* Create synthetic empty sections as needed.  DJ */
if|if
condition|(
name|in
operator|->
name|n_scnum
operator|==
literal|0
condition|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
for|for
control|(
name|sec
operator|=
name|abfd
operator|->
name|sections
init|;
name|sec
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
name|in
operator|->
name|n_name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|in
operator|->
name|n_scnum
operator|=
name|sec
operator|->
name|target_index
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|in
operator|->
name|n_scnum
operator|==
literal|0
condition|)
block|{
name|int
name|unused_section_number
init|=
literal|0
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
for|for
control|(
name|sec
operator|=
name|abfd
operator|->
name|sections
init|;
name|sec
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
if|if
condition|(
name|unused_section_number
operator|<=
name|sec
operator|->
name|target_index
condition|)
name|unused_section_number
operator|=
name|sec
operator|->
name|target_index
operator|+
literal|1
expr_stmt|;
name|name
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|strlen
argument_list|(
name|in
operator|->
name|n_name
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return;
name|strcpy
argument_list|(
name|name
argument_list|,
name|in
operator|->
name|n_name
argument_list|)
expr_stmt|;
name|sec
operator|=
name|bfd_make_section_anyway
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|sec
operator|->
name|vma
operator|=
literal|0
expr_stmt|;
name|sec
operator|->
name|lma
operator|=
literal|0
expr_stmt|;
name|sec
operator|->
name|_cooked_size
operator|=
literal|0
expr_stmt|;
name|sec
operator|->
name|_raw_size
operator|=
literal|0
expr_stmt|;
name|sec
operator|->
name|filepos
operator|=
literal|0
expr_stmt|;
name|sec
operator|->
name|rel_filepos
operator|=
literal|0
expr_stmt|;
name|sec
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
name|sec
operator|->
name|line_filepos
operator|=
literal|0
expr_stmt|;
name|sec
operator|->
name|lineno_count
operator|=
literal|0
expr_stmt|;
name|sec
operator|->
name|userdata
operator|=
name|NULL
expr_stmt|;
name|sec
operator|->
name|next
operator|=
operator|(
name|asection
operator|*
operator|)
name|NULL
expr_stmt|;
name|sec
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|sec
operator|->
name|alignment_power
operator|=
literal|2
expr_stmt|;
name|sec
operator|->
name|flags
operator|=
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_DATA
operator||
name|SEC_LOAD
expr_stmt|;
name|sec
operator|->
name|target_index
operator|=
name|unused_section_number
expr_stmt|;
name|in
operator|->
name|n_scnum
operator|=
name|unused_section_number
expr_stmt|;
block|}
name|in
operator|->
name|n_sclass
operator|=
name|C_STAT
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|coff_swap_sym_in_hook
comment|/* This won't work in peigen.c, but since it's for PPC PE, it's not      worth fixing.  */
name|coff_swap_sym_in_hook
argument_list|(
name|abfd
argument_list|,
name|ext1
argument_list|,
name|in1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|unsigned
name|int
name|_bfd_XXi_swap_sym_out
parameter_list|(
name|abfd
parameter_list|,
name|inp
parameter_list|,
name|extp
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|inp
decl_stmt|;
name|PTR
name|extp
decl_stmt|;
block|{
name|struct
name|internal_syment
modifier|*
name|in
init|=
operator|(
expr|struct
name|internal_syment
operator|*
operator|)
name|inp
decl_stmt|;
name|SYMENT
modifier|*
name|ext
init|=
operator|(
name|SYMENT
operator|*
operator|)
name|extp
decl_stmt|;
if|if
condition|(
name|in
operator|->
name|_n
operator|.
name|_n_name
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|,
name|ext
operator|->
name|e
operator|.
name|e
operator|.
name|e_zeroes
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
argument_list|,
name|ext
operator|->
name|e
operator|.
name|e
operator|.
name|e_offset
argument_list|)
expr_stmt|;
block|}
else|else
name|memcpy
argument_list|(
name|ext
operator|->
name|e
operator|.
name|e_name
argument_list|,
name|in
operator|->
name|_n
operator|.
name|_n_name
argument_list|,
name|SYMNMLEN
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|n_value
argument_list|,
name|ext
operator|->
name|e_value
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|n_scnum
argument_list|,
name|ext
operator|->
name|e_scnum
argument_list|)
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|ext
operator|->
name|e_type
argument_list|)
operator|==
literal|2
condition|)
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|n_type
argument_list|,
name|ext
operator|->
name|e_type
argument_list|)
expr_stmt|;
else|else
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|n_type
argument_list|,
name|ext
operator|->
name|e_type
argument_list|)
expr_stmt|;
name|H_PUT_8
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|n_sclass
argument_list|,
name|ext
operator|->
name|e_sclass
argument_list|)
expr_stmt|;
name|H_PUT_8
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|n_numaux
argument_list|,
name|ext
operator|->
name|e_numaux
argument_list|)
expr_stmt|;
return|return
name|SYMESZ
return|;
block|}
end_function

begin_function
name|void
name|_bfd_XXi_swap_aux_in
parameter_list|(
name|abfd
parameter_list|,
name|ext1
parameter_list|,
name|type
parameter_list|,
name|class
parameter_list|,
name|indx
parameter_list|,
name|numaux
parameter_list|,
name|in1
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|ext1
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|class
decl_stmt|;
name|int
name|indx
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|numaux
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|PTR
name|in1
decl_stmt|;
block|{
name|AUXENT
modifier|*
name|ext
init|=
operator|(
name|AUXENT
operator|*
operator|)
name|ext1
decl_stmt|;
name|union
name|internal_auxent
modifier|*
name|in
init|=
operator|(
expr|union
name|internal_auxent
operator|*
operator|)
name|in1
decl_stmt|;
switch|switch
condition|(
name|class
condition|)
block|{
case|case
name|C_FILE
case|:
if|if
condition|(
name|ext
operator|->
name|x_file
operator|.
name|x_fname
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|in
operator|->
name|x_file
operator|.
name|x_n
operator|.
name|x_zeroes
operator|=
literal|0
expr_stmt|;
name|in
operator|->
name|x_file
operator|.
name|x_n
operator|.
name|x_offset
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|x_file
operator|.
name|x_n
operator|.
name|x_offset
argument_list|)
expr_stmt|;
block|}
else|else
name|memcpy
argument_list|(
name|in
operator|->
name|x_file
operator|.
name|x_fname
argument_list|,
name|ext
operator|->
name|x_file
operator|.
name|x_fname
argument_list|,
name|FILNMLEN
argument_list|)
expr_stmt|;
return|return;
case|case
name|C_STAT
case|:
case|case
name|C_LEAFSTAT
case|:
case|case
name|C_HIDDEN
case|:
if|if
condition|(
name|type
operator|==
name|T_NULL
condition|)
block|{
name|in
operator|->
name|x_scn
operator|.
name|x_scnlen
operator|=
name|GET_SCN_SCNLEN
argument_list|(
name|abfd
argument_list|,
name|ext
argument_list|)
expr_stmt|;
name|in
operator|->
name|x_scn
operator|.
name|x_nreloc
operator|=
name|GET_SCN_NRELOC
argument_list|(
name|abfd
argument_list|,
name|ext
argument_list|)
expr_stmt|;
name|in
operator|->
name|x_scn
operator|.
name|x_nlinno
operator|=
name|GET_SCN_NLINNO
argument_list|(
name|abfd
argument_list|,
name|ext
argument_list|)
expr_stmt|;
name|in
operator|->
name|x_scn
operator|.
name|x_checksum
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|x_scn
operator|.
name|x_checksum
argument_list|)
expr_stmt|;
name|in
operator|->
name|x_scn
operator|.
name|x_associated
operator|=
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|x_scn
operator|.
name|x_associated
argument_list|)
expr_stmt|;
name|in
operator|->
name|x_scn
operator|.
name|x_comdat
operator|=
name|H_GET_8
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|x_scn
operator|.
name|x_comdat
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
block|}
name|in
operator|->
name|x_sym
operator|.
name|x_tagndx
operator|.
name|l
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|x_sym
operator|.
name|x_tagndx
argument_list|)
expr_stmt|;
name|in
operator|->
name|x_sym
operator|.
name|x_tvndx
operator|=
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|x_sym
operator|.
name|x_tvndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|==
name|C_BLOCK
operator|||
name|class
operator|==
name|C_FCN
operator|||
name|ISFCN
argument_list|(
name|type
argument_list|)
operator|||
name|ISTAG
argument_list|(
name|class
argument_list|)
condition|)
block|{
name|in
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_lnnoptr
operator|=
name|GET_FCN_LNNOPTR
argument_list|(
name|abfd
argument_list|,
name|ext
argument_list|)
expr_stmt|;
name|in
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_endndx
operator|.
name|l
operator|=
name|GET_FCN_ENDNDX
argument_list|(
name|abfd
argument_list|,
name|ext
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|in
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
index|[
literal|0
index|]
operator|=
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|in
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
index|[
literal|1
index|]
operator|=
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|in
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
index|[
literal|2
index|]
operator|=
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|in
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
index|[
literal|3
index|]
operator|=
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ISFCN
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|in
operator|->
name|x_sym
operator|.
name|x_misc
operator|.
name|x_fsize
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|x_sym
operator|.
name|x_misc
operator|.
name|x_fsize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|in
operator|->
name|x_sym
operator|.
name|x_misc
operator|.
name|x_lnsz
operator|.
name|x_lnno
operator|=
name|GET_LNSZ_LNNO
argument_list|(
name|abfd
argument_list|,
name|ext
argument_list|)
expr_stmt|;
name|in
operator|->
name|x_sym
operator|.
name|x_misc
operator|.
name|x_lnsz
operator|.
name|x_size
operator|=
name|GET_LNSZ_SIZE
argument_list|(
name|abfd
argument_list|,
name|ext
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|unsigned
name|int
name|_bfd_XXi_swap_aux_out
parameter_list|(
name|abfd
parameter_list|,
name|inp
parameter_list|,
name|type
parameter_list|,
name|class
parameter_list|,
name|indx
parameter_list|,
name|numaux
parameter_list|,
name|extp
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|inp
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|class
decl_stmt|;
name|int
name|indx
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|numaux
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|PTR
name|extp
decl_stmt|;
block|{
name|union
name|internal_auxent
modifier|*
name|in
init|=
operator|(
expr|union
name|internal_auxent
operator|*
operator|)
name|inp
decl_stmt|;
name|AUXENT
modifier|*
name|ext
init|=
operator|(
name|AUXENT
operator|*
operator|)
name|extp
decl_stmt|;
name|memset
argument_list|(
operator|(
name|PTR
operator|)
name|ext
argument_list|,
literal|0
argument_list|,
name|AUXESZ
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|class
condition|)
block|{
case|case
name|C_FILE
case|:
if|if
condition|(
name|in
operator|->
name|x_file
operator|.
name|x_fname
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|,
name|ext
operator|->
name|x_file
operator|.
name|x_n
operator|.
name|x_zeroes
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_file
operator|.
name|x_n
operator|.
name|x_offset
argument_list|,
name|ext
operator|->
name|x_file
operator|.
name|x_n
operator|.
name|x_offset
argument_list|)
expr_stmt|;
block|}
else|else
name|memcpy
argument_list|(
name|ext
operator|->
name|x_file
operator|.
name|x_fname
argument_list|,
name|in
operator|->
name|x_file
operator|.
name|x_fname
argument_list|,
name|FILNMLEN
argument_list|)
expr_stmt|;
return|return
name|AUXESZ
return|;
case|case
name|C_STAT
case|:
case|case
name|C_LEAFSTAT
case|:
case|case
name|C_HIDDEN
case|:
if|if
condition|(
name|type
operator|==
name|T_NULL
condition|)
block|{
name|PUT_SCN_SCNLEN
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_scn
operator|.
name|x_scnlen
argument_list|,
name|ext
argument_list|)
expr_stmt|;
name|PUT_SCN_NRELOC
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_scn
operator|.
name|x_nreloc
argument_list|,
name|ext
argument_list|)
expr_stmt|;
name|PUT_SCN_NLINNO
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_scn
operator|.
name|x_nlinno
argument_list|,
name|ext
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_scn
operator|.
name|x_checksum
argument_list|,
name|ext
operator|->
name|x_scn
operator|.
name|x_checksum
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_scn
operator|.
name|x_associated
argument_list|,
name|ext
operator|->
name|x_scn
operator|.
name|x_associated
argument_list|)
expr_stmt|;
name|H_PUT_8
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_scn
operator|.
name|x_comdat
argument_list|,
name|ext
operator|->
name|x_scn
operator|.
name|x_comdat
argument_list|)
expr_stmt|;
return|return
name|AUXESZ
return|;
block|}
break|break;
block|}
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_sym
operator|.
name|x_tagndx
operator|.
name|l
argument_list|,
name|ext
operator|->
name|x_sym
operator|.
name|x_tagndx
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_sym
operator|.
name|x_tvndx
argument_list|,
name|ext
operator|->
name|x_sym
operator|.
name|x_tvndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|==
name|C_BLOCK
operator|||
name|class
operator|==
name|C_FCN
operator|||
name|ISFCN
argument_list|(
name|type
argument_list|)
operator|||
name|ISTAG
argument_list|(
name|class
argument_list|)
condition|)
block|{
name|PUT_FCN_LNNOPTR
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_lnnoptr
argument_list|,
name|ext
argument_list|)
expr_stmt|;
name|PUT_FCN_ENDNDX
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_endndx
operator|.
name|l
argument_list|,
name|ext
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
index|[
literal|0
index|]
argument_list|,
name|ext
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
index|[
literal|1
index|]
argument_list|,
name|ext
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
index|[
literal|2
index|]
argument_list|,
name|ext
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
index|[
literal|3
index|]
argument_list|,
name|ext
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ISFCN
argument_list|(
name|type
argument_list|)
condition|)
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_sym
operator|.
name|x_misc
operator|.
name|x_fsize
argument_list|,
name|ext
operator|->
name|x_sym
operator|.
name|x_misc
operator|.
name|x_fsize
argument_list|)
expr_stmt|;
else|else
block|{
name|PUT_LNSZ_LNNO
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_sym
operator|.
name|x_misc
operator|.
name|x_lnsz
operator|.
name|x_lnno
argument_list|,
name|ext
argument_list|)
expr_stmt|;
name|PUT_LNSZ_SIZE
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_sym
operator|.
name|x_misc
operator|.
name|x_lnsz
operator|.
name|x_size
argument_list|,
name|ext
argument_list|)
expr_stmt|;
block|}
return|return
name|AUXESZ
return|;
block|}
end_function

begin_function
name|void
name|_bfd_XXi_swap_lineno_in
parameter_list|(
name|abfd
parameter_list|,
name|ext1
parameter_list|,
name|in1
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|ext1
decl_stmt|;
name|PTR
name|in1
decl_stmt|;
block|{
name|LINENO
modifier|*
name|ext
init|=
operator|(
name|LINENO
operator|*
operator|)
name|ext1
decl_stmt|;
name|struct
name|internal_lineno
modifier|*
name|in
init|=
operator|(
expr|struct
name|internal_lineno
operator|*
operator|)
name|in1
decl_stmt|;
name|in
operator|->
name|l_addr
operator|.
name|l_symndx
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|l_addr
operator|.
name|l_symndx
argument_list|)
expr_stmt|;
name|in
operator|->
name|l_lnno
operator|=
name|GET_LINENO_LNNO
argument_list|(
name|abfd
argument_list|,
name|ext
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|unsigned
name|int
name|_bfd_XXi_swap_lineno_out
parameter_list|(
name|abfd
parameter_list|,
name|inp
parameter_list|,
name|outp
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|inp
decl_stmt|;
name|PTR
name|outp
decl_stmt|;
block|{
name|struct
name|internal_lineno
modifier|*
name|in
init|=
operator|(
expr|struct
name|internal_lineno
operator|*
operator|)
name|inp
decl_stmt|;
name|struct
name|external_lineno
modifier|*
name|ext
init|=
operator|(
expr|struct
name|external_lineno
operator|*
operator|)
name|outp
decl_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|l_addr
operator|.
name|l_symndx
argument_list|,
name|ext
operator|->
name|l_addr
operator|.
name|l_symndx
argument_list|)
expr_stmt|;
name|PUT_LINENO_LNNO
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|l_lnno
argument_list|,
name|ext
argument_list|)
expr_stmt|;
return|return
name|LINESZ
return|;
block|}
end_function

begin_function
name|void
name|_bfd_XXi_swap_aouthdr_in
parameter_list|(
name|abfd
parameter_list|,
name|aouthdr_ext1
parameter_list|,
name|aouthdr_int1
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|aouthdr_ext1
decl_stmt|;
name|PTR
name|aouthdr_int1
decl_stmt|;
block|{
name|struct
name|internal_extra_pe_aouthdr
modifier|*
name|a
decl_stmt|;
name|PEAOUTHDR
modifier|*
name|src
init|=
operator|(
name|PEAOUTHDR
operator|*
operator|)
operator|(
name|aouthdr_ext1
operator|)
decl_stmt|;
name|AOUTHDR
modifier|*
name|aouthdr_ext
init|=
operator|(
name|AOUTHDR
operator|*
operator|)
name|aouthdr_ext1
decl_stmt|;
name|struct
name|internal_aouthdr
modifier|*
name|aouthdr_int
init|=
operator|(
expr|struct
name|internal_aouthdr
operator|*
operator|)
name|aouthdr_int1
decl_stmt|;
name|aouthdr_int
operator|->
name|magic
operator|=
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|aouthdr_ext
operator|->
name|magic
argument_list|)
expr_stmt|;
name|aouthdr_int
operator|->
name|vstamp
operator|=
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|aouthdr_ext
operator|->
name|vstamp
argument_list|)
expr_stmt|;
name|aouthdr_int
operator|->
name|tsize
operator|=
name|GET_AOUTHDR_TSIZE
argument_list|(
name|abfd
argument_list|,
name|aouthdr_ext
operator|->
name|tsize
argument_list|)
expr_stmt|;
name|aouthdr_int
operator|->
name|dsize
operator|=
name|GET_AOUTHDR_DSIZE
argument_list|(
name|abfd
argument_list|,
name|aouthdr_ext
operator|->
name|dsize
argument_list|)
expr_stmt|;
name|aouthdr_int
operator|->
name|bsize
operator|=
name|GET_AOUTHDR_BSIZE
argument_list|(
name|abfd
argument_list|,
name|aouthdr_ext
operator|->
name|bsize
argument_list|)
expr_stmt|;
name|aouthdr_int
operator|->
name|entry
operator|=
name|GET_AOUTHDR_ENTRY
argument_list|(
name|abfd
argument_list|,
name|aouthdr_ext
operator|->
name|entry
argument_list|)
expr_stmt|;
name|aouthdr_int
operator|->
name|text_start
operator|=
name|GET_AOUTHDR_TEXT_START
argument_list|(
name|abfd
argument_list|,
name|aouthdr_ext
operator|->
name|text_start
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|COFF_WITH_pep
comment|/* PE32+ does not have data_start member! */
name|aouthdr_int
operator|->
name|data_start
operator|=
name|GET_AOUTHDR_DATA_START
argument_list|(
name|abfd
argument_list|,
name|aouthdr_ext
operator|->
name|data_start
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|a
operator|=
operator|&
name|aouthdr_int
operator|->
name|pe
expr_stmt|;
name|a
operator|->
name|ImageBase
operator|=
name|GET_OPTHDR_IMAGE_BASE
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|ImageBase
argument_list|)
expr_stmt|;
name|a
operator|->
name|SectionAlignment
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|SectionAlignment
argument_list|)
expr_stmt|;
name|a
operator|->
name|FileAlignment
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|FileAlignment
argument_list|)
expr_stmt|;
name|a
operator|->
name|MajorOperatingSystemVersion
operator|=
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|MajorOperatingSystemVersion
argument_list|)
expr_stmt|;
name|a
operator|->
name|MinorOperatingSystemVersion
operator|=
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|MinorOperatingSystemVersion
argument_list|)
expr_stmt|;
name|a
operator|->
name|MajorImageVersion
operator|=
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|MajorImageVersion
argument_list|)
expr_stmt|;
name|a
operator|->
name|MinorImageVersion
operator|=
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|MinorImageVersion
argument_list|)
expr_stmt|;
name|a
operator|->
name|MajorSubsystemVersion
operator|=
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|MajorSubsystemVersion
argument_list|)
expr_stmt|;
name|a
operator|->
name|MinorSubsystemVersion
operator|=
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|MinorSubsystemVersion
argument_list|)
expr_stmt|;
name|a
operator|->
name|Reserved1
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|Reserved1
argument_list|)
expr_stmt|;
name|a
operator|->
name|SizeOfImage
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|SizeOfImage
argument_list|)
expr_stmt|;
name|a
operator|->
name|SizeOfHeaders
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|SizeOfHeaders
argument_list|)
expr_stmt|;
name|a
operator|->
name|CheckSum
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|CheckSum
argument_list|)
expr_stmt|;
name|a
operator|->
name|Subsystem
operator|=
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|Subsystem
argument_list|)
expr_stmt|;
name|a
operator|->
name|DllCharacteristics
operator|=
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|DllCharacteristics
argument_list|)
expr_stmt|;
name|a
operator|->
name|SizeOfStackReserve
operator|=
name|GET_OPTHDR_SIZE_OF_STACK_RESERVE
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|SizeOfStackReserve
argument_list|)
expr_stmt|;
name|a
operator|->
name|SizeOfStackCommit
operator|=
name|GET_OPTHDR_SIZE_OF_STACK_COMMIT
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|SizeOfStackCommit
argument_list|)
expr_stmt|;
name|a
operator|->
name|SizeOfHeapReserve
operator|=
name|GET_OPTHDR_SIZE_OF_HEAP_RESERVE
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|SizeOfHeapReserve
argument_list|)
expr_stmt|;
name|a
operator|->
name|SizeOfHeapCommit
operator|=
name|GET_OPTHDR_SIZE_OF_HEAP_COMMIT
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|SizeOfHeapCommit
argument_list|)
expr_stmt|;
name|a
operator|->
name|LoaderFlags
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|LoaderFlags
argument_list|)
expr_stmt|;
name|a
operator|->
name|NumberOfRvaAndSizes
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|NumberOfRvaAndSizes
argument_list|)
expr_stmt|;
block|{
name|int
name|idx
decl_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
literal|16
condition|;
name|idx
operator|++
control|)
block|{
comment|/* If data directory is empty, rva also should be 0.  */
name|int
name|size
init|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|DataDirectory
index|[
name|idx
index|]
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|a
operator|->
name|DataDirectory
index|[
name|idx
index|]
operator|.
name|Size
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|size
condition|)
name|a
operator|->
name|DataDirectory
index|[
name|idx
index|]
operator|.
name|VirtualAddress
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|DataDirectory
index|[
name|idx
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
else|else
name|a
operator|->
name|DataDirectory
index|[
name|idx
index|]
operator|.
name|VirtualAddress
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|aouthdr_int
operator|->
name|entry
condition|)
block|{
name|aouthdr_int
operator|->
name|entry
operator|+=
name|a
operator|->
name|ImageBase
expr_stmt|;
ifndef|#
directive|ifndef
name|COFF_WITH_pep
name|aouthdr_int
operator|->
name|entry
operator|&=
literal|0xffffffff
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|aouthdr_int
operator|->
name|tsize
condition|)
block|{
name|aouthdr_int
operator|->
name|text_start
operator|+=
name|a
operator|->
name|ImageBase
expr_stmt|;
ifndef|#
directive|ifndef
name|COFF_WITH_pep
name|aouthdr_int
operator|->
name|text_start
operator|&=
literal|0xffffffff
expr_stmt|;
endif|#
directive|endif
block|}
ifndef|#
directive|ifndef
name|COFF_WITH_pep
comment|/* PE32+ does not have data_start member! */
if|if
condition|(
name|aouthdr_int
operator|->
name|dsize
condition|)
block|{
name|aouthdr_int
operator|->
name|data_start
operator|+=
name|a
operator|->
name|ImageBase
expr_stmt|;
name|aouthdr_int
operator|->
name|data_start
operator|&=
literal|0xffffffff
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|POWERPC_LE_PE
comment|/* These three fields are normally set up by ppc_relocate_section.      In the case of reading a file in, we can pick them up from the      DataDirectory.  */
name|first_thunk_address
operator|=
name|a
operator|->
name|DataDirectory
index|[
literal|12
index|]
operator|.
name|VirtualAddress
expr_stmt|;
name|thunk_size
operator|=
name|a
operator|->
name|DataDirectory
index|[
literal|12
index|]
operator|.
name|Size
expr_stmt|;
name|import_table_size
operator|=
name|a
operator|->
name|DataDirectory
index|[
literal|1
index|]
operator|.
name|Size
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* A support function for below.  */
end_comment

begin_function
specifier|static
name|void
name|add_data_entry
parameter_list|(
name|abfd
parameter_list|,
name|aout
parameter_list|,
name|idx
parameter_list|,
name|name
parameter_list|,
name|base
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|internal_extra_pe_aouthdr
modifier|*
name|aout
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|bfd_vma
name|base
decl_stmt|;
block|{
name|asection
modifier|*
name|sec
init|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
decl_stmt|;
comment|/* Add import directory information if it exists.  */
if|if
condition|(
operator|(
name|sec
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|pei_section_data
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|!=
name|NULL
operator|)
condition|)
block|{
comment|/* If data directory is empty, rva also should be 0.  */
name|int
name|size
init|=
name|pei_section_data
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|->
name|virt_size
decl_stmt|;
name|aout
operator|->
name|DataDirectory
index|[
name|idx
index|]
operator|.
name|Size
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|size
condition|)
block|{
name|aout
operator|->
name|DataDirectory
index|[
name|idx
index|]
operator|.
name|VirtualAddress
operator|=
operator|(
name|sec
operator|->
name|vma
operator|-
name|base
operator|)
operator|&
literal|0xffffffff
expr_stmt|;
name|sec
operator|->
name|flags
operator||=
name|SEC_DATA
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|unsigned
name|int
name|_bfd_XXi_swap_aouthdr_out
parameter_list|(
name|abfd
parameter_list|,
name|in
parameter_list|,
name|out
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|in
decl_stmt|;
name|PTR
name|out
decl_stmt|;
block|{
name|struct
name|internal_aouthdr
modifier|*
name|aouthdr_in
init|=
operator|(
expr|struct
name|internal_aouthdr
operator|*
operator|)
name|in
decl_stmt|;
name|pe_data_type
modifier|*
name|pe
init|=
name|pe_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|struct
name|internal_extra_pe_aouthdr
modifier|*
name|extra
init|=
operator|&
name|pe
operator|->
name|pe_opthdr
decl_stmt|;
name|PEAOUTHDR
modifier|*
name|aouthdr_out
init|=
operator|(
name|PEAOUTHDR
operator|*
operator|)
name|out
decl_stmt|;
name|bfd_vma
name|sa
decl_stmt|,
name|fa
decl_stmt|,
name|ib
decl_stmt|;
if|if
condition|(
name|pe
operator|->
name|force_minimum_alignment
condition|)
block|{
if|if
condition|(
operator|!
name|extra
operator|->
name|FileAlignment
condition|)
name|extra
operator|->
name|FileAlignment
operator|=
name|PE_DEF_FILE_ALIGNMENT
expr_stmt|;
if|if
condition|(
operator|!
name|extra
operator|->
name|SectionAlignment
condition|)
name|extra
operator|->
name|SectionAlignment
operator|=
name|PE_DEF_SECTION_ALIGNMENT
expr_stmt|;
block|}
if|if
condition|(
name|extra
operator|->
name|Subsystem
operator|==
name|IMAGE_SUBSYSTEM_UNKNOWN
condition|)
name|extra
operator|->
name|Subsystem
operator|=
name|pe
operator|->
name|target_subsystem
expr_stmt|;
name|sa
operator|=
name|extra
operator|->
name|SectionAlignment
expr_stmt|;
name|fa
operator|=
name|extra
operator|->
name|FileAlignment
expr_stmt|;
name|ib
operator|=
name|extra
operator|->
name|ImageBase
expr_stmt|;
if|if
condition|(
name|aouthdr_in
operator|->
name|tsize
condition|)
block|{
name|aouthdr_in
operator|->
name|text_start
operator|-=
name|ib
expr_stmt|;
ifndef|#
directive|ifndef
name|COFF_WITH_pep
name|aouthdr_in
operator|->
name|text_start
operator|&=
literal|0xffffffff
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|aouthdr_in
operator|->
name|dsize
condition|)
block|{
name|aouthdr_in
operator|->
name|data_start
operator|-=
name|ib
expr_stmt|;
ifndef|#
directive|ifndef
name|COFF_WITH_pep
name|aouthdr_in
operator|->
name|data_start
operator|&=
literal|0xffffffff
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|aouthdr_in
operator|->
name|entry
condition|)
block|{
name|aouthdr_in
operator|->
name|entry
operator|-=
name|ib
expr_stmt|;
ifndef|#
directive|ifndef
name|COFF_WITH_pep
name|aouthdr_in
operator|->
name|entry
operator|&=
literal|0xffffffff
expr_stmt|;
endif|#
directive|endif
block|}
define|#
directive|define
name|FA
parameter_list|(
name|x
parameter_list|)
value|(((x) + fa -1 )& (- fa))
define|#
directive|define
name|SA
parameter_list|(
name|x
parameter_list|)
value|(((x) + sa -1 )& (- sa))
comment|/* We like to have the sizes aligned.  */
name|aouthdr_in
operator|->
name|bsize
operator|=
name|FA
argument_list|(
name|aouthdr_in
operator|->
name|bsize
argument_list|)
expr_stmt|;
name|extra
operator|->
name|NumberOfRvaAndSizes
operator|=
name|IMAGE_NUMBEROF_DIRECTORY_ENTRIES
expr_stmt|;
comment|/* first null out all data directory entries ..  */
name|memset
argument_list|(
name|extra
operator|->
name|DataDirectory
argument_list|,
sizeof|sizeof
argument_list|(
name|extra
operator|->
name|DataDirectory
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_data_entry
argument_list|(
name|abfd
argument_list|,
name|extra
argument_list|,
literal|0
argument_list|,
literal|".edata"
argument_list|,
name|ib
argument_list|)
expr_stmt|;
comment|/* Don't call add_data_entry for .idata$2 or .idata$5.  It's done in      bfd_coff_final_link where all the required information is      available.  */
comment|/* However, until other .idata fixes are made (pending patch), the      entry for .idata is needed for backwards compatability.  FIXME.  */
name|add_data_entry
argument_list|(
name|abfd
argument_list|,
name|extra
argument_list|,
literal|1
argument_list|,
literal|".idata"
argument_list|,
name|ib
argument_list|)
expr_stmt|;
name|add_data_entry
argument_list|(
name|abfd
argument_list|,
name|extra
argument_list|,
literal|2
argument_list|,
literal|".rsrc"
argument_list|,
name|ib
argument_list|)
expr_stmt|;
name|add_data_entry
argument_list|(
name|abfd
argument_list|,
name|extra
argument_list|,
literal|3
argument_list|,
literal|".pdata"
argument_list|,
name|ib
argument_list|)
expr_stmt|;
comment|/* For some reason, the virtual size (which is what's set by      add_data_entry) for .reloc is not the same as the size recorded      in this slot by MSVC; it doesn't seem to cause problems (so far),      but since it's the best we've got, use it.  It does do the right      thing for .pdata.  */
if|if
condition|(
name|pe
operator|->
name|has_reloc_section
condition|)
name|add_data_entry
argument_list|(
name|abfd
argument_list|,
name|extra
argument_list|,
literal|5
argument_list|,
literal|".reloc"
argument_list|,
name|ib
argument_list|)
expr_stmt|;
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_vma
name|dsize
init|=
literal|0
decl_stmt|;
name|bfd_vma
name|isize
init|=
name|SA
argument_list|(
name|abfd
operator|->
name|sections
operator|->
name|filepos
argument_list|)
decl_stmt|;
name|bfd_vma
name|tsize
init|=
literal|0
decl_stmt|;
for|for
control|(
name|sec
operator|=
name|abfd
operator|->
name|sections
init|;
name|sec
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
block|{
name|int
name|rounded
init|=
name|FA
argument_list|(
name|sec
operator|->
name|_raw_size
argument_list|)
decl_stmt|;
if|if
condition|(
name|sec
operator|->
name|flags
operator|&
name|SEC_DATA
condition|)
name|dsize
operator|+=
name|rounded
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|flags
operator|&
name|SEC_CODE
condition|)
name|tsize
operator|+=
name|rounded
expr_stmt|;
comment|/* The image size is the total VIRTUAL size (which is what is 	   in the virt_size field).  Files have been seen (from MSVC 	   5.0 link.exe) where the file size of the .data segment is 	   quite small compared to the virtual size.  Without this 	   fix, strip munges the file.  */
name|isize
operator|+=
name|SA
argument_list|(
name|FA
argument_list|(
name|pei_section_data
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|->
name|virt_size
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|aouthdr_in
operator|->
name|dsize
operator|=
name|dsize
expr_stmt|;
name|aouthdr_in
operator|->
name|tsize
operator|=
name|tsize
expr_stmt|;
name|extra
operator|->
name|SizeOfImage
operator|=
name|isize
expr_stmt|;
block|}
name|extra
operator|->
name|SizeOfHeaders
operator|=
name|abfd
operator|->
name|sections
operator|->
name|filepos
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|aouthdr_in
operator|->
name|magic
argument_list|,
name|aouthdr_out
operator|->
name|standard
operator|.
name|magic
argument_list|)
expr_stmt|;
define|#
directive|define
name|LINKER_VERSION
value|256
comment|/* That is, 2.56 */
comment|/* This piece of magic sets the "linker version" field to      LINKER_VERSION.  */
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|LINKER_VERSION
operator|/
literal|100
operator|+
operator|(
name|LINKER_VERSION
operator|%
literal|100
operator|)
operator|*
literal|256
operator|)
argument_list|,
name|aouthdr_out
operator|->
name|standard
operator|.
name|vstamp
argument_list|)
expr_stmt|;
name|PUT_AOUTHDR_TSIZE
argument_list|(
name|abfd
argument_list|,
name|aouthdr_in
operator|->
name|tsize
argument_list|,
name|aouthdr_out
operator|->
name|standard
operator|.
name|tsize
argument_list|)
expr_stmt|;
name|PUT_AOUTHDR_DSIZE
argument_list|(
name|abfd
argument_list|,
name|aouthdr_in
operator|->
name|dsize
argument_list|,
name|aouthdr_out
operator|->
name|standard
operator|.
name|dsize
argument_list|)
expr_stmt|;
name|PUT_AOUTHDR_BSIZE
argument_list|(
name|abfd
argument_list|,
name|aouthdr_in
operator|->
name|bsize
argument_list|,
name|aouthdr_out
operator|->
name|standard
operator|.
name|bsize
argument_list|)
expr_stmt|;
name|PUT_AOUTHDR_ENTRY
argument_list|(
name|abfd
argument_list|,
name|aouthdr_in
operator|->
name|entry
argument_list|,
name|aouthdr_out
operator|->
name|standard
operator|.
name|entry
argument_list|)
expr_stmt|;
name|PUT_AOUTHDR_TEXT_START
argument_list|(
name|abfd
argument_list|,
name|aouthdr_in
operator|->
name|text_start
argument_list|,
name|aouthdr_out
operator|->
name|standard
operator|.
name|text_start
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|COFF_WITH_pep
comment|/* PE32+ does not have data_start member! */
name|PUT_AOUTHDR_DATA_START
argument_list|(
name|abfd
argument_list|,
name|aouthdr_in
operator|->
name|data_start
argument_list|,
name|aouthdr_out
operator|->
name|standard
operator|.
name|data_start
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PUT_OPTHDR_IMAGE_BASE
argument_list|(
name|abfd
argument_list|,
name|extra
operator|->
name|ImageBase
argument_list|,
name|aouthdr_out
operator|->
name|ImageBase
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|extra
operator|->
name|SectionAlignment
argument_list|,
name|aouthdr_out
operator|->
name|SectionAlignment
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|extra
operator|->
name|FileAlignment
argument_list|,
name|aouthdr_out
operator|->
name|FileAlignment
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|extra
operator|->
name|MajorOperatingSystemVersion
argument_list|,
name|aouthdr_out
operator|->
name|MajorOperatingSystemVersion
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|extra
operator|->
name|MinorOperatingSystemVersion
argument_list|,
name|aouthdr_out
operator|->
name|MinorOperatingSystemVersion
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|extra
operator|->
name|MajorImageVersion
argument_list|,
name|aouthdr_out
operator|->
name|MajorImageVersion
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|extra
operator|->
name|MinorImageVersion
argument_list|,
name|aouthdr_out
operator|->
name|MinorImageVersion
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|extra
operator|->
name|MajorSubsystemVersion
argument_list|,
name|aouthdr_out
operator|->
name|MajorSubsystemVersion
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|extra
operator|->
name|MinorSubsystemVersion
argument_list|,
name|aouthdr_out
operator|->
name|MinorSubsystemVersion
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|extra
operator|->
name|Reserved1
argument_list|,
name|aouthdr_out
operator|->
name|Reserved1
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|extra
operator|->
name|SizeOfImage
argument_list|,
name|aouthdr_out
operator|->
name|SizeOfImage
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|extra
operator|->
name|SizeOfHeaders
argument_list|,
name|aouthdr_out
operator|->
name|SizeOfHeaders
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|extra
operator|->
name|CheckSum
argument_list|,
name|aouthdr_out
operator|->
name|CheckSum
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|extra
operator|->
name|Subsystem
argument_list|,
name|aouthdr_out
operator|->
name|Subsystem
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|extra
operator|->
name|DllCharacteristics
argument_list|,
name|aouthdr_out
operator|->
name|DllCharacteristics
argument_list|)
expr_stmt|;
name|PUT_OPTHDR_SIZE_OF_STACK_RESERVE
argument_list|(
name|abfd
argument_list|,
name|extra
operator|->
name|SizeOfStackReserve
argument_list|,
name|aouthdr_out
operator|->
name|SizeOfStackReserve
argument_list|)
expr_stmt|;
name|PUT_OPTHDR_SIZE_OF_STACK_COMMIT
argument_list|(
name|abfd
argument_list|,
name|extra
operator|->
name|SizeOfStackCommit
argument_list|,
name|aouthdr_out
operator|->
name|SizeOfStackCommit
argument_list|)
expr_stmt|;
name|PUT_OPTHDR_SIZE_OF_HEAP_RESERVE
argument_list|(
name|abfd
argument_list|,
name|extra
operator|->
name|SizeOfHeapReserve
argument_list|,
name|aouthdr_out
operator|->
name|SizeOfHeapReserve
argument_list|)
expr_stmt|;
name|PUT_OPTHDR_SIZE_OF_HEAP_COMMIT
argument_list|(
name|abfd
argument_list|,
name|extra
operator|->
name|SizeOfHeapCommit
argument_list|,
name|aouthdr_out
operator|->
name|SizeOfHeapCommit
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|extra
operator|->
name|LoaderFlags
argument_list|,
name|aouthdr_out
operator|->
name|LoaderFlags
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|extra
operator|->
name|NumberOfRvaAndSizes
argument_list|,
name|aouthdr_out
operator|->
name|NumberOfRvaAndSizes
argument_list|)
expr_stmt|;
block|{
name|int
name|idx
decl_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
literal|16
condition|;
name|idx
operator|++
control|)
block|{
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|extra
operator|->
name|DataDirectory
index|[
name|idx
index|]
operator|.
name|VirtualAddress
argument_list|,
name|aouthdr_out
operator|->
name|DataDirectory
index|[
name|idx
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|extra
operator|->
name|DataDirectory
index|[
name|idx
index|]
operator|.
name|Size
argument_list|,
name|aouthdr_out
operator|->
name|DataDirectory
index|[
name|idx
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|AOUTSZ
return|;
block|}
end_function

begin_function
name|unsigned
name|int
name|_bfd_XXi_only_swap_filehdr_out
parameter_list|(
name|abfd
parameter_list|,
name|in
parameter_list|,
name|out
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|in
decl_stmt|;
name|PTR
name|out
decl_stmt|;
block|{
name|int
name|idx
decl_stmt|;
name|struct
name|internal_filehdr
modifier|*
name|filehdr_in
init|=
operator|(
expr|struct
name|internal_filehdr
operator|*
operator|)
name|in
decl_stmt|;
name|struct
name|external_PEI_filehdr
modifier|*
name|filehdr_out
init|=
operator|(
expr|struct
name|external_PEI_filehdr
operator|*
operator|)
name|out
decl_stmt|;
if|if
condition|(
name|pe_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|has_reloc_section
condition|)
name|filehdr_in
operator|->
name|f_flags
operator|&=
operator|~
name|F_RELFLG
expr_stmt|;
if|if
condition|(
name|pe_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|dll
condition|)
name|filehdr_in
operator|->
name|f_flags
operator||=
name|F_DLL
expr_stmt|;
name|filehdr_in
operator|->
name|pe
operator|.
name|e_magic
operator|=
name|DOSMAGIC
expr_stmt|;
name|filehdr_in
operator|->
name|pe
operator|.
name|e_cblp
operator|=
literal|0x90
expr_stmt|;
name|filehdr_in
operator|->
name|pe
operator|.
name|e_cp
operator|=
literal|0x3
expr_stmt|;
name|filehdr_in
operator|->
name|pe
operator|.
name|e_crlc
operator|=
literal|0x0
expr_stmt|;
name|filehdr_in
operator|->
name|pe
operator|.
name|e_cparhdr
operator|=
literal|0x4
expr_stmt|;
name|filehdr_in
operator|->
name|pe
operator|.
name|e_minalloc
operator|=
literal|0x0
expr_stmt|;
name|filehdr_in
operator|->
name|pe
operator|.
name|e_maxalloc
operator|=
literal|0xffff
expr_stmt|;
name|filehdr_in
operator|->
name|pe
operator|.
name|e_ss
operator|=
literal|0x0
expr_stmt|;
name|filehdr_in
operator|->
name|pe
operator|.
name|e_sp
operator|=
literal|0xb8
expr_stmt|;
name|filehdr_in
operator|->
name|pe
operator|.
name|e_csum
operator|=
literal|0x0
expr_stmt|;
name|filehdr_in
operator|->
name|pe
operator|.
name|e_ip
operator|=
literal|0x0
expr_stmt|;
name|filehdr_in
operator|->
name|pe
operator|.
name|e_cs
operator|=
literal|0x0
expr_stmt|;
name|filehdr_in
operator|->
name|pe
operator|.
name|e_lfarlc
operator|=
literal|0x40
expr_stmt|;
name|filehdr_in
operator|->
name|pe
operator|.
name|e_ovno
operator|=
literal|0x0
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
literal|4
condition|;
name|idx
operator|++
control|)
name|filehdr_in
operator|->
name|pe
operator|.
name|e_res
index|[
name|idx
index|]
operator|=
literal|0x0
expr_stmt|;
name|filehdr_in
operator|->
name|pe
operator|.
name|e_oemid
operator|=
literal|0x0
expr_stmt|;
name|filehdr_in
operator|->
name|pe
operator|.
name|e_oeminfo
operator|=
literal|0x0
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
literal|10
condition|;
name|idx
operator|++
control|)
name|filehdr_in
operator|->
name|pe
operator|.
name|e_res2
index|[
name|idx
index|]
operator|=
literal|0x0
expr_stmt|;
name|filehdr_in
operator|->
name|pe
operator|.
name|e_lfanew
operator|=
literal|0x80
expr_stmt|;
comment|/* This next collection of data are mostly just characters.  It      appears to be constant within the headers put on NT exes.  */
name|filehdr_in
operator|->
name|pe
operator|.
name|dos_message
index|[
literal|0
index|]
operator|=
literal|0x0eba1f0e
expr_stmt|;
name|filehdr_in
operator|->
name|pe
operator|.
name|dos_message
index|[
literal|1
index|]
operator|=
literal|0xcd09b400
expr_stmt|;
name|filehdr_in
operator|->
name|pe
operator|.
name|dos_message
index|[
literal|2
index|]
operator|=
literal|0x4c01b821
expr_stmt|;
name|filehdr_in
operator|->
name|pe
operator|.
name|dos_message
index|[
literal|3
index|]
operator|=
literal|0x685421cd
expr_stmt|;
name|filehdr_in
operator|->
name|pe
operator|.
name|dos_message
index|[
literal|4
index|]
operator|=
literal|0x70207369
expr_stmt|;
name|filehdr_in
operator|->
name|pe
operator|.
name|dos_message
index|[
literal|5
index|]
operator|=
literal|0x72676f72
expr_stmt|;
name|filehdr_in
operator|->
name|pe
operator|.
name|dos_message
index|[
literal|6
index|]
operator|=
literal|0x63206d61
expr_stmt|;
name|filehdr_in
operator|->
name|pe
operator|.
name|dos_message
index|[
literal|7
index|]
operator|=
literal|0x6f6e6e61
expr_stmt|;
name|filehdr_in
operator|->
name|pe
operator|.
name|dos_message
index|[
literal|8
index|]
operator|=
literal|0x65622074
expr_stmt|;
name|filehdr_in
operator|->
name|pe
operator|.
name|dos_message
index|[
literal|9
index|]
operator|=
literal|0x6e757220
expr_stmt|;
name|filehdr_in
operator|->
name|pe
operator|.
name|dos_message
index|[
literal|10
index|]
operator|=
literal|0x206e6920
expr_stmt|;
name|filehdr_in
operator|->
name|pe
operator|.
name|dos_message
index|[
literal|11
index|]
operator|=
literal|0x20534f44
expr_stmt|;
name|filehdr_in
operator|->
name|pe
operator|.
name|dos_message
index|[
literal|12
index|]
operator|=
literal|0x65646f6d
expr_stmt|;
name|filehdr_in
operator|->
name|pe
operator|.
name|dos_message
index|[
literal|13
index|]
operator|=
literal|0x0a0d0d2e
expr_stmt|;
name|filehdr_in
operator|->
name|pe
operator|.
name|dos_message
index|[
literal|14
index|]
operator|=
literal|0x24
expr_stmt|;
name|filehdr_in
operator|->
name|pe
operator|.
name|dos_message
index|[
literal|15
index|]
operator|=
literal|0x0
expr_stmt|;
name|filehdr_in
operator|->
name|pe
operator|.
name|nt_signature
operator|=
name|NT_SIGNATURE
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|filehdr_in
operator|->
name|f_magic
argument_list|,
name|filehdr_out
operator|->
name|f_magic
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|filehdr_in
operator|->
name|f_nscns
argument_list|,
name|filehdr_out
operator|->
name|f_nscns
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|time
argument_list|(
literal|0
argument_list|)
argument_list|,
name|filehdr_out
operator|->
name|f_timdat
argument_list|)
expr_stmt|;
name|PUT_FILEHDR_SYMPTR
argument_list|(
name|abfd
argument_list|,
name|filehdr_in
operator|->
name|f_symptr
argument_list|,
name|filehdr_out
operator|->
name|f_symptr
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|filehdr_in
operator|->
name|f_nsyms
argument_list|,
name|filehdr_out
operator|->
name|f_nsyms
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|filehdr_in
operator|->
name|f_opthdr
argument_list|,
name|filehdr_out
operator|->
name|f_opthdr
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|filehdr_in
operator|->
name|f_flags
argument_list|,
name|filehdr_out
operator|->
name|f_flags
argument_list|)
expr_stmt|;
comment|/* Put in extra dos header stuff.  This data remains essentially      constant, it just has to be tacked on to the beginning of all exes      for NT.  */
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|filehdr_in
operator|->
name|pe
operator|.
name|e_magic
argument_list|,
name|filehdr_out
operator|->
name|e_magic
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|filehdr_in
operator|->
name|pe
operator|.
name|e_cblp
argument_list|,
name|filehdr_out
operator|->
name|e_cblp
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|filehdr_in
operator|->
name|pe
operator|.
name|e_cp
argument_list|,
name|filehdr_out
operator|->
name|e_cp
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|filehdr_in
operator|->
name|pe
operator|.
name|e_crlc
argument_list|,
name|filehdr_out
operator|->
name|e_crlc
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|filehdr_in
operator|->
name|pe
operator|.
name|e_cparhdr
argument_list|,
name|filehdr_out
operator|->
name|e_cparhdr
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|filehdr_in
operator|->
name|pe
operator|.
name|e_minalloc
argument_list|,
name|filehdr_out
operator|->
name|e_minalloc
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|filehdr_in
operator|->
name|pe
operator|.
name|e_maxalloc
argument_list|,
name|filehdr_out
operator|->
name|e_maxalloc
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|filehdr_in
operator|->
name|pe
operator|.
name|e_ss
argument_list|,
name|filehdr_out
operator|->
name|e_ss
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|filehdr_in
operator|->
name|pe
operator|.
name|e_sp
argument_list|,
name|filehdr_out
operator|->
name|e_sp
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|filehdr_in
operator|->
name|pe
operator|.
name|e_csum
argument_list|,
name|filehdr_out
operator|->
name|e_csum
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|filehdr_in
operator|->
name|pe
operator|.
name|e_ip
argument_list|,
name|filehdr_out
operator|->
name|e_ip
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|filehdr_in
operator|->
name|pe
operator|.
name|e_cs
argument_list|,
name|filehdr_out
operator|->
name|e_cs
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|filehdr_in
operator|->
name|pe
operator|.
name|e_lfarlc
argument_list|,
name|filehdr_out
operator|->
name|e_lfarlc
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|filehdr_in
operator|->
name|pe
operator|.
name|e_ovno
argument_list|,
name|filehdr_out
operator|->
name|e_ovno
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
literal|4
condition|;
name|idx
operator|++
control|)
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|filehdr_in
operator|->
name|pe
operator|.
name|e_res
index|[
name|idx
index|]
argument_list|,
name|filehdr_out
operator|->
name|e_res
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|filehdr_in
operator|->
name|pe
operator|.
name|e_oemid
argument_list|,
name|filehdr_out
operator|->
name|e_oemid
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|filehdr_in
operator|->
name|pe
operator|.
name|e_oeminfo
argument_list|,
name|filehdr_out
operator|->
name|e_oeminfo
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
literal|10
condition|;
name|idx
operator|++
control|)
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|filehdr_in
operator|->
name|pe
operator|.
name|e_res2
index|[
name|idx
index|]
argument_list|,
name|filehdr_out
operator|->
name|e_res2
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|filehdr_in
operator|->
name|pe
operator|.
name|e_lfanew
argument_list|,
name|filehdr_out
operator|->
name|e_lfanew
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
literal|16
condition|;
name|idx
operator|++
control|)
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|filehdr_in
operator|->
name|pe
operator|.
name|dos_message
index|[
name|idx
index|]
argument_list|,
name|filehdr_out
operator|->
name|dos_message
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
comment|/* Also put in the NT signature.  */
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|filehdr_in
operator|->
name|pe
operator|.
name|nt_signature
argument_list|,
name|filehdr_out
operator|->
name|nt_signature
argument_list|)
expr_stmt|;
return|return
name|FILHSZ
return|;
block|}
end_function

begin_function
name|unsigned
name|int
name|_bfd_XX_only_swap_filehdr_out
parameter_list|(
name|abfd
parameter_list|,
name|in
parameter_list|,
name|out
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|in
decl_stmt|;
name|PTR
name|out
decl_stmt|;
block|{
name|struct
name|internal_filehdr
modifier|*
name|filehdr_in
init|=
operator|(
expr|struct
name|internal_filehdr
operator|*
operator|)
name|in
decl_stmt|;
name|FILHDR
modifier|*
name|filehdr_out
init|=
operator|(
name|FILHDR
operator|*
operator|)
name|out
decl_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|filehdr_in
operator|->
name|f_magic
argument_list|,
name|filehdr_out
operator|->
name|f_magic
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|filehdr_in
operator|->
name|f_nscns
argument_list|,
name|filehdr_out
operator|->
name|f_nscns
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|filehdr_in
operator|->
name|f_timdat
argument_list|,
name|filehdr_out
operator|->
name|f_timdat
argument_list|)
expr_stmt|;
name|PUT_FILEHDR_SYMPTR
argument_list|(
name|abfd
argument_list|,
name|filehdr_in
operator|->
name|f_symptr
argument_list|,
name|filehdr_out
operator|->
name|f_symptr
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|filehdr_in
operator|->
name|f_nsyms
argument_list|,
name|filehdr_out
operator|->
name|f_nsyms
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|filehdr_in
operator|->
name|f_opthdr
argument_list|,
name|filehdr_out
operator|->
name|f_opthdr
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|filehdr_in
operator|->
name|f_flags
argument_list|,
name|filehdr_out
operator|->
name|f_flags
argument_list|)
expr_stmt|;
return|return
name|FILHSZ
return|;
block|}
end_function

begin_function
name|unsigned
name|int
name|_bfd_XXi_swap_scnhdr_out
parameter_list|(
name|abfd
parameter_list|,
name|in
parameter_list|,
name|out
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|in
decl_stmt|;
name|PTR
name|out
decl_stmt|;
block|{
name|struct
name|internal_scnhdr
modifier|*
name|scnhdr_int
init|=
operator|(
expr|struct
name|internal_scnhdr
operator|*
operator|)
name|in
decl_stmt|;
name|SCNHDR
modifier|*
name|scnhdr_ext
init|=
operator|(
name|SCNHDR
operator|*
operator|)
name|out
decl_stmt|;
name|unsigned
name|int
name|ret
init|=
name|SCNHSZ
decl_stmt|;
name|bfd_vma
name|ps
decl_stmt|;
name|bfd_vma
name|ss
decl_stmt|;
name|memcpy
argument_list|(
name|scnhdr_ext
operator|->
name|s_name
argument_list|,
name|scnhdr_int
operator|->
name|s_name
argument_list|,
sizeof|sizeof
argument_list|(
name|scnhdr_int
operator|->
name|s_name
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_SCNHDR_VADDR
argument_list|(
name|abfd
argument_list|,
operator|(
operator|(
name|scnhdr_int
operator|->
name|s_vaddr
operator|-
name|pe_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|pe_opthdr
operator|.
name|ImageBase
operator|)
operator|&
literal|0xffffffff
operator|)
argument_list|,
name|scnhdr_ext
operator|->
name|s_vaddr
argument_list|)
expr_stmt|;
comment|/* NT wants the size data to be rounded up to the next      NT_FILE_ALIGNMENT, but zero if it has no content (as in .bss,      sometimes).  */
if|if
condition|(
operator|(
name|scnhdr_int
operator|->
name|s_flags
operator|&
name|IMAGE_SCN_CNT_UNINITIALIZED_DATA
operator|)
operator|!=
literal|0
condition|)
block|{
name|ps
operator|=
name|scnhdr_int
operator|->
name|s_size
expr_stmt|;
name|ss
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ps
operator|=
name|scnhdr_int
operator|->
name|s_paddr
expr_stmt|;
name|ss
operator|=
name|scnhdr_int
operator|->
name|s_size
expr_stmt|;
block|}
name|PUT_SCNHDR_SIZE
argument_list|(
name|abfd
argument_list|,
name|ss
argument_list|,
name|scnhdr_ext
operator|->
name|s_size
argument_list|)
expr_stmt|;
comment|/* s_paddr in PE is really the virtual size.  */
name|PUT_SCNHDR_PADDR
argument_list|(
name|abfd
argument_list|,
name|ps
argument_list|,
name|scnhdr_ext
operator|->
name|s_paddr
argument_list|)
expr_stmt|;
name|PUT_SCNHDR_SCNPTR
argument_list|(
name|abfd
argument_list|,
name|scnhdr_int
operator|->
name|s_scnptr
argument_list|,
name|scnhdr_ext
operator|->
name|s_scnptr
argument_list|)
expr_stmt|;
name|PUT_SCNHDR_RELPTR
argument_list|(
name|abfd
argument_list|,
name|scnhdr_int
operator|->
name|s_relptr
argument_list|,
name|scnhdr_ext
operator|->
name|s_relptr
argument_list|)
expr_stmt|;
name|PUT_SCNHDR_LNNOPTR
argument_list|(
name|abfd
argument_list|,
name|scnhdr_int
operator|->
name|s_lnnoptr
argument_list|,
name|scnhdr_ext
operator|->
name|s_lnnoptr
argument_list|)
expr_stmt|;
comment|/* Extra flags must be set when dealing with NT.  All sections should also      have the IMAGE_SCN_MEM_READ (0x40000000) flag set.  In addition, the      .text section must have IMAGE_SCN_MEM_EXECUTE (0x20000000) and the data      sections (.idata, .data, .bss, .CRT) must have IMAGE_SCN_MEM_WRITE set      (this is especially important when dealing with the .idata section since      the addresses for routines from .dlls must be overwritten).  If .reloc      section data is ever generated, we must add IMAGE_SCN_MEM_DISCARDABLE      (0x02000000).  Also, the resource data should also be read and      writable.  */
comment|/* FIXME: alignment is also encoded in this field, at least on ppc (krk) */
comment|/* FIXME: even worse, I don't see how to get the original alignment field*/
comment|/*        back...                                                        */
block|{
name|int
name|flags
init|=
name|scnhdr_int
operator|->
name|s_flags
decl_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|flags
argument_list|,
name|scnhdr_ext
operator|->
name|s_flags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|coff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|link_info
operator|&&
operator|!
name|coff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|link_info
operator|->
name|relocateable
operator|&&
operator|!
name|coff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|link_info
operator|->
name|shared
operator|&&
name|strcmp
argument_list|(
name|scnhdr_int
operator|->
name|s_name
argument_list|,
literal|".text"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* By inference from looking at MS output, the 32 bit field 	 which is the combintion of the number_of_relocs and 	 number_of_linenos is used for the line number count in 	 executables.  A 16-bit field won't do for cc1.  The MS 	 document says that the number of relocs is zero for 	 executables, but the 17-th bit has been observed to be there. 	 Overflow is not an issue: a 4G-line program will overflow a 	 bunch of other fields long before this!  */
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|scnhdr_int
operator|->
name|s_nlnno
operator|&
literal|0xffff
operator|)
argument_list|,
name|scnhdr_ext
operator|->
name|s_nlnno
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|scnhdr_int
operator|->
name|s_nlnno
operator|>>
literal|16
operator|)
argument_list|,
name|scnhdr_ext
operator|->
name|s_nreloc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|scnhdr_int
operator|->
name|s_nlnno
operator|<=
literal|0xffff
condition|)
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|scnhdr_int
operator|->
name|s_nlnno
argument_list|,
name|scnhdr_ext
operator|->
name|s_nlnno
argument_list|)
expr_stmt|;
else|else
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: line number overflow: 0x%lx> 0xffff"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|scnhdr_int
operator|->
name|s_nlnno
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_file_truncated
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
literal|0xffff
argument_list|,
name|scnhdr_ext
operator|->
name|s_nlnno
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|scnhdr_int
operator|->
name|s_nreloc
operator|<=
literal|0xffff
condition|)
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|scnhdr_int
operator|->
name|s_nreloc
argument_list|,
name|scnhdr_ext
operator|->
name|s_nreloc
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* PE can deal with large #s of relocs, but not here.  */
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
literal|0xffff
argument_list|,
name|scnhdr_ext
operator|->
name|s_nreloc
argument_list|)
expr_stmt|;
name|scnhdr_int
operator|->
name|s_flags
operator||=
name|IMAGE_SCN_LNK_NRELOC_OVFL
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|scnhdr_int
operator|->
name|s_flags
argument_list|,
name|scnhdr_ext
operator|->
name|s_flags
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|(*_bfd_error_handler) (_("%s: reloc overflow 1: 0x%lx> 0xffff"), 				 bfd_get_filename (abfd), 				 scnhdr_int->s_nreloc); 	  bfd_set_error (bfd_error_file_truncated); 	  H_PUT_16 (abfd, 0xffff, scnhdr_ext->s_nreloc); 	  ret = 0;
endif|#
directive|endif
block|}
block|}
return|return
name|ret
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dir_names
index|[
name|IMAGE_NUMBEROF_DIRECTORY_ENTRIES
index|]
init|=
block|{
name|N_
argument_list|(
literal|"Export Directory [.edata (or where ever we found it)]"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Import Directory [parts of .idata]"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Resource Directory [.rsrc]"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Exception Directory [.pdata]"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Security Directory"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Base Relocation Directory [.reloc]"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Debug Directory"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Description Directory"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Special Directory"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Thread Storage Directory [.tls]"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Load Configuration Directory"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Bound Import Directory"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Import Address Table Directory"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Delay Import Directory"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Reserved"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Reserved"
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|POWERPC_LE_PE
end_ifdef

begin_comment
comment|/* The code for the PPC really falls in the "architecture dependent"    category.  However, it's not clear that anyone will ever care, so    we're ignoring the issue for now; if/when PPC matters, some of this    may need to go into peicode.h, or arguments passed to enable the    PPC- specific code.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|boolean
name|pe_print_idata
parameter_list|(
name|abfd
parameter_list|,
name|vfile
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|vfile
decl_stmt|;
block|{
name|FILE
modifier|*
name|file
init|=
operator|(
name|FILE
operator|*
operator|)
name|vfile
decl_stmt|;
name|bfd_byte
modifier|*
name|data
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|bfd_signed_vma
name|adj
decl_stmt|;
ifdef|#
directive|ifdef
name|POWERPC_LE_PE
name|asection
modifier|*
name|rel_section
init|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".reldata"
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|bfd_size_type
name|datasize
init|=
literal|0
decl_stmt|;
name|bfd_size_type
name|dataoff
decl_stmt|;
name|bfd_size_type
name|i
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|int
name|onaline
init|=
literal|20
decl_stmt|;
name|pe_data_type
modifier|*
name|pe
init|=
name|pe_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|struct
name|internal_extra_pe_aouthdr
modifier|*
name|extra
init|=
operator|&
name|pe
operator|->
name|pe_opthdr
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
name|addr
operator|=
name|extra
operator|->
name|DataDirectory
index|[
literal|1
index|]
operator|.
name|VirtualAddress
expr_stmt|;
if|if
condition|(
name|addr
operator|==
literal|0
operator|&&
name|extra
operator|->
name|DataDirectory
index|[
literal|1
index|]
operator|.
name|Size
operator|==
literal|0
condition|)
block|{
comment|/* Maybe the extra header isn't there.  Look for the section.  */
name|section
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".idata"
argument_list|)
expr_stmt|;
if|if
condition|(
name|section
operator|==
name|NULL
condition|)
return|return
name|true
return|;
name|addr
operator|=
name|section
operator|->
name|vma
expr_stmt|;
name|datasize
operator|=
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
name|datasize
operator|==
literal|0
condition|)
return|return
name|true
return|;
block|}
else|else
block|{
name|addr
operator|+=
name|extra
operator|->
name|ImageBase
expr_stmt|;
for|for
control|(
name|section
operator|=
name|abfd
operator|->
name|sections
init|;
name|section
operator|!=
name|NULL
condition|;
name|section
operator|=
name|section
operator|->
name|next
control|)
block|{
name|datasize
operator|=
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|>=
name|section
operator|->
name|vma
operator|&&
name|addr
operator|<
name|section
operator|->
name|vma
operator|+
name|datasize
condition|)
break|break;
block|}
if|if
condition|(
name|section
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"\nThere is an import table, but the section containing it could not be found\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"\nThere is an import table in %s at 0x%lx\n"
argument_list|)
argument_list|,
name|section
operator|->
name|name
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|addr
argument_list|)
expr_stmt|;
name|dataoff
operator|=
name|addr
operator|-
name|section
operator|->
name|vma
expr_stmt|;
name|datasize
operator|-=
name|dataoff
expr_stmt|;
ifdef|#
directive|ifdef
name|POWERPC_LE_PE
if|if
condition|(
name|rel_section
operator|!=
literal|0
operator|&&
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|rel_section
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* The toc address can be found by taking the starting address, 	 which on the PPC locates a function descriptor. The 	 descriptor consists of the function code starting address 	 followed by the address of the toc. The starting address we 	 get from the bfd, and the descriptor is supposed to be in the 	 .reldata section.  */
name|bfd_vma
name|loadable_toc_address
decl_stmt|;
name|bfd_vma
name|toc_address
decl_stmt|;
name|bfd_vma
name|start_address
decl_stmt|;
name|bfd_byte
modifier|*
name|data
init|=
literal|0
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|amt
operator|=
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|rel_section
argument_list|)
expr_stmt|;
name|data
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
operator|&&
name|amt
operator|!=
literal|0
condition|)
return|return
name|false
return|;
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|rel_section
argument_list|,
operator|(
name|PTR
operator|)
name|data
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|amt
argument_list|)
expr_stmt|;
name|offset
operator|=
name|abfd
operator|->
name|start_address
operator|-
name|rel_section
operator|->
name|vma
expr_stmt|;
name|start_address
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|data
operator|+
name|offset
argument_list|)
expr_stmt|;
name|loadable_toc_address
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|data
operator|+
name|offset
operator|+
literal|4
argument_list|)
expr_stmt|;
name|toc_address
operator|=
name|loadable_toc_address
operator|-
literal|32768
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"\nFunction descriptor located at the start address: %04lx\n"
argument_list|)
argument_list|,
call|(
name|unsigned
name|long
name|int
call|)
argument_list|(
name|abfd
operator|->
name|start_address
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"\tcode-base %08lx toc (loadable/actual) %08lx/%08lx\n"
argument_list|)
argument_list|,
name|start_address
argument_list|,
name|loadable_toc_address
argument_list|,
name|toc_address
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"\nNo reldata section! Function descriptor not decoded.\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"\nThe Import Tables (interpreted %s section contents)\n"
argument_list|)
argument_list|,
name|section
operator|->
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"\  vma:            Hint    Time      Forward  DLL       First\n\                  Table   Stamp     Chain    Name      Thunk\n"
argument_list|)
argument_list|)
expr_stmt|;
name|amt
operator|=
name|dataoff
operator|+
name|datasize
expr_stmt|;
name|data
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
return|return
name|false
return|;
comment|/* Read the whole section.  Some of the fields might be before dataoff.  */
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
operator|(
name|PTR
operator|)
name|data
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|amt
argument_list|)
condition|)
return|return
name|false
return|;
name|adj
operator|=
name|section
operator|->
name|vma
operator|-
name|extra
operator|->
name|ImageBase
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|datasize
condition|;
name|i
operator|+=
name|onaline
control|)
block|{
name|bfd_vma
name|hint_addr
decl_stmt|;
name|bfd_vma
name|time_stamp
decl_stmt|;
name|bfd_vma
name|forward_chain
decl_stmt|;
name|bfd_vma
name|dll_name
decl_stmt|;
name|bfd_vma
name|first_thunk
decl_stmt|;
name|int
name|idx
init|=
literal|0
decl_stmt|;
name|bfd_size_type
name|j
decl_stmt|;
name|char
modifier|*
name|dll
decl_stmt|;
comment|/* print (i + extra->DataDirectory[1].VirtualAddress)  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %08lx\t"
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|i
operator|+
name|adj
operator|+
name|dataoff
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (i + 20> datasize)
comment|/* Check stuff.  */
block|;
endif|#
directive|endif
name|hint_addr
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|data
operator|+
name|i
operator|+
name|dataoff
argument_list|)
expr_stmt|;
name|time_stamp
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|data
operator|+
name|i
operator|+
literal|4
operator|+
name|dataoff
argument_list|)
expr_stmt|;
name|forward_chain
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|data
operator|+
name|i
operator|+
literal|8
operator|+
name|dataoff
argument_list|)
expr_stmt|;
name|dll_name
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|data
operator|+
name|i
operator|+
literal|12
operator|+
name|dataoff
argument_list|)
expr_stmt|;
name|first_thunk
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|data
operator|+
name|i
operator|+
literal|16
operator|+
name|dataoff
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%08lx %08lx %08lx %08lx %08lx\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|hint_addr
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|time_stamp
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|forward_chain
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|dll_name
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|first_thunk
argument_list|)
expr_stmt|;
if|if
condition|(
name|hint_addr
operator|==
literal|0
operator|&&
name|first_thunk
operator|==
literal|0
condition|)
break|break;
name|dll
operator|=
operator|(
name|char
operator|*
operator|)
name|data
operator|+
name|dll_name
operator|-
name|adj
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"\n\tDLL Name: %s\n"
argument_list|)
argument_list|,
name|dll
argument_list|)
expr_stmt|;
if|if
condition|(
name|hint_addr
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"\tvma:  Hint/Ord Member-Name\n"
argument_list|)
argument_list|)
expr_stmt|;
name|idx
operator|=
name|hint_addr
operator|-
name|adj
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|datasize
condition|;
name|j
operator|+=
literal|4
control|)
block|{
name|unsigned
name|long
name|member
init|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|data
operator|+
name|idx
operator|+
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|member
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|member
operator|&
literal|0x80000000
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%04lx\t %4lu"
argument_list|,
name|member
argument_list|,
name|member
operator|&
literal|0x7fffffff
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|ordinal
decl_stmt|;
name|char
modifier|*
name|member_name
decl_stmt|;
name|ordinal
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|data
operator|+
name|member
operator|-
name|adj
argument_list|)
expr_stmt|;
name|member_name
operator|=
operator|(
name|char
operator|*
operator|)
name|data
operator|+
name|member
operator|-
name|adj
operator|+
literal|2
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%04lx\t %4d  %s"
argument_list|,
name|member
argument_list|,
name|ordinal
argument_list|,
name|member_name
argument_list|)
expr_stmt|;
block|}
comment|/* If the time stamp is not zero, the import address                  table holds actual addresses.  */
if|if
condition|(
name|time_stamp
operator|!=
literal|0
operator|&&
name|first_thunk
operator|!=
literal|0
operator|&&
name|first_thunk
operator|!=
name|hint_addr
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%04lx"
argument_list|,
operator|(
name|long
operator|)
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|data
operator|+
name|first_thunk
operator|-
name|adj
operator|+
name|j
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hint_addr
operator|!=
name|first_thunk
operator|&&
name|time_stamp
operator|==
literal|0
condition|)
block|{
name|int
name|differ
init|=
literal|0
decl_stmt|;
name|int
name|idx2
decl_stmt|;
name|idx2
operator|=
name|first_thunk
operator|-
name|adj
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|datasize
condition|;
name|j
operator|+=
literal|4
control|)
block|{
name|int
name|ordinal
decl_stmt|;
name|char
modifier|*
name|member_name
decl_stmt|;
name|bfd_vma
name|hint_member
init|=
literal|0
decl_stmt|;
name|bfd_vma
name|iat_member
decl_stmt|;
if|if
condition|(
name|hint_addr
operator|!=
literal|0
condition|)
name|hint_member
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|data
operator|+
name|idx
operator|+
name|j
argument_list|)
expr_stmt|;
name|iat_member
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|data
operator|+
name|idx2
operator|+
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|hint_addr
operator|==
literal|0
operator|&&
name|iat_member
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|hint_addr
operator|==
literal|0
operator|||
name|hint_member
operator|!=
name|iat_member
condition|)
block|{
if|if
condition|(
name|differ
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"\tThe Import Address Table (difference found)\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"\tvma:  Hint/Ord Member-Name\n"
argument_list|)
argument_list|)
expr_stmt|;
name|differ
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|iat_member
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"\t>>> Ran out of IAT members!\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|ordinal
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|data
operator|+
name|iat_member
operator|-
name|adj
argument_list|)
expr_stmt|;
name|member_name
operator|=
operator|(
name|char
operator|*
operator|)
name|data
operator|+
name|iat_member
operator|-
name|adj
operator|+
literal|2
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%04lx\t %4d  %s\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|iat_member
argument_list|,
name|ordinal
argument_list|,
name|member_name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hint_addr
operator|!=
literal|0
operator|&&
name|hint_member
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|differ
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"\tThe Import Address Table is identical\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|pe_print_edata
parameter_list|(
name|abfd
parameter_list|,
name|vfile
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|vfile
decl_stmt|;
block|{
name|FILE
modifier|*
name|file
init|=
operator|(
name|FILE
operator|*
operator|)
name|vfile
decl_stmt|;
name|bfd_byte
modifier|*
name|data
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|bfd_size_type
name|datasize
init|=
literal|0
decl_stmt|;
name|bfd_size_type
name|dataoff
decl_stmt|;
name|bfd_size_type
name|i
decl_stmt|;
name|bfd_signed_vma
name|adj
decl_stmt|;
struct|struct
name|EDT_type
block|{
name|long
name|export_flags
decl_stmt|;
comment|/* reserved - should be zero */
name|long
name|time_stamp
decl_stmt|;
name|short
name|major_ver
decl_stmt|;
name|short
name|minor_ver
decl_stmt|;
name|bfd_vma
name|name
decl_stmt|;
comment|/* rva - relative to image base */
name|long
name|base
decl_stmt|;
comment|/* ordinal base */
name|unsigned
name|long
name|num_functions
decl_stmt|;
comment|/* Number in the export address table */
name|unsigned
name|long
name|num_names
decl_stmt|;
comment|/* Number in the name pointer table */
name|bfd_vma
name|eat_addr
decl_stmt|;
comment|/* rva to the export address table */
name|bfd_vma
name|npt_addr
decl_stmt|;
comment|/* rva to the Export Name Pointer Table */
name|bfd_vma
name|ot_addr
decl_stmt|;
comment|/* rva to the Ordinal Table */
block|}
name|edt
struct|;
name|pe_data_type
modifier|*
name|pe
init|=
name|pe_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|struct
name|internal_extra_pe_aouthdr
modifier|*
name|extra
init|=
operator|&
name|pe
operator|->
name|pe_opthdr
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
name|addr
operator|=
name|extra
operator|->
name|DataDirectory
index|[
literal|0
index|]
operator|.
name|VirtualAddress
expr_stmt|;
if|if
condition|(
name|addr
operator|==
literal|0
operator|&&
name|extra
operator|->
name|DataDirectory
index|[
literal|0
index|]
operator|.
name|Size
operator|==
literal|0
condition|)
block|{
comment|/* Maybe the extra header isn't there.  Look for the section.  */
name|section
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".edata"
argument_list|)
expr_stmt|;
if|if
condition|(
name|section
operator|==
name|NULL
condition|)
return|return
name|true
return|;
name|addr
operator|=
name|section
operator|->
name|vma
expr_stmt|;
name|datasize
operator|=
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
name|datasize
operator|==
literal|0
condition|)
return|return
name|true
return|;
block|}
else|else
block|{
name|addr
operator|+=
name|extra
operator|->
name|ImageBase
expr_stmt|;
for|for
control|(
name|section
operator|=
name|abfd
operator|->
name|sections
init|;
name|section
operator|!=
name|NULL
condition|;
name|section
operator|=
name|section
operator|->
name|next
control|)
block|{
name|datasize
operator|=
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|>=
name|section
operator|->
name|vma
operator|&&
name|addr
operator|<
name|section
operator|->
name|vma
operator|+
name|datasize
condition|)
break|break;
block|}
if|if
condition|(
name|section
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"\nThere is an export table, but the section containing it could not be found\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"\nThere is an export table in %s at 0x%lx\n"
argument_list|)
argument_list|,
name|section
operator|->
name|name
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|addr
argument_list|)
expr_stmt|;
name|dataoff
operator|=
name|addr
operator|-
name|section
operator|->
name|vma
expr_stmt|;
name|datasize
operator|-=
name|dataoff
expr_stmt|;
name|data
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|datasize
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
operator|(
name|PTR
operator|)
name|data
argument_list|,
operator|(
name|file_ptr
operator|)
name|dataoff
argument_list|,
name|datasize
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Go get Export Directory Table.  */
name|edt
operator|.
name|export_flags
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|data
operator|+
literal|0
argument_list|)
expr_stmt|;
name|edt
operator|.
name|time_stamp
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|data
operator|+
literal|4
argument_list|)
expr_stmt|;
name|edt
operator|.
name|major_ver
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|data
operator|+
literal|8
argument_list|)
expr_stmt|;
name|edt
operator|.
name|minor_ver
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|data
operator|+
literal|10
argument_list|)
expr_stmt|;
name|edt
operator|.
name|name
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|data
operator|+
literal|12
argument_list|)
expr_stmt|;
name|edt
operator|.
name|base
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|data
operator|+
literal|16
argument_list|)
expr_stmt|;
name|edt
operator|.
name|num_functions
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|data
operator|+
literal|20
argument_list|)
expr_stmt|;
name|edt
operator|.
name|num_names
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|data
operator|+
literal|24
argument_list|)
expr_stmt|;
name|edt
operator|.
name|eat_addr
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|data
operator|+
literal|28
argument_list|)
expr_stmt|;
name|edt
operator|.
name|npt_addr
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|data
operator|+
literal|32
argument_list|)
expr_stmt|;
name|edt
operator|.
name|ot_addr
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|data
operator|+
literal|36
argument_list|)
expr_stmt|;
name|adj
operator|=
name|section
operator|->
name|vma
operator|-
name|extra
operator|->
name|ImageBase
operator|+
name|dataoff
expr_stmt|;
comment|/* Dump the EDT first.  */
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"\nThe Export Tables (interpreted %s section contents)\n\n"
argument_list|)
argument_list|,
name|section
operator|->
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"Export Flags \t\t\t%lx\n"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|edt
operator|.
name|export_flags
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"Time/Date stamp \t\t%lx\n"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|edt
operator|.
name|time_stamp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"Major/Minor \t\t\t%d/%d\n"
argument_list|)
argument_list|,
name|edt
operator|.
name|major_ver
argument_list|,
name|edt
operator|.
name|minor_ver
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"Name \t\t\t\t"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf_vma
argument_list|(
name|file
argument_list|,
name|edt
operator|.
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %s\n"
argument_list|,
name|data
operator|+
name|edt
operator|.
name|name
operator|-
name|adj
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"Ordinal Base \t\t\t%ld\n"
argument_list|)
argument_list|,
name|edt
operator|.
name|base
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"Number in:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"\tExport Address Table \t\t%08lx\n"
argument_list|)
argument_list|,
name|edt
operator|.
name|num_functions
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"\t[Name Pointer/Ordinal] Table\t%08lx\n"
argument_list|)
argument_list|,
name|edt
operator|.
name|num_names
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"Table Addresses\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"\tExport Address Table \t\t"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf_vma
argument_list|(
name|file
argument_list|,
name|edt
operator|.
name|eat_addr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"\tName Pointer Table \t\t"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf_vma
argument_list|(
name|file
argument_list|,
name|edt
operator|.
name|npt_addr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"\tOrdinal Table \t\t\t"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf_vma
argument_list|(
name|file
argument_list|,
name|edt
operator|.
name|ot_addr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* The next table to find is the Export Address Table. It's basically      a list of pointers that either locate a function in this dll, or      forward the call to another dll. Something like:       typedef union       {         long export_rva;         long forwarder_rva;       } export_address_table_entry;   */
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"\nExport Address Table -- Ordinal Base %ld\n"
argument_list|)
argument_list|,
name|edt
operator|.
name|base
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|edt
operator|.
name|num_functions
condition|;
operator|++
name|i
control|)
block|{
name|bfd_vma
name|eat_member
init|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|data
operator|+
name|edt
operator|.
name|eat_addr
operator|+
operator|(
name|i
operator|*
literal|4
operator|)
operator|-
name|adj
argument_list|)
decl_stmt|;
if|if
condition|(
name|eat_member
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|eat_member
operator|-
name|adj
operator|<=
name|datasize
condition|)
block|{
comment|/* This rva is to a name (forwarding function) in our section.  */
comment|/* Should locate a function descriptor.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t[%4ld] +base[%4ld] %04lx %s -- %s\n"
argument_list|,
operator|(
name|long
operator|)
name|i
argument_list|,
call|(
name|long
call|)
argument_list|(
name|i
operator|+
name|edt
operator|.
name|base
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|eat_member
argument_list|,
name|_
argument_list|(
literal|"Forwarder RVA"
argument_list|)
argument_list|,
name|data
operator|+
name|eat_member
operator|-
name|adj
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Should locate a function descriptor in the reldata section.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t[%4ld] +base[%4ld] %04lx %s\n"
argument_list|,
operator|(
name|long
operator|)
name|i
argument_list|,
call|(
name|long
call|)
argument_list|(
name|i
operator|+
name|edt
operator|.
name|base
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|eat_member
argument_list|,
name|_
argument_list|(
literal|"Export RVA"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* The Export Name Pointer Table is paired with the Export Ordinal Table.  */
comment|/* Dump them in parallel for clarity.  */
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"\n[Ordinal/Name Pointer] Table\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|edt
operator|.
name|num_names
condition|;
operator|++
name|i
control|)
block|{
name|bfd_vma
name|name_ptr
init|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|data
operator|+
name|edt
operator|.
name|npt_addr
operator|+
operator|(
name|i
operator|*
literal|4
operator|)
operator|-
name|adj
argument_list|)
decl_stmt|;
name|char
modifier|*
name|name
init|=
operator|(
name|char
operator|*
operator|)
name|data
operator|+
name|name_ptr
operator|-
name|adj
decl_stmt|;
name|bfd_vma
name|ord
init|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|data
operator|+
name|edt
operator|.
name|ot_addr
operator|+
operator|(
name|i
operator|*
literal|2
operator|)
operator|-
name|adj
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t[%4ld] %s\n"
argument_list|,
operator|(
name|long
operator|)
name|ord
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* This really is architecture dependent.  On IA-64, a .pdata entry    consists of three dwords containing relative virtual addresses that    specify the start and end address of the code range the entry    covers and the address of the corresponding unwind info data.  */
end_comment

begin_function
specifier|static
name|boolean
name|pe_print_pdata
parameter_list|(
name|abfd
parameter_list|,
name|vfile
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|vfile
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|COFF_WITH_pep
define|#
directive|define
name|PDATA_ROW_SIZE
value|(3*8)
else|#
directive|else
define|#
directive|define
name|PDATA_ROW_SIZE
value|(5*4)
endif|#
directive|endif
name|FILE
modifier|*
name|file
init|=
operator|(
name|FILE
operator|*
operator|)
name|vfile
decl_stmt|;
name|bfd_byte
modifier|*
name|data
init|=
literal|0
decl_stmt|;
name|asection
modifier|*
name|section
init|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".pdata"
argument_list|)
decl_stmt|;
name|bfd_size_type
name|datasize
init|=
literal|0
decl_stmt|;
name|bfd_size_type
name|i
decl_stmt|;
name|bfd_size_type
name|start
decl_stmt|,
name|stop
decl_stmt|;
name|int
name|onaline
init|=
name|PDATA_ROW_SIZE
decl_stmt|;
if|if
condition|(
name|section
operator|==
name|NULL
operator|||
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
operator|==
name|NULL
operator|||
name|pei_section_data
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|true
return|;
name|stop
operator|=
name|pei_section_data
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
operator|->
name|virt_size
expr_stmt|;
if|if
condition|(
operator|(
name|stop
operator|%
name|onaline
operator|)
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"Warning, .pdata section size (%ld) is not a multiple of %d\n"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|stop
argument_list|,
name|onaline
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"\nThe Function Table (interpreted .pdata section contents)\n"
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COFF_WITH_pep
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" vma:\t\t\tBegin Address    End Address      Unwind Info\n"
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"\  vma:\t\tBegin    End      EH       EH       PrologEnd  Exception\n\      \t\tAddress  Address  Handler  Data     Address    Mask\n"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|datasize
operator|=
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
name|datasize
operator|==
literal|0
condition|)
return|return
name|true
return|;
name|data
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|datasize
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
operator|&&
name|datasize
operator|!=
literal|0
condition|)
return|return
name|false
return|;
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
operator|(
name|PTR
operator|)
name|data
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|datasize
argument_list|)
expr_stmt|;
name|start
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|stop
condition|;
name|i
operator|+=
name|onaline
control|)
block|{
name|bfd_vma
name|begin_addr
decl_stmt|;
name|bfd_vma
name|end_addr
decl_stmt|;
name|bfd_vma
name|eh_handler
decl_stmt|;
name|bfd_vma
name|eh_data
decl_stmt|;
name|bfd_vma
name|prolog_end_addr
decl_stmt|;
name|int
name|em_data
decl_stmt|;
if|if
condition|(
name|i
operator|+
name|PDATA_ROW_SIZE
operator|>
name|stop
condition|)
break|break;
name|begin_addr
operator|=
name|GET_PDATA_ENTRY
argument_list|(
name|abfd
argument_list|,
name|data
operator|+
name|i
argument_list|)
expr_stmt|;
name|end_addr
operator|=
name|GET_PDATA_ENTRY
argument_list|(
name|abfd
argument_list|,
name|data
operator|+
name|i
operator|+
literal|4
argument_list|)
expr_stmt|;
name|eh_handler
operator|=
name|GET_PDATA_ENTRY
argument_list|(
name|abfd
argument_list|,
name|data
operator|+
name|i
operator|+
literal|8
argument_list|)
expr_stmt|;
name|eh_data
operator|=
name|GET_PDATA_ENTRY
argument_list|(
name|abfd
argument_list|,
name|data
operator|+
name|i
operator|+
literal|12
argument_list|)
expr_stmt|;
name|prolog_end_addr
operator|=
name|GET_PDATA_ENTRY
argument_list|(
name|abfd
argument_list|,
name|data
operator|+
name|i
operator|+
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|begin_addr
operator|==
literal|0
operator|&&
name|end_addr
operator|==
literal|0
operator|&&
name|eh_handler
operator|==
literal|0
operator|&&
name|eh_data
operator|==
literal|0
operator|&&
name|prolog_end_addr
operator|==
literal|0
condition|)
comment|/* We are probably into the padding of the section now.  */
break|break;
name|em_data
operator|=
operator|(
operator|(
name|eh_handler
operator|&
literal|0x1
operator|)
operator|<<
literal|2
operator|)
operator||
operator|(
name|prolog_end_addr
operator|&
literal|0x3
operator|)
expr_stmt|;
name|eh_handler
operator|&=
operator|~
operator|(
name|bfd_vma
operator|)
literal|0x3
expr_stmt|;
name|prolog_end_addr
operator|&=
operator|~
operator|(
name|bfd_vma
operator|)
literal|0x3
expr_stmt|;
name|fputc
argument_list|(
literal|' '
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf_vma
argument_list|(
name|file
argument_list|,
name|i
operator|+
name|section
operator|->
name|vma
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\t'
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf_vma
argument_list|(
name|file
argument_list|,
name|begin_addr
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|' '
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf_vma
argument_list|(
name|file
argument_list|,
name|end_addr
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|' '
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf_vma
argument_list|(
name|file
argument_list|,
name|eh_handler
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|COFF_WITH_pep
name|fputc
argument_list|(
literal|' '
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf_vma
argument_list|(
name|file
argument_list|,
name|eh_data
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|' '
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf_vma
argument_list|(
name|file
argument_list|,
name|prolog_end_addr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"   %x"
argument_list|,
name|em_data
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|POWERPC_LE_PE
if|if
condition|(
name|eh_handler
operator|==
literal|0
operator|&&
name|eh_data
operator|!=
literal|0
condition|)
block|{
comment|/* Special bits here, although the meaning may be a little 	     mysterious. The only one I know for sure is 0x03.  */
comment|/* Code Significance                           */
comment|/* 0x00 None                                   */
comment|/* 0x01 Register Save Millicode                */
comment|/* 0x02 Register Restore Millicode             */
comment|/* 0x03 Glue Code Sequence                     */
switch|switch
condition|(
name|eh_data
condition|)
block|{
case|case
literal|0x01
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" Register save millicode"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x02
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" Register restore millicode"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x03
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" Glue code sequence"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
endif|#
directive|endif
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_define
define|#
directive|define
name|IMAGE_REL_BASED_HIGHADJ
value|4
end_define

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|tbl
index|[]
init|=
block|{
literal|"ABSOLUTE"
block|,
literal|"HIGH"
block|,
literal|"LOW"
block|,
literal|"HIGHLOW"
block|,
literal|"HIGHADJ"
block|,
literal|"MIPS_JMPADDR"
block|,
literal|"SECTION"
block|,
literal|"REL32"
block|,
literal|"RESERVED1"
block|,
literal|"MIPS_JMPADDR16"
block|,
literal|"DIR64"
block|,
literal|"HIGH3ADJ"
literal|"UNKNOWN"
block|,
comment|/* MUST be last */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|boolean
name|pe_print_reloc
parameter_list|(
name|abfd
parameter_list|,
name|vfile
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|vfile
decl_stmt|;
block|{
name|FILE
modifier|*
name|file
init|=
operator|(
name|FILE
operator|*
operator|)
name|vfile
decl_stmt|;
name|bfd_byte
modifier|*
name|data
init|=
literal|0
decl_stmt|;
name|asection
modifier|*
name|section
init|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".reloc"
argument_list|)
decl_stmt|;
name|bfd_size_type
name|datasize
decl_stmt|;
name|bfd_size_type
name|i
decl_stmt|;
name|bfd_size_type
name|start
decl_stmt|,
name|stop
decl_stmt|;
if|if
condition|(
name|section
operator|==
name|NULL
condition|)
return|return
name|true
return|;
if|if
condition|(
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
operator|==
literal|0
condition|)
return|return
name|true
return|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"\n\nPE File Base Relocations (interpreted .reloc section contents)\n"
argument_list|)
argument_list|)
expr_stmt|;
name|datasize
operator|=
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
expr_stmt|;
name|data
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|datasize
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
operator|&&
name|datasize
operator|!=
literal|0
condition|)
return|return
name|false
return|;
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
operator|(
name|PTR
operator|)
name|data
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|datasize
argument_list|)
expr_stmt|;
name|start
operator|=
literal|0
expr_stmt|;
name|stop
operator|=
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|stop
condition|;
control|)
block|{
name|int
name|j
decl_stmt|;
name|bfd_vma
name|virtual_address
decl_stmt|;
name|long
name|number
decl_stmt|,
name|size
decl_stmt|;
comment|/* The .reloc section is a sequence of blocks, with a header consisting 	 of two 32 bit quantities, followed by a number of 16 bit entries.  */
name|virtual_address
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|data
operator|+
name|i
argument_list|)
expr_stmt|;
name|size
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|data
operator|+
name|i
operator|+
literal|4
argument_list|)
expr_stmt|;
name|number
operator|=
operator|(
name|size
operator|-
literal|8
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
break|break;
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"\nVirtual Address: %08lx Chunk size %ld (0x%lx) Number of fixups %ld\n"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|virtual_address
argument_list|,
name|size
argument_list|,
name|size
argument_list|,
name|number
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|number
condition|;
operator|++
name|j
control|)
block|{
name|unsigned
name|short
name|e
init|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|data
operator|+
name|i
operator|+
literal|8
operator|+
name|j
operator|*
literal|2
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|t
init|=
operator|(
name|e
operator|&
literal|0xF000
operator|)
operator|>>
literal|12
decl_stmt|;
name|int
name|off
init|=
name|e
operator|&
literal|0x0FFF
decl_stmt|;
if|if
condition|(
name|t
operator|>=
sizeof|sizeof
argument_list|(
name|tbl
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|tbl
index|[
literal|0
index|]
argument_list|)
condition|)
name|t
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|tbl
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|tbl
index|[
literal|0
index|]
argument_list|)
operator|)
operator|-
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"\treloc %4d offset %4x [%4lx] %s"
argument_list|)
argument_list|,
name|j
argument_list|,
name|off
argument_list|,
call|(
name|long
call|)
argument_list|(
name|off
operator|+
name|virtual_address
argument_list|)
argument_list|,
name|tbl
index|[
name|t
index|]
argument_list|)
expr_stmt|;
comment|/* HIGHADJ takes an argument, - the next record *is* the 	     low 16 bits of addend.  */
if|if
condition|(
name|t
operator|==
name|IMAGE_REL_BASED_HIGHADJ
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" (%4x)"
argument_list|,
operator|(
operator|(
name|unsigned
name|int
operator|)
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|data
operator|+
name|i
operator|+
literal|8
operator|+
name|j
operator|*
literal|2
operator|+
literal|2
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|i
operator|+=
name|size
expr_stmt|;
block|}
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Print out the program headers.  */
end_comment

begin_function
name|boolean
name|_bfd_XX_print_private_bfd_data_common
parameter_list|(
name|abfd
parameter_list|,
name|vfile
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|vfile
decl_stmt|;
block|{
name|FILE
modifier|*
name|file
init|=
operator|(
name|FILE
operator|*
operator|)
name|vfile
decl_stmt|;
name|int
name|j
decl_stmt|;
name|pe_data_type
modifier|*
name|pe
init|=
name|pe_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|struct
name|internal_extra_pe_aouthdr
modifier|*
name|i
init|=
operator|&
name|pe
operator|->
name|pe_opthdr
decl_stmt|;
specifier|const
name|char
modifier|*
name|subsystem_name
init|=
name|NULL
decl_stmt|;
comment|/* The MS dumpbin program reportedly ands with 0xff0f before      printing the characteristics field.  Not sure why.  No reason to      emulate it here.  */
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"\nCharacteristics 0x%x\n"
argument_list|)
argument_list|,
name|pe
operator|->
name|real_flags
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|PF
define|#
directive|define
name|PF
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|if (pe->real_flags& x) { fprintf (file, "\t%s\n", y); }
name|PF
argument_list|(
name|F_RELFLG
argument_list|,
literal|"relocations stripped"
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|F_EXEC
argument_list|,
literal|"executable"
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|F_LNNO
argument_list|,
literal|"line numbers stripped"
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|F_LSYMS
argument_list|,
literal|"symbols stripped"
argument_list|)
expr_stmt|;
name|PF
argument_list|(
literal|0x80
argument_list|,
literal|"little endian"
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|F_AR32WR
argument_list|,
literal|"32 bit words"
argument_list|)
expr_stmt|;
name|PF
argument_list|(
literal|0x200
argument_list|,
literal|"debugging information removed"
argument_list|)
expr_stmt|;
name|PF
argument_list|(
literal|0x1000
argument_list|,
literal|"system file"
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|F_DLL
argument_list|,
literal|"DLL"
argument_list|)
expr_stmt|;
name|PF
argument_list|(
literal|0x8000
argument_list|,
literal|"big endian"
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|PF
comment|/* ctime implies '\n'.  */
block|{
name|time_t
name|t
init|=
name|pe
operator|->
name|coff
operator|.
name|timestamp
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\nTime/Date\t\t%s"
argument_list|,
name|ctime
argument_list|(
operator|&
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\nImageBase\t\t"
argument_list|)
expr_stmt|;
name|fprintf_vma
argument_list|(
name|file
argument_list|,
name|i
operator|->
name|ImageBase
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\nSectionAlignment\t"
argument_list|)
expr_stmt|;
name|fprintf_vma
argument_list|(
name|file
argument_list|,
name|i
operator|->
name|SectionAlignment
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\nFileAlignment\t\t"
argument_list|)
expr_stmt|;
name|fprintf_vma
argument_list|(
name|file
argument_list|,
name|i
operator|->
name|FileAlignment
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\nMajorOSystemVersion\t%d\n"
argument_list|,
name|i
operator|->
name|MajorOperatingSystemVersion
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"MinorOSystemVersion\t%d\n"
argument_list|,
name|i
operator|->
name|MinorOperatingSystemVersion
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"MajorImageVersion\t%d\n"
argument_list|,
name|i
operator|->
name|MajorImageVersion
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"MinorImageVersion\t%d\n"
argument_list|,
name|i
operator|->
name|MinorImageVersion
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"MajorSubsystemVersion\t%d\n"
argument_list|,
name|i
operator|->
name|MajorSubsystemVersion
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"MinorSubsystemVersion\t%d\n"
argument_list|,
name|i
operator|->
name|MinorSubsystemVersion
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Win32Version\t\t%08lx\n"
argument_list|,
name|i
operator|->
name|Reserved1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"SizeOfImage\t\t%08lx\n"
argument_list|,
name|i
operator|->
name|SizeOfImage
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"SizeOfHeaders\t\t%08lx\n"
argument_list|,
name|i
operator|->
name|SizeOfHeaders
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"CheckSum\t\t%08lx\n"
argument_list|,
name|i
operator|->
name|CheckSum
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|i
operator|->
name|Subsystem
condition|)
block|{
case|case
name|IMAGE_SUBSYSTEM_UNKNOWN
case|:
name|subsystem_name
operator|=
literal|"unspecified"
expr_stmt|;
break|break;
case|case
name|IMAGE_SUBSYSTEM_NATIVE
case|:
name|subsystem_name
operator|=
literal|"NT native"
expr_stmt|;
break|break;
case|case
name|IMAGE_SUBSYSTEM_WINDOWS_GUI
case|:
name|subsystem_name
operator|=
literal|"Windows GUI"
expr_stmt|;
break|break;
case|case
name|IMAGE_SUBSYSTEM_WINDOWS_CUI
case|:
name|subsystem_name
operator|=
literal|"Windows CUI"
expr_stmt|;
break|break;
case|case
name|IMAGE_SUBSYSTEM_POSIX_CUI
case|:
name|subsystem_name
operator|=
literal|"POSIX CUI"
expr_stmt|;
break|break;
case|case
name|IMAGE_SUBSYSTEM_WINDOWS_CE_GUI
case|:
name|subsystem_name
operator|=
literal|"Wince CUI"
expr_stmt|;
break|break;
case|case
name|IMAGE_SUBSYSTEM_EFI_APPLICATION
case|:
name|subsystem_name
operator|=
literal|"EFI application"
expr_stmt|;
break|break;
case|case
name|IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER
case|:
name|subsystem_name
operator|=
literal|"EFI boot service driver"
expr_stmt|;
break|break;
case|case
name|IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER
case|:
name|subsystem_name
operator|=
literal|"EFI runtime driver"
expr_stmt|;
break|break;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Subsystem\t\t%08x"
argument_list|,
name|i
operator|->
name|Subsystem
argument_list|)
expr_stmt|;
if|if
condition|(
name|subsystem_name
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t(%s)"
argument_list|,
name|subsystem_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\nDllCharacteristics\t%08x\n"
argument_list|,
name|i
operator|->
name|DllCharacteristics
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"SizeOfStackReserve\t"
argument_list|)
expr_stmt|;
name|fprintf_vma
argument_list|(
name|file
argument_list|,
name|i
operator|->
name|SizeOfStackReserve
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\nSizeOfStackCommit\t"
argument_list|)
expr_stmt|;
name|fprintf_vma
argument_list|(
name|file
argument_list|,
name|i
operator|->
name|SizeOfStackCommit
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\nSizeOfHeapReserve\t"
argument_list|)
expr_stmt|;
name|fprintf_vma
argument_list|(
name|file
argument_list|,
name|i
operator|->
name|SizeOfHeapReserve
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\nSizeOfHeapCommit\t"
argument_list|)
expr_stmt|;
name|fprintf_vma
argument_list|(
name|file
argument_list|,
name|i
operator|->
name|SizeOfHeapCommit
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\nLoaderFlags\t\t%08lx\n"
argument_list|,
name|i
operator|->
name|LoaderFlags
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"NumberOfRvaAndSizes\t%08lx\n"
argument_list|,
name|i
operator|->
name|NumberOfRvaAndSizes
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\nThe Data Directory\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|IMAGE_NUMBEROF_DIRECTORY_ENTRIES
condition|;
name|j
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Entry %1x "
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|fprintf_vma
argument_list|(
name|file
argument_list|,
name|i
operator|->
name|DataDirectory
index|[
name|j
index|]
operator|.
name|VirtualAddress
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %08lx "
argument_list|,
name|i
operator|->
name|DataDirectory
index|[
name|j
index|]
operator|.
name|Size
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s\n"
argument_list|,
name|dir_names
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
name|pe_print_idata
argument_list|(
name|abfd
argument_list|,
name|vfile
argument_list|)
expr_stmt|;
name|pe_print_edata
argument_list|(
name|abfd
argument_list|,
name|vfile
argument_list|)
expr_stmt|;
name|pe_print_pdata
argument_list|(
name|abfd
argument_list|,
name|vfile
argument_list|)
expr_stmt|;
name|pe_print_reloc
argument_list|(
name|abfd
argument_list|,
name|vfile
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Copy any private info we understand from the input bfd    to the output bfd.  */
end_comment

begin_function
name|boolean
name|_bfd_XX_bfd_copy_private_bfd_data_common
parameter_list|(
name|ibfd
parameter_list|,
name|obfd
parameter_list|)
name|bfd
modifier|*
name|ibfd
decl_stmt|,
decl|*
name|obfd
decl_stmt|;
end_function

begin_block
block|{
comment|/* One day we may try to grok other private data.  */
if|if
condition|(
name|ibfd
operator|->
name|xvec
operator|->
name|flavour
operator|!=
name|bfd_target_coff_flavour
operator|||
name|obfd
operator|->
name|xvec
operator|->
name|flavour
operator|!=
name|bfd_target_coff_flavour
condition|)
return|return
name|true
return|;
name|pe_data
argument_list|(
name|obfd
argument_list|)
operator|->
name|pe_opthdr
operator|=
name|pe_data
argument_list|(
name|ibfd
argument_list|)
operator|->
name|pe_opthdr
expr_stmt|;
name|pe_data
argument_list|(
name|obfd
argument_list|)
operator|->
name|dll
operator|=
name|pe_data
argument_list|(
name|ibfd
argument_list|)
operator|->
name|dll
expr_stmt|;
comment|/* For strip: if we removed .reloc, we'll make a real mess of things      if we don't remove this entry as well.  */
if|if
condition|(
operator|!
name|pe_data
argument_list|(
name|obfd
argument_list|)
operator|->
name|has_reloc_section
condition|)
block|{
name|pe_data
argument_list|(
name|obfd
argument_list|)
operator|->
name|pe_opthdr
operator|.
name|DataDirectory
index|[
literal|5
index|]
operator|.
name|VirtualAddress
operator|=
literal|0
expr_stmt|;
name|pe_data
argument_list|(
name|obfd
argument_list|)
operator|->
name|pe_opthdr
operator|.
name|DataDirectory
index|[
literal|5
index|]
operator|.
name|Size
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_block

begin_comment
comment|/* Copy private section data.  */
end_comment

begin_function
name|boolean
name|_bfd_XX_bfd_copy_private_section_data
parameter_list|(
name|ibfd
parameter_list|,
name|isec
parameter_list|,
name|obfd
parameter_list|,
name|osec
parameter_list|)
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|asection
modifier|*
name|isec
decl_stmt|;
name|bfd
modifier|*
name|obfd
decl_stmt|;
name|asection
modifier|*
name|osec
decl_stmt|;
block|{
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|ibfd
argument_list|)
operator|!=
name|bfd_target_coff_flavour
operator|||
name|bfd_get_flavour
argument_list|(
name|obfd
argument_list|)
operator|!=
name|bfd_target_coff_flavour
condition|)
return|return
name|true
return|;
if|if
condition|(
name|coff_section_data
argument_list|(
name|ibfd
argument_list|,
name|isec
argument_list|)
operator|!=
name|NULL
operator|&&
name|pei_section_data
argument_list|(
name|ibfd
argument_list|,
name|isec
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|coff_section_data
argument_list|(
name|obfd
argument_list|,
name|osec
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|coff_section_tdata
argument_list|)
decl_stmt|;
name|osec
operator|->
name|used_by_bfd
operator|=
operator|(
name|PTR
operator|)
name|bfd_zalloc
argument_list|(
name|obfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|osec
operator|->
name|used_by_bfd
operator|==
name|NULL
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|pei_section_data
argument_list|(
name|obfd
argument_list|,
name|osec
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|pei_section_tdata
argument_list|)
decl_stmt|;
name|coff_section_data
argument_list|(
name|obfd
argument_list|,
name|osec
argument_list|)
operator|->
name|tdata
operator|=
operator|(
name|PTR
operator|)
name|bfd_zalloc
argument_list|(
name|obfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|coff_section_data
argument_list|(
name|obfd
argument_list|,
name|osec
argument_list|)
operator|->
name|tdata
operator|==
name|NULL
condition|)
return|return
name|false
return|;
block|}
name|pei_section_data
argument_list|(
name|obfd
argument_list|,
name|osec
argument_list|)
operator|->
name|virt_size
operator|=
name|pei_section_data
argument_list|(
name|ibfd
argument_list|,
name|isec
argument_list|)
operator|->
name|virt_size
expr_stmt|;
name|pei_section_data
argument_list|(
name|obfd
argument_list|,
name|osec
argument_list|)
operator|->
name|pe_flags
operator|=
name|pei_section_data
argument_list|(
name|ibfd
argument_list|,
name|isec
argument_list|)
operator|->
name|pe_flags
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
name|void
name|_bfd_XX_get_symbol_info
parameter_list|(
name|abfd
parameter_list|,
name|symbol
parameter_list|,
name|ret
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|symbol_info
modifier|*
name|ret
decl_stmt|;
block|{
name|coff_get_symbol_info
argument_list|(
name|abfd
argument_list|,
name|symbol
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This code no longer appears to be necessary. 	 ImageBase has already been added in by coff_swap_scnhdr_in.  */
block|if (pe_data (abfd) != NULL&& ((symbol->flags& BSF_DEBUGGING) == 0 	  || (symbol->flags& BSF_DEBUGGING_RELOC) != 0)&& ! bfd_is_abs_section (symbol->section))     ret->value += pe_data (abfd)->pe_opthdr.ImageBase;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Handle the .idata section and other things that need symbol table    access.  */
end_comment

begin_function
name|boolean
name|_bfd_XXi_final_link_postscript
parameter_list|(
name|abfd
parameter_list|,
name|pfinfo
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|coff_final_link_info
modifier|*
name|pfinfo
decl_stmt|;
block|{
name|struct
name|coff_link_hash_entry
modifier|*
name|h1
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
init|=
name|pfinfo
operator|->
name|info
decl_stmt|;
comment|/* There are a few fields that need to be filled in now while we      have symbol table access.       The .idata subsections aren't directly available as sections, but      they are in the symbol table, so get them from there.  */
comment|/* The import directory.  This is the address of .idata$2, with size      of .idata$2 + .idata$3.  */
name|h1
operator|=
name|coff_link_hash_lookup
argument_list|(
name|coff_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
literal|".idata$2"
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|h1
operator|!=
name|NULL
condition|)
block|{
name|pe_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|pe_opthdr
operator|.
name|DataDirectory
index|[
literal|1
index|]
operator|.
name|VirtualAddress
operator|=
operator|(
name|h1
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h1
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h1
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|h1
operator|=
name|coff_link_hash_lookup
argument_list|(
name|coff_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
literal|".idata$4"
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|pe_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|pe_opthdr
operator|.
name|DataDirectory
index|[
literal|1
index|]
operator|.
name|Size
operator|=
operator|(
operator|(
name|h1
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h1
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h1
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
operator|-
name|pe_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|pe_opthdr
operator|.
name|DataDirectory
index|[
literal|1
index|]
operator|.
name|VirtualAddress
operator|)
expr_stmt|;
comment|/* The import address table.  This is the size/address of          .idata$5.  */
name|h1
operator|=
name|coff_link_hash_lookup
argument_list|(
name|coff_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
literal|".idata$5"
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|pe_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|pe_opthdr
operator|.
name|DataDirectory
index|[
literal|12
index|]
operator|.
name|VirtualAddress
operator|=
operator|(
name|h1
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h1
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h1
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|h1
operator|=
name|coff_link_hash_lookup
argument_list|(
name|coff_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
literal|".idata$6"
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|pe_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|pe_opthdr
operator|.
name|DataDirectory
index|[
literal|12
index|]
operator|.
name|Size
operator|=
operator|(
operator|(
name|h1
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h1
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h1
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
operator|-
name|pe_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|pe_opthdr
operator|.
name|DataDirectory
index|[
literal|12
index|]
operator|.
name|VirtualAddress
operator|)
expr_stmt|;
block|}
comment|/* If we couldn't find idata$2, we either have an excessively      trivial program or are in DEEP trouble; we have to assume trivial      program....  */
return|return
name|true
return|;
block|}
end_function

end_unit

