begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ELF core file support for BFD.    Copyright (C) 1995, 1996, 1997 Free Software Foundation, Inc.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Core file support */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_PROCFS_H
end_ifdef

begin_comment
comment|/* Some core file support requires host /proc files */
end_comment

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/procfs.h>
end_include

begin_comment
comment|/* Solaris includes the field pr_who that indicates the thread number within    the process.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PIOCOPENLWP
end_ifdef

begin_define
define|#
directive|define
name|get_thread
parameter_list|(
name|STATUS
parameter_list|)
value|((((prstatus_t *)(STATUS))->pr_who<< 16) \ 			    | ((prstatus_t *)(STATUS))->pr_pid)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|get_thread
parameter_list|(
name|STATUS
parameter_list|)
value|(((prstatus_t *)(STATUS))->pr_pid)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|boolean
name|bfd_prstatus
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|long
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|bfd_prpsinfo
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|bfd_fpregset
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|long
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf_corefile_note
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf_Internal_Phdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|bfd_prstatus
parameter_list|(
name|abfd
parameter_list|,
name|descdata
parameter_list|,
name|descsz
parameter_list|,
name|filepos
parameter_list|,
name|thread
parameter_list|)
value|true
end_define

begin_define
define|#
directive|define
name|bfd_fpregset
parameter_list|(
name|abfd
parameter_list|,
name|descdata
parameter_list|,
name|descsz
parameter_list|,
name|filepos
parameter_list|,
name|thread
parameter_list|)
value|true
end_define

begin_define
define|#
directive|define
name|bfd_prpsinfo
parameter_list|(
name|abfd
parameter_list|,
name|descdata
parameter_list|,
name|descsz
parameter_list|,
name|filepos
parameter_list|)
value|true
end_define

begin_define
define|#
directive|define
name|get_thread
parameter_list|(
name|STATUS
parameter_list|)
value|(1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_PROCFS_H
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|did_reg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|did_reg2
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|boolean
name|bfd_prstatus
parameter_list|(
name|abfd
parameter_list|,
name|descdata
parameter_list|,
name|descsz
parameter_list|,
name|filepos
parameter_list|,
name|thread
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|char
modifier|*
name|descdata
decl_stmt|;
name|int
name|descsz
decl_stmt|;
name|long
name|filepos
decl_stmt|;
name|int
name|thread
decl_stmt|;
block|{
name|asection
modifier|*
name|newsect
decl_stmt|;
name|prstatus_t
modifier|*
name|status
init|=
operator|(
name|prstatus_t
operator|*
operator|)
literal|0
decl_stmt|;
if|if
condition|(
name|descsz
operator|==
sizeof|sizeof
argument_list|(
name|prstatus_t
argument_list|)
condition|)
block|{
name|char
name|secname
index|[
literal|100
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|sprintf
argument_list|(
name|secname
argument_list|,
literal|".reg/%d"
argument_list|,
name|thread
argument_list|)
expr_stmt|;
name|p
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|strlen
argument_list|(
name|secname
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
return|return
name|false
return|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|secname
argument_list|)
expr_stmt|;
name|newsect
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|newsect
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|newsect
operator|->
name|_raw_size
operator|=
sizeof|sizeof
argument_list|(
name|status
operator|->
name|pr_reg
argument_list|)
expr_stmt|;
name|newsect
operator|->
name|filepos
operator|=
name|filepos
operator|+
operator|(
name|long
operator|)
operator|&
name|status
operator|->
name|pr_reg
expr_stmt|;
name|newsect
operator|->
name|flags
operator|=
name|SEC_HAS_CONTENTS
expr_stmt|;
name|newsect
operator|->
name|alignment_power
operator|=
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|core_prstatus
argument_list|(
name|abfd
argument_list|)
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|descsz
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|memcpy
argument_list|(
name|core_prstatus
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|descdata
argument_list|,
name|descsz
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|did_reg
operator|++
condition|)
block|{
name|asection
modifier|*
name|regsect
decl_stmt|;
name|regsect
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".reg"
argument_list|)
expr_stmt|;
if|if
condition|(
name|regsect
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|regsect
operator|->
name|_raw_size
operator|=
name|newsect
operator|->
name|_raw_size
expr_stmt|;
name|regsect
operator|->
name|filepos
operator|=
name|newsect
operator|->
name|filepos
expr_stmt|;
name|regsect
operator|->
name|flags
operator|=
name|newsect
operator|->
name|flags
expr_stmt|;
name|regsect
operator|->
name|alignment_power
operator|=
name|newsect
operator|->
name|alignment_power
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Stash a copy of the prpsinfo structure away for future use. */
end_comment

begin_function
specifier|static
name|boolean
name|bfd_prpsinfo
parameter_list|(
name|abfd
parameter_list|,
name|descdata
parameter_list|,
name|descsz
parameter_list|,
name|filepos
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|char
modifier|*
name|descdata
decl_stmt|;
name|int
name|descsz
decl_stmt|;
name|long
name|filepos
decl_stmt|;
block|{
if|if
condition|(
name|descsz
operator|==
sizeof|sizeof
argument_list|(
name|prpsinfo_t
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|core_prpsinfo
argument_list|(
name|abfd
argument_list|)
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|descsz
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|memcpy
argument_list|(
name|core_prpsinfo
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|descdata
argument_list|,
name|descsz
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|bfd_fpregset
parameter_list|(
name|abfd
parameter_list|,
name|descdata
parameter_list|,
name|descsz
parameter_list|,
name|filepos
parameter_list|,
name|thread
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|char
modifier|*
name|descdata
decl_stmt|;
name|int
name|descsz
decl_stmt|;
name|long
name|filepos
decl_stmt|;
name|int
name|thread
decl_stmt|;
block|{
name|asection
modifier|*
name|newsect
decl_stmt|;
name|char
name|secname
index|[
literal|100
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|sprintf
argument_list|(
name|secname
argument_list|,
literal|".reg2/%d"
argument_list|,
name|thread
argument_list|)
expr_stmt|;
name|p
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|strlen
argument_list|(
name|secname
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
return|return
name|false
return|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|secname
argument_list|)
expr_stmt|;
name|newsect
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|newsect
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|newsect
operator|->
name|_raw_size
operator|=
name|descsz
expr_stmt|;
name|newsect
operator|->
name|filepos
operator|=
name|filepos
expr_stmt|;
name|newsect
operator|->
name|flags
operator|=
name|SEC_HAS_CONTENTS
expr_stmt|;
name|newsect
operator|->
name|alignment_power
operator|=
literal|2
expr_stmt|;
if|if
condition|(
operator|!
name|did_reg2
operator|++
condition|)
block|{
name|asection
modifier|*
name|regsect
decl_stmt|;
name|regsect
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".reg2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|regsect
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|regsect
operator|->
name|_raw_size
operator|=
name|newsect
operator|->
name|_raw_size
expr_stmt|;
name|regsect
operator|->
name|filepos
operator|=
name|newsect
operator|->
name|filepos
expr_stmt|;
name|regsect
operator|->
name|flags
operator|=
name|newsect
operator|->
name|flags
expr_stmt|;
name|regsect
operator|->
name|alignment_power
operator|=
name|newsect
operator|->
name|alignment_power
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SYS_PROCFS_H */
end_comment

begin_comment
comment|/* Return a pointer to the args (including the command name) that were    seen by the program that generated the core dump.  Note that for    some reason, a spurious space is tacked onto the end of the args    in some (at least one anyway) implementations, so strip it off if    it exists. */
end_comment

begin_function
name|char
modifier|*
name|elf_core_file_failing_command
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|HAVE_SYS_PROCFS_H
if|if
condition|(
name|core_prpsinfo
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|prpsinfo_t
modifier|*
name|p
init|=
name|core_prpsinfo
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|char
modifier|*
name|scan
init|=
name|p
operator|->
name|pr_psargs
decl_stmt|;
while|while
condition|(
operator|*
name|scan
operator|++
condition|)
block|{
empty_stmt|;
block|}
name|scan
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|scan
operator|>
name|p
operator|->
name|pr_psargs
operator|)
operator|&&
operator|(
operator|*
name|scan
operator|==
literal|' '
operator|)
condition|)
block|{
operator|*
name|scan
operator|=
literal|'\000'
expr_stmt|;
block|}
return|return
name|p
operator|->
name|pr_psargs
return|;
block|}
endif|#
directive|endif
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return the number of the signal that caused the core dump.  Presumably,    since we have a core file, we got a signal of some kind, so don't bother    checking the other process status fields, just return the signal number.    */
end_comment

begin_function
name|int
name|elf_core_file_failing_signal
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|HAVE_SYS_PROCFS_H
if|if
condition|(
name|core_prstatus
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
return|return
operator|(
operator|(
name|prstatus_t
operator|*
operator|)
operator|(
name|core_prstatus
argument_list|(
name|abfd
argument_list|)
operator|)
operator|)
operator|->
name|pr_cursig
return|;
block|}
endif|#
directive|endif
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Check to see if the core file could reasonably be expected to have    come for the current executable file.  Note that by default we return    true unless we find something that indicates that there might be a    problem.    */
end_comment

begin_function
name|boolean
name|elf_core_file_matches_executable_p
parameter_list|(
name|core_bfd
parameter_list|,
name|exec_bfd
parameter_list|)
name|bfd
modifier|*
name|core_bfd
decl_stmt|;
name|bfd
modifier|*
name|exec_bfd
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|HAVE_SYS_PROCFS_H
name|char
modifier|*
name|corename
decl_stmt|;
name|char
modifier|*
name|execname
decl_stmt|;
endif|#
directive|endif
comment|/* First, xvecs must match since both are ELF files for the same target. */
if|if
condition|(
name|core_bfd
operator|->
name|xvec
operator|!=
name|exec_bfd
operator|->
name|xvec
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
ifdef|#
directive|ifdef
name|HAVE_SYS_PROCFS_H
comment|/* If no prpsinfo, just return true.  Otherwise, grab the last component      of the exec'd pathname from the prpsinfo. */
if|if
condition|(
name|core_prpsinfo
argument_list|(
name|core_bfd
argument_list|)
condition|)
block|{
name|corename
operator|=
operator|(
operator|(
operator|(
name|prpsinfo_t
operator|*
operator|)
name|core_prpsinfo
argument_list|(
name|core_bfd
argument_list|)
operator|)
operator|->
name|pr_fname
operator|)
expr_stmt|;
block|}
else|else
block|{
return|return
name|true
return|;
block|}
comment|/* Find the last component of the executable pathname. */
if|if
condition|(
operator|(
name|execname
operator|=
name|strrchr
argument_list|(
name|exec_bfd
operator|->
name|filename
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|execname
operator|++
expr_stmt|;
block|}
else|else
block|{
name|execname
operator|=
operator|(
name|char
operator|*
operator|)
name|exec_bfd
operator|->
name|filename
expr_stmt|;
block|}
comment|/* See if they match */
return|return
name|strcmp
argument_list|(
name|execname
argument_list|,
name|corename
argument_list|)
condition|?
name|false
else|:
name|true
return|;
else|#
directive|else
return|return
name|true
return|;
endif|#
directive|endif
comment|/* HAVE_SYS_PROCFS_H */
block|}
end_function

begin_comment
comment|/* ELF core files contain a segment of type PT_NOTE, that holds much of    the information that would normally be available from the /proc interface    for the process, at the time the process dumped core.  Currently this    includes copies of the prstatus, prpsinfo, and fpregset structures.     Since these structures are potentially machine dependent in size and    ordering, bfd provides two levels of support for them.  The first level,    available on all machines since it does not require that the host    have /proc support or the relevant include files, is to create a bfd    section for each of the prstatus, prpsinfo, and fpregset structures,    without any interpretation of their contents.  With just this support,    the bfd client will have to interpret the structures itself.  Even with    /proc support, it might want these full structures for it's own reasons.     In the second level of support, where HAVE_SYS_PROCFS_H is defined,    bfd will pick apart the structures to gather some additional    information that clients may want, such as the general register    set, the name of the exec'ed file and its arguments, the signal (if    any) that caused the core dump, etc.     */
end_comment

begin_function
specifier|static
name|boolean
name|elf_corefile_note
parameter_list|(
name|abfd
parameter_list|,
name|hdr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|Elf_Internal_Phdr
modifier|*
name|hdr
decl_stmt|;
block|{
name|Elf_External_Note
modifier|*
name|x_note_p
decl_stmt|;
comment|/* Elf note, external form */
name|Elf_Internal_Note
name|i_note
decl_stmt|;
comment|/* Elf note, internal form */
name|char
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
comment|/* Entire note segment contents */
name|char
modifier|*
name|namedata
decl_stmt|;
comment|/* Name portion of the note */
name|char
modifier|*
name|descdata
decl_stmt|;
comment|/* Descriptor portion of the note */
name|char
modifier|*
name|sectname
decl_stmt|;
comment|/* Name to use for new section */
name|long
name|filepos
decl_stmt|;
comment|/* File offset to descriptor data */
name|asection
modifier|*
name|newsect
decl_stmt|;
name|int
name|thread
init|=
literal|1
decl_stmt|;
comment|/* Current thread number */
ifdef|#
directive|ifdef
name|HAVE_SYS_PROCFS_H
name|did_reg
operator|=
literal|0
expr_stmt|;
comment|/* Non-zero if we made .reg section */
name|did_reg2
operator|=
literal|0
expr_stmt|;
comment|/* Ditto for .reg2 */
endif|#
directive|endif
if|if
condition|(
name|hdr
operator|->
name|p_filesz
operator|>
literal|0
operator|&&
operator|(
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_malloc
argument_list|(
operator|(
name|size_t
operator|)
name|hdr
operator|->
name|p_filesz
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|p_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
operator|-
literal|1
operator|&&
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|buf
argument_list|,
name|hdr
operator|->
name|p_filesz
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|==
name|hdr
operator|->
name|p_filesz
condition|)
block|{
name|x_note_p
operator|=
operator|(
name|Elf_External_Note
operator|*
operator|)
name|buf
expr_stmt|;
while|while
condition|(
operator|(
name|char
operator|*
operator|)
name|x_note_p
operator|<
operator|(
name|buf
operator|+
name|hdr
operator|->
name|p_filesz
operator|)
condition|)
block|{
name|i_note
operator|.
name|namesz
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|x_note_p
operator|->
name|namesz
argument_list|)
expr_stmt|;
name|i_note
operator|.
name|descsz
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|x_note_p
operator|->
name|descsz
argument_list|)
expr_stmt|;
name|i_note
operator|.
name|type
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|x_note_p
operator|->
name|type
argument_list|)
expr_stmt|;
name|namedata
operator|=
name|x_note_p
operator|->
name|name
expr_stmt|;
name|descdata
operator|=
name|namedata
operator|+
name|BFD_ALIGN
argument_list|(
name|i_note
operator|.
name|namesz
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|filepos
operator|=
name|hdr
operator|->
name|p_offset
operator|+
operator|(
name|descdata
operator|-
name|buf
operator|)
expr_stmt|;
switch|switch
condition|(
name|i_note
operator|.
name|type
condition|)
block|{
case|case
name|NT_PRSTATUS
case|:
comment|/* process descdata as prstatus info */
name|thread
operator|=
name|get_thread
argument_list|(
name|descdata
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_prstatus
argument_list|(
name|abfd
argument_list|,
name|descdata
argument_list|,
name|i_note
operator|.
name|descsz
argument_list|,
name|filepos
argument_list|,
name|thread
argument_list|)
condition|)
return|return
name|false
return|;
name|sectname
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|NT_FPREGSET
case|:
comment|/* process descdata as fpregset info */
if|if
condition|(
operator|!
name|bfd_fpregset
argument_list|(
name|abfd
argument_list|,
name|descdata
argument_list|,
name|i_note
operator|.
name|descsz
argument_list|,
name|filepos
argument_list|,
name|thread
argument_list|)
condition|)
return|return
name|false
return|;
name|sectname
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|NT_PRPSINFO
case|:
comment|/* process descdata as prpsinfo */
if|if
condition|(
operator|!
name|bfd_prpsinfo
argument_list|(
name|abfd
argument_list|,
name|descdata
argument_list|,
name|i_note
operator|.
name|descsz
argument_list|,
name|filepos
argument_list|)
condition|)
return|return
name|false
return|;
name|sectname
operator|=
literal|".prpsinfo"
expr_stmt|;
break|break;
default|default:
comment|/* Unknown descriptor, just ignore it. */
name|sectname
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|sectname
operator|!=
name|NULL
condition|)
block|{
name|newsect
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
name|sectname
argument_list|)
expr_stmt|;
if|if
condition|(
name|newsect
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|newsect
operator|->
name|_raw_size
operator|=
name|i_note
operator|.
name|descsz
expr_stmt|;
name|newsect
operator|->
name|filepos
operator|=
name|filepos
expr_stmt|;
name|newsect
operator|->
name|flags
operator|=
name|SEC_ALLOC
operator||
name|SEC_HAS_CONTENTS
expr_stmt|;
name|newsect
operator|->
name|alignment_power
operator|=
literal|2
expr_stmt|;
block|}
name|x_note_p
operator|=
operator|(
name|Elf_External_Note
operator|*
operator|)
operator|(
name|descdata
operator|+
name|BFD_ALIGN
argument_list|(
name|i_note
operator|.
name|descsz
argument_list|,
literal|4
argument_list|)
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hdr
operator|->
name|p_filesz
operator|>
literal|0
condition|)
block|{
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/*  Core files are simply standard ELF formatted files that partition     the file using the execution view of the file (program header table)     rather than the linking view.  In fact, there is no section header     table in a core file.      The process status information (including the contents of the general     register set) and the floating point register set are stored in a     segment of type PT_NOTE.  We handcraft a couple of extra bfd sections     that allow standard bfd access to the general registers (.reg) and the     floating point registers (.reg2).   */
end_comment

begin_function
specifier|const
name|bfd_target
modifier|*
name|elf_core_file_p
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|Elf_External_Ehdr
name|x_ehdr
decl_stmt|;
comment|/* Elf file header, external form */
name|Elf_Internal_Ehdr
modifier|*
name|i_ehdrp
decl_stmt|;
comment|/* Elf file header, internal form */
name|Elf_External_Phdr
name|x_phdr
decl_stmt|;
comment|/* Program header table entry, external form */
name|Elf_Internal_Phdr
modifier|*
name|i_phdrp
decl_stmt|;
comment|/* Program header table, internal form */
name|unsigned
name|int
name|phindex
decl_stmt|;
name|struct
name|elf_backend_data
modifier|*
name|ebd
decl_stmt|;
comment|/* Read in the ELF header in external format.  */
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|x_ehdr
argument_list|,
sizeof|sizeof
argument_list|(
name|x_ehdr
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|x_ehdr
argument_list|)
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_system_call
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Now check to see if we have a valid ELF file, and one that BFD can      make use of.  The magic number must match, the address size ('class')      and byte-swapping must match our XVEC entry, and it must have a      program header table (FIXME: See comments re segments at top of this      file). */
if|if
condition|(
name|elf_file_p
argument_list|(
operator|&
name|x_ehdr
argument_list|)
operator|==
name|false
condition|)
block|{
name|wrong
label|:
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* FIXME, Check EI_VERSION here !  */
block|{
if|#
directive|if
name|ARCH_SIZE
operator|==
literal|32
name|int
name|desired_address_size
init|=
name|ELFCLASS32
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|ARCH_SIZE
operator|==
literal|64
name|int
name|desired_address_size
init|=
name|ELFCLASS64
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|x_ehdr
operator|.
name|e_ident
index|[
name|EI_CLASS
index|]
operator|!=
name|desired_address_size
condition|)
goto|goto
name|wrong
goto|;
block|}
comment|/* Switch xvec to match the specified byte order.  */
switch|switch
condition|(
name|x_ehdr
operator|.
name|e_ident
index|[
name|EI_DATA
index|]
condition|)
block|{
case|case
name|ELFDATA2MSB
case|:
comment|/* Big-endian */
if|if
condition|(
operator|!
name|bfd_big_endian
argument_list|(
name|abfd
argument_list|)
condition|)
goto|goto
name|wrong
goto|;
break|break;
case|case
name|ELFDATA2LSB
case|:
comment|/* Little-endian */
if|if
condition|(
operator|!
name|bfd_little_endian
argument_list|(
name|abfd
argument_list|)
condition|)
goto|goto
name|wrong
goto|;
break|break;
case|case
name|ELFDATANONE
case|:
comment|/* No data encoding specified */
default|default:
comment|/* Unknown data encoding specified */
goto|goto
name|wrong
goto|;
block|}
comment|/* Allocate an instance of the elf_obj_tdata structure and hook it up to      the tdata pointer in the bfd. */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
expr|struct
name|elf_obj_tdata
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|elf_obj_tdata
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* FIXME, `wrong' returns from this point onward, leak memory.  */
comment|/* Now that we know the byte order, swap in the rest of the header */
name|i_ehdrp
operator|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|elf_swap_ehdr_in
argument_list|(
name|abfd
argument_list|,
operator|&
name|x_ehdr
argument_list|,
name|i_ehdrp
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUG
operator|&
literal|1
name|elf_debug_file
argument_list|(
name|i_ehdrp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ebd
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* Check that the ELF e_machine field matches what this particular      BFD format expects.  */
if|if
condition|(
name|ebd
operator|->
name|elf_machine_code
operator|!=
name|i_ehdrp
operator|->
name|e_machine
operator|&&
operator|(
name|ebd
operator|->
name|elf_machine_alt1
operator|==
literal|0
operator|||
name|i_ehdrp
operator|->
name|e_machine
operator|!=
name|ebd
operator|->
name|elf_machine_alt1
operator|)
operator|&&
operator|(
name|ebd
operator|->
name|elf_machine_alt2
operator|==
literal|0
operator|||
name|i_ehdrp
operator|->
name|e_machine
operator|!=
name|ebd
operator|->
name|elf_machine_alt2
operator|)
condition|)
block|{
specifier|const
name|bfd_target
modifier|*
specifier|const
modifier|*
name|target_ptr
decl_stmt|;
if|if
condition|(
name|ebd
operator|->
name|elf_machine_code
operator|!=
name|EM_NONE
condition|)
goto|goto
name|wrong
goto|;
comment|/* This is the generic ELF target.  Let it match any ELF target 	 for which we do not have a specific backend.  */
for|for
control|(
name|target_ptr
operator|=
name|bfd_target_vector
init|;
operator|*
name|target_ptr
operator|!=
name|NULL
condition|;
name|target_ptr
operator|++
control|)
block|{
name|struct
name|elf_backend_data
modifier|*
name|back
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|target_ptr
operator|)
operator|->
name|flavour
operator|!=
name|bfd_target_elf_flavour
condition|)
continue|continue;
name|back
operator|=
operator|(
expr|struct
name|elf_backend_data
operator|*
operator|)
operator|(
operator|*
name|target_ptr
operator|)
operator|->
name|backend_data
expr_stmt|;
if|if
condition|(
name|back
operator|->
name|elf_machine_code
operator|==
name|i_ehdrp
operator|->
name|e_machine
condition|)
block|{
comment|/* target_ptr is an ELF backend which matches this 		 object file, so reject the generic ELF target.  */
goto|goto
name|wrong
goto|;
block|}
block|}
block|}
comment|/* If there is no program header, or the type is not a core file, then      we are hosed. */
if|if
condition|(
name|i_ehdrp
operator|->
name|e_phoff
operator|==
literal|0
operator|||
name|i_ehdrp
operator|->
name|e_type
operator|!=
name|ET_CORE
condition|)
goto|goto
name|wrong
goto|;
comment|/* Allocate space for a copy of the program header table in      internal form, seek to the program header table in the file,      read it in, and convert it to internal form.  As a simple sanity      check, verify that the what BFD thinks is the size of each program      header table entry actually matches the size recorded in the file. */
if|if
condition|(
name|i_ehdrp
operator|->
name|e_phentsize
operator|!=
sizeof|sizeof
argument_list|(
name|x_phdr
argument_list|)
condition|)
goto|goto
name|wrong
goto|;
name|i_phdrp
operator|=
operator|(
name|Elf_Internal_Phdr
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|i_phdrp
argument_list|)
operator|*
name|i_ehdrp
operator|->
name|e_phnum
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|i_phdrp
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|i_ehdrp
operator|->
name|e_phoff
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|phindex
operator|=
literal|0
init|;
name|phindex
operator|<
name|i_ehdrp
operator|->
name|e_phnum
condition|;
name|phindex
operator|++
control|)
block|{
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|x_phdr
argument_list|,
sizeof|sizeof
argument_list|(
name|x_phdr
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|x_phdr
argument_list|)
condition|)
return|return
name|NULL
return|;
name|elf_swap_phdr_in
argument_list|(
name|abfd
argument_list|,
operator|&
name|x_phdr
argument_list|,
name|i_phdrp
operator|+
name|phindex
argument_list|)
expr_stmt|;
block|}
comment|/* Once all of the program headers have been read and converted, we      can start processing them. */
for|for
control|(
name|phindex
operator|=
literal|0
init|;
name|phindex
operator|<
name|i_ehdrp
operator|->
name|e_phnum
condition|;
name|phindex
operator|++
control|)
block|{
name|bfd_section_from_phdr
argument_list|(
name|abfd
argument_list|,
name|i_phdrp
operator|+
name|phindex
argument_list|,
name|phindex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i_phdrp
operator|+
name|phindex
operator|)
operator|->
name|p_type
operator|==
name|PT_NOTE
condition|)
block|{
if|if
condition|(
operator|!
name|elf_corefile_note
argument_list|(
name|abfd
argument_list|,
name|i_phdrp
operator|+
name|phindex
argument_list|)
condition|)
return|return
name|NULL
return|;
block|}
block|}
comment|/* Remember the entry point specified in the ELF file header. */
name|bfd_get_start_address
argument_list|(
name|abfd
argument_list|)
operator|=
name|i_ehdrp
operator|->
name|e_entry
expr_stmt|;
return|return
name|abfd
operator|->
name|xvec
return|;
block|}
end_function

end_unit

