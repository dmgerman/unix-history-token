begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ELF core file support for BFD.    Copyright 1995, 1996, 1997, 1998, 2000, 2001    Free Software Foundation, Inc.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_function
name|char
modifier|*
name|elf_core_file_failing_command
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
return|return
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_command
return|;
block|}
end_function

begin_function
name|int
name|elf_core_file_failing_signal
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
return|return
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_signal
return|;
block|}
end_function

begin_function
name|boolean
name|elf_core_file_matches_executable_p
parameter_list|(
name|core_bfd
parameter_list|,
name|exec_bfd
parameter_list|)
name|bfd
modifier|*
name|core_bfd
decl_stmt|;
name|bfd
modifier|*
name|exec_bfd
decl_stmt|;
block|{
name|char
modifier|*
name|corename
decl_stmt|;
comment|/* xvecs must match if both are ELF files for the same target.  */
if|if
condition|(
name|core_bfd
operator|->
name|xvec
operator|!=
name|exec_bfd
operator|->
name|xvec
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* See if the name in the corefile matches the executable name.  */
name|corename
operator|=
name|elf_tdata
argument_list|(
name|core_bfd
argument_list|)
operator|->
name|core_program
expr_stmt|;
if|if
condition|(
name|corename
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|execname
init|=
name|strrchr
argument_list|(
name|exec_bfd
operator|->
name|filename
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
name|execname
operator|=
name|execname
condition|?
name|execname
operator|+
literal|1
else|:
name|exec_bfd
operator|->
name|filename
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|execname
argument_list|,
name|corename
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/*  Core files are simply standard ELF formatted files that partition     the file using the execution view of the file (program header table)     rather than the linking view.  In fact, there is no section header     table in a core file.      The process status information (including the contents of the general     register set) and the floating point register set are stored in a     segment of type PT_NOTE.  We handcraft a couple of extra bfd sections     that allow standard bfd access to the general registers (.reg) and the     floating point registers (.reg2).   */
end_comment

begin_function
specifier|const
name|bfd_target
modifier|*
name|elf_core_file_p
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|Elf_External_Ehdr
name|x_ehdr
decl_stmt|;
comment|/* Elf file header, external form */
name|Elf_Internal_Ehdr
modifier|*
name|i_ehdrp
decl_stmt|;
comment|/* Elf file header, internal form */
name|Elf_Internal_Phdr
modifier|*
name|i_phdrp
init|=
name|NULL
decl_stmt|;
comment|/* Elf program header, internal form */
name|unsigned
name|int
name|phindex
decl_stmt|;
name|struct
name|elf_backend_data
modifier|*
name|ebd
decl_stmt|;
name|struct
name|elf_obj_tdata
modifier|*
name|preserved_tdata
init|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|struct
name|elf_obj_tdata
modifier|*
name|new_tdata
init|=
name|NULL
decl_stmt|;
comment|/* Read in the ELF header in external format.  */
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|x_ehdr
argument_list|,
sizeof|sizeof
argument_list|(
name|x_ehdr
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|x_ehdr
argument_list|)
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_system_call
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Check the magic number.  */
if|if
condition|(
name|elf_file_p
argument_list|(
operator|&
name|x_ehdr
argument_list|)
operator|==
name|false
condition|)
goto|goto
name|wrong
goto|;
comment|/* FIXME: Check EI_VERSION here ! */
comment|/* Check the address size ("class").  */
if|if
condition|(
name|x_ehdr
operator|.
name|e_ident
index|[
name|EI_CLASS
index|]
operator|!=
name|ELFCLASS
condition|)
goto|goto
name|wrong
goto|;
comment|/* Check the byteorder.  */
switch|switch
condition|(
name|x_ehdr
operator|.
name|e_ident
index|[
name|EI_DATA
index|]
condition|)
block|{
case|case
name|ELFDATA2MSB
case|:
comment|/* Big-endian */
if|if
condition|(
operator|!
name|bfd_big_endian
argument_list|(
name|abfd
argument_list|)
condition|)
goto|goto
name|wrong
goto|;
break|break;
case|case
name|ELFDATA2LSB
case|:
comment|/* Little-endian */
if|if
condition|(
operator|!
name|bfd_little_endian
argument_list|(
name|abfd
argument_list|)
condition|)
goto|goto
name|wrong
goto|;
break|break;
default|default:
goto|goto
name|wrong
goto|;
block|}
comment|/* Give abfd an elf_obj_tdata.  */
name|new_tdata
operator|=
operator|(
expr|struct
name|elf_obj_tdata
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|elf_obj_tdata
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_tdata
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|=
name|new_tdata
expr_stmt|;
comment|/* Swap in the rest of the header, now that we have the byte order.  */
name|i_ehdrp
operator|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|elf_swap_ehdr_in
argument_list|(
name|abfd
argument_list|,
operator|&
name|x_ehdr
argument_list|,
name|i_ehdrp
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUG
operator|&
literal|1
name|elf_debug_file
argument_list|(
name|i_ehdrp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ebd
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* Check that the ELF e_machine field matches what this particular      BFD format expects.  */
if|if
condition|(
name|ebd
operator|->
name|elf_machine_code
operator|!=
name|i_ehdrp
operator|->
name|e_machine
operator|&&
operator|(
name|ebd
operator|->
name|elf_machine_alt1
operator|==
literal|0
operator|||
name|i_ehdrp
operator|->
name|e_machine
operator|!=
name|ebd
operator|->
name|elf_machine_alt1
operator|)
operator|&&
operator|(
name|ebd
operator|->
name|elf_machine_alt2
operator|==
literal|0
operator|||
name|i_ehdrp
operator|->
name|e_machine
operator|!=
name|ebd
operator|->
name|elf_machine_alt2
operator|)
condition|)
block|{
specifier|const
name|bfd_target
modifier|*
specifier|const
modifier|*
name|target_ptr
decl_stmt|;
if|if
condition|(
name|ebd
operator|->
name|elf_machine_code
operator|!=
name|EM_NONE
condition|)
goto|goto
name|wrong
goto|;
comment|/* This is the generic ELF target.  Let it match any ELF target 	 for which we do not have a specific backend.  */
for|for
control|(
name|target_ptr
operator|=
name|bfd_target_vector
init|;
operator|*
name|target_ptr
operator|!=
name|NULL
condition|;
name|target_ptr
operator|++
control|)
block|{
name|struct
name|elf_backend_data
modifier|*
name|back
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|target_ptr
operator|)
operator|->
name|flavour
operator|!=
name|bfd_target_elf_flavour
condition|)
continue|continue;
name|back
operator|=
operator|(
expr|struct
name|elf_backend_data
operator|*
operator|)
operator|(
operator|*
name|target_ptr
operator|)
operator|->
name|backend_data
expr_stmt|;
if|if
condition|(
name|back
operator|->
name|elf_machine_code
operator|==
name|i_ehdrp
operator|->
name|e_machine
condition|)
block|{
comment|/* target_ptr is an ELF backend which matches this 		 object file, so reject the generic ELF target.  */
goto|goto
name|wrong
goto|;
block|}
block|}
block|}
comment|/* If there is no program header, or the type is not a core file, then      we are hosed.  */
if|if
condition|(
name|i_ehdrp
operator|->
name|e_phoff
operator|==
literal|0
operator|||
name|i_ehdrp
operator|->
name|e_type
operator|!=
name|ET_CORE
condition|)
goto|goto
name|wrong
goto|;
comment|/* Does BFD's idea of the phdr size match the size      recorded in the file? */
if|if
condition|(
name|i_ehdrp
operator|->
name|e_phentsize
operator|!=
sizeof|sizeof
argument_list|(
name|Elf_External_Phdr
argument_list|)
condition|)
goto|goto
name|wrong
goto|;
comment|/* Move to the start of the program headers.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|i_ehdrp
operator|->
name|e_phoff
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|wrong
goto|;
comment|/* Allocate space for the program headers.  */
name|i_phdrp
operator|=
operator|(
name|Elf_Internal_Phdr
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|i_phdrp
argument_list|)
operator|*
name|i_ehdrp
operator|->
name|e_phnum
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|i_phdrp
condition|)
goto|goto
name|fail
goto|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|phdr
operator|=
name|i_phdrp
expr_stmt|;
comment|/* Read and convert to internal form.  */
for|for
control|(
name|phindex
operator|=
literal|0
init|;
name|phindex
operator|<
name|i_ehdrp
operator|->
name|e_phnum
condition|;
operator|++
name|phindex
control|)
block|{
name|Elf_External_Phdr
name|x_phdr
decl_stmt|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|x_phdr
argument_list|,
sizeof|sizeof
argument_list|(
name|x_phdr
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|x_phdr
argument_list|)
condition|)
goto|goto
name|fail
goto|;
name|elf_swap_phdr_in
argument_list|(
name|abfd
argument_list|,
operator|&
name|x_phdr
argument_list|,
name|i_phdrp
operator|+
name|phindex
argument_list|)
expr_stmt|;
block|}
comment|/* Process each program header.  */
for|for
control|(
name|phindex
operator|=
literal|0
init|;
name|phindex
operator|<
name|i_ehdrp
operator|->
name|e_phnum
condition|;
operator|++
name|phindex
control|)
block|{
if|if
condition|(
operator|!
name|_bfd_elfcore_section_from_phdr
argument_list|(
name|abfd
argument_list|,
name|i_phdrp
operator|+
name|phindex
argument_list|,
name|phindex
argument_list|)
condition|)
goto|goto
name|fail
goto|;
block|}
comment|/* Set the machine architecture.  */
if|if
condition|(
operator|!
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|ebd
operator|->
name|arch
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* It's OK if this fails for the generic target.  */
if|if
condition|(
name|ebd
operator|->
name|elf_machine_code
operator|!=
name|EM_NONE
condition|)
goto|goto
name|fail
goto|;
block|}
comment|/* Save the entry point from the ELF header.  */
name|bfd_get_start_address
argument_list|(
name|abfd
argument_list|)
operator|=
name|i_ehdrp
operator|->
name|e_entry
expr_stmt|;
comment|/* Let the backend double check the format and override global      information.  */
if|if
condition|(
name|ebd
operator|->
name|elf_backend_object_p
condition|)
block|{
if|if
condition|(
call|(
modifier|*
name|ebd
operator|->
name|elf_backend_object_p
call|)
argument_list|(
name|abfd
argument_list|)
operator|==
name|false
condition|)
goto|goto
name|wrong
goto|;
block|}
return|return
name|abfd
operator|->
name|xvec
return|;
name|wrong
label|:
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
name|fail
label|:
if|if
condition|(
name|i_phdrp
operator|!=
name|NULL
condition|)
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|i_phdrp
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_tdata
operator|!=
name|NULL
condition|)
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|new_tdata
argument_list|)
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|=
name|preserved_tdata
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

end_unit

