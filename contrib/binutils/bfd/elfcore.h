begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ELF core file support for BFD.    Copyright 1995, 1996, 1997, 1998, 2000, 2001    Free Software Foundation, Inc.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_function
name|char
modifier|*
name|elf_core_file_failing_command
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
return|return
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_command
return|;
block|}
end_function

begin_function
name|int
name|elf_core_file_failing_signal
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
return|return
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_signal
return|;
block|}
end_function

begin_function
name|boolean
name|elf_core_file_matches_executable_p
parameter_list|(
name|core_bfd
parameter_list|,
name|exec_bfd
parameter_list|)
name|bfd
modifier|*
name|core_bfd
decl_stmt|;
name|bfd
modifier|*
name|exec_bfd
decl_stmt|;
block|{
name|char
modifier|*
name|corename
decl_stmt|;
comment|/* xvecs must match if both are ELF files for the same target.  */
if|if
condition|(
name|core_bfd
operator|->
name|xvec
operator|!=
name|exec_bfd
operator|->
name|xvec
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* See if the name in the corefile matches the executable name.  */
name|corename
operator|=
name|elf_tdata
argument_list|(
name|core_bfd
argument_list|)
operator|->
name|core_program
expr_stmt|;
if|if
condition|(
name|corename
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|execname
init|=
name|strrchr
argument_list|(
name|exec_bfd
operator|->
name|filename
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
name|execname
operator|=
name|execname
condition|?
name|execname
operator|+
literal|1
else|:
name|exec_bfd
operator|->
name|filename
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|execname
argument_list|,
name|corename
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/*  Core files are simply standard ELF formatted files that partition     the file using the execution view of the file (program header table)     rather than the linking view.  In fact, there is no section header     table in a core file.      The process status information (including the contents of the general     register set) and the floating point register set are stored in a     segment of type PT_NOTE.  We handcraft a couple of extra bfd sections     that allow standard bfd access to the general registers (.reg) and the     floating point registers (.reg2).   */
end_comment

begin_function
specifier|const
name|bfd_target
modifier|*
name|elf_core_file_p
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|Elf_External_Ehdr
name|x_ehdr
decl_stmt|;
comment|/* Elf file header, external form */
name|Elf_Internal_Ehdr
modifier|*
name|i_ehdrp
decl_stmt|;
comment|/* Elf file header, internal form */
name|Elf_Internal_Phdr
modifier|*
name|i_phdrp
decl_stmt|;
comment|/* Elf program header, internal form */
name|unsigned
name|int
name|phindex
decl_stmt|;
name|struct
name|elf_backend_data
modifier|*
name|ebd
decl_stmt|;
name|struct
name|bfd_preserve
name|preserve
decl_stmt|;
name|struct
name|elf_obj_tdata
modifier|*
name|new_tdata
init|=
name|NULL
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|preserve
operator|.
name|arch_info
operator|=
name|abfd
operator|->
name|arch_info
expr_stmt|;
comment|/* Read in the ELF header in external format.  */
if|if
condition|(
name|bfd_bread
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|x_ehdr
argument_list|,
operator|(
name|bfd_size_type
operator|)
sizeof|sizeof
argument_list|(
name|x_ehdr
argument_list|)
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|x_ehdr
argument_list|)
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_system_call
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Check the magic number.  */
if|if
condition|(
name|elf_file_p
argument_list|(
operator|&
name|x_ehdr
argument_list|)
operator|==
name|false
condition|)
goto|goto
name|wrong
goto|;
comment|/* FIXME: Check EI_VERSION here ! */
comment|/* Check the address size ("class").  */
if|if
condition|(
name|x_ehdr
operator|.
name|e_ident
index|[
name|EI_CLASS
index|]
operator|!=
name|ELFCLASS
condition|)
goto|goto
name|wrong
goto|;
comment|/* Check the byteorder.  */
switch|switch
condition|(
name|x_ehdr
operator|.
name|e_ident
index|[
name|EI_DATA
index|]
condition|)
block|{
case|case
name|ELFDATA2MSB
case|:
comment|/* Big-endian */
if|if
condition|(
operator|!
name|bfd_big_endian
argument_list|(
name|abfd
argument_list|)
condition|)
goto|goto
name|wrong
goto|;
break|break;
case|case
name|ELFDATA2LSB
case|:
comment|/* Little-endian */
if|if
condition|(
operator|!
name|bfd_little_endian
argument_list|(
name|abfd
argument_list|)
condition|)
goto|goto
name|wrong
goto|;
break|break;
default|default:
goto|goto
name|wrong
goto|;
block|}
comment|/* Give abfd an elf_obj_tdata.  */
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|elf_obj_tdata
argument_list|)
expr_stmt|;
name|new_tdata
operator|=
operator|(
expr|struct
name|elf_obj_tdata
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_tdata
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|preserve
operator|.
name|tdata
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|=
name|new_tdata
expr_stmt|;
comment|/* Clear section information, since there might be a recognized bfd that      we now check if we can replace, and we don't want to append to it.  */
name|preserve
operator|.
name|sections
operator|=
name|abfd
operator|->
name|sections
expr_stmt|;
name|preserve
operator|.
name|section_tail
operator|=
name|abfd
operator|->
name|section_tail
expr_stmt|;
name|preserve
operator|.
name|section_count
operator|=
name|abfd
operator|->
name|section_count
expr_stmt|;
name|preserve
operator|.
name|section_htab
operator|=
name|abfd
operator|->
name|section_htab
expr_stmt|;
name|abfd
operator|->
name|sections
operator|=
name|NULL
expr_stmt|;
name|abfd
operator|->
name|section_tail
operator|=
operator|&
name|abfd
operator|->
name|sections
expr_stmt|;
name|abfd
operator|->
name|section_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_hash_table_init
argument_list|(
operator|&
name|abfd
operator|->
name|section_htab
argument_list|,
name|bfd_section_hash_newfunc
argument_list|)
condition|)
goto|goto
name|fail
goto|;
comment|/* Swap in the rest of the header, now that we have the byte order.  */
name|i_ehdrp
operator|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|elf_swap_ehdr_in
argument_list|(
name|abfd
argument_list|,
operator|&
name|x_ehdr
argument_list|,
name|i_ehdrp
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUG
operator|&
literal|1
name|elf_debug_file
argument_list|(
name|i_ehdrp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ebd
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* Check that the ELF e_machine field matches what this particular      BFD format expects.  */
if|if
condition|(
name|ebd
operator|->
name|elf_machine_code
operator|!=
name|i_ehdrp
operator|->
name|e_machine
operator|&&
operator|(
name|ebd
operator|->
name|elf_machine_alt1
operator|==
literal|0
operator|||
name|i_ehdrp
operator|->
name|e_machine
operator|!=
name|ebd
operator|->
name|elf_machine_alt1
operator|)
operator|&&
operator|(
name|ebd
operator|->
name|elf_machine_alt2
operator|==
literal|0
operator|||
name|i_ehdrp
operator|->
name|e_machine
operator|!=
name|ebd
operator|->
name|elf_machine_alt2
operator|)
condition|)
block|{
specifier|const
name|bfd_target
modifier|*
specifier|const
modifier|*
name|target_ptr
decl_stmt|;
if|if
condition|(
name|ebd
operator|->
name|elf_machine_code
operator|!=
name|EM_NONE
condition|)
goto|goto
name|wrong
goto|;
comment|/* This is the generic ELF target.  Let it match any ELF target 	 for which we do not have a specific backend.  */
for|for
control|(
name|target_ptr
operator|=
name|bfd_target_vector
init|;
operator|*
name|target_ptr
operator|!=
name|NULL
condition|;
name|target_ptr
operator|++
control|)
block|{
name|struct
name|elf_backend_data
modifier|*
name|back
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|target_ptr
operator|)
operator|->
name|flavour
operator|!=
name|bfd_target_elf_flavour
condition|)
continue|continue;
name|back
operator|=
operator|(
expr|struct
name|elf_backend_data
operator|*
operator|)
operator|(
operator|*
name|target_ptr
operator|)
operator|->
name|backend_data
expr_stmt|;
if|if
condition|(
name|back
operator|->
name|elf_machine_code
operator|==
name|i_ehdrp
operator|->
name|e_machine
condition|)
block|{
comment|/* target_ptr is an ELF backend which matches this 		 object file, so reject the generic ELF target.  */
goto|goto
name|wrong
goto|;
block|}
block|}
block|}
comment|/* If there is no program header, or the type is not a core file, then      we are hosed.  */
if|if
condition|(
name|i_ehdrp
operator|->
name|e_phoff
operator|==
literal|0
operator|||
name|i_ehdrp
operator|->
name|e_type
operator|!=
name|ET_CORE
condition|)
goto|goto
name|wrong
goto|;
comment|/* Does BFD's idea of the phdr size match the size      recorded in the file? */
if|if
condition|(
name|i_ehdrp
operator|->
name|e_phentsize
operator|!=
sizeof|sizeof
argument_list|(
name|Elf_External_Phdr
argument_list|)
condition|)
goto|goto
name|wrong
goto|;
comment|/* Move to the start of the program headers.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
name|i_ehdrp
operator|->
name|e_phoff
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|wrong
goto|;
comment|/* Allocate space for the program headers.  */
name|amt
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|i_phdrp
argument_list|)
operator|*
name|i_ehdrp
operator|->
name|e_phnum
expr_stmt|;
name|i_phdrp
operator|=
operator|(
name|Elf_Internal_Phdr
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|i_phdrp
condition|)
goto|goto
name|fail
goto|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|phdr
operator|=
name|i_phdrp
expr_stmt|;
comment|/* Read and convert to internal form.  */
for|for
control|(
name|phindex
operator|=
literal|0
init|;
name|phindex
operator|<
name|i_ehdrp
operator|->
name|e_phnum
condition|;
operator|++
name|phindex
control|)
block|{
name|Elf_External_Phdr
name|x_phdr
decl_stmt|;
if|if
condition|(
name|bfd_bread
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|x_phdr
argument_list|,
operator|(
name|bfd_size_type
operator|)
sizeof|sizeof
argument_list|(
name|x_phdr
argument_list|)
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|x_phdr
argument_list|)
condition|)
goto|goto
name|fail
goto|;
name|elf_swap_phdr_in
argument_list|(
name|abfd
argument_list|,
operator|&
name|x_phdr
argument_list|,
name|i_phdrp
operator|+
name|phindex
argument_list|)
expr_stmt|;
block|}
comment|/* Set the machine architecture.  Do this before processing the      program headers since we need to know the architecture type      when processing the notes of some systems' core files.  */
if|if
condition|(
operator|!
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|ebd
operator|->
name|arch
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* It's OK if this fails for the generic target.  */
if|if
condition|(
name|ebd
operator|->
name|elf_machine_code
operator|!=
name|EM_NONE
condition|)
goto|goto
name|fail
goto|;
block|}
comment|/* Process each program header.  */
for|for
control|(
name|phindex
operator|=
literal|0
init|;
name|phindex
operator|<
name|i_ehdrp
operator|->
name|e_phnum
condition|;
operator|++
name|phindex
control|)
block|{
if|if
condition|(
operator|!
name|bfd_section_from_phdr
argument_list|(
name|abfd
argument_list|,
name|i_phdrp
operator|+
name|phindex
argument_list|,
operator|(
name|int
operator|)
name|phindex
argument_list|)
condition|)
goto|goto
name|fail
goto|;
block|}
comment|/* Save the entry point from the ELF header.  */
name|bfd_get_start_address
argument_list|(
name|abfd
argument_list|)
operator|=
name|i_ehdrp
operator|->
name|e_entry
expr_stmt|;
comment|/* Let the backend double check the format and override global      information.  */
if|if
condition|(
name|ebd
operator|->
name|elf_backend_object_p
condition|)
block|{
if|if
condition|(
call|(
modifier|*
name|ebd
operator|->
name|elf_backend_object_p
call|)
argument_list|(
name|abfd
argument_list|)
operator|==
name|false
condition|)
goto|goto
name|wrong
goto|;
block|}
name|bfd_hash_table_free
argument_list|(
operator|&
name|preserve
operator|.
name|section_htab
argument_list|)
expr_stmt|;
return|return
name|abfd
operator|->
name|xvec
return|;
name|wrong
label|:
comment|/* There is way too much undoing of half-known state here.  The caller,      bfd_check_format_matches, really shouldn't iterate on live bfd's to      check match/no-match like it does.  We have to rely on that a call to      bfd_default_set_arch_mach with the previously known mach, undoes what      was done by the first bfd_default_set_arch_mach (with mach 0) here.      For this to work, only elf-data and the mach may be changed by the      target-specific elf_backend_object_p function.  Note that saving the      whole bfd here and restoring it would be even worse; the first thing      you notice is that the cached bfd file position gets out of sync.  */
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
name|fail
label|:
name|abfd
operator|->
name|arch_info
operator|=
name|preserve
operator|.
name|arch_info
expr_stmt|;
if|if
condition|(
name|new_tdata
operator|!=
name|NULL
condition|)
block|{
comment|/* bfd_release frees all memory more recently bfd_alloc'd than 	 its arg, as well as its arg.  */
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|new_tdata
argument_list|)
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|=
name|preserve
operator|.
name|tdata
expr_stmt|;
name|abfd
operator|->
name|section_htab
operator|=
name|preserve
operator|.
name|section_htab
expr_stmt|;
name|abfd
operator|->
name|sections
operator|=
name|preserve
operator|.
name|sections
expr_stmt|;
name|abfd
operator|->
name|section_tail
operator|=
name|preserve
operator|.
name|section_tail
expr_stmt|;
name|abfd
operator|->
name|section_count
operator|=
name|preserve
operator|.
name|section_count
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

end_unit

