begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD back-end for ARM COFF files.    Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000    Free Software Foundation, Inc.    Written by Cygnus Support.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"coff/arm.h"
end_include

begin_include
include|#
directive|include
file|"coff/internal.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|COFF_WITH_PE
end_ifdef

begin_include
include|#
directive|include
file|"coff/pe.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"libcoff.h"
end_include

begin_comment
comment|/* Macros for manipulation the bits in the flags field of the coff data    structure.  */
end_comment

begin_define
define|#
directive|define
name|APCS_26_FLAG
parameter_list|(
name|abfd
parameter_list|)
value|(coff_data (abfd)->flags& F_APCS_26)
end_define

begin_define
define|#
directive|define
name|APCS_FLOAT_FLAG
parameter_list|(
name|abfd
parameter_list|)
value|(coff_data (abfd)->flags& F_APCS_FLOAT)
end_define

begin_define
define|#
directive|define
name|PIC_FLAG
parameter_list|(
name|abfd
parameter_list|)
value|(coff_data (abfd)->flags& F_PIC)
end_define

begin_define
define|#
directive|define
name|APCS_SET
parameter_list|(
name|abfd
parameter_list|)
value|(coff_data (abfd)->flags& F_APCS_SET)
end_define

begin_define
define|#
directive|define
name|SET_APCS_FLAGS
parameter_list|(
name|abfd
parameter_list|,
name|flgs
parameter_list|)
value|(coff_data (abfd)->flags = \ 					(coff_data (abfd)->flags& ~ (F_APCS_26 | F_APCS_FLOAT | F_PIC)) \ 					 | (flgs | F_APCS_SET))
end_define

begin_define
define|#
directive|define
name|INTERWORK_FLAG
parameter_list|(
name|abfd
parameter_list|)
value|(coff_data (abfd)->flags& F_INTERWORK)
end_define

begin_define
define|#
directive|define
name|INTERWORK_SET
parameter_list|(
name|abfd
parameter_list|)
value|(coff_data (abfd)->flags& F_INTERWORK_SET)
end_define

begin_define
define|#
directive|define
name|SET_INTERWORK_FLAG
parameter_list|(
name|abfd
parameter_list|,
name|flg
parameter_list|)
value|(coff_data (abfd)->flags = \ 					(coff_data (abfd)->flags& ~ F_INTERWORK) \ 					 | (flg | F_INTERWORK_SET))
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|NUM_ELEM
end_ifndef

begin_define
define|#
directive|define
name|NUM_ELEM
parameter_list|(
name|a
parameter_list|)
value|((sizeof (a)) / sizeof ((a)[0]))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
enum|enum
block|{
name|bunknown
block|,
name|b9
block|,
name|b12
block|,
name|b23
block|}
name|thumb_pcrel_branchtype
typedef|;
end_typedef

begin_comment
comment|/* some typedefs for holding instructions */
end_comment

begin_typedef
typedef|typedef
name|unsigned
name|long
name|int
name|insn32
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|short
name|int
name|insn16
typedef|;
end_typedef

begin_comment
comment|/* Forward declarations for stupid compilers.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|coff_arm_relocate_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
expr|struct
name|internal_reloc
operator|*
operator|,
expr|struct
name|internal_syment
operator|*
operator|,
name|asection
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|aoutarm_fix_pcrel_26_done
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|aoutarm_fix_pcrel_26
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|coff_thumb_pcrel_23
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|coff_thumb_pcrel_12
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|coff_thumb_pcrel_9
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|coff_arm_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|coff_arm_adjust_symndx
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
expr|struct
name|internal_reloc
operator|*
operator|,
name|boolean
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
modifier|*
name|coff_arm_rtype_to_howto
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
expr|struct
name|internal_reloc
operator|*
operator|,
expr|struct
name|coff_link_hash_entry
operator|*
operator|,
expr|struct
name|internal_syment
operator|*
operator|,
name|bfd_vma
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|coff_thumb_pcrel_common
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|,
name|thumb_pcrel_branchtype
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|CONST
expr|struct
name|reloc_howto_struct
operator|*
name|coff_arm_reloc_type_lookup
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd_reloc_code_real_type
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|bfd_link_hash_table
modifier|*
name|coff_arm_link_hash_table_create
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|insn32
name|insert_thumb_branch
name|PARAMS
argument_list|(
operator|(
name|insn32
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|coff_link_hash_entry
modifier|*
name|find_thumb_glue
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
name|CONST
name|char
operator|*
operator|,
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|coff_link_hash_entry
modifier|*
name|find_arm_glue
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
name|CONST
name|char
operator|*
operator|,
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|COFF_IMAGE_WITH_PE
end_ifndef

begin_decl_stmt
specifier|static
name|void
name|record_arm_to_thumb_glue
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|coff_link_hash_entry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|record_thumb_to_arm_glue
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|coff_link_hash_entry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|boolean
name|coff_arm_merge_private_bfd_data
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|coff_arm_print_private_bfd_data
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|_bfd_coff_arm_set_private_flags
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|flagword
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|coff_arm_copy_private_bfd_data
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|coff_arm_is_local_label_name
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|coff_arm_link_output_has_begun
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|coff_final_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|coff_arm_final_link_postscript
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|coff_final_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The linker script knows the section names for placement.    The entry_names are used to do simple name mangling on the stubs.    Given a function name, and its type, the stub can be found. The    name can be changed. The only requirement is the %s be present.    */
end_comment

begin_define
define|#
directive|define
name|THUMB2ARM_GLUE_SECTION_NAME
value|".glue_7t"
end_define

begin_define
define|#
directive|define
name|THUMB2ARM_GLUE_ENTRY_NAME
value|"__%s_from_thumb"
end_define

begin_define
define|#
directive|define
name|ARM2THUMB_GLUE_SECTION_NAME
value|".glue_7"
end_define

begin_define
define|#
directive|define
name|ARM2THUMB_GLUE_ENTRY_NAME
value|"__%s_from_arm"
end_define

begin_comment
comment|/* Used by the assembler.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|coff_arm_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|symvalue
name|diff
decl_stmt|;
if|if
condition|(
name|output_bfd
operator|==
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
return|return
name|bfd_reloc_continue
return|;
name|diff
operator|=
name|reloc_entry
operator|->
name|addend
expr_stmt|;
define|#
directive|define
name|DOIT
parameter_list|(
name|x
parameter_list|)
define|\
value|x = ((x& ~howto->dst_mask) | (((x& howto->src_mask) + diff)& howto->dst_mask))
if|if
condition|(
name|diff
operator|!=
literal|0
condition|)
block|{
name|reloc_howto_type
modifier|*
name|howto
init|=
name|reloc_entry
operator|->
name|howto
decl_stmt|;
name|unsigned
name|char
modifier|*
name|addr
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
decl_stmt|;
switch|switch
condition|(
name|howto
operator|->
name|size
condition|)
block|{
case|case
literal|0
case|:
block|{
name|char
name|x
init|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|addr
argument_list|)
decl_stmt|;
name|DOIT
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|x
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|1
case|:
block|{
name|short
name|x
init|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|addr
argument_list|)
decl_stmt|;
name|DOIT
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|x
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
block|{
name|long
name|x
init|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|addr
argument_list|)
decl_stmt|;
name|DOIT
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|x
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Now let bfd_perform_relocation finish everything up.  */
return|return
name|bfd_reloc_continue
return|;
block|}
end_function

begin_comment
comment|/* If USER_LABEL_PREFIX is defined as "_" (see coff_arm_is_local_label_name()    in this file), then TARGET_UNDERSCORE should be defined, otherwise it    should not.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TARGET_UNDERSCORE
end_ifndef

begin_define
define|#
directive|define
name|TARGET_UNDERSCORE
value|'_'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PCRELOFFSET
end_ifndef

begin_define
define|#
directive|define
name|PCRELOFFSET
value|true
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* These most certainly belong somewhere else. Just had to get rid of    the manifest constants in the code.  */
end_comment

begin_define
define|#
directive|define
name|ARM_8
value|0
end_define

begin_define
define|#
directive|define
name|ARM_16
value|1
end_define

begin_define
define|#
directive|define
name|ARM_32
value|2
end_define

begin_define
define|#
directive|define
name|ARM_26
value|3
end_define

begin_define
define|#
directive|define
name|ARM_DISP8
value|4
end_define

begin_define
define|#
directive|define
name|ARM_DISP16
value|5
end_define

begin_define
define|#
directive|define
name|ARM_DISP32
value|6
end_define

begin_define
define|#
directive|define
name|ARM_26D
value|7
end_define

begin_comment
comment|/* 8 is unused */
end_comment

begin_define
define|#
directive|define
name|ARM_NEG16
value|9
end_define

begin_define
define|#
directive|define
name|ARM_NEG32
value|10
end_define

begin_define
define|#
directive|define
name|ARM_RVA32
value|11
end_define

begin_define
define|#
directive|define
name|ARM_THUMB9
value|12
end_define

begin_define
define|#
directive|define
name|ARM_THUMB12
value|13
end_define

begin_define
define|#
directive|define
name|ARM_THUMB23
value|14
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|ARM_WINCE
end_ifdef

begin_undef
undef|#
directive|undef
name|ARM_32
end_undef

begin_undef
undef|#
directive|undef
name|ARM_RVA32
end_undef

begin_undef
undef|#
directive|undef
name|ARM_26
end_undef

begin_undef
undef|#
directive|undef
name|ARM_THUMB12
end_undef

begin_undef
undef|#
directive|undef
name|ARM_26D
end_undef

begin_define
define|#
directive|define
name|ARM_32
value|1
end_define

begin_define
define|#
directive|define
name|ARM_RVA32
value|2
end_define

begin_define
define|#
directive|define
name|ARM_26
value|3
end_define

begin_define
define|#
directive|define
name|ARM_THUMB12
value|4
end_define

begin_define
define|#
directive|define
name|ARM_26D
value|5
end_define

begin_define
define|#
directive|define
name|ARM_SECTION
value|14
end_define

begin_define
define|#
directive|define
name|ARM_SECREL
value|15
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|aoutarm_std_reloc_howto
index|[]
init|=
block|{
comment|/* type              rs size bsz  pcrel bitpos ovrf                     sf name     part_inpl readmask  setmask    pcdone */
ifdef|#
directive|ifdef
name|ARM_WINCE
name|EMPTY_HOWTO
argument_list|(
operator|-
literal|1
argument_list|)
block|,
name|HOWTO
argument_list|(
name|ARM_32
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|coff_arm_reloc
argument_list|,
literal|"ARM_32"
argument_list|,
name|true
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|PCRELOFFSET
argument_list|)
block|,
name|HOWTO
argument_list|(
name|ARM_RVA32
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|coff_arm_reloc
argument_list|,
literal|"ARM_RVA32"
argument_list|,
name|true
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|PCRELOFFSET
argument_list|)
block|,
name|HOWTO
argument_list|(
name|ARM_26
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|24
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
name|aoutarm_fix_pcrel_26
argument_list|,
literal|"ARM_26"
argument_list|,
name|false
argument_list|,
literal|0x00ffffff
argument_list|,
literal|0x00ffffff
argument_list|,
name|PCRELOFFSET
argument_list|)
block|,
name|HOWTO
argument_list|(
name|ARM_THUMB12
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|11
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
name|coff_thumb_pcrel_12
argument_list|,
literal|"ARM_THUMB12"
argument_list|,
name|false
argument_list|,
literal|0x000007ff
argument_list|,
literal|0x000007ff
argument_list|,
name|PCRELOFFSET
argument_list|)
block|,
name|HOWTO
argument_list|(
name|ARM_26D
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|24
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|aoutarm_fix_pcrel_26_done
argument_list|,
literal|"ARM_26D"
argument_list|,
name|true
argument_list|,
literal|0x00ffffff
argument_list|,
literal|0x0
argument_list|,
name|false
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
operator|-
literal|1
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
operator|-
literal|1
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
operator|-
literal|1
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
operator|-
literal|1
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
operator|-
literal|1
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
operator|-
literal|1
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
operator|-
literal|1
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
operator|-
literal|1
argument_list|)
block|,
name|HOWTO
argument_list|(
name|ARM_SECTION
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|coff_arm_reloc
argument_list|,
literal|"ARM_16"
argument_list|,
name|true
argument_list|,
literal|0x0000ffff
argument_list|,
literal|0x0000ffff
argument_list|,
name|PCRELOFFSET
argument_list|)
block|,
name|HOWTO
argument_list|(
name|ARM_SECREL
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|coff_arm_reloc
argument_list|,
literal|"ARM_32"
argument_list|,
name|true
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|PCRELOFFSET
argument_list|)
block|,
else|#
directive|else
comment|/* not ARM_WINCE */
name|HOWTO
argument_list|(
name|ARM_8
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size */
literal|8
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|coff_arm_reloc
argument_list|,
comment|/* special_function */
literal|"ARM_8"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0x000000ff
argument_list|,
comment|/* src_mask */
literal|0x000000ff
argument_list|,
comment|/* dst_mask */
name|PCRELOFFSET
comment|/* pcrel_offset */
argument_list|)
block|,
name|HOWTO
argument_list|(
name|ARM_16
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|coff_arm_reloc
argument_list|,
literal|"ARM_16"
argument_list|,
name|true
argument_list|,
literal|0x0000ffff
argument_list|,
literal|0x0000ffff
argument_list|,
name|PCRELOFFSET
argument_list|)
block|,
name|HOWTO
argument_list|(
name|ARM_32
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|coff_arm_reloc
argument_list|,
literal|"ARM_32"
argument_list|,
name|true
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|PCRELOFFSET
argument_list|)
block|,
name|HOWTO
argument_list|(
name|ARM_26
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|24
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
name|aoutarm_fix_pcrel_26
argument_list|,
literal|"ARM_26"
argument_list|,
name|false
argument_list|,
literal|0x00ffffff
argument_list|,
literal|0x00ffffff
argument_list|,
name|PCRELOFFSET
argument_list|)
block|,
name|HOWTO
argument_list|(
name|ARM_DISP8
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
name|coff_arm_reloc
argument_list|,
literal|"ARM_DISP8"
argument_list|,
name|true
argument_list|,
literal|0x000000ff
argument_list|,
literal|0x000000ff
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|ARM_DISP16
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
name|coff_arm_reloc
argument_list|,
literal|"ARM_DISP16"
argument_list|,
name|true
argument_list|,
literal|0x0000ffff
argument_list|,
literal|0x0000ffff
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|ARM_DISP32
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
name|coff_arm_reloc
argument_list|,
literal|"ARM_DISP32"
argument_list|,
name|true
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|ARM_26D
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|24
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|aoutarm_fix_pcrel_26_done
argument_list|,
literal|"ARM_26D"
argument_list|,
name|true
argument_list|,
literal|0x00ffffff
argument_list|,
literal|0x0
argument_list|,
name|false
argument_list|)
block|,
comment|/* 8 is unused */
name|EMPTY_HOWTO
argument_list|(
operator|-
literal|1
argument_list|)
block|,
name|HOWTO
argument_list|(
name|ARM_NEG16
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
literal|16
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|coff_arm_reloc
argument_list|,
literal|"ARM_NEG16"
argument_list|,
name|true
argument_list|,
literal|0x0000ffff
argument_list|,
literal|0x0000ffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|ARM_NEG32
argument_list|,
literal|0
argument_list|,
operator|-
literal|2
argument_list|,
literal|32
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|coff_arm_reloc
argument_list|,
literal|"ARM_NEG32"
argument_list|,
name|true
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|ARM_RVA32
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|coff_arm_reloc
argument_list|,
literal|"ARM_RVA32"
argument_list|,
name|true
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|PCRELOFFSET
argument_list|)
block|,
name|HOWTO
argument_list|(
name|ARM_THUMB9
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|8
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
name|coff_thumb_pcrel_9
argument_list|,
literal|"ARM_THUMB9"
argument_list|,
name|false
argument_list|,
literal|0x000000ff
argument_list|,
literal|0x000000ff
argument_list|,
name|PCRELOFFSET
argument_list|)
block|,
name|HOWTO
argument_list|(
name|ARM_THUMB12
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|11
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
name|coff_thumb_pcrel_12
argument_list|,
literal|"ARM_THUMB12"
argument_list|,
name|false
argument_list|,
literal|0x000007ff
argument_list|,
literal|0x000007ff
argument_list|,
name|PCRELOFFSET
argument_list|)
block|,
name|HOWTO
argument_list|(
argument|ARM_THUMB23
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|22
argument_list|,
argument|true
argument_list|,
literal|0
argument_list|,
argument|complain_overflow_signed
argument_list|,
argument|coff_thumb_pcrel_23
argument_list|,
literal|"ARM_THUMB23"
argument_list|,
argument|false
argument_list|,
literal|0x07ff07ff
argument_list|,
literal|0x07ff07ff
argument_list|,
argument|PCRELOFFSET
argument_list|)
endif|#
directive|endif
comment|/* not ARM_WINCE */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NUM_RELOCS
value|NUM_ELEM (aoutarm_std_reloc_howto)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|COFF_WITH_PE
end_ifdef

begin_comment
comment|/* Return true if this relocation should    appear in the output .reloc section.  */
end_comment

begin_function
specifier|static
name|boolean
name|in_reloc_p
parameter_list|(
name|abfd
parameter_list|,
name|howto
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
block|{
return|return
operator|!
name|howto
operator|->
name|pc_relative
operator|&&
name|howto
operator|->
name|type
operator|!=
name|ARM_RVA32
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|RTYPE2HOWTO
parameter_list|(
name|cache_ptr
parameter_list|,
name|dst
parameter_list|)
define|\
value|(cache_ptr)->howto =				\     (dst)->r_type< NUM_RELOCS			\     ? aoutarm_std_reloc_howto + (dst)->r_type	\     : NULL
end_define

begin_define
define|#
directive|define
name|coff_rtype_to_howto
value|coff_arm_rtype_to_howto
end_define

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|coff_arm_rtype_to_howto
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|rel
parameter_list|,
name|h
parameter_list|,
name|sym
parameter_list|,
name|addendp
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|rel
decl_stmt|;
name|struct
name|coff_link_hash_entry
modifier|*
name|h
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|internal_syment
modifier|*
name|sym
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd_vma
modifier|*
name|addendp
decl_stmt|;
block|{
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
if|if
condition|(
name|rel
operator|->
name|r_type
operator|>=
name|NUM_RELOCS
condition|)
return|return
name|NULL
return|;
name|howto
operator|=
name|aoutarm_std_reloc_howto
operator|+
name|rel
operator|->
name|r_type
expr_stmt|;
if|if
condition|(
name|rel
operator|->
name|r_type
operator|==
name|ARM_RVA32
condition|)
operator|*
name|addendp
operator|-=
name|pe_data
argument_list|(
name|sec
operator|->
name|output_section
operator|->
name|owner
argument_list|)
operator|->
name|pe_opthdr
operator|.
name|ImageBase
expr_stmt|;
return|return
name|howto
return|;
block|}
end_function

begin_comment
comment|/* Used by the assembler.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|aoutarm_fix_pcrel_26_done
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asymbol
modifier|*
name|symbol
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|PTR
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|input_section
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* This is dead simple at present.  */
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_comment
comment|/* Used by the assembler.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|aoutarm_fix_pcrel_26
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_size_type
name|addr
init|=
name|reloc_entry
operator|->
name|address
decl_stmt|;
name|long
name|target
init|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|addr
argument_list|)
decl_stmt|;
name|bfd_reloc_status_type
name|flag
init|=
name|bfd_reloc_ok
decl_stmt|;
comment|/* If this is an undefined symbol, return error */
if|if
condition|(
name|symbol
operator|->
name|section
operator|==
operator|&
name|bfd_und_section
operator|&&
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_WEAK
operator|)
operator|==
literal|0
condition|)
return|return
name|output_bfd
condition|?
name|bfd_reloc_continue
else|:
name|bfd_reloc_undefined
return|;
comment|/* If the sections are different, and we are doing a partial relocation,      just ignore it for now.  */
if|if
condition|(
name|symbol
operator|->
name|section
operator|->
name|name
operator|!=
name|input_section
operator|->
name|name
operator|&&
name|output_bfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
return|return
name|bfd_reloc_continue
return|;
name|relocation
operator|=
operator|(
name|target
operator|&
literal|0x00ffffff
operator|)
operator|<<
literal|2
expr_stmt|;
name|relocation
operator|=
operator|(
name|relocation
operator|^
literal|0x02000000
operator|)
operator|-
literal|0x02000000
expr_stmt|;
comment|/* Sign extend */
name|relocation
operator|+=
name|symbol
operator|->
name|value
expr_stmt|;
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
name|relocation
operator|+=
name|reloc_entry
operator|->
name|addend
expr_stmt|;
name|relocation
operator|-=
name|input_section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|relocation
operator|-=
name|input_section
operator|->
name|output_offset
expr_stmt|;
name|relocation
operator|-=
name|addr
expr_stmt|;
if|if
condition|(
name|relocation
operator|&
literal|3
condition|)
return|return
name|bfd_reloc_overflow
return|;
comment|/* Check for overflow */
if|if
condition|(
name|relocation
operator|&
literal|0x02000000
condition|)
block|{
if|if
condition|(
operator|(
name|relocation
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
literal|0x03ffffff
operator|)
operator|!=
operator|~
operator|(
name|bfd_vma
operator|)
literal|0x03ffffff
condition|)
name|flag
operator|=
name|bfd_reloc_overflow
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|relocation
operator|&
operator|~
literal|0x03ffffff
condition|)
name|flag
operator|=
name|bfd_reloc_overflow
expr_stmt|;
name|target
operator|&=
operator|~
literal|0x00ffffff
expr_stmt|;
name|target
operator||=
operator|(
name|relocation
operator|>>
literal|2
operator|)
operator|&
literal|0x00ffffff
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|target
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|addr
argument_list|)
expr_stmt|;
comment|/* Now the ARM magic... Change the reloc type so that it is marked as done.      Strictly this is only necessary if we are doing a partial relocation.  */
name|reloc_entry
operator|->
name|howto
operator|=
operator|&
name|aoutarm_std_reloc_howto
index|[
name|ARM_26D
index|]
expr_stmt|;
return|return
name|flag
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_status_type
name|coff_thumb_pcrel_common
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|,
name|btype
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|thumb_pcrel_branchtype
name|btype
decl_stmt|;
block|{
name|bfd_vma
name|relocation
init|=
literal|0
decl_stmt|;
name|bfd_size_type
name|addr
init|=
name|reloc_entry
operator|->
name|address
decl_stmt|;
name|long
name|target
init|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|addr
argument_list|)
decl_stmt|;
name|bfd_reloc_status_type
name|flag
init|=
name|bfd_reloc_ok
decl_stmt|;
name|bfd_vma
name|dstmsk
decl_stmt|;
name|bfd_vma
name|offmsk
decl_stmt|;
name|bfd_vma
name|signbit
decl_stmt|;
comment|/* NOTE: This routine is currently used by GAS, but not by the link      phase.  */
switch|switch
condition|(
name|btype
condition|)
block|{
case|case
name|b9
case|:
name|dstmsk
operator|=
literal|0x000000ff
expr_stmt|;
name|offmsk
operator|=
literal|0x000001fe
expr_stmt|;
name|signbit
operator|=
literal|0x00000100
expr_stmt|;
break|break;
case|case
name|b12
case|:
name|dstmsk
operator|=
literal|0x000007ff
expr_stmt|;
name|offmsk
operator|=
literal|0x00000ffe
expr_stmt|;
name|signbit
operator|=
literal|0x00000800
expr_stmt|;
break|break;
case|case
name|b23
case|:
name|dstmsk
operator|=
literal|0x07ff07ff
expr_stmt|;
name|offmsk
operator|=
literal|0x007fffff
expr_stmt|;
name|signbit
operator|=
literal|0x00400000
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* If this is an undefined symbol, return error */
if|if
condition|(
name|symbol
operator|->
name|section
operator|==
operator|&
name|bfd_und_section
operator|&&
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_WEAK
operator|)
operator|==
literal|0
condition|)
return|return
name|output_bfd
condition|?
name|bfd_reloc_continue
else|:
name|bfd_reloc_undefined
return|;
comment|/* If the sections are different, and we are doing a partial relocation,      just ignore it for now.  */
if|if
condition|(
name|symbol
operator|->
name|section
operator|->
name|name
operator|!=
name|input_section
operator|->
name|name
operator|&&
name|output_bfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
return|return
name|bfd_reloc_continue
return|;
switch|switch
condition|(
name|btype
condition|)
block|{
case|case
name|b9
case|:
case|case
name|b12
case|:
name|relocation
operator|=
operator|(
operator|(
name|target
operator|&
name|dstmsk
operator|)
operator|<<
literal|1
operator|)
expr_stmt|;
break|break;
case|case
name|b23
case|:
if|if
condition|(
name|bfd_big_endian
argument_list|(
name|abfd
argument_list|)
condition|)
name|relocation
operator|=
operator|(
operator|(
name|target
operator|&
literal|0x7ff
operator|)
operator|<<
literal|1
operator|)
operator||
operator|(
operator|(
name|target
operator|&
literal|0x07ff0000
operator|)
operator|>>
literal|4
operator|)
expr_stmt|;
else|else
name|relocation
operator|=
operator|(
operator|(
name|target
operator|&
literal|0x7ff
operator|)
operator|<<
literal|12
operator|)
operator||
operator|(
operator|(
name|target
operator|&
literal|0x07ff0000
operator|)
operator|>>
literal|15
operator|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|relocation
operator|=
operator|(
name|relocation
operator|^
name|signbit
operator|)
operator|-
name|signbit
expr_stmt|;
comment|/* Sign extend */
name|relocation
operator|+=
name|symbol
operator|->
name|value
expr_stmt|;
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
name|relocation
operator|+=
name|reloc_entry
operator|->
name|addend
expr_stmt|;
name|relocation
operator|-=
name|input_section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|relocation
operator|-=
name|input_section
operator|->
name|output_offset
expr_stmt|;
name|relocation
operator|-=
name|addr
expr_stmt|;
if|if
condition|(
name|relocation
operator|&
literal|1
condition|)
return|return
name|bfd_reloc_overflow
return|;
comment|/* Check for overflow */
if|if
condition|(
name|relocation
operator|&
name|signbit
condition|)
block|{
if|if
condition|(
operator|(
name|relocation
operator|&
operator|~
name|offmsk
operator|)
operator|!=
operator|~
name|offmsk
condition|)
name|flag
operator|=
name|bfd_reloc_overflow
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|relocation
operator|&
operator|~
name|offmsk
condition|)
name|flag
operator|=
name|bfd_reloc_overflow
expr_stmt|;
name|target
operator|&=
operator|~
name|dstmsk
expr_stmt|;
switch|switch
condition|(
name|btype
condition|)
block|{
case|case
name|b9
case|:
case|case
name|b12
case|:
name|target
operator||=
operator|(
name|relocation
operator|>>
literal|1
operator|)
expr_stmt|;
break|break;
case|case
name|b23
case|:
if|if
condition|(
name|bfd_big_endian
argument_list|(
name|abfd
argument_list|)
condition|)
name|target
operator||=
operator|(
operator|(
name|relocation
operator|&
literal|0xfff
operator|)
operator|>>
literal|1
operator|)
operator||
operator|(
operator|(
name|relocation
operator|<<
literal|4
operator|)
operator|&
literal|0x07ff0000
operator|)
expr_stmt|;
else|else
name|target
operator||=
operator|(
operator|(
name|relocation
operator|&
literal|0xffe
operator|)
operator|<<
literal|15
operator|)
operator||
operator|(
operator|(
name|relocation
operator|>>
literal|12
operator|)
operator|&
literal|0x7ff
operator|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|target
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|addr
argument_list|)
expr_stmt|;
comment|/* Now the ARM magic... Change the reloc type so that it is marked as done.      Strictly this is only necessary if we are doing a partial relocation.  */
name|reloc_entry
operator|->
name|howto
operator|=
operator|&
name|aoutarm_std_reloc_howto
index|[
name|ARM_26D
index|]
expr_stmt|;
comment|/* TODO: We should possibly have DONE entries for the THUMB PCREL relocations */
return|return
name|flag
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_status_type
name|coff_thumb_pcrel_23
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
block|{
return|return
name|coff_thumb_pcrel_common
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
argument_list|,
name|symbol
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
name|error_message
argument_list|,
name|b23
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_status_type
name|coff_thumb_pcrel_12
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
block|{
return|return
name|coff_thumb_pcrel_common
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
argument_list|,
name|symbol
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
name|error_message
argument_list|,
name|b12
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_status_type
name|coff_thumb_pcrel_9
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
block|{
return|return
name|coff_thumb_pcrel_common
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
argument_list|,
name|symbol
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
name|error_message
argument_list|,
name|b9
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|CONST
expr|struct
name|reloc_howto_struct
operator|*
name|coff_arm_reloc_type_lookup
argument_list|(
argument|abfd
argument_list|,
argument|code
argument_list|)
name|bfd
operator|*
name|abfd
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
end_decl_stmt

begin_block
block|{
define|#
directive|define
name|ASTD
parameter_list|(
name|i
parameter_list|,
name|j
parameter_list|)
value|case i: return aoutarm_std_reloc_howto + j
if|if
condition|(
name|code
operator|==
name|BFD_RELOC_CTOR
condition|)
switch|switch
condition|(
name|bfd_get_arch_info
argument_list|(
name|abfd
argument_list|)
operator|->
name|bits_per_address
condition|)
block|{
case|case
literal|32
case|:
name|code
operator|=
name|BFD_RELOC_32
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|CONST
expr|struct
name|reloc_howto_struct
operator|*
operator|)
literal|0
return|;
block|}
switch|switch
condition|(
name|code
condition|)
block|{
ifdef|#
directive|ifdef
name|ARM_WINCE
name|ASTD
argument_list|(
name|BFD_RELOC_32
argument_list|,
name|ARM_32
argument_list|)
expr_stmt|;
name|ASTD
argument_list|(
name|BFD_RELOC_RVA
argument_list|,
name|ARM_RVA32
argument_list|)
expr_stmt|;
name|ASTD
argument_list|(
name|BFD_RELOC_ARM_PCREL_BRANCH
argument_list|,
name|ARM_26
argument_list|)
expr_stmt|;
name|ASTD
argument_list|(
name|BFD_RELOC_THUMB_PCREL_BRANCH12
argument_list|,
name|ARM_THUMB12
argument_list|)
expr_stmt|;
else|#
directive|else
name|ASTD
argument_list|(
name|BFD_RELOC_8
argument_list|,
name|ARM_8
argument_list|)
expr_stmt|;
name|ASTD
argument_list|(
name|BFD_RELOC_16
argument_list|,
name|ARM_16
argument_list|)
expr_stmt|;
name|ASTD
argument_list|(
name|BFD_RELOC_32
argument_list|,
name|ARM_32
argument_list|)
expr_stmt|;
name|ASTD
argument_list|(
name|BFD_RELOC_ARM_PCREL_BRANCH
argument_list|,
name|ARM_26
argument_list|)
expr_stmt|;
name|ASTD
argument_list|(
name|BFD_RELOC_ARM_PCREL_BLX
argument_list|,
name|ARM_26
argument_list|)
expr_stmt|;
name|ASTD
argument_list|(
name|BFD_RELOC_8_PCREL
argument_list|,
name|ARM_DISP8
argument_list|)
expr_stmt|;
name|ASTD
argument_list|(
name|BFD_RELOC_16_PCREL
argument_list|,
name|ARM_DISP16
argument_list|)
expr_stmt|;
name|ASTD
argument_list|(
name|BFD_RELOC_32_PCREL
argument_list|,
name|ARM_DISP32
argument_list|)
expr_stmt|;
name|ASTD
argument_list|(
name|BFD_RELOC_RVA
argument_list|,
name|ARM_RVA32
argument_list|)
expr_stmt|;
name|ASTD
argument_list|(
name|BFD_RELOC_THUMB_PCREL_BRANCH9
argument_list|,
name|ARM_THUMB9
argument_list|)
expr_stmt|;
name|ASTD
argument_list|(
name|BFD_RELOC_THUMB_PCREL_BRANCH12
argument_list|,
name|ARM_THUMB12
argument_list|)
expr_stmt|;
name|ASTD
argument_list|(
name|BFD_RELOC_THUMB_PCREL_BRANCH23
argument_list|,
name|ARM_THUMB23
argument_list|)
expr_stmt|;
endif|#
directive|endif
default|default:
return|return
operator|(
name|CONST
expr|struct
name|reloc_howto_struct
operator|*
operator|)
literal|0
return|;
block|}
block|}
end_block

begin_define
define|#
directive|define
name|COFF_DEFAULT_SECTION_ALIGNMENT_POWER
value|(2)
end_define

begin_define
define|#
directive|define
name|COFF_PAGE_SIZE
value|0x1000
end_define

begin_comment
comment|/* Turn a howto into a reloc  nunmber */
end_comment

begin_define
define|#
directive|define
name|SELECT_RELOC
parameter_list|(
name|x
parameter_list|,
name|howto
parameter_list|)
value|{ x.r_type = howto->type; }
end_define

begin_define
define|#
directive|define
name|BADMAG
parameter_list|(
name|x
parameter_list|)
value|ARMBADMAG(x)
end_define

begin_define
define|#
directive|define
name|ARM
value|1
end_define

begin_comment
comment|/* Customize coffcode.h */
end_comment

begin_comment
comment|/* Extend the coff_link_hash_table structure with a few ARM specific fields.    This allows us to store global data here without actually creating any    global variables, which is a no-no in the BFD world.  */
end_comment

begin_struct
struct|struct
name|coff_arm_link_hash_table
block|{
comment|/* The original coff_link_hash_table structure.  MUST be first field.  */
name|struct
name|coff_link_hash_table
name|root
decl_stmt|;
comment|/* The size in bytes of the section containg the Thumb-to-ARM glue.  */
name|long
name|int
name|thumb_glue_size
decl_stmt|;
comment|/* The size in bytes of the section containg the ARM-to-Thumb glue.  */
name|long
name|int
name|arm_glue_size
decl_stmt|;
comment|/* An arbitary input BFD chosen to hold the glue sections.  */
name|bfd
modifier|*
name|bfd_of_glue_owner
decl_stmt|;
comment|/* Support interworking with old, non-interworking aware ARM code.  */
name|int
name|support_old_code
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Get the ARM coff linker hash table from a link_info structure.  */
end_comment

begin_define
define|#
directive|define
name|coff_arm_hash_table
parameter_list|(
name|info
parameter_list|)
define|\
value|((struct coff_arm_link_hash_table *) ((info)->hash))
end_define

begin_comment
comment|/* Create an ARM coff linker hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_link_hash_table
modifier|*
name|coff_arm_link_hash_table_create
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|coff_arm_link_hash_table
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
operator|(
operator|(
expr|struct
name|coff_arm_link_hash_table
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|coff_arm_link_hash_table
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|coff_arm_link_hash_table
operator|*
operator|)
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|_bfd_coff_link_hash_table_init
argument_list|(
operator|&
name|ret
operator|->
name|root
argument_list|,
name|abfd
argument_list|,
name|_bfd_coff_link_hash_newfunc
argument_list|)
condition|)
block|{
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|bfd_link_hash_table
operator|*
operator|)
name|NULL
return|;
block|}
name|ret
operator|->
name|thumb_glue_size
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|arm_glue_size
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|bfd_of_glue_owner
operator|=
name|NULL
expr_stmt|;
return|return
operator|&
name|ret
operator|->
name|root
operator|.
name|root
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|arm_emit_base_file_entry
parameter_list|(
name|info
parameter_list|,
name|output_bfd
parameter_list|,
name|input_section
parameter_list|,
name|reloc_offset
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd_vma
name|reloc_offset
decl_stmt|;
block|{
name|bfd_vma
name|addr
init|=
name|reloc_offset
operator|-
name|input_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|input_section
operator|->
name|output_section
operator|->
name|vma
decl_stmt|;
if|if
condition|(
name|coff_data
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|pe
condition|)
name|addr
operator|-=
name|pe_data
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|pe_opthdr
operator|.
name|ImageBase
expr_stmt|;
name|fwrite
argument_list|(
operator|&
name|addr
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|,
operator|(
name|FILE
operator|*
operator|)
name|info
operator|->
name|base_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The thumb form of a long branch is a bit finicky, because the offset    encoding is split over two fields, each in it's own instruction. They    can occur in any order. So given a thumb form of long branch, and an    offset, insert the offset into the thumb branch and return finished    instruction.     It takes two thumb instructions to encode the target address. Each has    11 bits to invest. The upper 11 bits are stored in one (identifed by    H-0.. see below), the lower 11 bits are stored in the other (identified    by H-1).     Combine together and shifted left by 1 (it's a half word address) and    there you have it.       Op: 1111 = F,      H-0, upper address-0 = 000      Op: 1111 = F,      H-1, lower address-0 = 800     They can be ordered either way, but the arm tools I've seen always put    the lower one first. It probably doesn't matter. krk@cygnus.com     XXX:  Actually the order does matter.  The second instruction (H-1)    moves the computed address into the PC, so it must be the second one    in the sequence.  The problem, however is that whilst little endian code    stores the instructions in HI then LOW order, big endian code does the    reverse.  nickc@cygnus.com  */
end_comment

begin_define
define|#
directive|define
name|LOW_HI_ORDER
value|0xF800F000
end_define

begin_define
define|#
directive|define
name|HI_LOW_ORDER
value|0xF000F800
end_define

begin_function
specifier|static
name|insn32
name|insert_thumb_branch
parameter_list|(
name|br_insn
parameter_list|,
name|rel_off
parameter_list|)
name|insn32
name|br_insn
decl_stmt|;
name|int
name|rel_off
decl_stmt|;
block|{
name|unsigned
name|int
name|low_bits
decl_stmt|;
name|unsigned
name|int
name|high_bits
decl_stmt|;
name|BFD_ASSERT
argument_list|(
operator|(
name|rel_off
operator|&
literal|1
operator|)
operator|!=
literal|1
argument_list|)
expr_stmt|;
name|rel_off
operator|>>=
literal|1
expr_stmt|;
comment|/* half word aligned address */
name|low_bits
operator|=
name|rel_off
operator|&
literal|0x000007FF
expr_stmt|;
comment|/* the bottom 11 bits */
name|high_bits
operator|=
operator|(
name|rel_off
operator|>>
literal|11
operator|)
operator|&
literal|0x000007FF
expr_stmt|;
comment|/* the top 11 bits */
if|if
condition|(
operator|(
name|br_insn
operator|&
name|LOW_HI_ORDER
operator|)
operator|==
name|LOW_HI_ORDER
condition|)
name|br_insn
operator|=
name|LOW_HI_ORDER
operator||
operator|(
name|low_bits
operator|<<
literal|16
operator|)
operator||
name|high_bits
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|br_insn
operator|&
name|HI_LOW_ORDER
operator|)
operator|==
name|HI_LOW_ORDER
condition|)
name|br_insn
operator|=
name|HI_LOW_ORDER
operator||
operator|(
name|high_bits
operator|<<
literal|16
operator|)
operator||
name|low_bits
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* error - not a valid branch instruction form */
comment|/* FIXME: abort is probably not the right call. krk@cygnus.com */
return|return
name|br_insn
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|struct
name|coff_link_hash_entry
modifier|*
name|find_thumb_glue
parameter_list|(
name|info
parameter_list|,
name|name
parameter_list|,
name|input_bfd
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|CONST
name|char
modifier|*
name|name
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
block|{
name|char
modifier|*
name|tmp_name
decl_stmt|;
name|struct
name|coff_link_hash_entry
modifier|*
name|myh
decl_stmt|;
name|tmp_name
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|THUMB2ARM_GLUE_ENTRY_NAME
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|tmp_name
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tmp_name
argument_list|,
name|THUMB2ARM_GLUE_ENTRY_NAME
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|myh
operator|=
name|coff_link_hash_lookup
argument_list|(
name|coff_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|tmp_name
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|myh
operator|==
name|NULL
condition|)
comment|/* xgettext:c-format */
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"%s: unable to find THUMB glue '%s' for `%s'"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|tmp_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp_name
argument_list|)
expr_stmt|;
return|return
name|myh
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|coff_link_hash_entry
modifier|*
name|find_arm_glue
parameter_list|(
name|info
parameter_list|,
name|name
parameter_list|,
name|input_bfd
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|CONST
name|char
modifier|*
name|name
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
block|{
name|char
modifier|*
name|tmp_name
decl_stmt|;
name|struct
name|coff_link_hash_entry
modifier|*
name|myh
decl_stmt|;
name|tmp_name
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|ARM2THUMB_GLUE_ENTRY_NAME
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|tmp_name
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tmp_name
argument_list|,
name|ARM2THUMB_GLUE_ENTRY_NAME
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|myh
operator|=
name|coff_link_hash_lookup
argument_list|(
name|coff_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|tmp_name
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|myh
operator|==
name|NULL
condition|)
comment|/* xgettext:c-format */
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"%s: unable to find ARM glue '%s' for `%s'"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|tmp_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp_name
argument_list|)
expr_stmt|;
return|return
name|myh
return|;
block|}
end_function

begin_comment
comment|/*   ARM->Thumb glue:         .arm        __func_from_arm: 	     ldr r12, __func_addr 	     bx  r12        __func_addr:             .word func    @ behave as if you saw a ARM_32 reloc */
end_comment

begin_define
define|#
directive|define
name|ARM2THUMB_GLUE_SIZE
value|12
end_define

begin_decl_stmt
specifier|static
specifier|const
name|insn32
name|a2t1_ldr_insn
init|=
literal|0xe59fc000
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|insn32
name|a2t2_bx_r12_insn
init|=
literal|0xe12fff1c
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|insn32
name|a2t3_func_addr_insn
init|=
literal|0x00000001
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*    Thumb->ARM:				Thumb->(non-interworking aware) ARM     .thumb				.thumb    .align 2				.align 2       __func_from_thumb:		   __func_from_thumb: 	   bx pc				push {r6, lr} 	   nop					ldr  r6, __func_addr    .arm						mov  lr, pc       __func_change_to_arm:			bx   r6 	   b func   			.arm 					   __func_back_to_thumb:    		  				ldmia r13! {r6, lr}    					        bx    lr    					   __func_addr: 					        .word	func */
end_comment

begin_define
define|#
directive|define
name|THUMB2ARM_GLUE_SIZE
value|(globals->support_old_code ? 20 : 8)
end_define

begin_decl_stmt
specifier|static
specifier|const
name|insn16
name|t2a1_bx_pc_insn
init|=
literal|0x4778
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|insn16
name|t2a2_noop_insn
init|=
literal|0x46c0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|insn32
name|t2a3_b_insn
init|=
literal|0xea000000
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|insn16
name|t2a1_push_insn
init|=
literal|0xb540
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|insn16
name|t2a2_ldr_insn
init|=
literal|0x4e03
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|insn16
name|t2a3_mov_insn
init|=
literal|0x46fe
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|insn16
name|t2a4_bx_insn
init|=
literal|0x4730
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|insn32
name|t2a5_pop_insn
init|=
literal|0xe8bd4040
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|insn32
name|t2a6_bx_insn
init|=
literal|0xe12fff1e
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TODO:      We should really create new local (static) symbols in destination      object for each stub we create.  We should also create local      (static) symbols within the stubs when switching between ARM and      Thumb code.  This will ensure that the debugger and disassembler      can present a better view of stubs.       We can treat stubs like literal sections, and for the THUMB9 ones      (short addressing range) we should be able to insert the stubs      between sections. i.e. the simplest approach (since relocations      are done on a section basis) is to dump the stubs at the end of      processing a section. That way we can always try and minimise the      offset to and from a stub. However, this does not map well onto      the way that the linker/BFD does its work: mapping all input      sections to output sections via the linker script before doing      all the processing.       Unfortunately it may be easier to just to disallow short range      Thumb->ARM stubs (i.e. no conditional inter-working branches,      only branch-and-link (BL) calls.  This will simplify the processing      since we can then put all of the stubs into their own section.    TODO:      On a different subject, rather than complaining when a      branch cannot fit in the number of bits available for the      instruction we should generate a trampoline stub (needed to      address the complete 32bit address space).  */
end_comment

begin_comment
comment|/* The standard COFF backend linker does not cope with the special    Thumb BRANCH23 relocation.  The alternative would be to split the    BRANCH23 into seperate HI23 and LO23 relocations. However, it is a    bit simpler simply providing our own relocation driver.  */
end_comment

begin_comment
comment|/* The reloc processing routine for the ARM/Thumb COFF linker.  NOTE:    This code is a very slightly modified copy of    _bfd_coff_generic_relocate_section.  It would be a much more    maintainable solution to have a MACRO that could be expanded within    _bfd_coff_generic_relocate_section that would only be provided for    ARM/Thumb builds.  It is only the code marked THUMBEXTENSION that    is different from the original.  */
end_comment

begin_function
specifier|static
name|boolean
name|coff_arm_relocate_section
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|contents
parameter_list|,
name|relocs
parameter_list|,
name|syms
parameter_list|,
name|sections
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|relocs
decl_stmt|;
name|struct
name|internal_syment
modifier|*
name|syms
decl_stmt|;
name|asection
modifier|*
modifier|*
name|sections
decl_stmt|;
block|{
name|struct
name|internal_reloc
modifier|*
name|rel
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|relend
decl_stmt|;
name|rel
operator|=
name|relocs
expr_stmt|;
name|relend
operator|=
name|rel
operator|+
name|input_section
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|int
name|done
init|=
literal|0
decl_stmt|;
name|long
name|symndx
decl_stmt|;
name|struct
name|coff_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|internal_syment
modifier|*
name|sym
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|bfd_reloc_status_type
name|rstat
decl_stmt|;
name|bfd_vma
name|h_val
decl_stmt|;
name|symndx
operator|=
name|rel
operator|->
name|r_symndx
expr_stmt|;
if|if
condition|(
name|symndx
operator|==
operator|-
literal|1
condition|)
block|{
name|h
operator|=
name|NULL
expr_stmt|;
name|sym
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|h
operator|=
name|obj_coff_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
index|[
name|symndx
index|]
expr_stmt|;
name|sym
operator|=
name|syms
operator|+
name|symndx
expr_stmt|;
block|}
comment|/* COFF treats common symbols in one of two ways.  Either the          size of the symbol is included in the section contents, or it          is not.  We assume that the size is not included, and force          the rtype_to_howto function to adjust the addend as needed.  */
if|if
condition|(
name|sym
operator|!=
name|NULL
operator|&&
name|sym
operator|->
name|n_scnum
operator|!=
literal|0
condition|)
name|addend
operator|=
operator|-
name|sym
operator|->
name|n_value
expr_stmt|;
else|else
name|addend
operator|=
literal|0
expr_stmt|;
name|howto
operator|=
name|coff_rtype_to_howto
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
argument_list|,
name|h
argument_list|,
name|sym
argument_list|,
operator|&
name|addend
argument_list|)
expr_stmt|;
if|if
condition|(
name|howto
operator|==
name|NULL
condition|)
return|return
name|false
return|;
comment|/* The relocation_section function will skip pcrel_offset relocs          when doing a relocateable link.  However, we want to convert          ARM26 to ARM26D relocs if possible.  We return a fake howto in          this case without pcrel_offset set, and adjust the addend to          compensate.  */
if|if
condition|(
name|rel
operator|->
name|r_type
operator|==
name|ARM_26
operator|&&
name|h
operator|!=
name|NULL
operator|&&
name|info
operator|->
name|relocateable
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|==
name|input_section
operator|->
name|output_section
condition|)
block|{
specifier|static
name|reloc_howto_type
name|fake_arm26_reloc
init|=
name|HOWTO
argument_list|(
name|ARM_26
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|24
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
name|aoutarm_fix_pcrel_26
argument_list|,
literal|"ARM_26"
argument_list|,
name|false
argument_list|,
literal|0x00ffffff
argument_list|,
literal|0x00ffffff
argument_list|,
name|false
argument_list|)
decl_stmt|;
name|addend
operator|-=
name|rel
operator|->
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
expr_stmt|;
name|howto
operator|=
operator|&
name|fake_arm26_reloc
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ARM_WINCE
comment|/* MS ARM-CE makes the reloc relative to the opcode's pc, not 	 the next opcode's pc, so is off by one.  */
if|if
condition|(
name|howto
operator|->
name|pc_relative
operator|&&
operator|!
name|info
operator|->
name|relocateable
condition|)
name|addend
operator|-=
literal|8
expr_stmt|;
endif|#
directive|endif
comment|/* If we are doing a relocateable link, then we can just ignore          a PC relative reloc that is pcrel_offset.  It will already          have the correct value.  If this is not a relocateable link,          then we should ignore the symbol value.  */
if|if
condition|(
name|howto
operator|->
name|pc_relative
operator|&&
name|howto
operator|->
name|pcrel_offset
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|relocateable
condition|)
continue|continue;
if|#
directive|if
literal|0
comment|/* We must not ignore the symbol value.  If the symbol is 	  within the same section, the relocation should have already 	  been fixed, but if it is not, we'll be handed a reloc into 	  the beginning of the symbol's section, so we must not cancel 	  out the symbol's value, otherwise we'll be adding it in 	  twice.  */
block|if (sym != NULL&& sym->n_scnum != 0)             addend += sym->n_value;
endif|#
directive|endif
block|}
name|val
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
if|if
condition|(
name|symndx
operator|==
operator|-
literal|1
condition|)
block|{
name|sec
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|sec
operator|=
name|sections
index|[
name|symndx
index|]
expr_stmt|;
name|val
operator|=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|sym
operator|->
name|n_value
operator|-
name|sec
operator|->
name|vma
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|#
directive|if
literal|1
comment|/* THUMBEXTENSION */
comment|/* We don't output the stubs if we are generating a              relocatable output file, since we may as well leave the              stub generation to the final linker pass. If we fail to 	     verify that the name is defined, we'll try to build stubs 	     for an undefined name...  */
if|if
condition|(
operator|!
name|info
operator|->
name|relocateable
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
condition|)
block|{
name|asection
modifier|*
name|h_sec
init|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
decl_stmt|;
comment|/* h locates the symbol referenced in the reloc.  */
name|h_val
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h_sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h_sec
operator|->
name|output_offset
operator|)
expr_stmt|;
if|if
condition|(
name|howto
operator|->
name|type
operator|==
name|ARM_26
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|class
operator|==
name|C_THUMBSTATFUNC
operator|||
name|h
operator|->
name|class
operator|==
name|C_THUMBEXTFUNC
condition|)
block|{
comment|/* Arm code calling a Thumb function */
name|unsigned
name|long
name|int
name|tmp
decl_stmt|;
name|long
name|int
name|my_offset
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|long
name|int
name|ret_offset
decl_stmt|;
name|struct
name|coff_link_hash_entry
modifier|*
name|myh
decl_stmt|;
name|struct
name|coff_arm_link_hash_table
modifier|*
name|globals
decl_stmt|;
name|myh
operator|=
name|find_arm_glue
argument_list|(
name|info
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|myh
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|globals
operator|=
name|coff_arm_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|globals
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|globals
operator|->
name|bfd_of_glue_owner
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|my_offset
operator|=
name|myh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|globals
operator|->
name|bfd_of_glue_owner
argument_list|,
name|ARM2THUMB_GLUE_SECTION_NAME
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|->
name|contents
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|->
name|output_section
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|my_offset
operator|&
literal|0x01
operator|)
operator|==
literal|0x01
condition|)
block|{
if|if
condition|(
name|h_sec
operator|->
name|owner
operator|!=
name|NULL
operator|&&
name|INTERWORK_SET
argument_list|(
name|h_sec
operator|->
name|owner
argument_list|)
operator|&&
operator|!
name|INTERWORK_FLAG
argument_list|(
name|h_sec
operator|->
name|owner
argument_list|)
condition|)
block|{
name|_bfd_error_handler
comment|/* xgettext:c-format */
argument_list|(
name|_
argument_list|(
literal|"%s(%s): warning: interworking not enabled."
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|h_sec
operator|->
name|owner
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|_bfd_error_handler
comment|/* xgettext:c-format */
argument_list|(
name|_
argument_list|(
literal|"  first occurrence: %s: arm call to thumb"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|--
name|my_offset
expr_stmt|;
name|myh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|my_offset
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|a2t1_ldr_insn
argument_list|,
name|s
operator|->
name|contents
operator|+
name|my_offset
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|a2t2_bx_r12_insn
argument_list|,
name|s
operator|->
name|contents
operator|+
name|my_offset
operator|+
literal|4
argument_list|)
expr_stmt|;
comment|/* It's a thumb address.  Add the low order bit.  */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|h_val
operator||
name|a2t3_func_addr_insn
argument_list|,
name|s
operator|->
name|contents
operator|+
name|my_offset
operator|+
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|base_file
condition|)
name|arm_emit_base_file_entry
argument_list|(
name|info
argument_list|,
name|output_bfd
argument_list|,
name|s
argument_list|,
name|my_offset
operator|+
literal|8
argument_list|)
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
name|my_offset
operator|<=
name|globals
operator|->
name|arm_glue_size
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|tmp
operator|&
literal|0xFF000000
expr_stmt|;
comment|/* Somehow these are both 4 too far, so subtract 8.  */
name|ret_offset
operator|=
name|s
operator|->
name|output_offset
operator|+
name|my_offset
operator|+
name|s
operator|->
name|output_section
operator|->
name|vma
operator|-
operator|(
name|input_section
operator|->
name|output_offset
operator|+
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|rel
operator|->
name|r_vaddr
operator|)
operator|-
literal|8
expr_stmt|;
name|tmp
operator|=
name|tmp
operator||
operator|(
operator|(
name|ret_offset
operator|>>
literal|2
operator|)
operator|&
literal|0x00FFFFFF
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|tmp
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
argument_list|)
expr_stmt|;
name|done
operator|=
literal|1
expr_stmt|;
block|}
block|}
ifndef|#
directive|ifndef
name|ARM_WINCE
comment|/* Note: We used to check for ARM_THUMB9 and ARM_THUMB12 */
elseif|else
if|if
condition|(
name|howto
operator|->
name|type
operator|==
name|ARM_THUMB23
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|class
operator|==
name|C_EXT
operator|||
name|h
operator|->
name|class
operator|==
name|C_STAT
operator|||
name|h
operator|->
name|class
operator|==
name|C_LABEL
condition|)
block|{
comment|/* Thumb code calling an ARM function */
name|asection
modifier|*
name|s
init|=
literal|0
decl_stmt|;
name|long
name|int
name|my_offset
decl_stmt|;
name|unsigned
name|long
name|int
name|tmp
decl_stmt|;
name|long
name|int
name|ret_offset
decl_stmt|;
name|struct
name|coff_link_hash_entry
modifier|*
name|myh
decl_stmt|;
name|struct
name|coff_arm_link_hash_table
modifier|*
name|globals
decl_stmt|;
name|myh
operator|=
name|find_thumb_glue
argument_list|(
name|info
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|myh
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|globals
operator|=
name|coff_arm_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|globals
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|globals
operator|->
name|bfd_of_glue_owner
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|my_offset
operator|=
name|myh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|globals
operator|->
name|bfd_of_glue_owner
argument_list|,
name|THUMB2ARM_GLUE_SECTION_NAME
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|->
name|contents
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|->
name|output_section
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|my_offset
operator|&
literal|0x01
operator|)
operator|==
literal|0x01
condition|)
block|{
if|if
condition|(
name|h_sec
operator|->
name|owner
operator|!=
name|NULL
operator|&&
name|INTERWORK_SET
argument_list|(
name|h_sec
operator|->
name|owner
argument_list|)
operator|&&
operator|!
name|INTERWORK_FLAG
argument_list|(
name|h_sec
operator|->
name|owner
argument_list|)
operator|&&
operator|!
name|globals
operator|->
name|support_old_code
condition|)
block|{
name|_bfd_error_handler
comment|/* xgettext:c-format */
argument_list|(
name|_
argument_list|(
literal|"%s(%s): warning: interworking not enabled."
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|h_sec
operator|->
name|owner
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|_bfd_error_handler
comment|/* xgettext:c-format */
argument_list|(
name|_
argument_list|(
literal|"  first occurrence: %s: thumb call to arm"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|)
expr_stmt|;
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"  consider relinking with --support-old-code enabled"
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|--
name|my_offset
expr_stmt|;
name|myh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|my_offset
expr_stmt|;
if|if
condition|(
name|globals
operator|->
name|support_old_code
condition|)
block|{
name|bfd_put_16
argument_list|(
name|output_bfd
argument_list|,
name|t2a1_push_insn
argument_list|,
name|s
operator|->
name|contents
operator|+
name|my_offset
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|output_bfd
argument_list|,
name|t2a2_ldr_insn
argument_list|,
name|s
operator|->
name|contents
operator|+
name|my_offset
operator|+
literal|2
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|output_bfd
argument_list|,
name|t2a3_mov_insn
argument_list|,
name|s
operator|->
name|contents
operator|+
name|my_offset
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|output_bfd
argument_list|,
name|t2a4_bx_insn
argument_list|,
name|s
operator|->
name|contents
operator|+
name|my_offset
operator|+
literal|6
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|t2a5_pop_insn
argument_list|,
name|s
operator|->
name|contents
operator|+
name|my_offset
operator|+
literal|8
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|t2a6_bx_insn
argument_list|,
name|s
operator|->
name|contents
operator|+
name|my_offset
operator|+
literal|12
argument_list|)
expr_stmt|;
comment|/* Store the address of the function in the last word of the stub.  */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|h_val
argument_list|,
name|s
operator|->
name|contents
operator|+
name|my_offset
operator|+
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|base_file
condition|)
name|arm_emit_base_file_entry
argument_list|(
name|info
argument_list|,
name|output_bfd
argument_list|,
name|s
argument_list|,
name|my_offset
operator|+
literal|16
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bfd_put_16
argument_list|(
name|output_bfd
argument_list|,
name|t2a1_bx_pc_insn
argument_list|,
name|s
operator|->
name|contents
operator|+
name|my_offset
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|output_bfd
argument_list|,
name|t2a2_noop_insn
argument_list|,
name|s
operator|->
name|contents
operator|+
name|my_offset
operator|+
literal|2
argument_list|)
expr_stmt|;
name|ret_offset
operator|=
operator|(
operator|(
name|bfd_signed_vma
operator|)
name|h_val
operator|)
comment|/* Address of destination of the stub */
operator|-
operator|(
call|(
name|bfd_signed_vma
call|)
argument_list|(
name|s
operator|->
name|output_offset
comment|/* Offset from the start of the current section to the start of the stubs.  */
operator|+
name|my_offset
comment|/* Offset of the start of this stub from the start of the stubs.  */
operator|+
name|s
operator|->
name|output_section
operator|->
name|vma
argument_list|)
comment|/* Address of the start of the current section.  */
operator|+
literal|4
comment|/* The branch instruction is 4 bytes into the stub.  */
operator|+
literal|8
operator|)
expr_stmt|;
comment|/* ARM branches work from the pc of the instruction + 8.  */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|t2a3_b_insn
operator||
operator|(
operator|(
name|ret_offset
operator|>>
literal|2
operator|)
operator|&
literal|0x00FFFFFF
operator|)
argument_list|,
name|s
operator|->
name|contents
operator|+
name|my_offset
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
name|BFD_ASSERT
argument_list|(
name|my_offset
operator|<=
name|globals
operator|->
name|thumb_glue_size
argument_list|)
expr_stmt|;
comment|/* Now go back and fix up the original BL insn to point 			 to here.  */
name|ret_offset
operator|=
name|s
operator|->
name|output_offset
operator|+
name|my_offset
operator|-
operator|(
name|input_section
operator|->
name|output_offset
operator|+
name|rel
operator|->
name|r_vaddr
operator|)
operator|-
literal|4
expr_stmt|;
name|tmp
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|insert_thumb_branch
argument_list|(
name|tmp
argument_list|,
name|ret_offset
argument_list|)
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
argument_list|)
expr_stmt|;
name|done
operator|=
literal|1
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
comment|/* If the relocation type and destination symbol does not              fall into one of the above categories, then we can just              perform a direct link.  */
if|if
condition|(
name|done
condition|)
name|rstat
operator|=
name|bfd_reloc_ok
expr_stmt|;
elseif|else
endif|#
directive|endif
comment|/* THUMBEXTENSION */
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|sec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|val
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|info
operator|->
name|relocateable
condition|)
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
argument_list|,
name|true
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
block|}
block|}
if|if
condition|(
name|info
operator|->
name|base_file
condition|)
block|{
comment|/* Emit a reloc if the backend thinks it needs it.  */
if|if
condition|(
name|sym
operator|&&
name|pe_data
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|in_reloc_p
argument_list|(
name|output_bfd
argument_list|,
name|howto
argument_list|)
condition|)
name|arm_emit_base_file_entry
argument_list|(
name|info
argument_list|,
name|output_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_vaddr
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|1
comment|/* THUMBEXTENSION */
if|if
condition|(
name|done
condition|)
name|rstat
operator|=
name|bfd_reloc_ok
expr_stmt|;
ifndef|#
directive|ifndef
name|ARM_WINCE
comment|/* Only perform this fix during the final link, not a relocatable link.  nickc@cygnus.com  */
elseif|else
if|if
condition|(
operator|!
name|info
operator|->
name|relocateable
operator|&&
name|howto
operator|->
name|type
operator|==
name|ARM_THUMB23
condition|)
block|{
comment|/* This is pretty much a copy of what the default              _bfd_final_link_relocate and _bfd_relocate_contents              routines do to perform a relocation, with special              processing for the split addressing of the Thumb BL              instruction.  Again, it would probably be simpler adding a              ThumbBRANCH23 specific macro expansion into the default              code.  */
name|bfd_vma
name|address
init|=
name|rel
operator|->
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
decl_stmt|;
if|if
condition|(
name|address
operator|>
name|input_section
operator|->
name|_raw_size
condition|)
name|rstat
operator|=
name|bfd_reloc_outofrange
expr_stmt|;
else|else
block|{
name|bfd_vma
name|relocation
init|=
name|val
operator|+
name|addend
decl_stmt|;
name|int
name|size
init|=
name|bfd_get_reloc_size
argument_list|(
name|howto
argument_list|)
decl_stmt|;
name|boolean
name|overflow
init|=
name|false
decl_stmt|;
name|bfd_byte
modifier|*
name|location
init|=
name|contents
operator|+
name|address
decl_stmt|;
name|bfd_vma
name|x
init|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|location
argument_list|)
decl_stmt|;
name|bfd_vma
name|src_mask
init|=
literal|0x007FFFFE
decl_stmt|;
name|bfd_signed_vma
name|reloc_signed_max
init|=
operator|(
literal|1
operator|<<
operator|(
name|howto
operator|->
name|bitsize
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
decl_stmt|;
name|bfd_signed_vma
name|reloc_signed_min
init|=
operator|~
name|reloc_signed_max
decl_stmt|;
name|bfd_vma
name|check
decl_stmt|;
name|bfd_signed_vma
name|signed_check
decl_stmt|;
name|bfd_vma
name|add
decl_stmt|;
name|bfd_signed_vma
name|signed_add
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|size
operator|==
literal|4
argument_list|)
expr_stmt|;
comment|/* howto->pc_relative should be TRUE for type 14 BRANCH23 */
name|relocation
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
comment|/* howto->pcrel_offset should be TRUE for type 14 BRANCH23 */
name|relocation
operator|-=
name|address
expr_stmt|;
comment|/* No need to negate the relocation with BRANCH23.  */
comment|/* howto->complain_on_overflow == complain_overflow_signed for BRANCH23.  */
comment|/* howto->rightshift == 1 */
comment|/* Drop unwanted bits from the value we are relocating to.  */
name|check
operator|=
name|relocation
operator|>>
name|howto
operator|->
name|rightshift
expr_stmt|;
comment|/* If this is a signed value, the rightshift just dropped 		 leading 1 bits (assuming twos complement).  */
if|if
condition|(
operator|(
name|bfd_signed_vma
operator|)
name|relocation
operator|>=
literal|0
condition|)
name|signed_check
operator|=
name|check
expr_stmt|;
else|else
name|signed_check
operator|=
operator|(
name|check
operator||
operator|(
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|&
operator|~
operator|(
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|>>
name|howto
operator|->
name|rightshift
operator|)
operator|)
operator|)
expr_stmt|;
comment|/* Get the value from the object file.  */
if|if
condition|(
name|bfd_big_endian
argument_list|(
name|input_bfd
argument_list|)
condition|)
block|{
name|add
operator|=
operator|(
operator|(
operator|(
name|x
operator|)
operator|&
literal|0x07ff0000
operator|)
operator|>>
literal|4
operator|)
operator||
operator|(
operator|(
operator|(
name|x
operator|)
operator|&
literal|0x7ff
operator|)
operator|<<
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
name|add
operator|=
operator|(
operator|(
operator|(
operator|(
name|x
operator|)
operator|&
literal|0x7ff
operator|)
operator|<<
literal|12
operator|)
operator||
operator|(
operator|(
operator|(
name|x
operator|)
operator|&
literal|0x07ff0000
operator|)
operator|>>
literal|15
operator|)
operator|)
expr_stmt|;
block|}
comment|/* Get the value from the object file with an appropriate sign. 		 The expression involving howto->src_mask isolates the upper 		 bit of src_mask.  If that bit is set in the value we are 		 adding, it is negative, and we subtract out that number times 		 two.  If src_mask includes the highest possible bit, then we 		 can not get the upper bit, but that does not matter since 		 signed_add needs no adjustment to become negative in that 		 case.  */
name|signed_add
operator|=
name|add
expr_stmt|;
if|if
condition|(
operator|(
name|add
operator|&
operator|(
operator|(
operator|(
operator|~
name|src_mask
operator|)
operator|>>
literal|1
operator|)
operator|&
name|src_mask
operator|)
operator|)
operator|!=
literal|0
condition|)
name|signed_add
operator|-=
operator|(
operator|(
operator|(
operator|~
name|src_mask
operator|)
operator|>>
literal|1
operator|)
operator|&
name|src_mask
operator|)
operator|<<
literal|1
expr_stmt|;
comment|/* Add the value from the object file, shifted so that it is a 		 straight number.  */
comment|/* howto->bitpos == 0 */
name|signed_check
operator|+=
name|signed_add
expr_stmt|;
name|relocation
operator|+=
name|signed_add
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|howto
operator|->
name|complain_on_overflow
operator|==
name|complain_overflow_signed
argument_list|)
expr_stmt|;
comment|/* Assumes two's complement.  */
if|if
condition|(
name|signed_check
operator|>
name|reloc_signed_max
operator|||
name|signed_check
operator|<
name|reloc_signed_min
condition|)
name|overflow
operator|=
name|true
expr_stmt|;
comment|/* Put RELOCATION into the correct bits:  */
if|if
condition|(
name|bfd_big_endian
argument_list|(
name|input_bfd
argument_list|)
condition|)
block|{
name|relocation
operator|=
operator|(
operator|(
operator|(
name|relocation
operator|&
literal|0xffe
operator|)
operator|>>
literal|1
operator|)
operator||
operator|(
operator|(
name|relocation
operator|<<
literal|4
operator|)
operator|&
literal|0x07ff0000
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|relocation
operator|=
operator|(
operator|(
operator|(
name|relocation
operator|&
literal|0xffe
operator|)
operator|<<
literal|15
operator|)
operator||
operator|(
operator|(
name|relocation
operator|>>
literal|12
operator|)
operator|&
literal|0x7ff
operator|)
operator|)
expr_stmt|;
block|}
comment|/* Add RELOCATION to the correct bits of X:  */
name|x
operator|=
operator|(
operator|(
name|x
operator|&
operator|~
name|howto
operator|->
name|dst_mask
operator|)
operator||
name|relocation
operator|)
expr_stmt|;
comment|/* Put the relocated value back in the object file:  */
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|location
argument_list|)
expr_stmt|;
name|rstat
operator|=
name|overflow
condition|?
name|bfd_reloc_overflow
else|:
name|bfd_reloc_ok
expr_stmt|;
block|}
block|}
endif|#
directive|endif
else|else
endif|#
directive|endif
comment|/* THUMBEXTENSION */
name|rstat
operator|=
name|_bfd_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
argument_list|,
name|val
argument_list|,
name|addend
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
comment|/* THUMBEXTENSION */
comment|/* FIXME: 	 Is this the best way to fix up thumb addresses? krk@cygnus.com 	 Probably not, but it works, and if it works it don't need fixing!  nickc@cygnus.com */
comment|/* Only perform this fix during the final link, not a relocatable link.  nickc@cygnus.com  */
if|if
condition|(
operator|!
name|info
operator|->
name|relocateable
operator|&&
operator|(
name|rel
operator|->
name|r_type
operator|==
name|ARM_32
operator|||
name|rel
operator|->
name|r_type
operator|==
name|ARM_RVA32
operator|)
condition|)
block|{
comment|/* Determine if we need to set the bottom bit of a relocated address 	     because the address is the address of a Thumb code symbol.  */
name|int
name|patchit
init|=
name|false
decl_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|class
operator|==
name|C_THUMBSTATFUNC
operator|||
name|h
operator|->
name|class
operator|==
name|C_THUMBEXTFUNC
operator|)
condition|)
block|{
name|patchit
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sym
operator|!=
name|NULL
operator|&&
name|sym
operator|->
name|n_scnum
operator|>
name|N_UNDEF
condition|)
block|{
comment|/* No hash entry - use the symbol instead.  */
if|if
condition|(
name|sym
operator|->
name|n_sclass
operator|==
name|C_THUMBSTATFUNC
operator|||
name|sym
operator|->
name|n_sclass
operator|==
name|C_THUMBEXTFUNC
condition|)
name|patchit
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|patchit
condition|)
block|{
name|bfd_byte
modifier|*
name|location
init|=
name|contents
operator|+
name|rel
operator|->
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
decl_stmt|;
name|bfd_vma
name|x
init|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|location
argument_list|)
decl_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|x
operator||
literal|1
argument_list|,
name|location
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* THUMBEXTENSION */
switch|switch
condition|(
name|rstat
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|bfd_reloc_ok
case|:
break|break;
case|case
name|bfd_reloc_outofrange
case|:
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: bad reloc address 0x%lx in section `%s'"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|rel
operator|->
name|r_vaddr
argument_list|,
name|bfd_get_section_name
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
name|bfd_reloc_overflow
case|:
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|buf
index|[
name|SYMNMLEN
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|symndx
operator|==
operator|-
literal|1
condition|)
name|name
operator|=
literal|"*ABS*"
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
else|else
block|{
name|name
operator|=
name|_bfd_coff_internal_syment_name
argument_list|(
name|input_bfd
argument_list|,
name|sym
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|info
argument_list|,
name|name
argument_list|,
name|howto
operator|->
name|name
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
block|}
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|COFF_IMAGE_WITH_PE
end_ifndef

begin_function
name|boolean
name|bfd_arm_allocate_interworking_sections
parameter_list|(
name|info
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_byte
modifier|*
name|foo
decl_stmt|;
name|struct
name|coff_arm_link_hash_table
modifier|*
name|globals
decl_stmt|;
if|#
directive|if
literal|0
block|static char                       test_char = '1';
endif|#
directive|endif
name|globals
operator|=
name|coff_arm_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|globals
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|globals
operator|->
name|arm_glue_size
operator|!=
literal|0
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|globals
operator|->
name|bfd_of_glue_owner
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|globals
operator|->
name|bfd_of_glue_owner
argument_list|,
name|ARM2THUMB_GLUE_SECTION_NAME
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|foo
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|globals
operator|->
name|bfd_of_glue_owner
argument_list|,
name|globals
operator|->
name|arm_glue_size
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|memset (foo, test_char, globals->arm_glue_size);
endif|#
directive|endif
name|s
operator|->
name|_raw_size
operator|=
name|s
operator|->
name|_cooked_size
operator|=
name|globals
operator|->
name|arm_glue_size
expr_stmt|;
name|s
operator|->
name|contents
operator|=
name|foo
expr_stmt|;
block|}
if|if
condition|(
name|globals
operator|->
name|thumb_glue_size
operator|!=
literal|0
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|globals
operator|->
name|bfd_of_glue_owner
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|globals
operator|->
name|bfd_of_glue_owner
argument_list|,
name|THUMB2ARM_GLUE_SECTION_NAME
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|foo
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|globals
operator|->
name|bfd_of_glue_owner
argument_list|,
name|globals
operator|->
name|thumb_glue_size
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|memset (foo, test_char, globals->thumb_glue_size);
endif|#
directive|endif
name|s
operator|->
name|_raw_size
operator|=
name|s
operator|->
name|_cooked_size
operator|=
name|globals
operator|->
name|thumb_glue_size
expr_stmt|;
name|s
operator|->
name|contents
operator|=
name|foo
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|record_arm_to_thumb_glue
parameter_list|(
name|info
parameter_list|,
name|h
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|coff_link_hash_entry
modifier|*
name|h
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
decl_stmt|;
specifier|register
name|asection
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|tmp_name
decl_stmt|;
name|struct
name|coff_link_hash_entry
modifier|*
name|myh
decl_stmt|;
name|struct
name|coff_arm_link_hash_table
modifier|*
name|globals
decl_stmt|;
name|globals
operator|=
name|coff_arm_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|globals
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|globals
operator|->
name|bfd_of_glue_owner
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|globals
operator|->
name|bfd_of_glue_owner
argument_list|,
name|ARM2THUMB_GLUE_SECTION_NAME
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|tmp_name
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|ARM2THUMB_GLUE_ENTRY_NAME
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|tmp_name
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tmp_name
argument_list|,
name|ARM2THUMB_GLUE_ENTRY_NAME
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|myh
operator|=
name|coff_link_hash_lookup
argument_list|(
name|coff_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|tmp_name
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|myh
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|tmp_name
argument_list|)
expr_stmt|;
return|return;
comment|/* we've already seen this guy */
block|}
comment|/* The only trick here is using globals->arm_glue_size as the value. Even      though the section isn't allocated yet, this is where we will be putting      it.  */
name|bfd_coff_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|globals
operator|->
name|bfd_of_glue_owner
argument_list|,
name|tmp_name
argument_list|,
name|BSF_GLOBAL
argument_list|,
name|s
argument_list|,
name|globals
operator|->
name|arm_glue_size
operator|+
literal|1
argument_list|,
name|NULL
argument_list|,
name|true
argument_list|,
name|false
argument_list|,
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|*
operator|)
operator|&
name|myh
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp_name
argument_list|)
expr_stmt|;
name|globals
operator|->
name|arm_glue_size
operator|+=
name|ARM2THUMB_GLUE_SIZE
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|record_thumb_to_arm_glue
parameter_list|(
name|info
parameter_list|,
name|h
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|coff_link_hash_entry
modifier|*
name|h
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
decl_stmt|;
specifier|register
name|asection
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|tmp_name
decl_stmt|;
name|struct
name|coff_link_hash_entry
modifier|*
name|myh
decl_stmt|;
name|struct
name|coff_arm_link_hash_table
modifier|*
name|globals
decl_stmt|;
name|globals
operator|=
name|coff_arm_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|globals
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|globals
operator|->
name|bfd_of_glue_owner
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|globals
operator|->
name|bfd_of_glue_owner
argument_list|,
name|THUMB2ARM_GLUE_SECTION_NAME
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|tmp_name
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|THUMB2ARM_GLUE_ENTRY_NAME
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|tmp_name
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tmp_name
argument_list|,
name|THUMB2ARM_GLUE_ENTRY_NAME
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|myh
operator|=
name|coff_link_hash_lookup
argument_list|(
name|coff_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|tmp_name
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|myh
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|tmp_name
argument_list|)
expr_stmt|;
return|return;
comment|/* we've already seen this guy */
block|}
name|bfd_coff_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|globals
operator|->
name|bfd_of_glue_owner
argument_list|,
name|tmp_name
argument_list|,
name|BSF_GLOBAL
argument_list|,
name|s
argument_list|,
name|globals
operator|->
name|thumb_glue_size
operator|+
literal|1
argument_list|,
name|NULL
argument_list|,
name|true
argument_list|,
name|false
argument_list|,
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|*
operator|)
operator|&
name|myh
argument_list|)
expr_stmt|;
comment|/* If we mark it 'thumb', the disassembler will do a better job.  */
name|myh
operator|->
name|class
operator|=
name|C_THUMBEXTFUNC
expr_stmt|;
name|free
argument_list|(
name|tmp_name
argument_list|)
expr_stmt|;
comment|/* Allocate another symbol to mark where we switch to arm mode.  */
define|#
directive|define
name|CHANGE_TO_ARM
value|"__%s_change_to_arm"
define|#
directive|define
name|BACK_FROM_ARM
value|"__%s_back_from_arm"
name|tmp_name
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|CHANGE_TO_ARM
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|tmp_name
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tmp_name
argument_list|,
name|globals
operator|->
name|support_old_code
condition|?
name|BACK_FROM_ARM
else|:
name|CHANGE_TO_ARM
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|myh
operator|=
name|NULL
expr_stmt|;
name|bfd_coff_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|globals
operator|->
name|bfd_of_glue_owner
argument_list|,
name|tmp_name
argument_list|,
name|BSF_LOCAL
argument_list|,
name|s
argument_list|,
name|globals
operator|->
name|thumb_glue_size
operator|+
operator|(
name|globals
operator|->
name|support_old_code
condition|?
literal|8
else|:
literal|4
operator|)
argument_list|,
name|NULL
argument_list|,
name|true
argument_list|,
name|false
argument_list|,
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|*
operator|)
operator|&
name|myh
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp_name
argument_list|)
expr_stmt|;
name|globals
operator|->
name|thumb_glue_size
operator|+=
name|THUMB2ARM_GLUE_SIZE
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Select a BFD to be used to hold the sections used by the glue code.    This function is called from the linker scripts in ld/emultempl/    {armcoff/pe}.em  */
end_comment

begin_function
name|boolean
name|bfd_arm_get_bfd_for_interworking
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|struct
name|coff_arm_link_hash_table
modifier|*
name|globals
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
comment|/* If we are only performing a partial link do not bother      getting a bfd to hold the glue.  */
if|if
condition|(
name|info
operator|->
name|relocateable
condition|)
return|return
name|true
return|;
name|globals
operator|=
name|coff_arm_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|globals
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|globals
operator|->
name|bfd_of_glue_owner
operator|!=
name|NULL
condition|)
return|return
name|true
return|;
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|ARM2THUMB_GLUE_SECTION_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
block|{
name|flags
operator|=
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_CODE
operator||
name|SEC_READONLY
expr_stmt|;
name|sec
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
name|ARM2THUMB_GLUE_SECTION_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|flags
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|false
return|;
block|}
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|THUMB2ARM_GLUE_SECTION_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
block|{
name|flags
operator|=
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_CODE
operator||
name|SEC_READONLY
expr_stmt|;
name|sec
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
name|THUMB2ARM_GLUE_SECTION_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|flags
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|false
return|;
block|}
comment|/* Save the bfd for later use.  */
name|globals
operator|->
name|bfd_of_glue_owner
operator|=
name|abfd
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
name|boolean
name|bfd_arm_process_before_allocation
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|support_old_code
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|int
name|support_old_code
decl_stmt|;
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|coff_arm_link_hash_table
modifier|*
name|globals
decl_stmt|;
comment|/* If we are only performing a partial link do not bother      to construct any glue.  */
if|if
condition|(
name|info
operator|->
name|relocateable
condition|)
return|return
name|true
return|;
comment|/* Here we have a bfd that is to be included on the link.  We have a hook      to do reloc rummaging, before section sizes are nailed down.  */
name|_bfd_coff_get_external_symbols
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|globals
operator|=
name|coff_arm_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|globals
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|globals
operator|->
name|bfd_of_glue_owner
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|globals
operator|->
name|support_old_code
operator|=
name|support_old_code
expr_stmt|;
comment|/* Rummage around all the relocs and map the glue vectors.  */
name|sec
operator|=
name|abfd
operator|->
name|sections
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
return|return
name|true
return|;
for|for
control|(
init|;
name|sec
operator|!=
name|NULL
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
block|{
name|struct
name|internal_reloc
modifier|*
name|i
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|rel
decl_stmt|;
if|if
condition|(
name|sec
operator|->
name|reloc_count
operator|==
literal|0
condition|)
continue|continue;
comment|/* Load the relocs.  */
comment|/* FIXME: there may be a storage leak here.  */
name|i
operator|=
name|_bfd_coff_read_internal_relocs
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|i
operator|!=
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|i
init|;
name|rel
operator|<
name|i
operator|+
name|sec
operator|->
name|reloc_count
condition|;
operator|++
name|rel
control|)
block|{
name|unsigned
name|short
name|r_type
init|=
name|rel
operator|->
name|r_type
decl_stmt|;
name|long
name|symndx
decl_stmt|;
name|struct
name|coff_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|symndx
operator|=
name|rel
operator|->
name|r_symndx
expr_stmt|;
comment|/* If the relocation is not against a symbol it cannot concern us.  */
if|if
condition|(
name|symndx
operator|==
operator|-
literal|1
condition|)
continue|continue;
comment|/* If the index is outside of the range of our table, something has gone wrong.  */
if|if
condition|(
name|symndx
operator|>=
name|obj_conv_table_size
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"%s: illegal symbol index in reloc: %d"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|symndx
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|h
operator|=
name|obj_coff_sym_hashes
argument_list|(
name|abfd
argument_list|)
index|[
name|symndx
index|]
expr_stmt|;
comment|/* If the relocation is against a static symbol it must be within 	     the current section and so cannot be a cross ARM/Thumb relocation.  */
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
continue|continue;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|ARM_26
case|:
comment|/* This one is a call from arm code.  We need to look up 		 the target of the call. If it is a thumb target, we 		 insert glue.  */
if|if
condition|(
name|h
operator|->
name|class
operator|==
name|C_THUMBEXTFUNC
condition|)
name|record_arm_to_thumb_glue
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|ARM_WINCE
case|case
name|ARM_THUMB23
case|:
comment|/* This one is a call from thumb code.  We used to look 		 for ARM_THUMB9 and ARM_THUMB12 as well.  We need to look 		 up the target of the call. If it is an arm target, we 		 insert glue.  If the symbol does not exist it will be 		 given a class of C_EXT and so we will generate a stub 		 for it.  This is not really a problem, since the link 		 is doomed anyway.  */
switch|switch
condition|(
name|h
operator|->
name|class
condition|)
block|{
case|case
name|C_EXT
case|:
case|case
name|C_STAT
case|:
case|case
name|C_LABEL
case|:
name|record_thumb_to_arm_glue
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
expr_stmt|;
break|break;
default|default:
empty_stmt|;
block|}
break|break;
endif|#
directive|endif
default|default:
break|break;
block|}
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! defined (COFF_IMAGE_WITH_PE) */
end_comment

begin_define
define|#
directive|define
name|coff_bfd_reloc_type_lookup
value|coff_arm_reloc_type_lookup
end_define

begin_define
define|#
directive|define
name|coff_relocate_section
value|coff_arm_relocate_section
end_define

begin_define
define|#
directive|define
name|coff_bfd_is_local_label_name
value|coff_arm_is_local_label_name
end_define

begin_define
define|#
directive|define
name|coff_adjust_symndx
value|coff_arm_adjust_symndx
end_define

begin_define
define|#
directive|define
name|coff_link_output_has_begun
value|coff_arm_link_output_has_begun
end_define

begin_define
define|#
directive|define
name|coff_final_link_postscript
value|coff_arm_final_link_postscript
end_define

begin_define
define|#
directive|define
name|coff_bfd_merge_private_bfd_data
value|coff_arm_merge_private_bfd_data
end_define

begin_define
define|#
directive|define
name|coff_bfd_print_private_bfd_data
value|coff_arm_print_private_bfd_data
end_define

begin_define
define|#
directive|define
name|coff_bfd_set_private_flags
value|_bfd_coff_arm_set_private_flags
end_define

begin_define
define|#
directive|define
name|coff_bfd_copy_private_bfd_data
value|coff_arm_copy_private_bfd_data
end_define

begin_define
define|#
directive|define
name|coff_bfd_link_hash_table_create
value|coff_arm_link_hash_table_create
end_define

begin_comment
comment|/* When doing a relocateable link, we want to convert ARM26 relocs    into ARM26D relocs.  */
end_comment

begin_function
specifier|static
name|boolean
name|coff_arm_adjust_symndx
parameter_list|(
name|obfd
parameter_list|,
name|info
parameter_list|,
name|ibfd
parameter_list|,
name|sec
parameter_list|,
name|irel
parameter_list|,
name|adjustedp
parameter_list|)
name|bfd
modifier|*
name|obfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|irel
decl_stmt|;
name|boolean
modifier|*
name|adjustedp
decl_stmt|;
block|{
if|if
condition|(
name|irel
operator|->
name|r_type
operator|==
literal|3
condition|)
block|{
name|struct
name|coff_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
name|obj_coff_sym_hashes
argument_list|(
name|ibfd
argument_list|)
index|[
name|irel
operator|->
name|r_symndx
index|]
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|==
name|sec
operator|->
name|output_section
condition|)
name|irel
operator|->
name|r_type
operator|=
literal|7
expr_stmt|;
block|}
operator|*
name|adjustedp
operator|=
name|false
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Called when merging the private data areas of two BFDs.    This is important as it allows us to detect if we are    attempting to merge binaries compiled for different ARM    targets, eg different CPUs or differents APCS's.     */
end_comment

begin_function
specifier|static
name|boolean
name|coff_arm_merge_private_bfd_data
parameter_list|(
name|ibfd
parameter_list|,
name|obfd
parameter_list|)
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|bfd
modifier|*
name|obfd
decl_stmt|;
block|{
name|BFD_ASSERT
argument_list|(
name|ibfd
operator|!=
name|NULL
operator|&&
name|obfd
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ibfd
operator|==
name|obfd
condition|)
return|return
name|true
return|;
comment|/* If the two formats are different we cannot merge anything.      This is not an error, since it is permissable to change the      input and output formats.  */
if|if
condition|(
name|ibfd
operator|->
name|xvec
operator|->
name|flavour
operator|!=
name|bfd_target_coff_flavour
operator|||
name|obfd
operator|->
name|xvec
operator|->
name|flavour
operator|!=
name|bfd_target_coff_flavour
condition|)
return|return
name|true
return|;
comment|/* Verify that the APCS is the same for the two BFDs */
if|if
condition|(
name|APCS_SET
argument_list|(
name|ibfd
argument_list|)
condition|)
block|{
if|if
condition|(
name|APCS_SET
argument_list|(
name|obfd
argument_list|)
condition|)
block|{
comment|/* If the src and dest have different APCS flag bits set, fail.  */
if|if
condition|(
name|APCS_26_FLAG
argument_list|(
name|obfd
argument_list|)
operator|!=
name|APCS_26_FLAG
argument_list|(
name|ibfd
argument_list|)
condition|)
block|{
name|_bfd_error_handler
comment|/* xgettext: c-format */
argument_list|(
name|_
argument_list|(
literal|"%s: ERROR: compiled for APCS-%d whereas target %s uses APCS-%d"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|APCS_26_FLAG
argument_list|(
name|ibfd
argument_list|)
condition|?
literal|26
else|:
literal|32
argument_list|,
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|,
name|APCS_26_FLAG
argument_list|(
name|obfd
argument_list|)
condition|?
literal|26
else|:
literal|32
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|APCS_FLOAT_FLAG
argument_list|(
name|obfd
argument_list|)
operator|!=
name|APCS_FLOAT_FLAG
argument_list|(
name|ibfd
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
if|if
condition|(
name|APCS_FLOAT_FLAG
argument_list|(
name|ibfd
argument_list|)
condition|)
comment|/* xgettext: c-format */
name|msg
operator|=
name|_
argument_list|(
literal|"%s: ERROR: passes floats in float registers whereas target %s uses integer registers"
argument_list|)
expr_stmt|;
else|else
comment|/* xgettext: c-format */
name|msg
operator|=
name|_
argument_list|(
literal|"%s: ERROR: passes floats in integer registers whereas target %s uses float registers"
argument_list|)
expr_stmt|;
name|_bfd_error_handler
argument_list|(
name|msg
argument_list|,
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|PIC_FLAG
argument_list|(
name|obfd
argument_list|)
operator|!=
name|PIC_FLAG
argument_list|(
name|ibfd
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
if|if
condition|(
name|PIC_FLAG
argument_list|(
name|ibfd
argument_list|)
condition|)
comment|/* xgettext: c-format */
name|msg
operator|=
name|_
argument_list|(
literal|"%s: ERROR: compiled as position independent code, whereas target %s is absolute position"
argument_list|)
expr_stmt|;
else|else
comment|/* xgettext: c-format */
name|msg
operator|=
name|_
argument_list|(
literal|"%s: ERROR: compiled as absolute position code, whereas target %s is position independent"
argument_list|)
expr_stmt|;
name|_bfd_error_handler
argument_list|(
name|msg
argument_list|,
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
else|else
block|{
name|SET_APCS_FLAGS
argument_list|(
name|obfd
argument_list|,
name|APCS_26_FLAG
argument_list|(
name|ibfd
argument_list|)
operator||
name|APCS_FLOAT_FLAG
argument_list|(
name|ibfd
argument_list|)
operator||
name|PIC_FLAG
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set up the arch and fields as well as these are probably wrong.  */
name|bfd_set_arch_mach
argument_list|(
name|obfd
argument_list|,
name|bfd_get_arch
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|bfd_get_mach
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Check the interworking support.  */
if|if
condition|(
name|INTERWORK_SET
argument_list|(
name|ibfd
argument_list|)
condition|)
block|{
if|if
condition|(
name|INTERWORK_SET
argument_list|(
name|obfd
argument_list|)
condition|)
block|{
comment|/* If the src and dest differ in their interworking issue a warning.  */
if|if
condition|(
name|INTERWORK_FLAG
argument_list|(
name|obfd
argument_list|)
operator|!=
name|INTERWORK_FLAG
argument_list|(
name|ibfd
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
if|if
condition|(
name|INTERWORK_FLAG
argument_list|(
name|ibfd
argument_list|)
condition|)
comment|/* xgettext: c-format */
name|msg
operator|=
name|_
argument_list|(
literal|"Warning: input file %s supports interworking, whereas %s does not."
argument_list|)
expr_stmt|;
else|else
comment|/* xgettext: c-format */
name|msg
operator|=
name|_
argument_list|(
literal|"Warning: input file %s does not support interworking, whereas %s does."
argument_list|)
expr_stmt|;
name|_bfd_error_handler
argument_list|(
name|msg
argument_list|,
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|SET_INTERWORK_FLAG
argument_list|(
name|obfd
argument_list|,
name|INTERWORK_FLAG
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Display the flags field.  */
end_comment

begin_function
specifier|static
name|boolean
name|coff_arm_print_private_bfd_data
parameter_list|(
name|abfd
parameter_list|,
name|ptr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|ptr
decl_stmt|;
block|{
name|FILE
modifier|*
name|file
init|=
operator|(
name|FILE
operator|*
operator|)
name|ptr
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|abfd
operator|!=
name|NULL
operator|&&
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* xgettext:c-format */
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"private flags = %x:"
argument_list|)
argument_list|,
name|coff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|APCS_SET
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
comment|/* xgettext: APCS is ARM Prodecure Call Standard, it should not be translated.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" [APCS-%d]"
argument_list|,
name|APCS_26_FLAG
argument_list|(
name|abfd
argument_list|)
condition|?
literal|26
else|:
literal|32
argument_list|)
expr_stmt|;
if|if
condition|(
name|APCS_FLOAT_FLAG
argument_list|(
name|abfd
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [floats passed in float registers]"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [floats passed in integer registers]"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|PIC_FLAG
argument_list|(
name|abfd
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [position independent]"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [absolute position]"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|INTERWORK_SET
argument_list|(
name|abfd
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [interworking flag not initialised]"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|INTERWORK_FLAG
argument_list|(
name|abfd
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [interworking supported]"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [interworking not supported]"
argument_list|)
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Copies the given flags into the coff_tdata.flags field.    Typically these flags come from the f_flags[] field of    the COFF filehdr structure, which contains important,    target specific information.    Note: Although this function is static, it is explicitly    called from both coffcode.h and peicode.h.  */
end_comment

begin_function
specifier|static
name|boolean
name|_bfd_coff_arm_set_private_flags
parameter_list|(
name|abfd
parameter_list|,
name|flags
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
block|{
name|flagword
name|flag
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|abfd
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|flag
operator|=
operator|(
name|flags
operator|&
name|F_APCS26
operator|)
condition|?
name|F_APCS_26
else|:
literal|0
expr_stmt|;
comment|/* Make sure that the APCS field has not been initialised to the opposite      value.  */
if|if
condition|(
name|APCS_SET
argument_list|(
name|abfd
argument_list|)
operator|&&
operator|(
operator|(
name|APCS_26_FLAG
argument_list|(
name|abfd
argument_list|)
operator|!=
name|flag
operator|)
operator|||
operator|(
name|APCS_FLOAT_FLAG
argument_list|(
name|abfd
argument_list|)
operator|!=
operator|(
name|flags
operator|&
name|F_APCS_FLOAT
operator|)
operator|)
operator|||
operator|(
name|PIC_FLAG
argument_list|(
name|abfd
argument_list|)
operator|!=
operator|(
name|flags
operator|&
name|F_PIC
operator|)
operator|)
operator|)
condition|)
return|return
name|false
return|;
name|flag
operator||=
operator|(
name|flags
operator|&
operator|(
name|F_APCS_FLOAT
operator||
name|F_PIC
operator|)
operator|)
expr_stmt|;
name|SET_APCS_FLAGS
argument_list|(
name|abfd
argument_list|,
name|flag
argument_list|)
expr_stmt|;
name|flag
operator|=
operator|(
name|flags
operator|&
name|F_INTERWORK
operator|)
expr_stmt|;
comment|/* If the BFD has already had its interworking flag set, but it      is different from the value that we have been asked to set,      then assume that that merged code will not support interworking      and set the flag accordingly.  */
if|if
condition|(
name|INTERWORK_SET
argument_list|(
name|abfd
argument_list|)
operator|&&
operator|(
name|INTERWORK_FLAG
argument_list|(
name|abfd
argument_list|)
operator|!=
name|flag
operator|)
condition|)
block|{
if|if
condition|(
name|flag
condition|)
comment|/* xgettext: c-format */
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"Warning: Not setting interworking flag of %s, since it has already been specified as non-interworking"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* xgettext: c-format */
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"Warning: Clearing the interworking flag of %s due to outside request"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|flag
operator|=
literal|0
expr_stmt|;
block|}
name|SET_INTERWORK_FLAG
argument_list|(
name|abfd
argument_list|,
name|flag
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Copy the important parts of the target specific data    from one instance of a BFD to another.  */
end_comment

begin_function
specifier|static
name|boolean
name|coff_arm_copy_private_bfd_data
parameter_list|(
name|src
parameter_list|,
name|dest
parameter_list|)
name|bfd
modifier|*
name|src
decl_stmt|;
name|bfd
modifier|*
name|dest
decl_stmt|;
block|{
name|BFD_ASSERT
argument_list|(
name|src
operator|!=
name|NULL
operator|&&
name|dest
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
operator|==
name|dest
condition|)
return|return
name|true
return|;
comment|/* If the destination is not in the same format as the source, do not do      the copy.  */
if|if
condition|(
name|src
operator|->
name|xvec
operator|!=
name|dest
operator|->
name|xvec
condition|)
return|return
name|true
return|;
comment|/* copy the flags field */
if|if
condition|(
name|APCS_SET
argument_list|(
name|src
argument_list|)
condition|)
block|{
if|if
condition|(
name|APCS_SET
argument_list|(
name|dest
argument_list|)
condition|)
block|{
comment|/* If the src and dest have different APCS flag bits set, fail.  */
if|if
condition|(
name|APCS_26_FLAG
argument_list|(
name|dest
argument_list|)
operator|!=
name|APCS_26_FLAG
argument_list|(
name|src
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|APCS_FLOAT_FLAG
argument_list|(
name|dest
argument_list|)
operator|!=
name|APCS_FLOAT_FLAG
argument_list|(
name|src
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|PIC_FLAG
argument_list|(
name|dest
argument_list|)
operator|!=
name|PIC_FLAG
argument_list|(
name|src
argument_list|)
condition|)
return|return
name|false
return|;
block|}
else|else
name|SET_APCS_FLAGS
argument_list|(
name|dest
argument_list|,
name|APCS_26_FLAG
argument_list|(
name|src
argument_list|)
operator||
name|APCS_FLOAT_FLAG
argument_list|(
name|src
argument_list|)
operator||
name|PIC_FLAG
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|INTERWORK_SET
argument_list|(
name|src
argument_list|)
condition|)
block|{
if|if
condition|(
name|INTERWORK_SET
argument_list|(
name|dest
argument_list|)
condition|)
block|{
comment|/* If the src and dest have different interworking flags then turn 	     off the interworking bit.  */
if|if
condition|(
name|INTERWORK_FLAG
argument_list|(
name|dest
argument_list|)
operator|!=
name|INTERWORK_FLAG
argument_list|(
name|src
argument_list|)
condition|)
block|{
if|if
condition|(
name|INTERWORK_FLAG
argument_list|(
name|dest
argument_list|)
condition|)
block|{
comment|/* xgettext:c-format */
name|_bfd_error_handler
argument_list|(
operator|(
literal|"Warning: Clearing the interworking bit of %s, because the non-interworking code in %s has been copied into it"
operator|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|dest
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SET_INTERWORK_FLAG
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|SET_INTERWORK_FLAG
argument_list|(
name|dest
argument_list|,
name|INTERWORK_FLAG
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Note:  the definitions here of LOCAL_LABEL_PREFIX and USER_LABEL_PREIFX    *must* match the definitions in gcc/config/arm/{coff|semi|aout}.h.  */
end_comment

begin_define
define|#
directive|define
name|LOCAL_LABEL_PREFIX
value|""
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|USER_LABEL_PREFIX
end_ifndef

begin_define
define|#
directive|define
name|USER_LABEL_PREFIX
value|"_"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Like _bfd_coff_is_local_label_name, but    a) test against USER_LABEL_PREFIX, to avoid stripping labels known to be       non-local.    b) Allow other prefixes than ".", e.g. an empty prefix would cause all       labels of the form Lxxx to be stripped.  */
end_comment

begin_function
specifier|static
name|boolean
name|coff_arm_is_local_label_name
parameter_list|(
name|abfd
parameter_list|,
name|name
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|USER_LABEL_PREFIX
if|if
condition|(
name|USER_LABEL_PREFIX
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|USER_LABEL_PREFIX
argument_list|,
name|strlen
argument_list|(
name|USER_LABEL_PREFIX
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
name|false
return|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LOCAL_LABEL_PREFIX
comment|/* If there is a prefix for local labels then look for this.      If the prefix exists, but it is empty, then ignore the test.  */
if|if
condition|(
name|LOCAL_LABEL_PREFIX
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|LOCAL_LABEL_PREFIX
argument_list|)
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|LOCAL_LABEL_PREFIX
argument_list|,
name|len
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
comment|/* Perform the checks below for the rest of the name.  */
name|name
operator|+=
name|len
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|name
index|[
literal|0
index|]
operator|==
literal|'L'
return|;
block|}
end_function

begin_comment
comment|/* This piece of machinery exists only to guarantee that the bfd that holds    the glue section is written last.     This does depend on bfd_make_section attaching a new section to the    end of the section list for the bfd.     krk@cygnus.com  */
end_comment

begin_function
specifier|static
name|boolean
name|coff_arm_link_output_has_begun
parameter_list|(
name|sub
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|sub
decl_stmt|;
name|struct
name|coff_final_link_info
modifier|*
name|info
decl_stmt|;
block|{
return|return
operator|(
name|sub
operator|->
name|output_has_begun
operator|||
name|sub
operator|==
name|coff_arm_hash_table
argument_list|(
name|info
operator|->
name|info
argument_list|)
operator|->
name|bfd_of_glue_owner
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|coff_arm_final_link_postscript
parameter_list|(
name|abfd
parameter_list|,
name|pfinfo
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|coff_final_link_info
modifier|*
name|pfinfo
decl_stmt|;
block|{
name|struct
name|coff_arm_link_hash_table
modifier|*
name|globals
decl_stmt|;
name|globals
operator|=
name|coff_arm_hash_table
argument_list|(
name|pfinfo
operator|->
name|info
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|globals
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|globals
operator|->
name|bfd_of_glue_owner
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|_bfd_coff_link_input_bfd
argument_list|(
name|pfinfo
argument_list|,
name|globals
operator|->
name|bfd_of_glue_owner
argument_list|)
condition|)
return|return
name|false
return|;
name|globals
operator|->
name|bfd_of_glue_owner
operator|->
name|output_has_begun
operator|=
name|true
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_include
include|#
directive|include
file|"coffcode.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|TARGET_LITTLE_SYM
end_ifndef

begin_define
define|#
directive|define
name|TARGET_LITTLE_SYM
value|armcoff_little_vec
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TARGET_LITTLE_NAME
end_ifndef

begin_define
define|#
directive|define
name|TARGET_LITTLE_NAME
value|"coff-arm-little"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TARGET_BIG_SYM
end_ifndef

begin_define
define|#
directive|define
name|TARGET_BIG_SYM
value|armcoff_big_vec
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TARGET_BIG_NAME
end_ifndef

begin_define
define|#
directive|define
name|TARGET_BIG_NAME
value|"coff-arm-big"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TARGET_UNDERSCORE
end_ifndef

begin_define
define|#
directive|define
name|TARGET_UNDERSCORE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|EXTRA_S_FLAGS
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|COFF_WITH_PE
end_ifdef

begin_define
define|#
directive|define
name|EXTRA_S_FLAGS
value|(SEC_LINK_ONCE | SEC_LINK_DUPLICATES)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|EXTRA_S_FLAGS
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Forward declaration for use initialising alternative_target field.  */
end_comment

begin_decl_stmt
specifier|extern
specifier|const
name|bfd_target
name|TARGET_BIG_SYM
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Target vectors.  */
end_comment

begin_macro
name|CREATE_LITTLE_COFF_TARGET_VEC
argument_list|(
argument|TARGET_LITTLE_SYM
argument_list|,
argument|TARGET_LITTLE_NAME
argument_list|,
argument|D_PAGED
argument_list|,
argument|EXTRA_S_FLAGS
argument_list|,
argument|TARGET_UNDERSCORE
argument_list|,
argument|& TARGET_BIG_SYM
argument_list|)
end_macro

begin_macro
name|CREATE_BIG_COFF_TARGET_VEC
argument_list|(
argument|TARGET_BIG_SYM
argument_list|,
argument|TARGET_BIG_NAME
argument_list|,
argument|D_PAGED
argument_list|,
argument|EXTRA_S_FLAGS
argument_list|,
argument|TARGET_UNDERSCORE
argument_list|,
argument|& TARGET_LITTLE_SYM
argument_list|)
end_macro

end_unit

