begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* opncls.c -- open and close a BFD.    Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 2000,    2001, 2002, 2003    Free Software Foundation, Inc.     Written by Cygnus Support.     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"objalloc.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|S_IXUSR
end_ifndef

begin_define
define|#
directive|define
name|S_IXUSR
value|0100
end_define

begin_comment
comment|/* Execute by owner.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|S_IXGRP
end_ifndef

begin_define
define|#
directive|define
name|S_IXGRP
value|0010
end_define

begin_comment
comment|/* Execute by group.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|S_IXOTH
end_ifndef

begin_define
define|#
directive|define
name|S_IXOTH
value|0001
end_define

begin_comment
comment|/* Execute by others.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Counter used to initialize the bfd identifier.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|_bfd_id_counter
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* fdopen is a loser -- we should use stdio exclusively.  Unfortunately    if we do that we can't use fcntl.  */
end_comment

begin_comment
comment|/* Return a new BFD.  All BFD's are allocated through this routine.  */
end_comment

begin_function
name|bfd
modifier|*
name|_bfd_new_bfd
parameter_list|(
name|void
parameter_list|)
block|{
name|bfd
modifier|*
name|nbfd
decl_stmt|;
name|nbfd
operator|=
name|bfd_zmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|bfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbfd
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|nbfd
operator|->
name|id
operator|=
name|_bfd_id_counter
operator|++
expr_stmt|;
name|nbfd
operator|->
name|memory
operator|=
name|objalloc_create
argument_list|()
expr_stmt|;
if|if
condition|(
name|nbfd
operator|->
name|memory
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nbfd
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|nbfd
operator|->
name|arch_info
operator|=
operator|&
name|bfd_default_arch_struct
expr_stmt|;
name|nbfd
operator|->
name|direction
operator|=
name|no_direction
expr_stmt|;
name|nbfd
operator|->
name|iostream
operator|=
name|NULL
expr_stmt|;
name|nbfd
operator|->
name|where
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_hash_table_init_n
argument_list|(
operator|&
name|nbfd
operator|->
name|section_htab
argument_list|,
name|bfd_section_hash_newfunc
argument_list|,
literal|251
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|nbfd
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|nbfd
operator|->
name|sections
operator|=
name|NULL
expr_stmt|;
name|nbfd
operator|->
name|section_tail
operator|=
operator|&
name|nbfd
operator|->
name|sections
expr_stmt|;
name|nbfd
operator|->
name|format
operator|=
name|bfd_unknown
expr_stmt|;
name|nbfd
operator|->
name|my_archive
operator|=
name|NULL
expr_stmt|;
name|nbfd
operator|->
name|origin
operator|=
literal|0
expr_stmt|;
name|nbfd
operator|->
name|opened_once
operator|=
name|FALSE
expr_stmt|;
name|nbfd
operator|->
name|output_has_begun
operator|=
name|FALSE
expr_stmt|;
name|nbfd
operator|->
name|section_count
operator|=
literal|0
expr_stmt|;
name|nbfd
operator|->
name|usrdata
operator|=
name|NULL
expr_stmt|;
name|nbfd
operator|->
name|cacheable
operator|=
name|FALSE
expr_stmt|;
name|nbfd
operator|->
name|flags
operator|=
name|BFD_NO_FLAGS
expr_stmt|;
name|nbfd
operator|->
name|mtime_set
operator|=
name|FALSE
expr_stmt|;
return|return
name|nbfd
return|;
block|}
end_function

begin_comment
comment|/* Allocate a new BFD as a member of archive OBFD.  */
end_comment

begin_function
name|bfd
modifier|*
name|_bfd_new_bfd_contained_in
parameter_list|(
name|bfd
modifier|*
name|obfd
parameter_list|)
block|{
name|bfd
modifier|*
name|nbfd
decl_stmt|;
name|nbfd
operator|=
name|_bfd_new_bfd
argument_list|()
expr_stmt|;
if|if
condition|(
name|nbfd
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|nbfd
operator|->
name|xvec
operator|=
name|obfd
operator|->
name|xvec
expr_stmt|;
name|nbfd
operator|->
name|my_archive
operator|=
name|obfd
expr_stmt|;
name|nbfd
operator|->
name|direction
operator|=
name|read_direction
expr_stmt|;
name|nbfd
operator|->
name|target_defaulted
operator|=
name|obfd
operator|->
name|target_defaulted
expr_stmt|;
return|return
name|nbfd
return|;
block|}
end_function

begin_comment
comment|/* Delete a BFD.  */
end_comment

begin_function
name|void
name|_bfd_delete_bfd
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|bfd_hash_table_free
argument_list|(
operator|&
name|abfd
operator|->
name|section_htab
argument_list|)
expr_stmt|;
name|objalloc_free
argument_list|(
operator|(
expr|struct
name|objalloc
operator|*
operator|)
name|abfd
operator|->
name|memory
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* SECTION 	Opening and closing BFDs  */
end_comment

begin_comment
comment|/* FUNCTION 	bfd_openr  SYNOPSIS 	bfd *bfd_openr (const char *filename, const char *target);  DESCRIPTION 	Open the file @var{filename} (using<<fopen>>) with the target 	@var{target}.  Return a pointer to the created BFD.  	Calls<<bfd_find_target>>, so @var{target} is interpreted as by 	that function.  	If<<NULL>> is returned then an error has occured.   Possible errors 	are<<bfd_error_no_memory>>,<<bfd_error_invalid_target>> or<<system_call>> error. */
end_comment

begin_function
name|bfd
modifier|*
name|bfd_openr
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
specifier|const
name|char
modifier|*
name|target
parameter_list|)
block|{
name|bfd
modifier|*
name|nbfd
decl_stmt|;
specifier|const
name|bfd_target
modifier|*
name|target_vec
decl_stmt|;
name|nbfd
operator|=
name|_bfd_new_bfd
argument_list|()
expr_stmt|;
if|if
condition|(
name|nbfd
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|target_vec
operator|=
name|bfd_find_target
argument_list|(
name|target
argument_list|,
name|nbfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_vec
operator|==
name|NULL
condition|)
block|{
name|_bfd_delete_bfd
argument_list|(
name|nbfd
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|nbfd
operator|->
name|filename
operator|=
name|filename
expr_stmt|;
name|nbfd
operator|->
name|direction
operator|=
name|read_direction
expr_stmt|;
if|if
condition|(
name|bfd_open_file
argument_list|(
name|nbfd
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* File didn't exist, or some such.  */
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
name|_bfd_delete_bfd
argument_list|(
name|nbfd
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|nbfd
return|;
block|}
end_function

begin_comment
comment|/* Don't try to `optimize' this function:     o - We lock using stack space so that interrupting the locking        won't cause a storage leak.    o - We open the file stream last, since we don't want to have to        close it if anything goes wrong.  Closing the stream means closing        the file descriptor too, even though we didn't open it.  */
end_comment

begin_comment
comment|/* FUNCTION 	bfd_fdopenr  SYNOPSIS 	bfd *bfd_fdopenr (const char *filename, const char *target, int fd);  DESCRIPTION<<bfd_fdopenr>> is to<<bfd_fopenr>> much like<<fdopen>> is to<<fopen>>.  It opens a BFD on a file already described by the 	@var{fd} supplied.  	When the file is later<<bfd_close>>d, the file descriptor will 	be closed.  If the caller desires that this file descriptor be 	cached by BFD (opened as needed, closed as needed to free 	descriptors for other opens), with the supplied @var{fd} used as 	an initial file descriptor (but subject to closure at any time), 	call bfd_set_cacheable(bfd, 1) on the returned BFD.  The default 	is to assume no caching; the file descriptor will remain open 	until<<bfd_close>>, and will not be affected by BFD operations 	on other files.  	Possible errors are<<bfd_error_no_memory>>,<<bfd_error_invalid_target>> and<<bfd_error_system_call>>. */
end_comment

begin_function
name|bfd
modifier|*
name|bfd_fdopenr
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
specifier|const
name|char
modifier|*
name|target
parameter_list|,
name|int
name|fd
parameter_list|)
block|{
name|bfd
modifier|*
name|nbfd
decl_stmt|;
specifier|const
name|bfd_target
modifier|*
name|target_vec
decl_stmt|;
name|int
name|fdflags
decl_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_FCNTL
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|F_GETFL
argument_list|)
name|fdflags
operator|=
name|O_RDWR
expr_stmt|;
comment|/* Assume full access.  */
else|#
directive|else
name|fdflags
operator|=
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_GETFL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|fdflags
operator|==
operator|-
literal|1
condition|)
return|return
name|NULL
return|;
name|nbfd
operator|=
name|_bfd_new_bfd
argument_list|()
expr_stmt|;
if|if
condition|(
name|nbfd
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|target_vec
operator|=
name|bfd_find_target
argument_list|(
name|target
argument_list|,
name|nbfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_vec
operator|==
name|NULL
condition|)
block|{
name|_bfd_delete_bfd
argument_list|(
name|nbfd
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
ifndef|#
directive|ifndef
name|HAVE_FDOPEN
name|nbfd
operator|->
name|iostream
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
name|FOPEN_RB
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* (O_ACCMODE) parens are to avoid Ultrix header file bug.  */
switch|switch
condition|(
name|fdflags
operator|&
operator|(
name|O_ACCMODE
operator|)
condition|)
block|{
case|case
name|O_RDONLY
case|:
name|nbfd
operator|->
name|iostream
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
name|FOPEN_RB
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_WRONLY
case|:
name|nbfd
operator|->
name|iostream
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
name|FOPEN_RUB
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_RDWR
case|:
name|nbfd
operator|->
name|iostream
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
name|FOPEN_RUB
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|nbfd
operator|->
name|iostream
operator|==
name|NULL
condition|)
block|{
name|_bfd_delete_bfd
argument_list|(
name|nbfd
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* OK, put everything where it belongs.  */
name|nbfd
operator|->
name|filename
operator|=
name|filename
expr_stmt|;
comment|/* As a special case we allow a FD open for read/write to      be written through, although doing so requires that we end      the previous clause with a preposition.  */
comment|/* (O_ACCMODE) parens are to avoid Ultrix header file bug.  */
switch|switch
condition|(
name|fdflags
operator|&
operator|(
name|O_ACCMODE
operator|)
condition|)
block|{
case|case
name|O_RDONLY
case|:
name|nbfd
operator|->
name|direction
operator|=
name|read_direction
expr_stmt|;
break|break;
case|case
name|O_WRONLY
case|:
name|nbfd
operator|->
name|direction
operator|=
name|write_direction
expr_stmt|;
break|break;
case|case
name|O_RDWR
case|:
name|nbfd
operator|->
name|direction
operator|=
name|both_direction
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bfd_cache_init
argument_list|(
name|nbfd
argument_list|)
condition|)
block|{
name|_bfd_delete_bfd
argument_list|(
name|nbfd
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|nbfd
operator|->
name|opened_once
operator|=
name|TRUE
expr_stmt|;
return|return
name|nbfd
return|;
block|}
end_function

begin_comment
comment|/* FUNCTION 	bfd_openstreamr  SYNOPSIS 	bfd *bfd_openstreamr (const char *, const char *, void *);  DESCRIPTION  	Open a BFD for read access on an existing stdio stream.  When 	the BFD is passed to<<bfd_close>>, the stream will be closed. */
end_comment

begin_function
name|bfd
modifier|*
name|bfd_openstreamr
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
specifier|const
name|char
modifier|*
name|target
parameter_list|,
name|void
modifier|*
name|streamarg
parameter_list|)
block|{
name|FILE
modifier|*
name|stream
init|=
name|streamarg
decl_stmt|;
name|bfd
modifier|*
name|nbfd
decl_stmt|;
specifier|const
name|bfd_target
modifier|*
name|target_vec
decl_stmt|;
name|nbfd
operator|=
name|_bfd_new_bfd
argument_list|()
expr_stmt|;
if|if
condition|(
name|nbfd
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|target_vec
operator|=
name|bfd_find_target
argument_list|(
name|target
argument_list|,
name|nbfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_vec
operator|==
name|NULL
condition|)
block|{
name|_bfd_delete_bfd
argument_list|(
name|nbfd
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|nbfd
operator|->
name|iostream
operator|=
name|stream
expr_stmt|;
name|nbfd
operator|->
name|filename
operator|=
name|filename
expr_stmt|;
name|nbfd
operator|->
name|direction
operator|=
name|read_direction
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_cache_init
argument_list|(
name|nbfd
argument_list|)
condition|)
block|{
name|_bfd_delete_bfd
argument_list|(
name|nbfd
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|nbfd
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* bfd_openw -- open for writing.    Returns a pointer to a freshly-allocated BFD on success, or NULL.     See comment by bfd_fdopenr before you try to modify this function.  */
end_comment

begin_comment
comment|/* FUNCTION 	bfd_openw  SYNOPSIS 	bfd *bfd_openw (const char *filename, const char *target);  DESCRIPTION 	Create a BFD, associated with file @var{filename}, using the 	file format @var{target}, and return a pointer to it.  	Possible errors are<<bfd_error_system_call>>,<<bfd_error_no_memory>>,<<bfd_error_invalid_target>>. */
end_comment

begin_function
name|bfd
modifier|*
name|bfd_openw
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
specifier|const
name|char
modifier|*
name|target
parameter_list|)
block|{
name|bfd
modifier|*
name|nbfd
decl_stmt|;
specifier|const
name|bfd_target
modifier|*
name|target_vec
decl_stmt|;
comment|/* nbfd has to point to head of malloc'ed block so that bfd_close may      reclaim it correctly.  */
name|nbfd
operator|=
name|_bfd_new_bfd
argument_list|()
expr_stmt|;
if|if
condition|(
name|nbfd
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|target_vec
operator|=
name|bfd_find_target
argument_list|(
name|target
argument_list|,
name|nbfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_vec
operator|==
name|NULL
condition|)
block|{
name|_bfd_delete_bfd
argument_list|(
name|nbfd
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|nbfd
operator|->
name|filename
operator|=
name|filename
expr_stmt|;
name|nbfd
operator|->
name|direction
operator|=
name|write_direction
expr_stmt|;
if|if
condition|(
name|bfd_open_file
argument_list|(
name|nbfd
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* File not writeable, etc.  */
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
name|_bfd_delete_bfd
argument_list|(
name|nbfd
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|nbfd
return|;
block|}
end_function

begin_comment
comment|/*  FUNCTION 	bfd_close  SYNOPSIS 	bfd_boolean bfd_close (bfd *abfd);  DESCRIPTION  	Close a BFD. If the BFD was open for writing, then pending 	operations are completed and the file written out and closed. 	If the created file is executable, then<<chmod>> is called 	to mark it as such.  	All memory attached to the BFD is released.  	The file descriptor associated with the BFD is closed (even 	if it was passed in to BFD by<<bfd_fdopenr>>).  RETURNS<<TRUE>> is returned if all is ok, otherwise<<FALSE>>. */
end_comment

begin_function
name|bfd_boolean
name|bfd_close
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|bfd_boolean
name|ret
decl_stmt|;
if|if
condition|(
name|bfd_write_p
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|BFD_SEND_FMT
argument_list|(
name|abfd
argument_list|,
name|_bfd_write_contents
argument_list|,
operator|(
name|abfd
operator|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|BFD_SEND
argument_list|(
name|abfd
argument_list|,
name|_close_and_cleanup
argument_list|,
operator|(
name|abfd
operator|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|ret
operator|=
name|bfd_cache_close
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* If the file was open for writing and is now executable,      make it so.  */
if|if
condition|(
name|ret
operator|&&
name|abfd
operator|->
name|direction
operator|==
name|write_direction
operator|&&
name|abfd
operator|->
name|flags
operator|&
name|EXEC_P
condition|)
block|{
name|struct
name|stat
name|buf
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|abfd
operator|->
name|filename
argument_list|,
operator|&
name|buf
argument_list|)
operator|==
literal|0
condition|)
block|{
name|unsigned
name|int
name|mask
init|=
name|umask
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|umask
argument_list|(
name|mask
argument_list|)
expr_stmt|;
name|chmod
argument_list|(
name|abfd
operator|->
name|filename
argument_list|,
operator|(
literal|0777
operator|&
operator|(
name|buf
operator|.
name|st_mode
operator||
operator|(
operator|(
name|S_IXUSR
operator||
name|S_IXGRP
operator||
name|S_IXOTH
operator|)
operator|&
operator|~
name|mask
operator|)
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|_bfd_delete_bfd
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* FUNCTION 	bfd_close_all_done  SYNOPSIS 	bfd_boolean bfd_close_all_done (bfd *);  DESCRIPTION 	Close a BFD.  Differs from<<bfd_close>> since it does not 	complete any pending operations.  This routine would be used 	if the application had just used BFD for swapping and didn't 	want to use any of the writing code.  	If the created file is executable, then<<chmod>> is called 	to mark it as such.  	All memory attached to the BFD is released.  RETURNS<<TRUE>> is returned if all is ok, otherwise<<FALSE>>. */
end_comment

begin_function
name|bfd_boolean
name|bfd_close_all_done
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|bfd_boolean
name|ret
decl_stmt|;
name|ret
operator|=
name|bfd_cache_close
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* If the file was open for writing and is now executable,      make it so.  */
if|if
condition|(
name|ret
operator|&&
name|abfd
operator|->
name|direction
operator|==
name|write_direction
operator|&&
name|abfd
operator|->
name|flags
operator|&
name|EXEC_P
condition|)
block|{
name|struct
name|stat
name|buf
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|abfd
operator|->
name|filename
argument_list|,
operator|&
name|buf
argument_list|)
operator|==
literal|0
condition|)
block|{
name|unsigned
name|int
name|mask
init|=
name|umask
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|umask
argument_list|(
name|mask
argument_list|)
expr_stmt|;
name|chmod
argument_list|(
name|abfd
operator|->
name|filename
argument_list|,
operator|(
literal|0777
operator|&
operator|(
name|buf
operator|.
name|st_mode
operator||
operator|(
operator|(
name|S_IXUSR
operator||
name|S_IXGRP
operator||
name|S_IXOTH
operator|)
operator|&
operator|~
name|mask
operator|)
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|_bfd_delete_bfd
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* FUNCTION 	bfd_create  SYNOPSIS 	bfd *bfd_create (const char *filename, bfd *templ);  DESCRIPTION 	Create a new BFD in the manner of<<bfd_openw>>, but without 	opening a file. The new BFD takes the target from the target 	used by @var{template}. The format is always set to<<bfd_object>>. */
end_comment

begin_function
name|bfd
modifier|*
name|bfd_create
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|bfd
modifier|*
name|templ
parameter_list|)
block|{
name|bfd
modifier|*
name|nbfd
decl_stmt|;
name|nbfd
operator|=
name|_bfd_new_bfd
argument_list|()
expr_stmt|;
if|if
condition|(
name|nbfd
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|nbfd
operator|->
name|filename
operator|=
name|filename
expr_stmt|;
if|if
condition|(
name|templ
condition|)
name|nbfd
operator|->
name|xvec
operator|=
name|templ
operator|->
name|xvec
expr_stmt|;
name|nbfd
operator|->
name|direction
operator|=
name|no_direction
expr_stmt|;
name|bfd_set_format
argument_list|(
name|nbfd
argument_list|,
name|bfd_object
argument_list|)
expr_stmt|;
return|return
name|nbfd
return|;
block|}
end_function

begin_comment
comment|/* FUNCTION 	bfd_make_writable  SYNOPSIS 	bfd_boolean bfd_make_writable (bfd *abfd);  DESCRIPTION 	Takes a BFD as created by<<bfd_create>> and converts it 	into one like as returned by<<bfd_openw>>.  It does this 	by converting the BFD to BFD_IN_MEMORY.  It's assumed that 	you will call<<bfd_make_readable>> on this bfd later.  RETURNS<<TRUE>> is returned if all is ok, otherwise<<FALSE>>. */
end_comment

begin_function
name|bfd_boolean
name|bfd_make_writable
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|struct
name|bfd_in_memory
modifier|*
name|bim
decl_stmt|;
if|if
condition|(
name|abfd
operator|->
name|direction
operator|!=
name|no_direction
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|bim
operator|=
name|bfd_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|bfd_in_memory
argument_list|)
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|iostream
operator|=
name|bim
expr_stmt|;
comment|/* bfd_bwrite will grow these as needed.  */
name|bim
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|bim
operator|->
name|buffer
operator|=
literal|0
expr_stmt|;
name|abfd
operator|->
name|flags
operator||=
name|BFD_IN_MEMORY
expr_stmt|;
name|abfd
operator|->
name|direction
operator|=
name|write_direction
expr_stmt|;
name|abfd
operator|->
name|where
operator|=
literal|0
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* FUNCTION 	bfd_make_readable  SYNOPSIS 	bfd_boolean bfd_make_readable (bfd *abfd);  DESCRIPTION 	Takes a BFD as created by<<bfd_create>> and<<bfd_make_writable>> and converts it into one like as 	returned by<<bfd_openr>>.  It does this by writing the 	contents out to the memory buffer, then reversing the 	direction.  RETURNS<<TRUE>> is returned if all is ok, otherwise<<FALSE>>.  */
end_comment

begin_function
name|bfd_boolean
name|bfd_make_readable
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
if|if
condition|(
name|abfd
operator|->
name|direction
operator|!=
name|write_direction
operator|||
operator|!
operator|(
name|abfd
operator|->
name|flags
operator|&
name|BFD_IN_MEMORY
operator|)
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|BFD_SEND_FMT
argument_list|(
name|abfd
argument_list|,
name|_bfd_write_contents
argument_list|,
operator|(
name|abfd
operator|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|BFD_SEND
argument_list|(
name|abfd
argument_list|,
name|_close_and_cleanup
argument_list|,
operator|(
name|abfd
operator|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|abfd
operator|->
name|arch_info
operator|=
operator|&
name|bfd_default_arch_struct
expr_stmt|;
name|abfd
operator|->
name|where
operator|=
literal|0
expr_stmt|;
name|abfd
operator|->
name|format
operator|=
name|bfd_unknown
expr_stmt|;
name|abfd
operator|->
name|my_archive
operator|=
name|NULL
expr_stmt|;
name|abfd
operator|->
name|origin
operator|=
literal|0
expr_stmt|;
name|abfd
operator|->
name|opened_once
operator|=
name|FALSE
expr_stmt|;
name|abfd
operator|->
name|output_has_begun
operator|=
name|FALSE
expr_stmt|;
name|abfd
operator|->
name|section_count
operator|=
literal|0
expr_stmt|;
name|abfd
operator|->
name|usrdata
operator|=
name|NULL
expr_stmt|;
name|abfd
operator|->
name|cacheable
operator|=
name|FALSE
expr_stmt|;
name|abfd
operator|->
name|flags
operator|=
name|BFD_IN_MEMORY
expr_stmt|;
name|abfd
operator|->
name|mtime_set
operator|=
name|FALSE
expr_stmt|;
name|abfd
operator|->
name|target_defaulted
operator|=
name|TRUE
expr_stmt|;
name|abfd
operator|->
name|direction
operator|=
name|read_direction
expr_stmt|;
name|abfd
operator|->
name|sections
operator|=
literal|0
expr_stmt|;
name|abfd
operator|->
name|symcount
operator|=
literal|0
expr_stmt|;
name|abfd
operator|->
name|outsymbols
operator|=
literal|0
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|any
operator|=
literal|0
expr_stmt|;
name|bfd_section_list_clear
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|bfd_check_format
argument_list|(
name|abfd
argument_list|,
name|bfd_object
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* INTERNAL_FUNCTION 	bfd_alloc  SYNOPSIS 	void *bfd_alloc (bfd *abfd, size_t wanted);  DESCRIPTION 	Allocate a block of @var{wanted} bytes of memory attached to<<abfd>> and return a pointer to it. */
end_comment

begin_function
name|void
modifier|*
name|bfd_alloc
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_size_type
name|size
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
name|size
operator|!=
operator|(
name|unsigned
name|long
operator|)
name|size
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ret
operator|=
name|objalloc_alloc
argument_list|(
name|abfd
operator|->
name|memory
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|bfd_zalloc
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_size_type
name|size
parameter_list|)
block|{
name|void
modifier|*
name|res
decl_stmt|;
name|res
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
name|memset
argument_list|(
name|res
argument_list|,
literal|0
argument_list|,
operator|(
name|size_t
operator|)
name|size
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* Free a block allocated for a BFD.    Note:  Also frees all more recently allocated blocks!  */
end_comment

begin_function
name|void
name|bfd_release
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|void
modifier|*
name|block
parameter_list|)
block|{
name|objalloc_free_block
argument_list|(
operator|(
expr|struct
name|objalloc
operator|*
operator|)
name|abfd
operator|->
name|memory
argument_list|,
name|block
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*     GNU Extension: separate debug-info files         The idea here is that a special section called .gnu_debuglink might be    embedded in a binary file, which indicates that some *other* file    contains the real debugging information. This special section contains a    filename and CRC32 checksum, which we read and resolve to another file,    if it exists.     This facilitates "optional" provision of debugging information, without    having to provide two complete copies of every binary object (with and    without debug symbols). */
end_comment

begin_define
define|#
directive|define
name|GNU_DEBUGLINK
value|".gnu_debuglink"
end_define

begin_comment
comment|/* FUNCTION 	bfd_calc_gnu_debuglink_crc32  SYNOPSIS 	unsigned long bfd_calc_gnu_debuglink_crc32 	  (unsigned long crc, const unsigned char *buf, bfd_size_type len);  DESCRIPTION 	Computes a CRC value as used in the .gnu_debuglink section. 	Advances the previously computed @var{crc} value by computing 	and adding in the crc32 for @var{len} bytes of @var{buf}.  RETURNS 	Return the updated CRC32 value. */
end_comment

begin_function
name|unsigned
name|long
name|bfd_calc_gnu_debuglink_crc32
parameter_list|(
name|unsigned
name|long
name|crc
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|bfd_size_type
name|len
parameter_list|)
block|{
specifier|static
specifier|const
name|unsigned
name|long
name|crc32_table
index|[
literal|256
index|]
init|=
block|{
literal|0x00000000
block|,
literal|0x77073096
block|,
literal|0xee0e612c
block|,
literal|0x990951ba
block|,
literal|0x076dc419
block|,
literal|0x706af48f
block|,
literal|0xe963a535
block|,
literal|0x9e6495a3
block|,
literal|0x0edb8832
block|,
literal|0x79dcb8a4
block|,
literal|0xe0d5e91e
block|,
literal|0x97d2d988
block|,
literal|0x09b64c2b
block|,
literal|0x7eb17cbd
block|,
literal|0xe7b82d07
block|,
literal|0x90bf1d91
block|,
literal|0x1db71064
block|,
literal|0x6ab020f2
block|,
literal|0xf3b97148
block|,
literal|0x84be41de
block|,
literal|0x1adad47d
block|,
literal|0x6ddde4eb
block|,
literal|0xf4d4b551
block|,
literal|0x83d385c7
block|,
literal|0x136c9856
block|,
literal|0x646ba8c0
block|,
literal|0xfd62f97a
block|,
literal|0x8a65c9ec
block|,
literal|0x14015c4f
block|,
literal|0x63066cd9
block|,
literal|0xfa0f3d63
block|,
literal|0x8d080df5
block|,
literal|0x3b6e20c8
block|,
literal|0x4c69105e
block|,
literal|0xd56041e4
block|,
literal|0xa2677172
block|,
literal|0x3c03e4d1
block|,
literal|0x4b04d447
block|,
literal|0xd20d85fd
block|,
literal|0xa50ab56b
block|,
literal|0x35b5a8fa
block|,
literal|0x42b2986c
block|,
literal|0xdbbbc9d6
block|,
literal|0xacbcf940
block|,
literal|0x32d86ce3
block|,
literal|0x45df5c75
block|,
literal|0xdcd60dcf
block|,
literal|0xabd13d59
block|,
literal|0x26d930ac
block|,
literal|0x51de003a
block|,
literal|0xc8d75180
block|,
literal|0xbfd06116
block|,
literal|0x21b4f4b5
block|,
literal|0x56b3c423
block|,
literal|0xcfba9599
block|,
literal|0xb8bda50f
block|,
literal|0x2802b89e
block|,
literal|0x5f058808
block|,
literal|0xc60cd9b2
block|,
literal|0xb10be924
block|,
literal|0x2f6f7c87
block|,
literal|0x58684c11
block|,
literal|0xc1611dab
block|,
literal|0xb6662d3d
block|,
literal|0x76dc4190
block|,
literal|0x01db7106
block|,
literal|0x98d220bc
block|,
literal|0xefd5102a
block|,
literal|0x71b18589
block|,
literal|0x06b6b51f
block|,
literal|0x9fbfe4a5
block|,
literal|0xe8b8d433
block|,
literal|0x7807c9a2
block|,
literal|0x0f00f934
block|,
literal|0x9609a88e
block|,
literal|0xe10e9818
block|,
literal|0x7f6a0dbb
block|,
literal|0x086d3d2d
block|,
literal|0x91646c97
block|,
literal|0xe6635c01
block|,
literal|0x6b6b51f4
block|,
literal|0x1c6c6162
block|,
literal|0x856530d8
block|,
literal|0xf262004e
block|,
literal|0x6c0695ed
block|,
literal|0x1b01a57b
block|,
literal|0x8208f4c1
block|,
literal|0xf50fc457
block|,
literal|0x65b0d9c6
block|,
literal|0x12b7e950
block|,
literal|0x8bbeb8ea
block|,
literal|0xfcb9887c
block|,
literal|0x62dd1ddf
block|,
literal|0x15da2d49
block|,
literal|0x8cd37cf3
block|,
literal|0xfbd44c65
block|,
literal|0x4db26158
block|,
literal|0x3ab551ce
block|,
literal|0xa3bc0074
block|,
literal|0xd4bb30e2
block|,
literal|0x4adfa541
block|,
literal|0x3dd895d7
block|,
literal|0xa4d1c46d
block|,
literal|0xd3d6f4fb
block|,
literal|0x4369e96a
block|,
literal|0x346ed9fc
block|,
literal|0xad678846
block|,
literal|0xda60b8d0
block|,
literal|0x44042d73
block|,
literal|0x33031de5
block|,
literal|0xaa0a4c5f
block|,
literal|0xdd0d7cc9
block|,
literal|0x5005713c
block|,
literal|0x270241aa
block|,
literal|0xbe0b1010
block|,
literal|0xc90c2086
block|,
literal|0x5768b525
block|,
literal|0x206f85b3
block|,
literal|0xb966d409
block|,
literal|0xce61e49f
block|,
literal|0x5edef90e
block|,
literal|0x29d9c998
block|,
literal|0xb0d09822
block|,
literal|0xc7d7a8b4
block|,
literal|0x59b33d17
block|,
literal|0x2eb40d81
block|,
literal|0xb7bd5c3b
block|,
literal|0xc0ba6cad
block|,
literal|0xedb88320
block|,
literal|0x9abfb3b6
block|,
literal|0x03b6e20c
block|,
literal|0x74b1d29a
block|,
literal|0xead54739
block|,
literal|0x9dd277af
block|,
literal|0x04db2615
block|,
literal|0x73dc1683
block|,
literal|0xe3630b12
block|,
literal|0x94643b84
block|,
literal|0x0d6d6a3e
block|,
literal|0x7a6a5aa8
block|,
literal|0xe40ecf0b
block|,
literal|0x9309ff9d
block|,
literal|0x0a00ae27
block|,
literal|0x7d079eb1
block|,
literal|0xf00f9344
block|,
literal|0x8708a3d2
block|,
literal|0x1e01f268
block|,
literal|0x6906c2fe
block|,
literal|0xf762575d
block|,
literal|0x806567cb
block|,
literal|0x196c3671
block|,
literal|0x6e6b06e7
block|,
literal|0xfed41b76
block|,
literal|0x89d32be0
block|,
literal|0x10da7a5a
block|,
literal|0x67dd4acc
block|,
literal|0xf9b9df6f
block|,
literal|0x8ebeeff9
block|,
literal|0x17b7be43
block|,
literal|0x60b08ed5
block|,
literal|0xd6d6a3e8
block|,
literal|0xa1d1937e
block|,
literal|0x38d8c2c4
block|,
literal|0x4fdff252
block|,
literal|0xd1bb67f1
block|,
literal|0xa6bc5767
block|,
literal|0x3fb506dd
block|,
literal|0x48b2364b
block|,
literal|0xd80d2bda
block|,
literal|0xaf0a1b4c
block|,
literal|0x36034af6
block|,
literal|0x41047a60
block|,
literal|0xdf60efc3
block|,
literal|0xa867df55
block|,
literal|0x316e8eef
block|,
literal|0x4669be79
block|,
literal|0xcb61b38c
block|,
literal|0xbc66831a
block|,
literal|0x256fd2a0
block|,
literal|0x5268e236
block|,
literal|0xcc0c7795
block|,
literal|0xbb0b4703
block|,
literal|0x220216b9
block|,
literal|0x5505262f
block|,
literal|0xc5ba3bbe
block|,
literal|0xb2bd0b28
block|,
literal|0x2bb45a92
block|,
literal|0x5cb36a04
block|,
literal|0xc2d7ffa7
block|,
literal|0xb5d0cf31
block|,
literal|0x2cd99e8b
block|,
literal|0x5bdeae1d
block|,
literal|0x9b64c2b0
block|,
literal|0xec63f226
block|,
literal|0x756aa39c
block|,
literal|0x026d930a
block|,
literal|0x9c0906a9
block|,
literal|0xeb0e363f
block|,
literal|0x72076785
block|,
literal|0x05005713
block|,
literal|0x95bf4a82
block|,
literal|0xe2b87a14
block|,
literal|0x7bb12bae
block|,
literal|0x0cb61b38
block|,
literal|0x92d28e9b
block|,
literal|0xe5d5be0d
block|,
literal|0x7cdcefb7
block|,
literal|0x0bdbdf21
block|,
literal|0x86d3d2d4
block|,
literal|0xf1d4e242
block|,
literal|0x68ddb3f8
block|,
literal|0x1fda836e
block|,
literal|0x81be16cd
block|,
literal|0xf6b9265b
block|,
literal|0x6fb077e1
block|,
literal|0x18b74777
block|,
literal|0x88085ae6
block|,
literal|0xff0f6a70
block|,
literal|0x66063bca
block|,
literal|0x11010b5c
block|,
literal|0x8f659eff
block|,
literal|0xf862ae69
block|,
literal|0x616bffd3
block|,
literal|0x166ccf45
block|,
literal|0xa00ae278
block|,
literal|0xd70dd2ee
block|,
literal|0x4e048354
block|,
literal|0x3903b3c2
block|,
literal|0xa7672661
block|,
literal|0xd06016f7
block|,
literal|0x4969474d
block|,
literal|0x3e6e77db
block|,
literal|0xaed16a4a
block|,
literal|0xd9d65adc
block|,
literal|0x40df0b66
block|,
literal|0x37d83bf0
block|,
literal|0xa9bcae53
block|,
literal|0xdebb9ec5
block|,
literal|0x47b2cf7f
block|,
literal|0x30b5ffe9
block|,
literal|0xbdbdf21c
block|,
literal|0xcabac28a
block|,
literal|0x53b39330
block|,
literal|0x24b4a3a6
block|,
literal|0xbad03605
block|,
literal|0xcdd70693
block|,
literal|0x54de5729
block|,
literal|0x23d967bf
block|,
literal|0xb3667a2e
block|,
literal|0xc4614ab8
block|,
literal|0x5d681b02
block|,
literal|0x2a6f2b94
block|,
literal|0xb40bbe37
block|,
literal|0xc30c8ea1
block|,
literal|0x5a05df1b
block|,
literal|0x2d02ef8d
block|}
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|end
decl_stmt|;
name|crc
operator|=
operator|~
name|crc
operator|&
literal|0xffffffff
expr_stmt|;
for|for
control|(
name|end
operator|=
name|buf
operator|+
name|len
init|;
name|buf
operator|<
name|end
condition|;
operator|++
name|buf
control|)
name|crc
operator|=
name|crc32_table
index|[
operator|(
name|crc
operator|^
operator|*
name|buf
operator|)
operator|&
literal|0xff
index|]
operator|^
operator|(
name|crc
operator|>>
literal|8
operator|)
expr_stmt|;
return|return
operator|~
name|crc
operator|&
literal|0xffffffff
return|;
empty_stmt|;
block|}
end_function

begin_comment
comment|/* INTERNAL_FUNCTION 	get_debug_link_info  SYNOPSIS 	char *get_debug_link_info (bfd *abfd, unsigned long *crc32_out);  DESCRIPTION 	fetch the filename and CRC32 value for any separate debuginfo 	associated with @var{abfd}. Return NULL if no such info found, 	otherwise return filename and update @var{crc32_out}. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|get_debug_link_info
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|unsigned
name|long
modifier|*
name|crc32_out
parameter_list|)
block|{
name|asection
modifier|*
name|sect
decl_stmt|;
name|bfd_size_type
name|debuglink_size
decl_stmt|;
name|unsigned
name|long
name|crc32
decl_stmt|;
name|char
modifier|*
name|contents
decl_stmt|;
name|int
name|crc_offset
decl_stmt|;
name|bfd_boolean
name|ret
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|crc32_out
argument_list|)
expr_stmt|;
name|sect
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|GNU_DEBUGLINK
argument_list|)
expr_stmt|;
if|if
condition|(
name|sect
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|debuglink_size
operator|=
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|)
expr_stmt|;
name|contents
operator|=
name|malloc
argument_list|(
name|debuglink_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|ret
operator|=
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|,
name|contents
argument_list|,
literal|0
argument_list|,
name|debuglink_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Crc value is stored after the filename, aligned up to 4 bytes.  */
name|crc_offset
operator|=
name|strlen
argument_list|(
name|contents
argument_list|)
operator|+
literal|1
expr_stmt|;
name|crc_offset
operator|=
operator|(
name|crc_offset
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
name|crc32
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|crc_offset
argument_list|)
expr_stmt|;
operator|*
name|crc32_out
operator|=
name|crc32
expr_stmt|;
return|return
name|contents
return|;
block|}
end_function

begin_comment
comment|/* INTERNAL_FUNCTION 	separate_debug_file_exists  SYNOPSIS 	bfd_boolean separate_debug_file_exists 	  (char *name, unsigned long crc32);  DESCRIPTION 	Checks to see if @var{name} is a file and if its contents 	match @var{crc32}. */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|separate_debug_file_exists
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|unsigned
name|long
name|crc
parameter_list|)
block|{
specifier|static
name|char
name|buffer
index|[
literal|8
operator|*
literal|1024
index|]
decl_stmt|;
name|unsigned
name|long
name|file_crc
init|=
literal|0
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|bfd_size_type
name|count
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
return|return
name|FALSE
return|;
while|while
condition|(
operator|(
name|count
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|file_crc
operator|=
name|bfd_calc_gnu_debuglink_crc32
argument_list|(
name|file_crc
argument_list|,
name|buffer
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|crc
operator|==
name|file_crc
return|;
block|}
end_function

begin_comment
comment|/* INTERNAL_FUNCTION 	find_separate_debug_file  SYNOPSIS 	char *find_separate_debug_file (bfd *abfd);  DESCRIPTION 	Searches @var{abfd} for a reference to separate debugging 	information, scans various locations in the filesystem, including 	the file tree rooted at @var{debug_file_directory}, and returns a 	filename of such debugging information if the file is found and has 	matching CRC32.  Returns NULL if no reference to debugging file 	exists, or file cannot be found. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|find_separate_debug_file
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|char
modifier|*
name|debug_file_directory
parameter_list|)
block|{
name|char
modifier|*
name|basename
decl_stmt|;
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|debugfile
decl_stmt|;
name|unsigned
name|long
name|crc32
decl_stmt|;
name|int
name|i
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_file_directory
operator|==
name|NULL
condition|)
name|debug_file_directory
operator|=
literal|"."
expr_stmt|;
comment|/* BFD may have been opened from a stream.  */
if|if
condition|(
operator|!
name|abfd
operator|->
name|filename
condition|)
return|return
name|NULL
return|;
name|basename
operator|=
name|get_debug_link_info
argument_list|(
name|abfd
argument_list|,
operator|&
name|crc32
argument_list|)
expr_stmt|;
if|if
condition|(
name|basename
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|strlen
argument_list|(
name|basename
argument_list|)
operator|<
literal|1
condition|)
block|{
name|free
argument_list|(
name|basename
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|dir
operator|=
name|strdup
argument_list|(
name|abfd
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|basename
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|BFD_ASSERT
argument_list|(
name|strlen
argument_list|(
name|dir
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* Strip off filename part.  */
for|for
control|(
name|i
operator|=
name|strlen
argument_list|(
name|dir
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|IS_DIR_SEPARATOR
argument_list|(
name|dir
index|[
name|i
index|]
argument_list|)
condition|)
break|break;
name|dir
index|[
name|i
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|BFD_ASSERT
argument_list|(
argument|dir[i] ==
literal|'/'
argument||| dir[
literal|0
argument|] ==
literal|'\0'
argument_list|)
name|debugfile
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|debug_file_directory
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|dir
argument_list|)
operator|+
name|strlen
argument_list|(
literal|".debug/"
argument_list|)
operator|+
name|strlen
argument_list|(
name|basename
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|debugfile
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|basename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dir
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* First try in the same directory as the original file:  */
name|strcpy
argument_list|(
name|debugfile
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|debugfile
argument_list|,
name|basename
argument_list|)
expr_stmt|;
if|if
condition|(
name|separate_debug_file_exists
argument_list|(
name|debugfile
argument_list|,
name|crc32
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|basename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dir
argument_list|)
expr_stmt|;
return|return
name|debugfile
return|;
block|}
comment|/* Then try in a subdirectory called .debug.  */
name|strcpy
argument_list|(
name|debugfile
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|debugfile
argument_list|,
literal|".debug/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|debugfile
argument_list|,
name|basename
argument_list|)
expr_stmt|;
if|if
condition|(
name|separate_debug_file_exists
argument_list|(
name|debugfile
argument_list|,
name|crc32
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|basename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dir
argument_list|)
expr_stmt|;
return|return
name|debugfile
return|;
block|}
comment|/* Then try in the global debugfile directory.  */
name|strcpy
argument_list|(
name|debugfile
argument_list|,
name|debug_file_directory
argument_list|)
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|debug_file_directory
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
name|debug_file_directory
index|[
name|i
index|]
operator|!=
literal|'/'
operator|&&
name|dir
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
name|strcat
argument_list|(
name|debugfile
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|debugfile
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|debugfile
argument_list|,
name|basename
argument_list|)
expr_stmt|;
if|if
condition|(
name|separate_debug_file_exists
argument_list|(
name|debugfile
argument_list|,
name|crc32
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|basename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dir
argument_list|)
expr_stmt|;
return|return
name|debugfile
return|;
block|}
name|free
argument_list|(
name|debugfile
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|basename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dir
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* FUNCTION 	bfd_follow_gnu_debuglink  SYNOPSIS 	char *bfd_follow_gnu_debuglink (bfd *abfd, const char *dir);  DESCRIPTION  	Takes a BFD and searches it for a .gnu_debuglink section.  If this 	section is found, it examines the section for the name and checksum 	of a '.debug' file containing auxiliary debugging information.  It 	then searches the filesystem for this .debug file in some standard 	locations, including the directory tree rooted at @var{dir}, and if 	found returns the full filename.  	If @var{dir} is NULL, it will search a default path configured into 	libbfd at build time.  [XXX this feature is not currently 	implemented].  RETURNS<<NULL>> on any errors or failure to locate the .debug file, 	otherwise a pointer to a heap-allocated string containing the 	filename.  The caller is responsible for freeing this string. */
end_comment

begin_function
name|char
modifier|*
name|bfd_follow_gnu_debuglink
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|char
modifier|*
name|dir
parameter_list|)
block|{
if|#
directive|if
literal|0
comment|/* Disabled until DEBUGDIR can be defined by configure.in.  */
block|if (dir == NULL)     dir = DEBUGDIR;
endif|#
directive|endif
return|return
name|find_separate_debug_file
argument_list|(
name|abfd
argument_list|,
name|dir
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* FUNCTION 	bfd_create_gnu_debuglink_section  SYNOPSIS 	struct bfd_section *bfd_create_gnu_debuglink_section 	  (bfd *abfd, const char *filename);  DESCRIPTION  	Takes a @var{BFD} and adds a .gnu_debuglink section to it.  The section is sized 	to be big enough to contain a link to the specified @var{filename}.  RETURNS 	A pointer to the new section is returned if all is ok.  Otherwise<<NULL>> is 	returned and bfd_error is set.   */
end_comment

begin_function
name|asection
modifier|*
name|bfd_create_gnu_debuglink_section
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|asection
modifier|*
name|sect
decl_stmt|;
name|bfd_size_type
name|debuglink_size
decl_stmt|;
if|if
condition|(
name|abfd
operator|==
name|NULL
operator|||
name|filename
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Strip off any path components in filename.  */
name|filename
operator|=
name|lbasename
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|sect
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|GNU_DEBUGLINK
argument_list|)
expr_stmt|;
if|if
condition|(
name|sect
condition|)
block|{
comment|/* Section already exists.  */
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|sect
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
name|GNU_DEBUGLINK
argument_list|)
expr_stmt|;
if|if
condition|(
name|sect
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|,
name|SEC_HAS_CONTENTS
operator||
name|SEC_READONLY
operator||
name|SEC_DEBUGGING
argument_list|)
condition|)
comment|/* XXX Should we delete the section from the bfd ?  */
return|return
name|NULL
return|;
name|debuglink_size
operator|=
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
literal|1
expr_stmt|;
name|debuglink_size
operator|+=
literal|3
expr_stmt|;
name|debuglink_size
operator|&=
operator|~
literal|3
expr_stmt|;
name|debuglink_size
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_size
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|,
name|debuglink_size
argument_list|)
condition|)
comment|/* XXX Should we delete the section from the bfd ?  */
return|return
name|NULL
return|;
return|return
name|sect
return|;
block|}
end_function

begin_comment
comment|/* FUNCTION 	bfd_fill_in_gnu_debuglink_section  SYNOPSIS 	bfd_boolean bfd_fill_in_gnu_debuglink_section 	  (bfd *abfd, struct bfd_section *sect, const char *filename);  DESCRIPTION  	Takes a @var{BFD} and containing a .gnu_debuglink section @var{SECT} 	and fills in the contents of the section to contain a link to the 	specified @var{filename}.  The filename should be relative to the 	current directory.  RETURNS<<TRUE>> is returned if all is ok.  Otherwise<<FALSE>> is returned 	and bfd_error is set.   */
end_comment

begin_function
name|bfd_boolean
name|bfd_fill_in_gnu_debuglink_section
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_section
modifier|*
name|sect
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|bfd_size_type
name|debuglink_size
decl_stmt|;
name|unsigned
name|long
name|crc32
decl_stmt|;
name|char
modifier|*
name|contents
decl_stmt|;
name|bfd_size_type
name|crc_offset
decl_stmt|;
name|FILE
modifier|*
name|handle
decl_stmt|;
specifier|static
name|char
name|buffer
index|[
literal|8
operator|*
literal|1024
index|]
decl_stmt|;
name|size_t
name|count
decl_stmt|;
if|if
condition|(
name|abfd
operator|==
name|NULL
operator|||
name|sect
operator|==
name|NULL
operator|||
name|filename
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Make sure that we can read the file.      XXX - Should we attempt to locate the debug info file using the same      algorithm as gdb ?  At the moment, since we are creating the      .gnu_debuglink section, we insist upon the user providing us with a      correct-for-section-creation-time path, but this need not conform to      the gdb location algorithm.  */
name|handle
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
name|FOPEN_RB
argument_list|)
expr_stmt|;
if|if
condition|(
name|handle
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|crc32
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|count
operator|=
name|fread
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
name|buffer
argument_list|,
name|handle
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|crc32
operator|=
name|bfd_calc_gnu_debuglink_crc32
argument_list|(
name|crc32
argument_list|,
name|buffer
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|handle
argument_list|)
expr_stmt|;
comment|/* Strip off any path components in filename,      now that we no longer need them.  */
name|filename
operator|=
name|lbasename
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|debuglink_size
operator|=
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
literal|1
expr_stmt|;
name|debuglink_size
operator|+=
literal|3
expr_stmt|;
name|debuglink_size
operator|&=
operator|~
literal|3
expr_stmt|;
name|debuglink_size
operator|+=
literal|4
expr_stmt|;
name|contents
operator|=
name|malloc
argument_list|(
name|debuglink_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
block|{
comment|/* XXX Should we delete the section from the bfd ?  */
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|strcpy
argument_list|(
name|contents
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|crc_offset
operator|=
name|debuglink_size
operator|-
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|crc32
argument_list|,
name|contents
operator|+
name|crc_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|,
name|contents
argument_list|,
literal|0
argument_list|,
name|debuglink_size
argument_list|)
condition|)
block|{
comment|/* XXX Should we delete the section from the bfd ?  */
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

end_unit

