begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* opncls.c -- open and close a BFD.    Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 2000,    2001    Free Software Foundation, Inc.     Written by Cygnus Support.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"objalloc.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|S_IXUSR
end_ifndef

begin_define
define|#
directive|define
name|S_IXUSR
value|0100
end_define

begin_comment
comment|/* Execute by owner.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|S_IXGRP
end_ifndef

begin_define
define|#
directive|define
name|S_IXGRP
value|0010
end_define

begin_comment
comment|/* Execute by group.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|S_IXOTH
end_ifndef

begin_define
define|#
directive|define
name|S_IXOTH
value|0001
end_define

begin_comment
comment|/* Execute by others.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* fdopen is a loser -- we should use stdio exclusively.  Unfortunately    if we do that we can't use fcntl.  */
end_comment

begin_comment
comment|/* FIXME: This is no longer used.  */
end_comment

begin_decl_stmt
name|long
name|_bfd_chunksize
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return a new BFD.  All BFD's are allocated through this routine.  */
end_comment

begin_function
name|bfd
modifier|*
name|_bfd_new_bfd
parameter_list|()
block|{
name|bfd
modifier|*
name|nbfd
decl_stmt|;
name|nbfd
operator|=
operator|(
name|bfd
operator|*
operator|)
name|bfd_zmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|bfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbfd
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|nbfd
operator|->
name|memory
operator|=
operator|(
name|PTR
operator|)
name|objalloc_create
argument_list|()
expr_stmt|;
if|if
condition|(
name|nbfd
operator|->
name|memory
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|nbfd
operator|->
name|arch_info
operator|=
operator|&
name|bfd_default_arch_struct
expr_stmt|;
name|nbfd
operator|->
name|direction
operator|=
name|no_direction
expr_stmt|;
name|nbfd
operator|->
name|iostream
operator|=
name|NULL
expr_stmt|;
name|nbfd
operator|->
name|where
operator|=
literal|0
expr_stmt|;
name|nbfd
operator|->
name|sections
operator|=
operator|(
name|asection
operator|*
operator|)
name|NULL
expr_stmt|;
name|nbfd
operator|->
name|format
operator|=
name|bfd_unknown
expr_stmt|;
name|nbfd
operator|->
name|my_archive
operator|=
operator|(
name|bfd
operator|*
operator|)
name|NULL
expr_stmt|;
name|nbfd
operator|->
name|origin
operator|=
literal|0
expr_stmt|;
name|nbfd
operator|->
name|opened_once
operator|=
name|false
expr_stmt|;
name|nbfd
operator|->
name|output_has_begun
operator|=
name|false
expr_stmt|;
name|nbfd
operator|->
name|section_count
operator|=
literal|0
expr_stmt|;
name|nbfd
operator|->
name|usrdata
operator|=
operator|(
name|PTR
operator|)
name|NULL
expr_stmt|;
name|nbfd
operator|->
name|cacheable
operator|=
name|false
expr_stmt|;
name|nbfd
operator|->
name|flags
operator|=
name|BFD_NO_FLAGS
expr_stmt|;
name|nbfd
operator|->
name|mtime_set
operator|=
name|false
expr_stmt|;
return|return
name|nbfd
return|;
block|}
end_function

begin_comment
comment|/* Allocate a new BFD as a member of archive OBFD.  */
end_comment

begin_function
name|bfd
modifier|*
name|_bfd_new_bfd_contained_in
parameter_list|(
name|obfd
parameter_list|)
name|bfd
modifier|*
name|obfd
decl_stmt|;
block|{
name|bfd
modifier|*
name|nbfd
decl_stmt|;
name|nbfd
operator|=
name|_bfd_new_bfd
argument_list|()
expr_stmt|;
name|nbfd
operator|->
name|xvec
operator|=
name|obfd
operator|->
name|xvec
expr_stmt|;
name|nbfd
operator|->
name|my_archive
operator|=
name|obfd
expr_stmt|;
name|nbfd
operator|->
name|direction
operator|=
name|read_direction
expr_stmt|;
name|nbfd
operator|->
name|target_defaulted
operator|=
name|obfd
operator|->
name|target_defaulted
expr_stmt|;
return|return
name|nbfd
return|;
block|}
end_function

begin_comment
comment|/* SECTION 	Opening and closing BFDs  */
end_comment

begin_comment
comment|/* FUNCTION 	bfd_openr  SYNOPSIS         bfd *bfd_openr(CONST char *filename, CONST char *target);  DESCRIPTION 	Open the file @var{filename} (using<<fopen>>) with the target 	@var{target}.  Return a pointer to the created BFD.  	Calls<<bfd_find_target>>, so @var{target} is interpreted as by 	that function.  	If<<NULL>> is returned then an error has occured.   Possible errors 	are<<bfd_error_no_memory>>,<<bfd_error_invalid_target>> or<<system_call>> error. */
end_comment

begin_function
name|bfd
modifier|*
name|bfd_openr
parameter_list|(
name|filename
parameter_list|,
name|target
parameter_list|)
name|CONST
name|char
modifier|*
name|filename
decl_stmt|;
name|CONST
name|char
modifier|*
name|target
decl_stmt|;
block|{
name|bfd
modifier|*
name|nbfd
decl_stmt|;
specifier|const
name|bfd_target
modifier|*
name|target_vec
decl_stmt|;
name|nbfd
operator|=
name|_bfd_new_bfd
argument_list|()
expr_stmt|;
if|if
condition|(
name|nbfd
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|target_vec
operator|=
name|bfd_find_target
argument_list|(
name|target
argument_list|,
name|nbfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_vec
operator|==
name|NULL
condition|)
block|{
name|objalloc_free
argument_list|(
operator|(
expr|struct
name|objalloc
operator|*
operator|)
name|nbfd
operator|->
name|memory
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nbfd
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_target
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|nbfd
operator|->
name|filename
operator|=
name|filename
expr_stmt|;
name|nbfd
operator|->
name|direction
operator|=
name|read_direction
expr_stmt|;
if|if
condition|(
name|bfd_open_file
argument_list|(
name|nbfd
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* File didn't exist, or some such */
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
name|objalloc_free
argument_list|(
operator|(
expr|struct
name|objalloc
operator|*
operator|)
name|nbfd
operator|->
name|memory
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nbfd
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|nbfd
return|;
block|}
end_function

begin_comment
comment|/* Don't try to `optimize' this function:     o - We lock using stack space so that interrupting the locking        won't cause a storage leak.    o - We open the file stream last, since we don't want to have to        close it if anything goes wrong.  Closing the stream means closing        the file descriptor too, even though we didn't open it.  */
end_comment

begin_comment
comment|/* FUNCTION          bfd_fdopenr  SYNOPSIS          bfd *bfd_fdopenr(CONST char *filename, CONST char *target, int fd);  DESCRIPTION<<bfd_fdopenr>> is to<<bfd_fopenr>> much like<<fdopen>> is to<<fopen>>. 	 It opens a BFD on a file already described by the @var{fd} 	 supplied.  	 When the file is later<<bfd_close>>d, the file descriptor will be closed.  	 If the caller desires that this file descriptor be cached by BFD 	 (opened as needed, closed as needed to free descriptors for 	 other opens), with the supplied @var{fd} used as an initial 	 file descriptor (but subject to closure at any time), call 	 bfd_set_cacheable(bfd, 1) on the returned BFD.  The default is to 	 assume no cacheing; the file descriptor will remain open until<<bfd_close>>, and will not be affected by BFD operations on other 	 files.           Possible errors are<<bfd_error_no_memory>>,<<bfd_error_invalid_target>> and<<bfd_error_system_call>>. */
end_comment

begin_function
name|bfd
modifier|*
name|bfd_fdopenr
parameter_list|(
name|filename
parameter_list|,
name|target
parameter_list|,
name|fd
parameter_list|)
name|CONST
name|char
modifier|*
name|filename
decl_stmt|;
name|CONST
name|char
modifier|*
name|target
decl_stmt|;
name|int
name|fd
decl_stmt|;
block|{
name|bfd
modifier|*
name|nbfd
decl_stmt|;
specifier|const
name|bfd_target
modifier|*
name|target_vec
decl_stmt|;
name|int
name|fdflags
decl_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_FCNTL
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|F_GETFL
argument_list|)
name|fdflags
operator|=
name|O_RDWR
expr_stmt|;
comment|/* Assume full access */
else|#
directive|else
name|fdflags
operator|=
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_GETFL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|fdflags
operator|==
operator|-
literal|1
condition|)
return|return
name|NULL
return|;
name|nbfd
operator|=
name|_bfd_new_bfd
argument_list|()
expr_stmt|;
if|if
condition|(
name|nbfd
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|target_vec
operator|=
name|bfd_find_target
argument_list|(
name|target
argument_list|,
name|nbfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_vec
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_target
argument_list|)
expr_stmt|;
name|objalloc_free
argument_list|(
operator|(
expr|struct
name|objalloc
operator|*
operator|)
name|nbfd
operator|->
name|memory
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nbfd
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
ifndef|#
directive|ifndef
name|HAVE_FDOPEN
name|nbfd
operator|->
name|iostream
operator|=
operator|(
name|PTR
operator|)
name|fopen
argument_list|(
name|filename
argument_list|,
name|FOPEN_RB
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* (O_ACCMODE) parens are to avoid Ultrix header file bug */
switch|switch
condition|(
name|fdflags
operator|&
operator|(
name|O_ACCMODE
operator|)
condition|)
block|{
case|case
name|O_RDONLY
case|:
name|nbfd
operator|->
name|iostream
operator|=
operator|(
name|PTR
operator|)
name|fdopen
argument_list|(
name|fd
argument_list|,
name|FOPEN_RB
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_WRONLY
case|:
name|nbfd
operator|->
name|iostream
operator|=
operator|(
name|PTR
operator|)
name|fdopen
argument_list|(
name|fd
argument_list|,
name|FOPEN_RUB
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_RDWR
case|:
name|nbfd
operator|->
name|iostream
operator|=
operator|(
name|PTR
operator|)
name|fdopen
argument_list|(
name|fd
argument_list|,
name|FOPEN_RUB
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|nbfd
operator|->
name|iostream
operator|==
name|NULL
condition|)
block|{
name|objalloc_free
argument_list|(
operator|(
expr|struct
name|objalloc
operator|*
operator|)
name|nbfd
operator|->
name|memory
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nbfd
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* OK, put everything where it belongs */
name|nbfd
operator|->
name|filename
operator|=
name|filename
expr_stmt|;
comment|/* As a special case we allow a FD open for read/write to      be written through, although doing so requires that we end      the previous clause with a preposition.  */
comment|/* (O_ACCMODE) parens are to avoid Ultrix header file bug */
switch|switch
condition|(
name|fdflags
operator|&
operator|(
name|O_ACCMODE
operator|)
condition|)
block|{
case|case
name|O_RDONLY
case|:
name|nbfd
operator|->
name|direction
operator|=
name|read_direction
expr_stmt|;
break|break;
case|case
name|O_WRONLY
case|:
name|nbfd
operator|->
name|direction
operator|=
name|write_direction
expr_stmt|;
break|break;
case|case
name|O_RDWR
case|:
name|nbfd
operator|->
name|direction
operator|=
name|both_direction
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bfd_cache_init
argument_list|(
name|nbfd
argument_list|)
condition|)
block|{
name|objalloc_free
argument_list|(
operator|(
expr|struct
name|objalloc
operator|*
operator|)
name|nbfd
operator|->
name|memory
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nbfd
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|nbfd
operator|->
name|opened_once
operator|=
name|true
expr_stmt|;
return|return
name|nbfd
return|;
block|}
end_function

begin_comment
comment|/* FUNCTION 	bfd_openstreamr  SYNOPSIS 	bfd *bfd_openstreamr(const char *, const char *, PTR);  DESCRIPTION  	Open a BFD for read access on an existing stdio stream.  When 	the BFD is passed to<<bfd_close>>, the stream will be closed. */
end_comment

begin_function
name|bfd
modifier|*
name|bfd_openstreamr
parameter_list|(
name|filename
parameter_list|,
name|target
parameter_list|,
name|streamarg
parameter_list|)
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
specifier|const
name|char
modifier|*
name|target
decl_stmt|;
name|PTR
name|streamarg
decl_stmt|;
block|{
name|FILE
modifier|*
name|stream
init|=
operator|(
name|FILE
operator|*
operator|)
name|streamarg
decl_stmt|;
name|bfd
modifier|*
name|nbfd
decl_stmt|;
specifier|const
name|bfd_target
modifier|*
name|target_vec
decl_stmt|;
name|nbfd
operator|=
name|_bfd_new_bfd
argument_list|()
expr_stmt|;
if|if
condition|(
name|nbfd
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|target_vec
operator|=
name|bfd_find_target
argument_list|(
name|target
argument_list|,
name|nbfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_vec
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_target
argument_list|)
expr_stmt|;
name|objalloc_free
argument_list|(
operator|(
expr|struct
name|objalloc
operator|*
operator|)
name|nbfd
operator|->
name|memory
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nbfd
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|nbfd
operator|->
name|iostream
operator|=
operator|(
name|PTR
operator|)
name|stream
expr_stmt|;
name|nbfd
operator|->
name|filename
operator|=
name|filename
expr_stmt|;
name|nbfd
operator|->
name|direction
operator|=
name|read_direction
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_cache_init
argument_list|(
name|nbfd
argument_list|)
condition|)
block|{
name|objalloc_free
argument_list|(
operator|(
expr|struct
name|objalloc
operator|*
operator|)
name|nbfd
operator|->
name|memory
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nbfd
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|nbfd
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/** bfd_openw -- open for writing.   Returns a pointer to a freshly-allocated BFD on success, or NULL.    See comment by bfd_fdopenr before you try to modify this function. */
end_comment

begin_comment
comment|/* FUNCTION 	bfd_openw  SYNOPSIS 	bfd *bfd_openw(CONST char *filename, CONST char *target);  DESCRIPTION 	Create a BFD, associated with file @var{filename}, using the 	file format @var{target}, and return a pointer to it.  	Possible errors are<<bfd_error_system_call>>,<<bfd_error_no_memory>>,<<bfd_error_invalid_target>>. */
end_comment

begin_function
name|bfd
modifier|*
name|bfd_openw
parameter_list|(
name|filename
parameter_list|,
name|target
parameter_list|)
name|CONST
name|char
modifier|*
name|filename
decl_stmt|;
name|CONST
name|char
modifier|*
name|target
decl_stmt|;
block|{
name|bfd
modifier|*
name|nbfd
decl_stmt|;
specifier|const
name|bfd_target
modifier|*
name|target_vec
decl_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
comment|/* nbfd has to point to head of malloc'ed block so that bfd_close may      reclaim it correctly. */
name|nbfd
operator|=
name|_bfd_new_bfd
argument_list|()
expr_stmt|;
if|if
condition|(
name|nbfd
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|target_vec
operator|=
name|bfd_find_target
argument_list|(
name|target
argument_list|,
name|nbfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_vec
operator|==
name|NULL
condition|)
block|{
name|objalloc_free
argument_list|(
operator|(
expr|struct
name|objalloc
operator|*
operator|)
name|nbfd
operator|->
name|memory
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nbfd
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|nbfd
operator|->
name|filename
operator|=
name|filename
expr_stmt|;
name|nbfd
operator|->
name|direction
operator|=
name|write_direction
expr_stmt|;
if|if
condition|(
name|bfd_open_file
argument_list|(
name|nbfd
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
comment|/* File not writeable, etc */
name|objalloc_free
argument_list|(
operator|(
expr|struct
name|objalloc
operator|*
operator|)
name|nbfd
operator|->
name|memory
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nbfd
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|nbfd
return|;
block|}
end_function

begin_comment
comment|/*  FUNCTION 	bfd_close  SYNOPSIS 	boolean bfd_close(bfd *abfd);  DESCRIPTION  	Close a BFD. If the BFD was open for writing, 	then pending operations are completed and the file written out 	and closed. If the created file is executable, then<<chmod>> is called to mark it as such.  	All memory attached to the BFD is released.  	The file descriptor associated with the BFD is closed (even 	if it was passed in to BFD by<<bfd_fdopenr>>).  RETURNS<<true>> is returned if all is ok, otherwise<<false>>. */
end_comment

begin_function
name|boolean
name|bfd_close
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|boolean
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|bfd_read_p
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|BFD_SEND_FMT
argument_list|(
name|abfd
argument_list|,
name|_bfd_write_contents
argument_list|,
operator|(
name|abfd
operator|)
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|BFD_SEND
argument_list|(
name|abfd
argument_list|,
name|_close_and_cleanup
argument_list|,
operator|(
name|abfd
operator|)
argument_list|)
condition|)
return|return
name|false
return|;
name|ret
operator|=
name|bfd_cache_close
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* If the file was open for writing and is now executable,      make it so */
if|if
condition|(
name|ret
operator|&&
name|abfd
operator|->
name|direction
operator|==
name|write_direction
operator|&&
name|abfd
operator|->
name|flags
operator|&
name|EXEC_P
condition|)
block|{
name|struct
name|stat
name|buf
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|abfd
operator|->
name|filename
argument_list|,
operator|&
name|buf
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|mask
init|=
name|umask
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|umask
argument_list|(
name|mask
argument_list|)
expr_stmt|;
name|chmod
argument_list|(
name|abfd
operator|->
name|filename
argument_list|,
operator|(
literal|0777
operator|&
operator|(
name|buf
operator|.
name|st_mode
operator||
operator|(
operator|(
name|S_IXUSR
operator||
name|S_IXGRP
operator||
name|S_IXOTH
operator|)
operator|&
operator|~
name|mask
operator|)
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|objalloc_free
argument_list|(
operator|(
expr|struct
name|objalloc
operator|*
operator|)
name|abfd
operator|->
name|memory
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* FUNCTION 	bfd_close_all_done  SYNOPSIS 	boolean bfd_close_all_done(bfd *);  DESCRIPTION 	Close a BFD.  Differs from<<bfd_close>> 	since it does not complete any pending operations.  This 	routine would be used if the application had just used BFD for 	swapping and didn't want to use any of the writing code.  	If the created file is executable, then<<chmod>> is called 	to mark it as such.  	All memory attached to the BFD is released.  RETURNS<<true>> is returned if all is ok, otherwise<<false>>.  */
end_comment

begin_function
name|boolean
name|bfd_close_all_done
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|boolean
name|ret
decl_stmt|;
name|ret
operator|=
name|bfd_cache_close
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* If the file was open for writing and is now executable,      make it so */
if|if
condition|(
name|ret
operator|&&
name|abfd
operator|->
name|direction
operator|==
name|write_direction
operator|&&
name|abfd
operator|->
name|flags
operator|&
name|EXEC_P
condition|)
block|{
name|struct
name|stat
name|buf
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|abfd
operator|->
name|filename
argument_list|,
operator|&
name|buf
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|mask
init|=
name|umask
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|umask
argument_list|(
name|mask
argument_list|)
expr_stmt|;
name|chmod
argument_list|(
name|abfd
operator|->
name|filename
argument_list|,
operator|(
literal|0777
operator|&
operator|(
name|buf
operator|.
name|st_mode
operator||
operator|(
operator|(
name|S_IXUSR
operator||
name|S_IXGRP
operator||
name|S_IXOTH
operator|)
operator|&
operator|~
name|mask
operator|)
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|objalloc_free
argument_list|(
operator|(
expr|struct
name|objalloc
operator|*
operator|)
name|abfd
operator|->
name|memory
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* FUNCTION 	bfd_create  SYNOPSIS 	bfd *bfd_create(CONST char *filename, bfd *templ);  DESCRIPTION 	Create a new BFD in the manner of<<bfd_openw>>, but without opening a file. The new BFD 	takes the target from the target used by @var{template}. The 	format is always set to<<bfd_object>>.  */
end_comment

begin_function
name|bfd
modifier|*
name|bfd_create
parameter_list|(
name|filename
parameter_list|,
name|templ
parameter_list|)
name|CONST
name|char
modifier|*
name|filename
decl_stmt|;
name|bfd
modifier|*
name|templ
decl_stmt|;
block|{
name|bfd
modifier|*
name|nbfd
decl_stmt|;
name|nbfd
operator|=
name|_bfd_new_bfd
argument_list|()
expr_stmt|;
if|if
condition|(
name|nbfd
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|nbfd
operator|->
name|filename
operator|=
name|filename
expr_stmt|;
if|if
condition|(
name|templ
condition|)
name|nbfd
operator|->
name|xvec
operator|=
name|templ
operator|->
name|xvec
expr_stmt|;
name|nbfd
operator|->
name|direction
operator|=
name|no_direction
expr_stmt|;
name|bfd_set_format
argument_list|(
name|nbfd
argument_list|,
name|bfd_object
argument_list|)
expr_stmt|;
return|return
name|nbfd
return|;
block|}
end_function

begin_comment
comment|/* FUNCTION 	bfd_make_writable  SYNOPSIS 	boolean bfd_make_writable(bfd *abfd);  DESCRIPTION 	Takes a BFD as created by<<bfd_create>> and converts it 	into one like as returned by<<bfd_openw>>.  It does this 	by converting the BFD to BFD_IN_MEMORY.  It's assumed that 	you will call<<bfd_make_readable>> on this bfd later.  RETURNS<<true>> is returned if all is ok, otherwise<<false>>. */
end_comment

begin_function
name|boolean
name|bfd_make_writable
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|bfd_in_memory
modifier|*
name|bim
decl_stmt|;
if|if
condition|(
name|abfd
operator|->
name|direction
operator|!=
name|no_direction
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|bim
operator|=
operator|(
expr|struct
name|bfd_in_memory
operator|*
operator|)
name|bfd_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|bfd_in_memory
argument_list|)
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|iostream
operator|=
operator|(
name|PTR
operator|)
name|bim
expr_stmt|;
comment|/* bfd_write will grow these as needed */
name|bim
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|bim
operator|->
name|buffer
operator|=
literal|0
expr_stmt|;
name|abfd
operator|->
name|flags
operator||=
name|BFD_IN_MEMORY
expr_stmt|;
name|abfd
operator|->
name|direction
operator|=
name|write_direction
expr_stmt|;
name|abfd
operator|->
name|where
operator|=
literal|0
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* FUNCTION 	bfd_make_readable  SYNOPSIS 	boolean bfd_make_readable(bfd *abfd);  DESCRIPTION 	Takes a BFD as created by<<bfd_create>> and<<bfd_make_writable>> and converts it into one like as 	returned by<<bfd_openr>>.  It does this by writing the 	contents out to the memory buffer, then reversing the 	direction.  RETURNS<<true>> is returned if all is ok, otherwise<<false>>.  */
end_comment

begin_function
name|boolean
name|bfd_make_readable
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
if|if
condition|(
name|abfd
operator|->
name|direction
operator|!=
name|write_direction
operator|||
operator|!
operator|(
name|abfd
operator|->
name|flags
operator|&
name|BFD_IN_MEMORY
operator|)
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|BFD_SEND_FMT
argument_list|(
name|abfd
argument_list|,
name|_bfd_write_contents
argument_list|,
operator|(
name|abfd
operator|)
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|BFD_SEND
argument_list|(
name|abfd
argument_list|,
name|_close_and_cleanup
argument_list|,
operator|(
name|abfd
operator|)
argument_list|)
condition|)
return|return
name|false
return|;
name|abfd
operator|->
name|arch_info
operator|=
operator|&
name|bfd_default_arch_struct
expr_stmt|;
name|abfd
operator|->
name|where
operator|=
literal|0
expr_stmt|;
name|abfd
operator|->
name|sections
operator|=
operator|(
name|asection
operator|*
operator|)
name|NULL
expr_stmt|;
name|abfd
operator|->
name|format
operator|=
name|bfd_unknown
expr_stmt|;
name|abfd
operator|->
name|my_archive
operator|=
operator|(
name|bfd
operator|*
operator|)
name|NULL
expr_stmt|;
name|abfd
operator|->
name|origin
operator|=
literal|0
expr_stmt|;
name|abfd
operator|->
name|opened_once
operator|=
name|false
expr_stmt|;
name|abfd
operator|->
name|output_has_begun
operator|=
name|false
expr_stmt|;
name|abfd
operator|->
name|section_count
operator|=
literal|0
expr_stmt|;
name|abfd
operator|->
name|usrdata
operator|=
operator|(
name|PTR
operator|)
name|NULL
expr_stmt|;
name|abfd
operator|->
name|cacheable
operator|=
name|false
expr_stmt|;
name|abfd
operator|->
name|flags
operator|=
name|BFD_IN_MEMORY
expr_stmt|;
name|abfd
operator|->
name|mtime_set
operator|=
name|false
expr_stmt|;
name|abfd
operator|->
name|target_defaulted
operator|=
name|true
expr_stmt|;
name|abfd
operator|->
name|direction
operator|=
name|read_direction
expr_stmt|;
name|abfd
operator|->
name|sections
operator|=
literal|0
expr_stmt|;
name|abfd
operator|->
name|symcount
operator|=
literal|0
expr_stmt|;
name|abfd
operator|->
name|outsymbols
operator|=
literal|0
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|any
operator|=
literal|0
expr_stmt|;
name|bfd_check_format
argument_list|(
name|abfd
argument_list|,
name|bfd_object
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* INTERNAL_FUNCTION 	bfd_alloc  SYNOPSIS 	PTR bfd_alloc (bfd *abfd, size_t wanted);  DESCRIPTION 	Allocate a block of @var{wanted} bytes of memory attached to<<abfd>> and return a pointer to it. */
end_comment

begin_function
name|PTR
name|bfd_alloc
parameter_list|(
name|abfd
parameter_list|,
name|size
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|size_t
name|size
decl_stmt|;
block|{
name|PTR
name|ret
decl_stmt|;
name|ret
operator|=
name|objalloc_alloc
argument_list|(
name|abfd
operator|->
name|memory
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|PTR
name|bfd_zalloc
parameter_list|(
name|abfd
parameter_list|,
name|size
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|size_t
name|size
decl_stmt|;
block|{
name|PTR
name|res
decl_stmt|;
name|res
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
name|memset
argument_list|(
name|res
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* Free a block allocated for a BFD.  */
end_comment

begin_function
name|void
name|bfd_release
parameter_list|(
name|abfd
parameter_list|,
name|block
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|block
decl_stmt|;
block|{
name|objalloc_free_block
argument_list|(
operator|(
expr|struct
name|objalloc
operator|*
operator|)
name|abfd
operator|->
name|memory
argument_list|,
name|block
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

