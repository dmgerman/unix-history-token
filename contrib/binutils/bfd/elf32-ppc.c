begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* PowerPC-specific support for 32-bit ELF    Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001    Free Software Foundation, Inc.    Written by Ian Lance Taylor, Cygnus Support.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file is based on a preliminary PowerPC ELF ABI.  The    information may not match the final PowerPC ELF ABI.  It includes    suggestions from the in-progress Embedded PowerPC ABI, and that    information may also not match.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf/ppc.h"
end_include

begin_define
define|#
directive|define
name|USE_RELA
end_define

begin_comment
comment|/* we want RELA relocations, not REL */
end_comment

begin_decl_stmt
specifier|static
name|reloc_howto_type
modifier|*
name|ppc_elf_reloc_type_lookup
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|bfd_reloc_code_real_type
name|code
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ppc_elf_info_to_howto
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|arelent
operator|*
name|cache_ptr
operator|,
name|Elf32_Internal_Rela
operator|*
name|dst
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ppc_elf_howto_init
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|ppc_elf_addr16_ha_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ppc_elf_set_private_flags
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|flagword
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ppc_elf_copy_private_bfd_data
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ppc_elf_merge_private_bfd_data
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ppc_elf_additional_program_headers
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ppc_elf_modify_segment_map
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ppc_elf_create_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ppc_elf_section_from_shdr
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf32_Internal_Shdr
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ppc_elf_fake_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf32_Internal_Shdr
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|elf_linker_section_t
modifier|*
name|ppc_elf_create_linker_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|,
expr|enum
name|elf_linker_section_enum
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ppc_elf_check_relocs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|asection
operator|*
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asection
modifier|*
name|ppc_elf_gc_mark_hook
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|,
name|Elf_Internal_Rela
operator|*
name|rel
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
name|h
operator|,
name|Elf_Internal_Sym
operator|*
name|sym
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ppc_elf_gc_sweep_hook
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|,
name|asection
operator|*
name|sec
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
name|relocs
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ppc_elf_adjust_dynamic_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ppc_elf_size_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ppc_elf_relocate_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
name|relocs
operator|,
name|Elf_Internal_Sym
operator|*
name|local_syms
operator|,
name|asection
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ppc_elf_add_symbol_hook
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
specifier|const
name|Elf_Internal_Sym
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|flagword
operator|*
operator|,
name|asection
operator|*
operator|*
operator|,
name|bfd_vma
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ppc_elf_finish_dynamic_symbol
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ppc_elf_finish_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|BRANCH_PREDICT_BIT
value|0x200000
end_define

begin_comment
comment|/* branch prediction bit for branch taken relocs */
end_comment

begin_define
define|#
directive|define
name|RA_REGISTER_MASK
value|0x001f0000
end_define

begin_comment
comment|/* mask to set RA in memory instructions */
end_comment

begin_define
define|#
directive|define
name|RA_REGISTER_SHIFT
value|16
end_define

begin_comment
comment|/* value to shift register by to insert RA */
end_comment

begin_comment
comment|/* The name of the dynamic interpreter.  This is put in the .interp    section.  */
end_comment

begin_define
define|#
directive|define
name|ELF_DYNAMIC_INTERPRETER
value|"/usr/lib/ld.so.1"
end_define

begin_comment
comment|/* The size in bytes of an entry in the procedure linkage table.  */
end_comment

begin_define
define|#
directive|define
name|PLT_ENTRY_SIZE
value|12
end_define

begin_comment
comment|/* The initial size of the plt reserved for the dynamic linker.  */
end_comment

begin_define
define|#
directive|define
name|PLT_INITIAL_ENTRY_SIZE
value|72
end_define

begin_comment
comment|/* The size of the gap between entries in the PLT.  */
end_comment

begin_define
define|#
directive|define
name|PLT_SLOT_SIZE
value|8
end_define

begin_comment
comment|/* The number of single-slot PLT entries (the rest use two slots).  */
end_comment

begin_define
define|#
directive|define
name|PLT_NUM_SINGLE_ENTRIES
value|8192
end_define

begin_comment
comment|/* Will references to this symbol always reference the symbol    in this object?  */
end_comment

begin_define
define|#
directive|define
name|SYMBOL_REFERENCES_LOCAL
parameter_list|(
name|INFO
parameter_list|,
name|H
parameter_list|)
define|\
value|((! INFO->shared							\     || INFO->symbolic							\     || H->dynindx == -1							\     || ELF_ST_VISIBILITY (H->other) == STV_INTERNAL			\     || ELF_ST_VISIBILITY (H->other) == STV_HIDDEN)			\&& (H->elf_link_hash_flags& ELF_LINK_HASH_DEF_REGULAR) != 0)
end_define

begin_comment
comment|/* Will _calls_ to this symbol always call the version in this object?  */
end_comment

begin_define
define|#
directive|define
name|SYMBOL_CALLS_LOCAL
parameter_list|(
name|INFO
parameter_list|,
name|H
parameter_list|)
define|\
value|((! INFO->shared							\     || INFO->symbolic							\     || H->dynindx == -1							\     || ELF_ST_VISIBILITY (H->other) != STV_DEFAULT)			\&& (H->elf_link_hash_flags& ELF_LINK_HASH_DEF_REGULAR) != 0)
end_define

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|reloc_howto_type
modifier|*
name|ppc_elf_howto_table
index|[
operator|(
name|int
operator|)
name|R_PPC_max
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|ppc_elf_howto_raw
index|[]
init|=
block|{
comment|/* This reloc does nothing.  */
name|HOWTO
argument_list|(
name|R_PPC_NONE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_NONE"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A standard 32 bit relocation.  */
name|HOWTO
argument_list|(
name|R_PPC_ADDR32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_ADDR32"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* An absolute 26 bit branch; the lower two bits must be zero.      FIXME: we don't check that, we just clear them.  */
name|HOWTO
argument_list|(
name|R_PPC_ADDR24
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|26
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_ADDR24"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffffc
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A standard 16 bit relocation.  */
name|HOWTO
argument_list|(
name|R_PPC_ADDR16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_ADDR16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 16 bit relocation without overflow.  */
name|HOWTO
argument_list|(
name|R_PPC_ADDR16_LO
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_ADDR16_LO"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The high order 16 bits of an address.  */
name|HOWTO
argument_list|(
name|R_PPC_ADDR16_HI
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_ADDR16_HI"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The high order 16 bits of an address, plus 1 if the contents of      the low 16 bits, treated as a signed number, is negative.  */
name|HOWTO
argument_list|(
name|R_PPC_ADDR16_HA
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_addr16_ha_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_ADDR16_HA"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* An absolute 16 bit branch; the lower two bits must be zero.      FIXME: we don't check that, we just clear them.  */
name|HOWTO
argument_list|(
name|R_PPC_ADDR14
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_ADDR14"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* An absolute 16 bit branch, for which bit 10 should be set to      indicate that the branch is expected to be taken.	The lower two      bits must be zero.  */
name|HOWTO
argument_list|(
name|R_PPC_ADDR14_BRTAKEN
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_ADDR14_BRTAKEN"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* An absolute 16 bit branch, for which bit 10 should be set to      indicate that the branch is not expected to be taken.  The lower      two bits must be zero.  */
name|HOWTO
argument_list|(
name|R_PPC_ADDR14_BRNTAKEN
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_ADDR14_BRNTAKEN"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A relative 26 bit branch; the lower two bits must be zero.  */
name|HOWTO
argument_list|(
name|R_PPC_REL24
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|26
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_REL24"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffffc
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A relative 16 bit branch; the lower two bits must be zero.  */
name|HOWTO
argument_list|(
name|R_PPC_REL14
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_REL14"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A relative 16 bit branch.  Bit 10 should be set to indicate that      the branch is expected to be taken.  The lower two bits must be      zero.  */
name|HOWTO
argument_list|(
name|R_PPC_REL14_BRTAKEN
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_REL14_BRTAKEN"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A relative 16 bit branch.  Bit 10 should be set to indicate that      the branch is not expected to be taken.  The lower two bits must      be zero.  */
name|HOWTO
argument_list|(
name|R_PPC_REL14_BRNTAKEN
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_REL14_BRNTAKEN"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC_ADDR16, but referring to the GOT table entry for the      symbol.  */
name|HOWTO
argument_list|(
name|R_PPC_GOT16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_GOT16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC_ADDR16_LO, but referring to the GOT table entry for      the symbol.  */
name|HOWTO
argument_list|(
name|R_PPC_GOT16_LO
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_GOT16_LO"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC_ADDR16_HI, but referring to the GOT table entry for      the symbol.  */
name|HOWTO
argument_list|(
name|R_PPC_GOT16_HI
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_GOT16_HI"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC_ADDR16_HA, but referring to the GOT table entry for      the symbol.  */
name|HOWTO
argument_list|(
name|R_PPC_GOT16_HA
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_addr16_ha_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_GOT16_HA"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC_REL24, but referring to the procedure linkage table      entry for the symbol.  */
name|HOWTO
argument_list|(
name|R_PPC_PLTREL24
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|26
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_PLTREL24"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffffc
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* This is used only by the dynamic linker.  The symbol should exist      both in the object being run and in some shared library.  The      dynamic linker copies the data addressed by the symbol from the      shared library into the object, because the object being      run has to have the data at some particular address.  */
name|HOWTO
argument_list|(
name|R_PPC_COPY
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_COPY"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC_ADDR32, but used when setting global offset table      entries.  */
name|HOWTO
argument_list|(
name|R_PPC_GLOB_DAT
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_GLOB_DAT"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Marks a procedure linkage table entry for a symbol.  */
name|HOWTO
argument_list|(
name|R_PPC_JMP_SLOT
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_JMP_SLOT"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used only by the dynamic linker.  When the object is run, this      longword is set to the load address of the object, plus the      addend.  */
name|HOWTO
argument_list|(
name|R_PPC_RELATIVE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_RELATIVE"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC_REL24, but uses the value of the symbol within the      object rather than the final value.  Normally used for      _GLOBAL_OFFSET_TABLE_.  */
name|HOWTO
argument_list|(
name|R_PPC_LOCAL24PC
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|26
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_LOCAL24PC"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffffc
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC_ADDR32, but may be unaligned.  */
name|HOWTO
argument_list|(
name|R_PPC_UADDR32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_UADDR32"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC_ADDR16, but may be unaligned.  */
name|HOWTO
argument_list|(
name|R_PPC_UADDR16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_UADDR16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 32-bit PC relative */
name|HOWTO
argument_list|(
name|R_PPC_REL32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_REL32"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 32-bit relocation to the symbol's procedure linkage table.      FIXME: not supported.  */
name|HOWTO
argument_list|(
name|R_PPC_PLT32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_PLT32"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 32-bit PC relative relocation to the symbol's procedure linkage table.      FIXME: not supported.  */
name|HOWTO
argument_list|(
name|R_PPC_PLTREL32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_PLTREL32"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC_ADDR16_LO, but referring to the PLT table entry for      the symbol.  */
name|HOWTO
argument_list|(
name|R_PPC_PLT16_LO
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_PLT16_LO"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC_ADDR16_HI, but referring to the PLT table entry for      the symbol.  */
name|HOWTO
argument_list|(
name|R_PPC_PLT16_HI
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_PLT16_HI"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC_ADDR16_HA, but referring to the PLT table entry for      the symbol.  */
name|HOWTO
argument_list|(
name|R_PPC_PLT16_HA
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_addr16_ha_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_PLT16_HA"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A sign-extended 16 bit value relative to _SDA_BASE_, for use with      small data items.  */
name|HOWTO
argument_list|(
name|R_PPC_SDAREL16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_SDAREL16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 32-bit section relative relocation.  */
name|HOWTO
argument_list|(
name|R_PPC_SECTOFF
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_SECTOFF"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16-bit lower half section relative relocation.  */
name|HOWTO
argument_list|(
name|R_PPC_SECTOFF_LO
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_SECTOFF_LO"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16-bit upper half section relative relocation.  */
name|HOWTO
argument_list|(
name|R_PPC_SECTOFF_HI
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_SECTOFF_HI"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16-bit upper half adjusted section relative relocation.  */
name|HOWTO
argument_list|(
name|R_PPC_SECTOFF_HA
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_addr16_ha_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_SECTOFF_HA"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The remaining relocs are from the Embedded ELF ABI, and are not      in the SVR4 ELF ABI.  */
comment|/* 32 bit value resulting from the addend minus the symbol */
name|HOWTO
argument_list|(
name|R_PPC_EMB_NADDR32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_EMB_NADDR32"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16 bit value resulting from the addend minus the symbol */
name|HOWTO
argument_list|(
name|R_PPC_EMB_NADDR16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_EMB_NADDR16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16 bit value resulting from the addend minus the symbol */
name|HOWTO
argument_list|(
name|R_PPC_EMB_NADDR16_LO
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_EMB_ADDR16_LO"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The high order 16 bits of the addend minus the symbol */
name|HOWTO
argument_list|(
name|R_PPC_EMB_NADDR16_HI
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_EMB_NADDR16_HI"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The high order 16 bits of the result of the addend minus the address,      plus 1 if the contents of the low 16 bits, treated as a signed number,      is negative.  */
name|HOWTO
argument_list|(
name|R_PPC_EMB_NADDR16_HA
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_addr16_ha_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_EMB_NADDR16_HA"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16 bit value resulting from allocating a 4 byte word to hold an      address in the .sdata section, and returning the offset from      _SDA_BASE_ for that relocation */
name|HOWTO
argument_list|(
name|R_PPC_EMB_SDAI16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_EMB_SDAI16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16 bit value resulting from allocating a 4 byte word to hold an      address in the .sdata2 section, and returning the offset from      _SDA2_BASE_ for that relocation */
name|HOWTO
argument_list|(
name|R_PPC_EMB_SDA2I16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_EMB_SDA2I16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A sign-extended 16 bit value relative to _SDA2_BASE_, for use with      small data items.	 */
name|HOWTO
argument_list|(
name|R_PPC_EMB_SDA2REL
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_EMB_SDA2REL"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Relocate against either _SDA_BASE_ or _SDA2_BASE_, filling in the 16 bit      signed offset from the appropriate base, and filling in the register      field with the appropriate register (0, 2, or 13).  */
name|HOWTO
argument_list|(
name|R_PPC_EMB_SDA21
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_EMB_SDA21"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Relocation not handled: R_PPC_EMB_MRKREF */
comment|/* Relocation not handled: R_PPC_EMB_RELSEC16 */
comment|/* Relocation not handled: R_PPC_EMB_RELST_LO */
comment|/* Relocation not handled: R_PPC_EMB_RELST_HI */
comment|/* Relocation not handled: R_PPC_EMB_RELST_HA */
comment|/* Relocation not handled: R_PPC_EMB_BIT_FLD */
comment|/* PC relative relocation against either _SDA_BASE_ or _SDA2_BASE_, filling      in the 16 bit signed offset from the appropriate base, and filling in the      register field with the appropriate register (0, 2, or 13).  */
name|HOWTO
argument_list|(
name|R_PPC_EMB_RELSDA
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_EMB_RELSDA"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* GNU extension to record C++ vtable hierarchy */
name|HOWTO
argument_list|(
name|R_PPC_GNU_VTINHERIT
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|NULL
argument_list|,
comment|/* special_function */
literal|"R_PPC_GNU_VTINHERIT"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* GNU extension to record C++ vtable member usage */
name|HOWTO
argument_list|(
name|R_PPC_GNU_VTENTRY
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|NULL
argument_list|,
comment|/* special_function */
literal|"R_PPC_GNU_VTENTRY"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Phony reloc to handle AIX style TOC entries */
name|HOWTO
argument_list|(
name|R_PPC_TOC16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_TOC16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Initialize the ppc_elf_howto_table, so that linear accesses can be done.  */
end_comment

begin_function
specifier|static
name|void
name|ppc_elf_howto_init
parameter_list|()
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|type
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|ppc_elf_howto_raw
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|ppc_elf_howto_raw
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|type
operator|=
name|ppc_elf_howto_raw
index|[
name|i
index|]
operator|.
name|type
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|type
operator|<
sizeof|sizeof
argument_list|(
name|ppc_elf_howto_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|ppc_elf_howto_table
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ppc_elf_howto_table
index|[
name|type
index|]
operator|=
operator|&
name|ppc_elf_howto_raw
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This function handles relaxing for the PPC with option --mpc860c0[=<n>].     The MPC860, revision C0 or earlier contains a bug in the die.    If all of the following conditions are true, the next instruction    to be executed *may* be treated as a no-op.    1/ A forward branch is executed.    2/ The branch is predicted as not taken.    3/ The branch is taken.    4/ The branch is located in the last 5 words of a page.       (The EOP limit is 5 by default but may be specified as any value from 1-10.)     Our software solution is to detect these problematic branches in a    linker pass and modify them as follows:    1/ Unconditional branches - Since these are always predicted taken,       there is no problem and no action is required.    2/ Conditional backward branches - No problem, no action required.    3/ Conditional forward branches - Ensure that the "inverse prediction       bit" is set (ensure it is predicted taken).    4/ Conditional register branches - Ensure that the "y bit" is set       (ensure it is predicted taken). */
end_comment

begin_comment
comment|/* Sort sections by address.  */
end_comment

begin_function
specifier|static
name|int
name|ppc_elf_sort_rela
parameter_list|(
name|arg1
parameter_list|,
name|arg2
parameter_list|)
specifier|const
name|void
modifier|*
name|arg1
decl_stmt|;
specifier|const
name|void
modifier|*
name|arg2
decl_stmt|;
block|{
specifier|const
name|Elf_Internal_Rela
modifier|*
modifier|*
name|rela1
init|=
operator|(
specifier|const
name|Elf_Internal_Rela
operator|*
operator|*
operator|)
name|arg1
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
modifier|*
name|rela2
init|=
operator|(
specifier|const
name|Elf_Internal_Rela
operator|*
operator|*
operator|)
name|arg2
decl_stmt|;
comment|/* Sort by offset.  */
return|return
operator|(
operator|(
operator|*
name|rela1
operator|)
operator|->
name|r_offset
operator|-
operator|(
operator|*
name|rela2
operator|)
operator|->
name|r_offset
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|ppc_elf_relax_section
parameter_list|(
name|abfd
parameter_list|,
name|isec
parameter_list|,
name|link_info
parameter_list|,
name|again
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|isec
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|link_info
decl_stmt|;
name|boolean
modifier|*
name|again
decl_stmt|;
block|{
define|#
directive|define
name|PAGESIZE
value|0x1000
name|bfd_byte
modifier|*
name|contents
init|=
name|NULL
decl_stmt|;
name|bfd_byte
modifier|*
name|free_contents
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|free_relocs
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
modifier|*
name|rela_comb
init|=
name|NULL
decl_stmt|;
name|int
name|comb_curr
decl_stmt|,
name|comb_count
decl_stmt|;
comment|/* We never have to do this more than once per input section.  */
operator|*
name|again
operator|=
name|false
expr_stmt|;
comment|/* If needed, initialize this section's cooked size.  */
if|if
condition|(
name|isec
operator|->
name|_cooked_size
operator|==
literal|0
condition|)
name|isec
operator|->
name|_cooked_size
operator|=
name|isec
operator|->
name|_raw_size
expr_stmt|;
comment|/* We're only interested in text sections which overlap the      troublesome area at the end of a page.  */
if|if
condition|(
name|link_info
operator|->
name|mpc860c0
operator|&&
operator|(
name|isec
operator|->
name|flags
operator|&
name|SEC_CODE
operator|)
operator|&&
name|isec
operator|->
name|_cooked_size
condition|)
block|{
name|bfd_vma
name|dot
decl_stmt|,
name|end_page
decl_stmt|,
name|end_section
decl_stmt|;
name|boolean
name|section_modified
decl_stmt|;
comment|/* Get the section contents.  */
comment|/* Get cached copy if it exists.  */
if|if
condition|(
name|elf_section_data
argument_list|(
name|isec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|NULL
condition|)
name|contents
operator|=
name|elf_section_data
argument_list|(
name|isec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
expr_stmt|;
else|else
block|{
comment|/* Go get them off disk.  */
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|isec
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|free_contents
operator|=
name|contents
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|isec
argument_list|,
name|contents
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|isec
operator|->
name|_raw_size
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
name|comb_curr
operator|=
literal|0
expr_stmt|;
name|comb_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isec
operator|->
name|reloc_count
condition|)
block|{
name|unsigned
name|n
decl_stmt|;
comment|/* Get a copy of the native relocations.  */
name|internal_relocs
operator|=
name|_bfd_elf32_link_read_relocs
argument_list|(
name|abfd
argument_list|,
name|isec
argument_list|,
operator|(
name|PTR
operator|)
name|NULL
argument_list|,
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
name|NULL
argument_list|,
name|link_info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|link_info
operator|->
name|keep_memory
condition|)
name|free_relocs
operator|=
name|internal_relocs
expr_stmt|;
comment|/* Setup a faster access method for the reloc info we need.  */
name|rela_comb
operator|=
operator|(
name|Elf_Internal_Rela
operator|*
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|isec
operator|->
name|reloc_count
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Internal_Rela
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rela_comb
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|isec
operator|->
name|reloc_count
condition|;
operator|++
name|n
control|)
block|{
name|long
name|r_type
decl_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|internal_relocs
index|[
name|n
index|]
operator|.
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|<
literal|0
operator|||
name|r_type
operator|>=
operator|(
name|int
operator|)
name|R_PPC_max
condition|)
goto|goto
name|error_return
goto|;
comment|/* Prologue constants are sometimes present in the ".text"               sections and they can be identified by their associated relocation.               We don't want to process those words and some others which               can also be identified by their relocations.  However, not all               conditional branches will have a relocation so we will               only ignore words that 1) have a reloc, and 2) the reloc               is not applicable to a conditional branch.               The array rela_comb is built here for use in the EOP scan loop.  */
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_PPC_ADDR14_BRNTAKEN
case|:
comment|/* absolute, predicted not taken */
case|case
name|R_PPC_REL14
case|:
comment|/* relative cond. br.  */
case|case
name|R_PPC_REL14_BRNTAKEN
case|:
comment|/* rel. cond. br., predicted not taken */
comment|/* We should check the instruction.  */
break|break;
default|default:
comment|/* The word is not a conditional branch - ignore it.  */
name|rela_comb
index|[
name|comb_count
operator|++
index|]
operator|=
operator|&
name|internal_relocs
index|[
name|n
index|]
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|comb_count
operator|>
literal|1
condition|)
name|qsort
argument_list|(
name|rela_comb
argument_list|,
operator|(
name|size_t
operator|)
name|comb_count
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|ppc_elf_sort_rela
argument_list|)
expr_stmt|;
block|}
comment|/* Enumerate each EOP region that overlaps this section.  */
name|end_section
operator|=
name|isec
operator|->
name|vma
operator|+
name|isec
operator|->
name|_cooked_size
expr_stmt|;
name|dot
operator|=
name|end_page
operator|=
operator|(
name|isec
operator|->
name|vma
operator||
operator|(
name|PAGESIZE
operator|-
literal|1
operator|)
operator|)
operator|+
literal|1
expr_stmt|;
name|dot
operator|-=
name|link_info
operator|->
name|mpc860c0
expr_stmt|;
name|section_modified
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|dot
operator|<
name|isec
operator|->
name|vma
condition|)
comment|/* Increment the start position if this section */
name|dot
operator|=
name|isec
operator|->
name|vma
expr_stmt|;
comment|/* begins in the middle of its first EOP region.  */
for|for
control|(
init|;
name|dot
operator|<
name|end_section
condition|;
name|dot
operator|+=
name|PAGESIZE
operator|,
name|end_page
operator|+=
name|PAGESIZE
control|)
block|{
comment|/* Check each word in this EOP region.  */
for|for
control|(
init|;
name|dot
operator|<
name|end_page
condition|;
name|dot
operator|+=
literal|4
control|)
block|{
name|bfd_vma
name|isec_offset
decl_stmt|;
name|unsigned
name|long
name|insn
decl_stmt|;
name|boolean
name|skip
decl_stmt|,
name|modified
decl_stmt|;
comment|/* Don't process this word if there is a relocation for it and               the relocation indicates the word is not a conditional branch.  */
name|skip
operator|=
name|false
expr_stmt|;
name|isec_offset
operator|=
name|dot
operator|-
name|isec
operator|->
name|vma
expr_stmt|;
for|for
control|(
init|;
name|comb_curr
operator|<
name|comb_count
condition|;
operator|++
name|comb_curr
control|)
block|{
name|bfd_vma
name|r_offset
decl_stmt|;
name|r_offset
operator|=
name|rela_comb
index|[
name|comb_curr
index|]
operator|->
name|r_offset
expr_stmt|;
if|if
condition|(
name|r_offset
operator|>=
name|isec_offset
condition|)
block|{
if|if
condition|(
name|r_offset
operator|==
name|isec_offset
condition|)
name|skip
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|skip
condition|)
continue|continue;
comment|/* Check the current word for a problematic conditional branch.  */
define|#
directive|define
name|BO0
parameter_list|(
name|insn
parameter_list|)
value|((insn)& 0x02000000)
define|#
directive|define
name|BO2
parameter_list|(
name|insn
parameter_list|)
value|((insn)& 0x00800000)
define|#
directive|define
name|BO4
parameter_list|(
name|insn
parameter_list|)
value|((insn)& 0x00200000)
name|insn
operator|=
operator|(
name|unsigned
name|long
operator|)
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|isec_offset
argument_list|)
expr_stmt|;
name|modified
operator|=
name|false
expr_stmt|;
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xFc000000
operator|)
operator|==
literal|0x40000000
condition|)
block|{
comment|/* Instruction is BCx */
if|if
condition|(
operator|(
operator|!
name|BO0
argument_list|(
name|insn
argument_list|)
operator|||
operator|!
name|BO2
argument_list|(
name|insn
argument_list|)
operator|)
operator|&&
operator|!
name|BO4
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|bfd_vma
name|target
decl_stmt|;
comment|/* This branch is predicted as "normal".                       If this is a forward branch, it is problematic.  */
name|target
operator|=
name|insn
operator|&
literal|0x0000Fffc
expr_stmt|;
comment|/*extract*/
name|target
operator|=
operator|(
name|target
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
expr_stmt|;
comment|/*sign extend*/
if|if
condition|(
operator|(
name|insn
operator|&
literal|0x00000002
operator|)
operator|==
literal|0
condition|)
name|target
operator|+=
name|dot
expr_stmt|;
comment|/*convert to abs*/
if|if
condition|(
name|target
operator|>
name|dot
condition|)
block|{
name|insn
operator||=
literal|0x00200000
expr_stmt|;
comment|/* set the prediction bit */
name|modified
operator|=
name|true
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xFc00Fffe
operator|)
operator|==
literal|0x4c000420
condition|)
block|{
comment|/* Instruction is BCCTRx */
if|if
condition|(
operator|(
operator|!
name|BO0
argument_list|(
name|insn
argument_list|)
operator|||
operator|!
name|BO2
argument_list|(
name|insn
argument_list|)
operator|)
operator|&&
operator|!
name|BO4
argument_list|(
name|insn
argument_list|)
condition|)
block|{
comment|/* This branch is predicted as not-taken. 		      If this is a forward branch, it is problematic.                       Since we can't tell statically if it will branch forward,                       always set the prediction bit.  */
name|insn
operator||=
literal|0x00200000
expr_stmt|;
comment|/* set the prediction bit */
name|modified
operator|=
name|true
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xFc00Fffe
operator|)
operator|==
literal|0x4c000020
condition|)
block|{
comment|/* Instruction is BCLRx */
if|if
condition|(
operator|(
operator|!
name|BO0
argument_list|(
name|insn
argument_list|)
operator|||
operator|!
name|BO2
argument_list|(
name|insn
argument_list|)
operator|)
operator|&&
operator|!
name|BO4
argument_list|(
name|insn
argument_list|)
condition|)
block|{
comment|/* This branch is predicted as not-taken. 		      If this is a forward branch, it is problematic.                       Since we can't tell statically if it will branch forward,                       always set the prediction bit.  */
name|insn
operator||=
literal|0x00200000
expr_stmt|;
comment|/* set the prediction bit */
name|modified
operator|=
name|true
expr_stmt|;
block|}
block|}
undef|#
directive|undef
name|BO0
undef|#
directive|undef
name|BO2
undef|#
directive|undef
name|BO4
if|if
condition|(
name|modified
condition|)
block|{
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|insn
argument_list|,
name|contents
operator|+
name|isec_offset
argument_list|)
expr_stmt|;
name|section_modified
operator|=
name|true
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|section_modified
condition|)
block|{
name|elf_section_data
argument_list|(
name|isec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
name|free_contents
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rela_comb
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|rela_comb
argument_list|)
expr_stmt|;
name|rela_comb
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|free_relocs
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|free_relocs
argument_list|)
expr_stmt|;
name|free_relocs
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|free_contents
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|link_info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|free_contents
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Cache the section contents for elf_link_input_bfd.  */
name|elf_section_data
argument_list|(
name|isec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
block|}
name|free_contents
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|true
return|;
name|error_return
label|:
if|if
condition|(
name|rela_comb
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rela_comb
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_relocs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|free_relocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_contents
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|free_contents
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|ppc_elf_reloc_type_lookup
parameter_list|(
name|abfd
parameter_list|,
name|code
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
block|{
name|enum
name|elf_ppc_reloc_type
name|ppc_reloc
init|=
name|R_PPC_NONE
decl_stmt|;
if|if
condition|(
operator|!
name|ppc_elf_howto_table
index|[
name|R_PPC_ADDR32
index|]
condition|)
comment|/* Initialize howto table if needed.  */
name|ppc_elf_howto_init
argument_list|()
expr_stmt|;
switch|switch
condition|(
operator|(
name|int
operator|)
name|code
condition|)
block|{
default|default:
return|return
operator|(
name|reloc_howto_type
operator|*
operator|)
name|NULL
return|;
case|case
name|BFD_RELOC_NONE
case|:
name|ppc_reloc
operator|=
name|R_PPC_NONE
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32
case|:
name|ppc_reloc
operator|=
name|R_PPC_ADDR32
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_BA26
case|:
name|ppc_reloc
operator|=
name|R_PPC_ADDR24
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_16
case|:
name|ppc_reloc
operator|=
name|R_PPC_ADDR16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_LO16
case|:
name|ppc_reloc
operator|=
name|R_PPC_ADDR16_LO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16
case|:
name|ppc_reloc
operator|=
name|R_PPC_ADDR16_HI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16_S
case|:
name|ppc_reloc
operator|=
name|R_PPC_ADDR16_HA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_BA16
case|:
name|ppc_reloc
operator|=
name|R_PPC_ADDR14
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_BA16_BRTAKEN
case|:
name|ppc_reloc
operator|=
name|R_PPC_ADDR14_BRTAKEN
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_BA16_BRNTAKEN
case|:
name|ppc_reloc
operator|=
name|R_PPC_ADDR14_BRNTAKEN
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_B26
case|:
name|ppc_reloc
operator|=
name|R_PPC_REL24
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_B16
case|:
name|ppc_reloc
operator|=
name|R_PPC_REL14
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_B16_BRTAKEN
case|:
name|ppc_reloc
operator|=
name|R_PPC_REL14_BRTAKEN
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_B16_BRNTAKEN
case|:
name|ppc_reloc
operator|=
name|R_PPC_REL14_BRNTAKEN
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_16_GOTOFF
case|:
name|ppc_reloc
operator|=
name|R_PPC_GOT16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_LO16_GOTOFF
case|:
name|ppc_reloc
operator|=
name|R_PPC_GOT16_LO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16_GOTOFF
case|:
name|ppc_reloc
operator|=
name|R_PPC_GOT16_HI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16_S_GOTOFF
case|:
name|ppc_reloc
operator|=
name|R_PPC_GOT16_HA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_24_PLT_PCREL
case|:
name|ppc_reloc
operator|=
name|R_PPC_PLTREL24
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_COPY
case|:
name|ppc_reloc
operator|=
name|R_PPC_COPY
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GLOB_DAT
case|:
name|ppc_reloc
operator|=
name|R_PPC_GLOB_DAT
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_LOCAL24PC
case|:
name|ppc_reloc
operator|=
name|R_PPC_LOCAL24PC
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32_PCREL
case|:
name|ppc_reloc
operator|=
name|R_PPC_REL32
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32_PLTOFF
case|:
name|ppc_reloc
operator|=
name|R_PPC_PLT32
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32_PLT_PCREL
case|:
name|ppc_reloc
operator|=
name|R_PPC_PLTREL32
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_LO16_PLTOFF
case|:
name|ppc_reloc
operator|=
name|R_PPC_PLT16_LO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16_PLTOFF
case|:
name|ppc_reloc
operator|=
name|R_PPC_PLT16_HI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16_S_PLTOFF
case|:
name|ppc_reloc
operator|=
name|R_PPC_PLT16_HA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_GPREL16
case|:
name|ppc_reloc
operator|=
name|R_PPC_SDAREL16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32_BASEREL
case|:
name|ppc_reloc
operator|=
name|R_PPC_SECTOFF
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_LO16_BASEREL
case|:
name|ppc_reloc
operator|=
name|R_PPC_SECTOFF_LO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16_BASEREL
case|:
name|ppc_reloc
operator|=
name|R_PPC_SECTOFF_HI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16_S_BASEREL
case|:
name|ppc_reloc
operator|=
name|R_PPC_SECTOFF_HA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_CTOR
case|:
name|ppc_reloc
operator|=
name|R_PPC_ADDR32
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_TOC16
case|:
name|ppc_reloc
operator|=
name|R_PPC_TOC16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_EMB_NADDR32
case|:
name|ppc_reloc
operator|=
name|R_PPC_EMB_NADDR32
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_EMB_NADDR16
case|:
name|ppc_reloc
operator|=
name|R_PPC_EMB_NADDR16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_EMB_NADDR16_LO
case|:
name|ppc_reloc
operator|=
name|R_PPC_EMB_NADDR16_LO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_EMB_NADDR16_HI
case|:
name|ppc_reloc
operator|=
name|R_PPC_EMB_NADDR16_HI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_EMB_NADDR16_HA
case|:
name|ppc_reloc
operator|=
name|R_PPC_EMB_NADDR16_HA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_EMB_SDAI16
case|:
name|ppc_reloc
operator|=
name|R_PPC_EMB_SDAI16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_EMB_SDA2I16
case|:
name|ppc_reloc
operator|=
name|R_PPC_EMB_SDA2I16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_EMB_SDA2REL
case|:
name|ppc_reloc
operator|=
name|R_PPC_EMB_SDA2REL
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_EMB_SDA21
case|:
name|ppc_reloc
operator|=
name|R_PPC_EMB_SDA21
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_EMB_MRKREF
case|:
name|ppc_reloc
operator|=
name|R_PPC_EMB_MRKREF
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_EMB_RELSEC16
case|:
name|ppc_reloc
operator|=
name|R_PPC_EMB_RELSEC16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_EMB_RELST_LO
case|:
name|ppc_reloc
operator|=
name|R_PPC_EMB_RELST_LO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_EMB_RELST_HI
case|:
name|ppc_reloc
operator|=
name|R_PPC_EMB_RELST_HI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_EMB_RELST_HA
case|:
name|ppc_reloc
operator|=
name|R_PPC_EMB_RELST_HA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_EMB_BIT_FLD
case|:
name|ppc_reloc
operator|=
name|R_PPC_EMB_BIT_FLD
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_EMB_RELSDA
case|:
name|ppc_reloc
operator|=
name|R_PPC_EMB_RELSDA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_VTABLE_INHERIT
case|:
name|ppc_reloc
operator|=
name|R_PPC_GNU_VTINHERIT
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_VTABLE_ENTRY
case|:
name|ppc_reloc
operator|=
name|R_PPC_GNU_VTENTRY
expr_stmt|;
break|break;
block|}
return|return
name|ppc_elf_howto_table
index|[
operator|(
name|int
operator|)
name|ppc_reloc
index|]
return|;
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* Set the howto pointer for a PowerPC ELF reloc.  */
end_comment

begin_function
specifier|static
name|void
name|ppc_elf_info_to_howto
parameter_list|(
name|abfd
parameter_list|,
name|cache_ptr
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|arelent
modifier|*
name|cache_ptr
decl_stmt|;
name|Elf32_Internal_Rela
modifier|*
name|dst
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|ppc_elf_howto_table
index|[
name|R_PPC_ADDR32
index|]
condition|)
comment|/* Initialize howto table if needed.  */
name|ppc_elf_howto_init
argument_list|()
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|ELF32_R_TYPE
argument_list|(
name|dst
operator|->
name|r_info
argument_list|)
operator|<
operator|(
name|unsigned
name|int
operator|)
name|R_PPC_max
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|howto
operator|=
name|ppc_elf_howto_table
index|[
name|ELF32_R_TYPE
argument_list|(
name|dst
operator|->
name|r_info
argument_list|)
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the R_PPC_ADDR16_HA reloc.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|ppc_elf_addr16_ha_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|bfd_vma
name|relocation
decl_stmt|;
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
condition|)
block|{
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
if|if
condition|(
name|reloc_entry
operator|->
name|address
operator|>
name|input_section
operator|->
name|_cooked_size
condition|)
return|return
name|bfd_reloc_outofrange
return|;
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
else|else
name|relocation
operator|=
name|symbol
operator|->
name|value
expr_stmt|;
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
name|relocation
operator|+=
name|reloc_entry
operator|->
name|addend
expr_stmt|;
name|reloc_entry
operator|->
name|addend
operator|+=
operator|(
name|relocation
operator|&
literal|0x8000
operator|)
operator|<<
literal|1
expr_stmt|;
return|return
name|bfd_reloc_continue
return|;
block|}
end_function

begin_comment
comment|/* Function to set whether a module needs the -mrelocatable bit set.  */
end_comment

begin_function
specifier|static
name|boolean
name|ppc_elf_set_private_flags
parameter_list|(
name|abfd
parameter_list|,
name|flags
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
block|{
name|BFD_ASSERT
argument_list|(
operator|!
name|elf_flags_init
argument_list|(
name|abfd
argument_list|)
operator|||
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|==
name|flags
argument_list|)
expr_stmt|;
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|=
name|flags
expr_stmt|;
name|elf_flags_init
argument_list|(
name|abfd
argument_list|)
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Copy backend specific data from one object module to another */
end_comment

begin_function
specifier|static
name|boolean
name|ppc_elf_copy_private_bfd_data
parameter_list|(
name|ibfd
parameter_list|,
name|obfd
parameter_list|)
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|bfd
modifier|*
name|obfd
decl_stmt|;
block|{
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|ibfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
operator|||
name|bfd_get_flavour
argument_list|(
name|obfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
return|return
name|true
return|;
name|BFD_ASSERT
argument_list|(
operator|!
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
operator|||
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|==
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
operator|->
name|e_flags
argument_list|)
expr_stmt|;
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|=
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Merge backend specific data from an object file to the output    object file when linking */
end_comment

begin_function
specifier|static
name|boolean
name|ppc_elf_merge_private_bfd_data
parameter_list|(
name|ibfd
parameter_list|,
name|obfd
parameter_list|)
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|bfd
modifier|*
name|obfd
decl_stmt|;
block|{
name|flagword
name|old_flags
decl_stmt|;
name|flagword
name|new_flags
decl_stmt|;
name|boolean
name|error
decl_stmt|;
comment|/* Check if we have the same endianess */
if|if
condition|(
name|_bfd_generic_verify_endian_match
argument_list|(
name|ibfd
argument_list|,
name|obfd
argument_list|)
operator|==
name|false
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|ibfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
operator|||
name|bfd_get_flavour
argument_list|(
name|obfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
return|return
name|true
return|;
name|new_flags
operator|=
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
name|old_flags
operator|=
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
if|if
condition|(
operator|!
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
condition|)
comment|/* First call, no flags set */
block|{
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
operator|=
name|true
expr_stmt|;
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|=
name|new_flags
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|new_flags
operator|==
name|old_flags
condition|)
comment|/* Compatible flags are ok */
empty_stmt|;
else|else
comment|/* Incompatible flags */
block|{
comment|/* Warn about -mrelocatable mismatch.  Allow -mrelocatable-lib to be linked          with either.  */
name|error
operator|=
name|false
expr_stmt|;
if|if
condition|(
operator|(
name|new_flags
operator|&
name|EF_PPC_RELOCATABLE
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|old_flags
operator|&
operator|(
name|EF_PPC_RELOCATABLE
operator||
name|EF_PPC_RELOCATABLE_LIB
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|true
expr_stmt|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: compiled with -mrelocatable and linked with modules compiled normally"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|new_flags
operator|&
operator|(
name|EF_PPC_RELOCATABLE
operator||
name|EF_PPC_RELOCATABLE_LIB
operator|)
operator|)
operator|==
literal|0
operator|&&
operator|(
name|old_flags
operator|&
name|EF_PPC_RELOCATABLE
operator|)
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|true
expr_stmt|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: compiled normally and linked with modules compiled with -mrelocatable"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* The output is -mrelocatable-lib iff both the input files are.  */
if|if
condition|(
operator|!
operator|(
name|new_flags
operator|&
name|EF_PPC_RELOCATABLE_LIB
operator|)
condition|)
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|&=
operator|~
name|EF_PPC_RELOCATABLE_LIB
expr_stmt|;
comment|/* The output is -mrelocatable iff it can't be -mrelocatable-lib,          but each input file is either -mrelocatable or -mrelocatable-lib.  */
if|if
condition|(
operator|!
operator|(
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_PPC_RELOCATABLE_LIB
operator|)
operator|&&
operator|(
name|new_flags
operator|&
operator|(
name|EF_PPC_RELOCATABLE_LIB
operator||
name|EF_PPC_RELOCATABLE
operator|)
operator|)
operator|&&
operator|(
name|old_flags
operator|&
operator|(
name|EF_PPC_RELOCATABLE_LIB
operator||
name|EF_PPC_RELOCATABLE
operator|)
operator|)
condition|)
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator||=
name|EF_PPC_RELOCATABLE
expr_stmt|;
comment|/* Do not warn about eabi vs. V.4 mismatch, just or in the bit if any module uses it */
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator||=
operator|(
name|new_flags
operator|&
name|EF_PPC_EMB
operator|)
expr_stmt|;
name|new_flags
operator|&=
operator|~
operator|(
name|EF_PPC_RELOCATABLE
operator||
name|EF_PPC_RELOCATABLE_LIB
operator||
name|EF_PPC_EMB
operator|)
expr_stmt|;
name|old_flags
operator|&=
operator|~
operator|(
name|EF_PPC_RELOCATABLE
operator||
name|EF_PPC_RELOCATABLE_LIB
operator||
name|EF_PPC_EMB
operator|)
expr_stmt|;
comment|/* Warn about any other mismatches */
if|if
condition|(
name|new_flags
operator|!=
name|old_flags
condition|)
block|{
name|error
operator|=
name|true
expr_stmt|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: uses different e_flags (0x%lx) fields than previous modules (0x%lx)"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|new_flags
argument_list|,
operator|(
name|long
operator|)
name|old_flags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Handle a PowerPC specific section when reading an object file.  This    is called when elfcode.h finds a section with an unknown type.  */
end_comment

begin_function
specifier|static
name|boolean
name|ppc_elf_section_from_shdr
parameter_list|(
name|abfd
parameter_list|,
name|hdr
parameter_list|,
name|name
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|Elf32_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|asection
modifier|*
name|newsect
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
if|if
condition|(
operator|!
name|_bfd_elf_make_section_from_shdr
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|false
return|;
name|newsect
operator|=
name|hdr
operator|->
name|bfd_section
expr_stmt|;
name|flags
operator|=
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|newsect
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|sh_flags
operator|&
name|SHF_EXCLUDE
condition|)
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|sh_type
operator|==
name|SHT_ORDERED
condition|)
name|flags
operator||=
name|SEC_SORT_ENTRIES
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|newsect
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set up any other section flags and such that may be necessary.  */
end_comment

begin_function
specifier|static
name|boolean
name|ppc_elf_fake_sections
parameter_list|(
name|abfd
parameter_list|,
name|shdr
parameter_list|,
name|asect
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|Elf32_Internal_Shdr
modifier|*
name|shdr
decl_stmt|;
name|asection
modifier|*
name|asect
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|asect
operator|->
name|flags
operator|&
name|SEC_EXCLUDE
operator|)
operator|!=
literal|0
condition|)
name|shdr
operator|->
name|sh_flags
operator||=
name|SHF_EXCLUDE
expr_stmt|;
if|if
condition|(
operator|(
name|asect
operator|->
name|flags
operator|&
name|SEC_SORT_ENTRIES
operator|)
operator|!=
literal|0
condition|)
name|shdr
operator|->
name|sh_type
operator|=
name|SHT_ORDERED
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create a special linker section */
end_comment

begin_function
specifier|static
name|elf_linker_section_t
modifier|*
name|ppc_elf_create_linker_section
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|which
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|enum
name|elf_linker_section_enum
name|which
decl_stmt|;
block|{
name|bfd
modifier|*
name|dynobj
init|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
decl_stmt|;
name|elf_linker_section_t
modifier|*
name|lsect
decl_stmt|;
comment|/* Record the first bfd section that needs the special section */
if|if
condition|(
operator|!
name|dynobj
condition|)
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
operator|=
name|abfd
expr_stmt|;
comment|/* If this is the first time, create the section */
name|lsect
operator|=
name|elf_linker_section
argument_list|(
name|dynobj
argument_list|,
name|which
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lsect
condition|)
block|{
name|elf_linker_section_t
name|defaults
decl_stmt|;
specifier|static
name|elf_linker_section_t
name|zero_section
decl_stmt|;
name|defaults
operator|=
name|zero_section
expr_stmt|;
name|defaults
operator|.
name|which
operator|=
name|which
expr_stmt|;
name|defaults
operator|.
name|hole_written_p
operator|=
name|false
expr_stmt|;
name|defaults
operator|.
name|alignment
operator|=
literal|2
expr_stmt|;
comment|/* Both of these sections are (technically) created by the user 	 putting data in them, so they shouldn't be marked 	 SEC_LINKER_CREATED.  	 The linker creates them so it has somewhere to attach their 	 respective symbols. In fact, if they were empty it would 	 be OK to leave the symbol set to 0 (or any random number), because 	 the appropriate register should never be used.  */
name|defaults
operator|.
name|flags
operator|=
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator|)
expr_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
default|default:
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: Unknown special linker type %d"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|which
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
operator|(
name|elf_linker_section_t
operator|*
operator|)
literal|0
return|;
case|case
name|LINKER_SECTION_SDATA
case|:
comment|/* .sdata/.sbss section */
name|defaults
operator|.
name|name
operator|=
literal|".sdata"
expr_stmt|;
name|defaults
operator|.
name|rel_name
operator|=
literal|".rela.sdata"
expr_stmt|;
name|defaults
operator|.
name|bss_name
operator|=
literal|".sbss"
expr_stmt|;
name|defaults
operator|.
name|sym_name
operator|=
literal|"_SDA_BASE_"
expr_stmt|;
name|defaults
operator|.
name|sym_offset
operator|=
literal|32768
expr_stmt|;
break|break;
case|case
name|LINKER_SECTION_SDATA2
case|:
comment|/* .sdata2/.sbss2 section */
name|defaults
operator|.
name|name
operator|=
literal|".sdata2"
expr_stmt|;
name|defaults
operator|.
name|rel_name
operator|=
literal|".rela.sdata2"
expr_stmt|;
name|defaults
operator|.
name|bss_name
operator|=
literal|".sbss2"
expr_stmt|;
name|defaults
operator|.
name|sym_name
operator|=
literal|"_SDA2_BASE_"
expr_stmt|;
name|defaults
operator|.
name|sym_offset
operator|=
literal|32768
expr_stmt|;
name|defaults
operator|.
name|flags
operator||=
name|SEC_READONLY
expr_stmt|;
break|break;
block|}
name|lsect
operator|=
name|_bfd_elf_create_linker_section
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|which
argument_list|,
operator|&
name|defaults
argument_list|)
expr_stmt|;
block|}
return|return
name|lsect
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If we have a non-zero sized .sbss2 or .PPC.EMB.sbss0 sections, we    need to bump up the number of section headers.  */
end_comment

begin_function
specifier|static
name|int
name|ppc_elf_additional_program_headers
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".interp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
operator|++
name|ret
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".sbss2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|!=
literal|0
operator|&&
name|s
operator|->
name|_raw_size
operator|>
literal|0
condition|)
operator|++
name|ret
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".PPC.EMB.sbss0"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|!=
literal|0
operator|&&
name|s
operator|->
name|_raw_size
operator|>
literal|0
condition|)
operator|++
name|ret
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Modify the segment map if needed.  */
end_comment

begin_function
specifier|static
name|boolean
name|ppc_elf_modify_segment_map
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* We have to create .dynsbss and .rela.sbss here so that they get mapped    to output sections (just like _bfd_elf_create_dynamic_sections has    to create .dynbss and .rela.bss).  */
end_comment

begin_function
specifier|static
name|boolean
name|ppc_elf_create_dynamic_sections
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
specifier|register
name|asection
modifier|*
name|s
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
if|if
condition|(
operator|!
name|_bfd_elf_create_dynamic_sections
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|false
return|;
name|flags
operator|=
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator|)
expr_stmt|;
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".dynsbss"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|SEC_ALLOC
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".rela.sbss"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|flags
operator||
name|SEC_READONLY
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Adjust a symbol defined by a dynamic object and referenced by a    regular object.  The current definition is in some section of the    dynamic object, but we're not including those sections.  We have to    change the definition to something the rest of the link can    understand.  */
end_comment

begin_function
specifier|static
name|boolean
name|ppc_elf_adjust_dynamic_symbol
parameter_list|(
name|info
parameter_list|,
name|h
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
block|{
name|bfd
modifier|*
name|dynobj
init|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|unsigned
name|int
name|power_of_two
decl_stmt|;
name|bfd_vma
name|plt_offset
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ppc_elf_adjust_dynamic_symbol called for %s\n"
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Make sure we know what is going on here.  */
name|BFD_ASSERT
argument_list|(
name|dynobj
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_NEEDS_PLT
operator|)
operator|||
name|h
operator|->
name|weakdef
operator|!=
name|NULL
operator|||
operator|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_REF_REGULAR
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* If this is a function, put it in the procedure linkage table.  We      will fill in the contents of the procedure linkage table later,      when we know the address of the .got section.  */
if|if
condition|(
name|h
operator|->
name|type
operator|==
name|STT_FUNC
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_NEEDS_PLT
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
operator|||
name|SYMBOL_CALLS_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
operator|||
operator|(
name|info
operator|->
name|shared
operator|&&
name|h
operator|->
name|plt
operator|.
name|refcount
operator|<=
literal|0
operator|)
condition|)
block|{
comment|/* A PLT entry is not required/allowed when:  	     1. We are not using ld.so; because then the PLT entry 	     can't be set up, so we can't use one.  	     2. We know for certain that a call to this symbol 	     will go to this object.  	     3. GC has rendered the entry unused. 	     Note, however, that in an executable all references to the 	     symbol go to the PLT, so we can't turn it off in that case. 	     ??? The correct thing to do here is to reference count 	     all uses of the symbol, not just those to the GOT or PLT.  */
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_HASH_NEEDS_PLT
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* Make sure this symbol is output as a dynamic symbol.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf32_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|false
return|;
block|}
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* If this is the first .plt entry, make room for the special 	 first entry.  */
if|if
condition|(
name|s
operator|->
name|_raw_size
operator|==
literal|0
condition|)
name|s
operator|->
name|_raw_size
operator|+=
name|PLT_INITIAL_ENTRY_SIZE
expr_stmt|;
comment|/* The PowerPC PLT is actually composed of two parts, the first part 	 is 2 words (for a load and a jump), and then there is a remaining 	 word available at the end.  */
name|plt_offset
operator|=
operator|(
name|PLT_INITIAL_ENTRY_SIZE
operator|+
operator|(
name|PLT_SLOT_SIZE
operator|*
operator|(
operator|(
name|s
operator|->
name|_raw_size
operator|-
name|PLT_INITIAL_ENTRY_SIZE
operator|)
operator|/
name|PLT_ENTRY_SIZE
operator|)
operator|)
operator|)
expr_stmt|;
comment|/* If this symbol is not defined in a regular file, and we are 	 not generating a shared library, then set the symbol to this 	 location in the .plt.  This is required to make function 	 pointers compare as equal between the normal executable and 	 the shared library.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
condition|)
block|{
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|s
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|plt_offset
expr_stmt|;
block|}
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
name|plt_offset
expr_stmt|;
comment|/* Make room for this entry.  After the 8192nd entry, room          for two entries is allocated.  */
if|if
condition|(
operator|(
name|s
operator|->
name|_raw_size
operator|-
name|PLT_INITIAL_ENTRY_SIZE
operator|)
operator|/
name|PLT_ENTRY_SIZE
operator|>=
name|PLT_NUM_SINGLE_ENTRIES
condition|)
name|s
operator|->
name|_raw_size
operator|+=
literal|2
operator|*
name|PLT_ENTRY_SIZE
expr_stmt|;
else|else
name|s
operator|->
name|_raw_size
operator|+=
name|PLT_ENTRY_SIZE
expr_stmt|;
comment|/* We also need to make an entry in the .rela.plt section.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.plt"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* If this is a weak symbol, and there is a real definition, the      processor independent code will have arranged for us to see the      real definition first, and we can just use the same value.  */
if|if
condition|(
name|h
operator|->
name|weakdef
operator|!=
name|NULL
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
argument_list|)
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* This is a reference to a symbol defined by a dynamic object which      is not a function.  */
comment|/* If we are creating a shared library, we must presume that the      only references to the symbol are via the global offset table.      For such cases we need not do anything here; the relocations will      be handled correctly by relocate_section.  */
if|if
condition|(
name|info
operator|->
name|shared
condition|)
return|return
name|true
return|;
comment|/* We must allocate the symbol in our .dynbss section, which will      become part of the .bss section of the executable.  There will be      an entry for this symbol in the .dynsym section.  The dynamic      object will contain position independent code, so all references      from the dynamic object to this symbol will go through the global      offset table.  The dynamic linker will use the .dynsym entry to      determine the address it must put in the global offset table, so      both the dynamic object and the regular object will refer to the      same memory location for the variable.       Of course, if the symbol is sufficiently small, we must instead      allocate it in .sbss.  FIXME: It would be better to do this if and      only if there were actually SDAREL relocs for that symbol.  */
if|if
condition|(
name|h
operator|->
name|size
operator|<=
name|elf_gp_size
argument_list|(
name|dynobj
argument_list|)
condition|)
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynsbss"
argument_list|)
expr_stmt|;
else|else
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynbss"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* We must generate a R_PPC_COPY reloc to tell the dynamic linker to      copy the initial value out of the dynamic object and into the      runtime process image.  We need to remember the offset into the      .rela.bss section we are going to use.  */
if|if
condition|(
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
name|asection
modifier|*
name|srel
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|size
operator|<=
name|elf_gp_size
argument_list|(
name|dynobj
argument_list|)
condition|)
name|srel
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.sbss"
argument_list|)
expr_stmt|;
else|else
name|srel
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.bss"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|srel
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|srel
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_NEEDS_COPY
expr_stmt|;
block|}
comment|/* We need to figure out the alignment required for this symbol.  I      have no idea how ELF linkers handle this.  */
name|power_of_two
operator|=
name|bfd_log2
argument_list|(
name|h
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|power_of_two
operator|>
literal|4
condition|)
name|power_of_two
operator|=
literal|4
expr_stmt|;
comment|/* Apply the required alignment.  */
name|s
operator|->
name|_raw_size
operator|=
name|BFD_ALIGN
argument_list|(
name|s
operator|->
name|_raw_size
argument_list|,
call|(
name|bfd_size_type
call|)
argument_list|(
literal|1
operator|<<
name|power_of_two
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|power_of_two
operator|>
name|bfd_get_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|,
name|power_of_two
argument_list|)
condition|)
return|return
name|false
return|;
block|}
comment|/* Define the symbol as being at this point in the section.  */
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|s
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
comment|/* Increment the section size to make room for the symbol.  */
name|s
operator|->
name|_raw_size
operator|+=
name|h
operator|->
name|size
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set the sizes of the dynamic sections.  */
end_comment

begin_function
specifier|static
name|boolean
name|ppc_elf_size_dynamic_sections
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|boolean
name|plt
decl_stmt|;
name|boolean
name|relocs
decl_stmt|;
name|boolean
name|reltext
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ppc_elf_size_dynamic_sections called\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|dynobj
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
comment|/* Set the contents of the .interp section to the interpreter.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".interp"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|=
sizeof|sizeof
name|ELF_DYNAMIC_INTERPRETER
expr_stmt|;
name|s
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ELF_DYNAMIC_INTERPRETER
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* We may have created entries in the .rela.got, .rela.sdata, and 	 .rela.sdata2 sections.  However, if we are not creating the 	 dynamic sections, we will not actually use these entries.  Reset 	 the size of .rela.got, et al, which will cause it to get 	 stripped from the output file below.  */
specifier|static
name|char
modifier|*
name|rela_sections
index|[]
init|=
block|{
literal|".rela.got"
block|,
literal|".rela.sdata"
block|,
literal|".rela.sdata2"
block|,
literal|".rela.sbss"
block|,
operator|(
name|char
operator|*
operator|)
literal|0
block|}
decl_stmt|;
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|rela_sections
init|;
operator|*
name|p
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
condition|;
name|p
operator|++
control|)
block|{
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|s
operator|->
name|_raw_size
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* The check_relocs and adjust_dynamic_symbol entry points have      determined the sizes of the various dynamic sections.  Allocate      memory for them.  */
name|plt
operator|=
name|false
expr_stmt|;
name|relocs
operator|=
name|false
expr_stmt|;
name|reltext
operator|=
name|false
expr_stmt|;
for|for
control|(
name|s
operator|=
name|dynobj
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|boolean
name|strip
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LINKER_CREATED
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* It's OK to base decisions on the section name, because none 	 of the dynobj section names depend upon the input files.  */
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|strip
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".plt"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|_raw_size
operator|==
literal|0
condition|)
block|{
comment|/* Strip this section if we don't need it; see the                  comment below.  */
name|strip
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
comment|/* Remember whether there is a PLT.  */
name|plt
operator|=
name|true
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".rela"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|_raw_size
operator|==
literal|0
condition|)
block|{
comment|/* If we don't need this section, strip it from the 		 output file.  This is mostly to handle .rela.bss and 		 .rela.plt.  We must create both sections in 		 create_dynamic_sections, because they must be created 		 before the linker maps input sections to output 		 sections.  The linker does that before 		 adjust_dynamic_symbol is called, and it is that 		 function which decides whether anything needs to go 		 into these sections.  */
name|strip
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|asection
modifier|*
name|target
decl_stmt|;
specifier|const
name|char
modifier|*
name|outname
decl_stmt|;
comment|/* Remember whether there are any relocation sections.  */
name|relocs
operator|=
name|true
expr_stmt|;
comment|/* If this relocation section applies to a read only 		 section, then we probably need a DT_TEXTREL entry.  */
name|outname
operator|=
name|bfd_get_section_name
argument_list|(
name|output_bfd
argument_list|,
name|s
operator|->
name|output_section
argument_list|)
expr_stmt|;
name|target
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
name|outname
operator|+
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|!=
name|NULL
operator|&&
operator|(
name|target
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|target
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
name|reltext
operator|=
name|true
expr_stmt|;
comment|/* We use the reloc_count field as a counter if we need 		 to copy relocs into the output file.  */
name|s
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".got"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sdata"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sdata2"
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* It's not one of our sections, so don't allocate space.  */
continue|continue;
block|}
if|if
condition|(
name|strip
condition|)
block|{
name|_bfd_strip_section_from_output
argument_list|(
name|info
argument_list|,
name|s
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Allocate memory for the section contents.  */
name|s
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|dynobj
argument_list|,
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|contents
operator|==
name|NULL
operator|&&
name|s
operator|->
name|_raw_size
operator|!=
literal|0
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
comment|/* Add some entries to the .dynamic section.  We fill in the 	 values later, in ppc_elf_finish_dynamic_sections, but we 	 must add the entries now so that we get the correct size for 	 the .dynamic section.  The DT_DEBUG entry is filled in by the 	 dynamic linker and used by the debugger.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf32_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_DEBUG
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|plt
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf32_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_PLTGOT
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|bfd_elf32_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_PLTRELSZ
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|bfd_elf32_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_PLTREL
argument_list|,
name|DT_RELA
argument_list|)
operator|||
operator|!
name|bfd_elf32_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_JMPREL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|relocs
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf32_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_RELA
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|bfd_elf32_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_RELASZ
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|bfd_elf32_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_RELAENT
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|reltext
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf32_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_TEXTREL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
name|info
operator|->
name|flags
operator||=
name|DF_TEXTREL
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Look through the relocs for a section during the first phase, and    allocate space in the global offset table or procedure linkage    table.  */
end_comment

begin_function
specifier|static
name|boolean
name|ppc_elf_check_relocs
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|sec
parameter_list|,
name|relocs
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|;
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|,
modifier|*
modifier|*
name|sym_hashes_end
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel_end
decl_stmt|;
name|bfd_signed_vma
modifier|*
name|local_got_refcounts
decl_stmt|;
name|elf_linker_section_t
modifier|*
name|sdata
decl_stmt|;
name|elf_linker_section_t
modifier|*
name|sdata2
decl_stmt|;
name|asection
modifier|*
name|sreloc
decl_stmt|;
name|asection
modifier|*
name|sgot
init|=
name|NULL
decl_stmt|;
name|asection
modifier|*
name|srelgot
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocateable
condition|)
return|return
name|true
return|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ppc_elf_check_relocs called for section %s in %s\n"
argument_list|,
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Create the linker generated sections all the time so that the      special symbols are created.  */
if|if
condition|(
operator|(
name|sdata
operator|=
name|elf_linker_section
argument_list|(
name|abfd
argument_list|,
name|LINKER_SECTION_SDATA
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|sdata
operator|=
name|ppc_elf_create_linker_section
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|LINKER_SECTION_SDATA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sdata
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
operator|(
name|sdata2
operator|=
name|elf_linker_section
argument_list|(
name|abfd
argument_list|,
name|LINKER_SECTION_SDATA2
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|sdata2
operator|=
name|ppc_elf_create_linker_section
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|LINKER_SECTION_SDATA2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sdata2
condition|)
return|return
name|false
return|;
block|}
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|local_got_refcounts
operator|=
name|elf_local_got_refcounts
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|sym_hashes_end
operator|=
name|sym_hashes
operator|+
name|symtab_hdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf32_External_Sym
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|elf_bad_symtab
argument_list|(
name|abfd
argument_list|)
condition|)
name|sym_hashes_end
operator|-=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|sreloc
operator|=
name|NULL
expr_stmt|;
name|rel_end
operator|=
name|relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|rel_end
condition|;
name|rel
operator|++
control|)
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
name|h
operator|=
name|NULL
expr_stmt|;
else|else
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
comment|/* If a relocation refers to _GLOBAL_OFFSET_TABLE_, create the .got. 	 This shows up in particular in an R_PPC_ADDR32 in the eabi 	 startup code.  */
if|if
condition|(
name|h
operator|&&
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sgot
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|dynobj
operator|==
name|NULL
condition|)
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
operator|=
name|dynobj
operator|=
name|abfd
expr_stmt|;
if|if
condition|(
operator|!
name|_bfd_elf_create_got_section
argument_list|(
name|dynobj
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|false
return|;
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
comment|/* GOT16 relocations */
case|case
name|R_PPC_GOT16
case|:
case|case
name|R_PPC_GOT16_LO
case|:
case|case
name|R_PPC_GOT16_HI
case|:
case|case
name|R_PPC_GOT16_HA
case|:
comment|/* This symbol requires a global offset table entry.  */
if|if
condition|(
name|sgot
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|dynobj
operator|==
name|NULL
condition|)
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
operator|=
name|dynobj
operator|=
name|abfd
expr_stmt|;
if|if
condition|(
operator|!
name|_bfd_elf_create_got_section
argument_list|(
name|dynobj
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|false
return|;
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|srelgot
operator|==
name|NULL
operator|&&
operator|(
name|h
operator|!=
name|NULL
operator|||
name|info
operator|->
name|shared
operator|)
condition|)
block|{
name|srelgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
if|if
condition|(
name|srelgot
operator|==
name|NULL
condition|)
block|{
name|srelgot
operator|=
name|bfd_make_section
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
if|if
condition|(
name|srelgot
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|dynobj
argument_list|,
name|srelgot
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_READONLY
operator|)
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|srelgot
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|refcount
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* Make sure this symbol is output as a dynamic symbol.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
if|if
condition|(
operator|!
name|bfd_elf32_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Allocate space in the .got.  */
name|sgot
operator|->
name|_raw_size
operator|+=
literal|4
expr_stmt|;
comment|/* Allocate relocation space.  */
name|srelgot
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
name|h
operator|->
name|got
operator|.
name|refcount
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|h
operator|->
name|got
operator|.
name|refcount
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* This is a global offset table entry for a local symbol.  */
if|if
condition|(
name|local_got_refcounts
operator|==
name|NULL
condition|)
block|{
name|size_t
name|size
decl_stmt|;
name|size
operator|=
name|symtab_hdr
operator|->
name|sh_info
operator|*
sizeof|sizeof
argument_list|(
name|bfd_signed_vma
argument_list|)
expr_stmt|;
name|local_got_refcounts
operator|=
operator|(
name|bfd_signed_vma
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_got_refcounts
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|elf_local_got_refcounts
argument_list|(
name|abfd
argument_list|)
operator|=
name|local_got_refcounts
expr_stmt|;
name|memset
argument_list|(
name|local_got_refcounts
argument_list|,
operator|-
literal|1
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|local_got_refcounts
index|[
name|r_symndx
index|]
operator|==
operator|-
literal|1
condition|)
block|{
name|sgot
operator|->
name|_raw_size
operator|+=
literal|4
expr_stmt|;
comment|/* If we are generating a shared object, we need to                      output a R_PPC_RELATIVE reloc so that the                      dynamic linker can adjust this GOT entry.  */
if|if
condition|(
name|info
operator|->
name|shared
condition|)
name|srelgot
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
name|local_got_refcounts
index|[
name|r_symndx
index|]
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|local_got_refcounts
index|[
name|r_symndx
index|]
operator|++
expr_stmt|;
block|}
break|break;
comment|/* Indirect .sdata relocation */
case|case
name|R_PPC_EMB_SDAI16
case|:
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
operator|(
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: relocation %s cannot be used when making a shared object"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
literal|"R_PPC_EMB_SDAI16"
argument_list|)
operator|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|srelgot
operator|==
name|NULL
operator|&&
operator|(
name|h
operator|!=
name|NULL
operator|||
name|info
operator|->
name|shared
operator|)
condition|)
block|{
name|srelgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
if|if
condition|(
name|srelgot
operator|==
name|NULL
condition|)
block|{
name|srelgot
operator|=
name|bfd_make_section
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
if|if
condition|(
name|srelgot
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|dynobj
argument_list|,
name|srelgot
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_READONLY
operator|)
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|srelgot
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
if|if
condition|(
operator|!
name|bfd_elf32_create_pointer_linker_section
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|sdata
argument_list|,
name|h
argument_list|,
name|rel
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
comment|/* Indirect .sdata2 relocation */
case|case
name|R_PPC_EMB_SDA2I16
case|:
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
operator|(
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: relocation %s cannot be used when making a shared object"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
literal|"R_PPC_EMB_SDA2I16"
argument_list|)
operator|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|srelgot
operator|==
name|NULL
operator|&&
operator|(
name|h
operator|!=
name|NULL
operator|||
name|info
operator|->
name|shared
operator|)
condition|)
block|{
name|srelgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
if|if
condition|(
name|srelgot
operator|==
name|NULL
condition|)
block|{
name|srelgot
operator|=
name|bfd_make_section
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
if|if
condition|(
name|srelgot
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|dynobj
argument_list|,
name|srelgot
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_READONLY
operator|)
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|srelgot
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
if|if
condition|(
operator|!
name|bfd_elf32_create_pointer_linker_section
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|sdata2
argument_list|,
name|h
argument_list|,
name|rel
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|R_PPC_SDAREL16
case|:
case|case
name|R_PPC_EMB_SDA2REL
case|:
case|case
name|R_PPC_EMB_SDA21
case|:
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
operator|(
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: relocation %s cannot be used when making a shared object"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|ppc_elf_howto_table
index|[
operator|(
name|int
operator|)
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
index|]
operator|->
name|name
argument_list|)
operator|)
expr_stmt|;
return|return
name|false
return|;
block|}
break|break;
case|case
name|R_PPC_PLT32
case|:
case|case
name|R_PPC_PLTREL24
case|:
case|case
name|R_PPC_PLT16_LO
case|:
case|case
name|R_PPC_PLT16_HI
case|:
case|case
name|R_PPC_PLT16_HA
case|:
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Reloc requires a PLT entry\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* This symbol requires a procedure linkage table entry.  We              actually build the entry in adjust_dynamic_symbol,              because this might be a case of linking PIC code without              linking in any dynamic objects, in which case we don't              need to generate a procedure linkage table after all.  */
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
block|{
comment|/* It does not make sense to have a procedure linkage                  table entry for a local symbol.  */
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Make sure this symbol is output as a dynamic symbol.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf32_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|refcount
operator|==
operator|-
literal|1
condition|)
block|{
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_NEEDS_PLT
expr_stmt|;
name|h
operator|->
name|plt
operator|.
name|refcount
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|h
operator|->
name|plt
operator|.
name|refcount
operator|++
expr_stmt|;
break|break;
comment|/* The following relocations don't need to propagate the 	     relocation if linking a shared object since they are 	     section relative.  */
case|case
name|R_PPC_SECTOFF
case|:
case|case
name|R_PPC_SECTOFF_LO
case|:
case|case
name|R_PPC_SECTOFF_HI
case|:
case|case
name|R_PPC_SECTOFF_HA
case|:
break|break;
comment|/* This refers only to functions defined in the shared library */
case|case
name|R_PPC_LOCAL24PC
case|:
break|break;
comment|/* This relocation describes the C++ object vtable hierarchy. 	     Reconstruct it for later use during GC.  */
case|case
name|R_PPC_GNU_VTINHERIT
case|:
if|if
condition|(
operator|!
name|_bfd_elf32_gc_record_vtinherit
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|h
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
comment|/* This relocation describes which C++ vtable entries are actually 	     used.  Record for later use during GC.  */
case|case
name|R_PPC_GNU_VTENTRY
case|:
if|if
condition|(
operator|!
name|_bfd_elf32_gc_record_vtentry
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|h
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
comment|/* When creating a shared object, we must copy these 	     relocs into the output file.  We create a reloc 	     section in dynobj and make room for the reloc.  */
case|case
name|R_PPC_REL24
case|:
case|case
name|R_PPC_REL14
case|:
case|case
name|R_PPC_REL14_BRTAKEN
case|:
case|case
name|R_PPC_REL14_BRNTAKEN
case|:
case|case
name|R_PPC_REL32
case|:
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|)
operator|==
literal|0
operator|||
name|SYMBOL_REFERENCES_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
break|break;
comment|/* fall through */
default|default:
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ppc_elf_check_relocs need to create relocation for %s\n"
argument_list|,
operator|(
name|h
operator|&&
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
operator|)
condition|?
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
else|:
literal|"<unknown>"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
operator|(
name|bfd_elf_string_from_elf_section
argument_list|(
name|abfd
argument_list|,
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_shstrndx
argument_list|,
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|rel_hdr
operator|.
name|sh_name
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|BFD_ASSERT
argument_list|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".rela"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|,
name|name
operator|+
literal|5
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|sreloc
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
block|{
name|flagword
name|flags
decl_stmt|;
name|sreloc
operator|=
name|bfd_make_section
argument_list|(
name|dynobj
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|flags
operator|=
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_READONLY
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
name|flags
operator||=
name|SEC_ALLOC
operator||
name|SEC_LOAD
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|dynobj
argument_list|,
name|sreloc
argument_list|,
name|flags
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|sreloc
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
name|sreloc
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
comment|/* FIXME: We should here do what the m68k and i386 		 backends do: if the reloc is pc-relative, record it 		 in case it turns out that the reloc is unnecessary 		 because the symbol is forced local by versioning or 		 we are linking with -Bdynamic.  Fortunately this 		 case is not frequent.  */
block|}
break|break;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Return the section that should be marked against GC for a given    relocation.  */
end_comment

begin_function
specifier|static
name|asection
modifier|*
name|ppc_elf_gc_mark_hook
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|rel
parameter_list|,
name|h
parameter_list|,
name|sym
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
block|{
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_PPC_GNU_VTINHERIT
case|:
case|case
name|R_PPC_GNU_VTENTRY
case|:
break|break;
default|default:
switch|switch
condition|(
name|h
operator|->
name|root
operator|.
name|type
condition|)
block|{
case|case
name|bfd_link_hash_defined
case|:
case|case
name|bfd_link_hash_defweak
case|:
return|return
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
return|;
case|case
name|bfd_link_hash_common
case|:
return|return
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
return|;
default|default:
break|break;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|elf_bad_symtab
argument_list|(
name|abfd
argument_list|)
operator|&&
name|ELF_ST_BIND
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|!=
name|STB_LOCAL
operator|)
operator|&&
operator|!
operator|(
operator|(
name|sym
operator|->
name|st_shndx
operator|<=
literal|0
operator|||
name|sym
operator|->
name|st_shndx
operator|>=
name|SHN_LORESERVE
operator|)
operator|&&
name|sym
operator|->
name|st_shndx
operator|!=
name|SHN_COMMON
operator|)
condition|)
block|{
return|return
name|bfd_section_from_elf_index
argument_list|(
name|abfd
argument_list|,
name|sym
operator|->
name|st_shndx
argument_list|)
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Update the got entry reference counts for the section being removed.  */
end_comment

begin_function
specifier|static
name|boolean
name|ppc_elf_gc_sweep_hook
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|sec
parameter_list|,
name|relocs
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|bfd_signed_vma
modifier|*
name|local_got_refcounts
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|,
modifier|*
name|relend
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|local_got_refcounts
operator|=
name|elf_local_got_refcounts
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
switch|switch
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_PPC_GOT16
case|:
case|case
name|R_PPC_GOT16_LO
case|:
case|case
name|R_PPC_GOT16_HI
case|:
case|case
name|R_PPC_GOT16_HA
case|:
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|>=
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|refcount
operator|>
literal|0
condition|)
name|h
operator|->
name|got
operator|.
name|refcount
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|local_got_refcounts
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|local_got_refcounts
index|[
name|r_symndx
index|]
operator|>
literal|0
condition|)
name|local_got_refcounts
index|[
name|r_symndx
index|]
operator|--
expr_stmt|;
block|}
break|break;
case|case
name|R_PPC_PLT32
case|:
case|case
name|R_PPC_PLTREL24
case|:
case|case
name|R_PPC_PLT16_LO
case|:
case|case
name|R_PPC_PLT16_HI
case|:
case|case
name|R_PPC_PLT16_HA
case|:
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|>=
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|refcount
operator|>
literal|0
condition|)
name|h
operator|->
name|plt
operator|.
name|refcount
operator|--
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Hook called by the linker routine which adds symbols from an object    file.  We use it to put .comm items in .sbss, and not .bss.  */
end_comment

begin_function
specifier|static
name|boolean
name|ppc_elf_add_symbol_hook
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|sym
parameter_list|,
name|namep
parameter_list|,
name|flagsp
parameter_list|,
name|secp
parameter_list|,
name|valp
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
specifier|const
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|namep
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|flagword
modifier|*
name|flagsp
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
modifier|*
name|secp
decl_stmt|;
name|bfd_vma
modifier|*
name|valp
decl_stmt|;
block|{
if|if
condition|(
name|sym
operator|->
name|st_shndx
operator|==
name|SHN_COMMON
operator|&&
operator|!
name|info
operator|->
name|relocateable
operator|&&
name|sym
operator|->
name|st_size
operator|<=
operator|(
name|bfd_vma
operator|)
name|bfd_get_gp_size
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
comment|/* Common symbols less than or equal to -G nn bytes are automatically 	 put into .sdata.  */
name|elf_linker_section_t
modifier|*
name|sdata
init|=
name|ppc_elf_create_linker_section
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|LINKER_SECTION_SDATA
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sdata
operator|->
name|bss_section
condition|)
block|{
comment|/* We don't go through bfd_make_section, because we don't              want to attach this common section to DYNOBJ.  The linker              will move the symbols to the appropriate output section              when it defines common symbols.  */
name|sdata
operator|->
name|bss_section
operator|=
operator|(
operator|(
name|asection
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|asection
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|sdata
operator|->
name|bss_section
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|sdata
operator|->
name|bss_section
operator|->
name|name
operator|=
name|sdata
operator|->
name|bss_name
expr_stmt|;
name|sdata
operator|->
name|bss_section
operator|->
name|flags
operator|=
name|SEC_IS_COMMON
expr_stmt|;
name|sdata
operator|->
name|bss_section
operator|->
name|output_section
operator|=
name|sdata
operator|->
name|bss_section
expr_stmt|;
name|sdata
operator|->
name|bss_section
operator|->
name|symbol
operator|=
operator|(
name|asymbol
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|asymbol
argument_list|)
argument_list|)
expr_stmt|;
name|sdata
operator|->
name|bss_section
operator|->
name|symbol_ptr_ptr
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdata
operator|->
name|bss_section
operator|->
name|symbol
operator|==
name|NULL
operator|||
name|sdata
operator|->
name|bss_section
operator|->
name|symbol_ptr_ptr
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|sdata
operator|->
name|bss_section
operator|->
name|symbol
operator|->
name|name
operator|=
name|sdata
operator|->
name|bss_name
expr_stmt|;
name|sdata
operator|->
name|bss_section
operator|->
name|symbol
operator|->
name|flags
operator|=
name|BSF_SECTION_SYM
expr_stmt|;
name|sdata
operator|->
name|bss_section
operator|->
name|symbol
operator|->
name|section
operator|=
name|sdata
operator|->
name|bss_section
expr_stmt|;
operator|*
name|sdata
operator|->
name|bss_section
operator|->
name|symbol_ptr_ptr
operator|=
name|sdata
operator|->
name|bss_section
operator|->
name|symbol
expr_stmt|;
block|}
operator|*
name|secp
operator|=
name|sdata
operator|->
name|bss_section
expr_stmt|;
operator|*
name|valp
operator|=
name|sym
operator|->
name|st_size
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Finish up dynamic symbol handling.  We set the contents of various    dynamic sections here.  */
end_comment

begin_function
specifier|static
name|boolean
name|ppc_elf_finish_dynamic_symbol
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|h
parameter_list|,
name|sym
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ppc_elf_finish_dynamic_symbol called for %s"
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|dynobj
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
name|asection
modifier|*
name|splt
decl_stmt|;
name|asection
modifier|*
name|srela
decl_stmt|;
name|Elf_Internal_Rela
name|rela
decl_stmt|;
name|bfd_vma
name|reloc_index
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", plt_offset = %d"
argument_list|,
name|h
operator|->
name|plt
operator|.
name|offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* This symbol has an entry in the procedure linkage table.  Set          it up.  */
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|splt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
name|srela
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.plt"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|splt
operator|!=
name|NULL
operator|&&
name|srela
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* We don't need to fill in the .plt.  The ppc dynamic linker 	 will fill it in.  */
comment|/* Fill in the entry in the .rela.plt section.  */
name|rela
operator|.
name|r_offset
operator|=
operator|(
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|splt
operator|->
name|output_offset
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|)
expr_stmt|;
name|rela
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_PPC_JMP_SLOT
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
name|reloc_index
operator|=
operator|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|-
name|PLT_INITIAL_ENTRY_SIZE
operator|)
operator|/
name|PLT_SLOT_SIZE
expr_stmt|;
if|if
condition|(
name|reloc_index
operator|>
name|PLT_NUM_SINGLE_ENTRIES
condition|)
name|reloc_index
operator|-=
operator|(
name|reloc_index
operator|-
name|PLT_NUM_SINGLE_ENTRIES
operator|)
operator|/
literal|2
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rela
argument_list|,
operator|(
operator|(
name|Elf32_External_Rela
operator|*
operator|)
name|srela
operator|->
name|contents
operator|+
name|reloc_index
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Mark the symbol as undefined, rather than as defined in 	     the .plt section.  Leave the value alone.  */
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_UNDEF
expr_stmt|;
comment|/* If the symbol is weak, we do need to clear the value. 	     Otherwise, the PLT entry would provide a definition for 	     the symbol even if the symbol wasn't defined anywhere, 	     and so the symbol would never be NULL.  */
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_REF_REGULAR_NONWEAK
operator|)
operator|==
literal|0
condition|)
name|sym
operator|->
name|st_value
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
name|asection
modifier|*
name|sgot
decl_stmt|;
name|asection
modifier|*
name|srela
decl_stmt|;
name|Elf_Internal_Rela
name|rela
decl_stmt|;
comment|/* This symbol has an entry in the global offset table.  Set it          up.  */
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
name|srela
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
operator|&&
name|srela
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_offset
operator|=
operator|(
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
operator|(
name|h
operator|->
name|got
operator|.
name|offset
operator|&
operator|~
literal|1
operator|)
operator|)
expr_stmt|;
comment|/* If this is a -Bsymbolic link, and the symbol is defined 	 locally, we just want to emit a RELATIVE reloc.  The entry in 	 the global offset table will already have been initialized in 	 the relocate_section function.  */
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
name|SYMBOL_REFERENCES_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
block|{
name|rela
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_PPC_RELATIVE
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_addend
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
else|else
block|{
name|BFD_ASSERT
argument_list|(
operator|(
name|h
operator|->
name|got
operator|.
name|offset
operator|&
literal|1
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|h
operator|->
name|got
operator|.
name|offset
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_PPC_GLOB_DAT
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
block|}
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rela
argument_list|,
operator|(
operator|(
name|Elf32_External_Rela
operator|*
operator|)
name|srela
operator|->
name|contents
operator|+
name|srela
operator|->
name|reloc_count
operator|)
argument_list|)
expr_stmt|;
operator|++
name|srela
operator|->
name|reloc_count
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_NEEDS_COPY
operator|)
operator|!=
literal|0
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|Elf_Internal_Rela
name|rela
decl_stmt|;
comment|/* This symbols needs a copy reloc.  Set it up.  */
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", copy"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|size
operator|<=
name|elf_gp_size
argument_list|(
name|dynobj
argument_list|)
condition|)
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
argument_list|,
literal|".rela.sbss"
argument_list|)
expr_stmt|;
else|else
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
argument_list|,
literal|".rela.bss"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_offset
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|rela
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_PPC_COPY
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rela
argument_list|,
operator|(
operator|(
name|Elf32_External_Rela
operator|*
operator|)
name|s
operator|->
name|contents
operator|+
name|s
operator|->
name|reloc_count
operator|)
argument_list|)
expr_stmt|;
operator|++
name|s
operator|->
name|reloc_count
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Mark some specially defined symbols as absolute.  */
if|if
condition|(
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_DYNAMIC"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_PROCEDURE_LINKAGE_TABLE_"
argument_list|)
operator|==
literal|0
condition|)
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_ABS
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Finish up the dynamic sections.  */
end_comment

begin_function
specifier|static
name|boolean
name|ppc_elf_finish_dynamic_sections
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|asection
modifier|*
name|sdyn
decl_stmt|;
name|bfd
modifier|*
name|dynobj
init|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|sgot
init|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ppc_elf_finish_dynamic_sections called\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sdyn
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
name|asection
modifier|*
name|splt
decl_stmt|;
name|Elf32_External_Dyn
modifier|*
name|dyncon
decl_stmt|,
modifier|*
name|dynconend
decl_stmt|;
name|splt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|splt
operator|!=
name|NULL
operator|&&
name|sdyn
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dyncon
operator|=
operator|(
name|Elf32_External_Dyn
operator|*
operator|)
name|sdyn
operator|->
name|contents
expr_stmt|;
name|dynconend
operator|=
operator|(
name|Elf32_External_Dyn
operator|*
operator|)
operator|(
name|sdyn
operator|->
name|contents
operator|+
name|sdyn
operator|->
name|_raw_size
operator|)
expr_stmt|;
for|for
control|(
init|;
name|dyncon
operator|<
name|dynconend
condition|;
name|dyncon
operator|++
control|)
block|{
name|Elf_Internal_Dyn
name|dyn
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|boolean
name|size
decl_stmt|;
name|bfd_elf32_swap_dyn_in
argument_list|(
name|dynobj
argument_list|,
name|dyncon
argument_list|,
operator|&
name|dyn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dyn
operator|.
name|d_tag
condition|)
block|{
case|case
name|DT_PLTGOT
case|:
name|name
operator|=
literal|".plt"
expr_stmt|;
name|size
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|DT_PLTRELSZ
case|:
name|name
operator|=
literal|".rela.plt"
expr_stmt|;
name|size
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|DT_JMPREL
case|:
name|name
operator|=
literal|".rela.plt"
expr_stmt|;
name|size
operator|=
name|false
expr_stmt|;
break|break;
default|default:
name|name
operator|=
name|NULL
expr_stmt|;
name|size
operator|=
name|false
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|size
condition|)
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|s
operator|->
name|vma
expr_stmt|;
else|else
block|{
if|if
condition|(
name|s
operator|->
name|_cooked_size
operator|!=
literal|0
condition|)
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|s
operator|->
name|_cooked_size
expr_stmt|;
else|else
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
block|}
block|}
name|bfd_elf32_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Add a blrl instruction at _GLOBAL_OFFSET_TABLE_-4 so that a function can      easily find the address of the _GLOBAL_OFFSET_TABLE_.  */
if|if
condition|(
name|sgot
condition|)
block|{
name|unsigned
name|char
modifier|*
name|contents
init|=
name|sgot
operator|->
name|contents
decl_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
literal|0x4e800021
comment|/* blrl */
argument_list|,
name|contents
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdyn
operator|==
name|NULL
condition|)
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|contents
operator|+
literal|4
argument_list|)
expr_stmt|;
else|else
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|sdyn
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sdyn
operator|->
name|output_offset
argument_list|,
name|contents
operator|+
literal|4
argument_list|)
expr_stmt|;
name|elf_section_data
argument_list|(
name|sgot
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
operator|=
literal|4
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The RELOCATE_SECTION function is called by the ELF backend linker    to handle the relocations for a section.     The relocs are always passed as Rela structures; if the section    actually uses Rel structures, the r_addend field will always be    zero.     This function is responsible for adjust the section contents as    necessary, and (if using Rela relocs and generating a    relocateable output file) adjusting the reloc addend as    necessary.     This function does not have to worry about setting the reloc    address or the reloc symbol index.     LOCAL_SYMS is a pointer to the swapped in local symbols.     LOCAL_SECTIONS is an array giving the section in the input file    corresponding to the st_shndx field of each local symbol.     The global hash table entry for the global symbols can be found    via elf_sym_hashes (input_bfd).     When generating relocateable output, this function must handle    STB_LOCAL/STT_SECTION symbols specially.  The output symbol is    going to be the section symbol corresponding to the output    section, which means that the addend must be adjusted    accordingly.  */
end_comment

begin_function
specifier|static
name|boolean
name|ppc_elf_relocate_section
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|contents
parameter_list|,
name|relocs
parameter_list|,
name|local_syms
parameter_list|,
name|local_sections
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|local_syms
decl_stmt|;
name|asection
modifier|*
modifier|*
name|local_sections
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
init|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
init|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
decl_stmt|;
name|bfd
modifier|*
name|dynobj
init|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
decl_stmt|;
name|elf_linker_section_t
modifier|*
name|sdata
init|=
operator|(
name|dynobj
operator|)
condition|?
name|elf_linker_section
argument_list|(
name|dynobj
argument_list|,
name|LINKER_SECTION_SDATA
argument_list|)
else|:
name|NULL
decl_stmt|;
name|elf_linker_section_t
modifier|*
name|sdata2
init|=
operator|(
name|dynobj
operator|)
condition|?
name|elf_linker_section
argument_list|(
name|dynobj
argument_list|,
name|LINKER_SECTION_SDATA2
argument_list|)
else|:
name|NULL
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
init|=
name|relocs
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relend
init|=
name|relocs
operator|+
name|input_section
operator|->
name|reloc_count
decl_stmt|;
name|asection
modifier|*
name|sreloc
init|=
name|NULL
decl_stmt|;
name|asection
modifier|*
name|splt
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
name|bfd_vma
modifier|*
name|local_got_offsets
decl_stmt|;
name|boolean
name|ret
init|=
name|true
decl_stmt|;
name|long
name|insn
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ppc_elf_relocate_section called for %s section %s, %ld relocations%s\n"
argument_list|,
name|bfd_get_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|bfd_section_name
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|input_section
operator|->
name|reloc_count
argument_list|,
operator|(
name|info
operator|->
name|relocateable
operator|)
condition|?
literal|" (relocatable)"
else|:
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|ppc_elf_howto_table
index|[
name|R_PPC_ADDR32
index|]
condition|)
comment|/* Initialize howto table if needed.  */
name|ppc_elf_howto_init
argument_list|()
expr_stmt|;
name|local_got_offsets
operator|=
name|elf_local_got_offsets
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|splt
operator|=
name|sgot
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dynobj
operator|!=
name|NULL
condition|)
block|{
name|splt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|enum
name|elf_ppc_reloc_type
name|r_type
init|=
operator|(
expr|enum
name|elf_ppc_reloc_type
operator|)
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
decl_stmt|;
name|bfd_vma
name|offset
init|=
name|rel
operator|->
name|r_offset
decl_stmt|;
name|bfd_vma
name|addend
init|=
name|rel
operator|->
name|r_addend
decl_stmt|;
name|bfd_reloc_status_type
name|r
init|=
name|bfd_reloc_other
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
init|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
literal|0
decl_stmt|;
name|asection
modifier|*
name|sec
init|=
operator|(
name|asection
operator|*
operator|)
literal|0
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
init|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|sym_name
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
literal|0
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|int
name|will_become_local
decl_stmt|;
comment|/* Unknown relocation handling */
if|if
condition|(
operator|(
name|unsigned
operator|)
name|r_type
operator|>=
operator|(
name|unsigned
operator|)
name|R_PPC_max
operator|||
operator|!
name|ppc_elf_howto_table
index|[
operator|(
name|int
operator|)
name|r_type
index|]
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: unknown relocation type %d"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|r_type
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
name|ret
operator|=
name|false
expr_stmt|;
continue|continue;
block|}
name|howto
operator|=
name|ppc_elf_howto_table
index|[
operator|(
name|int
operator|)
name|r_type
index|]
expr_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|relocateable
condition|)
block|{
comment|/* This is a relocateable link.  We don't have to change 	     anything, unless the reloc is against a section symbol, 	     in which case we have to adjust according to where the 	     section symbol winds up in the output section.  */
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_SECTION
condition|)
block|{
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|addend
operator|=
name|rel
operator|->
name|r_addend
operator|+=
name|sec
operator|->
name|output_offset
operator|+
name|sym
operator|->
name|st_value
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ttype = %s (%d), symbol index = %ld, offset = %ld, addend = %ld\n"
argument_list|,
name|howto
operator|->
name|name
argument_list|,
operator|(
name|int
operator|)
name|r_type
argument_list|,
name|r_symndx
argument_list|,
operator|(
name|long
operator|)
name|offset
argument_list|,
operator|(
name|long
operator|)
name|addend
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
comment|/* This is a final link.  */
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|sym_name
operator|=
literal|"<local symbol>"
expr_stmt|;
name|relocation
operator|=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|sym
operator|->
name|st_value
operator|)
expr_stmt|;
comment|/* Relocs to local symbols are always resolved.  */
name|will_become_local
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|sym_name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
comment|/* Can this relocation be resolved immediately?  */
name|will_become_local
operator|=
name|SYMBOL_REFERENCES_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
block|{
name|sec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|r_type
operator|==
name|R_PPC_PLT32
operator|||
name|r_type
operator|==
name|R_PPC_PLTREL24
operator|)
operator|&&
name|splt
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|plt
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|)
operator|||
operator|(
name|r_type
operator|==
name|R_PPC_LOCAL24PC
operator|&&
name|sec
operator|->
name|output_section
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|(
name|r_type
operator|==
name|R_PPC_GOT16
operator|||
name|r_type
operator|==
name|R_PPC_GOT16_LO
operator|||
name|r_type
operator|==
name|R_PPC_GOT16_HI
operator|||
name|r_type
operator|==
name|R_PPC_GOT16_HA
operator|)
operator|&&
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
operator|&&
operator|(
operator|!
name|info
operator|->
name|shared
operator|||
operator|!
name|will_become_local
operator|)
operator|)
operator|||
operator|(
name|info
operator|->
name|shared
operator|&&
operator|!
name|will_become_local
operator|&&
operator|(
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
comment|/* Testing SEC_DEBUGGING here may be wrong.                              It's here to avoid a crash when                              generating a shared library with DWARF                              debugging information.  */
operator|||
operator|(
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_DEBUGGING
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|)
operator|)
operator|&&
operator|(
name|r_type
operator|==
name|R_PPC_ADDR32
operator|||
name|r_type
operator|==
name|R_PPC_ADDR24
operator|||
name|r_type
operator|==
name|R_PPC_ADDR16
operator|||
name|r_type
operator|==
name|R_PPC_ADDR16_LO
operator|||
name|r_type
operator|==
name|R_PPC_ADDR16_HI
operator|||
name|r_type
operator|==
name|R_PPC_ADDR16_HA
operator|||
name|r_type
operator|==
name|R_PPC_ADDR14
operator|||
name|r_type
operator|==
name|R_PPC_ADDR14_BRTAKEN
operator|||
name|r_type
operator|==
name|R_PPC_ADDR14_BRNTAKEN
operator|||
name|r_type
operator|==
name|R_PPC_COPY
operator|||
name|r_type
operator|==
name|R_PPC_GLOB_DAT
operator|||
name|r_type
operator|==
name|R_PPC_JMP_SLOT
operator|||
name|r_type
operator|==
name|R_PPC_UADDR32
operator|||
name|r_type
operator|==
name|R_PPC_UADDR16
operator|||
name|r_type
operator|==
name|R_PPC_SDAREL16
operator|||
name|r_type
operator|==
name|R_PPC_EMB_NADDR32
operator|||
name|r_type
operator|==
name|R_PPC_EMB_NADDR16
operator|||
name|r_type
operator|==
name|R_PPC_EMB_NADDR16_LO
operator|||
name|r_type
operator|==
name|R_PPC_EMB_NADDR16_HI
operator|||
name|r_type
operator|==
name|R_PPC_EMB_NADDR16_HA
operator|||
name|r_type
operator|==
name|R_PPC_EMB_SDAI16
operator|||
name|r_type
operator|==
name|R_PPC_EMB_SDA2I16
operator|||
name|r_type
operator|==
name|R_PPC_EMB_SDA2REL
operator|||
name|r_type
operator|==
name|R_PPC_EMB_SDA21
operator|||
name|r_type
operator|==
name|R_PPC_EMB_MRKREF
operator|||
name|r_type
operator|==
name|R_PPC_EMB_BIT_FLD
operator|||
name|r_type
operator|==
name|R_PPC_EMB_RELSDA
operator|||
operator|(
operator|(
name|r_type
operator|==
name|R_PPC_REL24
operator|||
name|r_type
operator|==
name|R_PPC_REL32
operator|||
name|r_type
operator|==
name|R_PPC_REL14
operator|||
name|r_type
operator|==
name|R_PPC_REL14_BRTAKEN
operator|||
name|r_type
operator|==
name|R_PPC_REL14_BRNTAKEN
operator|||
name|r_type
operator|==
name|R_PPC_RELATIVE
operator|)
operator|&&
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|)
operator|!=
literal|0
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* In these cases, we don't need the relocation                      value.  We check specially because in some                      obscure cases sec->output_section will be NULL.  */
name|relocation
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sec
operator|->
name|output_section
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: warning: unresolvable relocation against symbol `%s' from %s section"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|bfd_get_section_name
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
argument_list|)
expr_stmt|;
name|relocation
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|relocation
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
operator|!
name|info
operator|->
name|symbolic
operator|&&
operator|!
name|info
operator|->
name|no_undefined
operator|&&
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_DEFAULT
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
operator|(
operator|!
name|info
operator|->
name|shared
operator|||
name|info
operator|->
name|no_undefined
operator|||
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|)
argument_list|)
condition|)
return|return
name|false
return|;
name|relocation
operator|=
literal|0
expr_stmt|;
block|}
block|}
switch|switch
condition|(
operator|(
name|int
operator|)
name|r_type
condition|)
block|{
default|default:
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: unknown relocation type %d for symbol %s"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|r_type
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
name|ret
operator|=
name|false
expr_stmt|;
continue|continue;
comment|/* Relocations that need no special processing.  */
case|case
operator|(
name|int
operator|)
name|R_PPC_LOCAL24PC
case|:
comment|/* It makes no sense to point a local relocation 	     at a symbol not in this object.  */
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
name|sec
operator|->
name|output_section
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|true
argument_list|)
condition|)
return|return
name|false
return|;
continue|continue;
block|}
break|break;
comment|/* Relocations that may need to be propagated if this is a shared            object.  */
case|case
operator|(
name|int
operator|)
name|R_PPC_REL24
case|:
case|case
operator|(
name|int
operator|)
name|R_PPC_REL32
case|:
case|case
operator|(
name|int
operator|)
name|R_PPC_REL14
case|:
comment|/* If these relocations are not to a named symbol, they can be 	     handled right here, no need to bother the dynamic linker.  */
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|)
operator|==
literal|0
operator|||
name|SYMBOL_REFERENCES_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
break|break;
comment|/* fall through */
comment|/* Relocations that always need to be propagated if this is a shared            object.  */
case|case
operator|(
name|int
operator|)
name|R_PPC_NONE
case|:
case|case
operator|(
name|int
operator|)
name|R_PPC_ADDR32
case|:
case|case
operator|(
name|int
operator|)
name|R_PPC_ADDR24
case|:
case|case
operator|(
name|int
operator|)
name|R_PPC_ADDR16
case|:
case|case
operator|(
name|int
operator|)
name|R_PPC_ADDR16_LO
case|:
case|case
operator|(
name|int
operator|)
name|R_PPC_ADDR16_HI
case|:
case|case
operator|(
name|int
operator|)
name|R_PPC_ADDR16_HA
case|:
case|case
operator|(
name|int
operator|)
name|R_PPC_ADDR14
case|:
case|case
operator|(
name|int
operator|)
name|R_PPC_UADDR32
case|:
case|case
operator|(
name|int
operator|)
name|R_PPC_UADDR16
case|:
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
name|Elf_Internal_Rela
name|outrel
decl_stmt|;
name|boolean
name|skip
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ppc_elf_relocate_section need to create relocation for %s\n"
argument_list|,
operator|(
name|h
operator|&&
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
operator|)
condition|?
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
else|:
literal|"<unknown>"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* When generating a shared object, these relocations                  are copied into the output file to be resolved at run                  time.  */
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
operator|(
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|elf_elfheader
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|e_shstrndx
argument_list|,
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|rel_hdr
operator|.
name|sh_name
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|BFD_ASSERT
argument_list|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".rela"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
argument_list|,
name|name
operator|+
literal|5
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|sreloc
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sreloc
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
name|skip
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|stab_info
operator|==
name|NULL
condition|)
name|outrel
operator|.
name|r_offset
operator|=
name|rel
operator|->
name|r_offset
expr_stmt|;
else|else
block|{
name|bfd_vma
name|off
decl_stmt|;
name|off
operator|=
operator|(
name|_bfd_stab_section_offset
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|stab_info
argument_list|,
name|input_section
argument_list|,
operator|&
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|stab_info
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|off
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
name|skip
operator|=
name|true
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|=
name|off
expr_stmt|;
block|}
name|outrel
operator|.
name|r_offset
operator|+=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
if|if
condition|(
name|skip
condition|)
name|memset
argument_list|(
operator|&
name|outrel
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|outrel
argument_list|)
expr_stmt|;
comment|/* h->dynindx may be -1 if this symbol was marked to                  become local.  */
elseif|else
if|if
condition|(
operator|!
name|will_become_local
condition|)
block|{
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
name|rel
operator|->
name|r_addend
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|r_type
operator|==
name|R_PPC_ADDR32
condition|)
block|{
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_PPC_RELATIVE
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
name|relocation
operator|+
name|rel
operator|->
name|r_addend
expr_stmt|;
block|}
else|else
block|{
name|long
name|indx
decl_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
else|else
block|{
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
argument_list|)
expr_stmt|;
name|sec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
block|}
if|if
condition|(
name|sec
operator|!=
name|NULL
operator|&&
name|bfd_is_abs_section
argument_list|(
name|sec
argument_list|)
condition|)
name|indx
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|sec
operator|==
name|NULL
operator|||
name|sec
operator|->
name|owner
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
else|else
block|{
name|asection
modifier|*
name|osec
decl_stmt|;
name|osec
operator|=
name|sec
operator|->
name|output_section
expr_stmt|;
name|indx
operator|=
name|elf_section_data
argument_list|(
name|osec
argument_list|)
operator|->
name|dynindx
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|indx
operator|>
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|indx
operator|<=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"indx=%d section=%s flags=%08x name=%s\n"
argument_list|,
name|indx
argument_list|,
name|osec
operator|->
name|name
argument_list|,
name|osec
operator|->
name|flags
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|indx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
name|relocation
operator|+
name|rel
operator|->
name|r_addend
expr_stmt|;
block|}
block|}
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
operator|(
operator|(
operator|(
name|Elf32_External_Rela
operator|*
operator|)
name|sreloc
operator|->
name|contents
operator|)
operator|+
name|sreloc
operator|->
name|reloc_count
operator|)
argument_list|)
expr_stmt|;
operator|++
name|sreloc
operator|->
name|reloc_count
expr_stmt|;
comment|/* This reloc will be computed at runtime, so there's no                  need to do anything now, unless this is a RELATIVE                  reloc in an unallocated section.  */
if|if
condition|(
name|skip
operator|||
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
operator|||
name|ELF32_R_TYPE
argument_list|(
name|outrel
operator|.
name|r_info
argument_list|)
operator|!=
name|R_PPC_RELATIVE
condition|)
continue|continue;
block|}
comment|/* Arithmetic adjust relocations that aren't going into a 	     shared object.  */
if|if
condition|(
name|r_type
operator|==
name|R_PPC_ADDR16_HA
comment|/* It's just possible that this symbol is a weak symbol 		 that's not actually defined anywhere. In that case, 		 'sec' would be NULL, and we should leave the symbol 		 alone (it will be set to zero elsewhere in the link).  */
operator|&&
name|sec
operator|!=
name|NULL
condition|)
block|{
name|addend
operator|+=
operator|(
operator|(
name|relocation
operator|+
name|addend
operator|)
operator|&
literal|0x8000
operator|)
operator|<<
literal|1
expr_stmt|;
block|}
break|break;
comment|/* branch taken prediction relocations */
case|case
operator|(
name|int
operator|)
name|R_PPC_ADDR14_BRTAKEN
case|:
case|case
operator|(
name|int
operator|)
name|R_PPC_REL14_BRTAKEN
case|:
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|output_bfd
argument_list|,
name|contents
operator|+
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|relocation
operator|-
name|offset
operator|)
operator|&
literal|0x8000
condition|)
name|insn
operator|&=
operator|~
name|BRANCH_PREDICT_BIT
expr_stmt|;
else|else
name|insn
operator||=
name|BRANCH_PREDICT_BIT
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|insn
argument_list|,
name|contents
operator|+
name|offset
argument_list|)
expr_stmt|;
break|break;
comment|/* branch not taken predicition relocations */
case|case
operator|(
name|int
operator|)
name|R_PPC_ADDR14_BRNTAKEN
case|:
case|case
operator|(
name|int
operator|)
name|R_PPC_REL14_BRNTAKEN
case|:
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|output_bfd
argument_list|,
name|contents
operator|+
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|relocation
operator|-
name|offset
operator|)
operator|&
literal|0x8000
condition|)
name|insn
operator||=
name|BRANCH_PREDICT_BIT
expr_stmt|;
else|else
name|insn
operator|&=
operator|~
name|BRANCH_PREDICT_BIT
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|insn
argument_list|,
name|contents
operator|+
name|offset
argument_list|)
expr_stmt|;
break|break;
comment|/* GOT16 relocations */
case|case
operator|(
name|int
operator|)
name|R_PPC_GOT16
case|:
case|case
operator|(
name|int
operator|)
name|R_PPC_GOT16_LO
case|:
case|case
operator|(
name|int
operator|)
name|R_PPC_GOT16_HI
case|:
case|case
operator|(
name|int
operator|)
name|R_PPC_GOT16_HA
case|:
comment|/* Relocation is to the entry for this symbol in the global              offset table.  */
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|bfd_vma
name|off
decl_stmt|;
name|off
operator|=
name|h
operator|->
name|got
operator|.
name|offset
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|off
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
operator|||
operator|(
name|info
operator|->
name|shared
operator|&&
name|SYMBOL_REFERENCES_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
operator|)
condition|)
block|{
comment|/* This is actually a static link, or it is a                      -Bsymbolic link and the symbol is defined                      locally.  We must initialize this entry in the                      global offset table.  Since the offset must                      always be a multiple of 4, we use the least                      significant bit to record whether we have                      initialized it already.  		     When doing a dynamic link, we create a .rela.got 		     relocation entry to initialize the value.  This 		     is done in the finish_dynamic_symbol routine.  */
if|if
condition|(
operator|(
name|off
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|off
operator|&=
operator|~
literal|1
expr_stmt|;
else|else
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|relocation
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|off
argument_list|)
expr_stmt|;
name|h
operator|->
name|got
operator|.
name|offset
operator||=
literal|1
expr_stmt|;
block|}
block|}
name|relocation
operator|=
name|sgot
operator|->
name|output_offset
operator|+
name|off
operator|-
literal|4
expr_stmt|;
block|}
else|else
block|{
name|bfd_vma
name|off
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|local_got_offsets
operator|!=
name|NULL
operator|&&
name|local_got_offsets
index|[
name|r_symndx
index|]
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|off
operator|=
name|local_got_offsets
index|[
name|r_symndx
index|]
expr_stmt|;
comment|/* The offset must always be a multiple of 4.  We use 		 the least significant bit to record whether we have 		 already processed this entry.  */
if|if
condition|(
operator|(
name|off
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|off
operator|&=
operator|~
literal|1
expr_stmt|;
else|else
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|relocation
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|off
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
name|asection
modifier|*
name|srelgot
decl_stmt|;
name|Elf_Internal_Rela
name|outrel
decl_stmt|;
comment|/* We need to generate a R_PPC_RELATIVE reloc 			 for the dynamic linker.  */
name|srelgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|srelgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|=
operator|(
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
name|off
operator|)
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_PPC_RELATIVE
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
name|relocation
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
operator|(
operator|(
operator|(
name|Elf32_External_Rela
operator|*
operator|)
name|srelgot
operator|->
name|contents
operator|)
operator|+
name|srelgot
operator|->
name|reloc_count
operator|)
argument_list|)
expr_stmt|;
operator|++
name|srelgot
operator|->
name|reloc_count
expr_stmt|;
block|}
name|local_got_offsets
index|[
name|r_symndx
index|]
operator||=
literal|1
expr_stmt|;
block|}
name|relocation
operator|=
name|sgot
operator|->
name|output_offset
operator|+
name|off
operator|-
literal|4
expr_stmt|;
block|}
break|break;
comment|/* Indirect .sdata relocation */
case|case
operator|(
name|int
operator|)
name|R_PPC_EMB_SDAI16
case|:
name|BFD_ASSERT
argument_list|(
name|sdata
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|relocation
operator|=
name|bfd_elf32_finish_pointer_linker_section
argument_list|(
name|output_bfd
argument_list|,
name|input_bfd
argument_list|,
name|info
argument_list|,
name|sdata
argument_list|,
name|h
argument_list|,
name|relocation
argument_list|,
name|rel
argument_list|,
name|R_PPC_RELATIVE
argument_list|)
expr_stmt|;
break|break;
comment|/* Indirect .sdata2 relocation */
case|case
operator|(
name|int
operator|)
name|R_PPC_EMB_SDA2I16
case|:
name|BFD_ASSERT
argument_list|(
name|sdata2
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|relocation
operator|=
name|bfd_elf32_finish_pointer_linker_section
argument_list|(
name|output_bfd
argument_list|,
name|input_bfd
argument_list|,
name|info
argument_list|,
name|sdata2
argument_list|,
name|h
argument_list|,
name|relocation
argument_list|,
name|rel
argument_list|,
name|R_PPC_RELATIVE
argument_list|)
expr_stmt|;
break|break;
comment|/* Handle the TOC16 reloc.  We want to use the offset within the .got 	   section, not the actual VMA.  This is appropriate when generating 	   an embedded ELF object, for which the .got section acts like the 	   AIX .toc section.  */
case|case
operator|(
name|int
operator|)
name|R_PPC_TOC16
case|:
comment|/* phony GOT16 relocations */
name|BFD_ASSERT
argument_list|(
name|sec
operator|!=
operator|(
name|asection
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
argument|bfd_is_und_section (sec) 		      || strcmp (bfd_get_section_name (abfd, sec),
literal|".got"
argument|) ==
literal|0
argument||| strcmp (bfd_get_section_name (abfd, sec),
literal|".cgot"
argument|) ==
literal|0
argument_list|)
name|addend
operator|-=
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
literal|0x8000
expr_stmt|;
break|break;
case|case
operator|(
name|int
operator|)
name|R_PPC_PLTREL24
case|:
comment|/* Relocation is to the entry for this symbol in the              procedure linkage table.  */
name|BFD_ASSERT
argument_list|(
name|h
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|||
name|splt
operator|==
name|NULL
condition|)
block|{
comment|/* We didn't make a PLT entry for this symbol.  This                  happens when statically linking PIC code, or when                  using -Bsymbolic.  */
break|break;
block|}
name|relocation
operator|=
operator|(
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|splt
operator|->
name|output_offset
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|)
expr_stmt|;
break|break;
comment|/* relocate against _SDA_BASE_ */
case|case
operator|(
name|int
operator|)
name|R_PPC_SDAREL16
case|:
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|sec
operator|!=
operator|(
name|asection
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
operator|->
name|output_section
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sdata"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sbss"
argument_list|)
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: The target (%s) of a %s relocation is in the wrong output section (%s)"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|sym_name
argument_list|,
name|ppc_elf_howto_table
index|[
operator|(
name|int
operator|)
name|r_type
index|]
operator|->
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|addend
operator|-=
operator|(
name|sdata
operator|->
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|sdata
operator|->
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sdata
operator|->
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
break|break;
comment|/* relocate against _SDA2_BASE_ */
case|case
operator|(
name|int
operator|)
name|R_PPC_EMB_SDA2REL
case|:
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|sec
operator|!=
operator|(
name|asection
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
operator|->
name|output_section
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sdata2"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sbss2"
argument_list|)
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: The target (%s) of a %s relocation is in the wrong output section (%s)"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|sym_name
argument_list|,
name|ppc_elf_howto_table
index|[
operator|(
name|int
operator|)
name|r_type
index|]
operator|->
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
name|ret
operator|=
name|false
expr_stmt|;
continue|continue;
block|}
name|addend
operator|-=
operator|(
name|sdata2
operator|->
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|sdata2
operator|->
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sdata2
operator|->
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
break|break;
comment|/* relocate against either _SDA_BASE_, _SDA2_BASE_, or 0 */
case|case
operator|(
name|int
operator|)
name|R_PPC_EMB_SDA21
case|:
case|case
operator|(
name|int
operator|)
name|R_PPC_EMB_RELSDA
case|:
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|reg
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|sec
operator|!=
operator|(
name|asection
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
operator|->
name|output_section
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sdata"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sbss"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|reg
operator|=
literal|13
expr_stmt|;
name|addend
operator|-=
operator|(
name|sdata
operator|->
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|sdata
operator|->
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sdata
operator|->
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sdata2"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sbss2"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|reg
operator|=
literal|2
expr_stmt|;
name|addend
operator|-=
operator|(
name|sdata2
operator|->
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|sdata2
operator|->
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sdata2
operator|->
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".PPC.EMB.sdata0"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".PPC.EMB.sbss0"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|reg
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: The target (%s) of a %s relocation is in the wrong output section (%s)"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|sym_name
argument_list|,
name|ppc_elf_howto_table
index|[
operator|(
name|int
operator|)
name|r_type
index|]
operator|->
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
name|ret
operator|=
name|false
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|r_type
operator|==
name|R_PPC_EMB_SDA21
condition|)
block|{
comment|/* fill in register field */
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|output_bfd
argument_list|,
name|contents
operator|+
name|offset
argument_list|)
expr_stmt|;
name|insn
operator|=
operator|(
name|insn
operator|&
operator|~
name|RA_REGISTER_MASK
operator|)
operator||
operator|(
name|reg
operator|<<
name|RA_REGISTER_SHIFT
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|insn
argument_list|,
name|contents
operator|+
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
comment|/* Relocate against the beginning of the section */
case|case
operator|(
name|int
operator|)
name|R_PPC_SECTOFF
case|:
case|case
operator|(
name|int
operator|)
name|R_PPC_SECTOFF_LO
case|:
case|case
operator|(
name|int
operator|)
name|R_PPC_SECTOFF_HI
case|:
name|BFD_ASSERT
argument_list|(
name|sec
operator|!=
operator|(
name|asection
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|addend
operator|-=
name|sec
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
break|break;
case|case
operator|(
name|int
operator|)
name|R_PPC_SECTOFF_HA
case|:
name|BFD_ASSERT
argument_list|(
name|sec
operator|!=
operator|(
name|asection
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|addend
operator|-=
name|sec
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|addend
operator|+=
operator|(
operator|(
name|relocation
operator|+
name|addend
operator|)
operator|&
literal|0x8000
operator|)
operator|<<
literal|1
expr_stmt|;
break|break;
comment|/* Negative relocations */
case|case
operator|(
name|int
operator|)
name|R_PPC_EMB_NADDR32
case|:
case|case
operator|(
name|int
operator|)
name|R_PPC_EMB_NADDR16
case|:
case|case
operator|(
name|int
operator|)
name|R_PPC_EMB_NADDR16_LO
case|:
case|case
operator|(
name|int
operator|)
name|R_PPC_EMB_NADDR16_HI
case|:
name|addend
operator|-=
literal|2
operator|*
name|relocation
expr_stmt|;
break|break;
case|case
operator|(
name|int
operator|)
name|R_PPC_EMB_NADDR16_HA
case|:
name|addend
operator|-=
literal|2
operator|*
name|relocation
expr_stmt|;
name|addend
operator|+=
operator|(
operator|(
name|relocation
operator|+
name|addend
operator|)
operator|&
literal|0x8000
operator|)
operator|<<
literal|1
expr_stmt|;
break|break;
comment|/* NOP relocation that prevents garbage collecting linkers from omitting a 	   reference.  */
case|case
operator|(
name|int
operator|)
name|R_PPC_EMB_MRKREF
case|:
continue|continue;
case|case
operator|(
name|int
operator|)
name|R_PPC_COPY
case|:
case|case
operator|(
name|int
operator|)
name|R_PPC_GLOB_DAT
case|:
case|case
operator|(
name|int
operator|)
name|R_PPC_JMP_SLOT
case|:
case|case
operator|(
name|int
operator|)
name|R_PPC_RELATIVE
case|:
case|case
operator|(
name|int
operator|)
name|R_PPC_PLT32
case|:
case|case
operator|(
name|int
operator|)
name|R_PPC_PLTREL32
case|:
case|case
operator|(
name|int
operator|)
name|R_PPC_PLT16_LO
case|:
case|case
operator|(
name|int
operator|)
name|R_PPC_PLT16_HI
case|:
case|case
operator|(
name|int
operator|)
name|R_PPC_PLT16_HA
case|:
case|case
operator|(
name|int
operator|)
name|R_PPC_EMB_RELSEC16
case|:
case|case
operator|(
name|int
operator|)
name|R_PPC_EMB_RELST_LO
case|:
case|case
operator|(
name|int
operator|)
name|R_PPC_EMB_RELST_HI
case|:
case|case
operator|(
name|int
operator|)
name|R_PPC_EMB_RELST_HA
case|:
case|case
operator|(
name|int
operator|)
name|R_PPC_EMB_BIT_FLD
case|:
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: Relocation %s is not yet supported for symbol %s."
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|ppc_elf_howto_table
index|[
operator|(
name|int
operator|)
name|r_type
index|]
operator|->
name|name
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
name|ret
operator|=
name|false
expr_stmt|;
continue|continue;
case|case
operator|(
name|int
operator|)
name|R_PPC_GNU_VTINHERIT
case|:
case|case
operator|(
name|int
operator|)
name|R_PPC_GNU_VTENTRY
case|:
comment|/* These are no-ops in the end.  */
continue|continue;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ttype = %s (%d), name = %s, symbol index = %ld, offset = %ld, addend = %ld\n"
argument_list|,
name|howto
operator|->
name|name
argument_list|,
operator|(
name|int
operator|)
name|r_type
argument_list|,
name|sym_name
argument_list|,
name|r_symndx
argument_list|,
operator|(
name|long
operator|)
name|offset
argument_list|,
operator|(
name|long
operator|)
name|addend
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|r
operator|=
name|_bfd_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|offset
argument_list|,
name|relocation
argument_list|,
name|addend
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|bfd_reloc_ok
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|r
operator|==
name|bfd_reloc_overflow
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|&&
name|howto
operator|->
name|pc_relative
condition|)
block|{
comment|/* Assume this is a call protected by other code that 		     detect the symbol is undefined.  If this is the case, 		     we can safely ignore the overflow.  If not, the 		     program is hosed anyway, and a little warning isn't 		     going to help.  */
continue|continue;
block|}
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
block|}
else|else
block|{
name|name
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_link
argument_list|,
name|sym
operator|->
name|st_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|*
name|name
operator|==
literal|'\0'
condition|)
name|name
operator|=
name|bfd_section_name
argument_list|(
name|input_bfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|info
argument_list|,
name|name
argument_list|,
name|howto
operator|->
name|name
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|offset
argument_list|)
condition|)
return|return
name|false
return|;
block|}
else|else
name|ret
operator|=
name|false
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|ret
return|;
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|TARGET_LITTLE_SYM
value|bfd_elf32_powerpcle_vec
end_define

begin_define
define|#
directive|define
name|TARGET_LITTLE_NAME
value|"elf32-powerpcle"
end_define

begin_define
define|#
directive|define
name|TARGET_BIG_SYM
value|bfd_elf32_powerpc_vec
end_define

begin_define
define|#
directive|define
name|TARGET_BIG_NAME
value|"elf32-powerpc"
end_define

begin_define
define|#
directive|define
name|ELF_ARCH
value|bfd_arch_powerpc
end_define

begin_define
define|#
directive|define
name|ELF_MACHINE_CODE
value|EM_PPC
end_define

begin_define
define|#
directive|define
name|ELF_MAXPAGESIZE
value|0x10000
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto
value|ppc_elf_info_to_howto
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|EM_CYGNUS_POWERPC
end_ifdef

begin_define
define|#
directive|define
name|ELF_MACHINE_ALT1
value|EM_CYGNUS_POWERPC
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EM_PPC_OLD
end_ifdef

begin_define
define|#
directive|define
name|ELF_MACHINE_ALT2
value|EM_PPC_OLD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|elf_backend_plt_not_loaded
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_got_symbol_offset
value|4
end_define

begin_define
define|#
directive|define
name|elf_backend_can_gc_sections
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_got_header_size
value|12
end_define

begin_define
define|#
directive|define
name|elf_backend_plt_header_size
value|PLT_INITIAL_ENTRY_SIZE
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_copy_private_bfd_data
value|ppc_elf_copy_private_bfd_data
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_merge_private_bfd_data
value|ppc_elf_merge_private_bfd_data
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_relax_section
value|ppc_elf_relax_section
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_reloc_type_lookup
value|ppc_elf_reloc_type_lookup
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_set_private_flags
value|ppc_elf_set_private_flags
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_final_link
value|_bfd_elf32_gc_common_final_link
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_mark_hook
value|ppc_elf_gc_mark_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_sweep_hook
value|ppc_elf_gc_sweep_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_section_from_shdr
value|ppc_elf_section_from_shdr
end_define

begin_define
define|#
directive|define
name|elf_backend_relocate_section
value|ppc_elf_relocate_section
end_define

begin_define
define|#
directive|define
name|elf_backend_create_dynamic_sections
value|ppc_elf_create_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_check_relocs
value|ppc_elf_check_relocs
end_define

begin_define
define|#
directive|define
name|elf_backend_adjust_dynamic_symbol
value|ppc_elf_adjust_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_add_symbol_hook
value|ppc_elf_add_symbol_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_size_dynamic_sections
value|ppc_elf_size_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_symbol
value|ppc_elf_finish_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_sections
value|ppc_elf_finish_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_fake_sections
value|ppc_elf_fake_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_additional_program_headers
value|ppc_elf_additional_program_headers
end_define

begin_define
define|#
directive|define
name|elf_backend_modify_segment_map
value|ppc_elf_modify_segment_map
end_define

begin_include
include|#
directive|include
file|"elf32-target.h"
end_include

end_unit

