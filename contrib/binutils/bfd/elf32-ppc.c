begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* PowerPC-specific support for 32-bit ELF    Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,    2004 Free Software Foundation, Inc.    Written by Ian Lance Taylor, Cygnus Support.     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the    Free Software Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file is based on a preliminary PowerPC ELF ABI.  The    information may not match the final PowerPC ELF ABI.  It includes    suggestions from the in-progress Embedded PowerPC ABI, and that    information may also not match.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf/ppc.h"
end_include

begin_include
include|#
directive|include
file|"elf32-ppc.h"
end_include

begin_comment
comment|/* RELA relocations are used here.  */
end_comment

begin_function_decl
specifier|static
name|bfd_reloc_status_type
name|ppc_elf_addr16_ha_reloc
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|arelent
modifier|*
parameter_list|,
name|asymbol
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_reloc_status_type
name|ppc_elf_unhandled_reloc
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|arelent
modifier|*
parameter_list|,
name|asymbol
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Branch prediction bit for branch taken relocs.  */
end_comment

begin_define
define|#
directive|define
name|BRANCH_PREDICT_BIT
value|0x200000
end_define

begin_comment
comment|/* Mask to set RA in memory instructions.  */
end_comment

begin_define
define|#
directive|define
name|RA_REGISTER_MASK
value|0x001f0000
end_define

begin_comment
comment|/* Value to shift register by to insert RA.  */
end_comment

begin_define
define|#
directive|define
name|RA_REGISTER_SHIFT
value|16
end_define

begin_comment
comment|/* The name of the dynamic interpreter.  This is put in the .interp    section.  */
end_comment

begin_define
define|#
directive|define
name|ELF_DYNAMIC_INTERPRETER
value|"/usr/lib/ld.so.1"
end_define

begin_comment
comment|/* The size in bytes of an entry in the procedure linkage table.  */
end_comment

begin_define
define|#
directive|define
name|PLT_ENTRY_SIZE
value|12
end_define

begin_comment
comment|/* The initial size of the plt reserved for the dynamic linker.  */
end_comment

begin_define
define|#
directive|define
name|PLT_INITIAL_ENTRY_SIZE
value|72
end_define

begin_comment
comment|/* The size of the gap between entries in the PLT.  */
end_comment

begin_define
define|#
directive|define
name|PLT_SLOT_SIZE
value|8
end_define

begin_comment
comment|/* The number of single-slot PLT entries (the rest use two slots).  */
end_comment

begin_define
define|#
directive|define
name|PLT_NUM_SINGLE_ENTRIES
value|8192
end_define

begin_comment
comment|/* Some nop instructions.  */
end_comment

begin_define
define|#
directive|define
name|NOP
value|0x60000000
end_define

begin_define
define|#
directive|define
name|CROR_151515
value|0x4def7b82
end_define

begin_define
define|#
directive|define
name|CROR_313131
value|0x4ffffb82
end_define

begin_comment
comment|/* Offset of tp and dtp pointers from start of TLS block.  */
end_comment

begin_define
define|#
directive|define
name|TP_OFFSET
value|0x7000
end_define

begin_define
define|#
directive|define
name|DTP_OFFSET
value|0x8000
end_define

begin_escape
end_escape

begin_comment
comment|/* Enumeration to specify the special section.  */
end_comment

begin_enum
enum|enum
name|elf_linker_section_enum
block|{
name|LINKER_SECTION_SDATA
block|,
name|LINKER_SECTION_SDATA2
block|}
enum|;
end_enum

begin_comment
comment|/* Sections created by the linker.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|elf_linker_section
block|{
comment|/* pointer to the section */
name|asection
modifier|*
name|section
decl_stmt|;
comment|/* pointer to the relocations needed for this section */
name|asection
modifier|*
name|rel_section
decl_stmt|;
comment|/* pointer to the created symbol hash value */
name|struct
name|elf_link_hash_entry
modifier|*
name|sym_hash
decl_stmt|;
comment|/* offset of symbol from beginning of section */
name|bfd_vma
name|sym_offset
decl_stmt|;
block|}
name|elf_linker_section_t
typedef|;
end_typedef

begin_comment
comment|/* Linked list of allocated pointer entries.  This hangs off of the    symbol lists, and provides allows us to return different pointers,    based on different addend's.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|elf_linker_section_pointers
block|{
comment|/* next allocated pointer for this symbol */
name|struct
name|elf_linker_section_pointers
modifier|*
name|next
decl_stmt|;
comment|/* offset of pointer from beginning of section */
name|bfd_vma
name|offset
decl_stmt|;
comment|/* addend used */
name|bfd_vma
name|addend
decl_stmt|;
comment|/* which linker section this is */
name|elf_linker_section_t
modifier|*
name|lsect
decl_stmt|;
comment|/* whether address was written yet */
name|bfd_boolean
name|written_address_p
decl_stmt|;
block|}
name|elf_linker_section_pointers_t
typedef|;
end_typedef

begin_struct
struct|struct
name|ppc_elf_obj_tdata
block|{
name|struct
name|elf_obj_tdata
name|elf
decl_stmt|;
comment|/* A mapping from local symbols to offsets into the various linker      sections added.  This is index by the symbol index.  */
name|elf_linker_section_pointers_t
modifier|*
modifier|*
name|linker_section_pointers
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|ppc_elf_tdata
parameter_list|(
name|bfd
parameter_list|)
define|\
value|((struct ppc_elf_obj_tdata *) (bfd)->tdata.any)
end_define

begin_define
define|#
directive|define
name|elf_local_ptr_offsets
parameter_list|(
name|bfd
parameter_list|)
define|\
value|(ppc_elf_tdata (bfd)->linker_section_pointers)
end_define

begin_comment
comment|/* Override the generic function because we store some extras.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc_elf_mkobject
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|ppc_elf_obj_tdata
argument_list|)
decl_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|any
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|tdata
operator|.
name|any
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* The PPC linker needs to keep track of the number of relocs that it    decides to copy as dynamic relocs in check_relocs for each symbol.    This is so that it can later discard them if they are found to be    unnecessary.  We store the information in a field extending the    regular ELF linker hash table.  */
end_comment

begin_struct
struct|struct
name|ppc_elf_dyn_relocs
block|{
name|struct
name|ppc_elf_dyn_relocs
modifier|*
name|next
decl_stmt|;
comment|/* The input section of the reloc.  */
name|asection
modifier|*
name|sec
decl_stmt|;
comment|/* Total number of relocs copied for the input section.  */
name|bfd_size_type
name|count
decl_stmt|;
comment|/* Number of pc-relative relocs copied for the input section.  */
name|bfd_size_type
name|pc_count
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* PPC ELF linker hash entry.  */
end_comment

begin_struct
struct|struct
name|ppc_elf_link_hash_entry
block|{
name|struct
name|elf_link_hash_entry
name|elf
decl_stmt|;
comment|/* If this symbol is used in the linker created sections, the processor      specific backend uses this field to map the field into the offset      from the beginning of the section.  */
name|elf_linker_section_pointers_t
modifier|*
name|linker_section_pointer
decl_stmt|;
comment|/* Track dynamic relocs copied for this symbol.  */
name|struct
name|ppc_elf_dyn_relocs
modifier|*
name|dyn_relocs
decl_stmt|;
comment|/* Contexts in which symbol is used in the GOT (or TOC).      TLS_GD .. TLS_TLS bits are or'd into the mask as the      corresponding relocs are encountered during check_relocs.      tls_optimize clears TLS_GD .. TLS_TPREL when optimizing to      indicate the corresponding GOT entry type is not needed.  */
define|#
directive|define
name|TLS_GD
value|1
comment|/* GD reloc. */
define|#
directive|define
name|TLS_LD
value|2
comment|/* LD reloc. */
define|#
directive|define
name|TLS_TPREL
value|4
comment|/* TPREL reloc, => IE. */
define|#
directive|define
name|TLS_DTPREL
value|8
comment|/* DTPREL reloc, => LD. */
define|#
directive|define
name|TLS_TLS
value|16
comment|/* Any TLS reloc.  */
define|#
directive|define
name|TLS_TPRELGD
value|32
comment|/* TPREL reloc resulting from GD->IE. */
name|char
name|tls_mask
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|ppc_elf_hash_entry
parameter_list|(
name|ent
parameter_list|)
value|((struct ppc_elf_link_hash_entry *) (ent))
end_define

begin_comment
comment|/* PPC ELF linker hash table.  */
end_comment

begin_struct
struct|struct
name|ppc_elf_link_hash_table
block|{
name|struct
name|elf_link_hash_table
name|elf
decl_stmt|;
comment|/* Short-cuts to get to dynamic linker sections.  */
name|asection
modifier|*
name|got
decl_stmt|;
name|asection
modifier|*
name|relgot
decl_stmt|;
name|asection
modifier|*
name|plt
decl_stmt|;
name|asection
modifier|*
name|relplt
decl_stmt|;
name|asection
modifier|*
name|dynbss
decl_stmt|;
name|asection
modifier|*
name|relbss
decl_stmt|;
name|asection
modifier|*
name|dynsbss
decl_stmt|;
name|asection
modifier|*
name|relsbss
decl_stmt|;
name|elf_linker_section_t
modifier|*
name|sdata
decl_stmt|;
name|elf_linker_section_t
modifier|*
name|sdata2
decl_stmt|;
name|asection
modifier|*
name|sbss
decl_stmt|;
comment|/* Shortcut to .__tls_get_addr.  */
name|struct
name|elf_link_hash_entry
modifier|*
name|tls_get_addr
decl_stmt|;
comment|/* TLS local dynamic got entry handling.  */
union|union
block|{
name|bfd_signed_vma
name|refcount
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
block|}
name|tlsld_got
union|;
comment|/* Small local sym to section mapping cache.  */
name|struct
name|sym_sec_cache
name|sym_sec
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Get the PPC ELF linker hash table from a link_info structure.  */
end_comment

begin_define
define|#
directive|define
name|ppc_elf_hash_table
parameter_list|(
name|p
parameter_list|)
define|\
value|((struct ppc_elf_link_hash_table *) (p)->hash)
end_define

begin_comment
comment|/* Create an entry in a PPC ELF linker hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|ppc_elf_link_hash_newfunc
parameter_list|(
name|struct
name|bfd_hash_entry
modifier|*
name|entry
parameter_list|,
name|struct
name|bfd_hash_table
modifier|*
name|table
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
comment|/* Allocate the structure if it has not already been allocated by a      subclass.  */
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
name|entry
operator|=
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ppc_elf_link_hash_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
return|return
name|entry
return|;
block|}
comment|/* Call the allocation method of the superclass.  */
name|entry
operator|=
name|_bfd_elf_link_hash_newfunc
argument_list|(
name|entry
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|!=
name|NULL
condition|)
block|{
name|ppc_elf_hash_entry
argument_list|(
name|entry
argument_list|)
operator|->
name|linker_section_pointer
operator|=
name|NULL
expr_stmt|;
name|ppc_elf_hash_entry
argument_list|(
name|entry
argument_list|)
operator|->
name|dyn_relocs
operator|=
name|NULL
expr_stmt|;
name|ppc_elf_hash_entry
argument_list|(
name|entry
argument_list|)
operator|->
name|tls_mask
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|entry
return|;
block|}
end_function

begin_comment
comment|/* Create a PPC ELF linker hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_link_hash_table
modifier|*
name|ppc_elf_link_hash_table_create
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|struct
name|ppc_elf_link_hash_table
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
name|bfd_zmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ppc_elf_link_hash_table
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|_bfd_elf_link_hash_table_init
argument_list|(
operator|&
name|ret
operator|->
name|elf
argument_list|,
name|abfd
argument_list|,
name|ppc_elf_link_hash_newfunc
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
operator|&
name|ret
operator|->
name|elf
operator|.
name|root
return|;
block|}
end_function

begin_comment
comment|/* If ELIMINATE_COPY_RELOCS is non-zero, the linker will try to avoid    copying dynamic variables from a shared lib into an app's dynbss    section, and instead use a dynamic relocation to point into the    shared lib.  */
end_comment

begin_define
define|#
directive|define
name|ELIMINATE_COPY_RELOCS
value|1
end_define

begin_comment
comment|/* Copy the extra info we tack onto an elf_link_hash_entry.  */
end_comment

begin_function
specifier|static
name|void
name|ppc_elf_copy_indirect_symbol
parameter_list|(
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|dir
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|ind
parameter_list|)
block|{
name|struct
name|ppc_elf_link_hash_entry
modifier|*
name|edir
decl_stmt|,
modifier|*
name|eind
decl_stmt|;
name|edir
operator|=
operator|(
expr|struct
name|ppc_elf_link_hash_entry
operator|*
operator|)
name|dir
expr_stmt|;
name|eind
operator|=
operator|(
expr|struct
name|ppc_elf_link_hash_entry
operator|*
operator|)
name|ind
expr_stmt|;
if|if
condition|(
name|eind
operator|->
name|dyn_relocs
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|edir
operator|->
name|dyn_relocs
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ppc_elf_dyn_relocs
modifier|*
modifier|*
name|pp
decl_stmt|;
name|struct
name|ppc_elf_dyn_relocs
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|ind
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Add reloc counts against the weak sym to the strong sym 	     list.  Merge any entries against the same section.  */
for|for
control|(
name|pp
operator|=
operator|&
name|eind
operator|->
name|dyn_relocs
init|;
operator|(
name|p
operator|=
operator|*
name|pp
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
name|struct
name|ppc_elf_dyn_relocs
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|q
operator|=
name|edir
operator|->
name|dyn_relocs
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|next
control|)
if|if
condition|(
name|q
operator|->
name|sec
operator|==
name|p
operator|->
name|sec
condition|)
block|{
name|q
operator|->
name|pc_count
operator|+=
name|p
operator|->
name|pc_count
expr_stmt|;
name|q
operator|->
name|count
operator|+=
name|p
operator|->
name|count
expr_stmt|;
operator|*
name|pp
operator|=
name|p
operator|->
name|next
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
name|pp
operator|=
operator|&
name|p
operator|->
name|next
expr_stmt|;
block|}
operator|*
name|pp
operator|=
name|edir
operator|->
name|dyn_relocs
expr_stmt|;
block|}
name|edir
operator|->
name|dyn_relocs
operator|=
name|eind
operator|->
name|dyn_relocs
expr_stmt|;
name|eind
operator|->
name|dyn_relocs
operator|=
name|NULL
expr_stmt|;
block|}
name|edir
operator|->
name|tls_mask
operator||=
name|eind
operator|->
name|tls_mask
expr_stmt|;
if|if
condition|(
name|ELIMINATE_COPY_RELOCS
operator|&&
name|ind
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_indirect
operator|&&
operator|(
name|dir
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DYNAMIC_ADJUSTED
operator|)
operator|!=
literal|0
condition|)
comment|/* If called to transfer flags for a weakdef during processing        of elf_adjust_dynamic_symbol, don't copy ELF_LINK_NON_GOT_REF.        We clear it ourselves for ELIMINATE_COPY_RELOCS.  */
name|dir
operator|->
name|elf_link_hash_flags
operator||=
operator|(
name|ind
operator|->
name|elf_link_hash_flags
operator|&
operator|(
name|ELF_LINK_HASH_REF_DYNAMIC
operator||
name|ELF_LINK_HASH_REF_REGULAR
operator||
name|ELF_LINK_HASH_REF_REGULAR_NONWEAK
operator||
name|ELF_LINK_HASH_NEEDS_PLT
operator|)
operator|)
expr_stmt|;
else|else
name|_bfd_elf_link_hash_copy_indirect
argument_list|(
name|bed
argument_list|,
name|dir
argument_list|,
name|ind
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|reloc_howto_type
modifier|*
name|ppc_elf_howto_table
index|[
name|R_PPC_max
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|ppc_elf_howto_raw
index|[]
init|=
block|{
comment|/* This reloc does nothing.  */
name|HOWTO
argument_list|(
name|R_PPC_NONE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_NONE"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A standard 32 bit relocation.  */
name|HOWTO
argument_list|(
name|R_PPC_ADDR32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_ADDR32"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* An absolute 26 bit branch; the lower two bits must be zero.      FIXME: we don't check that, we just clear them.  */
name|HOWTO
argument_list|(
name|R_PPC_ADDR24
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|26
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_ADDR24"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffffc
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A standard 16 bit relocation.  */
name|HOWTO
argument_list|(
name|R_PPC_ADDR16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_ADDR16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 16 bit relocation without overflow.  */
name|HOWTO
argument_list|(
name|R_PPC_ADDR16_LO
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_ADDR16_LO"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The high order 16 bits of an address.  */
name|HOWTO
argument_list|(
name|R_PPC_ADDR16_HI
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_ADDR16_HI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The high order 16 bits of an address, plus 1 if the contents of      the low 16 bits, treated as a signed number, is negative.  */
name|HOWTO
argument_list|(
name|R_PPC_ADDR16_HA
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_addr16_ha_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_ADDR16_HA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* An absolute 16 bit branch; the lower two bits must be zero.      FIXME: we don't check that, we just clear them.  */
name|HOWTO
argument_list|(
name|R_PPC_ADDR14
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_ADDR14"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* An absolute 16 bit branch, for which bit 10 should be set to      indicate that the branch is expected to be taken.	The lower two      bits must be zero.  */
name|HOWTO
argument_list|(
name|R_PPC_ADDR14_BRTAKEN
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_ADDR14_BRTAKEN"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* An absolute 16 bit branch, for which bit 10 should be set to      indicate that the branch is not expected to be taken.  The lower      two bits must be zero.  */
name|HOWTO
argument_list|(
name|R_PPC_ADDR14_BRNTAKEN
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_ADDR14_BRNTAKEN"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A relative 26 bit branch; the lower two bits must be zero.  */
name|HOWTO
argument_list|(
name|R_PPC_REL24
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|26
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_REL24"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffffc
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A relative 16 bit branch; the lower two bits must be zero.  */
name|HOWTO
argument_list|(
name|R_PPC_REL14
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_REL14"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A relative 16 bit branch.  Bit 10 should be set to indicate that      the branch is expected to be taken.  The lower two bits must be      zero.  */
name|HOWTO
argument_list|(
name|R_PPC_REL14_BRTAKEN
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_REL14_BRTAKEN"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A relative 16 bit branch.  Bit 10 should be set to indicate that      the branch is not expected to be taken.  The lower two bits must      be zero.  */
name|HOWTO
argument_list|(
name|R_PPC_REL14_BRNTAKEN
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_REL14_BRNTAKEN"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC_ADDR16, but referring to the GOT table entry for the      symbol.  */
name|HOWTO
argument_list|(
name|R_PPC_GOT16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_GOT16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC_ADDR16_LO, but referring to the GOT table entry for      the symbol.  */
name|HOWTO
argument_list|(
name|R_PPC_GOT16_LO
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_GOT16_LO"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC_ADDR16_HI, but referring to the GOT table entry for      the symbol.  */
name|HOWTO
argument_list|(
name|R_PPC_GOT16_HI
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_GOT16_HI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC_ADDR16_HA, but referring to the GOT table entry for      the symbol.  */
name|HOWTO
argument_list|(
name|R_PPC_GOT16_HA
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_addr16_ha_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_GOT16_HA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC_REL24, but referring to the procedure linkage table      entry for the symbol.  */
name|HOWTO
argument_list|(
name|R_PPC_PLTREL24
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|26
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_PLTREL24"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffffc
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* This is used only by the dynamic linker.  The symbol should exist      both in the object being run and in some shared library.  The      dynamic linker copies the data addressed by the symbol from the      shared library into the object, because the object being      run has to have the data at some particular address.  */
name|HOWTO
argument_list|(
name|R_PPC_COPY
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_COPY"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC_ADDR32, but used when setting global offset table      entries.  */
name|HOWTO
argument_list|(
name|R_PPC_GLOB_DAT
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_GLOB_DAT"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Marks a procedure linkage table entry for a symbol.  */
name|HOWTO
argument_list|(
name|R_PPC_JMP_SLOT
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_JMP_SLOT"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used only by the dynamic linker.  When the object is run, this      longword is set to the load address of the object, plus the      addend.  */
name|HOWTO
argument_list|(
name|R_PPC_RELATIVE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_RELATIVE"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC_REL24, but uses the value of the symbol within the      object rather than the final value.  Normally used for      _GLOBAL_OFFSET_TABLE_.  */
name|HOWTO
argument_list|(
name|R_PPC_LOCAL24PC
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|26
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_LOCAL24PC"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffffc
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC_ADDR32, but may be unaligned.  */
name|HOWTO
argument_list|(
name|R_PPC_UADDR32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_UADDR32"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC_ADDR16, but may be unaligned.  */
name|HOWTO
argument_list|(
name|R_PPC_UADDR16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_UADDR16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 32-bit PC relative */
name|HOWTO
argument_list|(
name|R_PPC_REL32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_REL32"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 32-bit relocation to the symbol's procedure linkage table.      FIXME: not supported.  */
name|HOWTO
argument_list|(
name|R_PPC_PLT32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_PLT32"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 32-bit PC relative relocation to the symbol's procedure linkage table.      FIXME: not supported.  */
name|HOWTO
argument_list|(
name|R_PPC_PLTREL32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_PLTREL32"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC_ADDR16_LO, but referring to the PLT table entry for      the symbol.  */
name|HOWTO
argument_list|(
name|R_PPC_PLT16_LO
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_PLT16_LO"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC_ADDR16_HI, but referring to the PLT table entry for      the symbol.  */
name|HOWTO
argument_list|(
name|R_PPC_PLT16_HI
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_PLT16_HI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC_ADDR16_HA, but referring to the PLT table entry for      the symbol.  */
name|HOWTO
argument_list|(
name|R_PPC_PLT16_HA
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_addr16_ha_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_PLT16_HA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A sign-extended 16 bit value relative to _SDA_BASE_, for use with      small data items.  */
name|HOWTO
argument_list|(
name|R_PPC_SDAREL16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_SDAREL16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16-bit section relative relocation.  */
name|HOWTO
argument_list|(
name|R_PPC_SECTOFF
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_SECTOFF"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16-bit lower half section relative relocation.  */
name|HOWTO
argument_list|(
name|R_PPC_SECTOFF_LO
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_SECTOFF_LO"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16-bit upper half section relative relocation.  */
name|HOWTO
argument_list|(
name|R_PPC_SECTOFF_HI
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_SECTOFF_HI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16-bit upper half adjusted section relative relocation.  */
name|HOWTO
argument_list|(
name|R_PPC_SECTOFF_HA
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_addr16_ha_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_SECTOFF_HA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Marker reloc for TLS.  */
name|HOWTO
argument_list|(
name|R_PPC_TLS
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_TLS"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Computes the load module index of the load module that contains the      definition of its TLS sym.  */
name|HOWTO
argument_list|(
name|R_PPC_DTPMOD32
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_DTPMOD32"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Computes a dtv-relative displacement, the difference between the value      of sym+add and the base address of the thread-local storage block that      contains the definition of sym, minus 0x8000.  */
name|HOWTO
argument_list|(
name|R_PPC_DTPREL32
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_DTPREL32"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 16 bit dtprel reloc.  */
name|HOWTO
argument_list|(
name|R_PPC_DTPREL16
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_DTPREL16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like DTPREL16, but no overflow.  */
name|HOWTO
argument_list|(
name|R_PPC_DTPREL16_LO
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_DTPREL16_LO"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like DTPREL16_LO, but next higher group of 16 bits.  */
name|HOWTO
argument_list|(
name|R_PPC_DTPREL16_HI
argument_list|,
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_DTPREL16_HI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like DTPREL16_HI, but adjust for low 16 bits.  */
name|HOWTO
argument_list|(
name|R_PPC_DTPREL16_HA
argument_list|,
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_DTPREL16_HA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Computes a tp-relative displacement, the difference between the value of      sym+add and the value of the thread pointer (r13).  */
name|HOWTO
argument_list|(
name|R_PPC_TPREL32
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_TPREL32"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 16 bit tprel reloc.  */
name|HOWTO
argument_list|(
name|R_PPC_TPREL16
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_TPREL16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like TPREL16, but no overflow.  */
name|HOWTO
argument_list|(
name|R_PPC_TPREL16_LO
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_TPREL16_LO"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like TPREL16_LO, but next higher group of 16 bits.  */
name|HOWTO
argument_list|(
name|R_PPC_TPREL16_HI
argument_list|,
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_TPREL16_HI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like TPREL16_HI, but adjust for low 16 bits.  */
name|HOWTO
argument_list|(
name|R_PPC_TPREL16_HA
argument_list|,
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_TPREL16_HA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Allocates two contiguous entries in the GOT to hold a tls_index structure,      with values (sym+add)@dtpmod and (sym+add)@dtprel, and computes the offset      to the first entry.  */
name|HOWTO
argument_list|(
name|R_PPC_GOT_TLSGD16
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_GOT_TLSGD16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like GOT_TLSGD16, but no overflow.  */
name|HOWTO
argument_list|(
name|R_PPC_GOT_TLSGD16_LO
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_GOT_TLSGD16_LO"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like GOT_TLSGD16_LO, but next higher group of 16 bits.  */
name|HOWTO
argument_list|(
name|R_PPC_GOT_TLSGD16_HI
argument_list|,
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_GOT_TLSGD16_HI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like GOT_TLSGD16_HI, but adjust for low 16 bits.  */
name|HOWTO
argument_list|(
name|R_PPC_GOT_TLSGD16_HA
argument_list|,
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_GOT_TLSGD16_HA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Allocates two contiguous entries in the GOT to hold a tls_index structure,      with values (sym+add)@dtpmod and zero, and computes the offset to the      first entry.  */
name|HOWTO
argument_list|(
name|R_PPC_GOT_TLSLD16
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_GOT_TLSLD16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like GOT_TLSLD16, but no overflow.  */
name|HOWTO
argument_list|(
name|R_PPC_GOT_TLSLD16_LO
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_GOT_TLSLD16_LO"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like GOT_TLSLD16_LO, but next higher group of 16 bits.  */
name|HOWTO
argument_list|(
name|R_PPC_GOT_TLSLD16_HI
argument_list|,
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_GOT_TLSLD16_HI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like GOT_TLSLD16_HI, but adjust for low 16 bits.  */
name|HOWTO
argument_list|(
name|R_PPC_GOT_TLSLD16_HA
argument_list|,
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_GOT_TLSLD16_HA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Allocates an entry in the GOT with value (sym+add)@dtprel, and computes      the offset to the entry.  */
name|HOWTO
argument_list|(
name|R_PPC_GOT_DTPREL16
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_GOT_DTPREL16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like GOT_DTPREL16, but no overflow.  */
name|HOWTO
argument_list|(
name|R_PPC_GOT_DTPREL16_LO
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_GOT_DTPREL16_LO"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like GOT_DTPREL16_LO, but next higher group of 16 bits.  */
name|HOWTO
argument_list|(
name|R_PPC_GOT_DTPREL16_HI
argument_list|,
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_GOT_DTPREL16_HI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like GOT_DTPREL16_HI, but adjust for low 16 bits.  */
name|HOWTO
argument_list|(
name|R_PPC_GOT_DTPREL16_HA
argument_list|,
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_GOT_DTPREL16_HA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Allocates an entry in the GOT with value (sym+add)@tprel, and computes the      offset to the entry.  */
name|HOWTO
argument_list|(
name|R_PPC_GOT_TPREL16
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_GOT_TPREL16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like GOT_TPREL16, but no overflow.  */
name|HOWTO
argument_list|(
name|R_PPC_GOT_TPREL16_LO
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_GOT_TPREL16_LO"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like GOT_TPREL16_LO, but next higher group of 16 bits.  */
name|HOWTO
argument_list|(
name|R_PPC_GOT_TPREL16_HI
argument_list|,
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_GOT_TPREL16_HI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like GOT_TPREL16_HI, but adjust for low 16 bits.  */
name|HOWTO
argument_list|(
name|R_PPC_GOT_TPREL16_HA
argument_list|,
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_GOT_TPREL16_HA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The remaining relocs are from the Embedded ELF ABI, and are not      in the SVR4 ELF ABI.  */
comment|/* 32 bit value resulting from the addend minus the symbol.  */
name|HOWTO
argument_list|(
name|R_PPC_EMB_NADDR32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_EMB_NADDR32"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16 bit value resulting from the addend minus the symbol.  */
name|HOWTO
argument_list|(
name|R_PPC_EMB_NADDR16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_EMB_NADDR16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16 bit value resulting from the addend minus the symbol.  */
name|HOWTO
argument_list|(
name|R_PPC_EMB_NADDR16_LO
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_EMB_ADDR16_LO"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The high order 16 bits of the addend minus the symbol.  */
name|HOWTO
argument_list|(
name|R_PPC_EMB_NADDR16_HI
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_EMB_NADDR16_HI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The high order 16 bits of the result of the addend minus the address,      plus 1 if the contents of the low 16 bits, treated as a signed number,      is negative.  */
name|HOWTO
argument_list|(
name|R_PPC_EMB_NADDR16_HA
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_addr16_ha_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_EMB_NADDR16_HA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16 bit value resulting from allocating a 4 byte word to hold an      address in the .sdata section, and returning the offset from      _SDA_BASE_ for that relocation.  */
name|HOWTO
argument_list|(
name|R_PPC_EMB_SDAI16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_EMB_SDAI16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16 bit value resulting from allocating a 4 byte word to hold an      address in the .sdata2 section, and returning the offset from      _SDA2_BASE_ for that relocation.  */
name|HOWTO
argument_list|(
name|R_PPC_EMB_SDA2I16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_EMB_SDA2I16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A sign-extended 16 bit value relative to _SDA2_BASE_, for use with      small data items.	 */
name|HOWTO
argument_list|(
name|R_PPC_EMB_SDA2REL
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_EMB_SDA2REL"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Relocate against either _SDA_BASE_ or _SDA2_BASE_, filling in the 16 bit      signed offset from the appropriate base, and filling in the register      field with the appropriate register (0, 2, or 13).  */
name|HOWTO
argument_list|(
name|R_PPC_EMB_SDA21
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_EMB_SDA21"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Relocation not handled: R_PPC_EMB_MRKREF */
comment|/* Relocation not handled: R_PPC_EMB_RELSEC16 */
comment|/* Relocation not handled: R_PPC_EMB_RELST_LO */
comment|/* Relocation not handled: R_PPC_EMB_RELST_HI */
comment|/* Relocation not handled: R_PPC_EMB_RELST_HA */
comment|/* Relocation not handled: R_PPC_EMB_BIT_FLD */
comment|/* PC relative relocation against either _SDA_BASE_ or _SDA2_BASE_, filling      in the 16 bit signed offset from the appropriate base, and filling in the      register field with the appropriate register (0, 2, or 13).  */
name|HOWTO
argument_list|(
name|R_PPC_EMB_RELSDA
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_EMB_RELSDA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Phony relocs to handle branch stubs.  */
name|HOWTO
argument_list|(
name|R_PPC_RELAX32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size */
literal|0
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_RELAX32"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_PPC_RELAX32PC
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size */
literal|0
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_RELAX32PC"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* GNU extension to record C++ vtable hierarchy.  */
name|HOWTO
argument_list|(
name|R_PPC_GNU_VTINHERIT
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|NULL
argument_list|,
comment|/* special_function */
literal|"R_PPC_GNU_VTINHERIT"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* GNU extension to record C++ vtable member usage.  */
name|HOWTO
argument_list|(
name|R_PPC_GNU_VTENTRY
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|NULL
argument_list|,
comment|/* special_function */
literal|"R_PPC_GNU_VTENTRY"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Phony reloc to handle AIX style TOC entries.  */
name|HOWTO
argument_list|(
name|R_PPC_TOC16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_TOC16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Initialize the ppc_elf_howto_table, so that linear accesses can be done.  */
end_comment

begin_function
specifier|static
name|void
name|ppc_elf_howto_init
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|type
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|ppc_elf_howto_raw
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|ppc_elf_howto_raw
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|type
operator|=
name|ppc_elf_howto_raw
index|[
name|i
index|]
operator|.
name|type
expr_stmt|;
if|if
condition|(
name|type
operator|>=
operator|(
sizeof|sizeof
argument_list|(
name|ppc_elf_howto_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|ppc_elf_howto_table
index|[
literal|0
index|]
argument_list|)
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|ppc_elf_howto_table
index|[
name|type
index|]
operator|=
operator|&
name|ppc_elf_howto_raw
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|ARRAY_SIZE
parameter_list|(
name|a
parameter_list|)
value|(sizeof (a) / sizeof ((a)[0]))
end_define

begin_decl_stmt
specifier|static
specifier|const
name|int
name|shared_stub_entry
index|[]
init|=
block|{
literal|0x7c0802a6
block|,
comment|/* mflr 0 */
literal|0x429f0005
block|,
comment|/* bcl 20, 31, .Lxxx */
literal|0x7d6802a6
block|,
comment|/* mflr 11 */
literal|0x3d6b0000
block|,
comment|/* addis 11, 11, (xxx-.Lxxx)@ha */
literal|0x396b0018
block|,
comment|/* addi 11, 11, (xxx-.Lxxx)@l */
literal|0x7c0803a6
block|,
comment|/* mtlr 0 */
literal|0x7d6903a6
block|,
comment|/* mtctr 11 */
literal|0x4e800420
block|,
comment|/* bctr */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|int
name|stub_entry
index|[]
init|=
block|{
literal|0x3d600000
block|,
comment|/* lis 11,xxx@ha */
literal|0x396b0000
block|,
comment|/* addi 11,11,xxx@l */
literal|0x7d6903a6
block|,
comment|/* mtctr 11 */
literal|0x4e800420
block|,
comment|/* bctr */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|bfd_boolean
name|ppc_elf_relax_section
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|isec
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
parameter_list|,
name|bfd_boolean
modifier|*
name|again
parameter_list|)
block|{
struct|struct
name|one_fixup
block|{
name|struct
name|one_fixup
modifier|*
name|next
decl_stmt|;
name|asection
modifier|*
name|tsec
decl_stmt|;
name|bfd_vma
name|toff
decl_stmt|;
name|bfd_vma
name|trampoff
decl_stmt|;
block|}
struct|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymbuf
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|,
modifier|*
name|irelend
decl_stmt|;
name|struct
name|one_fixup
modifier|*
name|fixups
init|=
name|NULL
decl_stmt|;
name|bfd_boolean
name|changed
decl_stmt|;
name|struct
name|ppc_elf_link_hash_table
modifier|*
name|ppc_info
decl_stmt|;
name|bfd_size_type
name|trampoff
decl_stmt|;
operator|*
name|again
operator|=
name|FALSE
expr_stmt|;
comment|/* Nothing to do if there are no relocations.  */
if|if
condition|(
operator|(
name|isec
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
operator|||
name|isec
operator|->
name|reloc_count
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
comment|/* If needed, initialize this section's cooked size.  */
if|if
condition|(
name|isec
operator|->
name|_cooked_size
operator|==
literal|0
condition|)
name|isec
operator|->
name|_cooked_size
operator|=
name|isec
operator|->
name|_raw_size
expr_stmt|;
name|trampoff
operator|=
operator|(
name|isec
operator|->
name|_cooked_size
operator|+
literal|3
operator|)
operator|&
operator|(
name|bfd_vma
operator|)
operator|-
literal|4
expr_stmt|;
comment|/* Space for a branch around any trampolines.  */
name|trampoff
operator|+=
literal|4
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
comment|/* Get a copy of the native relocations.  */
name|internal_relocs
operator|=
name|_bfd_elf_link_read_relocs
argument_list|(
name|abfd
argument_list|,
name|isec
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|link_info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|ppc_info
operator|=
name|ppc_elf_hash_table
argument_list|(
name|link_info
argument_list|)
expr_stmt|;
name|irelend
operator|=
name|internal_relocs
operator|+
name|isec
operator|->
name|reloc_count
expr_stmt|;
comment|/* Get the section contents.  */
comment|/* Get cached copy if it exists.  */
if|if
condition|(
name|elf_section_data
argument_list|(
name|isec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|NULL
condition|)
name|contents
operator|=
name|elf_section_data
argument_list|(
name|isec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
expr_stmt|;
else|else
block|{
comment|/* Go get them off disk.  */
name|contents
operator|=
name|bfd_malloc
argument_list|(
name|isec
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|isec
argument_list|,
name|contents
argument_list|,
literal|0
argument_list|,
name|isec
operator|->
name|_raw_size
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
for|for
control|(
name|irel
operator|=
name|internal_relocs
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
control|)
block|{
name|unsigned
name|long
name|r_type
init|=
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
decl_stmt|;
name|bfd_vma
name|symaddr
decl_stmt|,
name|reladdr
decl_stmt|,
name|toff
decl_stmt|,
name|roff
decl_stmt|;
name|asection
modifier|*
name|tsec
decl_stmt|;
name|struct
name|one_fixup
modifier|*
name|f
decl_stmt|;
name|size_t
name|insn_offset
init|=
literal|0
decl_stmt|;
name|bfd_vma
name|max_branch_offset
decl_stmt|,
name|val
decl_stmt|;
name|bfd_byte
modifier|*
name|hit_addr
decl_stmt|;
name|unsigned
name|long
name|t0
decl_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_PPC_REL24
case|:
case|case
name|R_PPC_LOCAL24PC
case|:
case|case
name|R_PPC_PLTREL24
case|:
name|max_branch_offset
operator|=
literal|1
operator|<<
literal|25
expr_stmt|;
break|break;
case|case
name|R_PPC_REL14
case|:
case|case
name|R_PPC_REL14_BRTAKEN
case|:
case|case
name|R_PPC_REL14_BRNTAKEN
case|:
name|max_branch_offset
operator|=
literal|1
operator|<<
literal|15
expr_stmt|;
break|break;
default|default:
continue|continue;
block|}
comment|/* Get the value of the symbol referred to by the reloc.  */
if|if
condition|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
comment|/* A local symbol.  */
name|Elf_Internal_Sym
modifier|*
name|isym
decl_stmt|;
comment|/* Read this BFD's local symbols.  */
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
block|{
name|isymbuf
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
name|isymbuf
operator|=
name|bfd_elf_get_elf_syms
argument_list|(
name|abfd
argument_list|,
name|symtab_hdr
argument_list|,
name|symtab_hdr
operator|->
name|sh_info
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
literal|0
condition|)
goto|goto
name|error_return
goto|;
block|}
name|isym
operator|=
name|isymbuf
operator|+
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_UNDEF
condition|)
continue|continue;
comment|/* We can't do anything with undefined symbols.  */
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_ABS
condition|)
name|tsec
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_COMMON
condition|)
name|tsec
operator|=
name|bfd_com_section_ptr
expr_stmt|;
else|else
name|tsec
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|abfd
argument_list|,
name|isym
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
name|toff
operator|=
name|isym
operator|->
name|st_value
expr_stmt|;
block|}
else|else
block|{
comment|/* Global symbol handling.  */
name|unsigned
name|long
name|indx
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|indx
operator|=
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|-
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|h
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
index|[
name|indx
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_PPC_PLTREL24
operator|&&
name|ppc_info
operator|->
name|plt
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|plt
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
name|tsec
operator|=
name|ppc_info
operator|->
name|plt
expr_stmt|;
name|toff
operator|=
name|h
operator|->
name|plt
operator|.
name|offset
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
block|{
name|tsec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|toff
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
block|}
else|else
continue|continue;
block|}
comment|/* If the branch and target are in the same section, you have 	 no hope of adding stubs.  We'll error out later should the 	 branch overflow.  */
if|if
condition|(
name|tsec
operator|==
name|isec
condition|)
continue|continue;
name|toff
operator|+=
name|irel
operator|->
name|r_addend
expr_stmt|;
if|if
condition|(
name|tsec
operator|->
name|sec_info_type
operator|==
name|ELF_INFO_TYPE_MERGE
condition|)
name|toff
operator|=
name|_bfd_merged_section_offset
argument_list|(
name|abfd
argument_list|,
operator|&
name|tsec
argument_list|,
name|elf_section_data
argument_list|(
name|tsec
argument_list|)
operator|->
name|sec_info
argument_list|,
name|toff
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|symaddr
operator|=
name|tsec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|tsec
operator|->
name|output_offset
operator|+
name|toff
expr_stmt|;
name|roff
operator|=
name|irel
operator|->
name|r_offset
expr_stmt|;
name|reladdr
operator|=
name|isec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|isec
operator|->
name|output_offset
operator|+
name|roff
expr_stmt|;
comment|/* If the branch is in range, no need to do anything.  */
if|if
condition|(
name|symaddr
operator|-
name|reladdr
operator|+
name|max_branch_offset
operator|<
literal|2
operator|*
name|max_branch_offset
condition|)
continue|continue;
comment|/* Look for an existing fixup to this address.  */
for|for
control|(
name|f
operator|=
name|fixups
init|;
name|f
condition|;
name|f
operator|=
name|f
operator|->
name|next
control|)
if|if
condition|(
name|f
operator|->
name|tsec
operator|==
name|tsec
operator|&&
name|f
operator|->
name|toff
operator|==
name|toff
condition|)
break|break;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|size_t
name|size
decl_stmt|;
name|unsigned
name|long
name|stub_rtype
decl_stmt|;
name|val
operator|=
name|trampoff
operator|-
name|roff
expr_stmt|;
if|if
condition|(
name|val
operator|>=
name|max_branch_offset
condition|)
comment|/* Oh dear, we can't reach a trampoline.  Don't try to add 	       one.  We'll report an error later.  */
continue|continue;
if|if
condition|(
name|link_info
operator|->
name|shared
condition|)
block|{
name|size
operator|=
literal|4
operator|*
name|ARRAY_SIZE
argument_list|(
name|shared_stub_entry
argument_list|)
expr_stmt|;
name|insn_offset
operator|=
literal|12
expr_stmt|;
name|stub_rtype
operator|=
name|R_PPC_RELAX32PC
expr_stmt|;
block|}
else|else
block|{
name|size
operator|=
literal|4
operator|*
name|ARRAY_SIZE
argument_list|(
name|stub_entry
argument_list|)
expr_stmt|;
name|insn_offset
operator|=
literal|0
expr_stmt|;
name|stub_rtype
operator|=
name|R_PPC_RELAX32
expr_stmt|;
block|}
comment|/* Hijack the old relocation.  Since we need two 	     relocations for this use a "composite" reloc.  */
name|irel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
name|stub_rtype
argument_list|)
expr_stmt|;
name|irel
operator|->
name|r_offset
operator|=
name|trampoff
operator|+
name|insn_offset
expr_stmt|;
comment|/* Record the fixup so we don't do it again this section.  */
name|f
operator|=
name|bfd_malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|f
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|->
name|next
operator|=
name|fixups
expr_stmt|;
name|f
operator|->
name|tsec
operator|=
name|tsec
expr_stmt|;
name|f
operator|->
name|toff
operator|=
name|toff
expr_stmt|;
name|f
operator|->
name|trampoff
operator|=
name|trampoff
expr_stmt|;
name|fixups
operator|=
name|f
expr_stmt|;
name|trampoff
operator|+=
name|size
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
name|f
operator|->
name|trampoff
operator|-
name|roff
expr_stmt|;
if|if
condition|(
name|val
operator|>=
name|max_branch_offset
condition|)
continue|continue;
comment|/* Nop out the reloc, since we're finalizing things here.  */
name|irel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_PPC_NONE
argument_list|)
expr_stmt|;
block|}
comment|/* Fix up the existing branch to hit the trampoline.  */
name|hit_addr
operator|=
name|contents
operator|+
name|roff
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_PPC_REL24
case|:
case|case
name|R_PPC_LOCAL24PC
case|:
case|case
name|R_PPC_PLTREL24
case|:
name|t0
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|hit_addr
argument_list|)
expr_stmt|;
name|t0
operator|&=
operator|~
literal|0x3fffffc
expr_stmt|;
name|t0
operator||=
name|val
operator|&
literal|0x3fffffc
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|t0
argument_list|,
name|hit_addr
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_PPC_REL14
case|:
case|case
name|R_PPC_REL14_BRTAKEN
case|:
case|case
name|R_PPC_REL14_BRNTAKEN
case|:
name|t0
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|hit_addr
argument_list|)
expr_stmt|;
name|t0
operator|&=
operator|~
literal|0xfffc
expr_stmt|;
name|t0
operator||=
name|val
operator|&
literal|0xfffc
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|t0
argument_list|,
name|hit_addr
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Write out the trampolines.  */
name|changed
operator|=
name|fixups
operator|!=
name|NULL
expr_stmt|;
if|if
condition|(
name|fixups
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|int
modifier|*
name|stub
decl_stmt|;
name|bfd_byte
modifier|*
name|dest
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
name|int
name|i
decl_stmt|,
name|size
decl_stmt|;
do|do
block|{
name|struct
name|one_fixup
modifier|*
name|f
init|=
name|fixups
decl_stmt|;
name|fixups
operator|=
name|fixups
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|fixups
condition|)
do|;
name|contents
operator|=
name|bfd_realloc
argument_list|(
name|contents
argument_list|,
name|trampoff
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|isec
operator|->
name|_cooked_size
operator|=
operator|(
name|isec
operator|->
name|_cooked_size
operator|+
literal|3
operator|)
operator|&
operator|(
name|bfd_vma
operator|)
operator|-
literal|4
expr_stmt|;
comment|/* Branch around the trampolines.  */
name|val
operator|=
name|trampoff
operator|-
name|isec
operator|->
name|_cooked_size
operator|+
literal|0x48000000
expr_stmt|;
name|dest
operator|=
name|contents
operator|+
name|isec
operator|->
name|_cooked_size
expr_stmt|;
name|isec
operator|->
name|_cooked_size
operator|=
name|trampoff
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|val
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|dest
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|link_info
operator|->
name|shared
condition|)
block|{
name|stub
operator|=
name|shared_stub_entry
expr_stmt|;
name|size
operator|=
name|ARRAY_SIZE
argument_list|(
name|shared_stub_entry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|stub
operator|=
name|stub_entry
expr_stmt|;
name|size
operator|=
name|ARRAY_SIZE
argument_list|(
name|stub_entry
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|dest
operator|<
name|contents
operator|+
name|trampoff
condition|)
block|{
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|stub
index|[
name|i
index|]
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|size
condition|)
name|i
operator|=
literal|0
expr_stmt|;
name|dest
operator|+=
literal|4
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
name|i
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isymbuf
operator|!=
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
condition|)
block|{
if|if
condition|(
operator|!
name|link_info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|isymbuf
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Cache the symbols for elf_link_input_bfd.  */
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
expr_stmt|;
block|}
block|}
if|if
condition|(
name|contents
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|isec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|contents
condition|)
block|{
if|if
condition|(
operator|!
name|changed
operator|&&
operator|!
name|link_info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Cache the section contents for elf_link_input_bfd.  */
name|elf_section_data
argument_list|(
name|isec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
block|}
block|}
if|if
condition|(
name|elf_section_data
argument_list|(
name|isec
argument_list|)
operator|->
name|relocs
operator|!=
name|internal_relocs
condition|)
block|{
if|if
condition|(
operator|!
name|changed
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
else|else
name|elf_section_data
argument_list|(
name|isec
argument_list|)
operator|->
name|relocs
operator|=
name|internal_relocs
expr_stmt|;
block|}
operator|*
name|again
operator|=
name|changed
expr_stmt|;
return|return
name|TRUE
return|;
name|error_return
label|:
if|if
condition|(
name|isymbuf
operator|!=
name|NULL
operator|&&
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
operator|!=
name|symtab_hdr
operator|->
name|contents
condition|)
name|free
argument_list|(
name|isymbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|isec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|contents
condition|)
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|isec
argument_list|)
operator|->
name|relocs
operator|!=
name|internal_relocs
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|ppc_elf_reloc_type_lookup
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd_reloc_code_real_type
name|code
parameter_list|)
block|{
name|enum
name|elf_ppc_reloc_type
name|r
decl_stmt|;
comment|/* Initialize howto table if not already done.  */
if|if
condition|(
operator|!
name|ppc_elf_howto_table
index|[
name|R_PPC_ADDR32
index|]
condition|)
name|ppc_elf_howto_init
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
default|default:
return|return
name|NULL
return|;
case|case
name|BFD_RELOC_NONE
case|:
name|r
operator|=
name|R_PPC_NONE
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32
case|:
name|r
operator|=
name|R_PPC_ADDR32
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_BA26
case|:
name|r
operator|=
name|R_PPC_ADDR24
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_16
case|:
name|r
operator|=
name|R_PPC_ADDR16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_LO16
case|:
name|r
operator|=
name|R_PPC_ADDR16_LO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16
case|:
name|r
operator|=
name|R_PPC_ADDR16_HI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16_S
case|:
name|r
operator|=
name|R_PPC_ADDR16_HA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_BA16
case|:
name|r
operator|=
name|R_PPC_ADDR14
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_BA16_BRTAKEN
case|:
name|r
operator|=
name|R_PPC_ADDR14_BRTAKEN
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_BA16_BRNTAKEN
case|:
name|r
operator|=
name|R_PPC_ADDR14_BRNTAKEN
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_B26
case|:
name|r
operator|=
name|R_PPC_REL24
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_B16
case|:
name|r
operator|=
name|R_PPC_REL14
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_B16_BRTAKEN
case|:
name|r
operator|=
name|R_PPC_REL14_BRTAKEN
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_B16_BRNTAKEN
case|:
name|r
operator|=
name|R_PPC_REL14_BRNTAKEN
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_16_GOTOFF
case|:
name|r
operator|=
name|R_PPC_GOT16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_LO16_GOTOFF
case|:
name|r
operator|=
name|R_PPC_GOT16_LO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16_GOTOFF
case|:
name|r
operator|=
name|R_PPC_GOT16_HI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16_S_GOTOFF
case|:
name|r
operator|=
name|R_PPC_GOT16_HA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_24_PLT_PCREL
case|:
name|r
operator|=
name|R_PPC_PLTREL24
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_COPY
case|:
name|r
operator|=
name|R_PPC_COPY
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GLOB_DAT
case|:
name|r
operator|=
name|R_PPC_GLOB_DAT
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_LOCAL24PC
case|:
name|r
operator|=
name|R_PPC_LOCAL24PC
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32_PCREL
case|:
name|r
operator|=
name|R_PPC_REL32
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32_PLTOFF
case|:
name|r
operator|=
name|R_PPC_PLT32
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32_PLT_PCREL
case|:
name|r
operator|=
name|R_PPC_PLTREL32
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_LO16_PLTOFF
case|:
name|r
operator|=
name|R_PPC_PLT16_LO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16_PLTOFF
case|:
name|r
operator|=
name|R_PPC_PLT16_HI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16_S_PLTOFF
case|:
name|r
operator|=
name|R_PPC_PLT16_HA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_GPREL16
case|:
name|r
operator|=
name|R_PPC_SDAREL16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_16_BASEREL
case|:
name|r
operator|=
name|R_PPC_SECTOFF
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_LO16_BASEREL
case|:
name|r
operator|=
name|R_PPC_SECTOFF_LO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16_BASEREL
case|:
name|r
operator|=
name|R_PPC_SECTOFF_HI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16_S_BASEREL
case|:
name|r
operator|=
name|R_PPC_SECTOFF_HA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_CTOR
case|:
name|r
operator|=
name|R_PPC_ADDR32
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_TOC16
case|:
name|r
operator|=
name|R_PPC_TOC16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_TLS
case|:
name|r
operator|=
name|R_PPC_TLS
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_DTPMOD
case|:
name|r
operator|=
name|R_PPC_DTPMOD32
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_TPREL16
case|:
name|r
operator|=
name|R_PPC_TPREL16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_TPREL16_LO
case|:
name|r
operator|=
name|R_PPC_TPREL16_LO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_TPREL16_HI
case|:
name|r
operator|=
name|R_PPC_TPREL16_HI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_TPREL16_HA
case|:
name|r
operator|=
name|R_PPC_TPREL16_HA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_TPREL
case|:
name|r
operator|=
name|R_PPC_TPREL32
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_DTPREL16
case|:
name|r
operator|=
name|R_PPC_DTPREL16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_DTPREL16_LO
case|:
name|r
operator|=
name|R_PPC_DTPREL16_LO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_DTPREL16_HI
case|:
name|r
operator|=
name|R_PPC_DTPREL16_HI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_DTPREL16_HA
case|:
name|r
operator|=
name|R_PPC_DTPREL16_HA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_DTPREL
case|:
name|r
operator|=
name|R_PPC_DTPREL32
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GOT_TLSGD16
case|:
name|r
operator|=
name|R_PPC_GOT_TLSGD16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GOT_TLSGD16_LO
case|:
name|r
operator|=
name|R_PPC_GOT_TLSGD16_LO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GOT_TLSGD16_HI
case|:
name|r
operator|=
name|R_PPC_GOT_TLSGD16_HI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GOT_TLSGD16_HA
case|:
name|r
operator|=
name|R_PPC_GOT_TLSGD16_HA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GOT_TLSLD16
case|:
name|r
operator|=
name|R_PPC_GOT_TLSLD16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GOT_TLSLD16_LO
case|:
name|r
operator|=
name|R_PPC_GOT_TLSLD16_LO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GOT_TLSLD16_HI
case|:
name|r
operator|=
name|R_PPC_GOT_TLSLD16_HI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GOT_TLSLD16_HA
case|:
name|r
operator|=
name|R_PPC_GOT_TLSLD16_HA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GOT_TPREL16
case|:
name|r
operator|=
name|R_PPC_GOT_TPREL16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GOT_TPREL16_LO
case|:
name|r
operator|=
name|R_PPC_GOT_TPREL16_LO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GOT_TPREL16_HI
case|:
name|r
operator|=
name|R_PPC_GOT_TPREL16_HI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GOT_TPREL16_HA
case|:
name|r
operator|=
name|R_PPC_GOT_TPREL16_HA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GOT_DTPREL16
case|:
name|r
operator|=
name|R_PPC_GOT_DTPREL16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GOT_DTPREL16_LO
case|:
name|r
operator|=
name|R_PPC_GOT_DTPREL16_LO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GOT_DTPREL16_HI
case|:
name|r
operator|=
name|R_PPC_GOT_DTPREL16_HI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GOT_DTPREL16_HA
case|:
name|r
operator|=
name|R_PPC_GOT_DTPREL16_HA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_EMB_NADDR32
case|:
name|r
operator|=
name|R_PPC_EMB_NADDR32
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_EMB_NADDR16
case|:
name|r
operator|=
name|R_PPC_EMB_NADDR16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_EMB_NADDR16_LO
case|:
name|r
operator|=
name|R_PPC_EMB_NADDR16_LO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_EMB_NADDR16_HI
case|:
name|r
operator|=
name|R_PPC_EMB_NADDR16_HI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_EMB_NADDR16_HA
case|:
name|r
operator|=
name|R_PPC_EMB_NADDR16_HA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_EMB_SDAI16
case|:
name|r
operator|=
name|R_PPC_EMB_SDAI16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_EMB_SDA2I16
case|:
name|r
operator|=
name|R_PPC_EMB_SDA2I16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_EMB_SDA2REL
case|:
name|r
operator|=
name|R_PPC_EMB_SDA2REL
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_EMB_SDA21
case|:
name|r
operator|=
name|R_PPC_EMB_SDA21
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_EMB_MRKREF
case|:
name|r
operator|=
name|R_PPC_EMB_MRKREF
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_EMB_RELSEC16
case|:
name|r
operator|=
name|R_PPC_EMB_RELSEC16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_EMB_RELST_LO
case|:
name|r
operator|=
name|R_PPC_EMB_RELST_LO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_EMB_RELST_HI
case|:
name|r
operator|=
name|R_PPC_EMB_RELST_HI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_EMB_RELST_HA
case|:
name|r
operator|=
name|R_PPC_EMB_RELST_HA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_EMB_BIT_FLD
case|:
name|r
operator|=
name|R_PPC_EMB_BIT_FLD
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_EMB_RELSDA
case|:
name|r
operator|=
name|R_PPC_EMB_RELSDA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_VTABLE_INHERIT
case|:
name|r
operator|=
name|R_PPC_GNU_VTINHERIT
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_VTABLE_ENTRY
case|:
name|r
operator|=
name|R_PPC_GNU_VTENTRY
expr_stmt|;
break|break;
block|}
return|return
name|ppc_elf_howto_table
index|[
name|r
index|]
return|;
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* Set the howto pointer for a PowerPC ELF reloc.  */
end_comment

begin_function
specifier|static
name|void
name|ppc_elf_info_to_howto
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|arelent
modifier|*
name|cache_ptr
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|dst
parameter_list|)
block|{
comment|/* Initialize howto table if not already done.  */
if|if
condition|(
operator|!
name|ppc_elf_howto_table
index|[
name|R_PPC_ADDR32
index|]
condition|)
name|ppc_elf_howto_init
argument_list|()
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|ELF32_R_TYPE
argument_list|(
name|dst
operator|->
name|r_info
argument_list|)
operator|<
operator|(
name|unsigned
name|int
operator|)
name|R_PPC_max
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|howto
operator|=
name|ppc_elf_howto_table
index|[
name|ELF32_R_TYPE
argument_list|(
name|dst
operator|->
name|r_info
argument_list|)
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the R_PPC_ADDR16_HA reloc.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|ppc_elf_addr16_ha_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|bfd_vma
name|relocation
decl_stmt|;
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
condition|)
block|{
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
if|if
condition|(
name|reloc_entry
operator|->
name|address
operator|>
name|input_section
operator|->
name|_cooked_size
condition|)
return|return
name|bfd_reloc_outofrange
return|;
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
else|else
name|relocation
operator|=
name|symbol
operator|->
name|value
expr_stmt|;
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
name|relocation
operator|+=
name|reloc_entry
operator|->
name|addend
expr_stmt|;
name|reloc_entry
operator|->
name|addend
operator|+=
operator|(
name|relocation
operator|&
literal|0x8000
operator|)
operator|<<
literal|1
expr_stmt|;
return|return
name|bfd_reloc_continue
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_status_type
name|ppc_elf_unhandled_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
parameter_list|)
block|{
comment|/* If this is a relocatable link (output_bfd test tells us), just      call the generic function.  Any adjustment will be done at final      link time.  */
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
condition|)
return|return
name|bfd_elf_generic_reloc
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
argument_list|,
name|symbol
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
name|error_message
argument_list|)
return|;
if|if
condition|(
name|error_message
operator|!=
name|NULL
condition|)
block|{
specifier|static
name|char
name|buf
index|[
literal|60
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
name|_
argument_list|(
literal|"generic linker can't handle %s"
argument_list|)
argument_list|,
name|reloc_entry
operator|->
name|howto
operator|->
name|name
argument_list|)
expr_stmt|;
operator|*
name|error_message
operator|=
name|buf
expr_stmt|;
block|}
return|return
name|bfd_reloc_dangerous
return|;
block|}
end_function

begin_comment
comment|/* Fix bad default arch selected for a 32 bit input bfd when the    default is 64 bit.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc_elf_object_p
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
if|if
condition|(
name|abfd
operator|->
name|arch_info
operator|->
name|the_default
operator|&&
name|abfd
operator|->
name|arch_info
operator|->
name|bits_per_word
operator|==
literal|64
condition|)
block|{
name|Elf_Internal_Ehdr
modifier|*
name|i_ehdr
init|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
if|if
condition|(
name|i_ehdr
operator|->
name|e_ident
index|[
name|EI_CLASS
index|]
operator|==
name|ELFCLASS32
condition|)
block|{
comment|/* Relies on arch after 64 bit default being 32 bit default.  */
name|abfd
operator|->
name|arch_info
operator|=
name|abfd
operator|->
name|arch_info
operator|->
name|next
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|abfd
operator|->
name|arch_info
operator|->
name|bits_per_word
operator|==
literal|32
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Function to set whether a module needs the -mrelocatable bit set.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc_elf_set_private_flags
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|flagword
name|flags
parameter_list|)
block|{
name|BFD_ASSERT
argument_list|(
operator|!
name|elf_flags_init
argument_list|(
name|abfd
argument_list|)
operator|||
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|==
name|flags
argument_list|)
expr_stmt|;
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|=
name|flags
expr_stmt|;
name|elf_flags_init
argument_list|(
name|abfd
argument_list|)
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Merge backend specific data from an object file to the output    object file when linking.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc_elf_merge_private_bfd_data
parameter_list|(
name|bfd
modifier|*
name|ibfd
parameter_list|,
name|bfd
modifier|*
name|obfd
parameter_list|)
block|{
name|flagword
name|old_flags
decl_stmt|;
name|flagword
name|new_flags
decl_stmt|;
name|bfd_boolean
name|error
decl_stmt|;
comment|/* Check if we have the same endianess.  */
if|if
condition|(
operator|!
name|_bfd_generic_verify_endian_match
argument_list|(
name|ibfd
argument_list|,
name|obfd
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|ibfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
operator|||
name|bfd_get_flavour
argument_list|(
name|obfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
return|return
name|TRUE
return|;
name|new_flags
operator|=
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
name|old_flags
operator|=
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
if|if
condition|(
operator|!
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
condition|)
block|{
comment|/* First call, no flags set.  */
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
operator|=
name|TRUE
expr_stmt|;
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|=
name|new_flags
expr_stmt|;
block|}
comment|/* Compatible flags are ok.  */
elseif|else
if|if
condition|(
name|new_flags
operator|==
name|old_flags
condition|)
empty_stmt|;
comment|/* Incompatible flags.  */
else|else
block|{
comment|/* Warn about -mrelocatable mismatch.  Allow -mrelocatable-lib 	 to be linked with either.  */
name|error
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|(
name|new_flags
operator|&
name|EF_PPC_RELOCATABLE
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|old_flags
operator|&
operator|(
name|EF_PPC_RELOCATABLE
operator||
name|EF_PPC_RELOCATABLE_LIB
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|TRUE
expr_stmt|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: compiled with -mrelocatable and linked with "
literal|"modules compiled normally"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|new_flags
operator|&
operator|(
name|EF_PPC_RELOCATABLE
operator||
name|EF_PPC_RELOCATABLE_LIB
operator|)
operator|)
operator|==
literal|0
operator|&&
operator|(
name|old_flags
operator|&
name|EF_PPC_RELOCATABLE
operator|)
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|TRUE
expr_stmt|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: compiled normally and linked with "
literal|"modules compiled with -mrelocatable"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* The output is -mrelocatable-lib iff both the input files are.  */
if|if
condition|(
operator|!
operator|(
name|new_flags
operator|&
name|EF_PPC_RELOCATABLE_LIB
operator|)
condition|)
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|&=
operator|~
name|EF_PPC_RELOCATABLE_LIB
expr_stmt|;
comment|/* The output is -mrelocatable iff it can't be -mrelocatable-lib, 	 but each input file is either -mrelocatable or -mrelocatable-lib.  */
if|if
condition|(
operator|!
operator|(
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_PPC_RELOCATABLE_LIB
operator|)
operator|&&
operator|(
name|new_flags
operator|&
operator|(
name|EF_PPC_RELOCATABLE_LIB
operator||
name|EF_PPC_RELOCATABLE
operator|)
operator|)
operator|&&
operator|(
name|old_flags
operator|&
operator|(
name|EF_PPC_RELOCATABLE_LIB
operator||
name|EF_PPC_RELOCATABLE
operator|)
operator|)
condition|)
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator||=
name|EF_PPC_RELOCATABLE
expr_stmt|;
comment|/* Do not warn about eabi vs. V.4 mismatch, just or in the bit if 	 any module uses it.  */
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator||=
operator|(
name|new_flags
operator|&
name|EF_PPC_EMB
operator|)
expr_stmt|;
name|new_flags
operator|&=
operator|~
operator|(
name|EF_PPC_RELOCATABLE
operator||
name|EF_PPC_RELOCATABLE_LIB
operator||
name|EF_PPC_EMB
operator|)
expr_stmt|;
name|old_flags
operator|&=
operator|~
operator|(
name|EF_PPC_RELOCATABLE
operator||
name|EF_PPC_RELOCATABLE_LIB
operator||
name|EF_PPC_EMB
operator|)
expr_stmt|;
comment|/* Warn about any other mismatches.  */
if|if
condition|(
name|new_flags
operator|!=
name|old_flags
condition|)
block|{
name|error
operator|=
name|TRUE
expr_stmt|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: uses different e_flags (0x%lx) fields "
literal|"than previous modules (0x%lx)"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|new_flags
argument_list|,
operator|(
name|long
operator|)
name|old_flags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Handle a PowerPC specific section when reading an object file.  This    is called when elfcode.h finds a section with an unknown type.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc_elf_section_from_shdr
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Shdr
modifier|*
name|hdr
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|asection
modifier|*
name|newsect
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
if|if
condition|(
operator|!
name|_bfd_elf_make_section_from_shdr
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|newsect
operator|=
name|hdr
operator|->
name|bfd_section
expr_stmt|;
name|flags
operator|=
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|newsect
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|sh_flags
operator|&
name|SHF_EXCLUDE
condition|)
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|sh_type
operator|==
name|SHT_ORDERED
condition|)
name|flags
operator||=
name|SEC_SORT_ENTRIES
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|newsect
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set up any other section flags and such that may be necessary.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc_elf_fake_sections
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|Elf_Internal_Shdr
modifier|*
name|shdr
parameter_list|,
name|asection
modifier|*
name|asect
parameter_list|)
block|{
if|if
condition|(
operator|(
name|asect
operator|->
name|flags
operator|&
name|SEC_EXCLUDE
operator|)
operator|!=
literal|0
condition|)
name|shdr
operator|->
name|sh_flags
operator||=
name|SHF_EXCLUDE
expr_stmt|;
if|if
condition|(
operator|(
name|asect
operator|->
name|flags
operator|&
name|SEC_SORT_ENTRIES
operator|)
operator|!=
literal|0
condition|)
name|shdr
operator|->
name|sh_type
operator|=
name|SHT_ORDERED
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find a linker generated pointer with a given addend and type.  */
end_comment

begin_function
specifier|static
name|elf_linker_section_pointers_t
modifier|*
name|elf_find_pointer_linker_section
parameter_list|(
name|elf_linker_section_pointers_t
modifier|*
name|linker_pointers
parameter_list|,
name|bfd_vma
name|addend
parameter_list|,
name|elf_linker_section_t
modifier|*
name|lsect
parameter_list|)
block|{
for|for
control|(
init|;
name|linker_pointers
operator|!=
name|NULL
condition|;
name|linker_pointers
operator|=
name|linker_pointers
operator|->
name|next
control|)
if|if
condition|(
name|lsect
operator|==
name|linker_pointers
operator|->
name|lsect
operator|&&
name|addend
operator|==
name|linker_pointers
operator|->
name|addend
condition|)
return|return
name|linker_pointers
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Allocate a pointer to live in a linker created section.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_create_pointer_linker_section
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|elf_linker_section_t
modifier|*
name|lsect
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
parameter_list|)
block|{
name|elf_linker_section_pointers_t
modifier|*
modifier|*
name|ptr_linker_section_ptr
init|=
name|NULL
decl_stmt|;
name|elf_linker_section_pointers_t
modifier|*
name|linker_section_ptr
decl_stmt|;
name|unsigned
name|long
name|r_symndx
init|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|lsect
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Is this a global symbol?  */
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ppc_elf_link_hash_entry
modifier|*
name|eh
decl_stmt|;
comment|/* Has this symbol already been allocated?  If so, our work is done.  */
name|eh
operator|=
operator|(
expr|struct
name|ppc_elf_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
if|if
condition|(
name|elf_find_pointer_linker_section
argument_list|(
name|eh
operator|->
name|linker_section_pointer
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|,
name|lsect
argument_list|)
condition|)
return|return
name|TRUE
return|;
name|ptr_linker_section_ptr
operator|=
operator|&
name|eh
operator|->
name|linker_section_pointer
expr_stmt|;
comment|/* Make sure this symbol is output as a dynamic symbol.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|lsect
operator|->
name|rel_section
condition|)
name|lsect
operator|->
name|rel_section
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Allocation of a pointer to a local symbol.  */
name|elf_linker_section_pointers_t
modifier|*
modifier|*
name|ptr
init|=
name|elf_local_ptr_offsets
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
comment|/* Allocate a table to hold the local symbols if first time.  */
if|if
condition|(
operator|!
name|ptr
condition|)
block|{
name|unsigned
name|int
name|num_symbols
init|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
operator|.
name|sh_info
decl_stmt|;
name|amt
operator|=
name|num_symbols
expr_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
name|elf_linker_section_pointers_t
operator|*
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
return|return
name|FALSE
return|;
name|elf_local_ptr_offsets
argument_list|(
name|abfd
argument_list|)
operator|=
name|ptr
expr_stmt|;
block|}
comment|/* Has this symbol already been allocated?  If so, our work is done.  */
if|if
condition|(
name|elf_find_pointer_linker_section
argument_list|(
name|ptr
index|[
name|r_symndx
index|]
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|,
name|lsect
argument_list|)
condition|)
return|return
name|TRUE
return|;
name|ptr_linker_section_ptr
operator|=
operator|&
name|ptr
index|[
name|r_symndx
index|]
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
comment|/* If we are generating a shared object, we need to 	     output a R_<xxx>_RELATIVE reloc so that the 	     dynamic linker can adjust this GOT entry.  */
name|BFD_ASSERT
argument_list|(
name|lsect
operator|->
name|rel_section
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|lsect
operator|->
name|rel_section
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Allocate space for a pointer in the linker section, and allocate      a new pointer record from internal memory.  */
name|BFD_ASSERT
argument_list|(
name|ptr_linker_section_ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
name|elf_linker_section_pointers_t
argument_list|)
expr_stmt|;
name|linker_section_ptr
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|linker_section_ptr
condition|)
return|return
name|FALSE
return|;
name|linker_section_ptr
operator|->
name|next
operator|=
operator|*
name|ptr_linker_section_ptr
expr_stmt|;
name|linker_section_ptr
operator|->
name|addend
operator|=
name|rel
operator|->
name|r_addend
expr_stmt|;
name|linker_section_ptr
operator|->
name|lsect
operator|=
name|lsect
expr_stmt|;
name|linker_section_ptr
operator|->
name|written_address_p
operator|=
name|FALSE
expr_stmt|;
operator|*
name|ptr_linker_section_ptr
operator|=
name|linker_section_ptr
expr_stmt|;
name|linker_section_ptr
operator|->
name|offset
operator|=
name|lsect
operator|->
name|section
operator|->
name|_raw_size
expr_stmt|;
name|lsect
operator|->
name|section
operator|->
name|_raw_size
operator|+=
literal|4
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Create pointer in linker section %s, offset = %ld, section size = %ld\n"
argument_list|,
name|lsect
operator|->
name|name
argument_list|,
operator|(
name|long
operator|)
name|linker_section_ptr
operator|->
name|offset
argument_list|,
operator|(
name|long
operator|)
name|lsect
operator|->
name|section
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|bfd_put_ptr
parameter_list|(
name|BFD
parameter_list|,
name|VAL
parameter_list|,
name|ADDR
parameter_list|)
value|bfd_put_32 (BFD, VAL, ADDR)
end_define

begin_comment
comment|/* Fill in the address for a pointer generated in a linker section.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|elf_finish_pointer_linker_section
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|elf_linker_section_t
modifier|*
name|lsect
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|bfd_vma
name|relocation
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
parameter_list|,
name|int
name|relative_reloc
parameter_list|)
block|{
name|elf_linker_section_pointers_t
modifier|*
name|linker_section_ptr
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|lsect
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
comment|/* Handle global symbol.  */
name|struct
name|ppc_elf_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|ppc_elf_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
name|linker_section_ptr
operator|=
name|elf_find_pointer_linker_section
argument_list|(
name|eh
operator|->
name|linker_section_pointer
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|,
name|lsect
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|linker_section_ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
operator|||
operator|(
name|info
operator|->
name|shared
operator|&&
name|info
operator|->
name|symbolic
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|)
condition|)
block|{
comment|/* This is actually a static link, or it is a 	     -Bsymbolic link and the symbol is defined 	     locally.  We must initialize this entry in the 	     global section.  	     When doing a dynamic link, we create a .rela.<xxx> 	     relocation entry to initialize the value.  This 	     is done in the finish_dynamic_symbol routine.  */
if|if
condition|(
operator|!
name|linker_section_ptr
operator|->
name|written_address_p
condition|)
block|{
name|linker_section_ptr
operator|->
name|written_address_p
operator|=
name|TRUE
expr_stmt|;
name|bfd_put_ptr
argument_list|(
name|output_bfd
argument_list|,
name|relocation
operator|+
name|linker_section_ptr
operator|->
name|addend
argument_list|,
operator|(
name|lsect
operator|->
name|section
operator|->
name|contents
operator|+
name|linker_section_ptr
operator|->
name|offset
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* Handle local symbol.  */
name|unsigned
name|long
name|r_symndx
init|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|elf_local_ptr_offsets
argument_list|(
name|input_bfd
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|elf_local_ptr_offsets
argument_list|(
name|input_bfd
argument_list|)
index|[
name|r_symndx
index|]
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|linker_section_ptr
operator|=
operator|(
name|elf_find_pointer_linker_section
argument_list|(
name|elf_local_ptr_offsets
argument_list|(
name|input_bfd
argument_list|)
index|[
name|r_symndx
index|]
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|,
name|lsect
argument_list|)
operator|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|linker_section_ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Write out pointer if it hasn't been rewritten out before.  */
if|if
condition|(
operator|!
name|linker_section_ptr
operator|->
name|written_address_p
condition|)
block|{
name|linker_section_ptr
operator|->
name|written_address_p
operator|=
name|TRUE
expr_stmt|;
name|bfd_put_ptr
argument_list|(
name|output_bfd
argument_list|,
name|relocation
operator|+
name|linker_section_ptr
operator|->
name|addend
argument_list|,
name|lsect
operator|->
name|section
operator|->
name|contents
operator|+
name|linker_section_ptr
operator|->
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
comment|/* We need to generate a relative reloc for the dynamic 		 linker.  */
name|asection
modifier|*
name|srel
init|=
name|lsect
operator|->
name|rel_section
decl_stmt|;
name|Elf_Internal_Rela
name|outrel
index|[
name|MAX_INT_RELS_PER_EXT_REL
index|]
decl_stmt|;
name|bfd_byte
modifier|*
name|erel
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|srel
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bed
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
condition|;
name|i
operator|++
control|)
block|{
name|outrel
index|[
name|i
index|]
operator|.
name|r_offset
operator|=
operator|(
name|lsect
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|lsect
operator|->
name|section
operator|->
name|output_offset
operator|+
name|linker_section_ptr
operator|->
name|offset
operator|)
expr_stmt|;
name|outrel
index|[
name|i
index|]
operator|.
name|r_info
operator|=
literal|0
expr_stmt|;
name|outrel
index|[
name|i
index|]
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
block|}
name|outrel
index|[
literal|0
index|]
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
literal|0
argument_list|,
name|relative_reloc
argument_list|)
expr_stmt|;
name|erel
operator|=
name|lsect
operator|->
name|section
operator|->
name|contents
expr_stmt|;
name|erel
operator|+=
operator|(
name|elf_section_data
argument_list|(
name|lsect
operator|->
name|section
argument_list|)
operator|->
name|rel_count
operator|++
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
operator|)
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
name|outrel
argument_list|,
name|erel
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|relocation
operator|=
operator|(
name|lsect
operator|->
name|section
operator|->
name|output_offset
operator|+
name|linker_section_ptr
operator|->
name|offset
operator|-
name|lsect
operator|->
name|sym_offset
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Finish pointer in linker section %s, offset = %ld (0x%lx)\n"
argument_list|,
name|lsect
operator|->
name|name
argument_list|,
operator|(
name|long
operator|)
name|relocation
argument_list|,
operator|(
name|long
operator|)
name|relocation
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Subtract out the addend, because it will get added back in by the normal      processing.  */
return|return
name|relocation
operator|-
name|linker_section_ptr
operator|->
name|addend
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create a special linker section */
end_comment

begin_function
specifier|static
name|elf_linker_section_t
modifier|*
name|ppc_elf_create_linker_section
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|enum
name|elf_linker_section_enum
name|which
parameter_list|)
block|{
name|elf_linker_section_t
modifier|*
name|lsect
decl_stmt|;
name|struct
name|ppc_elf_link_hash_table
modifier|*
name|htab
init|=
name|ppc_elf_hash_table
argument_list|(
name|info
argument_list|)
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|rel_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|sym_name
decl_stmt|;
name|bfd_vma
name|sym_offset
decl_stmt|;
comment|/* Both of these sections are (technically) created by the user      putting data in them, so they shouldn't be marked      SEC_LINKER_CREATED.       The linker creates them so it has somewhere to attach their      respective symbols. In fact, if they were empty it would      be OK to leave the symbol set to 0 (or any random number), because      the appropriate register should never be used.  */
name|flags
operator|=
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
expr_stmt|;
name|sym_offset
operator|=
literal|32768
expr_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
case|case
name|LINKER_SECTION_SDATA
case|:
comment|/* .sdata/.sbss section */
name|name
operator|=
literal|".sdata"
expr_stmt|;
name|rel_name
operator|=
literal|".rela.sdata"
expr_stmt|;
name|sym_name
operator|=
literal|"_SDA_BASE_"
expr_stmt|;
break|break;
case|case
name|LINKER_SECTION_SDATA2
case|:
comment|/* .sdata2/.sbss2 section */
name|name
operator|=
literal|".sdata2"
expr_stmt|;
name|rel_name
operator|=
literal|".rela.sdata2"
expr_stmt|;
name|sym_name
operator|=
literal|"_SDA2_BASE_"
expr_stmt|;
name|flags
operator||=
name|SEC_READONLY
expr_stmt|;
break|break;
block|}
comment|/* Record the first bfd that needs the special sections.  */
if|if
condition|(
operator|!
name|htab
operator|->
name|elf
operator|.
name|dynobj
condition|)
name|htab
operator|->
name|elf
operator|.
name|dynobj
operator|=
name|abfd
expr_stmt|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
name|elf_linker_section_t
argument_list|)
expr_stmt|;
name|lsect
operator|=
name|bfd_zalloc
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|amt
argument_list|)
expr_stmt|;
name|lsect
operator|->
name|sym_offset
operator|=
name|sym_offset
expr_stmt|;
comment|/* See if the sections already exist.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|(
name|s
operator|->
name|flags
operator|&
name|flags
operator|)
operator|!=
name|flags
condition|)
block|{
name|s
operator|=
name|bfd_make_section_anyway
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|s
argument_list|,
name|flags
argument_list|)
condition|)
return|return
name|NULL
return|;
block|}
name|lsect
operator|->
name|section
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|bfd_get_section_alignment
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|s
argument_list|)
operator|<
literal|2
operator|&&
operator|!
name|bfd_set_section_alignment
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|s
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|NULL
return|;
name|s
operator|->
name|_raw_size
operator|=
name|align_power
argument_list|(
name|s
operator|->
name|_raw_size
argument_list|,
literal|2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Creating section %s, current size = %ld\n"
argument_list|,
name|name
argument_list|,
operator|(
name|long
operator|)
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sym_name
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|bh
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Adding %s to section %s\n"
argument_list|,
name|sym_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bh
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|info
operator|->
name|hash
argument_list|,
name|sym_name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bh
operator|==
name|NULL
operator|||
name|bh
operator|->
name|type
operator|==
name|bfd_link_hash_undefined
operator|)
operator|&&
operator|!
operator|(
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
name|sym_name
argument_list|,
name|BSF_GLOBAL
argument_list|,
name|s
argument_list|,
name|sym_offset
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|collect
argument_list|,
operator|&
name|bh
argument_list|)
operator|)
condition|)
return|return
name|NULL
return|;
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|bh
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|STT_OBJECT
expr_stmt|;
name|lsect
operator|->
name|sym_hash
operator|=
name|h
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
name|s
operator|=
name|bfd_make_section_anyway
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|rel_name
argument_list|)
expr_stmt|;
name|lsect
operator|->
name|rel_section
operator|=
name|s
expr_stmt|;
name|flags
operator|=
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_READONLY
operator|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|s
argument_list|,
name|flags
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|s
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|NULL
return|;
block|}
return|return
name|lsect
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If we have a non-zero sized .sbss2 or .PPC.EMB.sbss0 sections, we    need to bump up the number of section headers.  */
end_comment

begin_function
specifier|static
name|int
name|ppc_elf_additional_program_headers
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".interp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
operator|++
name|ret
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".sbss2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|!=
literal|0
operator|&&
name|s
operator|->
name|_raw_size
operator|>
literal|0
condition|)
operator|++
name|ret
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".PPC.EMB.sbss0"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|!=
literal|0
operator|&&
name|s
operator|->
name|_raw_size
operator|>
literal|0
condition|)
operator|++
name|ret
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Modify the segment map if needed.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc_elf_modify_segment_map
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The powerpc .got has a blrl instruction in it.  Mark it executable.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc_elf_create_got
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|ppc_elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
if|if
condition|(
operator|!
name|_bfd_elf_create_got_section
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|htab
operator|=
name|ppc_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|htab
operator|->
name|got
operator|=
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|flags
operator|=
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_CODE
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|flags
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|htab
operator|->
name|relgot
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|htab
operator|->
name|relgot
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|htab
operator|->
name|relgot
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_READONLY
operator|)
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|htab
operator|->
name|relgot
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* We have to create .dynsbss and .rela.sbss here so that they get mapped    to output sections (just like _bfd_elf_create_dynamic_sections has    to create .dynbss and .rela.bss).  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc_elf_create_dynamic_sections
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|ppc_elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
name|htab
operator|=
name|ppc_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|got
operator|==
name|NULL
operator|&&
operator|!
name|ppc_elf_create_got
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|_bfd_elf_create_dynamic_sections
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|flags
operator|=
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator|)
expr_stmt|;
name|htab
operator|->
name|dynbss
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynbss"
argument_list|)
expr_stmt|;
name|htab
operator|->
name|dynsbss
operator|=
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".dynsbss"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|SEC_ALLOC
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
name|htab
operator|->
name|relbss
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".rela.bss"
argument_list|)
expr_stmt|;
name|htab
operator|->
name|relsbss
operator|=
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".rela.sbss"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|flags
operator||
name|SEC_READONLY
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
name|htab
operator|->
name|relplt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".rela.plt"
argument_list|)
expr_stmt|;
name|htab
operator|->
name|plt
operator|=
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|flags
operator|=
name|SEC_ALLOC
operator||
name|SEC_CODE
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
expr_stmt|;
return|return
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Adjust a symbol defined by a dynamic object and referenced by a    regular object.  The current definition is in some section of the    dynamic object, but we're not including those sections.  We have to    change the definition to something the rest of the link can    understand.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc_elf_adjust_dynamic_symbol
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|)
block|{
name|struct
name|ppc_elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|unsigned
name|int
name|power_of_two
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ppc_elf_adjust_dynamic_symbol called for %s\n"
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Make sure we know what is going on here.  */
name|htab
operator|=
name|ppc_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_NEEDS_PLT
operator|)
operator|||
name|h
operator|->
name|weakdef
operator|!=
name|NULL
operator|||
operator|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_REF_REGULAR
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Deal with function syms.  */
if|if
condition|(
name|h
operator|->
name|type
operator|==
name|STT_FUNC
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_NEEDS_PLT
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Clear procedure linkage table information for any symbol that 	 won't need a .plt entry.  */
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|refcount
operator|<=
literal|0
operator|||
name|SYMBOL_CALLS_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
operator|||
operator|(
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|!=
name|STV_DEFAULT
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|)
condition|)
block|{
comment|/* A PLT entry is not required/allowed when:  	     1. We are not using ld.so; because then the PLT entry 	     can't be set up, so we can't use one.  In this case, 	     ppc_elf_adjust_dynamic_symbol won't even be called.  	     2. GC has rendered the entry unused.  	     3. We know for certain that a call to this symbol 	     will go to this object, or will remain undefined.  */
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_HASH_NEEDS_PLT
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
else|else
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* If this is a weak symbol, and there is a real definition, the      processor independent code will have arranged for us to see the      real definition first, and we can just use the same value.  */
if|if
condition|(
name|h
operator|->
name|weakdef
operator|!=
name|NULL
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
argument_list|)
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
if|if
condition|(
name|ELIMINATE_COPY_RELOCS
condition|)
name|h
operator|->
name|elf_link_hash_flags
operator|=
operator|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
operator|~
name|ELF_LINK_NON_GOT_REF
operator|)
operator||
operator|(
name|h
operator|->
name|weakdef
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_NON_GOT_REF
operator|)
operator|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* This is a reference to a symbol defined by a dynamic object which      is not a function.  */
comment|/* If we are creating a shared library, we must presume that the      only references to the symbol are via the global offset table.      For such cases we need not do anything here; the relocations will      be handled correctly by relocate_section.  */
if|if
condition|(
name|info
operator|->
name|shared
condition|)
return|return
name|TRUE
return|;
comment|/* If there are no references to this symbol that do not use the      GOT, we don't need to generate a copy reloc.  */
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_NON_GOT_REF
operator|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|ELIMINATE_COPY_RELOCS
condition|)
block|{
name|struct
name|ppc_elf_dyn_relocs
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|ppc_elf_hash_entry
argument_list|(
name|h
argument_list|)
operator|->
name|dyn_relocs
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|s
operator|=
name|p
operator|->
name|sec
operator|->
name|output_section
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|!=
literal|0
condition|)
break|break;
block|}
comment|/* If we didn't find any dynamic relocs in read-only sections, then 	 we'll be keeping the dynamic relocs and avoiding the copy reloc.  */
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|h
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_NON_GOT_REF
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
comment|/* We must allocate the symbol in our .dynbss section, which will      become part of the .bss section of the executable.  There will be      an entry for this symbol in the .dynsym section.  The dynamic      object will contain position independent code, so all references      from the dynamic object to this symbol will go through the global      offset table.  The dynamic linker will use the .dynsym entry to      determine the address it must put in the global offset table, so      both the dynamic object and the regular object will refer to the      same memory location for the variable.       Of course, if the symbol is sufficiently small, we must instead      allocate it in .sbss.  FIXME: It would be better to do this if and      only if there were actually SDAREL relocs for that symbol.  */
if|if
condition|(
name|h
operator|->
name|size
operator|<=
name|elf_gp_size
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|)
condition|)
name|s
operator|=
name|htab
operator|->
name|dynsbss
expr_stmt|;
else|else
name|s
operator|=
name|htab
operator|->
name|dynbss
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* We must generate a R_PPC_COPY reloc to tell the dynamic linker to      copy the initial value out of the dynamic object and into the      runtime process image.  We need to remember the offset into the      .rela.bss section we are going to use.  */
if|if
condition|(
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
name|asection
modifier|*
name|srel
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|size
operator|<=
name|elf_gp_size
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|)
condition|)
name|srel
operator|=
name|htab
operator|->
name|relsbss
expr_stmt|;
else|else
name|srel
operator|=
name|htab
operator|->
name|relbss
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|srel
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|srel
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_NEEDS_COPY
expr_stmt|;
block|}
comment|/* We need to figure out the alignment required for this symbol.  I      have no idea how ELF linkers handle this.  */
name|power_of_two
operator|=
name|bfd_log2
argument_list|(
name|h
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|power_of_two
operator|>
literal|4
condition|)
name|power_of_two
operator|=
literal|4
expr_stmt|;
comment|/* Apply the required alignment.  */
name|s
operator|->
name|_raw_size
operator|=
name|BFD_ALIGN
argument_list|(
name|s
operator|->
name|_raw_size
argument_list|,
call|(
name|bfd_size_type
call|)
argument_list|(
literal|1
operator|<<
name|power_of_two
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|power_of_two
operator|>
name|bfd_get_section_alignment
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_alignment
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|s
argument_list|,
name|power_of_two
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Define the symbol as being at this point in the section.  */
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|s
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
comment|/* Increment the section size to make room for the symbol.  */
name|s
operator|->
name|_raw_size
operator|+=
name|h
operator|->
name|size
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Of those relocs that might be copied as dynamic relocs, this macro    selects those that must be copied when linking a shared library,    even when the symbol is local.  */
end_comment

begin_define
define|#
directive|define
name|MUST_BE_DYN_RELOC
parameter_list|(
name|RTYPE
parameter_list|)
define|\
value|((RTYPE) != R_PPC_REL24			\&& (RTYPE) != R_PPC_REL14			\&& (RTYPE) != R_PPC_REL14_BRTAKEN		\&& (RTYPE) != R_PPC_REL14_BRNTAKEN		\&& (RTYPE) != R_PPC_REL32)
end_define

begin_comment
comment|/* Allocate space in associated reloc sections for dynamic relocs.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|allocate_dynrelocs
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|void
modifier|*
name|inf
parameter_list|)
block|{
name|struct
name|bfd_link_info
modifier|*
name|info
init|=
name|inf
decl_stmt|;
name|struct
name|ppc_elf_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|struct
name|ppc_elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|struct
name|ppc_elf_dyn_relocs
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
comment|/* When warning symbols are created, they **replace** the "real"        entry in the hash table, thus we never get to see the real        symbol in a hash traversal.  So look at it now.  */
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|htab
operator|=
name|ppc_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|elf
operator|.
name|dynamic_sections_created
operator|&&
name|h
operator|->
name|plt
operator|.
name|refcount
operator|>
literal|0
condition|)
block|{
comment|/* Make sure this symbol is output as a dynamic symbol.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_FORCED_LOCAL
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|info
operator|->
name|shared
operator|||
name|WILL_CALL_FINISH_DYNAMIC_SYMBOL
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
name|h
argument_list|)
condition|)
block|{
name|asection
modifier|*
name|s
init|=
name|htab
operator|->
name|plt
decl_stmt|;
comment|/* If this is the first .plt entry, make room for the special 	     first entry.  */
if|if
condition|(
name|s
operator|->
name|_raw_size
operator|==
literal|0
condition|)
name|s
operator|->
name|_raw_size
operator|+=
name|PLT_INITIAL_ENTRY_SIZE
expr_stmt|;
comment|/* The PowerPC PLT is actually composed of two parts, the 	     first part is 2 words (for a load and a jump), and then 	     there is a remaining word available at the end.  */
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
operator|(
name|PLT_INITIAL_ENTRY_SIZE
operator|+
operator|(
name|PLT_SLOT_SIZE
operator|*
operator|(
operator|(
name|s
operator|->
name|_raw_size
operator|-
name|PLT_INITIAL_ENTRY_SIZE
operator|)
operator|/
name|PLT_ENTRY_SIZE
operator|)
operator|)
operator|)
expr_stmt|;
comment|/* If this symbol is not defined in a regular file, and we 	     are not generating a shared library, then set the symbol 	     to this location in the .plt.  This is required to make 	     function pointers compare as equal between the normal 	     executable and the shared library.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
condition|)
block|{
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|s
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|h
operator|->
name|plt
operator|.
name|offset
expr_stmt|;
block|}
comment|/* Make room for this entry.  After the 8192nd entry, room 	     for two entries is allocated.  */
name|s
operator|->
name|_raw_size
operator|+=
name|PLT_ENTRY_SIZE
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|->
name|_raw_size
operator|-
name|PLT_INITIAL_ENTRY_SIZE
operator|)
operator|/
name|PLT_ENTRY_SIZE
operator|>
name|PLT_NUM_SINGLE_ENTRIES
condition|)
name|s
operator|->
name|_raw_size
operator|+=
name|PLT_ENTRY_SIZE
expr_stmt|;
comment|/* We also need to make an entry in the .rela.plt section.  */
name|htab
operator|->
name|relplt
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_HASH_NEEDS_PLT
expr_stmt|;
block|}
block|}
else|else
block|{
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_HASH_NEEDS_PLT
expr_stmt|;
block|}
name|eh
operator|=
operator|(
expr|struct
name|ppc_elf_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
if|if
condition|(
name|eh
operator|->
name|elf
operator|.
name|got
operator|.
name|refcount
operator|>
literal|0
condition|)
block|{
comment|/* Make sure this symbol is output as a dynamic symbol.  */
if|if
condition|(
name|eh
operator|->
name|elf
operator|.
name|dynindx
operator|==
operator|-
literal|1
operator|&&
operator|(
name|eh
operator|->
name|elf
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_FORCED_LOCAL
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
operator|&
name|eh
operator|->
name|elf
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|eh
operator|->
name|tls_mask
operator|==
operator|(
name|TLS_TLS
operator||
name|TLS_LD
operator|)
operator|&&
operator|!
operator|(
name|eh
operator|->
name|elf
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
condition|)
comment|/* If just an LD reloc, we'll just use htab->tlsld_got.offset.  */
name|eh
operator|->
name|elf
operator|.
name|got
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
else|else
block|{
name|bfd_boolean
name|dyn
decl_stmt|;
name|eh
operator|->
name|elf
operator|.
name|got
operator|.
name|offset
operator|=
name|htab
operator|->
name|got
operator|->
name|_raw_size
expr_stmt|;
if|if
condition|(
operator|(
name|eh
operator|->
name|tls_mask
operator|&
name|TLS_TLS
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|eh
operator|->
name|tls_mask
operator|&
name|TLS_LD
operator|)
operator|!=
literal|0
condition|)
name|htab
operator|->
name|got
operator|->
name|_raw_size
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
operator|(
name|eh
operator|->
name|tls_mask
operator|&
name|TLS_GD
operator|)
operator|!=
literal|0
condition|)
name|htab
operator|->
name|got
operator|->
name|_raw_size
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
operator|(
name|eh
operator|->
name|tls_mask
operator|&
operator|(
name|TLS_TPREL
operator||
name|TLS_TPRELGD
operator|)
operator|)
operator|!=
literal|0
condition|)
name|htab
operator|->
name|got
operator|->
name|_raw_size
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
operator|(
name|eh
operator|->
name|tls_mask
operator|&
name|TLS_DTPREL
operator|)
operator|!=
literal|0
condition|)
name|htab
operator|->
name|got
operator|->
name|_raw_size
operator|+=
literal|4
expr_stmt|;
block|}
else|else
name|htab
operator|->
name|got
operator|->
name|_raw_size
operator|+=
literal|4
expr_stmt|;
name|dyn
operator|=
name|htab
operator|->
name|elf
operator|.
name|dynamic_sections_created
expr_stmt|;
if|if
condition|(
operator|(
name|info
operator|->
name|shared
operator|||
name|WILL_CALL_FINISH_DYNAMIC_SYMBOL
argument_list|(
name|dyn
argument_list|,
literal|0
argument_list|,
operator|&
name|eh
operator|->
name|elf
argument_list|)
operator|)
operator|&&
operator|(
name|ELF_ST_VISIBILITY
argument_list|(
name|eh
operator|->
name|elf
operator|.
name|other
argument_list|)
operator|==
name|STV_DEFAULT
operator|||
name|eh
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefweak
operator|)
condition|)
block|{
comment|/* All the entries we allocated need relocs.  */
name|htab
operator|->
name|relgot
operator|->
name|_raw_size
operator|+=
operator|(
operator|(
name|htab
operator|->
name|got
operator|->
name|_raw_size
operator|-
name|eh
operator|->
name|elf
operator|.
name|got
operator|.
name|offset
operator|)
operator|/
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
operator|)
expr_stmt|;
comment|/* Except LD only needs one.  */
if|if
condition|(
operator|(
name|eh
operator|->
name|tls_mask
operator|&
name|TLS_LD
operator|)
operator|!=
literal|0
condition|)
name|htab
operator|->
name|relgot
operator|->
name|_raw_size
operator|-=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
name|eh
operator|->
name|elf
operator|.
name|got
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|eh
operator|->
name|dyn_relocs
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
comment|/* In the shared -Bsymbolic case, discard space allocated for      dynamic pc-relative relocs against symbols which turn out to be      defined in regular objects.  For the normal shared case, discard      space for relocs that have become local due to symbol visibility      changes.  */
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
comment|/* Relocs that use pc_count are those that appear on a call insn, 	 or certain REL relocs (see MUST_BE_DYN_RELOC) that can be 	 generated via assembly.  We want calls to protected symbols to 	 resolve directly to the function rather than going via the plt. 	 If people want function pointer comparisons to work as expected 	 then they should avoid writing weird assembly.  */
if|if
condition|(
name|SYMBOL_CALLS_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
block|{
name|struct
name|ppc_elf_dyn_relocs
modifier|*
modifier|*
name|pp
decl_stmt|;
for|for
control|(
name|pp
operator|=
operator|&
name|eh
operator|->
name|dyn_relocs
init|;
operator|(
name|p
operator|=
operator|*
name|pp
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
name|p
operator|->
name|count
operator|-=
name|p
operator|->
name|pc_count
expr_stmt|;
name|p
operator|->
name|pc_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|count
operator|==
literal|0
condition|)
operator|*
name|pp
operator|=
name|p
operator|->
name|next
expr_stmt|;
else|else
name|pp
operator|=
operator|&
name|p
operator|->
name|next
expr_stmt|;
block|}
block|}
comment|/* Also discard relocs on undefined weak syms with non-default 	 visibility.  */
if|if
condition|(
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|!=
name|STV_DEFAULT
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
name|eh
operator|->
name|dyn_relocs
operator|=
name|NULL
expr_stmt|;
comment|/* Make sure undefined weak symbols are output as a dynamic symbol 	 in PIEs.  */
if|if
condition|(
name|info
operator|->
name|pie
operator|&&
name|eh
operator|->
name|dyn_relocs
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_FORCED_LOCAL
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|ELIMINATE_COPY_RELOCS
condition|)
block|{
comment|/* For the non-shared case, discard space for relocs against 	 symbols which turn out to need copy relocs or are not 	 dynamic.  */
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_NON_GOT_REF
operator|)
operator|==
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Make sure this symbol is output as a dynamic symbol. 	     Undefined weak syms won't yet be marked as dynamic.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_FORCED_LOCAL
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* If that succeeded, we know we'll be keeping all the 	     relocs.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
condition|)
goto|goto
name|keep
goto|;
block|}
name|eh
operator|->
name|dyn_relocs
operator|=
name|NULL
expr_stmt|;
name|keep
label|:
empty_stmt|;
block|}
comment|/* Finally, allocate space.  */
for|for
control|(
name|p
operator|=
name|eh
operator|->
name|dyn_relocs
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|asection
modifier|*
name|sreloc
init|=
name|elf_section_data
argument_list|(
name|p
operator|->
name|sec
argument_list|)
operator|->
name|sreloc
decl_stmt|;
name|sreloc
operator|->
name|_raw_size
operator|+=
name|p
operator|->
name|count
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Find any dynamic relocs that apply to read-only sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|readonly_dynrelocs
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|void
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|ppc_elf_dyn_relocs
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
for|for
control|(
name|p
operator|=
name|ppc_elf_hash_entry
argument_list|(
name|h
argument_list|)
operator|->
name|dyn_relocs
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|asection
modifier|*
name|s
init|=
name|p
operator|->
name|sec
operator|->
name|output_section
decl_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|s
operator|->
name|flags
operator|&
operator|(
name|SEC_READONLY
operator||
name|SEC_ALLOC
operator|)
operator|)
operator|==
operator|(
name|SEC_READONLY
operator||
name|SEC_ALLOC
operator|)
operator|)
condition|)
block|{
operator|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|)
name|info
operator|)
operator|->
name|flags
operator||=
name|DF_TEXTREL
expr_stmt|;
comment|/* Not an error, just cut short the traversal.  */
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Set the sizes of the dynamic sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc_elf_size_dynamic_sections
parameter_list|(
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|ppc_elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_boolean
name|relocs
decl_stmt|;
name|bfd
modifier|*
name|ibfd
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ppc_elf_size_dynamic_sections called\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|htab
operator|=
name|ppc_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
comment|/* Set the contents of the .interp section to the interpreter.  */
if|if
condition|(
name|info
operator|->
name|executable
condition|)
block|{
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
literal|".interp"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|=
sizeof|sizeof
name|ELF_DYNAMIC_INTERPRETER
expr_stmt|;
name|s
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ELF_DYNAMIC_INTERPRETER
expr_stmt|;
block|}
block|}
if|if
condition|(
name|htab
operator|->
name|tlsld_got
operator|.
name|refcount
operator|>
literal|0
condition|)
block|{
name|htab
operator|->
name|tlsld_got
operator|.
name|offset
operator|=
name|htab
operator|->
name|got
operator|->
name|_raw_size
expr_stmt|;
name|htab
operator|->
name|got
operator|->
name|_raw_size
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
name|htab
operator|->
name|relgot
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
block|}
else|else
name|htab
operator|->
name|tlsld_got
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* Set up .got offsets for local syms, and space for local dynamic      relocs.  */
for|for
control|(
name|ibfd
operator|=
name|info
operator|->
name|input_bfds
init|;
name|ibfd
operator|!=
name|NULL
condition|;
name|ibfd
operator|=
name|ibfd
operator|->
name|link_next
control|)
block|{
name|bfd_signed_vma
modifier|*
name|local_got
decl_stmt|;
name|bfd_signed_vma
modifier|*
name|end_local_got
decl_stmt|;
name|char
modifier|*
name|lgot_masks
decl_stmt|;
name|bfd_size_type
name|locsymcount
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|asection
modifier|*
name|srel
decl_stmt|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|ibfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
continue|continue;
for|for
control|(
name|s
operator|=
name|ibfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|struct
name|ppc_elf_dyn_relocs
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
operator|(
operator|(
expr|struct
name|ppc_elf_dyn_relocs
operator|*
operator|)
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|local_dynrel
operator|)
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|bfd_is_abs_section
argument_list|(
name|p
operator|->
name|sec
argument_list|)
operator|&&
name|bfd_is_abs_section
argument_list|(
name|p
operator|->
name|sec
operator|->
name|output_section
argument_list|)
condition|)
block|{
comment|/* Input section has been discarded, either because 		     it is a copy of a linkonce section or due to 		     linker script /DISCARD/, so we'll be discarding 		     the relocs too.  */
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|count
operator|!=
literal|0
condition|)
block|{
name|elf_section_data
argument_list|(
name|p
operator|->
name|sec
argument_list|)
operator|->
name|sreloc
operator|->
name|_raw_size
operator|+=
name|p
operator|->
name|count
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|sec
operator|->
name|output_section
operator|->
name|flags
operator|&
operator|(
name|SEC_READONLY
operator||
name|SEC_ALLOC
operator|)
operator|)
operator|==
operator|(
name|SEC_READONLY
operator||
name|SEC_ALLOC
operator|)
condition|)
name|info
operator|->
name|flags
operator||=
name|DF_TEXTREL
expr_stmt|;
block|}
block|}
block|}
name|local_got
operator|=
name|elf_local_got_refcounts
argument_list|(
name|ibfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|local_got
condition|)
continue|continue;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|locsymcount
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|end_local_got
operator|=
name|local_got
operator|+
name|locsymcount
expr_stmt|;
name|lgot_masks
operator|=
operator|(
name|char
operator|*
operator|)
name|end_local_got
expr_stmt|;
name|s
operator|=
name|htab
operator|->
name|got
expr_stmt|;
name|srel
operator|=
name|htab
operator|->
name|relgot
expr_stmt|;
for|for
control|(
init|;
name|local_got
operator|<
name|end_local_got
condition|;
operator|++
name|local_got
operator|,
operator|++
name|lgot_masks
control|)
if|if
condition|(
operator|*
name|local_got
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|lgot_masks
operator|==
operator|(
name|TLS_TLS
operator||
name|TLS_LD
operator|)
condition|)
block|{
comment|/* If just an LD reloc, we'll just use 		   htab->tlsld_got.offset.  */
if|if
condition|(
name|htab
operator|->
name|tlsld_got
operator|.
name|offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
name|htab
operator|->
name|tlsld_got
operator|.
name|offset
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
name|srel
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
block|}
operator|*
name|local_got
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|*
name|local_got
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|lgot_masks
operator|&
name|TLS_TLS
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|lgot_masks
operator|&
name|TLS_GD
operator|)
operator|!=
literal|0
condition|)
name|s
operator|->
name|_raw_size
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|lgot_masks
operator|&
operator|(
name|TLS_TPREL
operator||
name|TLS_TPRELGD
operator|)
operator|)
operator|!=
literal|0
condition|)
name|s
operator|->
name|_raw_size
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|lgot_masks
operator|&
name|TLS_DTPREL
operator|)
operator|!=
literal|0
condition|)
name|s
operator|->
name|_raw_size
operator|+=
literal|4
expr_stmt|;
block|}
else|else
name|s
operator|->
name|_raw_size
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
name|srel
operator|->
name|_raw_size
operator|+=
operator|(
operator|(
name|s
operator|->
name|_raw_size
operator|-
operator|*
name|local_got
operator|)
operator|/
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
operator|)
expr_stmt|;
block|}
block|}
else|else
operator|*
name|local_got
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Allocate space for global sym dynamic relocs.  */
name|elf_link_hash_traverse
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|allocate_dynrelocs
argument_list|,
name|info
argument_list|)
expr_stmt|;
comment|/* We've now determined the sizes of the various dynamic sections.      Allocate memory for them.  */
name|relocs
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|s
operator|=
name|htab
operator|->
name|elf
operator|.
name|dynobj
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LINKER_CREATED
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|s
operator|==
name|htab
operator|->
name|plt
operator|||
name|s
operator|==
name|htab
operator|->
name|got
operator|||
operator|(
name|htab
operator|->
name|sdata
operator|!=
name|NULL
operator|&&
name|s
operator|==
name|htab
operator|->
name|sdata
operator|->
name|section
operator|)
operator|||
operator|(
name|htab
operator|->
name|sdata2
operator|!=
name|NULL
operator|&&
name|s
operator|==
name|htab
operator|->
name|sdata2
operator|->
name|section
operator|)
condition|)
block|{
comment|/* Strip this section if we don't need it; see the 	     comment below.  */
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|)
argument_list|,
literal|".rela"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|_raw_size
operator|==
literal|0
condition|)
block|{
comment|/* If we don't need this section, strip it from the 		 output file.  This is mostly to handle .rela.bss and 		 .rela.plt.  We must create both sections in 		 create_dynamic_sections, because they must be created 		 before the linker maps input sections to output 		 sections.  The linker does that before 		 adjust_dynamic_symbol is called, and it is that 		 function which decides whether anything needs to go 		 into these sections.  */
block|}
else|else
block|{
comment|/* Remember whether there are any relocation sections.  */
name|relocs
operator|=
name|TRUE
expr_stmt|;
comment|/* We use the reloc_count field as a counter if we need 		 to copy relocs into the output file.  */
name|s
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* It's not one of our sections, so don't allocate space.  */
continue|continue;
block|}
if|if
condition|(
name|s
operator|->
name|_raw_size
operator|==
literal|0
condition|)
block|{
name|_bfd_strip_section_from_output
argument_list|(
name|info
argument_list|,
name|s
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Allocate memory for the section contents.  */
name|s
operator|->
name|contents
operator|=
name|bfd_zalloc
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|htab
operator|->
name|elf
operator|.
name|dynamic_sections_created
condition|)
block|{
comment|/* Add some entries to the .dynamic section.  We fill in the 	 values later, in ppc_elf_finish_dynamic_sections, but we 	 must add the entries now so that we get the correct size for 	 the .dynamic section.  The DT_DEBUG entry is filled in by the 	 dynamic linker and used by the debugger.  */
define|#
directive|define
name|add_dynamic_entry
parameter_list|(
name|TAG
parameter_list|,
name|VAL
parameter_list|)
define|\
value|_bfd_elf_add_dynamic_entry (info, TAG, VAL)
if|if
condition|(
name|info
operator|->
name|executable
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_DEBUG
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|htab
operator|->
name|plt
operator|!=
name|NULL
operator|&&
name|htab
operator|->
name|plt
operator|->
name|_raw_size
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PLTGOT
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PLTRELSZ
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PLTREL
argument_list|,
name|DT_RELA
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_JMPREL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|relocs
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELA
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELASZ
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELAENT
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* If any dynamic relocs apply to a read-only section, then we 	 need a DT_TEXTREL entry.  */
if|if
condition|(
operator|(
name|info
operator|->
name|flags
operator|&
name|DF_TEXTREL
operator|)
operator|==
literal|0
condition|)
name|elf_link_hash_traverse
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|readonly_dynrelocs
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|info
operator|->
name|flags
operator|&
name|DF_TEXTREL
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_TEXTREL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
undef|#
directive|undef
name|add_dynamic_entry
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|bfd_boolean
name|update_local_sym_info
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
parameter_list|,
name|unsigned
name|long
name|r_symndx
parameter_list|,
name|int
name|tls_type
parameter_list|)
block|{
name|bfd_signed_vma
modifier|*
name|local_got_refcounts
init|=
name|elf_local_got_refcounts
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|char
modifier|*
name|local_got_tls_masks
decl_stmt|;
if|if
condition|(
name|local_got_refcounts
operator|==
name|NULL
condition|)
block|{
name|bfd_size_type
name|size
init|=
name|symtab_hdr
operator|->
name|sh_info
decl_stmt|;
name|size
operator|*=
sizeof|sizeof
argument_list|(
operator|*
name|local_got_refcounts
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|local_got_tls_masks
argument_list|)
expr_stmt|;
name|local_got_refcounts
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_got_refcounts
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|elf_local_got_refcounts
argument_list|(
name|abfd
argument_list|)
operator|=
name|local_got_refcounts
expr_stmt|;
block|}
name|local_got_refcounts
index|[
name|r_symndx
index|]
operator|+=
literal|1
expr_stmt|;
name|local_got_tls_masks
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|local_got_refcounts
operator|+
name|symtab_hdr
operator|->
name|sh_info
operator|)
expr_stmt|;
name|local_got_tls_masks
index|[
name|r_symndx
index|]
operator||=
name|tls_type
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bad_shared_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|enum
name|elf_ppc_reloc_type
name|r_type
parameter_list|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: relocation %s cannot be used when making a shared object"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|ppc_elf_howto_table
index|[
name|r_type
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Look through the relocs for a section during the first phase, and    allocate space in the global offset table or procedure linkage    table.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc_elf_check_relocs
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
parameter_list|)
block|{
name|struct
name|ppc_elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel_end
decl_stmt|;
name|asection
modifier|*
name|sreloc
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
return|return
name|TRUE
return|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ppc_elf_check_relocs called for section %s in %s\n"
argument_list|,
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Initialize howto table if not already done.  */
if|if
condition|(
operator|!
name|ppc_elf_howto_table
index|[
name|R_PPC_ADDR32
index|]
condition|)
name|ppc_elf_howto_init
argument_list|()
expr_stmt|;
comment|/* Create the linker generated sections all the time so that the      special symbols are created.  */
name|htab
operator|=
name|ppc_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|sdata
operator|==
name|NULL
condition|)
block|{
name|htab
operator|->
name|sdata
operator|=
name|ppc_elf_create_linker_section
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|LINKER_SECTION_SDATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|sdata
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|htab
operator|->
name|sdata2
operator|==
name|NULL
condition|)
block|{
name|htab
operator|->
name|sdata2
operator|=
name|ppc_elf_create_linker_section
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|LINKER_SECTION_SDATA2
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|sdata2
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|sreloc
operator|=
name|NULL
expr_stmt|;
name|rel_end
operator|=
name|relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|rel_end
condition|;
name|rel
operator|++
control|)
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|enum
name|elf_ppc_reloc_type
name|r_type
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|int
name|tls_type
init|=
literal|0
decl_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
name|h
operator|=
name|NULL
expr_stmt|;
else|else
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
comment|/* If a relocation refers to _GLOBAL_OFFSET_TABLE_, create the .got. 	 This shows up in particular in an R_PPC_ADDR32 in the eabi 	 startup code.  */
if|if
condition|(
name|h
operator|&&
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|htab
operator|->
name|got
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
operator|==
name|NULL
condition|)
name|htab
operator|->
name|elf
operator|.
name|dynobj
operator|=
name|abfd
expr_stmt|;
if|if
condition|(
operator|!
name|ppc_elf_create_got
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_PPC_GOT_TLSLD16
case|:
case|case
name|R_PPC_GOT_TLSLD16_LO
case|:
case|case
name|R_PPC_GOT_TLSLD16_HI
case|:
case|case
name|R_PPC_GOT_TLSLD16_HA
case|:
name|htab
operator|->
name|tlsld_got
operator|.
name|refcount
operator|+=
literal|1
expr_stmt|;
name|tls_type
operator|=
name|TLS_TLS
operator||
name|TLS_LD
expr_stmt|;
goto|goto
name|dogottls
goto|;
case|case
name|R_PPC_GOT_TLSGD16
case|:
case|case
name|R_PPC_GOT_TLSGD16_LO
case|:
case|case
name|R_PPC_GOT_TLSGD16_HI
case|:
case|case
name|R_PPC_GOT_TLSGD16_HA
case|:
name|tls_type
operator|=
name|TLS_TLS
operator||
name|TLS_GD
expr_stmt|;
goto|goto
name|dogottls
goto|;
case|case
name|R_PPC_GOT_TPREL16
case|:
case|case
name|R_PPC_GOT_TPREL16_LO
case|:
case|case
name|R_PPC_GOT_TPREL16_HI
case|:
case|case
name|R_PPC_GOT_TPREL16_HA
case|:
if|if
condition|(
name|info
operator|->
name|shared
condition|)
name|info
operator|->
name|flags
operator||=
name|DF_STATIC_TLS
expr_stmt|;
name|tls_type
operator|=
name|TLS_TLS
operator||
name|TLS_TPREL
expr_stmt|;
goto|goto
name|dogottls
goto|;
case|case
name|R_PPC_GOT_DTPREL16
case|:
case|case
name|R_PPC_GOT_DTPREL16_LO
case|:
case|case
name|R_PPC_GOT_DTPREL16_HI
case|:
case|case
name|R_PPC_GOT_DTPREL16_HA
case|:
name|tls_type
operator|=
name|TLS_TLS
operator||
name|TLS_DTPREL
expr_stmt|;
name|dogottls
label|:
name|sec
operator|->
name|has_tls_reloc
operator|=
literal|1
expr_stmt|;
comment|/* Fall thru */
comment|/* GOT16 relocations */
case|case
name|R_PPC_GOT16
case|:
case|case
name|R_PPC_GOT16_LO
case|:
case|case
name|R_PPC_GOT16_HI
case|:
case|case
name|R_PPC_GOT16_HA
case|:
comment|/* This symbol requires a global offset table entry.  */
if|if
condition|(
name|htab
operator|->
name|got
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
operator|==
name|NULL
condition|)
name|htab
operator|->
name|elf
operator|.
name|dynobj
operator|=
name|abfd
expr_stmt|;
if|if
condition|(
operator|!
name|ppc_elf_create_got
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|h
operator|->
name|got
operator|.
name|refcount
operator|+=
literal|1
expr_stmt|;
name|ppc_elf_hash_entry
argument_list|(
name|h
argument_list|)
operator|->
name|tls_mask
operator||=
name|tls_type
expr_stmt|;
block|}
elseif|else
comment|/* This is a global offset table entry for a local symbol.  */
if|if
condition|(
operator|!
name|update_local_sym_info
argument_list|(
name|abfd
argument_list|,
name|symtab_hdr
argument_list|,
name|r_symndx
argument_list|,
name|tls_type
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
comment|/* Indirect .sdata relocation.  */
case|case
name|R_PPC_EMB_SDAI16
case|:
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
name|bad_shared_reloc
argument_list|(
name|abfd
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|elf_create_pointer_linker_section
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|htab
operator|->
name|sdata
argument_list|,
name|h
argument_list|,
name|rel
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
comment|/* Indirect .sdata2 relocation.  */
case|case
name|R_PPC_EMB_SDA2I16
case|:
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
name|bad_shared_reloc
argument_list|(
name|abfd
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|elf_create_pointer_linker_section
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|htab
operator|->
name|sdata2
argument_list|,
name|h
argument_list|,
name|rel
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|R_PPC_SDAREL16
case|:
case|case
name|R_PPC_EMB_SDA2REL
case|:
case|case
name|R_PPC_EMB_SDA21
case|:
case|case
name|R_PPC_EMB_RELSDA
case|:
case|case
name|R_PPC_EMB_NADDR32
case|:
case|case
name|R_PPC_EMB_NADDR16
case|:
case|case
name|R_PPC_EMB_NADDR16_LO
case|:
case|case
name|R_PPC_EMB_NADDR16_HI
case|:
case|case
name|R_PPC_EMB_NADDR16_HA
case|:
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
name|bad_shared_reloc
argument_list|(
name|abfd
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
break|break;
case|case
name|R_PPC_PLT32
case|:
case|case
name|R_PPC_PLTREL24
case|:
case|case
name|R_PPC_PLTREL32
case|:
case|case
name|R_PPC_PLT16_LO
case|:
case|case
name|R_PPC_PLT16_HI
case|:
case|case
name|R_PPC_PLT16_HA
case|:
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Reloc requires a PLT entry\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* This symbol requires a procedure linkage table entry.  We 	     actually build the entry in finish_dynamic_symbol, 	     because this might be a case of linking PIC code without 	     linking in any dynamic objects, in which case we don't 	     need to generate a procedure linkage table after all.  */
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
block|{
comment|/* It does not make sense to have a procedure linkage 		 table entry for a local symbol.  */
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s(%s+0x%lx): %s reloc against "
literal|"local symbol"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|sec
operator|->
name|name
argument_list|,
operator|(
name|long
operator|)
name|rel
operator|->
name|r_offset
argument_list|,
name|ppc_elf_howto_table
index|[
name|r_type
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_NEEDS_PLT
expr_stmt|;
name|h
operator|->
name|plt
operator|.
name|refcount
operator|++
expr_stmt|;
break|break;
comment|/* The following relocations don't need to propagate the 	     relocation if linking a shared object since they are 	     section relative.  */
case|case
name|R_PPC_SECTOFF
case|:
case|case
name|R_PPC_SECTOFF_LO
case|:
case|case
name|R_PPC_SECTOFF_HI
case|:
case|case
name|R_PPC_SECTOFF_HA
case|:
case|case
name|R_PPC_DTPREL16
case|:
case|case
name|R_PPC_DTPREL16_LO
case|:
case|case
name|R_PPC_DTPREL16_HI
case|:
case|case
name|R_PPC_DTPREL16_HA
case|:
case|case
name|R_PPC_TOC16
case|:
break|break;
comment|/* This are just markers.  */
case|case
name|R_PPC_TLS
case|:
case|case
name|R_PPC_EMB_MRKREF
case|:
case|case
name|R_PPC_NONE
case|:
case|case
name|R_PPC_max
case|:
break|break;
comment|/* These should only appear in dynamic objects.  */
case|case
name|R_PPC_COPY
case|:
case|case
name|R_PPC_GLOB_DAT
case|:
case|case
name|R_PPC_JMP_SLOT
case|:
case|case
name|R_PPC_RELATIVE
case|:
break|break;
comment|/* These aren't handled yet.  We'll report an error later.  */
case|case
name|R_PPC_ADDR30
case|:
case|case
name|R_PPC_EMB_RELSEC16
case|:
case|case
name|R_PPC_EMB_RELST_LO
case|:
case|case
name|R_PPC_EMB_RELST_HI
case|:
case|case
name|R_PPC_EMB_RELST_HA
case|:
case|case
name|R_PPC_EMB_BIT_FLD
case|:
break|break;
comment|/* This refers only to functions defined in the shared library.  */
case|case
name|R_PPC_LOCAL24PC
case|:
break|break;
comment|/* This relocation describes the C++ object vtable hierarchy. 	     Reconstruct it for later use during GC.  */
case|case
name|R_PPC_GNU_VTINHERIT
case|:
if|if
condition|(
operator|!
name|bfd_elf_gc_record_vtinherit
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|h
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
comment|/* This relocation describes which C++ vtable entries are actually 	     used.  Record for later use during GC.  */
case|case
name|R_PPC_GNU_VTENTRY
case|:
if|if
condition|(
operator|!
name|bfd_elf_gc_record_vtentry
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|h
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
comment|/* We shouldn't really be seeing these.  */
case|case
name|R_PPC_TPREL32
case|:
if|if
condition|(
name|info
operator|->
name|shared
condition|)
name|info
operator|->
name|flags
operator||=
name|DF_STATIC_TLS
expr_stmt|;
goto|goto
name|dodyn
goto|;
comment|/* Nor these.  */
case|case
name|R_PPC_DTPMOD32
case|:
case|case
name|R_PPC_DTPREL32
case|:
goto|goto
name|dodyn
goto|;
case|case
name|R_PPC_TPREL16
case|:
case|case
name|R_PPC_TPREL16_LO
case|:
case|case
name|R_PPC_TPREL16_HI
case|:
case|case
name|R_PPC_TPREL16_HA
case|:
if|if
condition|(
name|info
operator|->
name|shared
condition|)
name|info
operator|->
name|flags
operator||=
name|DF_STATIC_TLS
expr_stmt|;
goto|goto
name|dodyn
goto|;
comment|/* When creating a shared object, we must copy these 	     relocs into the output file.  We create a reloc 	     section in dynobj and make room for the reloc.  */
case|case
name|R_PPC_REL24
case|:
case|case
name|R_PPC_REL14
case|:
case|case
name|R_PPC_REL14_BRTAKEN
case|:
case|case
name|R_PPC_REL14_BRNTAKEN
case|:
case|case
name|R_PPC_REL32
case|:
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|)
operator|==
literal|0
condition|)
break|break;
comment|/* fall through */
case|case
name|R_PPC_ADDR32
case|:
case|case
name|R_PPC_ADDR24
case|:
case|case
name|R_PPC_ADDR16
case|:
case|case
name|R_PPC_ADDR16_LO
case|:
case|case
name|R_PPC_ADDR16_HI
case|:
case|case
name|R_PPC_ADDR16_HA
case|:
case|case
name|R_PPC_ADDR14
case|:
case|case
name|R_PPC_ADDR14_BRTAKEN
case|:
case|case
name|R_PPC_ADDR14_BRNTAKEN
case|:
case|case
name|R_PPC_UADDR32
case|:
case|case
name|R_PPC_UADDR16
case|:
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|!
name|info
operator|->
name|shared
condition|)
block|{
comment|/* We may need a plt entry if the symbol turns out to be 		 a function defined in a dynamic object.  */
name|h
operator|->
name|plt
operator|.
name|refcount
operator|++
expr_stmt|;
comment|/* We may need a copy reloc too.  */
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_NON_GOT_REF
expr_stmt|;
block|}
name|dodyn
label|:
comment|/* If we are creating a shared library, and this is a reloc 	     against a global symbol, or a non PC relative reloc 	     against a local symbol, then we need to copy the reloc 	     into the shared library.  However, if we are linking with 	     -Bsymbolic, we do not need to copy a reloc against a 	     global symbol which is defined in an object we are 	     including in the link (i.e., DEF_REGULAR is set).  At 	     this point we have not seen all the input files, so it is 	     possible that DEF_REGULAR is not set now but will be set 	     later (it is never cleared).  In case of a weak definition, 	     DEF_REGULAR may be cleared later by a strong definition in 	     a shared library.  We account for that possibility below by 	     storing information in the dyn_relocs field of the hash 	     table entry.  A similar situation occurs when creating 	     shared libraries and symbol visibility changes render the 	     symbol local.  	     If on the other hand, we are creating an executable, we 	     may need to keep relocations for symbols satisfied by a 	     dynamic library if we manage to avoid copy relocs for the 	     symbol.  */
if|if
condition|(
operator|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|MUST_BE_DYN_RELOC
argument_list|(
name|r_type
argument_list|)
operator|||
operator|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
operator|!
name|info
operator|->
name|symbolic
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|ELIMINATE_COPY_RELOCS
operator|&&
operator|!
name|info
operator|->
name|shared
operator|&&
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
operator|&&
name|h
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|struct
name|ppc_elf_dyn_relocs
modifier|*
name|p
decl_stmt|;
name|struct
name|ppc_elf_dyn_relocs
modifier|*
modifier|*
name|head
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ppc_elf_check_relocs needs to "
literal|"create relocation for %s\n"
argument_list|,
operator|(
name|h
operator|&&
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
condition|?
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
else|:
literal|"<unknown>"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
operator|(
name|bfd_elf_string_from_elf_section
argument_list|(
name|abfd
argument_list|,
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_shstrndx
argument_list|,
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|rel_hdr
operator|.
name|sh_name
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|BFD_ASSERT
argument_list|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".rela"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|,
name|name
operator|+
literal|5
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|sreloc
operator|=
name|bfd_get_section_by_name
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
block|{
name|flagword
name|flags
decl_stmt|;
name|sreloc
operator|=
name|bfd_make_section
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|flags
operator|=
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_READONLY
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
name|flags
operator||=
name|SEC_ALLOC
operator||
name|SEC_LOAD
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|sreloc
argument_list|,
name|flags
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|sreloc
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|sreloc
operator|=
name|sreloc
expr_stmt|;
block|}
comment|/* If this is a global symbol, we count the number of 		 relocations we need for this symbol.  */
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|head
operator|=
operator|&
name|ppc_elf_hash_entry
argument_list|(
name|h
argument_list|)
operator|->
name|dyn_relocs
expr_stmt|;
block|}
else|else
block|{
comment|/* Track dynamic relocs needed for local syms too. 		     We really need local syms available to do this 		     easily.  Oh well.  */
name|asection
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|bfd_section_from_r_symndx
argument_list|(
name|abfd
argument_list|,
operator|&
name|htab
operator|->
name|sym_sec
argument_list|,
name|sec
argument_list|,
name|r_symndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|head
operator|=
operator|(
operator|(
expr|struct
name|ppc_elf_dyn_relocs
operator|*
operator|*
operator|)
operator|&
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|local_dynrel
operator|)
expr_stmt|;
block|}
name|p
operator|=
operator|*
name|head
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|p
operator|->
name|sec
operator|!=
name|sec
condition|)
block|{
name|p
operator|=
name|bfd_alloc
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
sizeof|sizeof
expr|*
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|p
operator|->
name|next
operator|=
operator|*
name|head
expr_stmt|;
operator|*
name|head
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|sec
operator|=
name|sec
expr_stmt|;
name|p
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|pc_count
operator|=
literal|0
expr_stmt|;
block|}
name|p
operator|->
name|count
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|MUST_BE_DYN_RELOC
argument_list|(
name|r_type
argument_list|)
condition|)
name|p
operator|->
name|pc_count
operator|+=
literal|1
expr_stmt|;
block|}
break|break;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return the section that should be marked against GC for a given    relocation.  */
end_comment

begin_function
specifier|static
name|asection
modifier|*
name|ppc_elf_gc_mark_hook
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|rel
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|)
block|{
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_PPC_GNU_VTINHERIT
case|:
case|case
name|R_PPC_GNU_VTENTRY
case|:
break|break;
default|default:
switch|switch
condition|(
name|h
operator|->
name|root
operator|.
name|type
condition|)
block|{
case|case
name|bfd_link_hash_defined
case|:
case|case
name|bfd_link_hash_defweak
case|:
return|return
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
return|;
case|case
name|bfd_link_hash_common
case|:
return|return
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
return|;
default|default:
break|break;
block|}
block|}
block|}
else|else
return|return
name|bfd_section_from_elf_index
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|sym
operator|->
name|st_shndx
argument_list|)
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Update the got, plt and dynamic reloc reference counts for the    section being removed.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc_elf_gc_sweep_hook
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
parameter_list|)
block|{
name|struct
name|ppc_elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|bfd_signed_vma
modifier|*
name|local_got_refcounts
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|,
modifier|*
name|relend
decl_stmt|;
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|local_dynrel
operator|=
name|NULL
expr_stmt|;
name|htab
operator|=
name|ppc_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|local_got_refcounts
operator|=
name|elf_local_got_refcounts
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|enum
name|elf_ppc_reloc_type
name|r_type
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
init|=
name|NULL
decl_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|>=
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|struct
name|ppc_elf_dyn_relocs
modifier|*
modifier|*
name|pp
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|struct
name|ppc_elf_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|ppc_elf_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
for|for
control|(
name|pp
operator|=
operator|&
name|eh
operator|->
name|dyn_relocs
init|;
operator|(
name|p
operator|=
operator|*
name|pp
operator|)
operator|!=
name|NULL
condition|;
name|pp
operator|=
operator|&
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|sec
operator|==
name|sec
condition|)
block|{
comment|/* Everything must go for SEC.  */
operator|*
name|pp
operator|=
name|p
operator|->
name|next
expr_stmt|;
break|break;
block|}
block|}
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_PPC_GOT_TLSLD16
case|:
case|case
name|R_PPC_GOT_TLSLD16_LO
case|:
case|case
name|R_PPC_GOT_TLSLD16_HI
case|:
case|case
name|R_PPC_GOT_TLSLD16_HA
case|:
name|htab
operator|->
name|tlsld_got
operator|.
name|refcount
operator|-=
literal|1
expr_stmt|;
comment|/* Fall thru */
case|case
name|R_PPC_GOT_TLSGD16
case|:
case|case
name|R_PPC_GOT_TLSGD16_LO
case|:
case|case
name|R_PPC_GOT_TLSGD16_HI
case|:
case|case
name|R_PPC_GOT_TLSGD16_HA
case|:
case|case
name|R_PPC_GOT_TPREL16
case|:
case|case
name|R_PPC_GOT_TPREL16_LO
case|:
case|case
name|R_PPC_GOT_TPREL16_HI
case|:
case|case
name|R_PPC_GOT_TPREL16_HA
case|:
case|case
name|R_PPC_GOT_DTPREL16
case|:
case|case
name|R_PPC_GOT_DTPREL16_LO
case|:
case|case
name|R_PPC_GOT_DTPREL16_HI
case|:
case|case
name|R_PPC_GOT_DTPREL16_HA
case|:
case|case
name|R_PPC_GOT16
case|:
case|case
name|R_PPC_GOT16_LO
case|:
case|case
name|R_PPC_GOT16_HI
case|:
case|case
name|R_PPC_GOT16_HA
case|:
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|refcount
operator|>
literal|0
condition|)
name|h
operator|->
name|got
operator|.
name|refcount
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|local_got_refcounts
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|local_got_refcounts
index|[
name|r_symndx
index|]
operator|>
literal|0
condition|)
name|local_got_refcounts
index|[
name|r_symndx
index|]
operator|--
expr_stmt|;
block|}
break|break;
case|case
name|R_PPC_REL24
case|:
case|case
name|R_PPC_REL14
case|:
case|case
name|R_PPC_REL14_BRTAKEN
case|:
case|case
name|R_PPC_REL14_BRNTAKEN
case|:
case|case
name|R_PPC_REL32
case|:
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|)
operator|==
literal|0
condition|)
break|break;
comment|/* Fall thru */
case|case
name|R_PPC_ADDR32
case|:
case|case
name|R_PPC_ADDR24
case|:
case|case
name|R_PPC_ADDR16
case|:
case|case
name|R_PPC_ADDR16_LO
case|:
case|case
name|R_PPC_ADDR16_HI
case|:
case|case
name|R_PPC_ADDR16_HA
case|:
case|case
name|R_PPC_ADDR14
case|:
case|case
name|R_PPC_ADDR14_BRTAKEN
case|:
case|case
name|R_PPC_ADDR14_BRNTAKEN
case|:
case|case
name|R_PPC_UADDR32
case|:
case|case
name|R_PPC_UADDR16
case|:
case|case
name|R_PPC_PLT32
case|:
case|case
name|R_PPC_PLTREL24
case|:
case|case
name|R_PPC_PLT16_LO
case|:
case|case
name|R_PPC_PLT16_HI
case|:
case|case
name|R_PPC_PLT16_HA
case|:
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|refcount
operator|>
literal|0
condition|)
name|h
operator|->
name|plt
operator|.
name|refcount
operator|--
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Set htab->tls_get_addr and call the generic ELF tls_setup function.  */
end_comment

begin_function
name|asection
modifier|*
name|ppc_elf_tls_setup
parameter_list|(
name|bfd
modifier|*
name|obfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|ppc_elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|htab
operator|=
name|ppc_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|htab
operator|->
name|tls_get_addr
operator|=
name|elf_link_hash_lookup
argument_list|(
operator|&
name|htab
operator|->
name|elf
argument_list|,
literal|"__tls_get_addr"
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|_bfd_elf_tls_setup
argument_list|(
name|obfd
argument_list|,
name|info
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Run through all the TLS relocs looking for optimization    opportunities.  */
end_comment

begin_function
name|bfd_boolean
name|ppc_elf_tls_optimize
parameter_list|(
name|bfd
modifier|*
name|obfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|ppc_elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
operator|||
name|info
operator|->
name|shared
condition|)
return|return
name|TRUE
return|;
name|htab
operator|=
name|ppc_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
for|for
control|(
name|ibfd
operator|=
name|info
operator|->
name|input_bfds
init|;
name|ibfd
operator|!=
name|NULL
condition|;
name|ibfd
operator|=
name|ibfd
operator|->
name|link_next
control|)
block|{
name|Elf_Internal_Sym
modifier|*
name|locsyms
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
init|=
operator|&
name|elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|symtab_hdr
decl_stmt|;
for|for
control|(
name|sec
operator|=
name|ibfd
operator|->
name|sections
init|;
name|sec
operator|!=
name|NULL
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
if|if
condition|(
name|sec
operator|->
name|has_tls_reloc
operator|&&
operator|!
name|bfd_is_abs_section
argument_list|(
name|sec
operator|->
name|output_section
argument_list|)
condition|)
block|{
name|Elf_Internal_Rela
modifier|*
name|relstart
decl_stmt|,
modifier|*
name|rel
decl_stmt|,
modifier|*
name|relend
decl_stmt|;
name|int
name|expecting_tls_get_addr
decl_stmt|;
comment|/* Read the relocations.  */
name|relstart
operator|=
name|_bfd_elf_link_read_relocs
argument_list|(
name|ibfd
argument_list|,
name|sec
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|relstart
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|expecting_tls_get_addr
operator|=
literal|0
expr_stmt|;
name|relend
operator|=
name|relstart
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relstart
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|enum
name|elf_ppc_reloc_type
name|r_type
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|tls_mask
decl_stmt|;
name|char
name|tls_set
decl_stmt|,
name|tls_clear
decl_stmt|;
name|bfd_boolean
name|is_local
decl_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|>=
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|ibfd
argument_list|)
expr_stmt|;
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
block|}
name|is_local
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
operator|!
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
condition|)
name|is_local
operator|=
name|TRUE
expr_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_PPC_GOT_TLSLD16
case|:
case|case
name|R_PPC_GOT_TLSLD16_LO
case|:
case|case
name|R_PPC_GOT_TLSLD16_HI
case|:
case|case
name|R_PPC_GOT_TLSLD16_HA
case|:
comment|/* These relocs should never be against a symbol 		       defined in a shared lib.  Leave them alone if 		       that turns out to be the case.  */
name|expecting_tls_get_addr
operator|=
literal|0
expr_stmt|;
name|htab
operator|->
name|tlsld_got
operator|.
name|refcount
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|is_local
condition|)
continue|continue;
comment|/* LD -> LE */
name|tls_set
operator|=
literal|0
expr_stmt|;
name|tls_clear
operator|=
name|TLS_LD
expr_stmt|;
name|expecting_tls_get_addr
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|R_PPC_GOT_TLSGD16
case|:
case|case
name|R_PPC_GOT_TLSGD16_LO
case|:
case|case
name|R_PPC_GOT_TLSGD16_HI
case|:
case|case
name|R_PPC_GOT_TLSGD16_HA
case|:
if|if
condition|(
name|is_local
condition|)
comment|/* GD -> LE */
name|tls_set
operator|=
literal|0
expr_stmt|;
else|else
comment|/* GD -> IE */
name|tls_set
operator|=
name|TLS_TLS
operator||
name|TLS_TPRELGD
expr_stmt|;
name|tls_clear
operator|=
name|TLS_GD
expr_stmt|;
name|expecting_tls_get_addr
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|R_PPC_GOT_TPREL16
case|:
case|case
name|R_PPC_GOT_TPREL16_LO
case|:
case|case
name|R_PPC_GOT_TPREL16_HI
case|:
case|case
name|R_PPC_GOT_TPREL16_HA
case|:
name|expecting_tls_get_addr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|is_local
condition|)
block|{
comment|/* IE -> LE */
name|tls_set
operator|=
literal|0
expr_stmt|;
name|tls_clear
operator|=
name|TLS_TPREL
expr_stmt|;
break|break;
block|}
else|else
continue|continue;
case|case
name|R_PPC_REL14
case|:
case|case
name|R_PPC_REL14_BRTAKEN
case|:
case|case
name|R_PPC_REL14_BRNTAKEN
case|:
case|case
name|R_PPC_REL24
case|:
if|if
condition|(
name|expecting_tls_get_addr
operator|&&
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|==
name|htab
operator|->
name|tls_get_addr
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|refcount
operator|>
literal|0
condition|)
name|h
operator|->
name|plt
operator|.
name|refcount
operator|-=
literal|1
expr_stmt|;
block|}
name|expecting_tls_get_addr
operator|=
literal|0
expr_stmt|;
continue|continue;
default|default:
name|expecting_tls_get_addr
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|tls_set
operator|==
literal|0
condition|)
block|{
comment|/* We managed to get rid of a got entry.  */
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|refcount
operator|>
literal|0
condition|)
name|h
operator|->
name|got
operator|.
name|refcount
operator|-=
literal|1
expr_stmt|;
block|}
name|tls_mask
operator|=
operator|&
name|ppc_elf_hash_entry
argument_list|(
name|h
argument_list|)
operator|->
name|tls_mask
expr_stmt|;
block|}
else|else
block|{
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|bfd_signed_vma
modifier|*
name|lgot_refs
decl_stmt|;
name|char
modifier|*
name|lgot_masks
decl_stmt|;
if|if
condition|(
name|locsyms
operator|==
name|NULL
condition|)
block|{
name|locsyms
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
if|if
condition|(
name|locsyms
operator|==
name|NULL
condition|)
name|locsyms
operator|=
name|bfd_elf_get_elf_syms
argument_list|(
name|ibfd
argument_list|,
name|symtab_hdr
argument_list|,
name|symtab_hdr
operator|->
name|sh_info
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|locsyms
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|!=
name|relstart
condition|)
name|free
argument_list|(
name|relstart
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
name|sym
operator|=
name|locsyms
operator|+
name|r_symndx
expr_stmt|;
name|lgot_refs
operator|=
name|elf_local_got_refcounts
argument_list|(
name|ibfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|lgot_refs
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|tls_set
operator|==
literal|0
condition|)
block|{
comment|/* We managed to get rid of a got entry.  */
if|if
condition|(
name|lgot_refs
index|[
name|r_symndx
index|]
operator|>
literal|0
condition|)
name|lgot_refs
index|[
name|r_symndx
index|]
operator|-=
literal|1
expr_stmt|;
block|}
name|lgot_masks
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|lgot_refs
operator|+
name|symtab_hdr
operator|->
name|sh_info
operator|)
expr_stmt|;
name|tls_mask
operator|=
operator|&
name|lgot_masks
index|[
name|r_symndx
index|]
expr_stmt|;
block|}
operator|*
name|tls_mask
operator||=
name|tls_set
expr_stmt|;
operator|*
name|tls_mask
operator|&=
operator|~
name|tls_clear
expr_stmt|;
block|}
if|if
condition|(
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|!=
name|relstart
condition|)
name|free
argument_list|(
name|relstart
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|locsyms
operator|!=
name|NULL
operator|&&
operator|(
name|symtab_hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|locsyms
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|locsyms
argument_list|)
expr_stmt|;
else|else
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|locsyms
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Hook called by the linker routine which adds symbols from an object    file.  We use it to put .comm items in .sbss, and not .bss.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc_elf_add_symbol_hook
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|namep
name|ATTRIBUTE_UNUSED
parameter_list|,
name|flagword
modifier|*
name|flagsp
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
modifier|*
name|secp
parameter_list|,
name|bfd_vma
modifier|*
name|valp
parameter_list|)
block|{
if|if
condition|(
name|sym
operator|->
name|st_shndx
operator|==
name|SHN_COMMON
operator|&&
operator|!
name|info
operator|->
name|relocatable
operator|&&
name|sym
operator|->
name|st_size
operator|<=
name|elf_gp_size
argument_list|(
name|abfd
argument_list|)
operator|&&
operator|(
name|info
operator|->
name|hash
operator|->
name|creator
operator|==
name|abfd
operator|->
name|xvec
operator|||
name|info
operator|->
name|hash
operator|->
name|creator
operator|==
name|abfd
operator|->
name|xvec
operator|->
name|alternative_target
operator|)
condition|)
block|{
comment|/* Common symbols less than or equal to -G nn bytes are automatically 	 put into .sbss.  */
name|struct
name|ppc_elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|htab
operator|=
name|ppc_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|sbss
operator|==
name|NULL
condition|)
block|{
name|flagword
name|flags
init|=
name|SEC_IS_COMMON
decl_stmt|;
name|htab
operator|->
name|sbss
operator|=
name|bfd_make_section_anyway
argument_list|(
name|abfd
argument_list|,
literal|".sbss"
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|sbss
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|htab
operator|->
name|sbss
argument_list|,
name|flags
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
operator|*
name|secp
operator|=
name|htab
operator|->
name|sbss
expr_stmt|;
operator|*
name|valp
operator|=
name|sym
operator|->
name|st_size
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Finish up dynamic symbol handling.  We set the contents of various    dynamic sections here.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc_elf_finish_dynamic_symbol
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|)
block|{
name|struct
name|ppc_elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ppc_elf_finish_dynamic_symbol called for %s"
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|htab
operator|=
name|ppc_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
name|Elf_Internal_Rela
name|rela
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|bfd_vma
name|reloc_index
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", plt_offset = %d"
argument_list|,
name|h
operator|->
name|plt
operator|.
name|offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* This symbol has an entry in the procedure linkage table.  Set 	 it up.  */
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|htab
operator|->
name|plt
operator|!=
name|NULL
operator|&&
name|htab
operator|->
name|relplt
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* We don't need to fill in the .plt.  The ppc dynamic linker 	 will fill it in.  */
comment|/* Fill in the entry in the .rela.plt section.  */
name|rela
operator|.
name|r_offset
operator|=
operator|(
name|htab
operator|->
name|plt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|plt
operator|->
name|output_offset
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|)
expr_stmt|;
name|rela
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_PPC_JMP_SLOT
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
name|reloc_index
operator|=
operator|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|-
name|PLT_INITIAL_ENTRY_SIZE
operator|)
operator|/
name|PLT_SLOT_SIZE
expr_stmt|;
if|if
condition|(
name|reloc_index
operator|>
name|PLT_NUM_SINGLE_ENTRIES
condition|)
name|reloc_index
operator|-=
operator|(
name|reloc_index
operator|-
name|PLT_NUM_SINGLE_ENTRIES
operator|)
operator|/
literal|2
expr_stmt|;
name|loc
operator|=
operator|(
name|htab
operator|->
name|relplt
operator|->
name|contents
operator|+
name|reloc_index
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
operator|)
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rela
argument_list|,
name|loc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Mark the symbol as undefined, rather than as defined in 	     the .plt section.  Leave the value alone.  */
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_UNDEF
expr_stmt|;
comment|/* If the symbol is weak, we do need to clear the value. 	     Otherwise, the PLT entry would provide a definition for 	     the symbol even if the symbol wasn't defined anywhere, 	     and so the symbol would never be NULL.  */
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_REF_REGULAR_NONWEAK
operator|)
operator|==
literal|0
condition|)
name|sym
operator|->
name|st_value
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_NEEDS_COPY
operator|)
operator|!=
literal|0
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|Elf_Internal_Rela
name|rela
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
comment|/* This symbols needs a copy reloc.  Set it up.  */
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", copy"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|size
operator|<=
name|elf_gp_size
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|)
condition|)
name|s
operator|=
name|htab
operator|->
name|relsbss
expr_stmt|;
else|else
name|s
operator|=
name|htab
operator|->
name|relbss
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_offset
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|rela
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_PPC_COPY
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
name|loc
operator|=
name|s
operator|->
name|contents
operator|+
name|s
operator|->
name|reloc_count
operator|++
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rela
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Mark some specially defined symbols as absolute.  */
if|if
condition|(
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_DYNAMIC"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_PROCEDURE_LINKAGE_TABLE_"
argument_list|)
operator|==
literal|0
condition|)
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_ABS
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Finish up the dynamic sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc_elf_finish_dynamic_sections
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|asection
modifier|*
name|sdyn
decl_stmt|;
name|struct
name|ppc_elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ppc_elf_finish_dynamic_sections called\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|htab
operator|=
name|ppc_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|sdyn
operator|=
name|bfd_get_section_by_name
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|elf
operator|.
name|dynamic_sections_created
condition|)
block|{
name|Elf32_External_Dyn
modifier|*
name|dyncon
decl_stmt|,
modifier|*
name|dynconend
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|htab
operator|->
name|plt
operator|!=
name|NULL
operator|&&
name|sdyn
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dyncon
operator|=
operator|(
name|Elf32_External_Dyn
operator|*
operator|)
name|sdyn
operator|->
name|contents
expr_stmt|;
name|dynconend
operator|=
operator|(
name|Elf32_External_Dyn
operator|*
operator|)
operator|(
name|sdyn
operator|->
name|contents
operator|+
name|sdyn
operator|->
name|_raw_size
operator|)
expr_stmt|;
for|for
control|(
init|;
name|dyncon
operator|<
name|dynconend
condition|;
name|dyncon
operator|++
control|)
block|{
name|Elf_Internal_Dyn
name|dyn
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_elf32_swap_dyn_in
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|dyncon
argument_list|,
operator|&
name|dyn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dyn
operator|.
name|d_tag
condition|)
block|{
case|case
name|DT_PLTGOT
case|:
name|s
operator|=
name|htab
operator|->
name|plt
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|s
operator|->
name|output_section
operator|->
name|vma
operator|+
name|s
operator|->
name|output_offset
expr_stmt|;
break|break;
case|case
name|DT_PLTRELSZ
case|:
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|htab
operator|->
name|relplt
operator|->
name|_raw_size
expr_stmt|;
break|break;
case|case
name|DT_JMPREL
case|:
name|s
operator|=
name|htab
operator|->
name|relplt
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|s
operator|->
name|output_section
operator|->
name|vma
operator|+
name|s
operator|->
name|output_offset
expr_stmt|;
break|break;
default|default:
continue|continue;
block|}
name|bfd_elf32_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Add a blrl instruction at _GLOBAL_OFFSET_TABLE_-4 so that a function can      easily find the address of the _GLOBAL_OFFSET_TABLE_.  */
if|if
condition|(
name|htab
operator|->
name|got
condition|)
block|{
name|unsigned
name|char
modifier|*
name|contents
init|=
name|htab
operator|->
name|got
operator|->
name|contents
decl_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
literal|0x4e800021
comment|/* blrl */
argument_list|,
name|contents
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdyn
operator|==
name|NULL
condition|)
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
literal|0
argument_list|,
name|contents
operator|+
literal|4
argument_list|)
expr_stmt|;
else|else
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|sdyn
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sdyn
operator|->
name|output_offset
argument_list|,
name|contents
operator|+
literal|4
argument_list|)
expr_stmt|;
name|elf_section_data
argument_list|(
name|htab
operator|->
name|got
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
operator|=
literal|4
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The RELOCATE_SECTION function is called by the ELF backend linker    to handle the relocations for a section.     The relocs are always passed as Rela structures; if the section    actually uses Rel structures, the r_addend field will always be    zero.     This function is responsible for adjust the section contents as    necessary, and (if using Rela relocs and generating a    relocatable output file) adjusting the reloc addend as    necessary.     This function does not have to worry about setting the reloc    address or the reloc symbol index.     LOCAL_SYMS is a pointer to the swapped in local symbols.     LOCAL_SECTIONS is an array giving the section in the input file    corresponding to the st_shndx field of each local symbol.     The global hash table entry for the global symbols can be found    via elf_sym_hashes (input_bfd).     When generating relocatable output, this function must handle    STB_LOCAL/STT_SECTION symbols specially.  The output symbol is    going to be the section symbol corresponding to the output    section, which means that the addend must be adjusted    accordingly.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc_elf_relocate_section
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|relocs
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|local_syms
parameter_list|,
name|asection
modifier|*
modifier|*
name|local_sections
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|struct
name|ppc_elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relend
decl_stmt|;
name|Elf_Internal_Rela
name|outrel
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|asection
modifier|*
name|sreloc
init|=
name|NULL
decl_stmt|;
name|bfd_vma
modifier|*
name|local_got_offsets
decl_stmt|;
name|bfd_boolean
name|ret
init|=
name|TRUE
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ppc_elf_relocate_section called for %s section %s, "
literal|"%ld relocations%s\n"
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|bfd_section_name
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|input_section
operator|->
name|reloc_count
argument_list|,
operator|(
name|info
operator|->
name|relocatable
operator|)
condition|?
literal|" (relocatable)"
else|:
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
return|return
name|TRUE
return|;
comment|/* Initialize howto table if not already done.  */
if|if
condition|(
operator|!
name|ppc_elf_howto_table
index|[
name|R_PPC_ADDR32
index|]
condition|)
name|ppc_elf_howto_init
argument_list|()
expr_stmt|;
name|htab
operator|=
name|ppc_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|local_got_offsets
operator|=
name|elf_local_got_offsets
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|rel
operator|=
name|relocs
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|input_section
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|enum
name|elf_ppc_reloc_type
name|r_type
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|;
name|bfd_reloc_status_type
name|r
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
specifier|const
name|char
modifier|*
name|sym_name
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_vma
name|branch_bit
decl_stmt|,
name|insn
decl_stmt|,
name|from
decl_stmt|;
name|bfd_boolean
name|unresolved_reloc
decl_stmt|;
name|bfd_boolean
name|warned
decl_stmt|;
name|unsigned
name|int
name|tls_type
decl_stmt|,
name|tls_mask
decl_stmt|,
name|tls_gd
decl_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|sym
operator|=
name|NULL
expr_stmt|;
name|sec
operator|=
name|NULL
expr_stmt|;
name|h
operator|=
name|NULL
expr_stmt|;
name|unresolved_reloc
operator|=
name|FALSE
expr_stmt|;
name|warned
operator|=
name|FALSE
expr_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|sym_name
operator|=
name|bfd_elf_local_sym_name
argument_list|(
name|input_bfd
argument_list|,
name|sym
argument_list|)
expr_stmt|;
name|relocation
operator|=
name|_bfd_elf_rela_local_sym
argument_list|(
name|output_bfd
argument_list|,
name|sym
argument_list|,
operator|&
name|sec
argument_list|,
name|rel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|RELOC_FOR_GLOBAL_SYMBOL
argument_list|(
name|info
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
argument_list|,
name|r_symndx
argument_list|,
name|symtab_hdr
argument_list|,
name|sym_hashes
argument_list|,
name|h
argument_list|,
name|sec
argument_list|,
name|relocation
argument_list|,
name|unresolved_reloc
argument_list|,
name|warned
argument_list|)
expr_stmt|;
name|sym_name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
block|}
comment|/* TLS optimizations.  Replace instruction sequences and relocs 	 based on information we collected in tls_optimize.  We edit 	 RELOCS so that --emit-relocs will output something sensible 	 for the final instruction stream.  */
name|tls_mask
operator|=
literal|0
expr_stmt|;
name|tls_gd
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|IS_PPC_TLS_RELOC
argument_list|(
name|r_type
argument_list|)
condition|)
block|{
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|tls_mask
operator|=
operator|(
operator|(
expr|struct
name|ppc_elf_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|tls_mask
expr_stmt|;
elseif|else
if|if
condition|(
name|local_got_offsets
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|lgot_masks
decl_stmt|;
name|lgot_masks
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|local_got_offsets
operator|+
name|symtab_hdr
operator|->
name|sh_info
operator|)
expr_stmt|;
name|tls_mask
operator|=
name|lgot_masks
index|[
name|r_symndx
index|]
expr_stmt|;
block|}
block|}
comment|/* Ensure reloc mapping code below stays sane.  */
if|if
condition|(
operator|(
name|R_PPC_GOT_TLSLD16
operator|&
literal|3
operator|)
operator|!=
operator|(
name|R_PPC_GOT_TLSGD16
operator|&
literal|3
operator|)
operator|||
operator|(
name|R_PPC_GOT_TLSLD16_LO
operator|&
literal|3
operator|)
operator|!=
operator|(
name|R_PPC_GOT_TLSGD16_LO
operator|&
literal|3
operator|)
operator|||
operator|(
name|R_PPC_GOT_TLSLD16_HI
operator|&
literal|3
operator|)
operator|!=
operator|(
name|R_PPC_GOT_TLSGD16_HI
operator|&
literal|3
operator|)
operator|||
operator|(
name|R_PPC_GOT_TLSLD16_HA
operator|&
literal|3
operator|)
operator|!=
operator|(
name|R_PPC_GOT_TLSGD16_HA
operator|&
literal|3
operator|)
operator|||
operator|(
name|R_PPC_GOT_TLSLD16
operator|&
literal|3
operator|)
operator|!=
operator|(
name|R_PPC_GOT_TPREL16
operator|&
literal|3
operator|)
operator|||
operator|(
name|R_PPC_GOT_TLSLD16_LO
operator|&
literal|3
operator|)
operator|!=
operator|(
name|R_PPC_GOT_TPREL16_LO
operator|&
literal|3
operator|)
operator|||
operator|(
name|R_PPC_GOT_TLSLD16_HI
operator|&
literal|3
operator|)
operator|!=
operator|(
name|R_PPC_GOT_TPREL16_HI
operator|&
literal|3
operator|)
operator|||
operator|(
name|R_PPC_GOT_TLSLD16_HA
operator|&
literal|3
operator|)
operator|!=
operator|(
name|R_PPC_GOT_TPREL16_HA
operator|&
literal|3
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
default|default:
break|break;
case|case
name|R_PPC_GOT_TPREL16
case|:
case|case
name|R_PPC_GOT_TPREL16_LO
case|:
if|if
condition|(
name|tls_mask
operator|!=
literal|0
operator|&&
operator|(
name|tls_mask
operator|&
name|TLS_TPREL
operator|)
operator|==
literal|0
condition|)
block|{
name|bfd_vma
name|insn
decl_stmt|;
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|output_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|-
literal|2
argument_list|)
expr_stmt|;
name|insn
operator|&=
literal|31
operator|<<
literal|21
expr_stmt|;
name|insn
operator||=
literal|0x3c020000
expr_stmt|;
comment|/* addis 0,2,0 */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|insn
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|-
literal|2
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|R_PPC_TPREL16_HA
expr_stmt|;
name|rel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|r_symndx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|R_PPC_TLS
case|:
if|if
condition|(
name|tls_mask
operator|!=
literal|0
operator|&&
operator|(
name|tls_mask
operator|&
name|TLS_TPREL
operator|)
operator|==
literal|0
condition|)
block|{
name|bfd_vma
name|insn
decl_stmt|,
name|rtra
decl_stmt|;
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|output_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|insn
operator|&
operator|(
operator|(
literal|31
operator|<<
literal|26
operator|)
operator||
operator|(
literal|31
operator|<<
literal|11
operator|)
operator|)
operator|)
operator|==
operator|(
operator|(
literal|31
operator|<<
literal|26
operator|)
operator||
operator|(
literal|2
operator|<<
literal|11
operator|)
operator|)
condition|)
name|rtra
operator|=
name|insn
operator|&
operator|(
operator|(
literal|1
operator|<<
literal|26
operator|)
operator|-
operator|(
literal|1
operator|<<
literal|16
operator|)
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
operator|(
operator|(
literal|31
operator|<<
literal|26
operator|)
operator||
operator|(
literal|31
operator|<<
literal|16
operator|)
operator|)
operator|)
operator|==
operator|(
operator|(
literal|31
operator|<<
literal|26
operator|)
operator||
operator|(
literal|2
operator|<<
literal|16
operator|)
operator|)
condition|)
name|rtra
operator|=
operator|(
name|insn
operator|&
operator|(
literal|31
operator|<<
literal|21
operator|)
operator|)
operator||
operator|(
operator|(
name|insn
operator|&
operator|(
literal|31
operator|<<
literal|11
operator|)
operator|)
operator|<<
literal|5
operator|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|insn
operator|&
operator|(
operator|(
literal|1
operator|<<
literal|11
operator|)
operator|-
operator|(
literal|1
operator|<<
literal|1
operator|)
operator|)
operator|)
operator|==
literal|266
operator|<<
literal|1
condition|)
comment|/* add -> addi.  */
name|insn
operator|=
literal|14
operator|<<
literal|26
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
operator|(
literal|31
operator|<<
literal|1
operator|)
operator|)
operator|==
literal|23
operator|<<
literal|1
operator|&&
operator|(
operator|(
name|insn
operator|&
operator|(
literal|31
operator|<<
literal|6
operator|)
operator|)
operator|<
literal|14
operator|<<
literal|6
operator|||
operator|(
operator|(
name|insn
operator|&
operator|(
literal|31
operator|<<
literal|6
operator|)
operator|)
operator|>=
literal|16
operator|<<
literal|6
operator|&&
operator|(
name|insn
operator|&
operator|(
literal|31
operator|<<
literal|6
operator|)
operator|)
operator|<
literal|24
operator|<<
literal|6
operator|)
operator|)
condition|)
comment|/* load and store indexed -> dform.  */
name|insn
operator|=
operator|(
literal|32
operator||
operator|(
operator|(
name|insn
operator|>>
literal|6
operator|)
operator|&
literal|31
operator|)
operator|)
operator|<<
literal|26
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
operator|(
literal|31
operator|<<
literal|1
operator|)
operator|)
operator|==
literal|21
operator|<<
literal|1
operator|&&
operator|(
name|insn
operator|&
operator|(
literal|0x1a
operator|<<
literal|6
operator|)
operator|)
operator|==
literal|0
condition|)
comment|/* ldx, ldux, stdx, stdux -> ld, ldu, std, stdu.  */
name|insn
operator|=
operator|(
operator|(
operator|(
literal|58
operator||
operator|(
operator|(
name|insn
operator|>>
literal|6
operator|)
operator|&
literal|4
operator|)
operator|)
operator|<<
literal|26
operator|)
operator||
operator|(
operator|(
name|insn
operator|>>
literal|6
operator|)
operator|&
literal|1
operator|)
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
operator|(
literal|31
operator|<<
literal|1
operator|)
operator|)
operator|==
literal|21
operator|<<
literal|1
operator|&&
operator|(
name|insn
operator|&
operator|(
operator|(
literal|1
operator|<<
literal|11
operator|)
operator|-
operator|(
literal|1
operator|<<
literal|1
operator|)
operator|)
operator|)
operator|==
literal|341
operator|<<
literal|1
condition|)
comment|/* lwax -> lwa.  */
name|insn
operator|=
operator|(
literal|58
operator|<<
literal|26
operator|)
operator||
literal|2
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|insn
operator||=
name|rtra
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|insn
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|R_PPC_TPREL16_LO
expr_stmt|;
name|rel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|r_symndx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
comment|/* Was PPC_TLS which sits on insn boundary, now 		 PPC_TPREL16_LO which is at insn+2.  */
name|rel
operator|->
name|r_offset
operator|+=
literal|2
expr_stmt|;
block|}
break|break;
case|case
name|R_PPC_GOT_TLSGD16_HI
case|:
case|case
name|R_PPC_GOT_TLSGD16_HA
case|:
name|tls_gd
operator|=
name|TLS_TPRELGD
expr_stmt|;
if|if
condition|(
name|tls_mask
operator|!=
literal|0
operator|&&
operator|(
name|tls_mask
operator|&
name|TLS_GD
operator|)
operator|==
literal|0
condition|)
goto|goto
name|tls_gdld_hi
goto|;
break|break;
case|case
name|R_PPC_GOT_TLSLD16_HI
case|:
case|case
name|R_PPC_GOT_TLSLD16_HA
case|:
if|if
condition|(
name|tls_mask
operator|!=
literal|0
operator|&&
operator|(
name|tls_mask
operator|&
name|TLS_LD
operator|)
operator|==
literal|0
condition|)
block|{
name|tls_gdld_hi
label|:
if|if
condition|(
operator|(
name|tls_mask
operator|&
name|tls_gd
operator|)
operator|!=
literal|0
condition|)
name|r_type
operator|=
operator|(
operator|(
operator|(
name|r_type
operator|-
operator|(
name|R_PPC_GOT_TLSGD16
operator|&
literal|3
operator|)
operator|)
operator|&
literal|3
operator|)
operator|+
name|R_PPC_GOT_TPREL16
operator|)
expr_stmt|;
else|else
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|NOP
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|rel
operator|->
name|r_offset
operator|-=
literal|2
expr_stmt|;
name|r_type
operator|=
name|R_PPC_NONE
expr_stmt|;
block|}
name|rel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|r_symndx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|R_PPC_GOT_TLSGD16
case|:
case|case
name|R_PPC_GOT_TLSGD16_LO
case|:
name|tls_gd
operator|=
name|TLS_TPRELGD
expr_stmt|;
if|if
condition|(
name|tls_mask
operator|!=
literal|0
operator|&&
operator|(
name|tls_mask
operator|&
name|TLS_GD
operator|)
operator|==
literal|0
condition|)
goto|goto
name|tls_get_addr_check
goto|;
break|break;
case|case
name|R_PPC_GOT_TLSLD16
case|:
case|case
name|R_PPC_GOT_TLSLD16_LO
case|:
if|if
condition|(
name|tls_mask
operator|!=
literal|0
operator|&&
operator|(
name|tls_mask
operator|&
name|TLS_LD
operator|)
operator|==
literal|0
condition|)
block|{
name|tls_get_addr_check
label|:
if|if
condition|(
name|rel
operator|+
literal|1
operator|<
name|relend
condition|)
block|{
name|enum
name|elf_ppc_reloc_type
name|r_type2
decl_stmt|;
name|unsigned
name|long
name|r_symndx2
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h2
decl_stmt|;
name|bfd_vma
name|insn1
decl_stmt|,
name|insn2
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
comment|/* The next instruction should be a call to 		     __tls_get_addr.  Peek at the reloc to be sure.  */
name|r_type2
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
index|[
literal|1
index|]
operator|.
name|r_info
argument_list|)
expr_stmt|;
name|r_symndx2
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
index|[
literal|1
index|]
operator|.
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx2
operator|<
name|symtab_hdr
operator|->
name|sh_info
operator|||
operator|(
name|r_type2
operator|!=
name|R_PPC_REL14
operator|&&
name|r_type2
operator|!=
name|R_PPC_REL14_BRTAKEN
operator|&&
name|r_type2
operator|!=
name|R_PPC_REL14_BRNTAKEN
operator|&&
name|r_type2
operator|!=
name|R_PPC_REL24
operator|&&
name|r_type2
operator|!=
name|R_PPC_PLTREL24
operator|)
condition|)
break|break;
name|h2
operator|=
name|sym_hashes
index|[
name|r_symndx2
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
while|while
condition|(
name|h2
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h2
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h2
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h2
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|h2
operator|==
name|NULL
operator|||
name|h2
operator|!=
name|htab
operator|->
name|tls_get_addr
condition|)
break|break;
comment|/* OK, it checks out.  Replace the call.  */
name|offset
operator|=
name|rel
index|[
literal|1
index|]
operator|.
name|r_offset
expr_stmt|;
name|insn1
operator|=
name|bfd_get_32
argument_list|(
name|output_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|-
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tls_mask
operator|&
name|tls_gd
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* IE */
name|insn1
operator|&=
operator|(
literal|1
operator|<<
literal|26
operator|)
operator|-
literal|1
expr_stmt|;
name|insn1
operator||=
literal|32
operator|<<
literal|26
expr_stmt|;
comment|/* lwz */
name|insn2
operator|=
literal|0x7c631214
expr_stmt|;
comment|/* add 3,3,2 */
name|rel
index|[
literal|1
index|]
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|r_symndx2
argument_list|,
name|R_PPC_NONE
argument_list|)
expr_stmt|;
name|r_type
operator|=
operator|(
operator|(
operator|(
name|r_type
operator|-
operator|(
name|R_PPC_GOT_TLSGD16
operator|&
literal|3
operator|)
operator|)
operator|&
literal|3
operator|)
operator|+
name|R_PPC_GOT_TPREL16
operator|)
expr_stmt|;
name|rel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|r_symndx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* LE */
name|insn1
operator|=
literal|0x3c620000
expr_stmt|;
comment|/* addis 3,2,0 */
name|insn2
operator|=
literal|0x38630000
expr_stmt|;
comment|/* addi 3,3,0 */
if|if
condition|(
name|tls_gd
operator|==
literal|0
condition|)
block|{
comment|/* Was an LD reloc.  */
name|r_symndx
operator|=
literal|0
expr_stmt|;
name|rel
operator|->
name|r_addend
operator|=
name|htab
operator|->
name|elf
operator|.
name|tls_sec
operator|->
name|vma
operator|+
name|DTP_OFFSET
expr_stmt|;
name|rel
index|[
literal|1
index|]
operator|.
name|r_addend
operator|=
name|htab
operator|->
name|elf
operator|.
name|tls_sec
operator|->
name|vma
operator|+
name|DTP_OFFSET
expr_stmt|;
block|}
name|r_type
operator|=
name|R_PPC_TPREL16_HA
expr_stmt|;
name|rel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|r_symndx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
name|rel
index|[
literal|1
index|]
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|r_symndx
argument_list|,
name|R_PPC_TPREL16_LO
argument_list|)
expr_stmt|;
name|rel
index|[
literal|1
index|]
operator|.
name|r_offset
operator|+=
literal|2
expr_stmt|;
block|}
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|insn1
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|-
literal|2
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|insn2
argument_list|,
name|contents
operator|+
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|tls_gd
operator|==
literal|0
condition|)
block|{
comment|/* We changed the symbol on an LD reloc.  Start over 			 in order to get h, sym, sec etc. right.  */
name|rel
operator|--
expr_stmt|;
continue|continue;
block|}
block|}
block|}
break|break;
block|}
comment|/* Handle other relocations that tweak non-addend part of insn.  */
name|branch_bit
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
default|default:
break|break;
comment|/* Branch taken prediction relocations.  */
case|case
name|R_PPC_ADDR14_BRTAKEN
case|:
case|case
name|R_PPC_REL14_BRTAKEN
case|:
name|branch_bit
operator|=
name|BRANCH_PREDICT_BIT
expr_stmt|;
comment|/* Fall thru */
comment|/* Branch not taken prediction relocations.  */
case|case
name|R_PPC_ADDR14_BRNTAKEN
case|:
case|case
name|R_PPC_REL14_BRNTAKEN
case|:
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|output_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|insn
operator|&=
operator|~
name|BRANCH_PREDICT_BIT
expr_stmt|;
name|insn
operator||=
name|branch_bit
expr_stmt|;
name|from
operator|=
operator|(
name|rel
operator|->
name|r_offset
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
comment|/* Invert 'y' bit if not the default.  */
if|if
condition|(
call|(
name|bfd_signed_vma
call|)
argument_list|(
name|relocation
operator|+
name|rel
operator|->
name|r_addend
operator|-
name|from
argument_list|)
operator|<
literal|0
condition|)
name|insn
operator|^=
name|BRANCH_PREDICT_BIT
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|insn
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
break|break;
block|}
name|addend
operator|=
name|rel
operator|->
name|r_addend
expr_stmt|;
name|tls_type
operator|=
literal|0
expr_stmt|;
name|howto
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|r_type
operator|<
name|R_PPC_max
condition|)
name|howto
operator|=
name|ppc_elf_howto_table
index|[
name|r_type
index|]
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
default|default:
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: unknown relocation type %d for symbol %s"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|r_type
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
name|ret
operator|=
name|FALSE
expr_stmt|;
continue|continue;
case|case
name|R_PPC_NONE
case|:
case|case
name|R_PPC_TLS
case|:
case|case
name|R_PPC_EMB_MRKREF
case|:
case|case
name|R_PPC_GNU_VTINHERIT
case|:
case|case
name|R_PPC_GNU_VTENTRY
case|:
continue|continue;
comment|/* GOT16 relocations.  Like an ADDR16 using the symbol's 	     address in the GOT as relocation value instead of the 	     symbol's value itself.  Also, create a GOT entry for the 	     symbol and put the symbol value there.  */
case|case
name|R_PPC_GOT_TLSGD16
case|:
case|case
name|R_PPC_GOT_TLSGD16_LO
case|:
case|case
name|R_PPC_GOT_TLSGD16_HI
case|:
case|case
name|R_PPC_GOT_TLSGD16_HA
case|:
name|tls_type
operator|=
name|TLS_TLS
operator||
name|TLS_GD
expr_stmt|;
goto|goto
name|dogot
goto|;
case|case
name|R_PPC_GOT_TLSLD16
case|:
case|case
name|R_PPC_GOT_TLSLD16_LO
case|:
case|case
name|R_PPC_GOT_TLSLD16_HI
case|:
case|case
name|R_PPC_GOT_TLSLD16_HA
case|:
name|tls_type
operator|=
name|TLS_TLS
operator||
name|TLS_LD
expr_stmt|;
goto|goto
name|dogot
goto|;
case|case
name|R_PPC_GOT_TPREL16
case|:
case|case
name|R_PPC_GOT_TPREL16_LO
case|:
case|case
name|R_PPC_GOT_TPREL16_HI
case|:
case|case
name|R_PPC_GOT_TPREL16_HA
case|:
name|tls_type
operator|=
name|TLS_TLS
operator||
name|TLS_TPREL
expr_stmt|;
goto|goto
name|dogot
goto|;
case|case
name|R_PPC_GOT_DTPREL16
case|:
case|case
name|R_PPC_GOT_DTPREL16_LO
case|:
case|case
name|R_PPC_GOT_DTPREL16_HI
case|:
case|case
name|R_PPC_GOT_DTPREL16_HA
case|:
name|tls_type
operator|=
name|TLS_TLS
operator||
name|TLS_DTPREL
expr_stmt|;
goto|goto
name|dogot
goto|;
case|case
name|R_PPC_GOT16
case|:
case|case
name|R_PPC_GOT16_LO
case|:
case|case
name|R_PPC_GOT16_HI
case|:
case|case
name|R_PPC_GOT16_HA
case|:
name|dogot
label|:
block|{
comment|/* Relocation is to the entry for this symbol in the global 	       offset table.  */
name|bfd_vma
name|off
decl_stmt|;
name|bfd_vma
modifier|*
name|offp
decl_stmt|;
name|unsigned
name|long
name|indx
decl_stmt|;
if|if
condition|(
name|htab
operator|->
name|got
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|indx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tls_type
operator|==
operator|(
name|TLS_TLS
operator||
name|TLS_LD
operator|)
operator|&&
operator|(
name|h
operator|==
name|NULL
operator|||
operator|!
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|)
condition|)
name|offp
operator|=
operator|&
name|htab
operator|->
name|tlsld_got
operator|.
name|offset
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|bfd_boolean
name|dyn
decl_stmt|;
name|dyn
operator|=
name|htab
operator|->
name|elf
operator|.
name|dynamic_sections_created
expr_stmt|;
if|if
condition|(
operator|!
name|WILL_CALL_FINISH_DYNAMIC_SYMBOL
argument_list|(
name|dyn
argument_list|,
name|info
operator|->
name|shared
argument_list|,
name|h
argument_list|)
operator|||
operator|(
name|info
operator|->
name|shared
operator|&&
name|SYMBOL_REFERENCES_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
operator|)
condition|)
comment|/* This is actually a static link, or it is a 		     -Bsymbolic link and the symbol is defined 		     locally, or the symbol was forced to be local 		     because of a version file.  */
empty_stmt|;
else|else
block|{
name|indx
operator|=
name|h
operator|->
name|dynindx
expr_stmt|;
name|unresolved_reloc
operator|=
name|FALSE
expr_stmt|;
block|}
name|offp
operator|=
operator|&
name|h
operator|->
name|got
operator|.
name|offset
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|local_got_offsets
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|offp
operator|=
operator|&
name|local_got_offsets
index|[
name|r_symndx
index|]
expr_stmt|;
block|}
comment|/* The offset must always be a multiple of 4.  We use the 	       least significant bit to record whether we have already 	       processed this entry.  */
name|off
operator|=
operator|*
name|offp
expr_stmt|;
if|if
condition|(
operator|(
name|off
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|off
operator|&=
operator|~
literal|1
expr_stmt|;
else|else
block|{
name|unsigned
name|int
name|tls_m
init|=
operator|(
name|tls_mask
operator|&
operator|(
name|TLS_LD
operator||
name|TLS_GD
operator||
name|TLS_DTPREL
operator||
name|TLS_TPREL
operator||
name|TLS_TPRELGD
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|offp
operator|==
operator|&
name|htab
operator|->
name|tlsld_got
operator|.
name|offset
condition|)
name|tls_m
operator|=
name|TLS_LD
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
operator|!
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
condition|)
name|tls_m
operator|&=
operator|~
name|TLS_LD
expr_stmt|;
comment|/* We might have multiple got entries for this sym. 		   Initialize them all.  */
do|do
block|{
name|int
name|tls_ty
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|tls_m
operator|&
name|TLS_LD
operator|)
operator|!=
literal|0
condition|)
block|{
name|tls_ty
operator|=
name|TLS_TLS
operator||
name|TLS_LD
expr_stmt|;
name|tls_m
operator|&=
operator|~
name|TLS_LD
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|tls_m
operator|&
name|TLS_GD
operator|)
operator|!=
literal|0
condition|)
block|{
name|tls_ty
operator|=
name|TLS_TLS
operator||
name|TLS_GD
expr_stmt|;
name|tls_m
operator|&=
operator|~
name|TLS_GD
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|tls_m
operator|&
name|TLS_DTPREL
operator|)
operator|!=
literal|0
condition|)
block|{
name|tls_ty
operator|=
name|TLS_TLS
operator||
name|TLS_DTPREL
expr_stmt|;
name|tls_m
operator|&=
operator|~
name|TLS_DTPREL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|tls_m
operator|&
operator|(
name|TLS_TPREL
operator||
name|TLS_TPRELGD
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|tls_ty
operator|=
name|TLS_TLS
operator||
name|TLS_TPREL
expr_stmt|;
name|tls_m
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Generate relocs for the dynamic linker.  */
if|if
condition|(
operator|(
name|info
operator|->
name|shared
operator|||
name|indx
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|h
operator|==
name|NULL
operator|||
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_DEFAULT
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefweak
operator|)
condition|)
block|{
name|outrel
operator|.
name|r_offset
operator|=
operator|(
name|htab
operator|->
name|got
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|got
operator|->
name|output_offset
operator|+
name|off
operator|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tls_ty
operator|&
operator|(
name|TLS_LD
operator||
name|TLS_GD
operator|)
condition|)
block|{
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|indx
argument_list|,
name|R_PPC_DTPMOD32
argument_list|)
expr_stmt|;
if|if
condition|(
name|tls_ty
operator|==
operator|(
name|TLS_TLS
operator||
name|TLS_GD
operator|)
condition|)
block|{
name|loc
operator|=
name|htab
operator|->
name|relgot
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
operator|(
name|htab
operator|->
name|relgot
operator|->
name|reloc_count
operator|++
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
operator|)
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|+=
literal|4
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|indx
argument_list|,
name|R_PPC_DTPREL32
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|tls_ty
operator|==
operator|(
name|TLS_TLS
operator||
name|TLS_DTPREL
operator|)
condition|)
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|indx
argument_list|,
name|R_PPC_DTPREL32
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tls_ty
operator|==
operator|(
name|TLS_TLS
operator||
name|TLS_TPREL
operator|)
condition|)
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|indx
argument_list|,
name|R_PPC_TPREL32
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|indx
operator|==
literal|0
condition|)
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|indx
argument_list|,
name|R_PPC_RELATIVE
argument_list|)
expr_stmt|;
else|else
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|indx
argument_list|,
name|R_PPC_GLOB_DAT
argument_list|)
expr_stmt|;
if|if
condition|(
name|indx
operator|==
literal|0
condition|)
block|{
name|outrel
operator|.
name|r_addend
operator|+=
name|relocation
expr_stmt|;
if|if
condition|(
name|tls_ty
operator|&
operator|(
name|TLS_GD
operator||
name|TLS_DTPREL
operator||
name|TLS_TPREL
operator|)
condition|)
name|outrel
operator|.
name|r_addend
operator|-=
name|htab
operator|->
name|elf
operator|.
name|tls_sec
operator|->
name|vma
expr_stmt|;
block|}
name|loc
operator|=
name|htab
operator|->
name|relgot
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
operator|(
name|htab
operator|->
name|relgot
operator|->
name|reloc_count
operator|++
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
operator|)
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
comment|/* Init the .got section contents if we're not 		       emitting a reloc.  */
else|else
block|{
name|bfd_vma
name|value
init|=
name|relocation
decl_stmt|;
if|if
condition|(
name|tls_ty
operator|==
operator|(
name|TLS_TLS
operator||
name|TLS_LD
operator|)
condition|)
name|value
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|tls_ty
operator|!=
literal|0
condition|)
block|{
name|value
operator|-=
name|htab
operator|->
name|elf
operator|.
name|tls_sec
operator|->
name|vma
operator|+
name|DTP_OFFSET
expr_stmt|;
if|if
condition|(
name|tls_ty
operator|==
operator|(
name|TLS_TLS
operator||
name|TLS_TPREL
operator|)
condition|)
name|value
operator|+=
name|DTP_OFFSET
operator|-
name|TP_OFFSET
expr_stmt|;
if|if
condition|(
name|tls_ty
operator|==
operator|(
name|TLS_TLS
operator||
name|TLS_GD
operator|)
condition|)
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|value
argument_list|,
name|htab
operator|->
name|got
operator|->
name|contents
operator|+
name|off
operator|+
literal|4
argument_list|)
expr_stmt|;
name|value
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|value
argument_list|,
name|htab
operator|->
name|got
operator|->
name|contents
operator|+
name|off
argument_list|)
expr_stmt|;
block|}
name|off
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|tls_ty
operator|&
operator|(
name|TLS_LD
operator||
name|TLS_GD
operator|)
condition|)
name|off
operator|+=
literal|4
expr_stmt|;
block|}
do|while
condition|(
name|tls_m
operator|!=
literal|0
condition|)
do|;
name|off
operator|=
operator|*
name|offp
expr_stmt|;
operator|*
name|offp
operator|=
name|off
operator||
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|off
operator|>=
operator|(
name|bfd_vma
operator|)
operator|-
literal|2
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|tls_type
operator|&
name|TLS_TLS
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|tls_type
operator|!=
operator|(
name|TLS_TLS
operator||
name|TLS_LD
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|tls_mask
operator|&
name|TLS_LD
operator|)
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|h
operator|==
name|NULL
operator|||
operator|!
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|)
condition|)
name|off
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
name|tls_type
operator|!=
operator|(
name|TLS_TLS
operator||
name|TLS_GD
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|tls_mask
operator|&
name|TLS_GD
operator|)
operator|!=
literal|0
condition|)
name|off
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
name|tls_type
operator|!=
operator|(
name|TLS_TLS
operator||
name|TLS_DTPREL
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|tls_mask
operator|&
name|TLS_DTPREL
operator|)
operator|!=
literal|0
condition|)
name|off
operator|+=
literal|4
expr_stmt|;
block|}
block|}
block|}
block|}
name|relocation
operator|=
name|htab
operator|->
name|got
operator|->
name|output_offset
operator|+
name|off
operator|-
literal|4
expr_stmt|;
comment|/* Addends on got relocations don't make much sense. 	       x+off@got is actually x@got+off, and since the got is 	       generated by a hash table traversal, the value in the 	       got at entry m+n bears little relation to the entry m.  */
if|if
condition|(
name|addend
operator|!=
literal|0
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s(%s+0x%lx): non-zero addend on %s reloc against `%s'"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|bfd_get_section_name
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|rel
operator|->
name|r_offset
argument_list|,
name|howto
operator|->
name|name
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* Relocations that need no special processing.  */
case|case
name|R_PPC_LOCAL24PC
case|:
comment|/* It makes no sense to point a local relocation 	     at a symbol not in this object.  */
if|if
condition|(
name|unresolved_reloc
condition|)
block|{
if|if
condition|(
operator|!
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
name|FALSE
return|;
continue|continue;
block|}
break|break;
case|case
name|R_PPC_DTPREL16
case|:
case|case
name|R_PPC_DTPREL16_LO
case|:
case|case
name|R_PPC_DTPREL16_HI
case|:
case|case
name|R_PPC_DTPREL16_HA
case|:
name|addend
operator|-=
name|htab
operator|->
name|elf
operator|.
name|tls_sec
operator|->
name|vma
operator|+
name|DTP_OFFSET
expr_stmt|;
break|break;
comment|/* Relocations that may need to be propagated if this is a shared 	     object.  */
case|case
name|R_PPC_TPREL16
case|:
case|case
name|R_PPC_TPREL16_LO
case|:
case|case
name|R_PPC_TPREL16_HI
case|:
case|case
name|R_PPC_TPREL16_HA
case|:
name|addend
operator|-=
name|htab
operator|->
name|elf
operator|.
name|tls_sec
operator|->
name|vma
operator|+
name|TP_OFFSET
expr_stmt|;
comment|/* The TPREL16 relocs shouldn't really be used in shared 	     libs as they will result in DT_TEXTREL being set, but 	     support them anyway.  */
goto|goto
name|dodyn
goto|;
case|case
name|R_PPC_TPREL32
case|:
name|addend
operator|-=
name|htab
operator|->
name|elf
operator|.
name|tls_sec
operator|->
name|vma
operator|+
name|TP_OFFSET
expr_stmt|;
goto|goto
name|dodyn
goto|;
case|case
name|R_PPC_DTPREL32
case|:
name|addend
operator|-=
name|htab
operator|->
name|elf
operator|.
name|tls_sec
operator|->
name|vma
operator|+
name|DTP_OFFSET
expr_stmt|;
goto|goto
name|dodyn
goto|;
case|case
name|R_PPC_DTPMOD32
case|:
name|relocation
operator|=
literal|1
expr_stmt|;
name|addend
operator|=
literal|0
expr_stmt|;
goto|goto
name|dodyn
goto|;
case|case
name|R_PPC_REL24
case|:
case|case
name|R_PPC_REL32
case|:
case|case
name|R_PPC_REL14
case|:
case|case
name|R_PPC_REL14_BRTAKEN
case|:
case|case
name|R_PPC_REL14_BRNTAKEN
case|:
comment|/* If these relocations are not to a named symbol, they can be 	     handled right here, no need to bother the dynamic linker.  */
if|if
condition|(
name|SYMBOL_REFERENCES_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
operator|||
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|)
operator|==
literal|0
condition|)
break|break;
comment|/* fall through */
comment|/* Relocations that always need to be propagated if this is a shared 	     object.  */
case|case
name|R_PPC_ADDR32
case|:
case|case
name|R_PPC_ADDR24
case|:
case|case
name|R_PPC_ADDR16
case|:
case|case
name|R_PPC_ADDR16_LO
case|:
case|case
name|R_PPC_ADDR16_HI
case|:
case|case
name|R_PPC_ADDR16_HA
case|:
case|case
name|R_PPC_ADDR14
case|:
case|case
name|R_PPC_ADDR14_BRTAKEN
case|:
case|case
name|R_PPC_ADDR14_BRNTAKEN
case|:
case|case
name|R_PPC_UADDR32
case|:
case|case
name|R_PPC_UADDR16
case|:
comment|/* r_symndx will be zero only for relocs against symbols 	     from removed linkonce sections, or sections discarded by 	     a linker script.  */
name|dodyn
label|:
if|if
condition|(
name|r_symndx
operator|==
literal|0
condition|)
break|break;
comment|/* Fall thru.  */
if|if
condition|(
operator|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|h
operator|==
name|NULL
operator|||
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_DEFAULT
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefweak
operator|)
operator|&&
operator|(
name|MUST_BE_DYN_RELOC
argument_list|(
name|r_type
argument_list|)
operator|||
operator|!
name|SYMBOL_CALLS_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|ELIMINATE_COPY_RELOCS
operator|&&
operator|!
name|info
operator|->
name|shared
operator|&&
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
operator|&&
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_NON_GOT_REF
operator|)
operator|==
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|int
name|skip
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ppc_elf_relocate_section needs to "
literal|"create relocation for %s\n"
argument_list|,
operator|(
name|h
operator|&&
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
condition|?
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
else|:
literal|"<unknown>"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* When generating a shared object, these relocations 		 are copied into the output file to be resolved at run 		 time.  */
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
operator|(
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|elf_elfheader
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|e_shstrndx
argument_list|,
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|rel_hdr
operator|.
name|sh_name
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|BFD_ASSERT
argument_list|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".rela"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
argument_list|,
name|name
operator|+
literal|5
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|sreloc
operator|=
name|bfd_get_section_by_name
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sreloc
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
name|skip
operator|=
literal|0
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|=
name|_bfd_elf_section_offset
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|outrel
operator|.
name|r_offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|||
name|outrel
operator|.
name|r_offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|2
condition|)
name|skip
operator|=
operator|(
name|int
operator|)
name|outrel
operator|.
name|r_offset
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|+=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
if|if
condition|(
name|skip
condition|)
name|memset
argument_list|(
operator|&
name|outrel
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|outrel
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|SYMBOL_REFERENCES_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
block|{
name|unresolved_reloc
operator|=
name|FALSE
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
name|rel
operator|->
name|r_addend
expr_stmt|;
block|}
else|else
block|{
name|outrel
operator|.
name|r_addend
operator|=
name|relocation
operator|+
name|rel
operator|->
name|r_addend
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_PPC_ADDR32
condition|)
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_PPC_RELATIVE
argument_list|)
expr_stmt|;
else|else
block|{
name|long
name|indx
decl_stmt|;
if|if
condition|(
name|bfd_is_abs_section
argument_list|(
name|sec
argument_list|)
condition|)
name|indx
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|sec
operator|==
name|NULL
operator|||
name|sec
operator|->
name|owner
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
else|else
block|{
name|asection
modifier|*
name|osec
decl_stmt|;
comment|/* We are turning this relocation into one 			     against a section symbol.  It would be 			     proper to subtract the symbol's value, 			     osec->vma, from the emitted reloc addend, 			     but ld.so expects buggy relocs.  */
name|osec
operator|=
name|sec
operator|->
name|output_section
expr_stmt|;
name|indx
operator|=
name|elf_section_data
argument_list|(
name|osec
argument_list|)
operator|->
name|dynindx
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|indx
operator|>
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|indx
operator|<=
literal|0
condition|)
name|printf
argument_list|(
literal|"indx=%d section=%s flags=%08x name=%s\n"
argument_list|,
name|indx
argument_list|,
name|osec
operator|->
name|name
argument_list|,
name|osec
operator|->
name|flags
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|indx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
block|}
block|}
name|loc
operator|=
name|sreloc
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
name|sreloc
operator|->
name|reloc_count
operator|++
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
if|if
condition|(
name|skip
operator|==
operator|-
literal|1
condition|)
continue|continue;
comment|/* This reloc will be computed at runtime.  We clear the memory 		 so that it contains predictable value.  */
if|if
condition|(
operator|!
name|skip
operator|&&
operator|(
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
operator|||
name|ELF32_R_TYPE
argument_list|(
name|outrel
operator|.
name|r_info
argument_list|)
operator|!=
name|R_PPC_RELATIVE
operator|)
condition|)
block|{
name|relocation
operator|=
name|howto
operator|->
name|pc_relative
condition|?
name|outrel
operator|.
name|r_offset
else|:
literal|0
expr_stmt|;
name|addend
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
name|R_PPC_RELAX32PC
case|:
name|relocation
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|rel
operator|->
name|r_offset
operator|-
literal|4
operator|)
expr_stmt|;
comment|/* Fall thru */
case|case
name|R_PPC_RELAX32
case|:
block|{
name|unsigned
name|long
name|t0
decl_stmt|;
name|unsigned
name|long
name|t1
decl_stmt|;
name|t0
operator|=
name|bfd_get_32
argument_list|(
name|output_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|t1
operator|=
name|bfd_get_32
argument_list|(
name|output_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|+
literal|4
argument_list|)
expr_stmt|;
comment|/* We're clearing the bits for R_PPC_ADDR16_HA 	       and R_PPC_ADDR16_LO here.  */
name|t0
operator|&=
operator|~
literal|0xffff
expr_stmt|;
name|t1
operator|&=
operator|~
literal|0xffff
expr_stmt|;
comment|/* t0 is HA, t1 is LO */
name|relocation
operator|+=
name|addend
expr_stmt|;
name|t0
operator||=
operator|(
operator|(
name|relocation
operator|+
literal|0x8000
operator|)
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
expr_stmt|;
name|t1
operator||=
name|relocation
operator|&
literal|0xffff
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|t0
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|t1
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
continue|continue;
comment|/* Indirect .sdata relocation.  */
case|case
name|R_PPC_EMB_SDAI16
case|:
name|BFD_ASSERT
argument_list|(
name|htab
operator|->
name|sdata
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|relocation
operator|=
name|elf_finish_pointer_linker_section
argument_list|(
name|output_bfd
argument_list|,
name|input_bfd
argument_list|,
name|info
argument_list|,
name|htab
operator|->
name|sdata
argument_list|,
name|h
argument_list|,
name|relocation
argument_list|,
name|rel
argument_list|,
name|R_PPC_RELATIVE
argument_list|)
expr_stmt|;
break|break;
comment|/* Indirect .sdata2 relocation.  */
case|case
name|R_PPC_EMB_SDA2I16
case|:
name|BFD_ASSERT
argument_list|(
name|htab
operator|->
name|sdata2
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|relocation
operator|=
name|elf_finish_pointer_linker_section
argument_list|(
name|output_bfd
argument_list|,
name|input_bfd
argument_list|,
name|info
argument_list|,
name|htab
operator|->
name|sdata2
argument_list|,
name|h
argument_list|,
name|relocation
argument_list|,
name|rel
argument_list|,
name|R_PPC_RELATIVE
argument_list|)
expr_stmt|;
break|break;
comment|/* Handle the TOC16 reloc.  We want to use the offset within the .got 	     section, not the actual VMA.  This is appropriate when generating 	     an embedded ELF object, for which the .got section acts like the 	     AIX .toc section.  */
case|case
name|R_PPC_TOC16
case|:
comment|/* phony GOT16 relocations */
name|BFD_ASSERT
argument_list|(
name|sec
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
argument|bfd_is_und_section (sec) 		      || strcmp (bfd_get_section_name (abfd, sec),
literal|".got"
argument|) ==
literal|0
argument||| strcmp (bfd_get_section_name (abfd, sec),
literal|".cgot"
argument|) ==
literal|0
argument_list|)
name|addend
operator|-=
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
literal|0x8000
expr_stmt|;
break|break;
case|case
name|R_PPC_PLTREL24
case|:
comment|/* Relocation is to the entry for this symbol in the 	     procedure linkage table.  */
name|BFD_ASSERT
argument_list|(
name|h
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|||
name|htab
operator|->
name|plt
operator|==
name|NULL
condition|)
block|{
comment|/* We didn't make a PLT entry for this symbol.  This 		 happens when statically linking PIC code, or when 		 using -Bsymbolic.  */
break|break;
block|}
name|unresolved_reloc
operator|=
name|FALSE
expr_stmt|;
name|relocation
operator|=
operator|(
name|htab
operator|->
name|plt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|plt
operator|->
name|output_offset
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|)
expr_stmt|;
break|break;
comment|/* Relocate against _SDA_BASE_.  */
case|case
name|R_PPC_SDAREL16
case|:
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|struct
name|elf_link_hash_entry
modifier|*
name|sh
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|sec
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
operator|->
name|output_section
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".sdata"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|name
index|[
literal|6
index|]
operator|==
literal|0
operator|||
name|name
index|[
literal|6
index|]
operator|==
literal|'.'
operator|)
operator|)
operator|||
operator|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".sbss"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|name
index|[
literal|5
index|]
operator|==
literal|0
operator|||
name|name
index|[
literal|5
index|]
operator|==
literal|'.'
operator|)
operator|)
operator|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: the target (%s) of a %s relocation is "
literal|"in the wrong output section (%s)"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|sym_name
argument_list|,
name|howto
operator|->
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|sh
operator|=
name|htab
operator|->
name|sdata
operator|->
name|sym_hash
expr_stmt|;
name|addend
operator|-=
operator|(
name|sh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|sh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
break|break;
comment|/* Relocate against _SDA2_BASE_.  */
case|case
name|R_PPC_EMB_SDA2REL
case|:
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|struct
name|elf_link_hash_entry
modifier|*
name|sh
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|sec
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
operator|->
name|output_section
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".sdata2"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".sbss2"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: the target (%s) of a %s relocation is "
literal|"in the wrong output section (%s)"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|sym_name
argument_list|,
name|howto
operator|->
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
name|ret
operator|=
name|FALSE
expr_stmt|;
continue|continue;
block|}
name|sh
operator|=
name|htab
operator|->
name|sdata2
operator|->
name|sym_hash
expr_stmt|;
name|addend
operator|-=
operator|(
name|sh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|sh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
break|break;
comment|/* Relocate against either _SDA_BASE_, _SDA2_BASE_, or 0.  */
case|case
name|R_PPC_EMB_SDA21
case|:
case|case
name|R_PPC_EMB_RELSDA
case|:
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|struct
name|elf_link_hash_entry
modifier|*
name|sh
decl_stmt|;
name|int
name|reg
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|sec
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
operator|->
name|output_section
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".sdata"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|name
index|[
literal|6
index|]
operator|==
literal|0
operator|||
name|name
index|[
literal|6
index|]
operator|==
literal|'.'
operator|)
operator|)
operator|||
operator|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".sbss"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|name
index|[
literal|5
index|]
operator|==
literal|0
operator|||
name|name
index|[
literal|5
index|]
operator|==
literal|'.'
operator|)
operator|)
operator|)
condition|)
block|{
name|reg
operator|=
literal|13
expr_stmt|;
name|sh
operator|=
name|htab
operator|->
name|sdata
operator|->
name|sym_hash
expr_stmt|;
name|addend
operator|-=
operator|(
name|sh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|sh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".sdata2"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".sbss2"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|reg
operator|=
literal|2
expr_stmt|;
name|sh
operator|=
name|htab
operator|->
name|sdata2
operator|->
name|sym_hash
expr_stmt|;
name|addend
operator|-=
operator|(
name|sh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|sh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".PPC.EMB.sdata0"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".PPC.EMB.sbss0"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|reg
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: the target (%s) of a %s relocation is "
literal|"in the wrong output section (%s)"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|sym_name
argument_list|,
name|howto
operator|->
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
name|ret
operator|=
name|FALSE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|r_type
operator|==
name|R_PPC_EMB_SDA21
condition|)
block|{
comment|/* fill in register field */
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|output_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|insn
operator|=
operator|(
name|insn
operator|&
operator|~
name|RA_REGISTER_MASK
operator|)
operator||
operator|(
name|reg
operator|<<
name|RA_REGISTER_SHIFT
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|insn
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
comment|/* Relocate against the beginning of the section.  */
case|case
name|R_PPC_SECTOFF
case|:
case|case
name|R_PPC_SECTOFF_LO
case|:
case|case
name|R_PPC_SECTOFF_HI
case|:
case|case
name|R_PPC_SECTOFF_HA
case|:
name|BFD_ASSERT
argument_list|(
name|sec
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|addend
operator|-=
name|sec
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
break|break;
comment|/* Negative relocations.  */
case|case
name|R_PPC_EMB_NADDR32
case|:
case|case
name|R_PPC_EMB_NADDR16
case|:
case|case
name|R_PPC_EMB_NADDR16_LO
case|:
case|case
name|R_PPC_EMB_NADDR16_HI
case|:
case|case
name|R_PPC_EMB_NADDR16_HA
case|:
name|addend
operator|-=
literal|2
operator|*
name|relocation
expr_stmt|;
break|break;
case|case
name|R_PPC_COPY
case|:
case|case
name|R_PPC_GLOB_DAT
case|:
case|case
name|R_PPC_JMP_SLOT
case|:
case|case
name|R_PPC_RELATIVE
case|:
case|case
name|R_PPC_PLT32
case|:
case|case
name|R_PPC_PLTREL32
case|:
case|case
name|R_PPC_PLT16_LO
case|:
case|case
name|R_PPC_PLT16_HI
case|:
case|case
name|R_PPC_PLT16_HA
case|:
case|case
name|R_PPC_ADDR30
case|:
case|case
name|R_PPC_EMB_RELSEC16
case|:
case|case
name|R_PPC_EMB_RELST_LO
case|:
case|case
name|R_PPC_EMB_RELST_HI
case|:
case|case
name|R_PPC_EMB_RELST_HA
case|:
case|case
name|R_PPC_EMB_BIT_FLD
case|:
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: relocation %s is not yet supported for symbol %s."
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|howto
operator|->
name|name
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
name|ret
operator|=
name|FALSE
expr_stmt|;
continue|continue;
block|}
comment|/* Do any further special processing.  */
switch|switch
condition|(
name|r_type
condition|)
block|{
default|default:
break|break;
case|case
name|R_PPC_ADDR16_HA
case|:
case|case
name|R_PPC_GOT16_HA
case|:
case|case
name|R_PPC_PLT16_HA
case|:
case|case
name|R_PPC_SECTOFF_HA
case|:
case|case
name|R_PPC_TPREL16_HA
case|:
case|case
name|R_PPC_DTPREL16_HA
case|:
case|case
name|R_PPC_GOT_TLSGD16_HA
case|:
case|case
name|R_PPC_GOT_TLSLD16_HA
case|:
case|case
name|R_PPC_GOT_TPREL16_HA
case|:
case|case
name|R_PPC_GOT_DTPREL16_HA
case|:
case|case
name|R_PPC_EMB_NADDR16_HA
case|:
case|case
name|R_PPC_EMB_RELST_HA
case|:
comment|/* It's just possible that this symbol is a weak symbol 	     that's not actually defined anywhere.  In that case, 	     'sec' would be NULL, and we should leave the symbol 	     alone (it will be set to zero elsewhere in the link).  */
if|if
condition|(
name|sec
operator|!=
name|NULL
condition|)
comment|/* Add 0x10000 if sign bit in 0:15 is set. 	       Bits 0:15 are not used.  */
name|addend
operator|+=
literal|0x8000
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ttype = %s (%d), name = %s, symbol index = %ld, "
literal|"offset = %ld, addend = %ld\n"
argument_list|,
name|howto
operator|->
name|name
argument_list|,
operator|(
name|int
operator|)
name|r_type
argument_list|,
name|sym_name
argument_list|,
name|r_symndx
argument_list|,
operator|(
name|long
operator|)
name|rel
operator|->
name|r_offset
argument_list|,
operator|(
name|long
operator|)
name|addend
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|unresolved_reloc
operator|&&
operator|!
operator|(
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_DEBUGGING
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s(%s+0x%lx): unresolvable %s relocation against symbol `%s'"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|bfd_get_section_name
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|rel
operator|->
name|r_offset
argument_list|,
name|howto
operator|->
name|name
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
name|ret
operator|=
name|FALSE
expr_stmt|;
block|}
name|r
operator|=
name|_bfd_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|relocation
argument_list|,
name|addend
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|bfd_reloc_ok
condition|)
block|{
if|if
condition|(
name|sym_name
operator|==
name|NULL
condition|)
name|sym_name
operator|=
literal|"(null)"
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|bfd_reloc_overflow
condition|)
block|{
if|if
condition|(
name|warned
condition|)
continue|continue;
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|&&
name|howto
operator|->
name|pc_relative
condition|)
block|{
comment|/* Assume this is a call protected by other code that 		     detect the symbol is undefined.  If this is the case, 		     we can safely ignore the overflow.  If not, the 		     program is hosed anyway, and a little warning isn't 		     going to help.  */
continue|continue;
block|}
if|if
condition|(
operator|!
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|info
argument_list|,
name|sym_name
argument_list|,
name|howto
operator|->
name|name
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
else|else
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s(%s+0x%lx): %s reloc against `%s': error %d"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|bfd_get_section_name
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|rel
operator|->
name|r_offset
argument_list|,
name|howto
operator|->
name|name
argument_list|,
name|sym_name
argument_list|,
operator|(
name|int
operator|)
name|r
argument_list|)
expr_stmt|;
name|ret
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|elf_reloc_type_class
name|ppc_elf_reloc_type_class
parameter_list|(
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rela
parameter_list|)
block|{
switch|switch
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rela
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_PPC_RELATIVE
case|:
return|return
name|reloc_class_relative
return|;
case|case
name|R_PPC_REL24
case|:
case|case
name|R_PPC_ADDR24
case|:
case|case
name|R_PPC_JMP_SLOT
case|:
return|return
name|reloc_class_plt
return|;
case|case
name|R_PPC_COPY
case|:
return|return
name|reloc_class_copy
return|;
default|default:
return|return
name|reloc_class_normal
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Support for core dump NOTE sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc_elf_grok_prstatus
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Note
modifier|*
name|note
parameter_list|)
block|{
name|int
name|offset
decl_stmt|;
name|unsigned
name|int
name|raw_size
decl_stmt|;
switch|switch
condition|(
name|note
operator|->
name|descsz
condition|)
block|{
default|default:
return|return
name|FALSE
return|;
case|case
literal|268
case|:
comment|/* Linux/PPC.  */
comment|/* pr_cursig */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_signal
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|note
operator|->
name|descdata
operator|+
literal|12
argument_list|)
expr_stmt|;
comment|/* pr_pid */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_pid
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|note
operator|->
name|descdata
operator|+
literal|24
argument_list|)
expr_stmt|;
comment|/* pr_reg */
name|offset
operator|=
literal|72
expr_stmt|;
name|raw_size
operator|=
literal|192
expr_stmt|;
break|break;
block|}
comment|/* Make a ".reg/999" section.  */
return|return
name|_bfd_elfcore_make_pseudosection
argument_list|(
name|abfd
argument_list|,
literal|".reg"
argument_list|,
name|raw_size
argument_list|,
name|note
operator|->
name|descpos
operator|+
name|offset
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|ppc_elf_grok_psinfo
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Note
modifier|*
name|note
parameter_list|)
block|{
switch|switch
condition|(
name|note
operator|->
name|descsz
condition|)
block|{
default|default:
return|return
name|FALSE
return|;
case|case
literal|128
case|:
comment|/* Linux/PPC elf_prpsinfo.  */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_program
operator|=
name|_bfd_elfcore_strndup
argument_list|(
name|abfd
argument_list|,
name|note
operator|->
name|descdata
operator|+
literal|32
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_command
operator|=
name|_bfd_elfcore_strndup
argument_list|(
name|abfd
argument_list|,
name|note
operator|->
name|descdata
operator|+
literal|48
argument_list|,
literal|80
argument_list|)
expr_stmt|;
block|}
comment|/* Note that for some reason, a spurious space is tacked      onto the end of the args in some (at least one anyway)      implementations, so strip it off if it exists.  */
block|{
name|char
modifier|*
name|command
init|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_command
decl_stmt|;
name|int
name|n
init|=
name|strlen
argument_list|(
name|command
argument_list|)
decl_stmt|;
if|if
condition|(
literal|0
operator|<
name|n
operator|&&
name|command
index|[
name|n
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
name|command
index|[
name|n
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Very simple linked list structure for recording apuinfo values.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|apuinfo_list
block|{
name|struct
name|apuinfo_list
modifier|*
name|next
decl_stmt|;
name|unsigned
name|long
name|value
decl_stmt|;
block|}
name|apuinfo_list
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|apuinfo_list
modifier|*
name|head
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|apuinfo_list_init
parameter_list|(
name|void
parameter_list|)
block|{
name|head
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|apuinfo_list_add
parameter_list|(
name|unsigned
name|long
name|value
parameter_list|)
block|{
name|apuinfo_list
modifier|*
name|entry
init|=
name|head
decl_stmt|;
while|while
condition|(
name|entry
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|entry
operator|->
name|value
operator|==
name|value
condition|)
return|return;
name|entry
operator|=
name|entry
operator|->
name|next
expr_stmt|;
block|}
name|entry
operator|=
name|bfd_malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
return|return;
name|entry
operator|->
name|value
operator|=
name|value
expr_stmt|;
name|entry
operator|->
name|next
operator|=
name|head
expr_stmt|;
name|head
operator|=
name|entry
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|apuinfo_list_length
parameter_list|(
name|void
parameter_list|)
block|{
name|apuinfo_list
modifier|*
name|entry
decl_stmt|;
name|unsigned
name|long
name|count
decl_stmt|;
for|for
control|(
name|entry
operator|=
name|head
operator|,
name|count
operator|=
literal|0
init|;
name|entry
condition|;
name|entry
operator|=
name|entry
operator|->
name|next
control|)
operator|++
name|count
expr_stmt|;
return|return
name|count
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|unsigned
name|long
name|apuinfo_list_element
parameter_list|(
name|unsigned
name|long
name|number
parameter_list|)
block|{
name|apuinfo_list
modifier|*
name|entry
decl_stmt|;
for|for
control|(
name|entry
operator|=
name|head
init|;
name|entry
operator|&&
name|number
operator|--
condition|;
name|entry
operator|=
name|entry
operator|->
name|next
control|)
empty_stmt|;
return|return
name|entry
condition|?
name|entry
operator|->
name|value
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|apuinfo_list_finish
parameter_list|(
name|void
parameter_list|)
block|{
name|apuinfo_list
modifier|*
name|entry
decl_stmt|;
for|for
control|(
name|entry
operator|=
name|head
init|;
name|entry
condition|;
control|)
block|{
name|apuinfo_list
modifier|*
name|next
init|=
name|entry
operator|->
name|next
decl_stmt|;
name|free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|entry
operator|=
name|next
expr_stmt|;
block|}
name|head
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|APUINFO_SECTION_NAME
value|".PPC.EMB.apuinfo"
end_define

begin_define
define|#
directive|define
name|APUINFO_LABEL
value|"APUinfo"
end_define

begin_comment
comment|/* Scan the input BFDs and create a linked list of    the APUinfo values that will need to be emitted.  */
end_comment

begin_function
specifier|static
name|void
name|ppc_elf_begin_write_processing
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
parameter_list|)
block|{
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|asection
modifier|*
name|asec
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|unsigned
name|num_input_sections
decl_stmt|;
name|bfd_size_type
name|output_section_size
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|unsigned
name|num_entries
decl_stmt|;
name|unsigned
name|long
name|offset
decl_stmt|;
name|unsigned
name|long
name|length
decl_stmt|;
specifier|const
name|char
modifier|*
name|error_message
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|link_info
operator|==
name|NULL
condition|)
return|return;
comment|/* Scan the input bfds, looking for apuinfo sections.  */
name|num_input_sections
operator|=
literal|0
expr_stmt|;
name|output_section_size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ibfd
operator|=
name|link_info
operator|->
name|input_bfds
init|;
name|ibfd
condition|;
name|ibfd
operator|=
name|ibfd
operator|->
name|link_next
control|)
block|{
name|asec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|ibfd
argument_list|,
name|APUINFO_SECTION_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|asec
condition|)
block|{
operator|++
name|num_input_sections
expr_stmt|;
name|output_section_size
operator|+=
name|asec
operator|->
name|_raw_size
expr_stmt|;
block|}
block|}
comment|/* We need at least one input sections      in order to make merging worthwhile.  */
if|if
condition|(
name|num_input_sections
operator|<
literal|1
condition|)
return|return;
comment|/* Just make sure that the output section exists as well.  */
name|asec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|APUINFO_SECTION_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|asec
operator|==
name|NULL
condition|)
return|return;
comment|/* Allocate a buffer for the contents of the input sections.  */
name|buffer
operator|=
name|bfd_malloc
argument_list|(
name|output_section_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|==
name|NULL
condition|)
return|return;
name|offset
operator|=
literal|0
expr_stmt|;
name|apuinfo_list_init
argument_list|()
expr_stmt|;
comment|/* Read in the input sections contents.  */
for|for
control|(
name|ibfd
operator|=
name|link_info
operator|->
name|input_bfds
init|;
name|ibfd
condition|;
name|ibfd
operator|=
name|ibfd
operator|->
name|link_next
control|)
block|{
name|unsigned
name|long
name|datum
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|asec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|ibfd
argument_list|,
name|APUINFO_SECTION_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|asec
operator|==
name|NULL
condition|)
continue|continue;
name|length
operator|=
name|asec
operator|->
name|_raw_size
expr_stmt|;
if|if
condition|(
name|length
operator|<
literal|24
condition|)
block|{
name|error_message
operator|=
name|_
argument_list|(
literal|"corrupt or empty %s section in %s"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|bfd_seek
argument_list|(
name|ibfd
argument_list|,
name|asec
operator|->
name|filepos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|bfd_bread
argument_list|(
name|buffer
operator|+
name|offset
argument_list|,
name|length
argument_list|,
name|ibfd
argument_list|)
operator|!=
name|length
operator|)
condition|)
block|{
name|error_message
operator|=
name|_
argument_list|(
literal|"unable to read in %s section from %s"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Process the contents of the section.  */
name|ptr
operator|=
name|buffer
operator|+
name|offset
expr_stmt|;
name|error_message
operator|=
name|_
argument_list|(
literal|"corrupt %s section in %s"
argument_list|)
expr_stmt|;
comment|/* Verify the contents of the header.  Note - we have to 	 extract the values this way in order to allow for a 	 host whose endian-ness is different from the target.  */
name|datum
operator|=
name|bfd_get_32
argument_list|(
name|ibfd
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|datum
operator|!=
sizeof|sizeof
name|APUINFO_LABEL
condition|)
goto|goto
name|fail
goto|;
name|datum
operator|=
name|bfd_get_32
argument_list|(
name|ibfd
argument_list|,
name|ptr
operator|+
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|datum
operator|!=
literal|0x2
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|strcmp
argument_list|(
name|ptr
operator|+
literal|12
argument_list|,
name|APUINFO_LABEL
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
comment|/* Get the number of bytes used for apuinfo entries.  */
name|datum
operator|=
name|bfd_get_32
argument_list|(
name|ibfd
argument_list|,
name|ptr
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|datum
operator|+
literal|20
operator|!=
name|length
condition|)
goto|goto
name|fail
goto|;
comment|/* Make sure that we do not run off the end of the section.  */
if|if
condition|(
name|offset
operator|+
name|length
operator|>
name|output_section_size
condition|)
goto|goto
name|fail
goto|;
comment|/* Scan the apuinfo section, building a list of apuinfo numbers.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|datum
condition|;
name|i
operator|+=
literal|4
control|)
name|apuinfo_list_add
argument_list|(
name|bfd_get_32
argument_list|(
name|ibfd
argument_list|,
name|ptr
operator|+
literal|20
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Update the offset.  */
name|offset
operator|+=
name|length
expr_stmt|;
block|}
name|error_message
operator|=
name|NULL
expr_stmt|;
comment|/* Compute the size of the output section.  */
name|num_entries
operator|=
name|apuinfo_list_length
argument_list|()
expr_stmt|;
name|output_section_size
operator|=
literal|20
operator|+
name|num_entries
operator|*
literal|4
expr_stmt|;
name|asec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|APUINFO_SECTION_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_size
argument_list|(
name|abfd
argument_list|,
name|asec
argument_list|,
name|output_section_size
argument_list|)
condition|)
name|ibfd
operator|=
name|abfd
operator|,
name|error_message
operator|=
name|_
argument_list|(
literal|"warning: unable to set size of %s section in %s"
argument_list|)
expr_stmt|;
name|fail
label|:
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|error_message
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|error_message
argument_list|,
name|APUINFO_SECTION_NAME
argument_list|,
name|bfd_archive_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Prevent the output section from accumulating the input sections'    contents.  We have already stored this in our linked list structure.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc_elf_write_section
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|asec
parameter_list|,
name|bfd_byte
modifier|*
name|contents
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
operator|(
name|apuinfo_list_length
argument_list|()
operator|&&
name|strcmp
argument_list|(
name|asec
operator|->
name|name
argument_list|,
name|APUINFO_SECTION_NAME
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Finally we can generate the output section.  */
end_comment

begin_function
specifier|static
name|void
name|ppc_elf_final_write_processing
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_boolean
name|linker
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|bfd_byte
modifier|*
name|buffer
decl_stmt|;
name|asection
modifier|*
name|asec
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|unsigned
name|num_entries
decl_stmt|;
name|bfd_size_type
name|length
decl_stmt|;
name|asec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|APUINFO_SECTION_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|asec
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|apuinfo_list_length
argument_list|()
operator|==
literal|0
condition|)
return|return;
name|length
operator|=
name|asec
operator|->
name|_raw_size
expr_stmt|;
if|if
condition|(
name|length
operator|<
literal|20
condition|)
return|return;
name|buffer
operator|=
name|bfd_malloc
argument_list|(
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"failed to allocate space for new APUinfo section."
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Create the apuinfo header.  */
name|num_entries
operator|=
name|apuinfo_list_length
argument_list|()
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
name|APUINFO_LABEL
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|num_entries
operator|*
literal|4
argument_list|,
name|buffer
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
literal|0x2
argument_list|,
name|buffer
operator|+
literal|8
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|buffer
operator|+
literal|12
argument_list|,
name|APUINFO_LABEL
argument_list|)
expr_stmt|;
name|length
operator|=
literal|20
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_entries
condition|;
name|i
operator|++
control|)
block|{
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|apuinfo_list_element
argument_list|(
name|i
argument_list|)
argument_list|,
name|buffer
operator|+
name|length
argument_list|)
expr_stmt|;
name|length
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|length
operator|!=
name|asec
operator|->
name|_raw_size
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"failed to compute new APUinfo section."
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|asec
argument_list|,
name|buffer
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|length
argument_list|)
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"failed to install new APUinfo section."
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|apuinfo_list_finish
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add extra PPC sections -- Note, for now, make .sbss2 and    .PPC.EMB.sbss0 a normal section, and not a bss section so    that the linker doesn't crater when trying to make more than    2 sections.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|bfd_elf_special_section
specifier|const
name|ppc_elf_special_sections
index|[]
init|=
block|{
block|{
literal|".tags"
block|,
literal|5
block|,
literal|0
block|,
name|SHT_ORDERED
block|,
name|SHF_ALLOC
block|}
block|,
block|{
literal|".sdata"
block|,
literal|6
block|,
operator|-
literal|2
block|,
name|SHT_PROGBITS
block|,
name|SHF_ALLOC
operator|+
name|SHF_WRITE
block|}
block|,
block|{
literal|".sbss"
block|,
literal|5
block|,
operator|-
literal|2
block|,
name|SHT_NOBITS
block|,
name|SHF_ALLOC
operator|+
name|SHF_WRITE
block|}
block|,
block|{
literal|".sdata2"
block|,
literal|7
block|,
operator|-
literal|2
block|,
name|SHT_PROGBITS
block|,
name|SHF_ALLOC
block|}
block|,
block|{
literal|".sbss2"
block|,
literal|6
block|,
operator|-
literal|2
block|,
name|SHT_PROGBITS
block|,
name|SHF_ALLOC
block|}
block|,
block|{
literal|".PPC.EMB.apuinfo"
block|,
literal|16
block|,
literal|0
block|,
name|SHT_NOTE
block|,
literal|0
block|}
block|,
block|{
literal|".PPC.EMB.sdata0"
block|,
literal|15
block|,
literal|0
block|,
name|SHT_PROGBITS
block|,
name|SHF_ALLOC
block|}
block|,
block|{
literal|".PPC.EMB.sbss0"
block|,
literal|14
block|,
literal|0
block|,
name|SHT_PROGBITS
block|,
name|SHF_ALLOC
block|}
block|,
block|{
literal|".plt"
block|,
literal|4
block|,
literal|0
block|,
name|SHT_NOBITS
block|,
name|SHF_ALLOC
operator|+
name|SHF_EXECINSTR
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_define
define|#
directive|define
name|TARGET_LITTLE_SYM
value|bfd_elf32_powerpcle_vec
end_define

begin_define
define|#
directive|define
name|TARGET_LITTLE_NAME
value|"elf32-powerpcle"
end_define

begin_define
define|#
directive|define
name|TARGET_BIG_SYM
value|bfd_elf32_powerpc_vec
end_define

begin_define
define|#
directive|define
name|TARGET_BIG_NAME
value|"elf32-powerpc"
end_define

begin_define
define|#
directive|define
name|ELF_ARCH
value|bfd_arch_powerpc
end_define

begin_define
define|#
directive|define
name|ELF_MACHINE_CODE
value|EM_PPC
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__QNXTARGET__
end_ifdef

begin_define
define|#
directive|define
name|ELF_MAXPAGESIZE
value|0x1000
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ELF_MAXPAGESIZE
value|0x10000
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|elf_info_to_howto
value|ppc_elf_info_to_howto
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|EM_CYGNUS_POWERPC
end_ifdef

begin_define
define|#
directive|define
name|ELF_MACHINE_ALT1
value|EM_CYGNUS_POWERPC
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EM_PPC_OLD
end_ifdef

begin_define
define|#
directive|define
name|ELF_MACHINE_ALT2
value|EM_PPC_OLD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|elf_backend_plt_not_loaded
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_got_symbol_offset
value|4
end_define

begin_define
define|#
directive|define
name|elf_backend_can_gc_sections
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_can_refcount
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_got_header_size
value|12
end_define

begin_define
define|#
directive|define
name|elf_backend_rela_normal
value|1
end_define

begin_define
define|#
directive|define
name|bfd_elf32_mkobject
value|ppc_elf_mkobject
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_merge_private_bfd_data
value|ppc_elf_merge_private_bfd_data
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_relax_section
value|ppc_elf_relax_section
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_reloc_type_lookup
value|ppc_elf_reloc_type_lookup
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_set_private_flags
value|ppc_elf_set_private_flags
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_link_hash_table_create
value|ppc_elf_link_hash_table_create
end_define

begin_define
define|#
directive|define
name|elf_backend_object_p
value|ppc_elf_object_p
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_mark_hook
value|ppc_elf_gc_mark_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_sweep_hook
value|ppc_elf_gc_sweep_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_section_from_shdr
value|ppc_elf_section_from_shdr
end_define

begin_define
define|#
directive|define
name|elf_backend_relocate_section
value|ppc_elf_relocate_section
end_define

begin_define
define|#
directive|define
name|elf_backend_create_dynamic_sections
value|ppc_elf_create_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_check_relocs
value|ppc_elf_check_relocs
end_define

begin_define
define|#
directive|define
name|elf_backend_copy_indirect_symbol
value|ppc_elf_copy_indirect_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_adjust_dynamic_symbol
value|ppc_elf_adjust_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_add_symbol_hook
value|ppc_elf_add_symbol_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_size_dynamic_sections
value|ppc_elf_size_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_symbol
value|ppc_elf_finish_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_sections
value|ppc_elf_finish_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_fake_sections
value|ppc_elf_fake_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_additional_program_headers
value|ppc_elf_additional_program_headers
end_define

begin_define
define|#
directive|define
name|elf_backend_modify_segment_map
value|ppc_elf_modify_segment_map
end_define

begin_define
define|#
directive|define
name|elf_backend_grok_prstatus
value|ppc_elf_grok_prstatus
end_define

begin_define
define|#
directive|define
name|elf_backend_grok_psinfo
value|ppc_elf_grok_psinfo
end_define

begin_define
define|#
directive|define
name|elf_backend_reloc_type_class
value|ppc_elf_reloc_type_class
end_define

begin_define
define|#
directive|define
name|elf_backend_begin_write_processing
value|ppc_elf_begin_write_processing
end_define

begin_define
define|#
directive|define
name|elf_backend_final_write_processing
value|ppc_elf_final_write_processing
end_define

begin_define
define|#
directive|define
name|elf_backend_write_section
value|ppc_elf_write_section
end_define

begin_define
define|#
directive|define
name|elf_backend_special_sections
value|ppc_elf_special_sections
end_define

begin_include
include|#
directive|include
file|"elf32-target.h"
end_include

end_unit

