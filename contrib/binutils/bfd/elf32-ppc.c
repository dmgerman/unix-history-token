begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* PowerPC-specific support for 32-bit ELF    Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,    2004, 2005, 2006, 2007 Free Software Foundation, Inc.    Written by Ian Lance Taylor, Cygnus Support.     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the    Free Software Foundation, Inc., 51 Franklin Street - Fifth Floor,    Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* This file is based on a preliminary PowerPC ELF ABI.  The    information may not match the final PowerPC ELF ABI.  It includes    suggestions from the in-progress Embedded PowerPC ABI, and that    information may also not match.  */
end_comment

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf/ppc.h"
end_include

begin_include
include|#
directive|include
file|"elf32-ppc.h"
end_include

begin_include
include|#
directive|include
file|"elf-vxworks.h"
end_include

begin_comment
comment|/* RELA relocations are used here.  */
end_comment

begin_function_decl
specifier|static
name|bfd_reloc_status_type
name|ppc_elf_addr16_ha_reloc
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|arelent
modifier|*
parameter_list|,
name|asymbol
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_reloc_status_type
name|ppc_elf_unhandled_reloc
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|arelent
modifier|*
parameter_list|,
name|asymbol
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Branch prediction bit for branch taken relocs.  */
end_comment

begin_define
define|#
directive|define
name|BRANCH_PREDICT_BIT
value|0x200000
end_define

begin_comment
comment|/* Mask to set RA in memory instructions.  */
end_comment

begin_define
define|#
directive|define
name|RA_REGISTER_MASK
value|0x001f0000
end_define

begin_comment
comment|/* Value to shift register by to insert RA.  */
end_comment

begin_define
define|#
directive|define
name|RA_REGISTER_SHIFT
value|16
end_define

begin_comment
comment|/* The name of the dynamic interpreter.  This is put in the .interp    section.  */
end_comment

begin_define
define|#
directive|define
name|ELF_DYNAMIC_INTERPRETER
value|"/usr/lib/ld.so.1"
end_define

begin_comment
comment|/* For old-style PLT.  */
end_comment

begin_comment
comment|/* The number of single-slot PLT entries (the rest use two slots).  */
end_comment

begin_define
define|#
directive|define
name|PLT_NUM_SINGLE_ENTRIES
value|8192
end_define

begin_comment
comment|/* For new-style .glink and .plt.  */
end_comment

begin_define
define|#
directive|define
name|GLINK_PLTRESOLVE
value|16*4
end_define

begin_define
define|#
directive|define
name|GLINK_ENTRY_SIZE
value|4*4
end_define

begin_comment
comment|/* VxWorks uses its own plt layout, filled in by the static linker.  */
end_comment

begin_comment
comment|/* The standard VxWorks PLT entry.  */
end_comment

begin_define
define|#
directive|define
name|VXWORKS_PLT_ENTRY_SIZE
value|32
end_define

begin_decl_stmt
specifier|static
specifier|const
name|bfd_vma
name|ppc_elf_vxworks_plt_entry
index|[
name|VXWORKS_PLT_ENTRY_SIZE
operator|/
literal|4
index|]
init|=
block|{
literal|0x3d800000
block|,
comment|/* lis     r12,0                 */
literal|0x818c0000
block|,
comment|/* lwz     r12,0(r12)            */
literal|0x7d8903a6
block|,
comment|/* mtctr   r12                   */
literal|0x4e800420
block|,
comment|/* bctr                          */
literal|0x39600000
block|,
comment|/* li      r11,0                 */
literal|0x48000000
block|,
comment|/* b       14<.PLT0resolve+0x4> */
literal|0x60000000
block|,
comment|/* nop                           */
literal|0x60000000
block|,
comment|/* nop                           */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|bfd_vma
name|ppc_elf_vxworks_pic_plt_entry
index|[
name|VXWORKS_PLT_ENTRY_SIZE
operator|/
literal|4
index|]
init|=
block|{
literal|0x3d9e0000
block|,
comment|/* addis r12,r30,0 */
literal|0x818c0000
block|,
comment|/* lwz	 r12,0(r12) */
literal|0x7d8903a6
block|,
comment|/* mtctr r12 */
literal|0x4e800420
block|,
comment|/* bctr */
literal|0x39600000
block|,
comment|/* li	 r11,0 */
literal|0x48000000
block|,
comment|/* b	 14<.PLT0resolve+0x4> 14: R_PPC_REL24 .PLTresolve */
literal|0x60000000
block|,
comment|/* nop */
literal|0x60000000
block|,
comment|/* nop */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The initial VxWorks PLT entry.  */
end_comment

begin_define
define|#
directive|define
name|VXWORKS_PLT_INITIAL_ENTRY_SIZE
value|32
end_define

begin_decl_stmt
specifier|static
specifier|const
name|bfd_vma
name|ppc_elf_vxworks_plt0_entry
index|[
name|VXWORKS_PLT_INITIAL_ENTRY_SIZE
operator|/
literal|4
index|]
init|=
block|{
literal|0x3d800000
block|,
comment|/* lis     r12,0        */
literal|0x398c0000
block|,
comment|/* addi    r12,r12,0    */
literal|0x800c0008
block|,
comment|/* lwz     r0,8(r12)    */
literal|0x7c0903a6
block|,
comment|/* mtctr   r0           */
literal|0x818c0004
block|,
comment|/* lwz     r12,4(r12)   */
literal|0x4e800420
block|,
comment|/* bctr                 */
literal|0x60000000
block|,
comment|/* nop                  */
literal|0x60000000
block|,
comment|/* nop                  */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|bfd_vma
name|ppc_elf_vxworks_pic_plt0_entry
index|[
name|VXWORKS_PLT_INITIAL_ENTRY_SIZE
operator|/
literal|4
index|]
init|=
block|{
literal|0x819e0008
block|,
comment|/* lwz	 r12,8(r30) */
literal|0x7d8903a6
block|,
comment|/* mtctr r12        */
literal|0x819e0004
block|,
comment|/* lwz	 r12,4(r30) */
literal|0x4e800420
block|,
comment|/* bctr             */
literal|0x60000000
block|,
comment|/* nop              */
literal|0x60000000
block|,
comment|/* nop              */
literal|0x60000000
block|,
comment|/* nop              */
literal|0x60000000
block|,
comment|/* nop              */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For executables, we have some additional relocations in    .rela.plt.unloaded, for the kernel loader.  */
end_comment

begin_comment
comment|/* The number of non-JMP_SLOT relocations per PLT0 slot. */
end_comment

begin_define
define|#
directive|define
name|VXWORKS_PLT_NON_JMP_SLOT_RELOCS
value|3
end_define

begin_comment
comment|/* The number of relocations in the PLTResolve slot. */
end_comment

begin_define
define|#
directive|define
name|VXWORKS_PLTRESOLVE_RELOCS
value|2
end_define

begin_comment
comment|/* The number of relocations in the PLTResolve slot when when creating    a shared library. */
end_comment

begin_define
define|#
directive|define
name|VXWORKS_PLTRESOLVE_RELOCS_SHLIB
value|0
end_define

begin_comment
comment|/* Some instructions.  */
end_comment

begin_define
define|#
directive|define
name|ADDIS_11_11
value|0x3d6b0000
end_define

begin_define
define|#
directive|define
name|ADDIS_11_30
value|0x3d7e0000
end_define

begin_define
define|#
directive|define
name|ADDIS_12_12
value|0x3d8c0000
end_define

begin_define
define|#
directive|define
name|ADDI_11_11
value|0x396b0000
end_define

begin_define
define|#
directive|define
name|ADD_0_11_11
value|0x7c0b5a14
end_define

begin_define
define|#
directive|define
name|ADD_11_0_11
value|0x7d605a14
end_define

begin_define
define|#
directive|define
name|B
value|0x48000000
end_define

begin_define
define|#
directive|define
name|BCL_20_31
value|0x429f0005
end_define

begin_define
define|#
directive|define
name|BCTR
value|0x4e800420
end_define

begin_define
define|#
directive|define
name|LIS_11
value|0x3d600000
end_define

begin_define
define|#
directive|define
name|LIS_12
value|0x3d800000
end_define

begin_define
define|#
directive|define
name|LWZU_0_12
value|0x840c0000
end_define

begin_define
define|#
directive|define
name|LWZ_0_12
value|0x800c0000
end_define

begin_define
define|#
directive|define
name|LWZ_11_11
value|0x816b0000
end_define

begin_define
define|#
directive|define
name|LWZ_11_30
value|0x817e0000
end_define

begin_define
define|#
directive|define
name|LWZ_12_12
value|0x818c0000
end_define

begin_define
define|#
directive|define
name|MFLR_0
value|0x7c0802a6
end_define

begin_define
define|#
directive|define
name|MFLR_12
value|0x7d8802a6
end_define

begin_define
define|#
directive|define
name|MTCTR_0
value|0x7c0903a6
end_define

begin_define
define|#
directive|define
name|MTCTR_11
value|0x7d6903a6
end_define

begin_define
define|#
directive|define
name|MTLR_0
value|0x7c0803a6
end_define

begin_define
define|#
directive|define
name|NOP
value|0x60000000
end_define

begin_define
define|#
directive|define
name|SUB_11_11_12
value|0x7d6c5850
end_define

begin_comment
comment|/* Offset of tp and dtp pointers from start of TLS block.  */
end_comment

begin_define
define|#
directive|define
name|TP_OFFSET
value|0x7000
end_define

begin_define
define|#
directive|define
name|DTP_OFFSET
value|0x8000
end_define

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|reloc_howto_type
modifier|*
name|ppc_elf_howto_table
index|[
name|R_PPC_max
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|ppc_elf_howto_raw
index|[]
init|=
block|{
comment|/* This reloc does nothing.  */
name|HOWTO
argument_list|(
name|R_PPC_NONE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_NONE"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A standard 32 bit relocation.  */
name|HOWTO
argument_list|(
name|R_PPC_ADDR32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_ADDR32"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* An absolute 26 bit branch; the lower two bits must be zero.      FIXME: we don't check that, we just clear them.  */
name|HOWTO
argument_list|(
name|R_PPC_ADDR24
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|26
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_ADDR24"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffffc
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A standard 16 bit relocation.  */
name|HOWTO
argument_list|(
name|R_PPC_ADDR16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_ADDR16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 16 bit relocation without overflow.  */
name|HOWTO
argument_list|(
name|R_PPC_ADDR16_LO
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_ADDR16_LO"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The high order 16 bits of an address.  */
name|HOWTO
argument_list|(
name|R_PPC_ADDR16_HI
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_ADDR16_HI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The high order 16 bits of an address, plus 1 if the contents of      the low 16 bits, treated as a signed number, is negative.  */
name|HOWTO
argument_list|(
name|R_PPC_ADDR16_HA
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_addr16_ha_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_ADDR16_HA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* An absolute 16 bit branch; the lower two bits must be zero.      FIXME: we don't check that, we just clear them.  */
name|HOWTO
argument_list|(
name|R_PPC_ADDR14
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_ADDR14"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* An absolute 16 bit branch, for which bit 10 should be set to      indicate that the branch is expected to be taken.	The lower two      bits must be zero.  */
name|HOWTO
argument_list|(
name|R_PPC_ADDR14_BRTAKEN
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_ADDR14_BRTAKEN"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* An absolute 16 bit branch, for which bit 10 should be set to      indicate that the branch is not expected to be taken.  The lower      two bits must be zero.  */
name|HOWTO
argument_list|(
name|R_PPC_ADDR14_BRNTAKEN
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_ADDR14_BRNTAKEN"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A relative 26 bit branch; the lower two bits must be zero.  */
name|HOWTO
argument_list|(
name|R_PPC_REL24
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|26
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_REL24"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffffc
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A relative 16 bit branch; the lower two bits must be zero.  */
name|HOWTO
argument_list|(
name|R_PPC_REL14
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_REL14"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A relative 16 bit branch.  Bit 10 should be set to indicate that      the branch is expected to be taken.  The lower two bits must be      zero.  */
name|HOWTO
argument_list|(
name|R_PPC_REL14_BRTAKEN
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_REL14_BRTAKEN"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A relative 16 bit branch.  Bit 10 should be set to indicate that      the branch is not expected to be taken.  The lower two bits must      be zero.  */
name|HOWTO
argument_list|(
name|R_PPC_REL14_BRNTAKEN
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_REL14_BRNTAKEN"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC_ADDR16, but referring to the GOT table entry for the      symbol.  */
name|HOWTO
argument_list|(
name|R_PPC_GOT16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_GOT16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC_ADDR16_LO, but referring to the GOT table entry for      the symbol.  */
name|HOWTO
argument_list|(
name|R_PPC_GOT16_LO
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_GOT16_LO"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC_ADDR16_HI, but referring to the GOT table entry for      the symbol.  */
name|HOWTO
argument_list|(
name|R_PPC_GOT16_HI
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_GOT16_HI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC_ADDR16_HA, but referring to the GOT table entry for      the symbol.  */
name|HOWTO
argument_list|(
name|R_PPC_GOT16_HA
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_addr16_ha_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_GOT16_HA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC_REL24, but referring to the procedure linkage table      entry for the symbol.  */
name|HOWTO
argument_list|(
name|R_PPC_PLTREL24
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|26
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_PLTREL24"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffffc
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* This is used only by the dynamic linker.  The symbol should exist      both in the object being run and in some shared library.  The      dynamic linker copies the data addressed by the symbol from the      shared library into the object, because the object being      run has to have the data at some particular address.  */
name|HOWTO
argument_list|(
name|R_PPC_COPY
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_COPY"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC_ADDR32, but used when setting global offset table      entries.  */
name|HOWTO
argument_list|(
name|R_PPC_GLOB_DAT
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_GLOB_DAT"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Marks a procedure linkage table entry for a symbol.  */
name|HOWTO
argument_list|(
name|R_PPC_JMP_SLOT
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_JMP_SLOT"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used only by the dynamic linker.  When the object is run, this      longword is set to the load address of the object, plus the      addend.  */
name|HOWTO
argument_list|(
name|R_PPC_RELATIVE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_RELATIVE"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC_REL24, but uses the value of the symbol within the      object rather than the final value.  Normally used for      _GLOBAL_OFFSET_TABLE_.  */
name|HOWTO
argument_list|(
name|R_PPC_LOCAL24PC
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|26
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_LOCAL24PC"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffffc
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC_ADDR32, but may be unaligned.  */
name|HOWTO
argument_list|(
name|R_PPC_UADDR32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_UADDR32"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC_ADDR16, but may be unaligned.  */
name|HOWTO
argument_list|(
name|R_PPC_UADDR16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_UADDR16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 32-bit PC relative */
name|HOWTO
argument_list|(
name|R_PPC_REL32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_REL32"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 32-bit relocation to the symbol's procedure linkage table.      FIXME: not supported.  */
name|HOWTO
argument_list|(
name|R_PPC_PLT32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_PLT32"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 32-bit PC relative relocation to the symbol's procedure linkage table.      FIXME: not supported.  */
name|HOWTO
argument_list|(
name|R_PPC_PLTREL32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_PLTREL32"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC_ADDR16_LO, but referring to the PLT table entry for      the symbol.  */
name|HOWTO
argument_list|(
name|R_PPC_PLT16_LO
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_PLT16_LO"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC_ADDR16_HI, but referring to the PLT table entry for      the symbol.  */
name|HOWTO
argument_list|(
name|R_PPC_PLT16_HI
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_PLT16_HI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_PPC_ADDR16_HA, but referring to the PLT table entry for      the symbol.  */
name|HOWTO
argument_list|(
name|R_PPC_PLT16_HA
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_addr16_ha_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_PLT16_HA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A sign-extended 16 bit value relative to _SDA_BASE_, for use with      small data items.  */
name|HOWTO
argument_list|(
name|R_PPC_SDAREL16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_SDAREL16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16-bit section relative relocation.  */
name|HOWTO
argument_list|(
name|R_PPC_SECTOFF
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_SECTOFF"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16-bit lower half section relative relocation.  */
name|HOWTO
argument_list|(
name|R_PPC_SECTOFF_LO
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_SECTOFF_LO"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16-bit upper half section relative relocation.  */
name|HOWTO
argument_list|(
name|R_PPC_SECTOFF_HI
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_SECTOFF_HI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16-bit upper half adjusted section relative relocation.  */
name|HOWTO
argument_list|(
name|R_PPC_SECTOFF_HA
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_addr16_ha_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_SECTOFF_HA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Marker reloc for TLS.  */
name|HOWTO
argument_list|(
name|R_PPC_TLS
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_TLS"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Computes the load module index of the load module that contains the      definition of its TLS sym.  */
name|HOWTO
argument_list|(
name|R_PPC_DTPMOD32
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_DTPMOD32"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Computes a dtv-relative displacement, the difference between the value      of sym+add and the base address of the thread-local storage block that      contains the definition of sym, minus 0x8000.  */
name|HOWTO
argument_list|(
name|R_PPC_DTPREL32
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_DTPREL32"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 16 bit dtprel reloc.  */
name|HOWTO
argument_list|(
name|R_PPC_DTPREL16
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_DTPREL16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like DTPREL16, but no overflow.  */
name|HOWTO
argument_list|(
name|R_PPC_DTPREL16_LO
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_DTPREL16_LO"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like DTPREL16_LO, but next higher group of 16 bits.  */
name|HOWTO
argument_list|(
name|R_PPC_DTPREL16_HI
argument_list|,
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_DTPREL16_HI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like DTPREL16_HI, but adjust for low 16 bits.  */
name|HOWTO
argument_list|(
name|R_PPC_DTPREL16_HA
argument_list|,
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_DTPREL16_HA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Computes a tp-relative displacement, the difference between the value of      sym+add and the value of the thread pointer (r13).  */
name|HOWTO
argument_list|(
name|R_PPC_TPREL32
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_TPREL32"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 16 bit tprel reloc.  */
name|HOWTO
argument_list|(
name|R_PPC_TPREL16
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_TPREL16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like TPREL16, but no overflow.  */
name|HOWTO
argument_list|(
name|R_PPC_TPREL16_LO
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_TPREL16_LO"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like TPREL16_LO, but next higher group of 16 bits.  */
name|HOWTO
argument_list|(
name|R_PPC_TPREL16_HI
argument_list|,
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_TPREL16_HI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like TPREL16_HI, but adjust for low 16 bits.  */
name|HOWTO
argument_list|(
name|R_PPC_TPREL16_HA
argument_list|,
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_TPREL16_HA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Allocates two contiguous entries in the GOT to hold a tls_index structure,      with values (sym+add)@dtpmod and (sym+add)@dtprel, and computes the offset      to the first entry.  */
name|HOWTO
argument_list|(
name|R_PPC_GOT_TLSGD16
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_GOT_TLSGD16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like GOT_TLSGD16, but no overflow.  */
name|HOWTO
argument_list|(
name|R_PPC_GOT_TLSGD16_LO
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_GOT_TLSGD16_LO"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like GOT_TLSGD16_LO, but next higher group of 16 bits.  */
name|HOWTO
argument_list|(
name|R_PPC_GOT_TLSGD16_HI
argument_list|,
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_GOT_TLSGD16_HI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like GOT_TLSGD16_HI, but adjust for low 16 bits.  */
name|HOWTO
argument_list|(
name|R_PPC_GOT_TLSGD16_HA
argument_list|,
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_GOT_TLSGD16_HA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Allocates two contiguous entries in the GOT to hold a tls_index structure,      with values (sym+add)@dtpmod and zero, and computes the offset to the      first entry.  */
name|HOWTO
argument_list|(
name|R_PPC_GOT_TLSLD16
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_GOT_TLSLD16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like GOT_TLSLD16, but no overflow.  */
name|HOWTO
argument_list|(
name|R_PPC_GOT_TLSLD16_LO
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_GOT_TLSLD16_LO"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like GOT_TLSLD16_LO, but next higher group of 16 bits.  */
name|HOWTO
argument_list|(
name|R_PPC_GOT_TLSLD16_HI
argument_list|,
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_GOT_TLSLD16_HI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like GOT_TLSLD16_HI, but adjust for low 16 bits.  */
name|HOWTO
argument_list|(
name|R_PPC_GOT_TLSLD16_HA
argument_list|,
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_GOT_TLSLD16_HA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Allocates an entry in the GOT with value (sym+add)@dtprel, and computes      the offset to the entry.  */
name|HOWTO
argument_list|(
name|R_PPC_GOT_DTPREL16
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_GOT_DTPREL16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like GOT_DTPREL16, but no overflow.  */
name|HOWTO
argument_list|(
name|R_PPC_GOT_DTPREL16_LO
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_GOT_DTPREL16_LO"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like GOT_DTPREL16_LO, but next higher group of 16 bits.  */
name|HOWTO
argument_list|(
name|R_PPC_GOT_DTPREL16_HI
argument_list|,
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_GOT_DTPREL16_HI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like GOT_DTPREL16_HI, but adjust for low 16 bits.  */
name|HOWTO
argument_list|(
name|R_PPC_GOT_DTPREL16_HA
argument_list|,
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_GOT_DTPREL16_HA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Allocates an entry in the GOT with value (sym+add)@tprel, and computes the      offset to the entry.  */
name|HOWTO
argument_list|(
name|R_PPC_GOT_TPREL16
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_GOT_TPREL16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like GOT_TPREL16, but no overflow.  */
name|HOWTO
argument_list|(
name|R_PPC_GOT_TPREL16_LO
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_GOT_TPREL16_LO"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like GOT_TPREL16_LO, but next higher group of 16 bits.  */
name|HOWTO
argument_list|(
name|R_PPC_GOT_TPREL16_HI
argument_list|,
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_GOT_TPREL16_HI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like GOT_TPREL16_HI, but adjust for low 16 bits.  */
name|HOWTO
argument_list|(
name|R_PPC_GOT_TPREL16_HA
argument_list|,
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_unhandled_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_GOT_TPREL16_HA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The remaining relocs are from the Embedded ELF ABI, and are not      in the SVR4 ELF ABI.  */
comment|/* 32 bit value resulting from the addend minus the symbol.  */
name|HOWTO
argument_list|(
name|R_PPC_EMB_NADDR32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_EMB_NADDR32"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16 bit value resulting from the addend minus the symbol.  */
name|HOWTO
argument_list|(
name|R_PPC_EMB_NADDR16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_EMB_NADDR16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16 bit value resulting from the addend minus the symbol.  */
name|HOWTO
argument_list|(
name|R_PPC_EMB_NADDR16_LO
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_EMB_ADDR16_LO"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The high order 16 bits of the addend minus the symbol.  */
name|HOWTO
argument_list|(
name|R_PPC_EMB_NADDR16_HI
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_EMB_NADDR16_HI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The high order 16 bits of the result of the addend minus the address,      plus 1 if the contents of the low 16 bits, treated as a signed number,      is negative.  */
name|HOWTO
argument_list|(
name|R_PPC_EMB_NADDR16_HA
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_addr16_ha_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_EMB_NADDR16_HA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16 bit value resulting from allocating a 4 byte word to hold an      address in the .sdata section, and returning the offset from      _SDA_BASE_ for that relocation.  */
name|HOWTO
argument_list|(
name|R_PPC_EMB_SDAI16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_EMB_SDAI16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16 bit value resulting from allocating a 4 byte word to hold an      address in the .sdata2 section, and returning the offset from      _SDA2_BASE_ for that relocation.  */
name|HOWTO
argument_list|(
name|R_PPC_EMB_SDA2I16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_EMB_SDA2I16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A sign-extended 16 bit value relative to _SDA2_BASE_, for use with      small data items.	 */
name|HOWTO
argument_list|(
name|R_PPC_EMB_SDA2REL
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_EMB_SDA2REL"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Relocate against either _SDA_BASE_ or _SDA2_BASE_, filling in the 16 bit      signed offset from the appropriate base, and filling in the register      field with the appropriate register (0, 2, or 13).  */
name|HOWTO
argument_list|(
name|R_PPC_EMB_SDA21
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_EMB_SDA21"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Relocation not handled: R_PPC_EMB_MRKREF */
comment|/* Relocation not handled: R_PPC_EMB_RELSEC16 */
comment|/* Relocation not handled: R_PPC_EMB_RELST_LO */
comment|/* Relocation not handled: R_PPC_EMB_RELST_HI */
comment|/* Relocation not handled: R_PPC_EMB_RELST_HA */
comment|/* Relocation not handled: R_PPC_EMB_BIT_FLD */
comment|/* PC relative relocation against either _SDA_BASE_ or _SDA2_BASE_, filling      in the 16 bit signed offset from the appropriate base, and filling in the      register field with the appropriate register (0, 2, or 13).  */
name|HOWTO
argument_list|(
name|R_PPC_EMB_RELSDA
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_EMB_RELSDA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 16 bit relative relocation.  */
name|HOWTO
argument_list|(
name|R_PPC_REL16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_REL16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 16 bit relative relocation without overflow.  */
name|HOWTO
argument_list|(
name|R_PPC_REL16_LO
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_REL16_LO"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The high order 16 bits of a relative address.  */
name|HOWTO
argument_list|(
name|R_PPC_REL16_HI
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_REL16_HI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The high order 16 bits of a relative address, plus 1 if the contents of      the low 16 bits, treated as a signed number, is negative.  */
name|HOWTO
argument_list|(
name|R_PPC_REL16_HA
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|ppc_elf_addr16_ha_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_REL16_HA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* GNU extension to record C++ vtable hierarchy.  */
name|HOWTO
argument_list|(
name|R_PPC_GNU_VTINHERIT
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|NULL
argument_list|,
comment|/* special_function */
literal|"R_PPC_GNU_VTINHERIT"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* GNU extension to record C++ vtable member usage.  */
name|HOWTO
argument_list|(
name|R_PPC_GNU_VTENTRY
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|NULL
argument_list|,
comment|/* special_function */
literal|"R_PPC_GNU_VTENTRY"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Phony reloc to handle AIX style TOC entries.  */
name|HOWTO
argument_list|(
name|R_PPC_TOC16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_PPC_TOC16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Initialize the ppc_elf_howto_table, so that linear accesses can be done.  */
end_comment

begin_function
specifier|static
name|void
name|ppc_elf_howto_init
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|type
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|ppc_elf_howto_raw
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|ppc_elf_howto_raw
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|type
operator|=
name|ppc_elf_howto_raw
index|[
name|i
index|]
operator|.
name|type
expr_stmt|;
if|if
condition|(
name|type
operator|>=
operator|(
sizeof|sizeof
argument_list|(
name|ppc_elf_howto_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|ppc_elf_howto_table
index|[
literal|0
index|]
argument_list|)
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|ppc_elf_howto_table
index|[
name|type
index|]
operator|=
operator|&
name|ppc_elf_howto_raw
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|ppc_elf_reloc_type_lookup
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd_reloc_code_real_type
name|code
parameter_list|)
block|{
name|enum
name|elf_ppc_reloc_type
name|r
decl_stmt|;
comment|/* Initialize howto table if not already done.  */
if|if
condition|(
operator|!
name|ppc_elf_howto_table
index|[
name|R_PPC_ADDR32
index|]
condition|)
name|ppc_elf_howto_init
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
default|default:
return|return
name|NULL
return|;
case|case
name|BFD_RELOC_NONE
case|:
name|r
operator|=
name|R_PPC_NONE
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32
case|:
name|r
operator|=
name|R_PPC_ADDR32
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_BA26
case|:
name|r
operator|=
name|R_PPC_ADDR24
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_16
case|:
name|r
operator|=
name|R_PPC_ADDR16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_LO16
case|:
name|r
operator|=
name|R_PPC_ADDR16_LO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16
case|:
name|r
operator|=
name|R_PPC_ADDR16_HI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16_S
case|:
name|r
operator|=
name|R_PPC_ADDR16_HA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_BA16
case|:
name|r
operator|=
name|R_PPC_ADDR14
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_BA16_BRTAKEN
case|:
name|r
operator|=
name|R_PPC_ADDR14_BRTAKEN
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_BA16_BRNTAKEN
case|:
name|r
operator|=
name|R_PPC_ADDR14_BRNTAKEN
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_B26
case|:
name|r
operator|=
name|R_PPC_REL24
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_B16
case|:
name|r
operator|=
name|R_PPC_REL14
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_B16_BRTAKEN
case|:
name|r
operator|=
name|R_PPC_REL14_BRTAKEN
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_B16_BRNTAKEN
case|:
name|r
operator|=
name|R_PPC_REL14_BRNTAKEN
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_16_GOTOFF
case|:
name|r
operator|=
name|R_PPC_GOT16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_LO16_GOTOFF
case|:
name|r
operator|=
name|R_PPC_GOT16_LO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16_GOTOFF
case|:
name|r
operator|=
name|R_PPC_GOT16_HI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16_S_GOTOFF
case|:
name|r
operator|=
name|R_PPC_GOT16_HA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_24_PLT_PCREL
case|:
name|r
operator|=
name|R_PPC_PLTREL24
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_COPY
case|:
name|r
operator|=
name|R_PPC_COPY
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GLOB_DAT
case|:
name|r
operator|=
name|R_PPC_GLOB_DAT
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_LOCAL24PC
case|:
name|r
operator|=
name|R_PPC_LOCAL24PC
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32_PCREL
case|:
name|r
operator|=
name|R_PPC_REL32
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32_PLTOFF
case|:
name|r
operator|=
name|R_PPC_PLT32
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32_PLT_PCREL
case|:
name|r
operator|=
name|R_PPC_PLTREL32
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_LO16_PLTOFF
case|:
name|r
operator|=
name|R_PPC_PLT16_LO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16_PLTOFF
case|:
name|r
operator|=
name|R_PPC_PLT16_HI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16_S_PLTOFF
case|:
name|r
operator|=
name|R_PPC_PLT16_HA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_GPREL16
case|:
name|r
operator|=
name|R_PPC_SDAREL16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_16_BASEREL
case|:
name|r
operator|=
name|R_PPC_SECTOFF
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_LO16_BASEREL
case|:
name|r
operator|=
name|R_PPC_SECTOFF_LO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16_BASEREL
case|:
name|r
operator|=
name|R_PPC_SECTOFF_HI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16_S_BASEREL
case|:
name|r
operator|=
name|R_PPC_SECTOFF_HA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_CTOR
case|:
name|r
operator|=
name|R_PPC_ADDR32
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_TOC16
case|:
name|r
operator|=
name|R_PPC_TOC16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_TLS
case|:
name|r
operator|=
name|R_PPC_TLS
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_DTPMOD
case|:
name|r
operator|=
name|R_PPC_DTPMOD32
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_TPREL16
case|:
name|r
operator|=
name|R_PPC_TPREL16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_TPREL16_LO
case|:
name|r
operator|=
name|R_PPC_TPREL16_LO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_TPREL16_HI
case|:
name|r
operator|=
name|R_PPC_TPREL16_HI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_TPREL16_HA
case|:
name|r
operator|=
name|R_PPC_TPREL16_HA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_TPREL
case|:
name|r
operator|=
name|R_PPC_TPREL32
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_DTPREL16
case|:
name|r
operator|=
name|R_PPC_DTPREL16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_DTPREL16_LO
case|:
name|r
operator|=
name|R_PPC_DTPREL16_LO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_DTPREL16_HI
case|:
name|r
operator|=
name|R_PPC_DTPREL16_HI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_DTPREL16_HA
case|:
name|r
operator|=
name|R_PPC_DTPREL16_HA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_DTPREL
case|:
name|r
operator|=
name|R_PPC_DTPREL32
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GOT_TLSGD16
case|:
name|r
operator|=
name|R_PPC_GOT_TLSGD16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GOT_TLSGD16_LO
case|:
name|r
operator|=
name|R_PPC_GOT_TLSGD16_LO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GOT_TLSGD16_HI
case|:
name|r
operator|=
name|R_PPC_GOT_TLSGD16_HI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GOT_TLSGD16_HA
case|:
name|r
operator|=
name|R_PPC_GOT_TLSGD16_HA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GOT_TLSLD16
case|:
name|r
operator|=
name|R_PPC_GOT_TLSLD16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GOT_TLSLD16_LO
case|:
name|r
operator|=
name|R_PPC_GOT_TLSLD16_LO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GOT_TLSLD16_HI
case|:
name|r
operator|=
name|R_PPC_GOT_TLSLD16_HI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GOT_TLSLD16_HA
case|:
name|r
operator|=
name|R_PPC_GOT_TLSLD16_HA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GOT_TPREL16
case|:
name|r
operator|=
name|R_PPC_GOT_TPREL16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GOT_TPREL16_LO
case|:
name|r
operator|=
name|R_PPC_GOT_TPREL16_LO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GOT_TPREL16_HI
case|:
name|r
operator|=
name|R_PPC_GOT_TPREL16_HI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GOT_TPREL16_HA
case|:
name|r
operator|=
name|R_PPC_GOT_TPREL16_HA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GOT_DTPREL16
case|:
name|r
operator|=
name|R_PPC_GOT_DTPREL16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GOT_DTPREL16_LO
case|:
name|r
operator|=
name|R_PPC_GOT_DTPREL16_LO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GOT_DTPREL16_HI
case|:
name|r
operator|=
name|R_PPC_GOT_DTPREL16_HI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_GOT_DTPREL16_HA
case|:
name|r
operator|=
name|R_PPC_GOT_DTPREL16_HA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_EMB_NADDR32
case|:
name|r
operator|=
name|R_PPC_EMB_NADDR32
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_EMB_NADDR16
case|:
name|r
operator|=
name|R_PPC_EMB_NADDR16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_EMB_NADDR16_LO
case|:
name|r
operator|=
name|R_PPC_EMB_NADDR16_LO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_EMB_NADDR16_HI
case|:
name|r
operator|=
name|R_PPC_EMB_NADDR16_HI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_EMB_NADDR16_HA
case|:
name|r
operator|=
name|R_PPC_EMB_NADDR16_HA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_EMB_SDAI16
case|:
name|r
operator|=
name|R_PPC_EMB_SDAI16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_EMB_SDA2I16
case|:
name|r
operator|=
name|R_PPC_EMB_SDA2I16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_EMB_SDA2REL
case|:
name|r
operator|=
name|R_PPC_EMB_SDA2REL
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_EMB_SDA21
case|:
name|r
operator|=
name|R_PPC_EMB_SDA21
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_EMB_MRKREF
case|:
name|r
operator|=
name|R_PPC_EMB_MRKREF
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_EMB_RELSEC16
case|:
name|r
operator|=
name|R_PPC_EMB_RELSEC16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_EMB_RELST_LO
case|:
name|r
operator|=
name|R_PPC_EMB_RELST_LO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_EMB_RELST_HI
case|:
name|r
operator|=
name|R_PPC_EMB_RELST_HI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_EMB_RELST_HA
case|:
name|r
operator|=
name|R_PPC_EMB_RELST_HA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_EMB_BIT_FLD
case|:
name|r
operator|=
name|R_PPC_EMB_BIT_FLD
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_PPC_EMB_RELSDA
case|:
name|r
operator|=
name|R_PPC_EMB_RELSDA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_16_PCREL
case|:
name|r
operator|=
name|R_PPC_REL16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_LO16_PCREL
case|:
name|r
operator|=
name|R_PPC_REL16_LO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16_PCREL
case|:
name|r
operator|=
name|R_PPC_REL16_HI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16_S_PCREL
case|:
name|r
operator|=
name|R_PPC_REL16_HA
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_VTABLE_INHERIT
case|:
name|r
operator|=
name|R_PPC_GNU_VTINHERIT
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_VTABLE_ENTRY
case|:
name|r
operator|=
name|R_PPC_GNU_VTENTRY
expr_stmt|;
break|break;
block|}
return|return
name|ppc_elf_howto_table
index|[
name|r
index|]
return|;
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|ppc_elf_reloc_name_lookup
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|r_name
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|ppc_elf_howto_raw
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|ppc_elf_howto_raw
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ppc_elf_howto_raw
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
operator|&&
name|strcasecmp
argument_list|(
name|ppc_elf_howto_raw
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|r_name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|&
name|ppc_elf_howto_raw
index|[
name|i
index|]
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Set the howto pointer for a PowerPC ELF reloc.  */
end_comment

begin_function
specifier|static
name|void
name|ppc_elf_info_to_howto
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|arelent
modifier|*
name|cache_ptr
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|dst
parameter_list|)
block|{
comment|/* Initialize howto table if not already done.  */
if|if
condition|(
operator|!
name|ppc_elf_howto_table
index|[
name|R_PPC_ADDR32
index|]
condition|)
name|ppc_elf_howto_init
argument_list|()
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|ELF32_R_TYPE
argument_list|(
name|dst
operator|->
name|r_info
argument_list|)
operator|<
operator|(
name|unsigned
name|int
operator|)
name|R_PPC_max
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|howto
operator|=
name|ppc_elf_howto_table
index|[
name|ELF32_R_TYPE
argument_list|(
name|dst
operator|->
name|r_info
argument_list|)
index|]
expr_stmt|;
comment|/* Just because the above assert didn't trigger doesn't mean that      ELF32_R_TYPE (dst->r_info) is necessarily a valid relocation.  */
if|if
condition|(
operator|!
name|cache_ptr
operator|->
name|howto
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: invalid relocation type %d"
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|ELF32_R_TYPE
argument_list|(
name|dst
operator|->
name|r_info
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|howto
operator|=
name|ppc_elf_howto_table
index|[
name|R_PPC_NONE
index|]
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Handle the R_PPC_ADDR16_HA and R_PPC_REL16_HA relocs.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|ppc_elf_addr16_ha_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|bfd_vma
name|relocation
decl_stmt|;
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
condition|)
block|{
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
if|if
condition|(
name|reloc_entry
operator|->
name|address
operator|>
name|bfd_get_section_limit
argument_list|(
name|abfd
argument_list|,
name|input_section
argument_list|)
condition|)
return|return
name|bfd_reloc_outofrange
return|;
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
else|else
name|relocation
operator|=
name|symbol
operator|->
name|value
expr_stmt|;
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
name|relocation
operator|+=
name|reloc_entry
operator|->
name|addend
expr_stmt|;
if|if
condition|(
name|reloc_entry
operator|->
name|howto
operator|->
name|pc_relative
condition|)
name|relocation
operator|-=
name|reloc_entry
operator|->
name|address
expr_stmt|;
name|reloc_entry
operator|->
name|addend
operator|+=
operator|(
name|relocation
operator|&
literal|0x8000
operator|)
operator|<<
literal|1
expr_stmt|;
return|return
name|bfd_reloc_continue
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_status_type
name|ppc_elf_unhandled_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
parameter_list|)
block|{
comment|/* If this is a relocatable link (output_bfd test tells us), just      call the generic function.  Any adjustment will be done at final      link time.  */
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
condition|)
return|return
name|bfd_elf_generic_reloc
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
argument_list|,
name|symbol
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
name|error_message
argument_list|)
return|;
if|if
condition|(
name|error_message
operator|!=
name|NULL
condition|)
block|{
specifier|static
name|char
name|buf
index|[
literal|60
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
name|_
argument_list|(
literal|"generic linker can't handle %s"
argument_list|)
argument_list|,
name|reloc_entry
operator|->
name|howto
operator|->
name|name
argument_list|)
expr_stmt|;
operator|*
name|error_message
operator|=
name|buf
expr_stmt|;
block|}
return|return
name|bfd_reloc_dangerous
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Sections created by the linker.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|elf_linker_section
block|{
comment|/* Pointer to the bfd section.  */
name|asection
modifier|*
name|section
decl_stmt|;
comment|/* Section name.  */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Associated bss section name.  */
specifier|const
name|char
modifier|*
name|bss_name
decl_stmt|;
comment|/* Associated symbol name.  */
specifier|const
name|char
modifier|*
name|sym_name
decl_stmt|;
comment|/* Associated symbol.  */
name|struct
name|elf_link_hash_entry
modifier|*
name|sym
decl_stmt|;
block|}
name|elf_linker_section_t
typedef|;
end_typedef

begin_comment
comment|/* Linked list of allocated pointer entries.  This hangs off of the    symbol lists, and provides allows us to return different pointers,    based on different addend's.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|elf_linker_section_pointers
block|{
comment|/* next allocated pointer for this symbol */
name|struct
name|elf_linker_section_pointers
modifier|*
name|next
decl_stmt|;
comment|/* offset of pointer from beginning of section */
name|bfd_vma
name|offset
decl_stmt|;
comment|/* addend used */
name|bfd_vma
name|addend
decl_stmt|;
comment|/* which linker section this is */
name|elf_linker_section_t
modifier|*
name|lsect
decl_stmt|;
block|}
name|elf_linker_section_pointers_t
typedef|;
end_typedef

begin_struct
struct|struct
name|ppc_elf_obj_tdata
block|{
name|struct
name|elf_obj_tdata
name|elf
decl_stmt|;
comment|/* A mapping from local symbols to offsets into the various linker      sections added.  This is index by the symbol index.  */
name|elf_linker_section_pointers_t
modifier|*
modifier|*
name|linker_section_pointers
decl_stmt|;
comment|/* Flags used to auto-detect plt type.  */
name|unsigned
name|int
name|makes_plt_call
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|has_rel16
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|ppc_elf_tdata
parameter_list|(
name|bfd
parameter_list|)
define|\
value|((struct ppc_elf_obj_tdata *) (bfd)->tdata.any)
end_define

begin_define
define|#
directive|define
name|elf_local_ptr_offsets
parameter_list|(
name|bfd
parameter_list|)
define|\
value|(ppc_elf_tdata (bfd)->linker_section_pointers)
end_define

begin_comment
comment|/* Override the generic function because we store some extras.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc_elf_mkobject
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
if|if
condition|(
name|abfd
operator|->
name|tdata
operator|.
name|any
operator|==
name|NULL
condition|)
block|{
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|ppc_elf_obj_tdata
argument_list|)
decl_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|any
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|tdata
operator|.
name|any
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|bfd_elf_mkobject
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Fix bad default arch selected for a 32 bit input bfd when the    default is 64 bit.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc_elf_object_p
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
if|if
condition|(
name|abfd
operator|->
name|arch_info
operator|->
name|the_default
operator|&&
name|abfd
operator|->
name|arch_info
operator|->
name|bits_per_word
operator|==
literal|64
condition|)
block|{
name|Elf_Internal_Ehdr
modifier|*
name|i_ehdr
init|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
if|if
condition|(
name|i_ehdr
operator|->
name|e_ident
index|[
name|EI_CLASS
index|]
operator|==
name|ELFCLASS32
condition|)
block|{
comment|/* Relies on arch after 64 bit default being 32 bit default.  */
name|abfd
operator|->
name|arch_info
operator|=
name|abfd
operator|->
name|arch_info
operator|->
name|next
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|abfd
operator|->
name|arch_info
operator|->
name|bits_per_word
operator|==
literal|32
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Function to set whether a module needs the -mrelocatable bit set.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc_elf_set_private_flags
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|flagword
name|flags
parameter_list|)
block|{
name|BFD_ASSERT
argument_list|(
operator|!
name|elf_flags_init
argument_list|(
name|abfd
argument_list|)
operator|||
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|==
name|flags
argument_list|)
expr_stmt|;
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|=
name|flags
expr_stmt|;
name|elf_flags_init
argument_list|(
name|abfd
argument_list|)
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Support for core dump NOTE sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc_elf_grok_prstatus
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Note
modifier|*
name|note
parameter_list|)
block|{
name|int
name|offset
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
switch|switch
condition|(
name|note
operator|->
name|descsz
condition|)
block|{
default|default:
return|return
name|FALSE
return|;
case|case
literal|268
case|:
comment|/* Linux/PPC.  */
comment|/* pr_cursig */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_signal
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|note
operator|->
name|descdata
operator|+
literal|12
argument_list|)
expr_stmt|;
comment|/* pr_pid */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_pid
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|note
operator|->
name|descdata
operator|+
literal|24
argument_list|)
expr_stmt|;
comment|/* pr_reg */
name|offset
operator|=
literal|72
expr_stmt|;
name|size
operator|=
literal|192
expr_stmt|;
break|break;
block|}
comment|/* Make a ".reg/999" section.  */
return|return
name|_bfd_elfcore_make_pseudosection
argument_list|(
name|abfd
argument_list|,
literal|".reg"
argument_list|,
name|size
argument_list|,
name|note
operator|->
name|descpos
operator|+
name|offset
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|ppc_elf_grok_psinfo
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Note
modifier|*
name|note
parameter_list|)
block|{
switch|switch
condition|(
name|note
operator|->
name|descsz
condition|)
block|{
default|default:
return|return
name|FALSE
return|;
case|case
literal|128
case|:
comment|/* Linux/PPC elf_prpsinfo.  */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_program
operator|=
name|_bfd_elfcore_strndup
argument_list|(
name|abfd
argument_list|,
name|note
operator|->
name|descdata
operator|+
literal|32
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_command
operator|=
name|_bfd_elfcore_strndup
argument_list|(
name|abfd
argument_list|,
name|note
operator|->
name|descdata
operator|+
literal|48
argument_list|,
literal|80
argument_list|)
expr_stmt|;
block|}
comment|/* Note that for some reason, a spurious space is tacked      onto the end of the args in some (at least one anyway)      implementations, so strip it off if it exists.  */
block|{
name|char
modifier|*
name|command
init|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_command
decl_stmt|;
name|int
name|n
init|=
name|strlen
argument_list|(
name|command
argument_list|)
decl_stmt|;
if|if
condition|(
literal|0
operator|<
name|n
operator|&&
name|command
index|[
name|n
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
name|command
index|[
name|n
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|ppc_elf_write_core_note
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|bufsiz
parameter_list|,
name|int
name|note_type
parameter_list|,
modifier|...
parameter_list|)
block|{
switch|switch
condition|(
name|note_type
condition|)
block|{
default|default:
return|return
name|NULL
return|;
case|case
name|NT_PRPSINFO
case|:
block|{
name|char
name|data
index|[
literal|128
index|]
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|note_type
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|data
operator|+
literal|32
argument_list|,
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|data
operator|+
literal|48
argument_list|,
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|,
literal|80
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|elfcore_write_note
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|,
name|bufsiz
argument_list|,
literal|"CORE"
argument_list|,
name|note_type
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
return|;
block|}
case|case
name|NT_PRSTATUS
case|:
block|{
name|char
name|data
index|[
literal|268
index|]
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|long
name|pid
decl_stmt|;
name|int
name|cursig
decl_stmt|;
specifier|const
name|void
modifier|*
name|greg
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|note_type
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
literal|72
argument_list|)
expr_stmt|;
name|pid
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|long
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|pid
argument_list|,
name|data
operator|+
literal|24
argument_list|)
expr_stmt|;
name|cursig
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|cursig
argument_list|,
name|data
operator|+
literal|12
argument_list|)
expr_stmt|;
name|greg
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|data
operator|+
literal|72
argument_list|,
name|greg
argument_list|,
literal|192
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|data
operator|+
literal|264
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|elfcore_write_note
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|,
name|bufsiz
argument_list|,
literal|"CORE"
argument_list|,
name|note_type
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Return address for Ith PLT stub in section PLT, for relocation REL    or (bfd_vma) -1 if it should not be included.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|ppc_elf_plt_sym_val
parameter_list|(
name|bfd_vma
name|i
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|asection
modifier|*
name|plt
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|arelent
modifier|*
name|rel
parameter_list|)
block|{
return|return
name|rel
operator|->
name|address
return|;
block|}
end_function

begin_comment
comment|/* Handle a PowerPC specific section when reading an object file.  This    is called when bfd_section_from_shdr finds a section with an unknown    type.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc_elf_section_from_shdr
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Shdr
modifier|*
name|hdr
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|shindex
parameter_list|)
block|{
name|asection
modifier|*
name|newsect
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
if|if
condition|(
operator|!
name|_bfd_elf_make_section_from_shdr
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|,
name|name
argument_list|,
name|shindex
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|newsect
operator|=
name|hdr
operator|->
name|bfd_section
expr_stmt|;
name|flags
operator|=
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|newsect
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|sh_flags
operator|&
name|SHF_EXCLUDE
condition|)
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|sh_type
operator|==
name|SHT_ORDERED
condition|)
name|flags
operator||=
name|SEC_SORT_ENTRIES
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|newsect
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Set up any other section flags and such that may be necessary.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc_elf_fake_sections
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|Elf_Internal_Shdr
modifier|*
name|shdr
parameter_list|,
name|asection
modifier|*
name|asect
parameter_list|)
block|{
if|if
condition|(
operator|(
name|asect
operator|->
name|flags
operator|&
operator|(
name|SEC_GROUP
operator||
name|SEC_EXCLUDE
operator|)
operator|)
operator|==
name|SEC_EXCLUDE
condition|)
name|shdr
operator|->
name|sh_flags
operator||=
name|SHF_EXCLUDE
expr_stmt|;
if|if
condition|(
operator|(
name|asect
operator|->
name|flags
operator|&
name|SEC_SORT_ENTRIES
operator|)
operator|!=
literal|0
condition|)
name|shdr
operator|->
name|sh_type
operator|=
name|SHT_ORDERED
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* If we have .sbss2 or .PPC.EMB.sbss0 output sections, we    need to bump up the number of section headers.  */
end_comment

begin_function
specifier|static
name|int
name|ppc_elf_additional_program_headers
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".sbss2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
operator|++
name|ret
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".PPC.EMB.sbss0"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
operator|++
name|ret
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Add extra PPC sections -- Note, for now, make .sbss2 and    .PPC.EMB.sbss0 a normal section, and not a bss section so    that the linker doesn't crater when trying to make more than    2 sections.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|bfd_elf_special_section
name|ppc_elf_special_sections
index|[]
init|=
block|{
block|{
name|STRING_COMMA_LEN
argument_list|(
literal|".plt"
argument_list|)
block|,
literal|0
block|,
name|SHT_NOBITS
block|,
name|SHF_ALLOC
operator|+
name|SHF_EXECINSTR
block|}
block|,
block|{
name|STRING_COMMA_LEN
argument_list|(
literal|".sbss"
argument_list|)
block|,
operator|-
literal|2
block|,
name|SHT_NOBITS
block|,
name|SHF_ALLOC
operator|+
name|SHF_WRITE
block|}
block|,
block|{
name|STRING_COMMA_LEN
argument_list|(
literal|".sbss2"
argument_list|)
block|,
operator|-
literal|2
block|,
name|SHT_PROGBITS
block|,
name|SHF_ALLOC
block|}
block|,
block|{
name|STRING_COMMA_LEN
argument_list|(
literal|".sdata"
argument_list|)
block|,
operator|-
literal|2
block|,
name|SHT_PROGBITS
block|,
name|SHF_ALLOC
operator|+
name|SHF_WRITE
block|}
block|,
block|{
name|STRING_COMMA_LEN
argument_list|(
literal|".sdata2"
argument_list|)
block|,
operator|-
literal|2
block|,
name|SHT_PROGBITS
block|,
name|SHF_ALLOC
block|}
block|,
block|{
name|STRING_COMMA_LEN
argument_list|(
literal|".tags"
argument_list|)
block|,
literal|0
block|,
name|SHT_ORDERED
block|,
name|SHF_ALLOC
block|}
block|,
block|{
name|STRING_COMMA_LEN
argument_list|(
literal|".PPC.EMB.apuinfo"
argument_list|)
block|,
literal|0
block|,
name|SHT_NOTE
block|,
literal|0
block|}
block|,
block|{
name|STRING_COMMA_LEN
argument_list|(
literal|".PPC.EMB.sbss0"
argument_list|)
block|,
literal|0
block|,
name|SHT_PROGBITS
block|,
name|SHF_ALLOC
block|}
block|,
block|{
name|STRING_COMMA_LEN
argument_list|(
literal|".PPC.EMB.sdata0"
argument_list|)
block|,
literal|0
block|,
name|SHT_PROGBITS
block|,
name|SHF_ALLOC
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is what we want for new plt/got.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|bfd_elf_special_section
name|ppc_alt_plt
init|=
block|{
name|STRING_COMMA_LEN
argument_list|(
literal|".plt"
argument_list|)
block|,
literal|0
block|,
name|SHT_PROGBITS
block|,
name|SHF_ALLOC
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|const
name|struct
name|bfd_elf_special_section
modifier|*
name|ppc_elf_get_sec_type_attr
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|)
block|{
specifier|const
name|struct
name|bfd_elf_special_section
modifier|*
name|ssect
decl_stmt|;
comment|/* See if this is one of the special sections.  */
if|if
condition|(
name|sec
operator|->
name|name
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|ssect
operator|=
name|_bfd_elf_get_special_section
argument_list|(
name|sec
operator|->
name|name
argument_list|,
name|ppc_elf_special_sections
argument_list|,
name|sec
operator|->
name|use_rela_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssect
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ssect
operator|==
name|ppc_elf_special_sections
operator|&&
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|!=
literal|0
condition|)
name|ssect
operator|=
operator|&
name|ppc_alt_plt
expr_stmt|;
return|return
name|ssect
return|;
block|}
return|return
name|_bfd_elf_get_sec_type_attr
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Very simple linked list structure for recording apuinfo values.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|apuinfo_list
block|{
name|struct
name|apuinfo_list
modifier|*
name|next
decl_stmt|;
name|unsigned
name|long
name|value
decl_stmt|;
block|}
name|apuinfo_list
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|apuinfo_list
modifier|*
name|head
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|apuinfo_list_init
parameter_list|(
name|void
parameter_list|)
block|{
name|head
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|apuinfo_list_add
parameter_list|(
name|unsigned
name|long
name|value
parameter_list|)
block|{
name|apuinfo_list
modifier|*
name|entry
init|=
name|head
decl_stmt|;
while|while
condition|(
name|entry
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|entry
operator|->
name|value
operator|==
name|value
condition|)
return|return;
name|entry
operator|=
name|entry
operator|->
name|next
expr_stmt|;
block|}
name|entry
operator|=
name|bfd_malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
return|return;
name|entry
operator|->
name|value
operator|=
name|value
expr_stmt|;
name|entry
operator|->
name|next
operator|=
name|head
expr_stmt|;
name|head
operator|=
name|entry
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|apuinfo_list_length
parameter_list|(
name|void
parameter_list|)
block|{
name|apuinfo_list
modifier|*
name|entry
decl_stmt|;
name|unsigned
name|long
name|count
decl_stmt|;
for|for
control|(
name|entry
operator|=
name|head
operator|,
name|count
operator|=
literal|0
init|;
name|entry
condition|;
name|entry
operator|=
name|entry
operator|->
name|next
control|)
operator|++
name|count
expr_stmt|;
return|return
name|count
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|unsigned
name|long
name|apuinfo_list_element
parameter_list|(
name|unsigned
name|long
name|number
parameter_list|)
block|{
name|apuinfo_list
modifier|*
name|entry
decl_stmt|;
for|for
control|(
name|entry
operator|=
name|head
init|;
name|entry
operator|&&
name|number
operator|--
condition|;
name|entry
operator|=
name|entry
operator|->
name|next
control|)
empty_stmt|;
return|return
name|entry
condition|?
name|entry
operator|->
name|value
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|apuinfo_list_finish
parameter_list|(
name|void
parameter_list|)
block|{
name|apuinfo_list
modifier|*
name|entry
decl_stmt|;
for|for
control|(
name|entry
operator|=
name|head
init|;
name|entry
condition|;
control|)
block|{
name|apuinfo_list
modifier|*
name|next
init|=
name|entry
operator|->
name|next
decl_stmt|;
name|free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|entry
operator|=
name|next
expr_stmt|;
block|}
name|head
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|APUINFO_SECTION_NAME
value|".PPC.EMB.apuinfo"
end_define

begin_define
define|#
directive|define
name|APUINFO_LABEL
value|"APUinfo"
end_define

begin_comment
comment|/* Scan the input BFDs and create a linked list of    the APUinfo values that will need to be emitted.  */
end_comment

begin_function
specifier|static
name|void
name|ppc_elf_begin_write_processing
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
parameter_list|)
block|{
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|asection
modifier|*
name|asec
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|unsigned
name|num_input_sections
decl_stmt|;
name|bfd_size_type
name|output_section_size
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|unsigned
name|num_entries
decl_stmt|;
name|unsigned
name|long
name|offset
decl_stmt|;
name|unsigned
name|long
name|length
decl_stmt|;
specifier|const
name|char
modifier|*
name|error_message
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|link_info
operator|==
name|NULL
condition|)
return|return;
comment|/* Scan the input bfds, looking for apuinfo sections.  */
name|num_input_sections
operator|=
literal|0
expr_stmt|;
name|output_section_size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ibfd
operator|=
name|link_info
operator|->
name|input_bfds
init|;
name|ibfd
condition|;
name|ibfd
operator|=
name|ibfd
operator|->
name|link_next
control|)
block|{
name|asec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|ibfd
argument_list|,
name|APUINFO_SECTION_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|asec
condition|)
block|{
operator|++
name|num_input_sections
expr_stmt|;
name|output_section_size
operator|+=
name|asec
operator|->
name|size
expr_stmt|;
block|}
block|}
comment|/* We need at least one input sections      in order to make merging worthwhile.  */
if|if
condition|(
name|num_input_sections
operator|<
literal|1
condition|)
return|return;
comment|/* Just make sure that the output section exists as well.  */
name|asec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|APUINFO_SECTION_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|asec
operator|==
name|NULL
condition|)
return|return;
comment|/* Allocate a buffer for the contents of the input sections.  */
name|buffer
operator|=
name|bfd_malloc
argument_list|(
name|output_section_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|==
name|NULL
condition|)
return|return;
name|offset
operator|=
literal|0
expr_stmt|;
name|apuinfo_list_init
argument_list|()
expr_stmt|;
comment|/* Read in the input sections contents.  */
for|for
control|(
name|ibfd
operator|=
name|link_info
operator|->
name|input_bfds
init|;
name|ibfd
condition|;
name|ibfd
operator|=
name|ibfd
operator|->
name|link_next
control|)
block|{
name|unsigned
name|long
name|datum
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|asec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|ibfd
argument_list|,
name|APUINFO_SECTION_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|asec
operator|==
name|NULL
condition|)
continue|continue;
name|length
operator|=
name|asec
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|length
operator|<
literal|24
condition|)
block|{
name|error_message
operator|=
name|_
argument_list|(
literal|"corrupt or empty %s section in %B"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|bfd_seek
argument_list|(
name|ibfd
argument_list|,
name|asec
operator|->
name|filepos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|bfd_bread
argument_list|(
name|buffer
operator|+
name|offset
argument_list|,
name|length
argument_list|,
name|ibfd
argument_list|)
operator|!=
name|length
operator|)
condition|)
block|{
name|error_message
operator|=
name|_
argument_list|(
literal|"unable to read in %s section from %B"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Process the contents of the section.  */
name|ptr
operator|=
name|buffer
operator|+
name|offset
expr_stmt|;
name|error_message
operator|=
name|_
argument_list|(
literal|"corrupt %s section in %B"
argument_list|)
expr_stmt|;
comment|/* Verify the contents of the header.  Note - we have to 	 extract the values this way in order to allow for a 	 host whose endian-ness is different from the target.  */
name|datum
operator|=
name|bfd_get_32
argument_list|(
name|ibfd
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|datum
operator|!=
sizeof|sizeof
name|APUINFO_LABEL
condition|)
goto|goto
name|fail
goto|;
name|datum
operator|=
name|bfd_get_32
argument_list|(
name|ibfd
argument_list|,
name|ptr
operator|+
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|datum
operator|!=
literal|0x2
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|strcmp
argument_list|(
name|ptr
operator|+
literal|12
argument_list|,
name|APUINFO_LABEL
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
comment|/* Get the number of bytes used for apuinfo entries.  */
name|datum
operator|=
name|bfd_get_32
argument_list|(
name|ibfd
argument_list|,
name|ptr
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|datum
operator|+
literal|20
operator|!=
name|length
condition|)
goto|goto
name|fail
goto|;
comment|/* Make sure that we do not run off the end of the section.  */
if|if
condition|(
name|offset
operator|+
name|length
operator|>
name|output_section_size
condition|)
goto|goto
name|fail
goto|;
comment|/* Scan the apuinfo section, building a list of apuinfo numbers.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|datum
condition|;
name|i
operator|+=
literal|4
control|)
name|apuinfo_list_add
argument_list|(
name|bfd_get_32
argument_list|(
name|ibfd
argument_list|,
name|ptr
operator|+
literal|20
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Update the offset.  */
name|offset
operator|+=
name|length
expr_stmt|;
block|}
name|error_message
operator|=
name|NULL
expr_stmt|;
comment|/* Compute the size of the output section.  */
name|num_entries
operator|=
name|apuinfo_list_length
argument_list|()
expr_stmt|;
name|output_section_size
operator|=
literal|20
operator|+
name|num_entries
operator|*
literal|4
expr_stmt|;
name|asec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|APUINFO_SECTION_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_size
argument_list|(
name|abfd
argument_list|,
name|asec
argument_list|,
name|output_section_size
argument_list|)
condition|)
name|ibfd
operator|=
name|abfd
operator|,
name|error_message
operator|=
name|_
argument_list|(
literal|"warning: unable to set size of %s section in %B"
argument_list|)
expr_stmt|;
name|fail
label|:
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|error_message
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|error_message
argument_list|,
name|ibfd
argument_list|,
name|APUINFO_SECTION_NAME
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Prevent the output section from accumulating the input sections'    contents.  We have already stored this in our linked list structure.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc_elf_write_section
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|asec
parameter_list|,
name|bfd_byte
modifier|*
name|contents
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
operator|(
name|apuinfo_list_length
argument_list|()
operator|&&
name|strcmp
argument_list|(
name|asec
operator|->
name|name
argument_list|,
name|APUINFO_SECTION_NAME
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Finally we can generate the output section.  */
end_comment

begin_function
specifier|static
name|void
name|ppc_elf_final_write_processing
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_boolean
name|linker
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|bfd_byte
modifier|*
name|buffer
decl_stmt|;
name|asection
modifier|*
name|asec
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|unsigned
name|num_entries
decl_stmt|;
name|bfd_size_type
name|length
decl_stmt|;
name|asec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|APUINFO_SECTION_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|asec
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|apuinfo_list_length
argument_list|()
operator|==
literal|0
condition|)
return|return;
name|length
operator|=
name|asec
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|length
operator|<
literal|20
condition|)
return|return;
name|buffer
operator|=
name|bfd_malloc
argument_list|(
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"failed to allocate space for new APUinfo section."
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Create the apuinfo header.  */
name|num_entries
operator|=
name|apuinfo_list_length
argument_list|()
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
name|APUINFO_LABEL
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|num_entries
operator|*
literal|4
argument_list|,
name|buffer
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
literal|0x2
argument_list|,
name|buffer
operator|+
literal|8
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buffer
operator|+
literal|12
argument_list|,
name|APUINFO_LABEL
argument_list|)
expr_stmt|;
name|length
operator|=
literal|20
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_entries
condition|;
name|i
operator|++
control|)
block|{
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|apuinfo_list_element
argument_list|(
name|i
argument_list|)
argument_list|,
name|buffer
operator|+
name|length
argument_list|)
expr_stmt|;
name|length
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|length
operator|!=
name|asec
operator|->
name|size
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"failed to compute new APUinfo section."
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|asec
argument_list|,
name|buffer
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|length
argument_list|)
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"failed to install new APUinfo section."
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|apuinfo_list_finish
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The following functions are specific to the ELF linker, while    functions above are used generally.  They appear in this file more    or less in the order in which they are called.  eg.    ppc_elf_check_relocs is called early in the link process,    ppc_elf_finish_dynamic_sections is one of the last functions    called.  */
end_comment

begin_comment
comment|/* The PPC linker needs to keep track of the number of relocs that it    decides to copy as dynamic relocs in check_relocs for each symbol.    This is so that it can later discard them if they are found to be    unnecessary.  We store the information in a field extending the    regular ELF linker hash table.  */
end_comment

begin_struct
struct|struct
name|ppc_elf_dyn_relocs
block|{
name|struct
name|ppc_elf_dyn_relocs
modifier|*
name|next
decl_stmt|;
comment|/* The input section of the reloc.  */
name|asection
modifier|*
name|sec
decl_stmt|;
comment|/* Total number of relocs copied for the input section.  */
name|bfd_size_type
name|count
decl_stmt|;
comment|/* Number of pc-relative relocs copied for the input section.  */
name|bfd_size_type
name|pc_count
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Track PLT entries needed for a given symbol.  We might need more    than one glink entry per symbol.  */
end_comment

begin_struct
struct|struct
name|plt_entry
block|{
name|struct
name|plt_entry
modifier|*
name|next
decl_stmt|;
comment|/* -fPIC uses multiple GOT sections, one per file, called ".got2".      This field stores the offset into .got2 used to initialise the      GOT pointer reg.  It will always be at least 32768 (and for      current gcc this is the only offset used).  */
name|bfd_vma
name|addend
decl_stmt|;
comment|/* The .got2 section.  */
name|asection
modifier|*
name|sec
decl_stmt|;
comment|/* PLT refcount or offset.  */
union|union
block|{
name|bfd_signed_vma
name|refcount
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
block|}
name|plt
union|;
comment|/* .glink stub offset.  */
name|bfd_vma
name|glink_offset
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Of those relocs that might be copied as dynamic relocs, this macro    selects those that must be copied when linking a shared library,    even when the symbol is local.  */
end_comment

begin_define
define|#
directive|define
name|MUST_BE_DYN_RELOC
parameter_list|(
name|RTYPE
parameter_list|)
define|\
value|((RTYPE) != R_PPC_REL24			\&& (RTYPE) != R_PPC_REL14			\&& (RTYPE) != R_PPC_REL14_BRTAKEN		\&& (RTYPE) != R_PPC_REL14_BRNTAKEN		\&& (RTYPE) != R_PPC_REL32)
end_define

begin_comment
comment|/* If ELIMINATE_COPY_RELOCS is non-zero, the linker will try to avoid    copying dynamic variables from a shared lib into an app's dynbss    section, and instead use a dynamic relocation to point into the    shared lib.  */
end_comment

begin_define
define|#
directive|define
name|ELIMINATE_COPY_RELOCS
value|1
end_define

begin_comment
comment|/* PPC ELF linker hash entry.  */
end_comment

begin_struct
struct|struct
name|ppc_elf_link_hash_entry
block|{
name|struct
name|elf_link_hash_entry
name|elf
decl_stmt|;
comment|/* If this symbol is used in the linker created sections, the processor      specific backend uses this field to map the field into the offset      from the beginning of the section.  */
name|elf_linker_section_pointers_t
modifier|*
name|linker_section_pointer
decl_stmt|;
comment|/* Track dynamic relocs copied for this symbol.  */
name|struct
name|ppc_elf_dyn_relocs
modifier|*
name|dyn_relocs
decl_stmt|;
comment|/* Contexts in which symbol is used in the GOT (or TOC).      TLS_GD .. TLS_TLS bits are or'd into the mask as the      corresponding relocs are encountered during check_relocs.      tls_optimize clears TLS_GD .. TLS_TPREL when optimizing to      indicate the corresponding GOT entry type is not needed.  */
define|#
directive|define
name|TLS_GD
value|1
comment|/* GD reloc. */
define|#
directive|define
name|TLS_LD
value|2
comment|/* LD reloc. */
define|#
directive|define
name|TLS_TPREL
value|4
comment|/* TPREL reloc, => IE. */
define|#
directive|define
name|TLS_DTPREL
value|8
comment|/* DTPREL reloc, => LD. */
define|#
directive|define
name|TLS_TLS
value|16
comment|/* Any TLS reloc.  */
define|#
directive|define
name|TLS_TPRELGD
value|32
comment|/* TPREL reloc resulting from GD->IE. */
name|char
name|tls_mask
decl_stmt|;
comment|/* Nonzero if we have seen a small data relocation referring to this      symbol.  */
name|unsigned
name|char
name|has_sda_refs
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|ppc_elf_hash_entry
parameter_list|(
name|ent
parameter_list|)
value|((struct ppc_elf_link_hash_entry *) (ent))
end_define

begin_comment
comment|/* PPC ELF linker hash table.  */
end_comment

begin_struct
struct|struct
name|ppc_elf_link_hash_table
block|{
name|struct
name|elf_link_hash_table
name|elf
decl_stmt|;
comment|/* Short-cuts to get to dynamic linker sections.  */
name|asection
modifier|*
name|got
decl_stmt|;
name|asection
modifier|*
name|relgot
decl_stmt|;
name|asection
modifier|*
name|glink
decl_stmt|;
name|asection
modifier|*
name|plt
decl_stmt|;
name|asection
modifier|*
name|relplt
decl_stmt|;
name|asection
modifier|*
name|dynbss
decl_stmt|;
name|asection
modifier|*
name|relbss
decl_stmt|;
name|asection
modifier|*
name|dynsbss
decl_stmt|;
name|asection
modifier|*
name|relsbss
decl_stmt|;
name|elf_linker_section_t
name|sdata
index|[
literal|2
index|]
decl_stmt|;
name|asection
modifier|*
name|sbss
decl_stmt|;
comment|/* The (unloaded but important) .rela.plt.unloaded on VxWorks.  */
name|asection
modifier|*
name|srelplt2
decl_stmt|;
comment|/* The .got.plt section (VxWorks only)*/
name|asection
modifier|*
name|sgotplt
decl_stmt|;
comment|/* Shortcut to .__tls_get_addr.  */
name|struct
name|elf_link_hash_entry
modifier|*
name|tls_get_addr
decl_stmt|;
comment|/* The bfd that forced an old-style PLT.  */
name|bfd
modifier|*
name|old_bfd
decl_stmt|;
comment|/* TLS local dynamic got entry handling.  */
union|union
block|{
name|bfd_signed_vma
name|refcount
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
block|}
name|tlsld_got
union|;
comment|/* Offset of PltResolve function in glink.  */
name|bfd_vma
name|glink_pltresolve
decl_stmt|;
comment|/* Size of reserved GOT entries.  */
name|unsigned
name|int
name|got_header_size
decl_stmt|;
comment|/* Non-zero if allocating the header left a gap.  */
name|unsigned
name|int
name|got_gap
decl_stmt|;
comment|/* The type of PLT we have chosen to use.  */
name|enum
name|ppc_elf_plt_type
name|plt_type
decl_stmt|;
comment|/* Set if we should emit symbols for stubs.  */
name|unsigned
name|int
name|emit_stub_syms
range|:
literal|1
decl_stmt|;
comment|/* True if the target system is VxWorks.  */
name|unsigned
name|int
name|is_vxworks
range|:
literal|1
decl_stmt|;
comment|/* The size of PLT entries.  */
name|int
name|plt_entry_size
decl_stmt|;
comment|/* The distance between adjacent PLT slots.  */
name|int
name|plt_slot_size
decl_stmt|;
comment|/* The size of the first PLT entry.  */
name|int
name|plt_initial_entry_size
decl_stmt|;
comment|/* Small local sym to section mapping cache.  */
name|struct
name|sym_sec_cache
name|sym_sec
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Get the PPC ELF linker hash table from a link_info structure.  */
end_comment

begin_define
define|#
directive|define
name|ppc_elf_hash_table
parameter_list|(
name|p
parameter_list|)
define|\
value|((struct ppc_elf_link_hash_table *) (p)->hash)
end_define

begin_comment
comment|/* Create an entry in a PPC ELF linker hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|ppc_elf_link_hash_newfunc
parameter_list|(
name|struct
name|bfd_hash_entry
modifier|*
name|entry
parameter_list|,
name|struct
name|bfd_hash_table
modifier|*
name|table
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
comment|/* Allocate the structure if it has not already been allocated by a      subclass.  */
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
name|entry
operator|=
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ppc_elf_link_hash_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
return|return
name|entry
return|;
block|}
comment|/* Call the allocation method of the superclass.  */
name|entry
operator|=
name|_bfd_elf_link_hash_newfunc
argument_list|(
name|entry
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|!=
name|NULL
condition|)
block|{
name|ppc_elf_hash_entry
argument_list|(
name|entry
argument_list|)
operator|->
name|linker_section_pointer
operator|=
name|NULL
expr_stmt|;
name|ppc_elf_hash_entry
argument_list|(
name|entry
argument_list|)
operator|->
name|dyn_relocs
operator|=
name|NULL
expr_stmt|;
name|ppc_elf_hash_entry
argument_list|(
name|entry
argument_list|)
operator|->
name|tls_mask
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|entry
return|;
block|}
end_function

begin_comment
comment|/* Create a PPC ELF linker hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_link_hash_table
modifier|*
name|ppc_elf_link_hash_table_create
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|struct
name|ppc_elf_link_hash_table
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
name|bfd_zmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ppc_elf_link_hash_table
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|_bfd_elf_link_hash_table_init
argument_list|(
operator|&
name|ret
operator|->
name|elf
argument_list|,
name|abfd
argument_list|,
name|ppc_elf_link_hash_newfunc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ppc_elf_link_hash_entry
argument_list|)
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ret
operator|->
name|elf
operator|.
name|init_plt_refcount
operator|.
name|refcount
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|elf
operator|.
name|init_plt_refcount
operator|.
name|glist
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|elf
operator|.
name|init_plt_offset
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|elf
operator|.
name|init_plt_offset
operator|.
name|glist
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|sdata
index|[
literal|0
index|]
operator|.
name|name
operator|=
literal|".sdata"
expr_stmt|;
name|ret
operator|->
name|sdata
index|[
literal|0
index|]
operator|.
name|sym_name
operator|=
literal|"_SDA_BASE_"
expr_stmt|;
name|ret
operator|->
name|sdata
index|[
literal|0
index|]
operator|.
name|bss_name
operator|=
literal|".sbss"
expr_stmt|;
name|ret
operator|->
name|sdata
index|[
literal|1
index|]
operator|.
name|name
operator|=
literal|".sdata2"
expr_stmt|;
name|ret
operator|->
name|sdata
index|[
literal|1
index|]
operator|.
name|sym_name
operator|=
literal|"_SDA2_BASE_"
expr_stmt|;
name|ret
operator|->
name|sdata
index|[
literal|1
index|]
operator|.
name|bss_name
operator|=
literal|".sbss2"
expr_stmt|;
name|ret
operator|->
name|plt_entry_size
operator|=
literal|12
expr_stmt|;
name|ret
operator|->
name|plt_slot_size
operator|=
literal|8
expr_stmt|;
name|ret
operator|->
name|plt_initial_entry_size
operator|=
literal|72
expr_stmt|;
return|return
operator|&
name|ret
operator|->
name|elf
operator|.
name|root
return|;
block|}
end_function

begin_comment
comment|/* Create .got and the related sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc_elf_create_got
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|ppc_elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
if|if
condition|(
operator|!
name|_bfd_elf_create_got_section
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|htab
operator|=
name|ppc_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|htab
operator|->
name|got
operator|=
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|is_vxworks
condition|)
block|{
name|htab
operator|->
name|sgotplt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".got.plt"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|htab
operator|->
name|sgotplt
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* The powerpc .got has a blrl instruction in it.  Mark it 	 executable.  */
name|flags
operator|=
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_CODE
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|flags
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
name|flags
operator|=
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_READONLY
operator|)
expr_stmt|;
name|htab
operator|->
name|relgot
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|abfd
argument_list|,
literal|".rela.got"
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|htab
operator|->
name|relgot
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|htab
operator|->
name|relgot
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* We have to create .dynsbss and .rela.sbss here so that they get mapped    to output sections (just like _bfd_elf_create_dynamic_sections has    to create .dynbss and .rela.bss).  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc_elf_create_dynamic_sections
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|ppc_elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
name|htab
operator|=
name|ppc_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|got
operator|==
name|NULL
operator|&&
operator|!
name|ppc_elf_create_got
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|_bfd_elf_create_dynamic_sections
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|flags
operator|=
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_READONLY
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator|)
expr_stmt|;
name|s
operator|=
name|bfd_make_section_anyway_with_flags
argument_list|(
name|abfd
argument_list|,
literal|".glink"
argument_list|,
name|flags
operator||
name|SEC_CODE
argument_list|)
expr_stmt|;
name|htab
operator|->
name|glink
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
literal|4
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|htab
operator|->
name|dynbss
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynbss"
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|abfd
argument_list|,
literal|".dynsbss"
argument_list|,
name|SEC_ALLOC
operator||
name|SEC_LINKER_CREATED
argument_list|)
expr_stmt|;
name|htab
operator|->
name|dynsbss
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
name|htab
operator|->
name|relbss
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".rela.bss"
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|abfd
argument_list|,
literal|".rela.sbss"
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|htab
operator|->
name|relsbss
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|htab
operator|->
name|is_vxworks
operator|&&
operator|!
name|elf_vxworks_create_dynamic_sections
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
operator|&
name|htab
operator|->
name|srelplt2
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|htab
operator|->
name|relplt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".rela.plt"
argument_list|)
expr_stmt|;
name|htab
operator|->
name|plt
operator|=
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|flags
operator|=
name|SEC_ALLOC
operator||
name|SEC_CODE
operator||
name|SEC_LINKER_CREATED
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|plt_type
operator|==
name|PLT_VXWORKS
condition|)
comment|/* The VxWorks PLT is a loaded section with contents.  */
name|flags
operator||=
name|SEC_HAS_CONTENTS
operator||
name|SEC_LOAD
operator||
name|SEC_READONLY
expr_stmt|;
return|return
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Copy the extra info we tack onto an elf_link_hash_entry.  */
end_comment

begin_function
specifier|static
name|void
name|ppc_elf_copy_indirect_symbol
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|dir
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|ind
parameter_list|)
block|{
name|struct
name|ppc_elf_link_hash_entry
modifier|*
name|edir
decl_stmt|,
modifier|*
name|eind
decl_stmt|;
name|edir
operator|=
operator|(
expr|struct
name|ppc_elf_link_hash_entry
operator|*
operator|)
name|dir
expr_stmt|;
name|eind
operator|=
operator|(
expr|struct
name|ppc_elf_link_hash_entry
operator|*
operator|)
name|ind
expr_stmt|;
if|if
condition|(
name|eind
operator|->
name|dyn_relocs
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|edir
operator|->
name|dyn_relocs
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ppc_elf_dyn_relocs
modifier|*
modifier|*
name|pp
decl_stmt|;
name|struct
name|ppc_elf_dyn_relocs
modifier|*
name|p
decl_stmt|;
comment|/* Add reloc counts against the indirect sym to the direct sym 	     list.  Merge any entries against the same section.  */
for|for
control|(
name|pp
operator|=
operator|&
name|eind
operator|->
name|dyn_relocs
init|;
operator|(
name|p
operator|=
operator|*
name|pp
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
name|struct
name|ppc_elf_dyn_relocs
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|q
operator|=
name|edir
operator|->
name|dyn_relocs
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|next
control|)
if|if
condition|(
name|q
operator|->
name|sec
operator|==
name|p
operator|->
name|sec
condition|)
block|{
name|q
operator|->
name|pc_count
operator|+=
name|p
operator|->
name|pc_count
expr_stmt|;
name|q
operator|->
name|count
operator|+=
name|p
operator|->
name|count
expr_stmt|;
operator|*
name|pp
operator|=
name|p
operator|->
name|next
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
name|pp
operator|=
operator|&
name|p
operator|->
name|next
expr_stmt|;
block|}
operator|*
name|pp
operator|=
name|edir
operator|->
name|dyn_relocs
expr_stmt|;
block|}
name|edir
operator|->
name|dyn_relocs
operator|=
name|eind
operator|->
name|dyn_relocs
expr_stmt|;
name|eind
operator|->
name|dyn_relocs
operator|=
name|NULL
expr_stmt|;
block|}
name|edir
operator|->
name|tls_mask
operator||=
name|eind
operator|->
name|tls_mask
expr_stmt|;
name|edir
operator|->
name|has_sda_refs
operator||=
name|eind
operator|->
name|has_sda_refs
expr_stmt|;
comment|/* If called to transfer flags for a weakdef during processing      of elf_adjust_dynamic_symbol, don't copy non_got_ref.      We clear it ourselves for ELIMINATE_COPY_RELOCS.  */
if|if
condition|(
operator|!
operator|(
name|ELIMINATE_COPY_RELOCS
operator|&&
name|eind
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_indirect
operator|&&
name|edir
operator|->
name|elf
operator|.
name|dynamic_adjusted
operator|)
condition|)
name|edir
operator|->
name|elf
operator|.
name|non_got_ref
operator||=
name|eind
operator|->
name|elf
operator|.
name|non_got_ref
expr_stmt|;
name|edir
operator|->
name|elf
operator|.
name|ref_dynamic
operator||=
name|eind
operator|->
name|elf
operator|.
name|ref_dynamic
expr_stmt|;
name|edir
operator|->
name|elf
operator|.
name|ref_regular
operator||=
name|eind
operator|->
name|elf
operator|.
name|ref_regular
expr_stmt|;
name|edir
operator|->
name|elf
operator|.
name|ref_regular_nonweak
operator||=
name|eind
operator|->
name|elf
operator|.
name|ref_regular_nonweak
expr_stmt|;
name|edir
operator|->
name|elf
operator|.
name|needs_plt
operator||=
name|eind
operator|->
name|elf
operator|.
name|needs_plt
expr_stmt|;
comment|/* If we were called to copy over info for a weak sym, that's all.  */
if|if
condition|(
name|eind
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_indirect
condition|)
return|return;
comment|/* Copy over the GOT refcount entries that we may have already seen to      the symbol which just became indirect.  */
name|edir
operator|->
name|elf
operator|.
name|got
operator|.
name|refcount
operator|+=
name|eind
operator|->
name|elf
operator|.
name|got
operator|.
name|refcount
expr_stmt|;
name|eind
operator|->
name|elf
operator|.
name|got
operator|.
name|refcount
operator|=
literal|0
expr_stmt|;
comment|/* And plt entries.  */
if|if
condition|(
name|eind
operator|->
name|elf
operator|.
name|plt
operator|.
name|plist
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|edir
operator|->
name|elf
operator|.
name|plt
operator|.
name|plist
operator|!=
name|NULL
condition|)
block|{
name|struct
name|plt_entry
modifier|*
modifier|*
name|entp
decl_stmt|;
name|struct
name|plt_entry
modifier|*
name|ent
decl_stmt|;
for|for
control|(
name|entp
operator|=
operator|&
name|eind
operator|->
name|elf
operator|.
name|plt
operator|.
name|plist
init|;
operator|(
name|ent
operator|=
operator|*
name|entp
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
name|struct
name|plt_entry
modifier|*
name|dent
decl_stmt|;
for|for
control|(
name|dent
operator|=
name|edir
operator|->
name|elf
operator|.
name|plt
operator|.
name|plist
init|;
name|dent
operator|!=
name|NULL
condition|;
name|dent
operator|=
name|dent
operator|->
name|next
control|)
if|if
condition|(
name|dent
operator|->
name|sec
operator|==
name|ent
operator|->
name|sec
operator|&&
name|dent
operator|->
name|addend
operator|==
name|ent
operator|->
name|addend
condition|)
block|{
name|dent
operator|->
name|plt
operator|.
name|refcount
operator|+=
name|ent
operator|->
name|plt
operator|.
name|refcount
expr_stmt|;
operator|*
name|entp
operator|=
name|ent
operator|->
name|next
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dent
operator|==
name|NULL
condition|)
name|entp
operator|=
operator|&
name|ent
operator|->
name|next
expr_stmt|;
block|}
operator|*
name|entp
operator|=
name|edir
operator|->
name|elf
operator|.
name|plt
operator|.
name|plist
expr_stmt|;
block|}
name|edir
operator|->
name|elf
operator|.
name|plt
operator|.
name|plist
operator|=
name|eind
operator|->
name|elf
operator|.
name|plt
operator|.
name|plist
expr_stmt|;
name|eind
operator|->
name|elf
operator|.
name|plt
operator|.
name|plist
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|eind
operator|->
name|elf
operator|.
name|dynindx
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|edir
operator|->
name|elf
operator|.
name|dynindx
operator|!=
operator|-
literal|1
condition|)
name|_bfd_elf_strtab_delref
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
argument_list|,
name|edir
operator|->
name|elf
operator|.
name|dynstr_index
argument_list|)
expr_stmt|;
name|edir
operator|->
name|elf
operator|.
name|dynindx
operator|=
name|eind
operator|->
name|elf
operator|.
name|dynindx
expr_stmt|;
name|edir
operator|->
name|elf
operator|.
name|dynstr_index
operator|=
name|eind
operator|->
name|elf
operator|.
name|dynstr_index
expr_stmt|;
name|eind
operator|->
name|elf
operator|.
name|dynindx
operator|=
operator|-
literal|1
expr_stmt|;
name|eind
operator|->
name|elf
operator|.
name|dynstr_index
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return 1 if target is one of ours.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|is_ppc_elf_target
parameter_list|(
specifier|const
name|struct
name|bfd_target
modifier|*
name|targ
parameter_list|)
block|{
specifier|extern
specifier|const
name|bfd_target
name|bfd_elf32_powerpc_vec
decl_stmt|;
specifier|extern
specifier|const
name|bfd_target
name|bfd_elf32_powerpc_vxworks_vec
decl_stmt|;
specifier|extern
specifier|const
name|bfd_target
name|bfd_elf32_powerpcle_vec
decl_stmt|;
return|return
operator|(
name|targ
operator|==
operator|&
name|bfd_elf32_powerpc_vec
operator|||
name|targ
operator|==
operator|&
name|bfd_elf32_powerpc_vxworks_vec
operator|||
name|targ
operator|==
operator|&
name|bfd_elf32_powerpcle_vec
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Hook called by the linker routine which adds symbols from an object    file.  We use it to put .comm items in .sbss, and not .bss.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc_elf_add_symbol_hook
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|namep
name|ATTRIBUTE_UNUSED
parameter_list|,
name|flagword
modifier|*
name|flagsp
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
modifier|*
name|secp
parameter_list|,
name|bfd_vma
modifier|*
name|valp
parameter_list|)
block|{
if|if
condition|(
name|sym
operator|->
name|st_shndx
operator|==
name|SHN_COMMON
operator|&&
operator|!
name|info
operator|->
name|relocatable
operator|&&
name|sym
operator|->
name|st_size
operator|<=
name|elf_gp_size
argument_list|(
name|abfd
argument_list|)
operator|&&
name|is_ppc_elf_target
argument_list|(
name|info
operator|->
name|hash
operator|->
name|creator
argument_list|)
condition|)
block|{
comment|/* Common symbols less than or equal to -G nn bytes are automatically 	 put into .sbss.  */
name|struct
name|ppc_elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|htab
operator|=
name|ppc_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|sbss
operator|==
name|NULL
condition|)
block|{
name|flagword
name|flags
init|=
name|SEC_IS_COMMON
operator||
name|SEC_LINKER_CREATED
decl_stmt|;
if|if
condition|(
operator|!
name|htab
operator|->
name|elf
operator|.
name|dynobj
condition|)
name|htab
operator|->
name|elf
operator|.
name|dynobj
operator|=
name|abfd
expr_stmt|;
name|htab
operator|->
name|sbss
operator|=
name|bfd_make_section_anyway_with_flags
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
literal|".sbss"
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|sbss
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
operator|*
name|secp
operator|=
name|htab
operator|->
name|sbss
expr_stmt|;
operator|*
name|valp
operator|=
name|sym
operator|->
name|st_size
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|bfd_boolean
name|create_sdata_sym
parameter_list|(
name|struct
name|ppc_elf_link_hash_table
modifier|*
name|htab
parameter_list|,
name|elf_linker_section_t
modifier|*
name|lsect
parameter_list|)
block|{
name|lsect
operator|->
name|sym
operator|=
name|elf_link_hash_lookup
argument_list|(
operator|&
name|htab
operator|->
name|elf
argument_list|,
name|lsect
operator|->
name|sym_name
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|lsect
operator|->
name|sym
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|lsect
operator|->
name|sym
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_new
condition|)
name|lsect
operator|->
name|sym
operator|->
name|non_elf
operator|=
literal|0
expr_stmt|;
name|lsect
operator|->
name|sym
operator|->
name|ref_regular
operator|=
literal|1
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Create a special linker section.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc_elf_create_linker_section
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|flagword
name|flags
parameter_list|,
name|elf_linker_section_t
modifier|*
name|lsect
parameter_list|)
block|{
name|struct
name|ppc_elf_link_hash_table
modifier|*
name|htab
init|=
name|ppc_elf_hash_table
argument_list|(
name|info
argument_list|)
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|flags
operator||=
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator|)
expr_stmt|;
comment|/* Record the first bfd that needs the special sections.  */
if|if
condition|(
operator|!
name|htab
operator|->
name|elf
operator|.
name|dynobj
condition|)
name|htab
operator|->
name|elf
operator|.
name|dynobj
operator|=
name|abfd
expr_stmt|;
name|s
operator|=
name|bfd_make_section_anyway_with_flags
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|lsect
operator|->
name|name
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|s
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|lsect
operator|->
name|section
operator|=
name|s
expr_stmt|;
return|return
name|create_sdata_sym
argument_list|(
name|htab
argument_list|,
name|lsect
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Find a linker generated pointer with a given addend and type.  */
end_comment

begin_function
specifier|static
name|elf_linker_section_pointers_t
modifier|*
name|elf_find_pointer_linker_section
parameter_list|(
name|elf_linker_section_pointers_t
modifier|*
name|linker_pointers
parameter_list|,
name|bfd_vma
name|addend
parameter_list|,
name|elf_linker_section_t
modifier|*
name|lsect
parameter_list|)
block|{
for|for
control|(
init|;
name|linker_pointers
operator|!=
name|NULL
condition|;
name|linker_pointers
operator|=
name|linker_pointers
operator|->
name|next
control|)
if|if
condition|(
name|lsect
operator|==
name|linker_pointers
operator|->
name|lsect
operator|&&
name|addend
operator|==
name|linker_pointers
operator|->
name|addend
condition|)
return|return
name|linker_pointers
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Allocate a pointer to live in a linker created section.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_create_pointer_linker_section
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|elf_linker_section_t
modifier|*
name|lsect
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
parameter_list|)
block|{
name|elf_linker_section_pointers_t
modifier|*
modifier|*
name|ptr_linker_section_ptr
init|=
name|NULL
decl_stmt|;
name|elf_linker_section_pointers_t
modifier|*
name|linker_section_ptr
decl_stmt|;
name|unsigned
name|long
name|r_symndx
init|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|lsect
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Is this a global symbol?  */
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ppc_elf_link_hash_entry
modifier|*
name|eh
decl_stmt|;
comment|/* Has this symbol already been allocated?  If so, our work is done.  */
name|eh
operator|=
operator|(
expr|struct
name|ppc_elf_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
if|if
condition|(
name|elf_find_pointer_linker_section
argument_list|(
name|eh
operator|->
name|linker_section_pointer
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|,
name|lsect
argument_list|)
condition|)
return|return
name|TRUE
return|;
name|ptr_linker_section_ptr
operator|=
operator|&
name|eh
operator|->
name|linker_section_pointer
expr_stmt|;
block|}
else|else
block|{
comment|/* Allocation of a pointer to a local symbol.  */
name|elf_linker_section_pointers_t
modifier|*
modifier|*
name|ptr
init|=
name|elf_local_ptr_offsets
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
comment|/* Allocate a table to hold the local symbols if first time.  */
if|if
condition|(
operator|!
name|ptr
condition|)
block|{
name|unsigned
name|int
name|num_symbols
init|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
operator|.
name|sh_info
decl_stmt|;
name|amt
operator|=
name|num_symbols
expr_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
name|elf_linker_section_pointers_t
operator|*
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
return|return
name|FALSE
return|;
name|elf_local_ptr_offsets
argument_list|(
name|abfd
argument_list|)
operator|=
name|ptr
expr_stmt|;
block|}
comment|/* Has this symbol already been allocated?  If so, our work is done.  */
if|if
condition|(
name|elf_find_pointer_linker_section
argument_list|(
name|ptr
index|[
name|r_symndx
index|]
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|,
name|lsect
argument_list|)
condition|)
return|return
name|TRUE
return|;
name|ptr_linker_section_ptr
operator|=
operator|&
name|ptr
index|[
name|r_symndx
index|]
expr_stmt|;
block|}
comment|/* Allocate space for a pointer in the linker section, and allocate      a new pointer record from internal memory.  */
name|BFD_ASSERT
argument_list|(
name|ptr_linker_section_ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
name|elf_linker_section_pointers_t
argument_list|)
expr_stmt|;
name|linker_section_ptr
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|linker_section_ptr
condition|)
return|return
name|FALSE
return|;
name|linker_section_ptr
operator|->
name|next
operator|=
operator|*
name|ptr_linker_section_ptr
expr_stmt|;
name|linker_section_ptr
operator|->
name|addend
operator|=
name|rel
operator|->
name|r_addend
expr_stmt|;
name|linker_section_ptr
operator|->
name|lsect
operator|=
name|lsect
expr_stmt|;
operator|*
name|ptr_linker_section_ptr
operator|=
name|linker_section_ptr
expr_stmt|;
name|linker_section_ptr
operator|->
name|offset
operator|=
name|lsect
operator|->
name|section
operator|->
name|size
expr_stmt|;
name|lsect
operator|->
name|section
operator|->
name|size
operator|+=
literal|4
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Create pointer in linker section %s, offset = %ld, section size = %ld\n"
argument_list|,
name|lsect
operator|->
name|name
argument_list|,
operator|(
name|long
operator|)
name|linker_section_ptr
operator|->
name|offset
argument_list|,
operator|(
name|long
operator|)
name|lsect
operator|->
name|section
operator|->
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|update_local_sym_info
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
parameter_list|,
name|unsigned
name|long
name|r_symndx
parameter_list|,
name|int
name|tls_type
parameter_list|)
block|{
name|bfd_signed_vma
modifier|*
name|local_got_refcounts
init|=
name|elf_local_got_refcounts
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|char
modifier|*
name|local_got_tls_masks
decl_stmt|;
if|if
condition|(
name|local_got_refcounts
operator|==
name|NULL
condition|)
block|{
name|bfd_size_type
name|size
init|=
name|symtab_hdr
operator|->
name|sh_info
decl_stmt|;
name|size
operator|*=
sizeof|sizeof
argument_list|(
operator|*
name|local_got_refcounts
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|local_got_tls_masks
argument_list|)
expr_stmt|;
name|local_got_refcounts
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_got_refcounts
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|elf_local_got_refcounts
argument_list|(
name|abfd
argument_list|)
operator|=
name|local_got_refcounts
expr_stmt|;
block|}
name|local_got_refcounts
index|[
name|r_symndx
index|]
operator|+=
literal|1
expr_stmt|;
name|local_got_tls_masks
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|local_got_refcounts
operator|+
name|symtab_hdr
operator|->
name|sh_info
operator|)
expr_stmt|;
name|local_got_tls_masks
index|[
name|r_symndx
index|]
operator||=
name|tls_type
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|update_plt_info
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|bfd_vma
name|addend
parameter_list|)
block|{
name|struct
name|plt_entry
modifier|*
name|ent
decl_stmt|;
if|if
condition|(
name|addend
operator|<
literal|32768
condition|)
name|sec
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|ent
operator|=
name|h
operator|->
name|plt
operator|.
name|plist
init|;
name|ent
operator|!=
name|NULL
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
if|if
condition|(
name|ent
operator|->
name|sec
operator|==
name|sec
operator|&&
name|ent
operator|->
name|addend
operator|==
name|addend
condition|)
break|break;
if|if
condition|(
name|ent
operator|==
name|NULL
condition|)
block|{
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
operator|*
name|ent
argument_list|)
decl_stmt|;
name|ent
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ent
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|ent
operator|->
name|next
operator|=
name|h
operator|->
name|plt
operator|.
name|plist
expr_stmt|;
name|ent
operator|->
name|sec
operator|=
name|sec
expr_stmt|;
name|ent
operator|->
name|addend
operator|=
name|addend
expr_stmt|;
name|ent
operator|->
name|plt
operator|.
name|refcount
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|plt
operator|.
name|plist
operator|=
name|ent
expr_stmt|;
block|}
name|ent
operator|->
name|plt
operator|.
name|refcount
operator|+=
literal|1
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|plt_entry
modifier|*
name|find_plt_ent
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|bfd_vma
name|addend
parameter_list|)
block|{
name|struct
name|plt_entry
modifier|*
name|ent
decl_stmt|;
if|if
condition|(
name|addend
operator|<
literal|32768
condition|)
name|sec
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|ent
operator|=
name|h
operator|->
name|plt
operator|.
name|plist
init|;
name|ent
operator|!=
name|NULL
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
if|if
condition|(
name|ent
operator|->
name|sec
operator|==
name|sec
operator|&&
name|ent
operator|->
name|addend
operator|==
name|addend
condition|)
break|break;
return|return
name|ent
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bad_shared_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|enum
name|elf_ppc_reloc_type
name|r_type
parameter_list|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: relocation %s cannot be used when making a shared object"
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|ppc_elf_howto_table
index|[
name|r_type
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Look through the relocs for a section during the first phase, and    allocate space in the global offset table or procedure linkage    table.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc_elf_check_relocs
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
parameter_list|)
block|{
name|struct
name|ppc_elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel_end
decl_stmt|;
name|asection
modifier|*
name|got2
decl_stmt|,
modifier|*
name|sreloc
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
return|return
name|TRUE
return|;
comment|/* Don't do anything special with non-loaded, non-alloced sections.      In particular, any relocs in such sections should not affect GOT      and PLT reference counting (ie. we don't allow them to create GOT      or PLT entries), there's no possibility or desire to optimize TLS      relocs, and there's not much point in propagating relocs to shared      libs that the dynamic linker won't relocate.  */
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
ifdef|#
directive|ifdef
name|DEBUG
name|_bfd_error_handler
argument_list|(
literal|"ppc_elf_check_relocs called for section %A in %B"
argument_list|,
name|sec
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Initialize howto table if not already done.  */
if|if
condition|(
operator|!
name|ppc_elf_howto_table
index|[
name|R_PPC_ADDR32
index|]
condition|)
name|ppc_elf_howto_init
argument_list|()
expr_stmt|;
name|htab
operator|=
name|ppc_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|got2
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".got2"
argument_list|)
expr_stmt|;
name|sreloc
operator|=
name|NULL
expr_stmt|;
name|rel_end
operator|=
name|relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|rel_end
condition|;
name|rel
operator|++
control|)
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|enum
name|elf_ppc_reloc_type
name|r_type
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|int
name|tls_type
init|=
literal|0
decl_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
name|h
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
block|}
comment|/* If a relocation refers to _GLOBAL_OFFSET_TABLE_, create the .got. 	 This shows up in particular in an R_PPC_ADDR32 in the eabi 	 startup code.  */
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|htab
operator|->
name|got
operator|==
name|NULL
operator|&&
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
operator|==
name|NULL
condition|)
name|htab
operator|->
name|elf
operator|.
name|dynobj
operator|=
name|abfd
expr_stmt|;
if|if
condition|(
operator|!
name|ppc_elf_create_got
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|BFD_ASSERT
argument_list|(
name|h
operator|==
name|htab
operator|->
name|elf
operator|.
name|hgot
argument_list|)
expr_stmt|;
block|}
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_PPC_GOT_TLSLD16
case|:
case|case
name|R_PPC_GOT_TLSLD16_LO
case|:
case|case
name|R_PPC_GOT_TLSLD16_HI
case|:
case|case
name|R_PPC_GOT_TLSLD16_HA
case|:
name|htab
operator|->
name|tlsld_got
operator|.
name|refcount
operator|+=
literal|1
expr_stmt|;
name|tls_type
operator|=
name|TLS_TLS
operator||
name|TLS_LD
expr_stmt|;
goto|goto
name|dogottls
goto|;
case|case
name|R_PPC_GOT_TLSGD16
case|:
case|case
name|R_PPC_GOT_TLSGD16_LO
case|:
case|case
name|R_PPC_GOT_TLSGD16_HI
case|:
case|case
name|R_PPC_GOT_TLSGD16_HA
case|:
name|tls_type
operator|=
name|TLS_TLS
operator||
name|TLS_GD
expr_stmt|;
goto|goto
name|dogottls
goto|;
case|case
name|R_PPC_GOT_TPREL16
case|:
case|case
name|R_PPC_GOT_TPREL16_LO
case|:
case|case
name|R_PPC_GOT_TPREL16_HI
case|:
case|case
name|R_PPC_GOT_TPREL16_HA
case|:
if|if
condition|(
name|info
operator|->
name|shared
condition|)
name|info
operator|->
name|flags
operator||=
name|DF_STATIC_TLS
expr_stmt|;
name|tls_type
operator|=
name|TLS_TLS
operator||
name|TLS_TPREL
expr_stmt|;
goto|goto
name|dogottls
goto|;
case|case
name|R_PPC_GOT_DTPREL16
case|:
case|case
name|R_PPC_GOT_DTPREL16_LO
case|:
case|case
name|R_PPC_GOT_DTPREL16_HI
case|:
case|case
name|R_PPC_GOT_DTPREL16_HA
case|:
name|tls_type
operator|=
name|TLS_TLS
operator||
name|TLS_DTPREL
expr_stmt|;
name|dogottls
label|:
name|sec
operator|->
name|has_tls_reloc
operator|=
literal|1
expr_stmt|;
comment|/* Fall thru */
comment|/* GOT16 relocations */
case|case
name|R_PPC_GOT16
case|:
case|case
name|R_PPC_GOT16_LO
case|:
case|case
name|R_PPC_GOT16_HI
case|:
case|case
name|R_PPC_GOT16_HA
case|:
comment|/* This symbol requires a global offset table entry.  */
if|if
condition|(
name|htab
operator|->
name|got
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
operator|==
name|NULL
condition|)
name|htab
operator|->
name|elf
operator|.
name|dynobj
operator|=
name|abfd
expr_stmt|;
if|if
condition|(
operator|!
name|ppc_elf_create_got
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|h
operator|->
name|got
operator|.
name|refcount
operator|+=
literal|1
expr_stmt|;
name|ppc_elf_hash_entry
argument_list|(
name|h
argument_list|)
operator|->
name|tls_mask
operator||=
name|tls_type
expr_stmt|;
block|}
elseif|else
comment|/* This is a global offset table entry for a local symbol.  */
if|if
condition|(
operator|!
name|update_local_sym_info
argument_list|(
name|abfd
argument_list|,
name|symtab_hdr
argument_list|,
name|r_symndx
argument_list|,
name|tls_type
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
comment|/* Indirect .sdata relocation.  */
case|case
name|R_PPC_EMB_SDAI16
case|:
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
name|bad_shared_reloc
argument_list|(
name|abfd
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|htab
operator|->
name|sdata
index|[
literal|0
index|]
operator|.
name|section
operator|==
name|NULL
operator|&&
operator|!
name|ppc_elf_create_linker_section
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
literal|0
argument_list|,
operator|&
name|htab
operator|->
name|sdata
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|elf_create_pointer_linker_section
argument_list|(
name|abfd
argument_list|,
operator|&
name|htab
operator|->
name|sdata
index|[
literal|0
index|]
argument_list|,
name|h
argument_list|,
name|rel
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|ppc_elf_hash_entry
argument_list|(
name|h
argument_list|)
operator|->
name|has_sda_refs
operator|=
name|TRUE
expr_stmt|;
name|h
operator|->
name|non_got_ref
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
comment|/* Indirect .sdata2 relocation.  */
case|case
name|R_PPC_EMB_SDA2I16
case|:
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
name|bad_shared_reloc
argument_list|(
name|abfd
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|htab
operator|->
name|sdata
index|[
literal|1
index|]
operator|.
name|section
operator|==
name|NULL
operator|&&
operator|!
name|ppc_elf_create_linker_section
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|SEC_READONLY
argument_list|,
operator|&
name|htab
operator|->
name|sdata
index|[
literal|1
index|]
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|elf_create_pointer_linker_section
argument_list|(
name|abfd
argument_list|,
operator|&
name|htab
operator|->
name|sdata
index|[
literal|1
index|]
argument_list|,
name|h
argument_list|,
name|rel
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|ppc_elf_hash_entry
argument_list|(
name|h
argument_list|)
operator|->
name|has_sda_refs
operator|=
name|TRUE
expr_stmt|;
name|h
operator|->
name|non_got_ref
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
case|case
name|R_PPC_SDAREL16
case|:
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
name|bad_shared_reloc
argument_list|(
name|abfd
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|htab
operator|->
name|sdata
index|[
literal|0
index|]
operator|.
name|sym
operator|==
name|NULL
operator|&&
operator|!
name|create_sdata_sym
argument_list|(
name|htab
argument_list|,
operator|&
name|htab
operator|->
name|sdata
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|ppc_elf_hash_entry
argument_list|(
name|h
argument_list|)
operator|->
name|has_sda_refs
operator|=
name|TRUE
expr_stmt|;
name|h
operator|->
name|non_got_ref
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
case|case
name|R_PPC_EMB_SDA2REL
case|:
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
name|bad_shared_reloc
argument_list|(
name|abfd
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|htab
operator|->
name|sdata
index|[
literal|1
index|]
operator|.
name|sym
operator|==
name|NULL
operator|&&
operator|!
name|create_sdata_sym
argument_list|(
name|htab
argument_list|,
operator|&
name|htab
operator|->
name|sdata
index|[
literal|1
index|]
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|ppc_elf_hash_entry
argument_list|(
name|h
argument_list|)
operator|->
name|has_sda_refs
operator|=
name|TRUE
expr_stmt|;
name|h
operator|->
name|non_got_ref
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
case|case
name|R_PPC_EMB_SDA21
case|:
case|case
name|R_PPC_EMB_RELSDA
case|:
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
name|bad_shared_reloc
argument_list|(
name|abfd
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|htab
operator|->
name|sdata
index|[
literal|0
index|]
operator|.
name|sym
operator|==
name|NULL
operator|&&
operator|!
name|create_sdata_sym
argument_list|(
name|htab
argument_list|,
operator|&
name|htab
operator|->
name|sdata
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|htab
operator|->
name|sdata
index|[
literal|1
index|]
operator|.
name|sym
operator|==
name|NULL
operator|&&
operator|!
name|create_sdata_sym
argument_list|(
name|htab
argument_list|,
operator|&
name|htab
operator|->
name|sdata
index|[
literal|1
index|]
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|ppc_elf_hash_entry
argument_list|(
name|h
argument_list|)
operator|->
name|has_sda_refs
operator|=
name|TRUE
expr_stmt|;
name|h
operator|->
name|non_got_ref
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
case|case
name|R_PPC_EMB_NADDR32
case|:
case|case
name|R_PPC_EMB_NADDR16
case|:
case|case
name|R_PPC_EMB_NADDR16_LO
case|:
case|case
name|R_PPC_EMB_NADDR16_HI
case|:
case|case
name|R_PPC_EMB_NADDR16_HA
case|:
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
name|bad_shared_reloc
argument_list|(
name|abfd
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|h
operator|->
name|non_got_ref
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|R_PPC_PLT32
case|:
case|case
name|R_PPC_PLTREL24
case|:
case|case
name|R_PPC_PLTREL32
case|:
case|case
name|R_PPC_PLT16_LO
case|:
case|case
name|R_PPC_PLT16_HI
case|:
case|case
name|R_PPC_PLT16_HA
case|:
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Reloc requires a PLT entry\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* This symbol requires a procedure linkage table entry.  We 	     actually build the entry in finish_dynamic_symbol, 	     because this might be a case of linking PIC code without 	     linking in any dynamic objects, in which case we don't 	     need to generate a procedure linkage table after all.  */
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
block|{
comment|/* It does not make sense to have a procedure linkage 		 table entry for a local symbol.  */
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B(%A+0x%lx): %s reloc against "
literal|"local symbol"
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|sec
argument_list|,
operator|(
name|long
operator|)
name|rel
operator|->
name|r_offset
argument_list|,
name|ppc_elf_howto_table
index|[
name|r_type
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
else|else
block|{
name|bfd_vma
name|addend
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_PPC_PLTREL24
condition|)
block|{
name|ppc_elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|makes_plt_call
operator|=
literal|1
expr_stmt|;
name|addend
operator|=
name|rel
operator|->
name|r_addend
expr_stmt|;
block|}
name|h
operator|->
name|needs_plt
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|update_plt_info
argument_list|(
name|abfd
argument_list|,
name|h
argument_list|,
name|got2
argument_list|,
name|addend
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
break|break;
comment|/* The following relocations don't need to propagate the 	     relocation if linking a shared object since they are 	     section relative.  */
case|case
name|R_PPC_SECTOFF
case|:
case|case
name|R_PPC_SECTOFF_LO
case|:
case|case
name|R_PPC_SECTOFF_HI
case|:
case|case
name|R_PPC_SECTOFF_HA
case|:
case|case
name|R_PPC_DTPREL16
case|:
case|case
name|R_PPC_DTPREL16_LO
case|:
case|case
name|R_PPC_DTPREL16_HI
case|:
case|case
name|R_PPC_DTPREL16_HA
case|:
case|case
name|R_PPC_TOC16
case|:
break|break;
case|case
name|R_PPC_REL16
case|:
case|case
name|R_PPC_REL16_LO
case|:
case|case
name|R_PPC_REL16_HI
case|:
case|case
name|R_PPC_REL16_HA
case|:
name|ppc_elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|has_rel16
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* These are just markers.  */
case|case
name|R_PPC_TLS
case|:
case|case
name|R_PPC_EMB_MRKREF
case|:
case|case
name|R_PPC_NONE
case|:
case|case
name|R_PPC_max
case|:
break|break;
comment|/* These should only appear in dynamic objects.  */
case|case
name|R_PPC_COPY
case|:
case|case
name|R_PPC_GLOB_DAT
case|:
case|case
name|R_PPC_JMP_SLOT
case|:
case|case
name|R_PPC_RELATIVE
case|:
break|break;
comment|/* These aren't handled yet.  We'll report an error later.  */
case|case
name|R_PPC_ADDR30
case|:
case|case
name|R_PPC_EMB_RELSEC16
case|:
case|case
name|R_PPC_EMB_RELST_LO
case|:
case|case
name|R_PPC_EMB_RELST_HI
case|:
case|case
name|R_PPC_EMB_RELST_HA
case|:
case|case
name|R_PPC_EMB_BIT_FLD
case|:
break|break;
comment|/* This refers only to functions defined in the shared library.  */
case|case
name|R_PPC_LOCAL24PC
case|:
if|if
condition|(
name|h
operator|&&
name|h
operator|==
name|htab
operator|->
name|elf
operator|.
name|hgot
operator|&&
name|htab
operator|->
name|plt_type
operator|==
name|PLT_UNSET
condition|)
block|{
name|htab
operator|->
name|plt_type
operator|=
name|PLT_OLD
expr_stmt|;
name|htab
operator|->
name|old_bfd
operator|=
name|abfd
expr_stmt|;
block|}
break|break;
comment|/* This relocation describes the C++ object vtable hierarchy. 	     Reconstruct it for later use during GC.  */
case|case
name|R_PPC_GNU_VTINHERIT
case|:
if|if
condition|(
operator|!
name|bfd_elf_gc_record_vtinherit
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|h
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
comment|/* This relocation describes which C++ vtable entries are actually 	     used.  Record for later use during GC.  */
case|case
name|R_PPC_GNU_VTENTRY
case|:
if|if
condition|(
operator|!
name|bfd_elf_gc_record_vtentry
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|h
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
comment|/* We shouldn't really be seeing these.  */
case|case
name|R_PPC_TPREL32
case|:
if|if
condition|(
name|info
operator|->
name|shared
condition|)
name|info
operator|->
name|flags
operator||=
name|DF_STATIC_TLS
expr_stmt|;
goto|goto
name|dodyn
goto|;
comment|/* Nor these.  */
case|case
name|R_PPC_DTPMOD32
case|:
case|case
name|R_PPC_DTPREL32
case|:
goto|goto
name|dodyn
goto|;
case|case
name|R_PPC_TPREL16
case|:
case|case
name|R_PPC_TPREL16_LO
case|:
case|case
name|R_PPC_TPREL16_HI
case|:
case|case
name|R_PPC_TPREL16_HA
case|:
if|if
condition|(
name|info
operator|->
name|shared
condition|)
name|info
operator|->
name|flags
operator||=
name|DF_STATIC_TLS
expr_stmt|;
goto|goto
name|dodyn
goto|;
case|case
name|R_PPC_REL32
case|:
if|if
condition|(
name|h
operator|==
name|NULL
operator|&&
name|got2
operator|!=
name|NULL
operator|&&
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_CODE
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|info
operator|->
name|shared
operator|||
name|info
operator|->
name|pie
operator|)
operator|&&
name|htab
operator|->
name|plt_type
operator|==
name|PLT_UNSET
condition|)
block|{
comment|/* Old -fPIC gcc code has .long LCTOC1-LCFx just before 		 the start of a function, which assembles to a REL32 		 reference to .got2.  If we detect one of these, then 		 force the old PLT layout because the linker cannot 		 reliably deduce the GOT pointer value needed for 		 PLT call stubs.  */
name|asection
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|bfd_section_from_r_symndx
argument_list|(
name|abfd
argument_list|,
operator|&
name|htab
operator|->
name|sym_sec
argument_list|,
name|sec
argument_list|,
name|r_symndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|got2
condition|)
block|{
name|htab
operator|->
name|plt_type
operator|=
name|PLT_OLD
expr_stmt|;
name|htab
operator|->
name|old_bfd
operator|=
name|abfd
expr_stmt|;
block|}
block|}
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
name|h
operator|==
name|htab
operator|->
name|elf
operator|.
name|hgot
condition|)
break|break;
goto|goto
name|dodyn1
goto|;
case|case
name|R_PPC_REL24
case|:
case|case
name|R_PPC_REL14
case|:
case|case
name|R_PPC_REL14_BRTAKEN
case|:
case|case
name|R_PPC_REL14_BRNTAKEN
case|:
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|h
operator|==
name|htab
operator|->
name|elf
operator|.
name|hgot
condition|)
block|{
if|if
condition|(
name|htab
operator|->
name|plt_type
operator|==
name|PLT_UNSET
condition|)
block|{
name|htab
operator|->
name|plt_type
operator|=
name|PLT_OLD
expr_stmt|;
name|htab
operator|->
name|old_bfd
operator|=
name|abfd
expr_stmt|;
block|}
break|break;
block|}
comment|/* fall through */
case|case
name|R_PPC_ADDR32
case|:
case|case
name|R_PPC_ADDR24
case|:
case|case
name|R_PPC_ADDR16
case|:
case|case
name|R_PPC_ADDR16_LO
case|:
case|case
name|R_PPC_ADDR16_HI
case|:
case|case
name|R_PPC_ADDR16_HA
case|:
case|case
name|R_PPC_ADDR14
case|:
case|case
name|R_PPC_ADDR14_BRTAKEN
case|:
case|case
name|R_PPC_ADDR14_BRNTAKEN
case|:
case|case
name|R_PPC_UADDR32
case|:
case|case
name|R_PPC_UADDR16
case|:
name|dodyn1
label|:
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|!
name|info
operator|->
name|shared
condition|)
block|{
comment|/* We may need a plt entry if the symbol turns out to be 		 a function defined in a dynamic object.  */
if|if
condition|(
operator|!
name|update_plt_info
argument_list|(
name|abfd
argument_list|,
name|h
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* We may need a copy reloc too.  */
name|h
operator|->
name|non_got_ref
operator|=
literal|1
expr_stmt|;
block|}
name|dodyn
label|:
comment|/* If we are creating a shared library, and this is a reloc 	     against a global symbol, or a non PC relative reloc 	     against a local symbol, then we need to copy the reloc 	     into the shared library.  However, if we are linking with 	     -Bsymbolic, we do not need to copy a reloc against a 	     global symbol which is defined in an object we are 	     including in the link (i.e., DEF_REGULAR is set).  At 	     this point we have not seen all the input files, so it is 	     possible that DEF_REGULAR is not set now but will be set 	     later (it is never cleared).  In case of a weak definition, 	     DEF_REGULAR may be cleared later by a strong definition in 	     a shared library.  We account for that possibility below by 	     storing information in the dyn_relocs field of the hash 	     table entry.  A similar situation occurs when creating 	     shared libraries and symbol visibility changes render the 	     symbol local.  	     If on the other hand, we are creating an executable, we 	     may need to keep relocations for symbols satisfied by a 	     dynamic library if we manage to avoid copy relocs for the 	     symbol.  */
if|if
condition|(
operator|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|MUST_BE_DYN_RELOC
argument_list|(
name|r_type
argument_list|)
operator|||
operator|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
operator|!
name|info
operator|->
name|symbolic
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|||
operator|!
name|h
operator|->
name|def_regular
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|ELIMINATE_COPY_RELOCS
operator|&&
operator|!
name|info
operator|->
name|shared
operator|&&
name|h
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|||
operator|!
name|h
operator|->
name|def_regular
operator|)
operator|)
condition|)
block|{
name|struct
name|ppc_elf_dyn_relocs
modifier|*
name|p
decl_stmt|;
name|struct
name|ppc_elf_dyn_relocs
modifier|*
modifier|*
name|head
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ppc_elf_check_relocs needs to "
literal|"create relocation for %s\n"
argument_list|,
operator|(
name|h
operator|&&
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
condition|?
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
else|:
literal|"<unknown>"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
operator|(
name|bfd_elf_string_from_elf_section
argument_list|(
name|abfd
argument_list|,
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_shstrndx
argument_list|,
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|rel_hdr
operator|.
name|sh_name
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|BFD_ASSERT
argument_list|(
name|CONST_STRNEQ
argument_list|(
name|name
argument_list|,
literal|".rela"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|,
name|name
operator|+
literal|5
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
operator|==
name|NULL
condition|)
name|htab
operator|->
name|elf
operator|.
name|dynobj
operator|=
name|abfd
expr_stmt|;
name|sreloc
operator|=
name|bfd_get_section_by_name
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
block|{
name|flagword
name|flags
decl_stmt|;
name|flags
operator|=
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_READONLY
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator|)
expr_stmt|;
name|sreloc
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|name
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|sreloc
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|sreloc
operator|=
name|sreloc
expr_stmt|;
block|}
comment|/* If this is a global symbol, we count the number of 		 relocations we need for this symbol.  */
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|head
operator|=
operator|&
name|ppc_elf_hash_entry
argument_list|(
name|h
argument_list|)
operator|->
name|dyn_relocs
expr_stmt|;
block|}
else|else
block|{
comment|/* Track dynamic relocs needed for local syms too. 		     We really need local syms available to do this 		     easily.  Oh well.  */
name|asection
modifier|*
name|s
decl_stmt|;
name|void
modifier|*
name|vpp
decl_stmt|;
name|s
operator|=
name|bfd_section_from_r_symndx
argument_list|(
name|abfd
argument_list|,
operator|&
name|htab
operator|->
name|sym_sec
argument_list|,
name|sec
argument_list|,
name|r_symndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|vpp
operator|=
operator|&
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|local_dynrel
expr_stmt|;
name|head
operator|=
operator|(
expr|struct
name|ppc_elf_dyn_relocs
operator|*
operator|*
operator|)
name|vpp
expr_stmt|;
block|}
name|p
operator|=
operator|*
name|head
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|p
operator|->
name|sec
operator|!=
name|sec
condition|)
block|{
name|p
operator|=
name|bfd_alloc
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
sizeof|sizeof
expr|*
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|p
operator|->
name|next
operator|=
operator|*
name|head
expr_stmt|;
operator|*
name|head
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|sec
operator|=
name|sec
expr_stmt|;
name|p
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|pc_count
operator|=
literal|0
expr_stmt|;
block|}
name|p
operator|->
name|count
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|MUST_BE_DYN_RELOC
argument_list|(
name|r_type
argument_list|)
condition|)
name|p
operator|->
name|pc_count
operator|+=
literal|1
expr_stmt|;
block|}
break|break;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Merge object attributes from IBFD into OBFD.  Raise an error if    there are conflicting attributes.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc_elf_merge_obj_attributes
parameter_list|(
name|bfd
modifier|*
name|ibfd
parameter_list|,
name|bfd
modifier|*
name|obfd
parameter_list|)
block|{
name|obj_attribute
modifier|*
name|in_attr
decl_stmt|;
name|obj_attribute
modifier|*
name|out_attr
decl_stmt|;
if|if
condition|(
operator|!
name|elf_known_obj_attributes_proc
argument_list|(
name|obfd
argument_list|)
index|[
literal|0
index|]
operator|.
name|i
condition|)
block|{
comment|/* This is the first object.  Copy the attributes.  */
name|_bfd_elf_copy_obj_attributes
argument_list|(
name|ibfd
argument_list|,
name|obfd
argument_list|)
expr_stmt|;
comment|/* Use the Tag_null value to indicate the attributes have been 	 initialized.  */
name|elf_known_obj_attributes_proc
argument_list|(
name|obfd
argument_list|)
index|[
literal|0
index|]
operator|.
name|i
operator|=
literal|1
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* Check for conflicting Tag_GNU_Power_ABI_FP attributes and merge      non-conflicting ones.  */
name|in_attr
operator|=
name|elf_known_obj_attributes
argument_list|(
name|ibfd
argument_list|)
index|[
name|OBJ_ATTR_GNU
index|]
expr_stmt|;
name|out_attr
operator|=
name|elf_known_obj_attributes
argument_list|(
name|obfd
argument_list|)
index|[
name|OBJ_ATTR_GNU
index|]
expr_stmt|;
if|if
condition|(
name|in_attr
index|[
name|Tag_GNU_Power_ABI_FP
index|]
operator|.
name|i
operator|!=
name|out_attr
index|[
name|Tag_GNU_Power_ABI_FP
index|]
operator|.
name|i
condition|)
block|{
name|out_attr
index|[
name|Tag_GNU_Power_ABI_FP
index|]
operator|.
name|type
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|out_attr
index|[
name|Tag_GNU_Power_ABI_FP
index|]
operator|.
name|i
operator|==
literal|0
condition|)
name|out_attr
index|[
name|Tag_GNU_Power_ABI_FP
index|]
operator|.
name|i
operator|=
name|in_attr
index|[
name|Tag_GNU_Power_ABI_FP
index|]
operator|.
name|i
expr_stmt|;
elseif|else
if|if
condition|(
name|in_attr
index|[
name|Tag_GNU_Power_ABI_FP
index|]
operator|.
name|i
operator|==
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|out_attr
index|[
name|Tag_GNU_Power_ABI_FP
index|]
operator|.
name|i
operator|==
literal|1
operator|&&
name|in_attr
index|[
name|Tag_GNU_Power_ABI_FP
index|]
operator|.
name|i
operator|==
literal|2
condition|)
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"Warning: %B uses hard float, %B uses soft float"
argument_list|)
argument_list|,
name|obfd
argument_list|,
name|ibfd
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|out_attr
index|[
name|Tag_GNU_Power_ABI_FP
index|]
operator|.
name|i
operator|==
literal|2
operator|&&
name|in_attr
index|[
name|Tag_GNU_Power_ABI_FP
index|]
operator|.
name|i
operator|==
literal|1
condition|)
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"Warning: %B uses hard float, %B uses soft float"
argument_list|)
argument_list|,
name|ibfd
argument_list|,
name|obfd
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|in_attr
index|[
name|Tag_GNU_Power_ABI_FP
index|]
operator|.
name|i
operator|>
literal|2
condition|)
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"Warning: %B uses unknown floating point ABI %d"
argument_list|)
argument_list|,
name|ibfd
argument_list|,
name|in_attr
index|[
name|Tag_GNU_Power_ABI_FP
index|]
operator|.
name|i
argument_list|)
expr_stmt|;
else|else
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"Warning: %B uses unknown floating point ABI %d"
argument_list|)
argument_list|,
name|obfd
argument_list|,
name|out_attr
index|[
name|Tag_GNU_Power_ABI_FP
index|]
operator|.
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* Merge Tag_compatibility attributes and any common GNU ones.  */
name|_bfd_elf_merge_object_attributes
argument_list|(
name|ibfd
argument_list|,
name|obfd
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Merge backend specific data from an object file to the output    object file when linking.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc_elf_merge_private_bfd_data
parameter_list|(
name|bfd
modifier|*
name|ibfd
parameter_list|,
name|bfd
modifier|*
name|obfd
parameter_list|)
block|{
name|flagword
name|old_flags
decl_stmt|;
name|flagword
name|new_flags
decl_stmt|;
name|bfd_boolean
name|error
decl_stmt|;
if|if
condition|(
operator|!
name|is_ppc_elf_target
argument_list|(
name|ibfd
operator|->
name|xvec
argument_list|)
operator|||
operator|!
name|is_ppc_elf_target
argument_list|(
name|obfd
operator|->
name|xvec
argument_list|)
condition|)
return|return
name|TRUE
return|;
comment|/* Check if we have the same endianess.  */
if|if
condition|(
operator|!
name|_bfd_generic_verify_endian_match
argument_list|(
name|ibfd
argument_list|,
name|obfd
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|ppc_elf_merge_obj_attributes
argument_list|(
name|ibfd
argument_list|,
name|obfd
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|new_flags
operator|=
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
name|old_flags
operator|=
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
if|if
condition|(
operator|!
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
condition|)
block|{
comment|/* First call, no flags set.  */
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
operator|=
name|TRUE
expr_stmt|;
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|=
name|new_flags
expr_stmt|;
block|}
comment|/* Compatible flags are ok.  */
elseif|else
if|if
condition|(
name|new_flags
operator|==
name|old_flags
condition|)
empty_stmt|;
comment|/* Incompatible flags.  */
else|else
block|{
comment|/* Warn about -mrelocatable mismatch.  Allow -mrelocatable-lib 	 to be linked with either.  */
name|error
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|(
name|new_flags
operator|&
name|EF_PPC_RELOCATABLE
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|old_flags
operator|&
operator|(
name|EF_PPC_RELOCATABLE
operator||
name|EF_PPC_RELOCATABLE_LIB
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|TRUE
expr_stmt|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: compiled with -mrelocatable and linked with "
literal|"modules compiled normally"
argument_list|)
argument_list|,
name|ibfd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|new_flags
operator|&
operator|(
name|EF_PPC_RELOCATABLE
operator||
name|EF_PPC_RELOCATABLE_LIB
operator|)
operator|)
operator|==
literal|0
operator|&&
operator|(
name|old_flags
operator|&
name|EF_PPC_RELOCATABLE
operator|)
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|TRUE
expr_stmt|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: compiled normally and linked with "
literal|"modules compiled with -mrelocatable"
argument_list|)
argument_list|,
name|ibfd
argument_list|)
expr_stmt|;
block|}
comment|/* The output is -mrelocatable-lib iff both the input files are.  */
if|if
condition|(
operator|!
operator|(
name|new_flags
operator|&
name|EF_PPC_RELOCATABLE_LIB
operator|)
condition|)
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|&=
operator|~
name|EF_PPC_RELOCATABLE_LIB
expr_stmt|;
comment|/* The output is -mrelocatable iff it can't be -mrelocatable-lib, 	 but each input file is either -mrelocatable or -mrelocatable-lib.  */
if|if
condition|(
operator|!
operator|(
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_PPC_RELOCATABLE_LIB
operator|)
operator|&&
operator|(
name|new_flags
operator|&
operator|(
name|EF_PPC_RELOCATABLE_LIB
operator||
name|EF_PPC_RELOCATABLE
operator|)
operator|)
operator|&&
operator|(
name|old_flags
operator|&
operator|(
name|EF_PPC_RELOCATABLE_LIB
operator||
name|EF_PPC_RELOCATABLE
operator|)
operator|)
condition|)
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator||=
name|EF_PPC_RELOCATABLE
expr_stmt|;
comment|/* Do not warn about eabi vs. V.4 mismatch, just or in the bit if 	 any module uses it.  */
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator||=
operator|(
name|new_flags
operator|&
name|EF_PPC_EMB
operator|)
expr_stmt|;
name|new_flags
operator|&=
operator|~
operator|(
name|EF_PPC_RELOCATABLE
operator||
name|EF_PPC_RELOCATABLE_LIB
operator||
name|EF_PPC_EMB
operator|)
expr_stmt|;
name|old_flags
operator|&=
operator|~
operator|(
name|EF_PPC_RELOCATABLE
operator||
name|EF_PPC_RELOCATABLE_LIB
operator||
name|EF_PPC_EMB
operator|)
expr_stmt|;
comment|/* Warn about any other mismatches.  */
if|if
condition|(
name|new_flags
operator|!=
name|old_flags
condition|)
block|{
name|error
operator|=
name|TRUE
expr_stmt|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: uses different e_flags (0x%lx) fields "
literal|"than previous modules (0x%lx)"
argument_list|)
argument_list|,
name|ibfd
argument_list|,
operator|(
name|long
operator|)
name|new_flags
argument_list|,
operator|(
name|long
operator|)
name|old_flags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Choose which PLT scheme to use, and set .plt flags appropriately.    Returns -1 on error, 0 for old PLT, 1 for new PLT.  */
end_comment

begin_function
name|int
name|ppc_elf_select_plt_layout
parameter_list|(
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|enum
name|ppc_elf_plt_type
name|plt_style
parameter_list|,
name|int
name|emit_stub_syms
parameter_list|)
block|{
name|struct
name|ppc_elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
name|htab
operator|=
name|ppc_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|plt_type
operator|==
name|PLT_UNSET
condition|)
block|{
if|if
condition|(
name|plt_style
operator|==
name|PLT_OLD
condition|)
name|htab
operator|->
name|plt_type
operator|=
name|PLT_OLD
expr_stmt|;
else|else
block|{
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|enum
name|ppc_elf_plt_type
name|plt_type
init|=
name|plt_style
decl_stmt|;
comment|/* Look through the reloc flags left by ppc_elf_check_relocs. 	     Use the old style bss plt if a file makes plt calls 	     without using the new relocs, and if ld isn't given 	     --secure-plt and we never see REL16 relocs.  */
if|if
condition|(
name|plt_type
operator|==
name|PLT_UNSET
condition|)
name|plt_type
operator|=
name|PLT_OLD
expr_stmt|;
for|for
control|(
name|ibfd
operator|=
name|info
operator|->
name|input_bfds
init|;
name|ibfd
condition|;
name|ibfd
operator|=
name|ibfd
operator|->
name|link_next
control|)
if|if
condition|(
name|is_ppc_elf_target
argument_list|(
name|ibfd
operator|->
name|xvec
argument_list|)
condition|)
block|{
if|if
condition|(
name|ppc_elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|has_rel16
condition|)
name|plt_type
operator|=
name|PLT_NEW
expr_stmt|;
elseif|else
if|if
condition|(
name|ppc_elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|makes_plt_call
condition|)
block|{
name|plt_type
operator|=
name|PLT_OLD
expr_stmt|;
name|htab
operator|->
name|old_bfd
operator|=
name|ibfd
expr_stmt|;
break|break;
block|}
block|}
name|htab
operator|->
name|plt_type
operator|=
name|plt_type
expr_stmt|;
block|}
block|}
if|if
condition|(
name|htab
operator|->
name|plt_type
operator|==
name|PLT_OLD
operator|&&
name|plt_style
operator|==
name|PLT_NEW
condition|)
name|info
operator|->
name|callbacks
operator|->
name|info
argument_list|(
name|_
argument_list|(
literal|"Using bss-plt due to %B"
argument_list|)
argument_list|,
name|htab
operator|->
name|old_bfd
argument_list|)
expr_stmt|;
name|htab
operator|->
name|emit_stub_syms
operator|=
name|emit_stub_syms
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|htab
operator|->
name|plt_type
operator|!=
name|PLT_VXWORKS
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|plt_type
operator|==
name|PLT_NEW
condition|)
block|{
name|flags
operator|=
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator|)
expr_stmt|;
comment|/* The new PLT is a loaded section.  */
if|if
condition|(
name|htab
operator|->
name|plt
operator|!=
name|NULL
operator|&&
operator|!
name|bfd_set_section_flags
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|htab
operator|->
name|plt
argument_list|,
name|flags
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* The new GOT is not executable.  */
if|if
condition|(
name|htab
operator|->
name|got
operator|!=
name|NULL
operator|&&
operator|!
name|bfd_set_section_flags
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|htab
operator|->
name|got
argument_list|,
name|flags
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
comment|/* Stop an unused .glink section from affecting .text alignment.  */
if|if
condition|(
name|htab
operator|->
name|glink
operator|!=
name|NULL
operator|&&
operator|!
name|bfd_set_section_alignment
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|htab
operator|->
name|glink
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
return|return
name|htab
operator|->
name|plt_type
operator|==
name|PLT_NEW
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the section that should be marked against GC for a given    relocation.  */
end_comment

begin_function
specifier|static
name|asection
modifier|*
name|ppc_elf_gc_mark_hook
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|rel
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|)
block|{
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
switch|switch
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_PPC_GNU_VTINHERIT
case|:
case|case
name|R_PPC_GNU_VTENTRY
case|:
return|return
name|NULL
return|;
block|}
return|return
name|_bfd_elf_gc_mark_hook
argument_list|(
name|sec
argument_list|,
name|info
argument_list|,
name|rel
argument_list|,
name|h
argument_list|,
name|sym
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Update the got, plt and dynamic reloc reference counts for the    section being removed.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc_elf_gc_sweep_hook
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
parameter_list|)
block|{
name|struct
name|ppc_elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|bfd_signed_vma
modifier|*
name|local_got_refcounts
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|,
modifier|*
name|relend
decl_stmt|;
name|asection
modifier|*
name|got2
decl_stmt|;
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|local_dynrel
operator|=
name|NULL
expr_stmt|;
name|htab
operator|=
name|ppc_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|local_got_refcounts
operator|=
name|elf_local_got_refcounts
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|got2
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".got2"
argument_list|)
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|enum
name|elf_ppc_reloc_type
name|r_type
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
init|=
name|NULL
decl_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|>=
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|struct
name|ppc_elf_dyn_relocs
modifier|*
modifier|*
name|pp
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|struct
name|ppc_elf_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|ppc_elf_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
for|for
control|(
name|pp
operator|=
operator|&
name|eh
operator|->
name|dyn_relocs
init|;
operator|(
name|p
operator|=
operator|*
name|pp
operator|)
operator|!=
name|NULL
condition|;
name|pp
operator|=
operator|&
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|sec
operator|==
name|sec
condition|)
block|{
comment|/* Everything must go for SEC.  */
operator|*
name|pp
operator|=
name|p
operator|->
name|next
expr_stmt|;
break|break;
block|}
block|}
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_PPC_GOT_TLSLD16
case|:
case|case
name|R_PPC_GOT_TLSLD16_LO
case|:
case|case
name|R_PPC_GOT_TLSLD16_HI
case|:
case|case
name|R_PPC_GOT_TLSLD16_HA
case|:
name|htab
operator|->
name|tlsld_got
operator|.
name|refcount
operator|-=
literal|1
expr_stmt|;
comment|/* Fall thru */
case|case
name|R_PPC_GOT_TLSGD16
case|:
case|case
name|R_PPC_GOT_TLSGD16_LO
case|:
case|case
name|R_PPC_GOT_TLSGD16_HI
case|:
case|case
name|R_PPC_GOT_TLSGD16_HA
case|:
case|case
name|R_PPC_GOT_TPREL16
case|:
case|case
name|R_PPC_GOT_TPREL16_LO
case|:
case|case
name|R_PPC_GOT_TPREL16_HI
case|:
case|case
name|R_PPC_GOT_TPREL16_HA
case|:
case|case
name|R_PPC_GOT_DTPREL16
case|:
case|case
name|R_PPC_GOT_DTPREL16_LO
case|:
case|case
name|R_PPC_GOT_DTPREL16_HI
case|:
case|case
name|R_PPC_GOT_DTPREL16_HA
case|:
case|case
name|R_PPC_GOT16
case|:
case|case
name|R_PPC_GOT16_LO
case|:
case|case
name|R_PPC_GOT16_HI
case|:
case|case
name|R_PPC_GOT16_HA
case|:
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|refcount
operator|>
literal|0
condition|)
name|h
operator|->
name|got
operator|.
name|refcount
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|local_got_refcounts
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|local_got_refcounts
index|[
name|r_symndx
index|]
operator|>
literal|0
condition|)
name|local_got_refcounts
index|[
name|r_symndx
index|]
operator|--
expr_stmt|;
block|}
break|break;
case|case
name|R_PPC_REL24
case|:
case|case
name|R_PPC_REL14
case|:
case|case
name|R_PPC_REL14_BRTAKEN
case|:
case|case
name|R_PPC_REL14_BRNTAKEN
case|:
case|case
name|R_PPC_REL32
case|:
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
name|h
operator|==
name|htab
operator|->
name|elf
operator|.
name|hgot
condition|)
break|break;
comment|/* Fall thru */
case|case
name|R_PPC_ADDR32
case|:
case|case
name|R_PPC_ADDR24
case|:
case|case
name|R_PPC_ADDR16
case|:
case|case
name|R_PPC_ADDR16_LO
case|:
case|case
name|R_PPC_ADDR16_HI
case|:
case|case
name|R_PPC_ADDR16_HA
case|:
case|case
name|R_PPC_ADDR14
case|:
case|case
name|R_PPC_ADDR14_BRTAKEN
case|:
case|case
name|R_PPC_ADDR14_BRNTAKEN
case|:
case|case
name|R_PPC_UADDR32
case|:
case|case
name|R_PPC_UADDR16
case|:
if|if
condition|(
name|info
operator|->
name|shared
condition|)
break|break;
case|case
name|R_PPC_PLT32
case|:
case|case
name|R_PPC_PLTREL24
case|:
case|case
name|R_PPC_PLTREL32
case|:
case|case
name|R_PPC_PLT16_LO
case|:
case|case
name|R_PPC_PLT16_HI
case|:
case|case
name|R_PPC_PLT16_HA
case|:
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|bfd_vma
name|addend
init|=
name|r_type
operator|==
name|R_PPC_PLTREL24
condition|?
name|rel
operator|->
name|r_addend
else|:
literal|0
decl_stmt|;
name|struct
name|plt_entry
modifier|*
name|ent
init|=
name|find_plt_ent
argument_list|(
name|h
argument_list|,
name|got2
argument_list|,
name|addend
argument_list|)
decl_stmt|;
if|if
condition|(
name|ent
operator|->
name|plt
operator|.
name|refcount
operator|>
literal|0
condition|)
name|ent
operator|->
name|plt
operator|.
name|refcount
operator|-=
literal|1
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set htab->tls_get_addr and call the generic ELF tls_setup function.  */
end_comment

begin_function
name|asection
modifier|*
name|ppc_elf_tls_setup
parameter_list|(
name|bfd
modifier|*
name|obfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|ppc_elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|htab
operator|=
name|ppc_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|plt_type
operator|==
name|PLT_NEW
operator|&&
name|htab
operator|->
name|plt
operator|!=
name|NULL
operator|&&
name|htab
operator|->
name|plt
operator|->
name|output_section
operator|!=
name|NULL
condition|)
block|{
name|elf_section_type
argument_list|(
name|htab
operator|->
name|plt
operator|->
name|output_section
argument_list|)
operator|=
name|SHT_PROGBITS
expr_stmt|;
name|elf_section_flags
argument_list|(
name|htab
operator|->
name|plt
operator|->
name|output_section
argument_list|)
operator|=
name|SHF_ALLOC
operator|+
name|SHF_WRITE
expr_stmt|;
block|}
name|htab
operator|->
name|tls_get_addr
operator|=
name|elf_link_hash_lookup
argument_list|(
operator|&
name|htab
operator|->
name|elf
argument_list|,
literal|"__tls_get_addr"
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|_bfd_elf_tls_setup
argument_list|(
name|obfd
argument_list|,
name|info
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Run through all the TLS relocs looking for optimization    opportunities.  */
end_comment

begin_function
name|bfd_boolean
name|ppc_elf_tls_optimize
parameter_list|(
name|bfd
modifier|*
name|obfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|ppc_elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
operator|||
name|info
operator|->
name|shared
condition|)
return|return
name|TRUE
return|;
name|htab
operator|=
name|ppc_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
for|for
control|(
name|ibfd
operator|=
name|info
operator|->
name|input_bfds
init|;
name|ibfd
operator|!=
name|NULL
condition|;
name|ibfd
operator|=
name|ibfd
operator|->
name|link_next
control|)
block|{
name|Elf_Internal_Sym
modifier|*
name|locsyms
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
init|=
operator|&
name|elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|symtab_hdr
decl_stmt|;
for|for
control|(
name|sec
operator|=
name|ibfd
operator|->
name|sections
init|;
name|sec
operator|!=
name|NULL
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
if|if
condition|(
name|sec
operator|->
name|has_tls_reloc
operator|&&
operator|!
name|bfd_is_abs_section
argument_list|(
name|sec
operator|->
name|output_section
argument_list|)
condition|)
block|{
name|Elf_Internal_Rela
modifier|*
name|relstart
decl_stmt|,
modifier|*
name|rel
decl_stmt|,
modifier|*
name|relend
decl_stmt|;
name|int
name|expecting_tls_get_addr
decl_stmt|;
comment|/* Read the relocations.  */
name|relstart
operator|=
name|_bfd_elf_link_read_relocs
argument_list|(
name|ibfd
argument_list|,
name|sec
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|relstart
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|expecting_tls_get_addr
operator|=
literal|0
expr_stmt|;
name|relend
operator|=
name|relstart
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relstart
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|enum
name|elf_ppc_reloc_type
name|r_type
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|tls_mask
decl_stmt|;
name|char
name|tls_set
decl_stmt|,
name|tls_clear
decl_stmt|;
name|bfd_boolean
name|is_local
decl_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|>=
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|ibfd
argument_list|)
expr_stmt|;
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
block|}
name|is_local
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
operator|!
name|h
operator|->
name|def_dynamic
condition|)
name|is_local
operator|=
name|TRUE
expr_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_PPC_GOT_TLSLD16
case|:
case|case
name|R_PPC_GOT_TLSLD16_LO
case|:
case|case
name|R_PPC_GOT_TLSLD16_HI
case|:
case|case
name|R_PPC_GOT_TLSLD16_HA
case|:
comment|/* These relocs should never be against a symbol 		       defined in a shared lib.  Leave them alone if 		       that turns out to be the case.  */
name|expecting_tls_get_addr
operator|=
literal|0
expr_stmt|;
name|htab
operator|->
name|tlsld_got
operator|.
name|refcount
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|is_local
condition|)
continue|continue;
comment|/* LD -> LE */
name|tls_set
operator|=
literal|0
expr_stmt|;
name|tls_clear
operator|=
name|TLS_LD
expr_stmt|;
name|expecting_tls_get_addr
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|R_PPC_GOT_TLSGD16
case|:
case|case
name|R_PPC_GOT_TLSGD16_LO
case|:
case|case
name|R_PPC_GOT_TLSGD16_HI
case|:
case|case
name|R_PPC_GOT_TLSGD16_HA
case|:
if|if
condition|(
name|is_local
condition|)
comment|/* GD -> LE */
name|tls_set
operator|=
literal|0
expr_stmt|;
else|else
comment|/* GD -> IE */
name|tls_set
operator|=
name|TLS_TLS
operator||
name|TLS_TPRELGD
expr_stmt|;
name|tls_clear
operator|=
name|TLS_GD
expr_stmt|;
name|expecting_tls_get_addr
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|R_PPC_GOT_TPREL16
case|:
case|case
name|R_PPC_GOT_TPREL16_LO
case|:
case|case
name|R_PPC_GOT_TPREL16_HI
case|:
case|case
name|R_PPC_GOT_TPREL16_HA
case|:
name|expecting_tls_get_addr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|is_local
condition|)
block|{
comment|/* IE -> LE */
name|tls_set
operator|=
literal|0
expr_stmt|;
name|tls_clear
operator|=
name|TLS_TPREL
expr_stmt|;
break|break;
block|}
else|else
continue|continue;
case|case
name|R_PPC_REL14
case|:
case|case
name|R_PPC_REL14_BRTAKEN
case|:
case|case
name|R_PPC_REL14_BRNTAKEN
case|:
case|case
name|R_PPC_REL24
case|:
if|if
condition|(
name|expecting_tls_get_addr
operator|&&
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|==
name|htab
operator|->
name|tls_get_addr
condition|)
block|{
name|struct
name|plt_entry
modifier|*
name|ent
init|=
name|find_plt_ent
argument_list|(
name|h
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|ent
operator|!=
name|NULL
operator|&&
name|ent
operator|->
name|plt
operator|.
name|refcount
operator|>
literal|0
condition|)
name|ent
operator|->
name|plt
operator|.
name|refcount
operator|-=
literal|1
expr_stmt|;
block|}
name|expecting_tls_get_addr
operator|=
literal|0
expr_stmt|;
continue|continue;
default|default:
name|expecting_tls_get_addr
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|tls_set
operator|==
literal|0
condition|)
block|{
comment|/* We managed to get rid of a got entry.  */
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|refcount
operator|>
literal|0
condition|)
name|h
operator|->
name|got
operator|.
name|refcount
operator|-=
literal|1
expr_stmt|;
block|}
name|tls_mask
operator|=
operator|&
name|ppc_elf_hash_entry
argument_list|(
name|h
argument_list|)
operator|->
name|tls_mask
expr_stmt|;
block|}
else|else
block|{
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|bfd_signed_vma
modifier|*
name|lgot_refs
decl_stmt|;
name|char
modifier|*
name|lgot_masks
decl_stmt|;
if|if
condition|(
name|locsyms
operator|==
name|NULL
condition|)
block|{
name|locsyms
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
if|if
condition|(
name|locsyms
operator|==
name|NULL
condition|)
name|locsyms
operator|=
name|bfd_elf_get_elf_syms
argument_list|(
name|ibfd
argument_list|,
name|symtab_hdr
argument_list|,
name|symtab_hdr
operator|->
name|sh_info
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|locsyms
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|!=
name|relstart
condition|)
name|free
argument_list|(
name|relstart
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
name|sym
operator|=
name|locsyms
operator|+
name|r_symndx
expr_stmt|;
name|lgot_refs
operator|=
name|elf_local_got_refcounts
argument_list|(
name|ibfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|lgot_refs
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|tls_set
operator|==
literal|0
condition|)
block|{
comment|/* We managed to get rid of a got entry.  */
if|if
condition|(
name|lgot_refs
index|[
name|r_symndx
index|]
operator|>
literal|0
condition|)
name|lgot_refs
index|[
name|r_symndx
index|]
operator|-=
literal|1
expr_stmt|;
block|}
name|lgot_masks
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|lgot_refs
operator|+
name|symtab_hdr
operator|->
name|sh_info
operator|)
expr_stmt|;
name|tls_mask
operator|=
operator|&
name|lgot_masks
index|[
name|r_symndx
index|]
expr_stmt|;
block|}
operator|*
name|tls_mask
operator||=
name|tls_set
expr_stmt|;
operator|*
name|tls_mask
operator|&=
operator|~
name|tls_clear
expr_stmt|;
block|}
if|if
condition|(
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|!=
name|relstart
condition|)
name|free
argument_list|(
name|relstart
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|locsyms
operator|!=
name|NULL
operator|&&
operator|(
name|symtab_hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|locsyms
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|locsyms
argument_list|)
expr_stmt|;
else|else
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|locsyms
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Adjust a symbol defined by a dynamic object and referenced by a    regular object.  The current definition is in some section of the    dynamic object, but we're not including those sections.  We have to    change the definition to something the rest of the link can    understand.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc_elf_adjust_dynamic_symbol
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|)
block|{
name|struct
name|ppc_elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ppc_elf_adjust_dynamic_symbol called for %s\n"
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Make sure we know what is going on here.  */
name|htab
operator|=
name|ppc_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|needs_plt
operator|||
name|h
operator|->
name|u
operator|.
name|weakdef
operator|!=
name|NULL
operator|||
operator|(
name|h
operator|->
name|def_dynamic
operator|&&
name|h
operator|->
name|ref_regular
operator|&&
operator|!
name|h
operator|->
name|def_regular
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Deal with function syms.  */
if|if
condition|(
name|h
operator|->
name|type
operator|==
name|STT_FUNC
operator|||
name|h
operator|->
name|needs_plt
condition|)
block|{
comment|/* Clear procedure linkage table information for any symbol that 	 won't need a .plt entry.  */
name|struct
name|plt_entry
modifier|*
name|ent
decl_stmt|;
for|for
control|(
name|ent
operator|=
name|h
operator|->
name|plt
operator|.
name|plist
init|;
name|ent
operator|!=
name|NULL
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
if|if
condition|(
name|ent
operator|->
name|plt
operator|.
name|refcount
operator|>
literal|0
condition|)
break|break;
if|if
condition|(
name|ent
operator|==
name|NULL
operator|||
name|SYMBOL_CALLS_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
operator|||
operator|(
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|!=
name|STV_DEFAULT
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|)
condition|)
block|{
comment|/* A PLT entry is not required/allowed when:  	     1. We are not using ld.so; because then the PLT entry 	     can't be set up, so we can't use one.  In this case, 	     ppc_elf_adjust_dynamic_symbol won't even be called.  	     2. GC has rendered the entry unused.  	     3. We know for certain that a call to this symbol 	     will go to this object, or will remain undefined.  */
name|h
operator|->
name|plt
operator|.
name|plist
operator|=
name|NULL
expr_stmt|;
name|h
operator|->
name|needs_plt
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
else|else
name|h
operator|->
name|plt
operator|.
name|plist
operator|=
name|NULL
expr_stmt|;
comment|/* If this is a weak symbol, and there is a real definition, the      processor independent code will have arranged for us to see the      real definition first, and we can just use the same value.  */
if|if
condition|(
name|h
operator|->
name|u
operator|.
name|weakdef
operator|!=
name|NULL
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
argument_list|)
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
if|if
condition|(
name|ELIMINATE_COPY_RELOCS
condition|)
name|h
operator|->
name|non_got_ref
operator|=
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|non_got_ref
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* This is a reference to a symbol defined by a dynamic object which      is not a function.  */
comment|/* If we are creating a shared library, we must presume that the      only references to the symbol are via the global offset table.      For such cases we need not do anything here; the relocations will      be handled correctly by relocate_section.  */
if|if
condition|(
name|info
operator|->
name|shared
condition|)
return|return
name|TRUE
return|;
comment|/* If there are no references to this symbol that do not use the      GOT, we don't need to generate a copy reloc.  */
if|if
condition|(
operator|!
name|h
operator|->
name|non_got_ref
condition|)
return|return
name|TRUE
return|;
comment|/* If we didn't find any dynamic relocs in read-only sections, then we'll       be keeping the dynamic relocs and avoiding the copy reloc.  We can't       do this if there are any small data relocations.  */
if|if
condition|(
name|ELIMINATE_COPY_RELOCS
operator|&&
operator|!
name|ppc_elf_hash_entry
argument_list|(
name|h
argument_list|)
operator|->
name|has_sda_refs
condition|)
block|{
name|struct
name|ppc_elf_dyn_relocs
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|ppc_elf_hash_entry
argument_list|(
name|h
argument_list|)
operator|->
name|dyn_relocs
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|s
operator|=
name|p
operator|->
name|sec
operator|->
name|output_section
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|!=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|h
operator|->
name|non_got_ref
operator|=
literal|0
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
if|if
condition|(
name|h
operator|->
name|size
operator|==
literal|0
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"dynamic variable `%s' is zero size"
argument_list|)
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* We must allocate the symbol in our .dynbss section, which will      become part of the .bss section of the executable.  There will be      an entry for this symbol in the .dynsym section.  The dynamic      object will contain position independent code, so all references      from the dynamic object to this symbol will go through the global      offset table.  The dynamic linker will use the .dynsym entry to      determine the address it must put in the global offset table, so      both the dynamic object and the regular object will refer to the      same memory location for the variable.       Of course, if the symbol is referenced using SDAREL relocs, we      must instead allocate it in .sbss.  */
if|if
condition|(
name|ppc_elf_hash_entry
argument_list|(
name|h
argument_list|)
operator|->
name|has_sda_refs
condition|)
name|s
operator|=
name|htab
operator|->
name|dynsbss
expr_stmt|;
else|else
name|s
operator|=
name|htab
operator|->
name|dynbss
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* We must generate a R_PPC_COPY reloc to tell the dynamic linker to      copy the initial value out of the dynamic object and into the      runtime process image.  We need to remember the offset into the      .rela.bss section we are going to use.  */
if|if
condition|(
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
name|asection
modifier|*
name|srel
decl_stmt|;
if|if
condition|(
name|ppc_elf_hash_entry
argument_list|(
name|h
argument_list|)
operator|->
name|has_sda_refs
condition|)
name|srel
operator|=
name|htab
operator|->
name|relsbss
expr_stmt|;
else|else
name|srel
operator|=
name|htab
operator|->
name|relbss
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|srel
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|srel
operator|->
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
name|h
operator|->
name|needs_copy
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|_bfd_elf_adjust_dynamic_copy
argument_list|(
name|h
argument_list|,
name|s
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate a symbol to mark plt call stubs.  For non-PIC code the sym is    xxxxxxxx.plt_call32.<callee> where xxxxxxxx is a hex number, usually 0,    specifying the addend on the plt relocation.  For -fpic code, the sym    is xxxxxxxx.plt_pic32.<callee>, and for -fPIC    xxxxxxxx.got2.plt_pic32.<callee>.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|add_stub_sym
parameter_list|(
name|struct
name|plt_entry
modifier|*
name|ent
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|sh
decl_stmt|;
name|size_t
name|len1
decl_stmt|,
name|len2
decl_stmt|,
name|len3
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|stub
decl_stmt|;
name|struct
name|ppc_elf_link_hash_table
modifier|*
name|htab
init|=
name|ppc_elf_hash_table
argument_list|(
name|info
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
operator|||
name|info
operator|->
name|pie
condition|)
name|stub
operator|=
literal|".plt_pic32."
expr_stmt|;
else|else
name|stub
operator|=
literal|".plt_call32."
expr_stmt|;
name|len1
operator|=
name|strlen
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
name|len2
operator|=
name|strlen
argument_list|(
name|stub
argument_list|)
expr_stmt|;
name|len3
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ent
operator|->
name|sec
condition|)
name|len3
operator|=
name|strlen
argument_list|(
name|ent
operator|->
name|sec
operator|->
name|name
argument_list|)
expr_stmt|;
name|name
operator|=
name|bfd_malloc
argument_list|(
name|len1
operator|+
name|len2
operator|+
name|len3
operator|+
literal|9
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"%08x"
argument_list|,
operator|(
name|unsigned
operator|)
name|ent
operator|->
name|addend
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
if|if
condition|(
name|ent
operator|->
name|sec
condition|)
name|memcpy
argument_list|(
name|name
operator|+
literal|8
argument_list|,
name|ent
operator|->
name|sec
operator|->
name|name
argument_list|,
name|len3
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|name
operator|+
literal|8
operator|+
name|len3
argument_list|,
name|stub
argument_list|,
name|len2
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|name
operator|+
literal|8
operator|+
name|len3
operator|+
name|len2
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|len1
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sh
operator|=
name|elf_link_hash_lookup
argument_list|(
operator|&
name|htab
operator|->
name|elf
argument_list|,
name|name
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sh
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|sh
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_new
condition|)
block|{
name|sh
operator|->
name|root
operator|.
name|type
operator|=
name|bfd_link_hash_defined
expr_stmt|;
name|sh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|htab
operator|->
name|glink
expr_stmt|;
name|sh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|ent
operator|->
name|glink_offset
expr_stmt|;
name|sh
operator|->
name|ref_regular
operator|=
literal|1
expr_stmt|;
name|sh
operator|->
name|def_regular
operator|=
literal|1
expr_stmt|;
name|sh
operator|->
name|ref_regular_nonweak
operator|=
literal|1
expr_stmt|;
name|sh
operator|->
name|forced_local
operator|=
literal|1
expr_stmt|;
name|sh
operator|->
name|non_elf
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Allocate NEED contiguous space in .got, and return the offset.    Handles allocation of the got header when crossing 32k.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|allocate_got
parameter_list|(
name|struct
name|ppc_elf_link_hash_table
modifier|*
name|htab
parameter_list|,
name|unsigned
name|int
name|need
parameter_list|)
block|{
name|bfd_vma
name|where
decl_stmt|;
name|unsigned
name|int
name|max_before_header
decl_stmt|;
if|if
condition|(
name|htab
operator|->
name|plt_type
operator|==
name|PLT_VXWORKS
condition|)
block|{
name|where
operator|=
name|htab
operator|->
name|got
operator|->
name|size
expr_stmt|;
name|htab
operator|->
name|got
operator|->
name|size
operator|+=
name|need
expr_stmt|;
block|}
else|else
block|{
name|max_before_header
operator|=
name|htab
operator|->
name|plt_type
operator|==
name|PLT_NEW
condition|?
literal|32768
else|:
literal|32764
expr_stmt|;
if|if
condition|(
name|need
operator|<=
name|htab
operator|->
name|got_gap
condition|)
block|{
name|where
operator|=
name|max_before_header
operator|-
name|htab
operator|->
name|got_gap
expr_stmt|;
name|htab
operator|->
name|got_gap
operator|-=
name|need
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|htab
operator|->
name|got
operator|->
name|size
operator|+
name|need
operator|>
name|max_before_header
operator|&&
name|htab
operator|->
name|got
operator|->
name|size
operator|<=
name|max_before_header
condition|)
block|{
name|htab
operator|->
name|got_gap
operator|=
name|max_before_header
operator|-
name|htab
operator|->
name|got
operator|->
name|size
expr_stmt|;
name|htab
operator|->
name|got
operator|->
name|size
operator|=
name|max_before_header
operator|+
name|htab
operator|->
name|got_header_size
expr_stmt|;
block|}
name|where
operator|=
name|htab
operator|->
name|got
operator|->
name|size
expr_stmt|;
name|htab
operator|->
name|got
operator|->
name|size
operator|+=
name|need
expr_stmt|;
block|}
block|}
return|return
name|where
return|;
block|}
end_function

begin_comment
comment|/* Allocate space in associated reloc sections for dynamic relocs.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|allocate_dynrelocs
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|void
modifier|*
name|inf
parameter_list|)
block|{
name|struct
name|bfd_link_info
modifier|*
name|info
init|=
name|inf
decl_stmt|;
name|struct
name|ppc_elf_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|struct
name|ppc_elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|struct
name|ppc_elf_dyn_relocs
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
comment|/* When warning symbols are created, they **replace** the "real"        entry in the hash table, thus we never get to see the real        symbol in a hash traversal.  So look at it now.  */
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|htab
operator|=
name|ppc_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|elf
operator|.
name|dynamic_sections_created
condition|)
block|{
name|struct
name|plt_entry
modifier|*
name|ent
decl_stmt|;
name|bfd_boolean
name|doneone
init|=
name|FALSE
decl_stmt|;
name|bfd_vma
name|plt_offset
init|=
literal|0
decl_stmt|,
name|glink_offset
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ent
operator|=
name|h
operator|->
name|plt
operator|.
name|plist
init|;
name|ent
operator|!=
name|NULL
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
if|if
condition|(
name|ent
operator|->
name|plt
operator|.
name|refcount
operator|>
literal|0
condition|)
block|{
comment|/* Make sure this symbol is output as a dynamic symbol.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|&&
operator|!
name|h
operator|->
name|forced_local
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|info
operator|->
name|shared
operator|||
name|WILL_CALL_FINISH_DYNAMIC_SYMBOL
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
name|h
argument_list|)
condition|)
block|{
name|asection
modifier|*
name|s
init|=
name|htab
operator|->
name|plt
decl_stmt|;
if|if
condition|(
name|htab
operator|->
name|plt_type
operator|==
name|PLT_NEW
condition|)
block|{
if|if
condition|(
operator|!
name|doneone
condition|)
block|{
name|plt_offset
operator|=
name|s
operator|->
name|size
expr_stmt|;
name|s
operator|->
name|size
operator|+=
literal|4
expr_stmt|;
block|}
name|ent
operator|->
name|plt
operator|.
name|offset
operator|=
name|plt_offset
expr_stmt|;
name|s
operator|=
name|htab
operator|->
name|glink
expr_stmt|;
if|if
condition|(
operator|!
name|doneone
operator|||
name|info
operator|->
name|shared
operator|||
name|info
operator|->
name|pie
condition|)
block|{
name|glink_offset
operator|=
name|s
operator|->
name|size
expr_stmt|;
name|s
operator|->
name|size
operator|+=
name|GLINK_ENTRY_SIZE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|doneone
operator|&&
operator|!
name|info
operator|->
name|shared
operator|&&
operator|!
name|h
operator|->
name|def_regular
condition|)
block|{
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|s
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|glink_offset
expr_stmt|;
block|}
name|ent
operator|->
name|glink_offset
operator|=
name|glink_offset
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|emit_stub_syms
operator|&&
operator|!
name|add_stub_sym
argument_list|(
name|ent
argument_list|,
name|h
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|doneone
condition|)
block|{
comment|/* If this is the first .plt entry, make room 			   for the special first entry.  */
if|if
condition|(
name|s
operator|->
name|size
operator|==
literal|0
condition|)
name|s
operator|->
name|size
operator|+=
name|htab
operator|->
name|plt_initial_entry_size
expr_stmt|;
comment|/* The PowerPC PLT is actually composed of two 			   parts, the first part is 2 words (for a load 			   and a jump), and then there is a remaining 			   word available at the end.  */
name|plt_offset
operator|=
operator|(
name|htab
operator|->
name|plt_initial_entry_size
operator|+
operator|(
name|htab
operator|->
name|plt_slot_size
operator|*
operator|(
operator|(
name|s
operator|->
name|size
operator|-
name|htab
operator|->
name|plt_initial_entry_size
operator|)
operator|/
name|htab
operator|->
name|plt_entry_size
operator|)
operator|)
operator|)
expr_stmt|;
comment|/* If this symbol is not defined in a regular 			   file, and we are not generating a shared 			   library, then set the symbol to this location 			   in the .plt.  This is required to make 			   function pointers compare as equal between 			   the normal executable and the shared library.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
operator|&&
operator|!
name|h
operator|->
name|def_regular
condition|)
block|{
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|s
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|plt_offset
expr_stmt|;
block|}
comment|/* Make room for this entry.  */
name|s
operator|->
name|size
operator|+=
name|htab
operator|->
name|plt_entry_size
expr_stmt|;
comment|/* After the 8192nd entry, room for two entries 			   is allocated.  */
if|if
condition|(
name|htab
operator|->
name|plt_type
operator|==
name|PLT_OLD
operator|&&
operator|(
name|s
operator|->
name|size
operator|-
name|htab
operator|->
name|plt_initial_entry_size
operator|)
operator|/
name|htab
operator|->
name|plt_entry_size
operator|>
name|PLT_NUM_SINGLE_ENTRIES
condition|)
name|s
operator|->
name|size
operator|+=
name|htab
operator|->
name|plt_entry_size
expr_stmt|;
block|}
name|ent
operator|->
name|plt
operator|.
name|offset
operator|=
name|plt_offset
expr_stmt|;
block|}
comment|/* We also need to make an entry in the .rela.plt section.  */
if|if
condition|(
operator|!
name|doneone
condition|)
block|{
name|htab
operator|->
name|relplt
operator|->
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|plt_type
operator|==
name|PLT_VXWORKS
condition|)
block|{
comment|/* Allocate space for the unloaded relocations.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
if|if
condition|(
name|ent
operator|->
name|plt
operator|.
name|offset
operator|==
operator|(
name|bfd_vma
operator|)
name|htab
operator|->
name|plt_initial_entry_size
condition|)
block|{
name|htab
operator|->
name|srelplt2
operator|->
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
operator|*
name|VXWORKS_PLTRESOLVE_RELOCS
expr_stmt|;
block|}
name|htab
operator|->
name|srelplt2
operator|->
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
operator|*
name|VXWORKS_PLT_NON_JMP_SLOT_RELOCS
expr_stmt|;
block|}
comment|/* Every PLT entry has an associated GOT entry in 			   .got.plt.  */
name|htab
operator|->
name|sgotplt
operator|->
name|size
operator|+=
literal|4
expr_stmt|;
block|}
name|doneone
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
else|else
name|ent
operator|->
name|plt
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|ent
operator|->
name|plt
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|doneone
condition|)
block|{
name|h
operator|->
name|plt
operator|.
name|plist
operator|=
name|NULL
expr_stmt|;
name|h
operator|->
name|needs_plt
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|h
operator|->
name|plt
operator|.
name|plist
operator|=
name|NULL
expr_stmt|;
name|h
operator|->
name|needs_plt
operator|=
literal|0
expr_stmt|;
block|}
name|eh
operator|=
operator|(
expr|struct
name|ppc_elf_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
if|if
condition|(
name|eh
operator|->
name|elf
operator|.
name|got
operator|.
name|refcount
operator|>
literal|0
condition|)
block|{
comment|/* Make sure this symbol is output as a dynamic symbol.  */
if|if
condition|(
name|eh
operator|->
name|elf
operator|.
name|dynindx
operator|==
operator|-
literal|1
operator|&&
operator|!
name|eh
operator|->
name|elf
operator|.
name|forced_local
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
operator|&
name|eh
operator|->
name|elf
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|eh
operator|->
name|tls_mask
operator|==
operator|(
name|TLS_TLS
operator||
name|TLS_LD
operator|)
operator|&&
operator|!
name|eh
operator|->
name|elf
operator|.
name|def_dynamic
condition|)
comment|/* If just an LD reloc, we'll just use htab->tlsld_got.offset.  */
name|eh
operator|->
name|elf
operator|.
name|got
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
else|else
block|{
name|bfd_boolean
name|dyn
decl_stmt|;
name|unsigned
name|int
name|need
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|eh
operator|->
name|tls_mask
operator|&
name|TLS_TLS
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|eh
operator|->
name|tls_mask
operator|&
name|TLS_LD
operator|)
operator|!=
literal|0
condition|)
name|need
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
operator|(
name|eh
operator|->
name|tls_mask
operator|&
name|TLS_GD
operator|)
operator|!=
literal|0
condition|)
name|need
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
operator|(
name|eh
operator|->
name|tls_mask
operator|&
operator|(
name|TLS_TPREL
operator||
name|TLS_TPRELGD
operator|)
operator|)
operator|!=
literal|0
condition|)
name|need
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
operator|(
name|eh
operator|->
name|tls_mask
operator|&
name|TLS_DTPREL
operator|)
operator|!=
literal|0
condition|)
name|need
operator|+=
literal|4
expr_stmt|;
block|}
else|else
name|need
operator|+=
literal|4
expr_stmt|;
name|eh
operator|->
name|elf
operator|.
name|got
operator|.
name|offset
operator|=
name|allocate_got
argument_list|(
name|htab
argument_list|,
name|need
argument_list|)
expr_stmt|;
name|dyn
operator|=
name|htab
operator|->
name|elf
operator|.
name|dynamic_sections_created
expr_stmt|;
if|if
condition|(
operator|(
name|info
operator|->
name|shared
operator|||
name|WILL_CALL_FINISH_DYNAMIC_SYMBOL
argument_list|(
name|dyn
argument_list|,
literal|0
argument_list|,
operator|&
name|eh
operator|->
name|elf
argument_list|)
operator|)
operator|&&
operator|(
name|ELF_ST_VISIBILITY
argument_list|(
name|eh
operator|->
name|elf
operator|.
name|other
argument_list|)
operator|==
name|STV_DEFAULT
operator|||
name|eh
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefweak
operator|)
condition|)
block|{
comment|/* All the entries we allocated need relocs. 		 Except LD only needs one.  */
if|if
condition|(
operator|(
name|eh
operator|->
name|tls_mask
operator|&
name|TLS_LD
operator|)
operator|!=
literal|0
condition|)
name|need
operator|-=
literal|4
expr_stmt|;
name|htab
operator|->
name|relgot
operator|->
name|size
operator|+=
name|need
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
operator|/
literal|4
operator|)
expr_stmt|;
block|}
block|}
block|}
else|else
name|eh
operator|->
name|elf
operator|.
name|got
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|eh
operator|->
name|dyn_relocs
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
comment|/* In the shared -Bsymbolic case, discard space allocated for      dynamic pc-relative relocs against symbols which turn out to be      defined in regular objects.  For the normal shared case, discard      space for relocs that have become local due to symbol visibility      changes.  */
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
comment|/* Relocs that use pc_count are those that appear on a call insn, 	 or certain REL relocs (see MUST_BE_DYN_RELOC) that can be 	 generated via assembly.  We want calls to protected symbols to 	 resolve directly to the function rather than going via the plt. 	 If people want function pointer comparisons to work as expected 	 then they should avoid writing weird assembly.  */
if|if
condition|(
name|SYMBOL_CALLS_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
block|{
name|struct
name|ppc_elf_dyn_relocs
modifier|*
modifier|*
name|pp
decl_stmt|;
for|for
control|(
name|pp
operator|=
operator|&
name|eh
operator|->
name|dyn_relocs
init|;
operator|(
name|p
operator|=
operator|*
name|pp
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
name|p
operator|->
name|count
operator|-=
name|p
operator|->
name|pc_count
expr_stmt|;
name|p
operator|->
name|pc_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|count
operator|==
literal|0
condition|)
operator|*
name|pp
operator|=
name|p
operator|->
name|next
expr_stmt|;
else|else
name|pp
operator|=
operator|&
name|p
operator|->
name|next
expr_stmt|;
block|}
block|}
comment|/* Also discard relocs on undefined weak syms with non-default 	 visibility.  */
if|if
condition|(
name|eh
operator|->
name|dyn_relocs
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
block|{
if|if
condition|(
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|!=
name|STV_DEFAULT
condition|)
name|eh
operator|->
name|dyn_relocs
operator|=
name|NULL
expr_stmt|;
comment|/* Make sure undefined weak symbols are output as a dynamic 	     symbol in PIEs.  */
elseif|else
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|&&
operator|!
name|h
operator|->
name|forced_local
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|ELIMINATE_COPY_RELOCS
condition|)
block|{
comment|/* For the non-shared case, discard space for relocs against 	 symbols which turn out to need copy relocs or are not 	 dynamic.  */
if|if
condition|(
operator|!
name|h
operator|->
name|non_got_ref
operator|&&
name|h
operator|->
name|def_dynamic
operator|&&
operator|!
name|h
operator|->
name|def_regular
condition|)
block|{
comment|/* Make sure this symbol is output as a dynamic symbol. 	     Undefined weak syms won't yet be marked as dynamic.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|&&
operator|!
name|h
operator|->
name|forced_local
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* If that succeeded, we know we'll be keeping all the 	     relocs.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
condition|)
goto|goto
name|keep
goto|;
block|}
name|eh
operator|->
name|dyn_relocs
operator|=
name|NULL
expr_stmt|;
name|keep
label|:
empty_stmt|;
block|}
comment|/* Finally, allocate space.  */
for|for
control|(
name|p
operator|=
name|eh
operator|->
name|dyn_relocs
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|asection
modifier|*
name|sreloc
init|=
name|elf_section_data
argument_list|(
name|p
operator|->
name|sec
argument_list|)
operator|->
name|sreloc
decl_stmt|;
name|sreloc
operator|->
name|size
operator|+=
name|p
operator|->
name|count
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Find any dynamic relocs that apply to read-only sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|readonly_dynrelocs
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|void
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|ppc_elf_dyn_relocs
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
for|for
control|(
name|p
operator|=
name|ppc_elf_hash_entry
argument_list|(
name|h
argument_list|)
operator|->
name|dyn_relocs
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|asection
modifier|*
name|s
init|=
name|p
operator|->
name|sec
operator|->
name|output_section
decl_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|s
operator|->
name|flags
operator|&
operator|(
name|SEC_READONLY
operator||
name|SEC_ALLOC
operator|)
operator|)
operator|==
operator|(
name|SEC_READONLY
operator||
name|SEC_ALLOC
operator|)
operator|)
condition|)
block|{
operator|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|)
name|info
operator|)
operator|->
name|flags
operator||=
name|DF_TEXTREL
expr_stmt|;
comment|/* Not an error, just cut short the traversal.  */
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Set the sizes of the dynamic sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc_elf_size_dynamic_sections
parameter_list|(
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|ppc_elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_boolean
name|relocs
decl_stmt|;
name|bfd
modifier|*
name|ibfd
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ppc_elf_size_dynamic_sections called\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|htab
operator|=
name|ppc_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
comment|/* Set the contents of the .interp section to the interpreter.  */
if|if
condition|(
name|info
operator|->
name|executable
condition|)
block|{
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
literal|".interp"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|size
operator|=
sizeof|sizeof
name|ELF_DYNAMIC_INTERPRETER
expr_stmt|;
name|s
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ELF_DYNAMIC_INTERPRETER
expr_stmt|;
block|}
block|}
if|if
condition|(
name|htab
operator|->
name|plt_type
operator|==
name|PLT_OLD
condition|)
name|htab
operator|->
name|got_header_size
operator|=
literal|16
expr_stmt|;
elseif|else
if|if
condition|(
name|htab
operator|->
name|plt_type
operator|==
name|PLT_NEW
condition|)
name|htab
operator|->
name|got_header_size
operator|=
literal|12
expr_stmt|;
comment|/* Set up .got offsets for local syms, and space for local dynamic      relocs.  */
for|for
control|(
name|ibfd
operator|=
name|info
operator|->
name|input_bfds
init|;
name|ibfd
operator|!=
name|NULL
condition|;
name|ibfd
operator|=
name|ibfd
operator|->
name|link_next
control|)
block|{
name|bfd_signed_vma
modifier|*
name|local_got
decl_stmt|;
name|bfd_signed_vma
modifier|*
name|end_local_got
decl_stmt|;
name|char
modifier|*
name|lgot_masks
decl_stmt|;
name|bfd_size_type
name|locsymcount
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
if|if
condition|(
operator|!
name|is_ppc_elf_target
argument_list|(
name|ibfd
operator|->
name|xvec
argument_list|)
condition|)
continue|continue;
for|for
control|(
name|s
operator|=
name|ibfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|struct
name|ppc_elf_dyn_relocs
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
operator|(
operator|(
expr|struct
name|ppc_elf_dyn_relocs
operator|*
operator|)
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|local_dynrel
operator|)
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|bfd_is_abs_section
argument_list|(
name|p
operator|->
name|sec
argument_list|)
operator|&&
name|bfd_is_abs_section
argument_list|(
name|p
operator|->
name|sec
operator|->
name|output_section
argument_list|)
condition|)
block|{
comment|/* Input section has been discarded, either because 		     it is a copy of a linkonce section or due to 		     linker script /DISCARD/, so we'll be discarding 		     the relocs too.  */
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|count
operator|!=
literal|0
condition|)
block|{
name|elf_section_data
argument_list|(
name|p
operator|->
name|sec
argument_list|)
operator|->
name|sreloc
operator|->
name|size
operator|+=
name|p
operator|->
name|count
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|sec
operator|->
name|output_section
operator|->
name|flags
operator|&
operator|(
name|SEC_READONLY
operator||
name|SEC_ALLOC
operator|)
operator|)
operator|==
operator|(
name|SEC_READONLY
operator||
name|SEC_ALLOC
operator|)
condition|)
name|info
operator|->
name|flags
operator||=
name|DF_TEXTREL
expr_stmt|;
block|}
block|}
block|}
name|local_got
operator|=
name|elf_local_got_refcounts
argument_list|(
name|ibfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|local_got
condition|)
continue|continue;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|locsymcount
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|end_local_got
operator|=
name|local_got
operator|+
name|locsymcount
expr_stmt|;
name|lgot_masks
operator|=
operator|(
name|char
operator|*
operator|)
name|end_local_got
expr_stmt|;
for|for
control|(
init|;
name|local_got
operator|<
name|end_local_got
condition|;
operator|++
name|local_got
operator|,
operator|++
name|lgot_masks
control|)
if|if
condition|(
operator|*
name|local_got
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|lgot_masks
operator|==
operator|(
name|TLS_TLS
operator||
name|TLS_LD
operator|)
condition|)
block|{
comment|/* If just an LD reloc, we'll just use 		   htab->tlsld_got.offset.  */
name|htab
operator|->
name|tlsld_got
operator|.
name|refcount
operator|+=
literal|1
expr_stmt|;
operator|*
name|local_got
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|int
name|need
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|lgot_masks
operator|&
name|TLS_TLS
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|lgot_masks
operator|&
name|TLS_GD
operator|)
operator|!=
literal|0
condition|)
name|need
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|lgot_masks
operator|&
operator|(
name|TLS_TPREL
operator||
name|TLS_TPRELGD
operator|)
operator|)
operator|!=
literal|0
condition|)
name|need
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|lgot_masks
operator|&
name|TLS_DTPREL
operator|)
operator|!=
literal|0
condition|)
name|need
operator|+=
literal|4
expr_stmt|;
block|}
else|else
name|need
operator|+=
literal|4
expr_stmt|;
operator|*
name|local_got
operator|=
name|allocate_got
argument_list|(
name|htab
argument_list|,
name|need
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
name|htab
operator|->
name|relgot
operator|->
name|size
operator|+=
operator|(
name|need
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
operator|/
literal|4
operator|)
operator|)
expr_stmt|;
block|}
block|}
else|else
operator|*
name|local_got
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|htab
operator|->
name|tlsld_got
operator|.
name|refcount
operator|>
literal|0
condition|)
block|{
name|htab
operator|->
name|tlsld_got
operator|.
name|offset
operator|=
name|allocate_got
argument_list|(
name|htab
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
name|htab
operator|->
name|relgot
operator|->
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
block|}
else|else
name|htab
operator|->
name|tlsld_got
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* Allocate space for global sym dynamic relocs.  */
name|elf_link_hash_traverse
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|allocate_dynrelocs
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|got
operator|!=
name|NULL
operator|&&
name|htab
operator|->
name|plt_type
operator|!=
name|PLT_VXWORKS
condition|)
block|{
name|unsigned
name|int
name|g_o_t
init|=
literal|32768
decl_stmt|;
comment|/* If we haven't allocated the header, do so now.  When we get here, 	 for old plt/got the got size will be 0 to 32764 (not allocated), 	 or 32780 to 65536 (header allocated).  For new plt/got, the 	 corresponding ranges are 0 to 32768 and 32780 to 65536.  */
if|if
condition|(
name|htab
operator|->
name|got
operator|->
name|size
operator|<=
literal|32768
condition|)
block|{
name|g_o_t
operator|=
name|htab
operator|->
name|got
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|plt_type
operator|==
name|PLT_OLD
condition|)
name|g_o_t
operator|+=
literal|4
expr_stmt|;
name|htab
operator|->
name|got
operator|->
name|size
operator|+=
name|htab
operator|->
name|got_header_size
expr_stmt|;
block|}
name|htab
operator|->
name|elf
operator|.
name|hgot
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|g_o_t
expr_stmt|;
block|}
if|if
condition|(
name|htab
operator|->
name|glink
operator|!=
name|NULL
operator|&&
name|htab
operator|->
name|glink
operator|->
name|size
operator|!=
literal|0
condition|)
block|{
name|htab
operator|->
name|glink_pltresolve
operator|=
name|htab
operator|->
name|glink
operator|->
name|size
expr_stmt|;
comment|/* Space for the branch table.  */
name|htab
operator|->
name|glink
operator|->
name|size
operator|+=
name|htab
operator|->
name|glink
operator|->
name|size
operator|/
operator|(
name|GLINK_ENTRY_SIZE
operator|/
literal|4
operator|)
operator|-
literal|4
expr_stmt|;
comment|/* Pad out to align the start of PLTresolve.  */
name|htab
operator|->
name|glink
operator|->
name|size
operator|+=
operator|-
name|htab
operator|->
name|glink
operator|->
name|size
operator|&
literal|15
expr_stmt|;
name|htab
operator|->
name|glink
operator|->
name|size
operator|+=
name|GLINK_PLTRESOLVE
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|emit_stub_syms
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|sh
decl_stmt|;
name|sh
operator|=
name|elf_link_hash_lookup
argument_list|(
operator|&
name|htab
operator|->
name|elf
argument_list|,
literal|"__glink"
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sh
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|sh
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_new
condition|)
block|{
name|sh
operator|->
name|root
operator|.
name|type
operator|=
name|bfd_link_hash_defined
expr_stmt|;
name|sh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|htab
operator|->
name|glink
expr_stmt|;
name|sh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|htab
operator|->
name|glink_pltresolve
expr_stmt|;
name|sh
operator|->
name|ref_regular
operator|=
literal|1
expr_stmt|;
name|sh
operator|->
name|def_regular
operator|=
literal|1
expr_stmt|;
name|sh
operator|->
name|ref_regular_nonweak
operator|=
literal|1
expr_stmt|;
name|sh
operator|->
name|forced_local
operator|=
literal|1
expr_stmt|;
name|sh
operator|->
name|non_elf
operator|=
literal|0
expr_stmt|;
block|}
name|sh
operator|=
name|elf_link_hash_lookup
argument_list|(
operator|&
name|htab
operator|->
name|elf
argument_list|,
literal|"__glink_PLTresolve"
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sh
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|sh
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_new
condition|)
block|{
name|sh
operator|->
name|root
operator|.
name|type
operator|=
name|bfd_link_hash_defined
expr_stmt|;
name|sh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|htab
operator|->
name|glink
expr_stmt|;
name|sh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|htab
operator|->
name|glink
operator|->
name|size
operator|-
name|GLINK_PLTRESOLVE
expr_stmt|;
name|sh
operator|->
name|ref_regular
operator|=
literal|1
expr_stmt|;
name|sh
operator|->
name|def_regular
operator|=
literal|1
expr_stmt|;
name|sh
operator|->
name|ref_regular_nonweak
operator|=
literal|1
expr_stmt|;
name|sh
operator|->
name|forced_local
operator|=
literal|1
expr_stmt|;
name|sh
operator|->
name|non_elf
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
comment|/* We've now determined the sizes of the various dynamic sections.      Allocate memory for them.  */
name|relocs
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|s
operator|=
name|htab
operator|->
name|elf
operator|.
name|dynobj
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|bfd_boolean
name|strip_section
init|=
name|TRUE
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LINKER_CREATED
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|s
operator|==
name|htab
operator|->
name|plt
operator|||
name|s
operator|==
name|htab
operator|->
name|glink
operator|||
name|s
operator|==
name|htab
operator|->
name|got
operator|||
name|s
operator|==
name|htab
operator|->
name|sgotplt
operator|||
name|s
operator|==
name|htab
operator|->
name|sbss
operator|||
name|s
operator|==
name|htab
operator|->
name|dynbss
operator|||
name|s
operator|==
name|htab
operator|->
name|dynsbss
condition|)
block|{
comment|/* We'd like to strip these sections if they aren't needed, but if 	     we've exported dynamic symbols from them we must leave them. 	     It's too late to tell BFD to get rid of the symbols.  */
if|if
condition|(
operator|(
name|s
operator|==
name|htab
operator|->
name|plt
operator|||
name|s
operator|==
name|htab
operator|->
name|got
operator|)
operator|&&
name|htab
operator|->
name|elf
operator|.
name|hplt
operator|!=
name|NULL
condition|)
name|strip_section
operator|=
name|FALSE
expr_stmt|;
comment|/* Strip this section if we don't need it; see the 	     comment below.  */
block|}
elseif|else
if|if
condition|(
name|s
operator|==
name|htab
operator|->
name|sdata
index|[
literal|0
index|]
operator|.
name|section
operator|||
name|s
operator|==
name|htab
operator|->
name|sdata
index|[
literal|1
index|]
operator|.
name|section
condition|)
block|{
comment|/* Strip these too.  */
block|}
elseif|else
if|if
condition|(
name|CONST_STRNEQ
argument_list|(
name|bfd_get_section_name
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|)
argument_list|,
literal|".rela"
argument_list|)
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|size
operator|!=
literal|0
condition|)
block|{
comment|/* Remember whether there are any relocation sections.  */
name|relocs
operator|=
name|TRUE
expr_stmt|;
comment|/* We use the reloc_count field as a counter if we need 		 to copy relocs into the output file.  */
name|s
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* It's not one of our sections, so don't allocate space.  */
continue|continue;
block|}
if|if
condition|(
name|s
operator|->
name|size
operator|==
literal|0
operator|&&
name|strip_section
condition|)
block|{
comment|/* If we don't need this section, strip it from the 	     output file.  This is mostly to handle .rela.bss and 	     .rela.plt.  We must create both sections in 	     create_dynamic_sections, because they must be created 	     before the linker maps input sections to output 	     sections.  The linker does that before 	     adjust_dynamic_symbol is called, and it is that 	     function which decides whether anything needs to go 	     into these sections.  */
name|s
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* Allocate memory for the section contents.  */
name|s
operator|->
name|contents
operator|=
name|bfd_zalloc
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|s
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|htab
operator|->
name|elf
operator|.
name|dynamic_sections_created
condition|)
block|{
comment|/* Add some entries to the .dynamic section.  We fill in the 	 values later, in ppc_elf_finish_dynamic_sections, but we 	 must add the entries now so that we get the correct size for 	 the .dynamic section.  The DT_DEBUG entry is filled in by the 	 dynamic linker and used by the debugger.  */
define|#
directive|define
name|add_dynamic_entry
parameter_list|(
name|TAG
parameter_list|,
name|VAL
parameter_list|)
define|\
value|_bfd_elf_add_dynamic_entry (info, TAG, VAL)
if|if
condition|(
name|info
operator|->
name|executable
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_DEBUG
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|htab
operator|->
name|plt
operator|!=
name|NULL
operator|&&
name|htab
operator|->
name|plt
operator|->
name|size
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PLTGOT
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PLTRELSZ
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PLTREL
argument_list|,
name|DT_RELA
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_JMPREL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|htab
operator|->
name|glink
operator|!=
name|NULL
operator|&&
name|htab
operator|->
name|glink
operator|->
name|size
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PPC_GOT
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|relocs
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELA
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELASZ
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELAENT
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* If any dynamic relocs apply to a read-only section, then we 	 need a DT_TEXTREL entry.  */
if|if
condition|(
operator|(
name|info
operator|->
name|flags
operator|&
name|DF_TEXTREL
operator|)
operator|==
literal|0
condition|)
name|elf_link_hash_traverse
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|readonly_dynrelocs
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|info
operator|->
name|flags
operator|&
name|DF_TEXTREL
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_TEXTREL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
undef|#
directive|undef
name|add_dynamic_entry
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|ARRAY_SIZE
parameter_list|(
name|a
parameter_list|)
value|(sizeof (a) / sizeof ((a)[0]))
end_define

begin_decl_stmt
specifier|static
specifier|const
name|int
name|shared_stub_entry
index|[]
init|=
block|{
literal|0x7c0802a6
block|,
comment|/* mflr 0 */
literal|0x429f0005
block|,
comment|/* bcl 20, 31, .Lxxx */
literal|0x7d6802a6
block|,
comment|/* mflr 11 */
literal|0x3d6b0000
block|,
comment|/* addis 11, 11, (xxx-.Lxxx)@ha */
literal|0x396b0018
block|,
comment|/* addi 11, 11, (xxx-.Lxxx)@l */
literal|0x7c0803a6
block|,
comment|/* mtlr 0 */
literal|0x7d6903a6
block|,
comment|/* mtctr 11 */
literal|0x4e800420
block|,
comment|/* bctr */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|int
name|stub_entry
index|[]
init|=
block|{
literal|0x3d600000
block|,
comment|/* lis 11,xxx@ha */
literal|0x396b0000
block|,
comment|/* addi 11,11,xxx@l */
literal|0x7d6903a6
block|,
comment|/* mtctr 11 */
literal|0x4e800420
block|,
comment|/* bctr */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|bfd_boolean
name|ppc_elf_relax_section
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|isec
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
parameter_list|,
name|bfd_boolean
modifier|*
name|again
parameter_list|)
block|{
struct|struct
name|one_fixup
block|{
name|struct
name|one_fixup
modifier|*
name|next
decl_stmt|;
name|asection
modifier|*
name|tsec
decl_stmt|;
name|bfd_vma
name|toff
decl_stmt|;
name|bfd_vma
name|trampoff
decl_stmt|;
block|}
struct|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymbuf
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|,
modifier|*
name|irelend
decl_stmt|;
name|struct
name|one_fixup
modifier|*
name|fixups
init|=
name|NULL
decl_stmt|;
name|bfd_boolean
name|changed
decl_stmt|;
name|struct
name|ppc_elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|bfd_size_type
name|trampoff
decl_stmt|;
name|asection
modifier|*
name|got2
decl_stmt|;
operator|*
name|again
operator|=
name|FALSE
expr_stmt|;
comment|/* Nothing to do if there are no relocations, and no need to do      anything with non-alloc sections.  */
if|if
condition|(
operator|(
name|isec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|==
literal|0
operator|||
operator|(
name|isec
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
operator|||
name|isec
operator|->
name|reloc_count
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
name|trampoff
operator|=
operator|(
name|isec
operator|->
name|size
operator|+
literal|3
operator|)
operator|&
operator|(
name|bfd_vma
operator|)
operator|-
literal|4
expr_stmt|;
comment|/* Space for a branch around any trampolines.  */
name|trampoff
operator|+=
literal|4
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
comment|/* Get a copy of the native relocations.  */
name|internal_relocs
operator|=
name|_bfd_elf_link_read_relocs
argument_list|(
name|abfd
argument_list|,
name|isec
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|link_info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|htab
operator|=
name|ppc_elf_hash_table
argument_list|(
name|link_info
argument_list|)
expr_stmt|;
name|got2
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".got2"
argument_list|)
expr_stmt|;
name|irelend
operator|=
name|internal_relocs
operator|+
name|isec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|irel
operator|=
name|internal_relocs
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
control|)
block|{
name|unsigned
name|long
name|r_type
init|=
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
decl_stmt|;
name|bfd_vma
name|symaddr
decl_stmt|,
name|reladdr
decl_stmt|,
name|toff
decl_stmt|,
name|roff
decl_stmt|;
name|asection
modifier|*
name|tsec
decl_stmt|;
name|struct
name|one_fixup
modifier|*
name|f
decl_stmt|;
name|size_t
name|insn_offset
init|=
literal|0
decl_stmt|;
name|bfd_vma
name|max_branch_offset
decl_stmt|,
name|val
decl_stmt|;
name|bfd_byte
modifier|*
name|hit_addr
decl_stmt|;
name|unsigned
name|long
name|t0
decl_stmt|;
name|unsigned
name|char
name|sym_type
decl_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_PPC_REL24
case|:
case|case
name|R_PPC_LOCAL24PC
case|:
case|case
name|R_PPC_PLTREL24
case|:
name|max_branch_offset
operator|=
literal|1
operator|<<
literal|25
expr_stmt|;
break|break;
case|case
name|R_PPC_REL14
case|:
case|case
name|R_PPC_REL14_BRTAKEN
case|:
case|case
name|R_PPC_REL14_BRNTAKEN
case|:
name|max_branch_offset
operator|=
literal|1
operator|<<
literal|15
expr_stmt|;
break|break;
default|default:
continue|continue;
block|}
comment|/* Get the value of the symbol referred to by the reloc.  */
if|if
condition|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
comment|/* A local symbol.  */
name|Elf_Internal_Sym
modifier|*
name|isym
decl_stmt|;
comment|/* Read this BFD's local symbols.  */
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
block|{
name|isymbuf
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
name|isymbuf
operator|=
name|bfd_elf_get_elf_syms
argument_list|(
name|abfd
argument_list|,
name|symtab_hdr
argument_list|,
name|symtab_hdr
operator|->
name|sh_info
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
literal|0
condition|)
goto|goto
name|error_return
goto|;
block|}
name|isym
operator|=
name|isymbuf
operator|+
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_UNDEF
condition|)
continue|continue;
comment|/* We can't do anything with undefined symbols.  */
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_ABS
condition|)
name|tsec
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_COMMON
condition|)
name|tsec
operator|=
name|bfd_com_section_ptr
expr_stmt|;
else|else
name|tsec
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|abfd
argument_list|,
name|isym
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
name|toff
operator|=
name|isym
operator|->
name|st_value
expr_stmt|;
name|sym_type
operator|=
name|ELF_ST_TYPE
argument_list|(
name|isym
operator|->
name|st_info
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Global symbol handling.  */
name|unsigned
name|long
name|indx
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|indx
operator|=
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|-
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|h
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
index|[
name|indx
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|tsec
operator|=
name|NULL
expr_stmt|;
name|toff
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_PPC_PLTREL24
operator|&&
name|htab
operator|->
name|plt
operator|!=
name|NULL
condition|)
block|{
name|struct
name|plt_entry
modifier|*
name|ent
init|=
name|find_plt_ent
argument_list|(
name|h
argument_list|,
name|got2
argument_list|,
name|irel
operator|->
name|r_addend
argument_list|)
decl_stmt|;
if|if
condition|(
name|ent
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|htab
operator|->
name|plt_type
operator|==
name|PLT_NEW
condition|)
block|{
name|tsec
operator|=
name|htab
operator|->
name|glink
expr_stmt|;
name|toff
operator|=
name|ent
operator|->
name|glink_offset
expr_stmt|;
block|}
else|else
block|{
name|tsec
operator|=
name|htab
operator|->
name|plt
expr_stmt|;
name|toff
operator|=
name|ent
operator|->
name|plt
operator|.
name|offset
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|tsec
operator|!=
name|NULL
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
block|{
name|tsec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|toff
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
block|}
else|else
continue|continue;
name|sym_type
operator|=
name|h
operator|->
name|type
expr_stmt|;
block|}
comment|/* If the branch and target are in the same section, you have 	 no hope of adding stubs.  We'll error out later should the 	 branch overflow.  */
if|if
condition|(
name|tsec
operator|==
name|isec
condition|)
continue|continue;
comment|/* There probably isn't any reason to handle symbols in 	 SEC_MERGE sections;  SEC_MERGE doesn't seem a likely 	 attribute for a code section, and we are only looking at 	 branches.  However, implement it correctly here as a 	 reference for other target relax_section functions.  */
if|if
condition|(
literal|0
operator|&&
name|tsec
operator|->
name|sec_info_type
operator|==
name|ELF_INFO_TYPE_MERGE
condition|)
block|{
comment|/* At this stage in linking, no SEC_MERGE symbol has been 	     adjusted, so all references to such symbols need to be 	     passed through _bfd_merged_section_offset.  (Later, in 	     relocate_section, all SEC_MERGE symbols *except* for 	     section symbols have been adjusted.)  	     gas may reduce relocations against symbols in SEC_MERGE 	     sections to a relocation against the section symbol when 	     the original addend was zero.  When the reloc is against 	     a section symbol we should include the addend in the 	     offset passed to _bfd_merged_section_offset, since the 	     location of interest is the original symbol.  On the 	     other hand, an access to "sym+addend" where "sym" is not 	     a section symbol should not include the addend;  Such an 	     access is presumed to be an offset from "sym";  The 	     location of interest is just "sym".  */
if|if
condition|(
name|sym_type
operator|==
name|STT_SECTION
condition|)
name|toff
operator|+=
name|irel
operator|->
name|r_addend
expr_stmt|;
name|toff
operator|=
name|_bfd_merged_section_offset
argument_list|(
name|abfd
argument_list|,
operator|&
name|tsec
argument_list|,
name|elf_section_data
argument_list|(
name|tsec
argument_list|)
operator|->
name|sec_info
argument_list|,
name|toff
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_type
operator|!=
name|STT_SECTION
condition|)
name|toff
operator|+=
name|irel
operator|->
name|r_addend
expr_stmt|;
block|}
comment|/* PLTREL24 addends are special.  */
elseif|else
if|if
condition|(
name|r_type
operator|!=
name|R_PPC_PLTREL24
condition|)
name|toff
operator|+=
name|irel
operator|->
name|r_addend
expr_stmt|;
comment|/* Attempted -shared link of non-pic code loses.  */
if|if
condition|(
name|tsec
operator|->
name|output_section
operator|==
name|NULL
condition|)
continue|continue;
name|symaddr
operator|=
name|tsec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|tsec
operator|->
name|output_offset
operator|+
name|toff
expr_stmt|;
name|roff
operator|=
name|irel
operator|->
name|r_offset
expr_stmt|;
name|reladdr
operator|=
name|isec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|isec
operator|->
name|output_offset
operator|+
name|roff
expr_stmt|;
comment|/* If the branch is in range, no need to do anything.  */
if|if
condition|(
name|symaddr
operator|-
name|reladdr
operator|+
name|max_branch_offset
operator|<
literal|2
operator|*
name|max_branch_offset
condition|)
continue|continue;
comment|/* Look for an existing fixup to this address.  */
for|for
control|(
name|f
operator|=
name|fixups
init|;
name|f
condition|;
name|f
operator|=
name|f
operator|->
name|next
control|)
if|if
condition|(
name|f
operator|->
name|tsec
operator|==
name|tsec
operator|&&
name|f
operator|->
name|toff
operator|==
name|toff
condition|)
break|break;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|size_t
name|size
decl_stmt|;
name|unsigned
name|long
name|stub_rtype
decl_stmt|;
name|val
operator|=
name|trampoff
operator|-
name|roff
expr_stmt|;
if|if
condition|(
name|val
operator|>=
name|max_branch_offset
condition|)
comment|/* Oh dear, we can't reach a trampoline.  Don't try to add 	       one.  We'll report an error later.  */
continue|continue;
if|if
condition|(
name|link_info
operator|->
name|shared
condition|)
block|{
name|size
operator|=
literal|4
operator|*
name|ARRAY_SIZE
argument_list|(
name|shared_stub_entry
argument_list|)
expr_stmt|;
name|insn_offset
operator|=
literal|12
expr_stmt|;
name|stub_rtype
operator|=
name|R_PPC_RELAX32PC
expr_stmt|;
block|}
else|else
block|{
name|size
operator|=
literal|4
operator|*
name|ARRAY_SIZE
argument_list|(
name|stub_entry
argument_list|)
expr_stmt|;
name|insn_offset
operator|=
literal|0
expr_stmt|;
name|stub_rtype
operator|=
name|R_PPC_RELAX32
expr_stmt|;
block|}
if|if
condition|(
name|R_PPC_RELAX32_PLT
operator|-
name|R_PPC_RELAX32
operator|!=
name|R_PPC_RELAX32PC_PLT
operator|-
name|R_PPC_RELAX32PC
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|tsec
operator|==
name|htab
operator|->
name|plt
operator|||
name|tsec
operator|==
name|htab
operator|->
name|glink
condition|)
name|stub_rtype
operator|+=
name|R_PPC_RELAX32_PLT
operator|-
name|R_PPC_RELAX32
expr_stmt|;
comment|/* Hijack the old relocation.  Since we need two 	     relocations for this use a "composite" reloc.  */
name|irel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
name|stub_rtype
argument_list|)
expr_stmt|;
name|irel
operator|->
name|r_offset
operator|=
name|trampoff
operator|+
name|insn_offset
expr_stmt|;
comment|/* Record the fixup so we don't do it again this section.  */
name|f
operator|=
name|bfd_malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|f
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|->
name|next
operator|=
name|fixups
expr_stmt|;
name|f
operator|->
name|tsec
operator|=
name|tsec
expr_stmt|;
name|f
operator|->
name|toff
operator|=
name|toff
expr_stmt|;
name|f
operator|->
name|trampoff
operator|=
name|trampoff
expr_stmt|;
name|fixups
operator|=
name|f
expr_stmt|;
name|trampoff
operator|+=
name|size
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
name|f
operator|->
name|trampoff
operator|-
name|roff
expr_stmt|;
if|if
condition|(
name|val
operator|>=
name|max_branch_offset
condition|)
continue|continue;
comment|/* Nop out the reloc, since we're finalizing things here.  */
name|irel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_PPC_NONE
argument_list|)
expr_stmt|;
block|}
comment|/* Get the section contents.  */
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
block|{
comment|/* Get cached copy if it exists.  */
if|if
condition|(
name|elf_section_data
argument_list|(
name|isec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|NULL
condition|)
name|contents
operator|=
name|elf_section_data
argument_list|(
name|isec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
expr_stmt|;
else|else
block|{
comment|/* Go get them off disk.  */
if|if
condition|(
operator|!
name|bfd_malloc_and_get_section
argument_list|(
name|abfd
argument_list|,
name|isec
argument_list|,
operator|&
name|contents
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
block|}
comment|/* Fix up the existing branch to hit the trampoline.  */
name|hit_addr
operator|=
name|contents
operator|+
name|roff
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_PPC_REL24
case|:
case|case
name|R_PPC_LOCAL24PC
case|:
case|case
name|R_PPC_PLTREL24
case|:
name|t0
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|hit_addr
argument_list|)
expr_stmt|;
name|t0
operator|&=
operator|~
literal|0x3fffffc
expr_stmt|;
name|t0
operator||=
name|val
operator|&
literal|0x3fffffc
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|t0
argument_list|,
name|hit_addr
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_PPC_REL14
case|:
case|case
name|R_PPC_REL14_BRTAKEN
case|:
case|case
name|R_PPC_REL14_BRNTAKEN
case|:
name|t0
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|hit_addr
argument_list|)
expr_stmt|;
name|t0
operator|&=
operator|~
literal|0xfffc
expr_stmt|;
name|t0
operator||=
name|val
operator|&
literal|0xfffc
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|t0
argument_list|,
name|hit_addr
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Write out the trampolines.  */
name|changed
operator|=
name|fixups
operator|!=
name|NULL
expr_stmt|;
if|if
condition|(
name|fixups
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|int
modifier|*
name|stub
decl_stmt|;
name|bfd_byte
modifier|*
name|dest
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
name|int
name|i
decl_stmt|,
name|size
decl_stmt|;
do|do
block|{
name|struct
name|one_fixup
modifier|*
name|f
init|=
name|fixups
decl_stmt|;
name|fixups
operator|=
name|fixups
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|fixups
condition|)
do|;
name|contents
operator|=
name|bfd_realloc
argument_list|(
name|contents
argument_list|,
name|trampoff
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|isec
operator|->
name|size
operator|=
operator|(
name|isec
operator|->
name|size
operator|+
literal|3
operator|)
operator|&
operator|(
name|bfd_vma
operator|)
operator|-
literal|4
expr_stmt|;
comment|/* Branch around the trampolines.  */
name|val
operator|=
name|trampoff
operator|-
name|isec
operator|->
name|size
operator|+
literal|0x48000000
expr_stmt|;
name|dest
operator|=
name|contents
operator|+
name|isec
operator|->
name|size
expr_stmt|;
name|isec
operator|->
name|size
operator|=
name|trampoff
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|val
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|dest
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|link_info
operator|->
name|shared
condition|)
block|{
name|stub
operator|=
name|shared_stub_entry
expr_stmt|;
name|size
operator|=
name|ARRAY_SIZE
argument_list|(
name|shared_stub_entry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|stub
operator|=
name|stub_entry
expr_stmt|;
name|size
operator|=
name|ARRAY_SIZE
argument_list|(
name|stub_entry
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|dest
operator|<
name|contents
operator|+
name|trampoff
condition|)
block|{
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|stub
index|[
name|i
index|]
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|size
condition|)
name|i
operator|=
literal|0
expr_stmt|;
name|dest
operator|+=
literal|4
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
name|i
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isymbuf
operator|!=
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
condition|)
block|{
if|if
condition|(
operator|!
name|link_info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|isymbuf
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Cache the symbols for elf_link_input_bfd.  */
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
expr_stmt|;
block|}
block|}
if|if
condition|(
name|contents
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|isec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|contents
condition|)
block|{
if|if
condition|(
operator|!
name|changed
operator|&&
operator|!
name|link_info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Cache the section contents for elf_link_input_bfd.  */
name|elf_section_data
argument_list|(
name|isec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
block|}
block|}
if|if
condition|(
name|elf_section_data
argument_list|(
name|isec
argument_list|)
operator|->
name|relocs
operator|!=
name|internal_relocs
condition|)
block|{
if|if
condition|(
operator|!
name|changed
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
else|else
name|elf_section_data
argument_list|(
name|isec
argument_list|)
operator|->
name|relocs
operator|=
name|internal_relocs
expr_stmt|;
block|}
operator|*
name|again
operator|=
name|changed
expr_stmt|;
return|return
name|TRUE
return|;
name|error_return
label|:
if|if
condition|(
name|isymbuf
operator|!=
name|NULL
operator|&&
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
operator|!=
name|symtab_hdr
operator|->
name|contents
condition|)
name|free
argument_list|(
name|isymbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|isec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|contents
condition|)
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|isec
argument_list|)
operator|->
name|relocs
operator|!=
name|internal_relocs
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* What to do when ld finds relocations against symbols defined in    discarded sections.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|ppc_elf_action_discarded
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
literal|".fixup"
argument_list|,
name|sec
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|strcmp
argument_list|(
literal|".got2"
argument_list|,
name|sec
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|_bfd_elf_default_action_discarded
argument_list|(
name|sec
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Fill in the address for a pointer generated in a linker section.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|elf_finish_pointer_linker_section
parameter_list|(
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|elf_linker_section_t
modifier|*
name|lsect
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|bfd_vma
name|relocation
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
parameter_list|)
block|{
name|elf_linker_section_pointers_t
modifier|*
name|linker_section_ptr
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|lsect
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
comment|/* Handle global symbol.  */
name|struct
name|ppc_elf_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|ppc_elf_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|eh
operator|->
name|elf
operator|.
name|def_regular
argument_list|)
expr_stmt|;
name|linker_section_ptr
operator|=
name|eh
operator|->
name|linker_section_pointer
expr_stmt|;
block|}
else|else
block|{
comment|/* Handle local symbol.  */
name|unsigned
name|long
name|r_symndx
init|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|elf_local_ptr_offsets
argument_list|(
name|input_bfd
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|linker_section_ptr
operator|=
name|elf_local_ptr_offsets
argument_list|(
name|input_bfd
argument_list|)
index|[
name|r_symndx
index|]
expr_stmt|;
block|}
name|linker_section_ptr
operator|=
name|elf_find_pointer_linker_section
argument_list|(
name|linker_section_ptr
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|,
name|lsect
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|linker_section_ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Offset will always be a multiple of four, so use the bottom bit      as a "written" flag.  */
if|if
condition|(
operator|(
name|linker_section_ptr
operator|->
name|offset
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|bfd_put_32
argument_list|(
name|lsect
operator|->
name|section
operator|->
name|owner
argument_list|,
name|relocation
operator|+
name|linker_section_ptr
operator|->
name|addend
argument_list|,
name|lsect
operator|->
name|section
operator|->
name|contents
operator|+
name|linker_section_ptr
operator|->
name|offset
argument_list|)
expr_stmt|;
name|linker_section_ptr
operator|->
name|offset
operator|+=
literal|1
expr_stmt|;
block|}
name|relocation
operator|=
operator|(
name|lsect
operator|->
name|section
operator|->
name|output_offset
operator|+
name|linker_section_ptr
operator|->
name|offset
operator|-
literal|1
operator|-
literal|0x8000
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Finish pointer in linker section %s, offset = %ld (0x%lx)\n"
argument_list|,
name|lsect
operator|->
name|name
argument_list|,
operator|(
name|long
operator|)
name|relocation
argument_list|,
operator|(
name|long
operator|)
name|relocation
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Subtract out the addend, because it will get added back in by the normal      processing.  */
return|return
name|relocation
operator|-
name|linker_section_ptr
operator|->
name|addend
return|;
block|}
end_function

begin_comment
comment|/* The RELOCATE_SECTION function is called by the ELF backend linker    to handle the relocations for a section.     The relocs are always passed as Rela structures; if the section    actually uses Rel structures, the r_addend field will always be    zero.     This function is responsible for adjust the section contents as    necessary, and (if using Rela relocs and generating a    relocatable output file) adjusting the reloc addend as    necessary.     This function does not have to worry about setting the reloc    address or the reloc symbol index.     LOCAL_SYMS is a pointer to the swapped in local symbols.     LOCAL_SECTIONS is an array giving the section in the input file    corresponding to the st_shndx field of each local symbol.     The global hash table entry for the global symbols can be found    via elf_sym_hashes (input_bfd).     When generating relocatable output, this function must handle    STB_LOCAL/STT_SECTION symbols specially.  The output symbol is    going to be the section symbol corresponding to the output    section, which means that the addend must be adjusted    accordingly.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc_elf_relocate_section
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|relocs
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|local_syms
parameter_list|,
name|asection
modifier|*
modifier|*
name|local_sections
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|struct
name|ppc_elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relend
decl_stmt|;
name|Elf_Internal_Rela
name|outrel
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|asection
modifier|*
name|got2
decl_stmt|,
modifier|*
name|sreloc
init|=
name|NULL
decl_stmt|;
name|bfd_vma
modifier|*
name|local_got_offsets
decl_stmt|;
name|bfd_boolean
name|ret
init|=
name|TRUE
decl_stmt|;
name|bfd_vma
name|d_offset
init|=
operator|(
name|bfd_big_endian
argument_list|(
name|output_bfd
argument_list|)
condition|?
literal|2
else|:
literal|0
operator|)
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|_bfd_error_handler
argument_list|(
literal|"ppc_elf_relocate_section called for %B section %A, "
literal|"%ld relocations%s"
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
name|long
operator|)
name|input_section
operator|->
name|reloc_count
argument_list|,
operator|(
name|info
operator|->
name|relocatable
operator|)
condition|?
literal|" (relocatable)"
else|:
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|got2
operator|=
name|bfd_get_section_by_name
argument_list|(
name|input_bfd
argument_list|,
literal|".got2"
argument_list|)
expr_stmt|;
comment|/* Initialize howto table if not already done.  */
if|if
condition|(
operator|!
name|ppc_elf_howto_table
index|[
name|R_PPC_ADDR32
index|]
condition|)
name|ppc_elf_howto_init
argument_list|()
expr_stmt|;
name|htab
operator|=
name|ppc_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|local_got_offsets
operator|=
name|elf_local_got_offsets
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|rel
operator|=
name|relocs
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|input_section
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|enum
name|elf_ppc_reloc_type
name|r_type
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|;
name|bfd_reloc_status_type
name|r
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
specifier|const
name|char
modifier|*
name|sym_name
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_vma
name|branch_bit
decl_stmt|,
name|insn
decl_stmt|,
name|from
decl_stmt|;
name|bfd_boolean
name|unresolved_reloc
decl_stmt|;
name|bfd_boolean
name|warned
decl_stmt|;
name|unsigned
name|int
name|tls_type
decl_stmt|,
name|tls_mask
decl_stmt|,
name|tls_gd
decl_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|sym
operator|=
name|NULL
expr_stmt|;
name|sec
operator|=
name|NULL
expr_stmt|;
name|h
operator|=
name|NULL
expr_stmt|;
name|unresolved_reloc
operator|=
name|FALSE
expr_stmt|;
name|warned
operator|=
name|FALSE
expr_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|sym_name
operator|=
name|bfd_elf_sym_name
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
argument_list|,
name|sym
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|relocation
operator|=
name|_bfd_elf_rela_local_sym
argument_list|(
name|output_bfd
argument_list|,
name|sym
argument_list|,
operator|&
name|sec
argument_list|,
name|rel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|RELOC_FOR_GLOBAL_SYMBOL
argument_list|(
name|info
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
argument_list|,
name|r_symndx
argument_list|,
name|symtab_hdr
argument_list|,
name|sym_hashes
argument_list|,
name|h
argument_list|,
name|sec
argument_list|,
name|relocation
argument_list|,
name|unresolved_reloc
argument_list|,
name|warned
argument_list|)
expr_stmt|;
name|sym_name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
block|}
if|if
condition|(
name|sec
operator|!=
name|NULL
operator|&&
name|elf_discarded_section
argument_list|(
name|sec
argument_list|)
condition|)
block|{
comment|/* For relocs against symbols from removed linkonce sections, 	     or sections discarded by a linker script, we just want the 	     section contents zeroed.  Avoid any special processing.  */
name|howto
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|r_type
operator|<
name|R_PPC_max
condition|)
name|howto
operator|=
name|ppc_elf_howto_table
index|[
name|r_type
index|]
expr_stmt|;
name|_bfd_clear_contents
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|rel
operator|->
name|r_info
operator|=
literal|0
expr_stmt|;
name|rel
operator|->
name|r_addend
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
block|{
if|if
condition|(
name|got2
operator|!=
name|NULL
operator|&&
name|r_type
operator|==
name|R_PPC_PLTREL24
operator|&&
name|rel
operator|->
name|r_addend
operator|>=
literal|32768
condition|)
block|{
comment|/* R_PPC_PLTREL24 is rather special.  If non-zero, the 		 addend specifies the GOT pointer offset within .got2.  */
name|rel
operator|->
name|r_addend
operator|+=
name|got2
operator|->
name|output_offset
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* TLS optimizations.  Replace instruction sequences and relocs 	 based on information we collected in tls_optimize.  We edit 	 RELOCS so that --emit-relocs will output something sensible 	 for the final instruction stream.  */
name|tls_mask
operator|=
literal|0
expr_stmt|;
name|tls_gd
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|IS_PPC_TLS_RELOC
argument_list|(
name|r_type
argument_list|)
condition|)
block|{
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|tls_mask
operator|=
operator|(
operator|(
expr|struct
name|ppc_elf_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|tls_mask
expr_stmt|;
elseif|else
if|if
condition|(
name|local_got_offsets
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|lgot_masks
decl_stmt|;
name|lgot_masks
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|local_got_offsets
operator|+
name|symtab_hdr
operator|->
name|sh_info
operator|)
expr_stmt|;
name|tls_mask
operator|=
name|lgot_masks
index|[
name|r_symndx
index|]
expr_stmt|;
block|}
block|}
comment|/* Ensure reloc mapping code below stays sane.  */
if|if
condition|(
operator|(
name|R_PPC_GOT_TLSLD16
operator|&
literal|3
operator|)
operator|!=
operator|(
name|R_PPC_GOT_TLSGD16
operator|&
literal|3
operator|)
operator|||
operator|(
name|R_PPC_GOT_TLSLD16_LO
operator|&
literal|3
operator|)
operator|!=
operator|(
name|R_PPC_GOT_TLSGD16_LO
operator|&
literal|3
operator|)
operator|||
operator|(
name|R_PPC_GOT_TLSLD16_HI
operator|&
literal|3
operator|)
operator|!=
operator|(
name|R_PPC_GOT_TLSGD16_HI
operator|&
literal|3
operator|)
operator|||
operator|(
name|R_PPC_GOT_TLSLD16_HA
operator|&
literal|3
operator|)
operator|!=
operator|(
name|R_PPC_GOT_TLSGD16_HA
operator|&
literal|3
operator|)
operator|||
operator|(
name|R_PPC_GOT_TLSLD16
operator|&
literal|3
operator|)
operator|!=
operator|(
name|R_PPC_GOT_TPREL16
operator|&
literal|3
operator|)
operator|||
operator|(
name|R_PPC_GOT_TLSLD16_LO
operator|&
literal|3
operator|)
operator|!=
operator|(
name|R_PPC_GOT_TPREL16_LO
operator|&
literal|3
operator|)
operator|||
operator|(
name|R_PPC_GOT_TLSLD16_HI
operator|&
literal|3
operator|)
operator|!=
operator|(
name|R_PPC_GOT_TPREL16_HI
operator|&
literal|3
operator|)
operator|||
operator|(
name|R_PPC_GOT_TLSLD16_HA
operator|&
literal|3
operator|)
operator|!=
operator|(
name|R_PPC_GOT_TPREL16_HA
operator|&
literal|3
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
default|default:
break|break;
case|case
name|R_PPC_GOT_TPREL16
case|:
case|case
name|R_PPC_GOT_TPREL16_LO
case|:
if|if
condition|(
name|tls_mask
operator|!=
literal|0
operator|&&
operator|(
name|tls_mask
operator|&
name|TLS_TPREL
operator|)
operator|==
literal|0
condition|)
block|{
name|bfd_vma
name|insn
decl_stmt|;
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|output_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|-
name|d_offset
argument_list|)
expr_stmt|;
name|insn
operator|&=
literal|31
operator|<<
literal|21
expr_stmt|;
name|insn
operator||=
literal|0x3c020000
expr_stmt|;
comment|/* addis 0,2,0 */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|insn
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|-
name|d_offset
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|R_PPC_TPREL16_HA
expr_stmt|;
name|rel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|r_symndx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|R_PPC_TLS
case|:
if|if
condition|(
name|tls_mask
operator|!=
literal|0
operator|&&
operator|(
name|tls_mask
operator|&
name|TLS_TPREL
operator|)
operator|==
literal|0
condition|)
block|{
name|bfd_vma
name|insn
decl_stmt|,
name|rtra
decl_stmt|;
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|output_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|insn
operator|&
operator|(
operator|(
literal|31
operator|<<
literal|26
operator|)
operator||
operator|(
literal|31
operator|<<
literal|11
operator|)
operator|)
operator|)
operator|==
operator|(
operator|(
literal|31
operator|<<
literal|26
operator|)
operator||
operator|(
literal|2
operator|<<
literal|11
operator|)
operator|)
condition|)
name|rtra
operator|=
name|insn
operator|&
operator|(
operator|(
literal|1
operator|<<
literal|26
operator|)
operator|-
operator|(
literal|1
operator|<<
literal|16
operator|)
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
operator|(
operator|(
literal|31
operator|<<
literal|26
operator|)
operator||
operator|(
literal|31
operator|<<
literal|16
operator|)
operator|)
operator|)
operator|==
operator|(
operator|(
literal|31
operator|<<
literal|26
operator|)
operator||
operator|(
literal|2
operator|<<
literal|16
operator|)
operator|)
condition|)
name|rtra
operator|=
operator|(
name|insn
operator|&
operator|(
literal|31
operator|<<
literal|21
operator|)
operator|)
operator||
operator|(
operator|(
name|insn
operator|&
operator|(
literal|31
operator|<<
literal|11
operator|)
operator|)
operator|<<
literal|5
operator|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|insn
operator|&
operator|(
operator|(
literal|1
operator|<<
literal|11
operator|)
operator|-
operator|(
literal|1
operator|<<
literal|1
operator|)
operator|)
operator|)
operator|==
literal|266
operator|<<
literal|1
condition|)
comment|/* add -> addi.  */
name|insn
operator|=
literal|14
operator|<<
literal|26
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
operator|(
literal|31
operator|<<
literal|1
operator|)
operator|)
operator|==
literal|23
operator|<<
literal|1
operator|&&
operator|(
operator|(
name|insn
operator|&
operator|(
literal|31
operator|<<
literal|6
operator|)
operator|)
operator|<
literal|14
operator|<<
literal|6
operator|||
operator|(
operator|(
name|insn
operator|&
operator|(
literal|31
operator|<<
literal|6
operator|)
operator|)
operator|>=
literal|16
operator|<<
literal|6
operator|&&
operator|(
name|insn
operator|&
operator|(
literal|31
operator|<<
literal|6
operator|)
operator|)
operator|<
literal|24
operator|<<
literal|6
operator|)
operator|)
condition|)
comment|/* load and store indexed -> dform.  */
name|insn
operator|=
operator|(
literal|32
operator||
operator|(
operator|(
name|insn
operator|>>
literal|6
operator|)
operator|&
literal|31
operator|)
operator|)
operator|<<
literal|26
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
operator|(
literal|31
operator|<<
literal|1
operator|)
operator|)
operator|==
literal|21
operator|<<
literal|1
operator|&&
operator|(
name|insn
operator|&
operator|(
literal|0x1a
operator|<<
literal|6
operator|)
operator|)
operator|==
literal|0
condition|)
comment|/* ldx, ldux, stdx, stdux -> ld, ldu, std, stdu.  */
name|insn
operator|=
operator|(
operator|(
operator|(
literal|58
operator||
operator|(
operator|(
name|insn
operator|>>
literal|6
operator|)
operator|&
literal|4
operator|)
operator|)
operator|<<
literal|26
operator|)
operator||
operator|(
operator|(
name|insn
operator|>>
literal|6
operator|)
operator|&
literal|1
operator|)
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
operator|(
literal|31
operator|<<
literal|1
operator|)
operator|)
operator|==
literal|21
operator|<<
literal|1
operator|&&
operator|(
name|insn
operator|&
operator|(
operator|(
literal|1
operator|<<
literal|11
operator|)
operator|-
operator|(
literal|1
operator|<<
literal|1
operator|)
operator|)
operator|)
operator|==
literal|341
operator|<<
literal|1
condition|)
comment|/* lwax -> lwa.  */
name|insn
operator|=
operator|(
literal|58
operator|<<
literal|26
operator|)
operator||
literal|2
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|insn
operator||=
name|rtra
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|insn
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|R_PPC_TPREL16_LO
expr_stmt|;
name|rel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|r_symndx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
comment|/* Was PPC_TLS which sits on insn boundary, now 		 PPC_TPREL16_LO which is at low-order half-word.  */
name|rel
operator|->
name|r_offset
operator|+=
name|d_offset
expr_stmt|;
block|}
break|break;
case|case
name|R_PPC_GOT_TLSGD16_HI
case|:
case|case
name|R_PPC_GOT_TLSGD16_HA
case|:
name|tls_gd
operator|=
name|TLS_TPRELGD
expr_stmt|;
if|if
condition|(
name|tls_mask
operator|!=
literal|0
operator|&&
operator|(
name|tls_mask
operator|&
name|TLS_GD
operator|)
operator|==
literal|0
condition|)
goto|goto
name|tls_gdld_hi
goto|;
break|break;
case|case
name|R_PPC_GOT_TLSLD16_HI
case|:
case|case
name|R_PPC_GOT_TLSLD16_HA
case|:
if|if
condition|(
name|tls_mask
operator|!=
literal|0
operator|&&
operator|(
name|tls_mask
operator|&
name|TLS_LD
operator|)
operator|==
literal|0
condition|)
block|{
name|tls_gdld_hi
label|:
if|if
condition|(
operator|(
name|tls_mask
operator|&
name|tls_gd
operator|)
operator|!=
literal|0
condition|)
name|r_type
operator|=
operator|(
operator|(
operator|(
name|r_type
operator|-
operator|(
name|R_PPC_GOT_TLSGD16
operator|&
literal|3
operator|)
operator|)
operator|&
literal|3
operator|)
operator|+
name|R_PPC_GOT_TPREL16
operator|)
expr_stmt|;
else|else
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|NOP
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|rel
operator|->
name|r_offset
operator|-=
name|d_offset
expr_stmt|;
name|r_type
operator|=
name|R_PPC_NONE
expr_stmt|;
block|}
name|rel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|r_symndx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|R_PPC_GOT_TLSGD16
case|:
case|case
name|R_PPC_GOT_TLSGD16_LO
case|:
name|tls_gd
operator|=
name|TLS_TPRELGD
expr_stmt|;
if|if
condition|(
name|tls_mask
operator|!=
literal|0
operator|&&
operator|(
name|tls_mask
operator|&
name|TLS_GD
operator|)
operator|==
literal|0
condition|)
goto|goto
name|tls_get_addr_check
goto|;
break|break;
case|case
name|R_PPC_GOT_TLSLD16
case|:
case|case
name|R_PPC_GOT_TLSLD16_LO
case|:
if|if
condition|(
name|tls_mask
operator|!=
literal|0
operator|&&
operator|(
name|tls_mask
operator|&
name|TLS_LD
operator|)
operator|==
literal|0
condition|)
block|{
name|tls_get_addr_check
label|:
if|if
condition|(
name|rel
operator|+
literal|1
operator|<
name|relend
condition|)
block|{
name|enum
name|elf_ppc_reloc_type
name|r_type2
decl_stmt|;
name|unsigned
name|long
name|r_symndx2
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h2
decl_stmt|;
name|bfd_vma
name|insn1
decl_stmt|,
name|insn2
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
comment|/* The next instruction should be a call to 		     __tls_get_addr.  Peek at the reloc to be sure.  */
name|r_type2
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
index|[
literal|1
index|]
operator|.
name|r_info
argument_list|)
expr_stmt|;
name|r_symndx2
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
index|[
literal|1
index|]
operator|.
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx2
operator|<
name|symtab_hdr
operator|->
name|sh_info
operator|||
operator|(
name|r_type2
operator|!=
name|R_PPC_REL14
operator|&&
name|r_type2
operator|!=
name|R_PPC_REL14_BRTAKEN
operator|&&
name|r_type2
operator|!=
name|R_PPC_REL14_BRNTAKEN
operator|&&
name|r_type2
operator|!=
name|R_PPC_REL24
operator|&&
name|r_type2
operator|!=
name|R_PPC_PLTREL24
operator|)
condition|)
break|break;
name|h2
operator|=
name|sym_hashes
index|[
name|r_symndx2
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
while|while
condition|(
name|h2
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h2
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h2
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h2
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|h2
operator|==
name|NULL
operator|||
name|h2
operator|!=
name|htab
operator|->
name|tls_get_addr
condition|)
break|break;
comment|/* OK, it checks out.  Replace the call.  */
name|offset
operator|=
name|rel
index|[
literal|1
index|]
operator|.
name|r_offset
expr_stmt|;
name|insn1
operator|=
name|bfd_get_32
argument_list|(
name|output_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|-
name|d_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tls_mask
operator|&
name|tls_gd
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* IE */
name|insn1
operator|&=
operator|(
literal|1
operator|<<
literal|26
operator|)
operator|-
literal|1
expr_stmt|;
name|insn1
operator||=
literal|32
operator|<<
literal|26
expr_stmt|;
comment|/* lwz */
name|insn2
operator|=
literal|0x7c631214
expr_stmt|;
comment|/* add 3,3,2 */
name|rel
index|[
literal|1
index|]
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|r_symndx2
argument_list|,
name|R_PPC_NONE
argument_list|)
expr_stmt|;
name|rel
index|[
literal|1
index|]
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
name|r_type
operator|=
operator|(
operator|(
operator|(
name|r_type
operator|-
operator|(
name|R_PPC_GOT_TLSGD16
operator|&
literal|3
operator|)
operator|)
operator|&
literal|3
operator|)
operator|+
name|R_PPC_GOT_TPREL16
operator|)
expr_stmt|;
name|rel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|r_symndx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* LE */
name|insn1
operator|=
literal|0x3c620000
expr_stmt|;
comment|/* addis 3,2,0 */
name|insn2
operator|=
literal|0x38630000
expr_stmt|;
comment|/* addi 3,3,0 */
if|if
condition|(
name|tls_gd
operator|==
literal|0
condition|)
block|{
comment|/* Was an LD reloc.  */
name|r_symndx
operator|=
literal|0
expr_stmt|;
name|rel
operator|->
name|r_addend
operator|=
name|htab
operator|->
name|elf
operator|.
name|tls_sec
operator|->
name|vma
operator|+
name|DTP_OFFSET
expr_stmt|;
block|}
name|r_type
operator|=
name|R_PPC_TPREL16_HA
expr_stmt|;
name|rel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|r_symndx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
name|rel
index|[
literal|1
index|]
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|r_symndx
argument_list|,
name|R_PPC_TPREL16_LO
argument_list|)
expr_stmt|;
name|rel
index|[
literal|1
index|]
operator|.
name|r_offset
operator|+=
name|d_offset
expr_stmt|;
name|rel
index|[
literal|1
index|]
operator|.
name|r_addend
operator|=
name|rel
operator|->
name|r_addend
expr_stmt|;
block|}
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|insn1
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|-
name|d_offset
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|insn2
argument_list|,
name|contents
operator|+
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|tls_gd
operator|==
literal|0
condition|)
block|{
comment|/* We changed the symbol on an LD reloc.  Start over 			 in order to get h, sym, sec etc. right.  */
name|rel
operator|--
expr_stmt|;
continue|continue;
block|}
block|}
block|}
break|break;
block|}
comment|/* Handle other relocations that tweak non-addend part of insn.  */
name|branch_bit
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
default|default:
break|break;
comment|/* Branch taken prediction relocations.  */
case|case
name|R_PPC_ADDR14_BRTAKEN
case|:
case|case
name|R_PPC_REL14_BRTAKEN
case|:
name|branch_bit
operator|=
name|BRANCH_PREDICT_BIT
expr_stmt|;
comment|/* Fall thru */
comment|/* Branch not taken prediction relocations.  */
case|case
name|R_PPC_ADDR14_BRNTAKEN
case|:
case|case
name|R_PPC_REL14_BRNTAKEN
case|:
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|output_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|insn
operator|&=
operator|~
name|BRANCH_PREDICT_BIT
expr_stmt|;
name|insn
operator||=
name|branch_bit
expr_stmt|;
name|from
operator|=
operator|(
name|rel
operator|->
name|r_offset
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
comment|/* Invert 'y' bit if not the default.  */
if|if
condition|(
call|(
name|bfd_signed_vma
call|)
argument_list|(
name|relocation
operator|+
name|rel
operator|->
name|r_addend
operator|-
name|from
argument_list|)
operator|<
literal|0
condition|)
name|insn
operator|^=
name|BRANCH_PREDICT_BIT
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|insn
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
break|break;
block|}
name|addend
operator|=
name|rel
operator|->
name|r_addend
expr_stmt|;
name|tls_type
operator|=
literal|0
expr_stmt|;
name|howto
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|r_type
operator|<
name|R_PPC_max
condition|)
name|howto
operator|=
name|ppc_elf_howto_table
index|[
name|r_type
index|]
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
default|default:
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: unknown relocation type %d for symbol %s"
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
operator|(
name|int
operator|)
name|r_type
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
name|ret
operator|=
name|FALSE
expr_stmt|;
continue|continue;
case|case
name|R_PPC_NONE
case|:
case|case
name|R_PPC_TLS
case|:
case|case
name|R_PPC_EMB_MRKREF
case|:
case|case
name|R_PPC_GNU_VTINHERIT
case|:
case|case
name|R_PPC_GNU_VTENTRY
case|:
continue|continue;
comment|/* GOT16 relocations.  Like an ADDR16 using the symbol's 	     address in the GOT as relocation value instead of the 	     symbol's value itself.  Also, create a GOT entry for the 	     symbol and put the symbol value there.  */
case|case
name|R_PPC_GOT_TLSGD16
case|:
case|case
name|R_PPC_GOT_TLSGD16_LO
case|:
case|case
name|R_PPC_GOT_TLSGD16_HI
case|:
case|case
name|R_PPC_GOT_TLSGD16_HA
case|:
name|tls_type
operator|=
name|TLS_TLS
operator||
name|TLS_GD
expr_stmt|;
goto|goto
name|dogot
goto|;
case|case
name|R_PPC_GOT_TLSLD16
case|:
case|case
name|R_PPC_GOT_TLSLD16_LO
case|:
case|case
name|R_PPC_GOT_TLSLD16_HI
case|:
case|case
name|R_PPC_GOT_TLSLD16_HA
case|:
name|tls_type
operator|=
name|TLS_TLS
operator||
name|TLS_LD
expr_stmt|;
goto|goto
name|dogot
goto|;
case|case
name|R_PPC_GOT_TPREL16
case|:
case|case
name|R_PPC_GOT_TPREL16_LO
case|:
case|case
name|R_PPC_GOT_TPREL16_HI
case|:
case|case
name|R_PPC_GOT_TPREL16_HA
case|:
name|tls_type
operator|=
name|TLS_TLS
operator||
name|TLS_TPREL
expr_stmt|;
goto|goto
name|dogot
goto|;
case|case
name|R_PPC_GOT_DTPREL16
case|:
case|case
name|R_PPC_GOT_DTPREL16_LO
case|:
case|case
name|R_PPC_GOT_DTPREL16_HI
case|:
case|case
name|R_PPC_GOT_DTPREL16_HA
case|:
name|tls_type
operator|=
name|TLS_TLS
operator||
name|TLS_DTPREL
expr_stmt|;
goto|goto
name|dogot
goto|;
case|case
name|R_PPC_GOT16
case|:
case|case
name|R_PPC_GOT16_LO
case|:
case|case
name|R_PPC_GOT16_HI
case|:
case|case
name|R_PPC_GOT16_HA
case|:
name|dogot
label|:
block|{
comment|/* Relocation is to the entry for this symbol in the global 	       offset table.  */
name|bfd_vma
name|off
decl_stmt|;
name|bfd_vma
modifier|*
name|offp
decl_stmt|;
name|unsigned
name|long
name|indx
decl_stmt|;
if|if
condition|(
name|htab
operator|->
name|got
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|indx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tls_type
operator|==
operator|(
name|TLS_TLS
operator||
name|TLS_LD
operator|)
operator|&&
operator|(
name|h
operator|==
name|NULL
operator|||
operator|!
name|h
operator|->
name|def_dynamic
operator|)
condition|)
name|offp
operator|=
operator|&
name|htab
operator|->
name|tlsld_got
operator|.
name|offset
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|bfd_boolean
name|dyn
decl_stmt|;
name|dyn
operator|=
name|htab
operator|->
name|elf
operator|.
name|dynamic_sections_created
expr_stmt|;
if|if
condition|(
operator|!
name|WILL_CALL_FINISH_DYNAMIC_SYMBOL
argument_list|(
name|dyn
argument_list|,
name|info
operator|->
name|shared
argument_list|,
name|h
argument_list|)
operator|||
operator|(
name|info
operator|->
name|shared
operator|&&
name|SYMBOL_REFERENCES_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
operator|)
condition|)
comment|/* This is actually a static link, or it is a 		     -Bsymbolic link and the symbol is defined 		     locally, or the symbol was forced to be local 		     because of a version file.  */
empty_stmt|;
else|else
block|{
name|indx
operator|=
name|h
operator|->
name|dynindx
expr_stmt|;
name|unresolved_reloc
operator|=
name|FALSE
expr_stmt|;
block|}
name|offp
operator|=
operator|&
name|h
operator|->
name|got
operator|.
name|offset
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|local_got_offsets
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|offp
operator|=
operator|&
name|local_got_offsets
index|[
name|r_symndx
index|]
expr_stmt|;
block|}
comment|/* The offset must always be a multiple of 4.  We use the 	       least significant bit to record whether we have already 	       processed this entry.  */
name|off
operator|=
operator|*
name|offp
expr_stmt|;
if|if
condition|(
operator|(
name|off
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|off
operator|&=
operator|~
literal|1
expr_stmt|;
else|else
block|{
name|unsigned
name|int
name|tls_m
init|=
operator|(
name|tls_mask
operator|&
operator|(
name|TLS_LD
operator||
name|TLS_GD
operator||
name|TLS_DTPREL
operator||
name|TLS_TPREL
operator||
name|TLS_TPRELGD
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|offp
operator|==
operator|&
name|htab
operator|->
name|tlsld_got
operator|.
name|offset
condition|)
name|tls_m
operator|=
name|TLS_LD
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
operator|!
name|h
operator|->
name|def_dynamic
condition|)
name|tls_m
operator|&=
operator|~
name|TLS_LD
expr_stmt|;
comment|/* We might have multiple got entries for this sym. 		   Initialize them all.  */
do|do
block|{
name|int
name|tls_ty
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|tls_m
operator|&
name|TLS_LD
operator|)
operator|!=
literal|0
condition|)
block|{
name|tls_ty
operator|=
name|TLS_TLS
operator||
name|TLS_LD
expr_stmt|;
name|tls_m
operator|&=
operator|~
name|TLS_LD
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|tls_m
operator|&
name|TLS_GD
operator|)
operator|!=
literal|0
condition|)
block|{
name|tls_ty
operator|=
name|TLS_TLS
operator||
name|TLS_GD
expr_stmt|;
name|tls_m
operator|&=
operator|~
name|TLS_GD
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|tls_m
operator|&
name|TLS_DTPREL
operator|)
operator|!=
literal|0
condition|)
block|{
name|tls_ty
operator|=
name|TLS_TLS
operator||
name|TLS_DTPREL
expr_stmt|;
name|tls_m
operator|&=
operator|~
name|TLS_DTPREL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|tls_m
operator|&
operator|(
name|TLS_TPREL
operator||
name|TLS_TPRELGD
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|tls_ty
operator|=
name|TLS_TLS
operator||
name|TLS_TPREL
expr_stmt|;
name|tls_m
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Generate relocs for the dynamic linker.  */
if|if
condition|(
operator|(
name|info
operator|->
name|shared
operator|||
name|indx
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|h
operator|==
name|NULL
operator|||
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_DEFAULT
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefweak
operator|)
condition|)
block|{
name|outrel
operator|.
name|r_offset
operator|=
operator|(
name|htab
operator|->
name|got
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|got
operator|->
name|output_offset
operator|+
name|off
operator|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tls_ty
operator|&
operator|(
name|TLS_LD
operator||
name|TLS_GD
operator|)
condition|)
block|{
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|indx
argument_list|,
name|R_PPC_DTPMOD32
argument_list|)
expr_stmt|;
if|if
condition|(
name|tls_ty
operator|==
operator|(
name|TLS_TLS
operator||
name|TLS_GD
operator|)
condition|)
block|{
name|loc
operator|=
name|htab
operator|->
name|relgot
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
operator|(
name|htab
operator|->
name|relgot
operator|->
name|reloc_count
operator|++
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
operator|)
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|+=
literal|4
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|indx
argument_list|,
name|R_PPC_DTPREL32
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|tls_ty
operator|==
operator|(
name|TLS_TLS
operator||
name|TLS_DTPREL
operator|)
condition|)
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|indx
argument_list|,
name|R_PPC_DTPREL32
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tls_ty
operator|==
operator|(
name|TLS_TLS
operator||
name|TLS_TPREL
operator|)
condition|)
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|indx
argument_list|,
name|R_PPC_TPREL32
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|indx
operator|==
literal|0
condition|)
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|indx
argument_list|,
name|R_PPC_RELATIVE
argument_list|)
expr_stmt|;
else|else
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|indx
argument_list|,
name|R_PPC_GLOB_DAT
argument_list|)
expr_stmt|;
if|if
condition|(
name|indx
operator|==
literal|0
condition|)
block|{
name|outrel
operator|.
name|r_addend
operator|+=
name|relocation
expr_stmt|;
if|if
condition|(
name|tls_ty
operator|&
operator|(
name|TLS_GD
operator||
name|TLS_DTPREL
operator||
name|TLS_TPREL
operator|)
condition|)
name|outrel
operator|.
name|r_addend
operator|-=
name|htab
operator|->
name|elf
operator|.
name|tls_sec
operator|->
name|vma
expr_stmt|;
block|}
name|loc
operator|=
name|htab
operator|->
name|relgot
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
operator|(
name|htab
operator|->
name|relgot
operator|->
name|reloc_count
operator|++
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
operator|)
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
comment|/* Init the .got section contents if we're not 		       emitting a reloc.  */
else|else
block|{
name|bfd_vma
name|value
init|=
name|relocation
decl_stmt|;
if|if
condition|(
name|tls_ty
operator|==
operator|(
name|TLS_TLS
operator||
name|TLS_LD
operator|)
condition|)
name|value
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|tls_ty
operator|!=
literal|0
condition|)
block|{
name|value
operator|-=
name|htab
operator|->
name|elf
operator|.
name|tls_sec
operator|->
name|vma
operator|+
name|DTP_OFFSET
expr_stmt|;
if|if
condition|(
name|tls_ty
operator|==
operator|(
name|TLS_TLS
operator||
name|TLS_TPREL
operator|)
condition|)
name|value
operator|+=
name|DTP_OFFSET
operator|-
name|TP_OFFSET
expr_stmt|;
if|if
condition|(
name|tls_ty
operator|==
operator|(
name|TLS_TLS
operator||
name|TLS_GD
operator|)
condition|)
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|value
argument_list|,
name|htab
operator|->
name|got
operator|->
name|contents
operator|+
name|off
operator|+
literal|4
argument_list|)
expr_stmt|;
name|value
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|value
argument_list|,
name|htab
operator|->
name|got
operator|->
name|contents
operator|+
name|off
argument_list|)
expr_stmt|;
block|}
name|off
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|tls_ty
operator|&
operator|(
name|TLS_LD
operator||
name|TLS_GD
operator|)
condition|)
name|off
operator|+=
literal|4
expr_stmt|;
block|}
do|while
condition|(
name|tls_m
operator|!=
literal|0
condition|)
do|;
name|off
operator|=
operator|*
name|offp
expr_stmt|;
operator|*
name|offp
operator|=
name|off
operator||
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|off
operator|>=
operator|(
name|bfd_vma
operator|)
operator|-
literal|2
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|tls_type
operator|&
name|TLS_TLS
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|tls_type
operator|!=
operator|(
name|TLS_TLS
operator||
name|TLS_LD
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|tls_mask
operator|&
name|TLS_LD
operator|)
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|h
operator|==
name|NULL
operator|||
operator|!
name|h
operator|->
name|def_dynamic
operator|)
condition|)
name|off
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
name|tls_type
operator|!=
operator|(
name|TLS_TLS
operator||
name|TLS_GD
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|tls_mask
operator|&
name|TLS_GD
operator|)
operator|!=
literal|0
condition|)
name|off
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
name|tls_type
operator|!=
operator|(
name|TLS_TLS
operator||
name|TLS_DTPREL
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|tls_mask
operator|&
name|TLS_DTPREL
operator|)
operator|!=
literal|0
condition|)
name|off
operator|+=
literal|4
expr_stmt|;
block|}
block|}
block|}
block|}
name|relocation
operator|=
name|htab
operator|->
name|got
operator|->
name|output_offset
operator|+
name|off
expr_stmt|;
name|relocation
operator|-=
name|htab
operator|->
name|elf
operator|.
name|hgot
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
comment|/* Addends on got relocations don't make much sense. 	       x+off@got is actually x@got+off, and since the got is 	       generated by a hash table traversal, the value in the 	       got at entry m+n bears little relation to the entry m.  */
if|if
condition|(
name|addend
operator|!=
literal|0
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B(%A+0x%lx): non-zero addend on %s reloc against `%s'"
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
name|long
operator|)
name|rel
operator|->
name|r_offset
argument_list|,
name|howto
operator|->
name|name
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* Relocations that need no special processing.  */
case|case
name|R_PPC_LOCAL24PC
case|:
comment|/* It makes no sense to point a local relocation 	     at a symbol not in this object.  */
if|if
condition|(
name|unresolved_reloc
condition|)
block|{
if|if
condition|(
operator|!
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
name|FALSE
return|;
continue|continue;
block|}
break|break;
case|case
name|R_PPC_DTPREL16
case|:
case|case
name|R_PPC_DTPREL16_LO
case|:
case|case
name|R_PPC_DTPREL16_HI
case|:
case|case
name|R_PPC_DTPREL16_HA
case|:
name|addend
operator|-=
name|htab
operator|->
name|elf
operator|.
name|tls_sec
operator|->
name|vma
operator|+
name|DTP_OFFSET
expr_stmt|;
break|break;
comment|/* Relocations that may need to be propagated if this is a shared 	     object.  */
case|case
name|R_PPC_TPREL16
case|:
case|case
name|R_PPC_TPREL16_LO
case|:
case|case
name|R_PPC_TPREL16_HI
case|:
case|case
name|R_PPC_TPREL16_HA
case|:
name|addend
operator|-=
name|htab
operator|->
name|elf
operator|.
name|tls_sec
operator|->
name|vma
operator|+
name|TP_OFFSET
expr_stmt|;
comment|/* The TPREL16 relocs shouldn't really be used in shared 	     libs as they will result in DT_TEXTREL being set, but 	     support them anyway.  */
goto|goto
name|dodyn
goto|;
case|case
name|R_PPC_TPREL32
case|:
name|addend
operator|-=
name|htab
operator|->
name|elf
operator|.
name|tls_sec
operator|->
name|vma
operator|+
name|TP_OFFSET
expr_stmt|;
goto|goto
name|dodyn
goto|;
case|case
name|R_PPC_DTPREL32
case|:
name|addend
operator|-=
name|htab
operator|->
name|elf
operator|.
name|tls_sec
operator|->
name|vma
operator|+
name|DTP_OFFSET
expr_stmt|;
goto|goto
name|dodyn
goto|;
case|case
name|R_PPC_DTPMOD32
case|:
name|relocation
operator|=
literal|1
expr_stmt|;
name|addend
operator|=
literal|0
expr_stmt|;
goto|goto
name|dodyn
goto|;
case|case
name|R_PPC_REL16
case|:
case|case
name|R_PPC_REL16_LO
case|:
case|case
name|R_PPC_REL16_HI
case|:
case|case
name|R_PPC_REL16_HA
case|:
break|break;
case|case
name|R_PPC_REL24
case|:
case|case
name|R_PPC_REL32
case|:
case|case
name|R_PPC_REL14
case|:
case|case
name|R_PPC_REL14_BRTAKEN
case|:
case|case
name|R_PPC_REL14_BRNTAKEN
case|:
comment|/* If these relocations are not to a named symbol, they can be 	     handled right here, no need to bother the dynamic linker.  */
if|if
condition|(
name|SYMBOL_REFERENCES_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
operator|||
name|h
operator|==
name|htab
operator|->
name|elf
operator|.
name|hgot
condition|)
break|break;
comment|/* fall through */
comment|/* Relocations that always need to be propagated if this is a shared 	     object.  */
case|case
name|R_PPC_ADDR32
case|:
case|case
name|R_PPC_ADDR24
case|:
case|case
name|R_PPC_ADDR16
case|:
case|case
name|R_PPC_ADDR16_LO
case|:
case|case
name|R_PPC_ADDR16_HI
case|:
case|case
name|R_PPC_ADDR16_HA
case|:
case|case
name|R_PPC_ADDR14
case|:
case|case
name|R_PPC_ADDR14_BRTAKEN
case|:
case|case
name|R_PPC_ADDR14_BRNTAKEN
case|:
case|case
name|R_PPC_UADDR32
case|:
case|case
name|R_PPC_UADDR16
case|:
name|dodyn
label|:
if|if
condition|(
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|==
literal|0
condition|)
break|break;
comment|/* Fall thru.  */
if|if
condition|(
operator|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|h
operator|==
name|NULL
operator|||
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_DEFAULT
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefweak
operator|)
operator|&&
operator|(
name|MUST_BE_DYN_RELOC
argument_list|(
name|r_type
argument_list|)
operator|||
operator|!
name|SYMBOL_CALLS_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|ELIMINATE_COPY_RELOCS
operator|&&
operator|!
name|info
operator|->
name|shared
operator|&&
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|&&
operator|!
name|h
operator|->
name|non_got_ref
operator|&&
name|h
operator|->
name|def_dynamic
operator|&&
operator|!
name|h
operator|->
name|def_regular
operator|)
condition|)
block|{
name|int
name|skip
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ppc_elf_relocate_section needs to "
literal|"create relocation for %s\n"
argument_list|,
operator|(
name|h
operator|&&
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
condition|?
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
else|:
literal|"<unknown>"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* When generating a shared object, these relocations 		 are copied into the output file to be resolved at run 		 time.  */
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
operator|(
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|elf_elfheader
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|e_shstrndx
argument_list|,
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|rel_hdr
operator|.
name|sh_name
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|BFD_ASSERT
argument_list|(
name|CONST_STRNEQ
argument_list|(
name|name
argument_list|,
literal|".rela"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
argument_list|,
name|name
operator|+
literal|5
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|sreloc
operator|=
name|bfd_get_section_by_name
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sreloc
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
name|skip
operator|=
literal|0
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|=
name|_bfd_elf_section_offset
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|outrel
operator|.
name|r_offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|||
name|outrel
operator|.
name|r_offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|2
condition|)
name|skip
operator|=
operator|(
name|int
operator|)
name|outrel
operator|.
name|r_offset
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|+=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
if|if
condition|(
name|skip
condition|)
name|memset
argument_list|(
operator|&
name|outrel
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|outrel
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|SYMBOL_REFERENCES_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
block|{
name|unresolved_reloc
operator|=
name|FALSE
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
name|rel
operator|->
name|r_addend
expr_stmt|;
block|}
else|else
block|{
name|outrel
operator|.
name|r_addend
operator|=
name|relocation
operator|+
name|rel
operator|->
name|r_addend
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_PPC_ADDR32
condition|)
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_PPC_RELATIVE
argument_list|)
expr_stmt|;
else|else
block|{
name|long
name|indx
decl_stmt|;
if|if
condition|(
name|bfd_is_abs_section
argument_list|(
name|sec
argument_list|)
condition|)
name|indx
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|sec
operator|==
name|NULL
operator|||
name|sec
operator|->
name|owner
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
else|else
block|{
name|asection
modifier|*
name|osec
decl_stmt|;
comment|/* We are turning this relocation into one 			     against a section symbol.  It would be 			     proper to subtract the symbol's value, 			     osec->vma, from the emitted reloc addend, 			     but ld.so expects buggy relocs.  */
name|osec
operator|=
name|sec
operator|->
name|output_section
expr_stmt|;
name|indx
operator|=
name|elf_section_data
argument_list|(
name|osec
argument_list|)
operator|->
name|dynindx
expr_stmt|;
if|if
condition|(
name|indx
operator|==
literal|0
condition|)
block|{
name|osec
operator|=
name|htab
operator|->
name|elf
operator|.
name|text_index_section
expr_stmt|;
name|indx
operator|=
name|elf_section_data
argument_list|(
name|osec
argument_list|)
operator|->
name|dynindx
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
name|indx
operator|!=
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|indx
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"indx=%ld section=%s flags=%08x name=%s\n"
argument_list|,
name|indx
argument_list|,
name|osec
operator|->
name|name
argument_list|,
name|osec
operator|->
name|flags
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|indx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
block|}
block|}
name|loc
operator|=
name|sreloc
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
name|sreloc
operator|->
name|reloc_count
operator|++
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
if|if
condition|(
name|skip
operator|==
operator|-
literal|1
condition|)
continue|continue;
comment|/* This reloc will be computed at runtime.  We clear the memory 		 so that it contains predictable value.  */
if|if
condition|(
operator|!
name|skip
operator|&&
operator|(
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
operator|||
name|ELF32_R_TYPE
argument_list|(
name|outrel
operator|.
name|r_info
argument_list|)
operator|!=
name|R_PPC_RELATIVE
operator|)
condition|)
block|{
name|relocation
operator|=
name|howto
operator|->
name|pc_relative
condition|?
name|outrel
operator|.
name|r_offset
else|:
literal|0
expr_stmt|;
name|addend
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
name|R_PPC_RELAX32PC_PLT
case|:
case|case
name|R_PPC_RELAX32_PLT
case|:
block|{
name|struct
name|plt_entry
modifier|*
name|ent
init|=
name|find_plt_ent
argument_list|(
name|h
argument_list|,
name|got2
argument_list|,
name|addend
argument_list|)
decl_stmt|;
if|if
condition|(
name|htab
operator|->
name|plt_type
operator|==
name|PLT_NEW
condition|)
name|relocation
operator|=
operator|(
name|htab
operator|->
name|glink
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|glink
operator|->
name|output_offset
operator|+
name|ent
operator|->
name|glink_offset
operator|)
expr_stmt|;
else|else
name|relocation
operator|=
operator|(
name|htab
operator|->
name|plt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|plt
operator|->
name|output_offset
operator|+
name|ent
operator|->
name|plt
operator|.
name|offset
operator|)
expr_stmt|;
name|addend
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|r_type
operator|==
name|R_PPC_RELAX32_PLT
condition|)
goto|goto
name|relax32
goto|;
comment|/* Fall thru */
case|case
name|R_PPC_RELAX32PC
case|:
name|relocation
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|rel
operator|->
name|r_offset
operator|-
literal|4
operator|)
expr_stmt|;
comment|/* Fall thru */
case|case
name|R_PPC_RELAX32
case|:
name|relax32
label|:
block|{
name|unsigned
name|long
name|t0
decl_stmt|;
name|unsigned
name|long
name|t1
decl_stmt|;
name|t0
operator|=
name|bfd_get_32
argument_list|(
name|output_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|t1
operator|=
name|bfd_get_32
argument_list|(
name|output_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|+
literal|4
argument_list|)
expr_stmt|;
comment|/* We're clearing the bits for R_PPC_ADDR16_HA 	       and R_PPC_ADDR16_LO here.  */
name|t0
operator|&=
operator|~
literal|0xffff
expr_stmt|;
name|t1
operator|&=
operator|~
literal|0xffff
expr_stmt|;
comment|/* t0 is HA, t1 is LO */
name|relocation
operator|+=
name|addend
expr_stmt|;
name|t0
operator||=
operator|(
operator|(
name|relocation
operator|+
literal|0x8000
operator|)
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
expr_stmt|;
name|t1
operator||=
name|relocation
operator|&
literal|0xffff
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|t0
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|t1
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
continue|continue;
comment|/* Indirect .sdata relocation.  */
case|case
name|R_PPC_EMB_SDAI16
case|:
name|BFD_ASSERT
argument_list|(
name|htab
operator|->
name|sdata
index|[
literal|0
index|]
operator|.
name|section
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|relocation
operator|=
name|elf_finish_pointer_linker_section
argument_list|(
name|input_bfd
argument_list|,
operator|&
name|htab
operator|->
name|sdata
index|[
literal|0
index|]
argument_list|,
name|h
argument_list|,
name|relocation
argument_list|,
name|rel
argument_list|)
expr_stmt|;
break|break;
comment|/* Indirect .sdata2 relocation.  */
case|case
name|R_PPC_EMB_SDA2I16
case|:
name|BFD_ASSERT
argument_list|(
name|htab
operator|->
name|sdata
index|[
literal|1
index|]
operator|.
name|section
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|relocation
operator|=
name|elf_finish_pointer_linker_section
argument_list|(
name|input_bfd
argument_list|,
operator|&
name|htab
operator|->
name|sdata
index|[
literal|1
index|]
argument_list|,
name|h
argument_list|,
name|relocation
argument_list|,
name|rel
argument_list|)
expr_stmt|;
break|break;
comment|/* Handle the TOC16 reloc.  We want to use the offset within the .got 	     section, not the actual VMA.  This is appropriate when generating 	     an embedded ELF object, for which the .got section acts like the 	     AIX .toc section.  */
case|case
name|R_PPC_TOC16
case|:
comment|/* phony GOT16 relocations */
name|BFD_ASSERT
argument_list|(
name|sec
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|bfd_is_und_section
argument_list|(
name|sec
argument_list|)
operator|||
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|,
literal|".got"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|,
literal|".cgot"
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|addend
operator|-=
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
literal|0x8000
expr_stmt|;
break|break;
case|case
name|R_PPC_PLTREL24
case|:
comment|/* Relocation is to the entry for this symbol in the 	     procedure linkage table.  */
block|{
name|struct
name|plt_entry
modifier|*
name|ent
init|=
name|find_plt_ent
argument_list|(
name|h
argument_list|,
name|got2
argument_list|,
name|addend
argument_list|)
decl_stmt|;
name|addend
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ent
operator|==
name|NULL
operator|||
name|htab
operator|->
name|plt
operator|==
name|NULL
condition|)
block|{
comment|/* We didn't make a PLT entry for this symbol.  This 		   happens when statically linking PIC code, or when 		   using -Bsymbolic.  */
break|break;
block|}
name|unresolved_reloc
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|plt_type
operator|==
name|PLT_NEW
condition|)
name|relocation
operator|=
operator|(
name|htab
operator|->
name|glink
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|glink
operator|->
name|output_offset
operator|+
name|ent
operator|->
name|glink_offset
operator|)
expr_stmt|;
else|else
name|relocation
operator|=
operator|(
name|htab
operator|->
name|plt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|plt
operator|->
name|output_offset
operator|+
name|ent
operator|->
name|plt
operator|.
name|offset
operator|)
expr_stmt|;
block|}
break|break;
comment|/* Relocate against _SDA_BASE_.  */
case|case
name|R_PPC_SDAREL16
case|:
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|sh
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|sec
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
operator|->
name|output_section
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|CONST_STRNEQ
argument_list|(
name|name
argument_list|,
literal|".sdata"
argument_list|)
operator|&&
operator|(
name|name
index|[
literal|6
index|]
operator|==
literal|0
operator|||
name|name
index|[
literal|6
index|]
operator|==
literal|'.'
operator|)
operator|)
operator|||
operator|(
name|CONST_STRNEQ
argument_list|(
name|name
argument_list|,
literal|".sbss"
argument_list|)
operator|&&
operator|(
name|name
index|[
literal|5
index|]
operator|==
literal|0
operator|||
name|name
index|[
literal|5
index|]
operator|==
literal|'.'
operator|)
operator|)
operator|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: the target (%s) of a %s relocation is "
literal|"in the wrong output section (%s)"
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|sym_name
argument_list|,
name|howto
operator|->
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|sh
operator|=
name|htab
operator|->
name|sdata
index|[
literal|0
index|]
operator|.
name|sym
expr_stmt|;
name|addend
operator|-=
operator|(
name|sh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|sh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|+
name|sh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
block|}
break|break;
comment|/* Relocate against _SDA2_BASE_.  */
case|case
name|R_PPC_EMB_SDA2REL
case|:
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|sh
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|sec
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
operator|->
name|output_section
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|CONST_STRNEQ
argument_list|(
name|name
argument_list|,
literal|".sdata2"
argument_list|)
operator|||
name|CONST_STRNEQ
argument_list|(
name|name
argument_list|,
literal|".sbss2"
argument_list|)
operator|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: the target (%s) of a %s relocation is "
literal|"in the wrong output section (%s)"
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|sym_name
argument_list|,
name|howto
operator|->
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
name|ret
operator|=
name|FALSE
expr_stmt|;
continue|continue;
block|}
name|sh
operator|=
name|htab
operator|->
name|sdata
index|[
literal|1
index|]
operator|.
name|sym
expr_stmt|;
name|addend
operator|-=
operator|(
name|sh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|sh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|+
name|sh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
block|}
break|break;
comment|/* Relocate against either _SDA_BASE_, _SDA2_BASE_, or 0.  */
case|case
name|R_PPC_EMB_SDA21
case|:
case|case
name|R_PPC_EMB_RELSDA
case|:
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|reg
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|sh
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|sec
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
operator|->
name|output_section
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|CONST_STRNEQ
argument_list|(
name|name
argument_list|,
literal|".sdata"
argument_list|)
operator|&&
operator|(
name|name
index|[
literal|6
index|]
operator|==
literal|0
operator|||
name|name
index|[
literal|6
index|]
operator|==
literal|'.'
operator|)
operator|)
operator|||
operator|(
name|CONST_STRNEQ
argument_list|(
name|name
argument_list|,
literal|".sbss"
argument_list|)
operator|&&
operator|(
name|name
index|[
literal|5
index|]
operator|==
literal|0
operator|||
name|name
index|[
literal|5
index|]
operator|==
literal|'.'
operator|)
operator|)
operator|)
condition|)
block|{
name|reg
operator|=
literal|13
expr_stmt|;
name|sh
operator|=
name|htab
operator|->
name|sdata
index|[
literal|0
index|]
operator|.
name|sym
expr_stmt|;
name|addend
operator|-=
operator|(
name|sh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|sh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|+
name|sh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CONST_STRNEQ
argument_list|(
name|name
argument_list|,
literal|".sdata2"
argument_list|)
operator|||
name|CONST_STRNEQ
argument_list|(
name|name
argument_list|,
literal|".sbss2"
argument_list|)
condition|)
block|{
name|reg
operator|=
literal|2
expr_stmt|;
name|sh
operator|=
name|htab
operator|->
name|sdata
index|[
literal|1
index|]
operator|.
name|sym
expr_stmt|;
name|addend
operator|-=
operator|(
name|sh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|sh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|+
name|sh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".PPC.EMB.sdata0"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".PPC.EMB.sbss0"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|reg
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: the target (%s) of a %s relocation is "
literal|"in the wrong output section (%s)"
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|sym_name
argument_list|,
name|howto
operator|->
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
name|ret
operator|=
name|FALSE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|r_type
operator|==
name|R_PPC_EMB_SDA21
condition|)
block|{
comment|/* fill in register field */
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|output_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|insn
operator|=
operator|(
name|insn
operator|&
operator|~
name|RA_REGISTER_MASK
operator|)
operator||
operator|(
name|reg
operator|<<
name|RA_REGISTER_SHIFT
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|insn
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
comment|/* Relocate against the beginning of the section.  */
case|case
name|R_PPC_SECTOFF
case|:
case|case
name|R_PPC_SECTOFF_LO
case|:
case|case
name|R_PPC_SECTOFF_HI
case|:
case|case
name|R_PPC_SECTOFF_HA
case|:
name|BFD_ASSERT
argument_list|(
name|sec
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|addend
operator|-=
name|sec
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
break|break;
comment|/* Negative relocations.  */
case|case
name|R_PPC_EMB_NADDR32
case|:
case|case
name|R_PPC_EMB_NADDR16
case|:
case|case
name|R_PPC_EMB_NADDR16_LO
case|:
case|case
name|R_PPC_EMB_NADDR16_HI
case|:
case|case
name|R_PPC_EMB_NADDR16_HA
case|:
name|addend
operator|-=
literal|2
operator|*
name|relocation
expr_stmt|;
break|break;
case|case
name|R_PPC_COPY
case|:
case|case
name|R_PPC_GLOB_DAT
case|:
case|case
name|R_PPC_JMP_SLOT
case|:
case|case
name|R_PPC_RELATIVE
case|:
case|case
name|R_PPC_PLT32
case|:
case|case
name|R_PPC_PLTREL32
case|:
case|case
name|R_PPC_PLT16_LO
case|:
case|case
name|R_PPC_PLT16_HI
case|:
case|case
name|R_PPC_PLT16_HA
case|:
case|case
name|R_PPC_ADDR30
case|:
case|case
name|R_PPC_EMB_RELSEC16
case|:
case|case
name|R_PPC_EMB_RELST_LO
case|:
case|case
name|R_PPC_EMB_RELST_HI
case|:
case|case
name|R_PPC_EMB_RELST_HA
case|:
case|case
name|R_PPC_EMB_BIT_FLD
case|:
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: relocation %s is not yet supported for symbol %s."
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|howto
operator|->
name|name
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
name|ret
operator|=
name|FALSE
expr_stmt|;
continue|continue;
block|}
comment|/* Do any further special processing.  */
switch|switch
condition|(
name|r_type
condition|)
block|{
default|default:
break|break;
case|case
name|R_PPC_ADDR16_HA
case|:
case|case
name|R_PPC_REL16_HA
case|:
case|case
name|R_PPC_SECTOFF_HA
case|:
case|case
name|R_PPC_TPREL16_HA
case|:
case|case
name|R_PPC_DTPREL16_HA
case|:
case|case
name|R_PPC_EMB_NADDR16_HA
case|:
case|case
name|R_PPC_EMB_RELST_HA
case|:
comment|/* It's just possible that this symbol is a weak symbol 	     that's not actually defined anywhere.  In that case, 	     'sec' would be NULL, and we should leave the symbol 	     alone (it will be set to zero elsewhere in the link).  */
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
break|break;
comment|/* Fall thru */
case|case
name|R_PPC_PLT16_HA
case|:
case|case
name|R_PPC_GOT16_HA
case|:
case|case
name|R_PPC_GOT_TLSGD16_HA
case|:
case|case
name|R_PPC_GOT_TLSLD16_HA
case|:
case|case
name|R_PPC_GOT_TPREL16_HA
case|:
case|case
name|R_PPC_GOT_DTPREL16_HA
case|:
comment|/* Add 0x10000 if sign bit in 0:15 is set. 	     Bits 0:15 are not used.  */
name|addend
operator|+=
literal|0x8000
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ttype = %s (%d), name = %s, symbol index = %ld, "
literal|"offset = %ld, addend = %ld\n"
argument_list|,
name|howto
operator|->
name|name
argument_list|,
operator|(
name|int
operator|)
name|r_type
argument_list|,
name|sym_name
argument_list|,
name|r_symndx
argument_list|,
operator|(
name|long
operator|)
name|rel
operator|->
name|r_offset
argument_list|,
operator|(
name|long
operator|)
name|addend
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|unresolved_reloc
operator|&&
operator|!
operator|(
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_DEBUGGING
operator|)
operator|!=
literal|0
operator|&&
name|h
operator|->
name|def_dynamic
operator|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B(%A+0x%lx): unresolvable %s relocation against symbol `%s'"
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
name|long
operator|)
name|rel
operator|->
name|r_offset
argument_list|,
name|howto
operator|->
name|name
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
name|ret
operator|=
name|FALSE
expr_stmt|;
block|}
name|r
operator|=
name|_bfd_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|relocation
argument_list|,
name|addend
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|bfd_reloc_ok
condition|)
block|{
if|if
condition|(
name|r
operator|==
name|bfd_reloc_overflow
condition|)
block|{
if|if
condition|(
name|warned
condition|)
continue|continue;
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|&&
name|howto
operator|->
name|pc_relative
condition|)
block|{
comment|/* Assume this is a call protected by other code that 		     detect the symbol is undefined.  If this is the case, 		     we can safely ignore the overflow.  If not, the 		     program is hosed anyway, and a little warning isn't 		     going to help.  */
continue|continue;
block|}
if|if
condition|(
operator|!
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|info
argument_list|,
operator|(
name|h
condition|?
operator|&
name|h
operator|->
name|root
else|:
name|NULL
operator|)
argument_list|,
name|sym_name
argument_list|,
name|howto
operator|->
name|name
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
else|else
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B(%A+0x%lx): %s reloc against `%s': error %d"
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
name|long
operator|)
name|rel
operator|->
name|r_offset
argument_list|,
name|howto
operator|->
name|name
argument_list|,
name|sym_name
argument_list|,
operator|(
name|int
operator|)
name|r
argument_list|)
expr_stmt|;
name|ret
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|ret
return|;
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|PPC_LO
parameter_list|(
name|v
parameter_list|)
value|((v)& 0xffff)
end_define

begin_define
define|#
directive|define
name|PPC_HI
parameter_list|(
name|v
parameter_list|)
value|(((v)>> 16)& 0xffff)
end_define

begin_define
define|#
directive|define
name|PPC_HA
parameter_list|(
name|v
parameter_list|)
value|PPC_HI ((v) + 0x8000)
end_define

begin_comment
comment|/* Finish up dynamic symbol handling.  We set the contents of various    dynamic sections here.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc_elf_finish_dynamic_symbol
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|)
block|{
name|struct
name|ppc_elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|struct
name|plt_entry
modifier|*
name|ent
decl_stmt|;
name|bfd_boolean
name|doneone
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ppc_elf_finish_dynamic_symbol called for %s"
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|htab
operator|=
name|ppc_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|doneone
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|ent
operator|=
name|h
operator|->
name|plt
operator|.
name|plist
init|;
name|ent
operator|!=
name|NULL
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
if|if
condition|(
name|ent
operator|->
name|plt
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|doneone
condition|)
block|{
name|Elf_Internal_Rela
name|rela
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|bfd_vma
name|reloc_index
decl_stmt|;
if|if
condition|(
name|htab
operator|->
name|plt_type
operator|==
name|PLT_NEW
condition|)
name|reloc_index
operator|=
name|ent
operator|->
name|plt
operator|.
name|offset
operator|/
literal|4
expr_stmt|;
else|else
block|{
name|reloc_index
operator|=
operator|(
operator|(
name|ent
operator|->
name|plt
operator|.
name|offset
operator|-
name|htab
operator|->
name|plt_initial_entry_size
operator|)
operator|/
name|htab
operator|->
name|plt_slot_size
operator|)
expr_stmt|;
if|if
condition|(
name|reloc_index
operator|>
name|PLT_NUM_SINGLE_ENTRIES
operator|&&
name|htab
operator|->
name|plt_type
operator|==
name|PLT_OLD
condition|)
name|reloc_index
operator|-=
operator|(
name|reloc_index
operator|-
name|PLT_NUM_SINGLE_ENTRIES
operator|)
operator|/
literal|2
expr_stmt|;
block|}
comment|/* This symbol has an entry in the procedure linkage table. 	       Set it up.  */
if|if
condition|(
name|htab
operator|->
name|plt_type
operator|==
name|PLT_VXWORKS
condition|)
block|{
name|bfd_vma
name|got_offset
decl_stmt|;
specifier|const
name|bfd_vma
modifier|*
name|plt_entry
decl_stmt|;
comment|/* The first three entries in .got.plt are reserved.  */
name|got_offset
operator|=
operator|(
name|reloc_index
operator|+
literal|3
operator|)
operator|*
literal|4
expr_stmt|;
comment|/* Use the right PLT. */
name|plt_entry
operator|=
name|info
operator|->
name|shared
condition|?
name|ppc_elf_vxworks_pic_plt_entry
else|:
name|ppc_elf_vxworks_plt_entry
expr_stmt|;
comment|/* Fill in the .plt on VxWorks.  */
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
name|bfd_vma
name|got_offset_hi
init|=
operator|(
name|got_offset
operator|>>
literal|16
operator|)
operator|+
operator|(
operator|(
name|got_offset
operator|&
literal|0x8000
operator|)
operator|>>
literal|15
operator|)
decl_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|plt_entry
index|[
literal|0
index|]
operator||
operator|(
name|got_offset_hi
operator|&
literal|0xffff
operator|)
argument_list|,
name|htab
operator|->
name|plt
operator|->
name|contents
operator|+
name|ent
operator|->
name|plt
operator|.
name|offset
operator|+
literal|0
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|plt_entry
index|[
literal|1
index|]
operator||
operator|(
name|got_offset
operator|&
literal|0xffff
operator|)
argument_list|,
name|htab
operator|->
name|plt
operator|->
name|contents
operator|+
name|ent
operator|->
name|plt
operator|.
name|offset
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bfd_vma
name|got_loc
init|=
operator|(
name|got_offset
operator|+
name|htab
operator|->
name|elf
operator|.
name|hgot
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|htab
operator|->
name|elf
operator|.
name|hgot
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|+
name|htab
operator|->
name|elf
operator|.
name|hgot
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|)
decl_stmt|;
name|bfd_vma
name|got_loc_hi
init|=
operator|(
name|got_loc
operator|>>
literal|16
operator|)
operator|+
operator|(
operator|(
name|got_loc
operator|&
literal|0x8000
operator|)
operator|>>
literal|15
operator|)
decl_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|plt_entry
index|[
literal|0
index|]
operator||
operator|(
name|got_loc_hi
operator|&
literal|0xffff
operator|)
argument_list|,
name|htab
operator|->
name|plt
operator|->
name|contents
operator|+
name|ent
operator|->
name|plt
operator|.
name|offset
operator|+
literal|0
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|plt_entry
index|[
literal|1
index|]
operator||
operator|(
name|got_loc
operator|&
literal|0xffff
operator|)
argument_list|,
name|htab
operator|->
name|plt
operator|->
name|contents
operator|+
name|ent
operator|->
name|plt
operator|.
name|offset
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|plt_entry
index|[
literal|2
index|]
argument_list|,
name|htab
operator|->
name|plt
operator|->
name|contents
operator|+
name|ent
operator|->
name|plt
operator|.
name|offset
operator|+
literal|8
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|plt_entry
index|[
literal|3
index|]
argument_list|,
name|htab
operator|->
name|plt
operator|->
name|contents
operator|+
name|ent
operator|->
name|plt
operator|.
name|offset
operator|+
literal|12
argument_list|)
expr_stmt|;
comment|/* This instruction is an immediate load.  The value loaded is 		   the byte offset of the R_PPC_JMP_SLOT relocation from the 		   start of the .rela.plt section.  The value is stored in the 		   low-order 16 bits of the load instruction.  */
comment|/* NOTE: It appears that this is now an index rather than a 		   prescaled offset.  */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|plt_entry
index|[
literal|4
index|]
operator||
name|reloc_index
argument_list|,
name|htab
operator|->
name|plt
operator|->
name|contents
operator|+
name|ent
operator|->
name|plt
operator|.
name|offset
operator|+
literal|16
argument_list|)
expr_stmt|;
comment|/* This instruction is a PC-relative branch whose target is 		   the start of the PLT section.  The address of this branch 		   instruction is 20 bytes beyond the start of this PLT entry. 		   The address is encoded in bits 6-29, inclusive.  The value 		   stored is right-shifted by two bits, permitting a 26-bit 		   offset.  */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|plt_entry
index|[
literal|5
index|]
operator||
operator|(
operator|-
operator|(
name|ent
operator|->
name|plt
operator|.
name|offset
operator|+
literal|20
operator|)
operator|&
literal|0x03fffffc
operator|)
operator|)
argument_list|,
name|htab
operator|->
name|plt
operator|->
name|contents
operator|+
name|ent
operator|->
name|plt
operator|.
name|offset
operator|+
literal|20
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|plt_entry
index|[
literal|6
index|]
argument_list|,
name|htab
operator|->
name|plt
operator|->
name|contents
operator|+
name|ent
operator|->
name|plt
operator|.
name|offset
operator|+
literal|24
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|plt_entry
index|[
literal|7
index|]
argument_list|,
name|htab
operator|->
name|plt
operator|->
name|contents
operator|+
name|ent
operator|->
name|plt
operator|.
name|offset
operator|+
literal|28
argument_list|)
expr_stmt|;
comment|/* Fill in the GOT entry corresponding to this PLT slot with 		   the address immediately after the the "bctr" instruction 		   in this PLT entry.  */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|htab
operator|->
name|plt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|plt
operator|->
name|output_offset
operator|+
name|ent
operator|->
name|plt
operator|.
name|offset
operator|+
literal|16
operator|)
argument_list|,
name|htab
operator|->
name|sgotplt
operator|->
name|contents
operator|+
name|got_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
comment|/* Fill in a couple of entries in .rela.plt.unloaded.  */
name|loc
operator|=
name|htab
operator|->
name|srelplt2
operator|->
name|contents
operator|+
operator|(
operator|(
name|VXWORKS_PLTRESOLVE_RELOCS
operator|+
name|reloc_index
operator|*
name|VXWORKS_PLT_NON_JMP_SLOT_RELOCS
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
operator|)
expr_stmt|;
comment|/* Provide the @ha relocation for the first instruction.  */
name|rela
operator|.
name|r_offset
operator|=
operator|(
name|htab
operator|->
name|plt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|plt
operator|->
name|output_offset
operator|+
name|ent
operator|->
name|plt
operator|.
name|offset
operator|+
literal|2
operator|)
expr_stmt|;
name|rela
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|hgot
operator|->
name|indx
argument_list|,
name|R_PPC_ADDR16_HA
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_addend
operator|=
name|got_offset
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rela
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|loc
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
comment|/* Provide the @l relocation for the second instruction.  */
name|rela
operator|.
name|r_offset
operator|=
operator|(
name|htab
operator|->
name|plt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|plt
operator|->
name|output_offset
operator|+
name|ent
operator|->
name|plt
operator|.
name|offset
operator|+
literal|6
operator|)
expr_stmt|;
name|rela
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|hgot
operator|->
name|indx
argument_list|,
name|R_PPC_ADDR16_LO
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_addend
operator|=
name|got_offset
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rela
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|loc
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
comment|/* Provide a relocation for the GOT entry corresponding to this 		       PLT slot.  Point it at the middle of the .plt entry.  */
name|rela
operator|.
name|r_offset
operator|=
operator|(
name|htab
operator|->
name|sgotplt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|sgotplt
operator|->
name|output_offset
operator|+
name|got_offset
operator|)
expr_stmt|;
name|rela
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|hplt
operator|->
name|indx
argument_list|,
name|R_PPC_ADDR32
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_addend
operator|=
name|ent
operator|->
name|plt
operator|.
name|offset
operator|+
literal|16
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rela
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
comment|/* VxWorks uses non-standard semantics for R_PPC_JMP_SLOT. 		   In particular, the offset for the relocation is not the 		   address of the PLT entry for this function, as specified 		   by the ABI.  Instead, the offset is set to the address of 		   the GOT slot for this function.  See EABI 4.4.4.1.  */
name|rela
operator|.
name|r_offset
operator|=
operator|(
name|htab
operator|->
name|sgotplt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|sgotplt
operator|->
name|output_offset
operator|+
name|got_offset
operator|)
expr_stmt|;
block|}
else|else
block|{
name|rela
operator|.
name|r_offset
operator|=
operator|(
name|htab
operator|->
name|plt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|plt
operator|->
name|output_offset
operator|+
name|ent
operator|->
name|plt
operator|.
name|offset
operator|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|plt_type
operator|==
name|PLT_OLD
condition|)
block|{
comment|/* We don't need to fill in the .plt.  The ppc dynamic 		       linker will fill it in.  */
block|}
else|else
block|{
name|bfd_vma
name|val
init|=
operator|(
name|htab
operator|->
name|glink_pltresolve
operator|+
name|ent
operator|->
name|plt
operator|.
name|offset
operator|+
name|htab
operator|->
name|glink
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|glink
operator|->
name|output_offset
operator|)
decl_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|val
argument_list|,
name|htab
operator|->
name|plt
operator|->
name|contents
operator|+
name|ent
operator|->
name|plt
operator|.
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Fill in the entry in the .rela.plt section.  */
name|rela
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_PPC_JMP_SLOT
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
name|loc
operator|=
operator|(
name|htab
operator|->
name|relplt
operator|->
name|contents
operator|+
name|reloc_index
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
operator|)
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rela
argument_list|,
name|loc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|h
operator|->
name|def_regular
condition|)
block|{
comment|/* Mark the symbol as undefined, rather than as defined in 		   the .plt section.  Leave the value alone.  */
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_UNDEF
expr_stmt|;
comment|/* If the symbol is weak, we do need to clear the value. 		   Otherwise, the PLT entry would provide a definition for 		   the symbol even if the symbol wasn't defined anywhere, 		   and so the symbol would never be NULL.  */
if|if
condition|(
operator|!
name|h
operator|->
name|ref_regular_nonweak
condition|)
name|sym
operator|->
name|st_value
operator|=
literal|0
expr_stmt|;
block|}
name|doneone
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|htab
operator|->
name|plt_type
operator|==
name|PLT_NEW
condition|)
block|{
name|bfd_vma
name|plt
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|plt
operator|=
operator|(
name|ent
operator|->
name|plt
operator|.
name|offset
operator|+
name|htab
operator|->
name|plt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|plt
operator|->
name|output_offset
operator|)
expr_stmt|;
name|p
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|htab
operator|->
name|glink
operator|->
name|contents
operator|+
name|ent
operator|->
name|glink_offset
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
operator|||
name|info
operator|->
name|pie
condition|)
block|{
name|bfd_vma
name|got
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ent
operator|->
name|addend
operator|>=
literal|32768
condition|)
name|got
operator|=
operator|(
name|ent
operator|->
name|addend
operator|+
name|ent
operator|->
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|ent
operator|->
name|sec
operator|->
name|output_offset
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|htab
operator|->
name|elf
operator|.
name|hgot
operator|!=
name|NULL
condition|)
name|got
operator|=
operator|(
name|htab
operator|->
name|elf
operator|.
name|hgot
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|htab
operator|->
name|elf
operator|.
name|hgot
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|elf
operator|.
name|hgot
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|plt
operator|-=
name|got
expr_stmt|;
if|if
condition|(
name|plt
operator|+
literal|0x8000
operator|<
literal|0x10000
condition|)
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|LWZ_11_30
operator|+
name|PPC_LO
argument_list|(
name|plt
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|MTCTR_11
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|BCTR
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|NOP
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|ADDIS_11_30
operator|+
name|PPC_HA
argument_list|(
name|plt
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|LWZ_11_11
operator|+
name|PPC_LO
argument_list|(
name|plt
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|MTCTR_11
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|BCTR
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
block|}
block|}
else|else
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|LIS_11
operator|+
name|PPC_HA
argument_list|(
name|plt
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|LWZ_11_11
operator|+
name|PPC_LO
argument_list|(
name|plt
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|MTCTR_11
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|BCTR
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
comment|/* We only need one non-PIC glink stub.  */
break|break;
block|}
block|}
else|else
break|break;
block|}
if|if
condition|(
name|h
operator|->
name|needs_copy
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|Elf_Internal_Rela
name|rela
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
comment|/* This symbols needs a copy reloc.  Set it up.  */
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", copy"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ppc_elf_hash_entry
argument_list|(
name|h
argument_list|)
operator|->
name|has_sda_refs
condition|)
name|s
operator|=
name|htab
operator|->
name|relsbss
expr_stmt|;
else|else
name|s
operator|=
name|htab
operator|->
name|relbss
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_offset
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|rela
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_PPC_COPY
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
name|loc
operator|=
name|s
operator|->
name|contents
operator|+
name|s
operator|->
name|reloc_count
operator|++
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rela
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Mark some specially defined symbols as absolute.  */
if|if
condition|(
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_DYNAMIC"
argument_list|)
operator|==
literal|0
operator|||
operator|(
operator|!
name|htab
operator|->
name|is_vxworks
operator|&&
operator|(
name|h
operator|==
name|htab
operator|->
name|elf
operator|.
name|hgot
operator|||
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_PROCEDURE_LINKAGE_TABLE_"
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_ABS
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|enum
name|elf_reloc_type_class
name|ppc_elf_reloc_type_class
parameter_list|(
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rela
parameter_list|)
block|{
switch|switch
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rela
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_PPC_RELATIVE
case|:
return|return
name|reloc_class_relative
return|;
case|case
name|R_PPC_REL24
case|:
case|case
name|R_PPC_ADDR24
case|:
case|case
name|R_PPC_JMP_SLOT
case|:
return|return
name|reloc_class_plt
return|;
case|case
name|R_PPC_COPY
case|:
return|return
name|reloc_class_copy
return|;
default|default:
return|return
name|reloc_class_normal
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Finish up the dynamic sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc_elf_finish_dynamic_sections
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|asection
modifier|*
name|sdyn
decl_stmt|;
name|asection
modifier|*
name|splt
decl_stmt|;
name|struct
name|ppc_elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|bfd_vma
name|got
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ppc_elf_finish_dynamic_sections called\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|htab
operator|=
name|ppc_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|sdyn
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|is_vxworks
condition|)
name|splt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
else|else
name|splt
operator|=
name|NULL
expr_stmt|;
name|got
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|elf
operator|.
name|hgot
operator|!=
name|NULL
condition|)
name|got
operator|=
operator|(
name|htab
operator|->
name|elf
operator|.
name|hgot
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|htab
operator|->
name|elf
operator|.
name|hgot
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|elf
operator|.
name|hgot
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|elf
operator|.
name|dynamic_sections_created
condition|)
block|{
name|Elf32_External_Dyn
modifier|*
name|dyncon
decl_stmt|,
modifier|*
name|dynconend
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|htab
operator|->
name|plt
operator|!=
name|NULL
operator|&&
name|sdyn
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dyncon
operator|=
operator|(
name|Elf32_External_Dyn
operator|*
operator|)
name|sdyn
operator|->
name|contents
expr_stmt|;
name|dynconend
operator|=
operator|(
name|Elf32_External_Dyn
operator|*
operator|)
operator|(
name|sdyn
operator|->
name|contents
operator|+
name|sdyn
operator|->
name|size
operator|)
expr_stmt|;
for|for
control|(
init|;
name|dyncon
operator|<
name|dynconend
condition|;
name|dyncon
operator|++
control|)
block|{
name|Elf_Internal_Dyn
name|dyn
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_elf32_swap_dyn_in
argument_list|(
name|dynobj
argument_list|,
name|dyncon
argument_list|,
operator|&
name|dyn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dyn
operator|.
name|d_tag
condition|)
block|{
case|case
name|DT_PLTGOT
case|:
if|if
condition|(
name|htab
operator|->
name|is_vxworks
condition|)
name|s
operator|=
name|htab
operator|->
name|sgotplt
expr_stmt|;
else|else
name|s
operator|=
name|htab
operator|->
name|plt
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|s
operator|->
name|output_section
operator|->
name|vma
operator|+
name|s
operator|->
name|output_offset
expr_stmt|;
break|break;
case|case
name|DT_PLTRELSZ
case|:
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|htab
operator|->
name|relplt
operator|->
name|size
expr_stmt|;
break|break;
case|case
name|DT_JMPREL
case|:
name|s
operator|=
name|htab
operator|->
name|relplt
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|s
operator|->
name|output_section
operator|->
name|vma
operator|+
name|s
operator|->
name|output_offset
expr_stmt|;
break|break;
case|case
name|DT_PPC_GOT
case|:
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|got
expr_stmt|;
break|break;
case|case
name|DT_RELASZ
case|:
if|if
condition|(
name|htab
operator|->
name|is_vxworks
condition|)
block|{
if|if
condition|(
name|htab
operator|->
name|relplt
condition|)
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|-=
name|htab
operator|->
name|relplt
operator|->
name|size
expr_stmt|;
break|break;
block|}
continue|continue;
default|default:
continue|continue;
block|}
name|bfd_elf32_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Add a blrl instruction at _GLOBAL_OFFSET_TABLE_-4 so that a function can      easily find the address of the _GLOBAL_OFFSET_TABLE_.  */
if|if
condition|(
name|htab
operator|->
name|got
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|char
modifier|*
name|p
init|=
name|htab
operator|->
name|got
operator|->
name|contents
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
name|p
operator|+=
name|htab
operator|->
name|elf
operator|.
name|hgot
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|plt_type
operator|==
name|PLT_OLD
condition|)
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
literal|0x4e800021
comment|/* blrl */
argument_list|,
name|p
operator|-
literal|4
argument_list|)
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sdyn
operator|!=
name|NULL
condition|)
name|val
operator|=
name|sdyn
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sdyn
operator|->
name|output_offset
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|val
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|elf_section_data
argument_list|(
name|htab
operator|->
name|got
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
operator|=
literal|4
expr_stmt|;
block|}
comment|/* Fill in the first entry in the VxWorks procedure linkage table.  */
if|if
condition|(
name|splt
operator|&&
name|splt
operator|->
name|size
operator|>
literal|0
condition|)
block|{
comment|/* Use the right PLT. */
specifier|static
specifier|const
name|bfd_vma
modifier|*
name|plt_entry
init|=
name|NULL
decl_stmt|;
name|plt_entry
operator|=
name|info
operator|->
name|shared
condition|?
name|ppc_elf_vxworks_pic_plt0_entry
else|:
name|ppc_elf_vxworks_plt0_entry
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
name|bfd_vma
name|got_value
init|=
operator|(
name|htab
operator|->
name|elf
operator|.
name|hgot
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|elf
operator|.
name|hgot
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|+
name|htab
operator|->
name|elf
operator|.
name|hgot
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|)
decl_stmt|;
name|bfd_vma
name|got_hi
init|=
operator|(
name|got_value
operator|>>
literal|16
operator|)
operator|+
operator|(
operator|(
name|got_value
operator|&
literal|0x8000
operator|)
operator|>>
literal|15
operator|)
decl_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|plt_entry
index|[
literal|0
index|]
operator||
operator|(
name|got_hi
operator|&
literal|0xffff
operator|)
argument_list|,
name|splt
operator|->
name|contents
operator|+
literal|0
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|plt_entry
index|[
literal|1
index|]
operator||
operator|(
name|got_value
operator|&
literal|0xffff
operator|)
argument_list|,
name|splt
operator|->
name|contents
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|plt_entry
index|[
literal|0
index|]
argument_list|,
name|splt
operator|->
name|contents
operator|+
literal|0
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|plt_entry
index|[
literal|1
index|]
argument_list|,
name|splt
operator|->
name|contents
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|plt_entry
index|[
literal|2
index|]
argument_list|,
name|splt
operator|->
name|contents
operator|+
literal|8
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|plt_entry
index|[
literal|3
index|]
argument_list|,
name|splt
operator|->
name|contents
operator|+
literal|12
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|plt_entry
index|[
literal|4
index|]
argument_list|,
name|splt
operator|->
name|contents
operator|+
literal|16
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|plt_entry
index|[
literal|5
index|]
argument_list|,
name|splt
operator|->
name|contents
operator|+
literal|20
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|plt_entry
index|[
literal|6
index|]
argument_list|,
name|splt
operator|->
name|contents
operator|+
literal|24
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|plt_entry
index|[
literal|7
index|]
argument_list|,
name|splt
operator|->
name|contents
operator|+
literal|28
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
name|Elf_Internal_Rela
name|rela
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|loc
operator|=
name|htab
operator|->
name|srelplt2
operator|->
name|contents
expr_stmt|;
comment|/* Output the @ha relocation for the first instruction.  */
name|rela
operator|.
name|r_offset
operator|=
operator|(
name|htab
operator|->
name|plt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|plt
operator|->
name|output_offset
operator|+
literal|2
operator|)
expr_stmt|;
name|rela
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|hgot
operator|->
name|indx
argument_list|,
name|R_PPC_ADDR16_HA
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rela
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|loc
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
comment|/* Output the @l relocation for the second instruction.  */
name|rela
operator|.
name|r_offset
operator|=
operator|(
name|htab
operator|->
name|plt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|plt
operator|->
name|output_offset
operator|+
literal|6
operator|)
expr_stmt|;
name|rela
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|hgot
operator|->
name|indx
argument_list|,
name|R_PPC_ADDR16_LO
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rela
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|loc
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
comment|/* Fix up the remaining relocations.  They may have the wrong 	     symbol index for _G_O_T_ or _P_L_T_ depending on the order 	     in which symbols were output.  */
while|while
condition|(
name|loc
operator|<
name|htab
operator|->
name|srelplt2
operator|->
name|contents
operator|+
name|htab
operator|->
name|srelplt2
operator|->
name|size
condition|)
block|{
name|Elf_Internal_Rela
name|rel
decl_stmt|;
name|bfd_elf32_swap_reloc_in
argument_list|(
name|output_bfd
argument_list|,
name|loc
argument_list|,
operator|&
name|rel
argument_list|)
expr_stmt|;
name|rel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|hgot
operator|->
name|indx
argument_list|,
name|R_PPC_ADDR16_HA
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloc_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|loc
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloc_in
argument_list|(
name|output_bfd
argument_list|,
name|loc
argument_list|,
operator|&
name|rel
argument_list|)
expr_stmt|;
name|rel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|hgot
operator|->
name|indx
argument_list|,
name|R_PPC_ADDR16_LO
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloc_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|loc
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloc_in
argument_list|(
name|output_bfd
argument_list|,
name|loc
argument_list|,
operator|&
name|rel
argument_list|)
expr_stmt|;
name|rel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|hplt
operator|->
name|indx
argument_list|,
name|R_PPC_ADDR32
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloc_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|loc
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|htab
operator|->
name|glink
operator|!=
name|NULL
operator|&&
name|htab
operator|->
name|glink
operator|->
name|contents
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|char
modifier|*
name|endp
decl_stmt|;
name|bfd_vma
name|res0
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
comment|/*        * PIC glink code is the following:        *        * # ith PLT code stub.        *   addis 11,30,(plt+(i-1)*4-got)@ha        *   lwz 11,(plt+(i-1)*4-got)@l(11)        *   mtctr 11        *   bctr        *        * # A table of branches, one for each plt entry.        * # The idea is that the plt call stub loads ctr (and r11) with these        * # addresses, so (r11 - res_0) gives the plt index * 4.        * res_0:	b PLTresolve        * res_1:	b PLTresolve        * .        * # Some number of entries towards the end can be nops        * res_n_m3: nop        * res_n_m2: nop        * res_n_m1:        *        * PLTresolve:        *    addis 11,11,(1f-res_0)@ha        *    mflr 0        *    bcl 20,31,1f        * 1: addi 11,11,(1b-res_0)@l        *    mflr 12        *    mtlr 0        *    sub 11,11,12                # r11 = index * 4        *    addis 12,12,(got+4-1b)@ha        *    lwz 0,(got+4-1b)@l(12)      # got[1] address of dl_runtime_resolve        *    lwz 12,(got+8-1b)@l(12)     # got[2] contains the map address        *    mtctr 0        *    add 0,11,11        *    add 11,0,11                 # r11 = index * 12 = reloc offset.        *    bctr        */
specifier|static
specifier|const
name|unsigned
name|int
name|pic_plt_resolve
index|[]
init|=
block|{
name|ADDIS_11_11
block|,
name|MFLR_0
block|,
name|BCL_20_31
block|,
name|ADDI_11_11
block|,
name|MFLR_12
block|,
name|MTLR_0
block|,
name|SUB_11_11_12
block|,
name|ADDIS_12_12
block|,
name|LWZ_0_12
block|,
name|LWZ_12_12
block|,
name|MTCTR_0
block|,
name|ADD_0_11_11
block|,
name|ADD_11_0_11
block|,
name|BCTR
block|,
name|NOP
block|,
name|NOP
block|}
decl_stmt|;
specifier|static
specifier|const
name|unsigned
name|int
name|plt_resolve
index|[]
init|=
block|{
name|LIS_12
block|,
name|ADDIS_11_11
block|,
name|LWZ_0_12
block|,
name|ADDI_11_11
block|,
name|MTCTR_0
block|,
name|ADD_0_11_11
block|,
name|LWZ_12_12
block|,
name|ADD_11_0_11
block|,
name|BCTR
block|,
name|NOP
block|,
name|NOP
block|,
name|NOP
block|,
name|NOP
block|,
name|NOP
block|,
name|NOP
block|,
name|NOP
block|}
decl_stmt|;
if|if
condition|(
name|ARRAY_SIZE
argument_list|(
name|pic_plt_resolve
argument_list|)
operator|!=
name|GLINK_PLTRESOLVE
operator|/
literal|4
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|ARRAY_SIZE
argument_list|(
name|plt_resolve
argument_list|)
operator|!=
name|GLINK_PLTRESOLVE
operator|/
literal|4
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Build the branch table, one for each plt entry (less one), 	 and perhaps some padding.  */
name|p
operator|=
name|htab
operator|->
name|glink
operator|->
name|contents
expr_stmt|;
name|p
operator|+=
name|htab
operator|->
name|glink_pltresolve
expr_stmt|;
name|endp
operator|=
name|htab
operator|->
name|glink
operator|->
name|contents
expr_stmt|;
name|endp
operator|+=
name|htab
operator|->
name|glink
operator|->
name|size
operator|-
name|GLINK_PLTRESOLVE
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|endp
operator|-
literal|8
operator|*
literal|4
condition|)
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|B
operator|+
name|endp
operator|-
name|p
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
block|}
while|while
condition|(
name|p
operator|<
name|endp
condition|)
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|NOP
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
block|}
name|res0
operator|=
operator|(
name|htab
operator|->
name|glink_pltresolve
operator|+
name|htab
operator|->
name|glink
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|glink
operator|->
name|output_offset
operator|)
expr_stmt|;
comment|/* Last comes the PLTresolve stub.  */
if|if
condition|(
name|info
operator|->
name|shared
operator|||
name|info
operator|->
name|pie
condition|)
block|{
name|bfd_vma
name|bcl
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|pic_plt_resolve
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|pic_plt_resolve
index|[
name|i
index|]
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
block|}
name|p
operator|-=
literal|4
operator|*
name|ARRAY_SIZE
argument_list|(
name|pic_plt_resolve
argument_list|)
expr_stmt|;
name|bcl
operator|=
operator|(
name|htab
operator|->
name|glink
operator|->
name|size
operator|-
name|GLINK_PLTRESOLVE
operator|+
literal|3
operator|*
literal|4
operator|+
name|htab
operator|->
name|glink
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|glink
operator|->
name|output_offset
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|ADDIS_11_11
operator|+
name|PPC_HA
argument_list|(
name|bcl
operator|-
name|res0
argument_list|)
argument_list|,
name|p
operator|+
literal|0
operator|*
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|ADDI_11_11
operator|+
name|PPC_LO
argument_list|(
name|bcl
operator|-
name|res0
argument_list|)
argument_list|,
name|p
operator|+
literal|3
operator|*
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|ADDIS_12_12
operator|+
name|PPC_HA
argument_list|(
name|got
operator|+
literal|4
operator|-
name|bcl
argument_list|)
argument_list|,
name|p
operator|+
literal|7
operator|*
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|PPC_HA
argument_list|(
name|got
operator|+
literal|4
operator|-
name|bcl
argument_list|)
operator|==
name|PPC_HA
argument_list|(
name|got
operator|+
literal|8
operator|-
name|bcl
argument_list|)
condition|)
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|LWZ_0_12
operator|+
name|PPC_LO
argument_list|(
name|got
operator|+
literal|4
operator|-
name|bcl
argument_list|)
argument_list|,
name|p
operator|+
literal|8
operator|*
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|LWZ_12_12
operator|+
name|PPC_LO
argument_list|(
name|got
operator|+
literal|8
operator|-
name|bcl
argument_list|)
argument_list|,
name|p
operator|+
literal|9
operator|*
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|LWZU_0_12
operator|+
name|PPC_LO
argument_list|(
name|got
operator|+
literal|4
operator|-
name|bcl
argument_list|)
argument_list|,
name|p
operator|+
literal|8
operator|*
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|LWZ_12_12
operator|+
literal|4
argument_list|,
name|p
operator|+
literal|9
operator|*
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|plt_resolve
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|plt_resolve
index|[
name|i
index|]
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
block|}
name|p
operator|-=
literal|4
operator|*
name|ARRAY_SIZE
argument_list|(
name|plt_resolve
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|LIS_12
operator|+
name|PPC_HA
argument_list|(
name|got
operator|+
literal|4
argument_list|)
argument_list|,
name|p
operator|+
literal|0
operator|*
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|ADDIS_11_11
operator|+
name|PPC_HA
argument_list|(
operator|-
name|res0
argument_list|)
argument_list|,
name|p
operator|+
literal|1
operator|*
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|ADDI_11_11
operator|+
name|PPC_LO
argument_list|(
operator|-
name|res0
argument_list|)
argument_list|,
name|p
operator|+
literal|3
operator|*
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|PPC_HA
argument_list|(
name|got
operator|+
literal|4
argument_list|)
operator|==
name|PPC_HA
argument_list|(
name|got
operator|+
literal|8
argument_list|)
condition|)
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|LWZ_0_12
operator|+
name|PPC_LO
argument_list|(
name|got
operator|+
literal|4
argument_list|)
argument_list|,
name|p
operator|+
literal|2
operator|*
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|LWZ_12_12
operator|+
name|PPC_LO
argument_list|(
name|got
operator|+
literal|8
argument_list|)
argument_list|,
name|p
operator|+
literal|6
operator|*
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|LWZU_0_12
operator|+
name|PPC_LO
argument_list|(
name|got
operator|+
literal|4
argument_list|)
argument_list|,
name|p
operator|+
literal|2
operator|*
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|LWZ_12_12
operator|+
literal|4
argument_list|,
name|p
operator|+
literal|6
operator|*
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|TARGET_LITTLE_SYM
value|bfd_elf32_powerpcle_vec
end_define

begin_define
define|#
directive|define
name|TARGET_LITTLE_NAME
value|"elf32-powerpcle"
end_define

begin_define
define|#
directive|define
name|TARGET_BIG_SYM
value|bfd_elf32_powerpc_vec
end_define

begin_define
define|#
directive|define
name|TARGET_BIG_NAME
value|"elf32-powerpc-freebsd"
end_define

begin_define
define|#
directive|define
name|ELF_ARCH
value|bfd_arch_powerpc
end_define

begin_define
define|#
directive|define
name|ELF_MACHINE_CODE
value|EM_PPC
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__QNXTARGET__
end_ifdef

begin_define
define|#
directive|define
name|ELF_MAXPAGESIZE
value|0x1000
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ELF_MAXPAGESIZE
value|0x10000
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ELF_MINPAGESIZE
value|0x1000
end_define

begin_define
define|#
directive|define
name|ELF_COMMONPAGESIZE
value|0x1000
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto
value|ppc_elf_info_to_howto
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|EM_CYGNUS_POWERPC
end_ifdef

begin_define
define|#
directive|define
name|ELF_MACHINE_ALT1
value|EM_CYGNUS_POWERPC
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EM_PPC_OLD
end_ifdef

begin_define
define|#
directive|define
name|ELF_MACHINE_ALT2
value|EM_PPC_OLD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|elf_backend_plt_not_loaded
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_can_gc_sections
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_can_refcount
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_rela_normal
value|1
end_define

begin_define
define|#
directive|define
name|bfd_elf32_mkobject
value|ppc_elf_mkobject
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_merge_private_bfd_data
value|ppc_elf_merge_private_bfd_data
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_relax_section
value|ppc_elf_relax_section
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_reloc_type_lookup
value|ppc_elf_reloc_type_lookup
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_reloc_name_lookup
value|ppc_elf_reloc_name_lookup
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_set_private_flags
value|ppc_elf_set_private_flags
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_link_hash_table_create
value|ppc_elf_link_hash_table_create
end_define

begin_define
define|#
directive|define
name|elf_backend_object_p
value|ppc_elf_object_p
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_mark_hook
value|ppc_elf_gc_mark_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_sweep_hook
value|ppc_elf_gc_sweep_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_section_from_shdr
value|ppc_elf_section_from_shdr
end_define

begin_define
define|#
directive|define
name|elf_backend_relocate_section
value|ppc_elf_relocate_section
end_define

begin_define
define|#
directive|define
name|elf_backend_create_dynamic_sections
value|ppc_elf_create_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_check_relocs
value|ppc_elf_check_relocs
end_define

begin_define
define|#
directive|define
name|elf_backend_copy_indirect_symbol
value|ppc_elf_copy_indirect_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_adjust_dynamic_symbol
value|ppc_elf_adjust_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_add_symbol_hook
value|ppc_elf_add_symbol_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_size_dynamic_sections
value|ppc_elf_size_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_symbol
value|ppc_elf_finish_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_sections
value|ppc_elf_finish_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_fake_sections
value|ppc_elf_fake_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_additional_program_headers
value|ppc_elf_additional_program_headers
end_define

begin_define
define|#
directive|define
name|elf_backend_grok_prstatus
value|ppc_elf_grok_prstatus
end_define

begin_define
define|#
directive|define
name|elf_backend_grok_psinfo
value|ppc_elf_grok_psinfo
end_define

begin_define
define|#
directive|define
name|elf_backend_write_core_note
value|ppc_elf_write_core_note
end_define

begin_define
define|#
directive|define
name|elf_backend_reloc_type_class
value|ppc_elf_reloc_type_class
end_define

begin_define
define|#
directive|define
name|elf_backend_begin_write_processing
value|ppc_elf_begin_write_processing
end_define

begin_define
define|#
directive|define
name|elf_backend_final_write_processing
value|ppc_elf_final_write_processing
end_define

begin_define
define|#
directive|define
name|elf_backend_write_section
value|ppc_elf_write_section
end_define

begin_define
define|#
directive|define
name|elf_backend_get_sec_type_attr
value|ppc_elf_get_sec_type_attr
end_define

begin_define
define|#
directive|define
name|elf_backend_plt_sym_val
value|ppc_elf_plt_sym_val
end_define

begin_define
define|#
directive|define
name|elf_backend_action_discarded
value|ppc_elf_action_discarded
end_define

begin_define
define|#
directive|define
name|elf_backend_init_index_section
value|_bfd_elf_init_1_index_section
end_define

begin_include
include|#
directive|include
file|"elf32-target.h"
end_include

begin_comment
comment|/* VxWorks Target */
end_comment

begin_undef
undef|#
directive|undef
name|TARGET_LITTLE_SYM
end_undef

begin_undef
undef|#
directive|undef
name|TARGET_LITTLE_NAME
end_undef

begin_undef
undef|#
directive|undef
name|TARGET_BIG_SYM
end_undef

begin_define
define|#
directive|define
name|TARGET_BIG_SYM
value|bfd_elf32_powerpc_vxworks_vec
end_define

begin_undef
undef|#
directive|undef
name|TARGET_BIG_NAME
end_undef

begin_define
define|#
directive|define
name|TARGET_BIG_NAME
value|"elf32-powerpc-vxworks"
end_define

begin_comment
comment|/* VxWorks uses the elf default section flags for .plt.  */
end_comment

begin_function
specifier|static
specifier|const
name|struct
name|bfd_elf_special_section
modifier|*
name|ppc_elf_vxworks_get_sec_type_attr
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|)
block|{
if|if
condition|(
name|sec
operator|->
name|name
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
literal|".plt"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|_bfd_elf_get_sec_type_attr
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
return|;
return|return
name|ppc_elf_get_sec_type_attr
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Like ppc_elf_link_hash_table_create, but overrides    appropriately for VxWorks.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_link_hash_table
modifier|*
name|ppc_elf_vxworks_link_hash_table_create
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|struct
name|bfd_link_hash_table
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
name|ppc_elf_link_hash_table_create
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|struct
name|ppc_elf_link_hash_table
modifier|*
name|htab
init|=
operator|(
expr|struct
name|ppc_elf_link_hash_table
operator|*
operator|)
name|ret
decl_stmt|;
name|htab
operator|->
name|is_vxworks
operator|=
literal|1
expr_stmt|;
name|htab
operator|->
name|plt_type
operator|=
name|PLT_VXWORKS
expr_stmt|;
name|htab
operator|->
name|plt_entry_size
operator|=
name|VXWORKS_PLT_ENTRY_SIZE
expr_stmt|;
name|htab
operator|->
name|plt_slot_size
operator|=
name|VXWORKS_PLT_ENTRY_SIZE
expr_stmt|;
name|htab
operator|->
name|plt_initial_entry_size
operator|=
name|VXWORKS_PLT_INITIAL_ENTRY_SIZE
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Tweak magic VxWorks symbols as they are loaded.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ppc_elf_vxworks_add_symbol_hook
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|namep
name|ATTRIBUTE_UNUSED
parameter_list|,
name|flagword
modifier|*
name|flagsp
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
modifier|*
name|secp
parameter_list|,
name|bfd_vma
modifier|*
name|valp
parameter_list|)
block|{
if|if
condition|(
operator|!
name|elf_vxworks_add_symbol_hook
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|sym
argument_list|,
name|namep
argument_list|,
name|flagsp
argument_list|,
name|secp
argument_list|,
name|valp
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
name|ppc_elf_add_symbol_hook
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|sym
argument_list|,
name|namep
argument_list|,
name|flagsp
argument_list|,
name|secp
argument_list|,
name|valp
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ppc_elf_vxworks_final_write_processing
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_boolean
name|linker
parameter_list|)
block|{
name|ppc_elf_final_write_processing
argument_list|(
name|abfd
argument_list|,
name|linker
argument_list|)
expr_stmt|;
name|elf_vxworks_final_write_processing
argument_list|(
name|abfd
argument_list|,
name|linker
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* On VxWorks, we emit relocations against _PROCEDURE_LINKAGE_TABLE_, so    define it.  */
end_comment

begin_undef
undef|#
directive|undef
name|elf_backend_want_plt_sym
end_undef

begin_define
define|#
directive|define
name|elf_backend_want_plt_sym
value|1
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_want_got_plt
end_undef

begin_define
define|#
directive|define
name|elf_backend_want_got_plt
value|1
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_got_symbol_offset
end_undef

begin_define
define|#
directive|define
name|elf_backend_got_symbol_offset
value|0
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_plt_not_loaded
end_undef

begin_define
define|#
directive|define
name|elf_backend_plt_not_loaded
value|0
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_plt_readonly
end_undef

begin_define
define|#
directive|define
name|elf_backend_plt_readonly
value|1
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_got_header_size
end_undef

begin_define
define|#
directive|define
name|elf_backend_got_header_size
value|12
end_define

begin_undef
undef|#
directive|undef
name|bfd_elf32_bfd_link_hash_table_create
end_undef

begin_define
define|#
directive|define
name|bfd_elf32_bfd_link_hash_table_create
define|\
value|ppc_elf_vxworks_link_hash_table_create
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_add_symbol_hook
end_undef

begin_define
define|#
directive|define
name|elf_backend_add_symbol_hook
define|\
value|ppc_elf_vxworks_add_symbol_hook
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_link_output_symbol_hook
end_undef

begin_define
define|#
directive|define
name|elf_backend_link_output_symbol_hook
define|\
value|elf_vxworks_link_output_symbol_hook
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_final_write_processing
end_undef

begin_define
define|#
directive|define
name|elf_backend_final_write_processing
define|\
value|ppc_elf_vxworks_final_write_processing
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_get_sec_type_attr
end_undef

begin_define
define|#
directive|define
name|elf_backend_get_sec_type_attr
define|\
value|ppc_elf_vxworks_get_sec_type_attr
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_emit_relocs
end_undef

begin_define
define|#
directive|define
name|elf_backend_emit_relocs
define|\
value|elf_vxworks_emit_relocs
end_define

begin_undef
undef|#
directive|undef
name|elf32_bed
end_undef

begin_define
define|#
directive|define
name|elf32_bed
value|ppc_elf_vxworks_bed
end_define

begin_include
include|#
directive|include
file|"elf32-target.h"
end_include

end_unit

