begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* SPARC-specific support for ELF    Copyright 2005, 2006, 2007 Free Software Foundation, Inc.     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* This file handles functionality common to the different SPARC ABI's.  */
end_comment

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf/sparc.h"
end_include

begin_include
include|#
directive|include
file|"opcode/sparc.h"
end_include

begin_include
include|#
directive|include
file|"elfxx-sparc.h"
end_include

begin_include
include|#
directive|include
file|"elf-vxworks.h"
end_include

begin_comment
comment|/* In case we're on a 32-bit machine, construct a 64-bit "-1" value.  */
end_comment

begin_define
define|#
directive|define
name|MINUS_ONE
value|(~ (bfd_vma) 0)
end_define

begin_define
define|#
directive|define
name|ABI_64_P
parameter_list|(
name|abfd
parameter_list|)
define|\
value|(get_elf_backend_data (abfd)->s->elfclass == ELFCLASS64)
end_define

begin_comment
comment|/* The relocation "howto" table.  */
end_comment

begin_comment
comment|/* Utility for performing the standard initial work of an instruction    relocation.    *PRELOCATION will contain the relocated item.    *PINSN will contain the instruction from the input stream.    If the result is `bfd_reloc_other' the caller can continue with    performing the relocation.  Otherwise it must stop and return the    value to its caller.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|init_insn_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|PTR
name|data
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|bfd_vma
modifier|*
name|prelocation
parameter_list|,
name|bfd_vma
modifier|*
name|pinsn
parameter_list|)
block|{
name|bfd_vma
name|relocation
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
init|=
name|reloc_entry
operator|->
name|howto
decl_stmt|;
if|if
condition|(
name|output_bfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
operator|&&
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|!
name|howto
operator|->
name|partial_inplace
operator|||
name|reloc_entry
operator|->
name|addend
operator|==
literal|0
operator|)
condition|)
block|{
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
comment|/* This works because partial_inplace is FALSE.  */
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
condition|)
return|return
name|bfd_reloc_continue
return|;
if|if
condition|(
name|reloc_entry
operator|->
name|address
operator|>
name|bfd_get_section_limit
argument_list|(
name|abfd
argument_list|,
name|input_section
argument_list|)
condition|)
return|return
name|bfd_reloc_outofrange
return|;
name|relocation
operator|=
operator|(
name|symbol
operator|->
name|value
operator|+
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|symbol
operator|->
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|relocation
operator|+=
name|reloc_entry
operator|->
name|addend
expr_stmt|;
if|if
condition|(
name|howto
operator|->
name|pc_relative
condition|)
block|{
name|relocation
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|relocation
operator|-=
name|reloc_entry
operator|->
name|address
expr_stmt|;
block|}
operator|*
name|prelocation
operator|=
name|relocation
expr_stmt|;
operator|*
name|pinsn
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_other
return|;
block|}
end_function

begin_comment
comment|/* For unsupported relocs.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|sparc_elf_notsup_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asymbol
modifier|*
name|symbol
name|ATTRIBUTE_UNUSED
parameter_list|,
name|PTR
name|data
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|input_section
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|bfd_reloc_notsupported
return|;
block|}
end_function

begin_comment
comment|/* Handle the WDISP16 reloc.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|sparc_elf_wdisp16_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|PTR
name|data
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_vma
name|insn
decl_stmt|;
name|bfd_reloc_status_type
name|status
decl_stmt|;
name|status
operator|=
name|init_insn_reloc
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
argument_list|,
name|symbol
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
operator|&
name|relocation
argument_list|,
operator|&
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|bfd_reloc_other
condition|)
return|return
name|status
return|;
name|insn
operator|&=
operator|~
operator|(
name|bfd_vma
operator|)
literal|0x303fff
expr_stmt|;
name|insn
operator||=
operator|(
operator|(
operator|(
name|relocation
operator|>>
literal|2
operator|)
operator|&
literal|0xc000
operator|)
operator|<<
literal|6
operator|)
operator||
operator|(
operator|(
name|relocation
operator|>>
literal|2
operator|)
operator|&
literal|0x3fff
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|insn
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bfd_signed_vma
operator|)
name|relocation
operator|<
operator|-
literal|0x40000
operator|||
operator|(
name|bfd_signed_vma
operator|)
name|relocation
operator|>
literal|0x3ffff
condition|)
return|return
name|bfd_reloc_overflow
return|;
else|else
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_comment
comment|/* Handle the HIX22 reloc.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|sparc_elf_hix22_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|PTR
name|data
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_vma
name|insn
decl_stmt|;
name|bfd_reloc_status_type
name|status
decl_stmt|;
name|status
operator|=
name|init_insn_reloc
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
argument_list|,
name|symbol
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
operator|&
name|relocation
argument_list|,
operator|&
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|bfd_reloc_other
condition|)
return|return
name|status
return|;
name|relocation
operator|^=
name|MINUS_ONE
expr_stmt|;
name|insn
operator|=
operator|(
name|insn
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
literal|0x3fffff
operator|)
operator||
operator|(
operator|(
name|relocation
operator|>>
literal|10
operator|)
operator|&
literal|0x3fffff
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|insn
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|relocation
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
literal|0xffffffff
operator|)
operator|!=
literal|0
condition|)
return|return
name|bfd_reloc_overflow
return|;
else|else
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_comment
comment|/* Handle the LOX10 reloc.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|sparc_elf_lox10_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|PTR
name|data
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_vma
name|insn
decl_stmt|;
name|bfd_reloc_status_type
name|status
decl_stmt|;
name|status
operator|=
name|init_insn_reloc
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
argument_list|,
name|symbol
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
operator|&
name|relocation
argument_list|,
operator|&
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|bfd_reloc_other
condition|)
return|return
name|status
return|;
name|insn
operator|=
operator|(
name|insn
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
literal|0x1fff
operator|)
operator||
literal|0x1c00
operator||
operator|(
name|relocation
operator|&
literal|0x3ff
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|insn
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|_bfd_sparc_elf_howto_table
index|[]
init|=
block|{
name|HOWTO
argument_list|(
name|R_SPARC_NONE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_NONE"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x00000000
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_8
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_8"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x000000ff
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_16
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_16"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x0000ffff
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_32
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_32"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_DISP8
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_DISP8"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x000000ff
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_DISP16
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_DISP16"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x0000ffff
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_DISP32
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_DISP32"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_WDISP30
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|30
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_WDISP30"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x3fffffff
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_WDISP22
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|22
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_WDISP22"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x003fffff
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_HI22
argument_list|,
literal|10
argument_list|,
literal|2
argument_list|,
literal|22
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_HI22"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x003fffff
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_22
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|22
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_22"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x003fffff
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_13
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|13
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_13"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x00001fff
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_LO10
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_LO10"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x000003ff
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_GOT10
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_GOT10"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x000003ff
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_GOT13
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|13
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_GOT13"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x00001fff
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_GOT22
argument_list|,
literal|10
argument_list|,
literal|2
argument_list|,
literal|22
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_GOT22"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x003fffff
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_PC10
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_PC10"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x000003ff
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_PC22
argument_list|,
literal|10
argument_list|,
literal|2
argument_list|,
literal|22
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_PC22"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x003fffff
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_WPLT30
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|30
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_WPLT30"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x3fffffff
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_COPY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|00
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_COPY"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x00000000
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_GLOB_DAT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|00
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_GLOB_DAT"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x00000000
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_JMP_SLOT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|00
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_JMP_SLOT"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x00000000
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_RELATIVE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|00
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_RELATIVE"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x00000000
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_UA32
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_UA32"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_PLT32
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_PLT32"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_HIPLT22
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|00
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|sparc_elf_notsup_reloc
argument_list|,
literal|"R_SPARC_HIPLT22"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x00000000
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_LOPLT10
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|00
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|sparc_elf_notsup_reloc
argument_list|,
literal|"R_SPARC_LOPLT10"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x00000000
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_PCPLT32
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|00
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|sparc_elf_notsup_reloc
argument_list|,
literal|"R_SPARC_PCPLT32"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x00000000
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_PCPLT22
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|00
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|sparc_elf_notsup_reloc
argument_list|,
literal|"R_SPARC_PCPLT22"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x00000000
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_PCPLT10
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|00
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|sparc_elf_notsup_reloc
argument_list|,
literal|"R_SPARC_PCPLT10"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x00000000
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_10
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_10"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x000003ff
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_11
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|11
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_11"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x000007ff
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_64
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|,
literal|64
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_64"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|MINUS_ONE
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_OLO10
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|13
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
name|sparc_elf_notsup_reloc
argument_list|,
literal|"R_SPARC_OLO10"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x00001fff
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_HH22
argument_list|,
literal|42
argument_list|,
literal|2
argument_list|,
literal|22
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_unsigned
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_HH22"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x003fffff
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_HM10
argument_list|,
literal|32
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_HM10"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x000003ff
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_LM22
argument_list|,
literal|10
argument_list|,
literal|2
argument_list|,
literal|22
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_LM22"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x003fffff
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_PC_HH22
argument_list|,
literal|42
argument_list|,
literal|2
argument_list|,
literal|22
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_unsigned
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_PC_HH22"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x003fffff
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_PC_HM10
argument_list|,
literal|32
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_PC_HM10"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x000003ff
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_PC_LM22
argument_list|,
literal|10
argument_list|,
literal|2
argument_list|,
literal|22
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_PC_LM22"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x003fffff
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_WDISP16
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|16
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
name|sparc_elf_wdisp16_reloc
argument_list|,
literal|"R_SPARC_WDISP16"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x00000000
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_WDISP19
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|19
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_WDISP19"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x0007ffff
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_UNUSED_42
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_UNUSED_42"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x00000000
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_7
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|7
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_7"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x0000007f
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_5
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|5
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_5"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x0000001f
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_6
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|6
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_6"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x0000003f
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_DISP64
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|,
literal|64
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_DISP64"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|MINUS_ONE
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_PLT64
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|,
literal|64
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_PLT64"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|MINUS_ONE
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_HIX22
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|sparc_elf_hix22_reloc
argument_list|,
literal|"R_SPARC_HIX22"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|MINUS_ONE
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_LOX10
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|sparc_elf_lox10_reloc
argument_list|,
literal|"R_SPARC_LOX10"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|MINUS_ONE
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_H44
argument_list|,
literal|22
argument_list|,
literal|2
argument_list|,
literal|22
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_unsigned
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_H44"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x003fffff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_M44
argument_list|,
literal|12
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_M44"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x000003ff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_L44
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|13
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_L44"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x00000fff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_REGISTER
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|sparc_elf_notsup_reloc
argument_list|,
literal|"R_SPARC_REGISTER"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|MINUS_ONE
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_UA64
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|,
literal|64
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_UA64"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|MINUS_ONE
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_UA16
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_UA16"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x0000ffff
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_TLS_GD_HI22
argument_list|,
literal|10
argument_list|,
literal|2
argument_list|,
literal|22
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_TLS_GD_HI22"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x003fffff
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_TLS_GD_LO10
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_TLS_GD_LO10"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x000003ff
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_TLS_GD_ADD
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_TLS_GD_ADD"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x00000000
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_TLS_GD_CALL
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|30
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_TLS_GD_CALL"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x3fffffff
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_TLS_LDM_HI22
argument_list|,
literal|10
argument_list|,
literal|2
argument_list|,
literal|22
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_TLS_LDM_HI22"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x003fffff
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_TLS_LDM_LO10
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_TLS_LDM_LO10"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x000003ff
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_TLS_LDM_ADD
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_TLS_LDM_ADD"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x00000000
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_TLS_LDM_CALL
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|30
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_TLS_LDM_CALL"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x3fffffff
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_TLS_LDO_HIX22
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|sparc_elf_hix22_reloc
argument_list|,
literal|"R_SPARC_TLS_LDO_HIX22"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x003fffff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_TLS_LDO_LOX10
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|sparc_elf_lox10_reloc
argument_list|,
literal|"R_SPARC_TLS_LDO_LOX10"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x000003ff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_TLS_LDO_ADD
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_TLS_LDO_ADD"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x00000000
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_TLS_IE_HI22
argument_list|,
literal|10
argument_list|,
literal|2
argument_list|,
literal|22
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_TLS_IE_HI22"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x003fffff
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_TLS_IE_LO10
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|10
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_TLS_IE_LO10"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x000003ff
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_TLS_IE_LD
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_TLS_IE_LD"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x00000000
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_TLS_IE_LDX
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_TLS_IE_LDX"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x00000000
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_TLS_IE_ADD
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_TLS_IE_ADD"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x00000000
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_TLS_LE_HIX22
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|sparc_elf_hix22_reloc
argument_list|,
literal|"R_SPARC_TLS_LE_HIX22"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x003fffff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_TLS_LE_LOX10
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|sparc_elf_lox10_reloc
argument_list|,
literal|"R_SPARC_TLS_LE_LOX10"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x000003ff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_TLS_DTPMOD32
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_TLS_DTPMOD32"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x00000000
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_TLS_DTPMOD64
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_TLS_DTPMOD64"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x00000000
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_TLS_DTPOFF32
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_TLS_DTPOFF32"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_TLS_DTPOFF64
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|,
literal|64
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_TLS_DTPOFF64"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|MINUS_ONE
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_SPARC_TLS_TPOFF32
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_TLS_TPOFF32"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x00000000
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
argument|R_SPARC_TLS_TPOFF64
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
argument|FALSE
argument_list|,
literal|0
argument_list|,
argument|complain_overflow_dont
argument_list|,
argument|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_TLS_TPOFF64"
argument_list|,
argument|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x00000000
argument_list|,
argument|TRUE
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|sparc_vtinherit_howto
init|=
name|HOWTO
argument_list|(
name|R_SPARC_GNU_VTINHERIT
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|NULL
argument_list|,
literal|"R_SPARC_GNU_VTINHERIT"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|sparc_vtentry_howto
init|=
name|HOWTO
argument_list|(
name|R_SPARC_GNU_VTENTRY
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|_bfd_elf_rel_vtable_reloc_fn
argument_list|,
literal|"R_SPARC_GNU_VTENTRY"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|sparc_rev32_howto
init|=
name|HOWTO
argument_list|(
name|R_SPARC_REV32
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_SPARC_REV32"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
name|TRUE
argument_list|)
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|elf_reloc_map
block|{
name|bfd_reloc_code_real_type
name|bfd_reloc_val
decl_stmt|;
name|unsigned
name|char
name|elf_reloc_val
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|elf_reloc_map
name|sparc_reloc_map
index|[]
init|=
block|{
block|{
name|BFD_RELOC_NONE
block|,
name|R_SPARC_NONE
block|, }
block|,
block|{
name|BFD_RELOC_16
block|,
name|R_SPARC_16
block|, }
block|,
block|{
name|BFD_RELOC_16_PCREL
block|,
name|R_SPARC_DISP16
block|}
block|,
block|{
name|BFD_RELOC_8
block|,
name|R_SPARC_8
block|}
block|,
block|{
name|BFD_RELOC_8_PCREL
block|,
name|R_SPARC_DISP8
block|}
block|,
block|{
name|BFD_RELOC_CTOR
block|,
name|R_SPARC_64
block|}
block|,
block|{
name|BFD_RELOC_32
block|,
name|R_SPARC_32
block|}
block|,
block|{
name|BFD_RELOC_32_PCREL
block|,
name|R_SPARC_DISP32
block|}
block|,
block|{
name|BFD_RELOC_HI22
block|,
name|R_SPARC_HI22
block|}
block|,
block|{
name|BFD_RELOC_LO10
block|,
name|R_SPARC_LO10
block|, }
block|,
block|{
name|BFD_RELOC_32_PCREL_S2
block|,
name|R_SPARC_WDISP30
block|}
block|,
block|{
name|BFD_RELOC_64_PCREL
block|,
name|R_SPARC_DISP64
block|}
block|,
block|{
name|BFD_RELOC_SPARC22
block|,
name|R_SPARC_22
block|}
block|,
block|{
name|BFD_RELOC_SPARC13
block|,
name|R_SPARC_13
block|}
block|,
block|{
name|BFD_RELOC_SPARC_GOT10
block|,
name|R_SPARC_GOT10
block|}
block|,
block|{
name|BFD_RELOC_SPARC_GOT13
block|,
name|R_SPARC_GOT13
block|}
block|,
block|{
name|BFD_RELOC_SPARC_GOT22
block|,
name|R_SPARC_GOT22
block|}
block|,
block|{
name|BFD_RELOC_SPARC_PC10
block|,
name|R_SPARC_PC10
block|}
block|,
block|{
name|BFD_RELOC_SPARC_PC22
block|,
name|R_SPARC_PC22
block|}
block|,
block|{
name|BFD_RELOC_SPARC_WPLT30
block|,
name|R_SPARC_WPLT30
block|}
block|,
block|{
name|BFD_RELOC_SPARC_COPY
block|,
name|R_SPARC_COPY
block|}
block|,
block|{
name|BFD_RELOC_SPARC_GLOB_DAT
block|,
name|R_SPARC_GLOB_DAT
block|}
block|,
block|{
name|BFD_RELOC_SPARC_JMP_SLOT
block|,
name|R_SPARC_JMP_SLOT
block|}
block|,
block|{
name|BFD_RELOC_SPARC_RELATIVE
block|,
name|R_SPARC_RELATIVE
block|}
block|,
block|{
name|BFD_RELOC_SPARC_WDISP22
block|,
name|R_SPARC_WDISP22
block|}
block|,
block|{
name|BFD_RELOC_SPARC_UA16
block|,
name|R_SPARC_UA16
block|}
block|,
block|{
name|BFD_RELOC_SPARC_UA32
block|,
name|R_SPARC_UA32
block|}
block|,
block|{
name|BFD_RELOC_SPARC_UA64
block|,
name|R_SPARC_UA64
block|}
block|,
block|{
name|BFD_RELOC_SPARC_10
block|,
name|R_SPARC_10
block|}
block|,
block|{
name|BFD_RELOC_SPARC_11
block|,
name|R_SPARC_11
block|}
block|,
block|{
name|BFD_RELOC_SPARC_64
block|,
name|R_SPARC_64
block|}
block|,
block|{
name|BFD_RELOC_SPARC_OLO10
block|,
name|R_SPARC_OLO10
block|}
block|,
block|{
name|BFD_RELOC_SPARC_HH22
block|,
name|R_SPARC_HH22
block|}
block|,
block|{
name|BFD_RELOC_SPARC_HM10
block|,
name|R_SPARC_HM10
block|}
block|,
block|{
name|BFD_RELOC_SPARC_LM22
block|,
name|R_SPARC_LM22
block|}
block|,
block|{
name|BFD_RELOC_SPARC_PC_HH22
block|,
name|R_SPARC_PC_HH22
block|}
block|,
block|{
name|BFD_RELOC_SPARC_PC_HM10
block|,
name|R_SPARC_PC_HM10
block|}
block|,
block|{
name|BFD_RELOC_SPARC_PC_LM22
block|,
name|R_SPARC_PC_LM22
block|}
block|,
block|{
name|BFD_RELOC_SPARC_WDISP16
block|,
name|R_SPARC_WDISP16
block|}
block|,
block|{
name|BFD_RELOC_SPARC_WDISP19
block|,
name|R_SPARC_WDISP19
block|}
block|,
block|{
name|BFD_RELOC_SPARC_7
block|,
name|R_SPARC_7
block|}
block|,
block|{
name|BFD_RELOC_SPARC_5
block|,
name|R_SPARC_5
block|}
block|,
block|{
name|BFD_RELOC_SPARC_6
block|,
name|R_SPARC_6
block|}
block|,
block|{
name|BFD_RELOC_SPARC_DISP64
block|,
name|R_SPARC_DISP64
block|}
block|,
block|{
name|BFD_RELOC_SPARC_TLS_GD_HI22
block|,
name|R_SPARC_TLS_GD_HI22
block|}
block|,
block|{
name|BFD_RELOC_SPARC_TLS_GD_LO10
block|,
name|R_SPARC_TLS_GD_LO10
block|}
block|,
block|{
name|BFD_RELOC_SPARC_TLS_GD_ADD
block|,
name|R_SPARC_TLS_GD_ADD
block|}
block|,
block|{
name|BFD_RELOC_SPARC_TLS_GD_CALL
block|,
name|R_SPARC_TLS_GD_CALL
block|}
block|,
block|{
name|BFD_RELOC_SPARC_TLS_LDM_HI22
block|,
name|R_SPARC_TLS_LDM_HI22
block|}
block|,
block|{
name|BFD_RELOC_SPARC_TLS_LDM_LO10
block|,
name|R_SPARC_TLS_LDM_LO10
block|}
block|,
block|{
name|BFD_RELOC_SPARC_TLS_LDM_ADD
block|,
name|R_SPARC_TLS_LDM_ADD
block|}
block|,
block|{
name|BFD_RELOC_SPARC_TLS_LDM_CALL
block|,
name|R_SPARC_TLS_LDM_CALL
block|}
block|,
block|{
name|BFD_RELOC_SPARC_TLS_LDO_HIX22
block|,
name|R_SPARC_TLS_LDO_HIX22
block|}
block|,
block|{
name|BFD_RELOC_SPARC_TLS_LDO_LOX10
block|,
name|R_SPARC_TLS_LDO_LOX10
block|}
block|,
block|{
name|BFD_RELOC_SPARC_TLS_LDO_ADD
block|,
name|R_SPARC_TLS_LDO_ADD
block|}
block|,
block|{
name|BFD_RELOC_SPARC_TLS_IE_HI22
block|,
name|R_SPARC_TLS_IE_HI22
block|}
block|,
block|{
name|BFD_RELOC_SPARC_TLS_IE_LO10
block|,
name|R_SPARC_TLS_IE_LO10
block|}
block|,
block|{
name|BFD_RELOC_SPARC_TLS_IE_LD
block|,
name|R_SPARC_TLS_IE_LD
block|}
block|,
block|{
name|BFD_RELOC_SPARC_TLS_IE_LDX
block|,
name|R_SPARC_TLS_IE_LDX
block|}
block|,
block|{
name|BFD_RELOC_SPARC_TLS_IE_ADD
block|,
name|R_SPARC_TLS_IE_ADD
block|}
block|,
block|{
name|BFD_RELOC_SPARC_TLS_LE_HIX22
block|,
name|R_SPARC_TLS_LE_HIX22
block|}
block|,
block|{
name|BFD_RELOC_SPARC_TLS_LE_LOX10
block|,
name|R_SPARC_TLS_LE_LOX10
block|}
block|,
block|{
name|BFD_RELOC_SPARC_TLS_DTPMOD32
block|,
name|R_SPARC_TLS_DTPMOD32
block|}
block|,
block|{
name|BFD_RELOC_SPARC_TLS_DTPMOD64
block|,
name|R_SPARC_TLS_DTPMOD64
block|}
block|,
block|{
name|BFD_RELOC_SPARC_TLS_DTPOFF32
block|,
name|R_SPARC_TLS_DTPOFF32
block|}
block|,
block|{
name|BFD_RELOC_SPARC_TLS_DTPOFF64
block|,
name|R_SPARC_TLS_DTPOFF64
block|}
block|,
block|{
name|BFD_RELOC_SPARC_TLS_TPOFF32
block|,
name|R_SPARC_TLS_TPOFF32
block|}
block|,
block|{
name|BFD_RELOC_SPARC_TLS_TPOFF64
block|,
name|R_SPARC_TLS_TPOFF64
block|}
block|,
block|{
name|BFD_RELOC_SPARC_PLT32
block|,
name|R_SPARC_PLT32
block|}
block|,
block|{
name|BFD_RELOC_SPARC_PLT64
block|,
name|R_SPARC_PLT64
block|}
block|,
block|{
name|BFD_RELOC_SPARC_HIX22
block|,
name|R_SPARC_HIX22
block|}
block|,
block|{
name|BFD_RELOC_SPARC_LOX10
block|,
name|R_SPARC_LOX10
block|}
block|,
block|{
name|BFD_RELOC_SPARC_H44
block|,
name|R_SPARC_H44
block|}
block|,
block|{
name|BFD_RELOC_SPARC_M44
block|,
name|R_SPARC_M44
block|}
block|,
block|{
name|BFD_RELOC_SPARC_L44
block|,
name|R_SPARC_L44
block|}
block|,
block|{
name|BFD_RELOC_SPARC_REGISTER
block|,
name|R_SPARC_REGISTER
block|}
block|,
block|{
name|BFD_RELOC_VTABLE_INHERIT
block|,
name|R_SPARC_GNU_VTINHERIT
block|}
block|,
block|{
name|BFD_RELOC_VTABLE_ENTRY
block|,
name|R_SPARC_GNU_VTENTRY
block|}
block|,
block|{
name|BFD_RELOC_SPARC_REV32
block|,
name|R_SPARC_REV32
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|reloc_howto_type
modifier|*
name|_bfd_sparc_elf_reloc_type_lookup
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd_reloc_code_real_type
name|code
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|BFD_RELOC_VTABLE_INHERIT
case|:
return|return
operator|&
name|sparc_vtinherit_howto
return|;
case|case
name|BFD_RELOC_VTABLE_ENTRY
case|:
return|return
operator|&
name|sparc_vtentry_howto
return|;
case|case
name|BFD_RELOC_SPARC_REV32
case|:
return|return
operator|&
name|sparc_rev32_howto
return|;
default|default:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|sparc_reloc_map
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|elf_reloc_map
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sparc_reloc_map
index|[
name|i
index|]
operator|.
name|bfd_reloc_val
operator|==
name|code
condition|)
return|return
operator|(
name|_bfd_sparc_elf_howto_table
operator|+
operator|(
name|int
operator|)
name|sparc_reloc_map
index|[
name|i
index|]
operator|.
name|elf_reloc_val
operator|)
return|;
block|}
block|}
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|reloc_howto_type
modifier|*
name|_bfd_sparc_elf_reloc_name_lookup
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|r_name
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|_bfd_sparc_elf_howto_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|_bfd_sparc_elf_howto_table
index|[
literal|0
index|]
argument_list|)
operator|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|_bfd_sparc_elf_howto_table
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
operator|&&
name|strcasecmp
argument_list|(
name|_bfd_sparc_elf_howto_table
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|r_name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|&
name|_bfd_sparc_elf_howto_table
index|[
name|i
index|]
return|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|sparc_vtinherit_howto
operator|.
name|name
argument_list|,
name|r_name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|&
name|sparc_vtinherit_howto
return|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|sparc_vtentry_howto
operator|.
name|name
argument_list|,
name|r_name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|&
name|sparc_vtentry_howto
return|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|sparc_rev32_howto
operator|.
name|name
argument_list|,
name|r_name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|&
name|sparc_rev32_howto
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|reloc_howto_type
modifier|*
name|_bfd_sparc_elf_info_to_howto_ptr
parameter_list|(
name|unsigned
name|int
name|r_type
parameter_list|)
block|{
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_SPARC_GNU_VTINHERIT
case|:
return|return
operator|&
name|sparc_vtinherit_howto
return|;
case|case
name|R_SPARC_GNU_VTENTRY
case|:
return|return
operator|&
name|sparc_vtentry_howto
return|;
case|case
name|R_SPARC_REV32
case|:
return|return
operator|&
name|sparc_rev32_howto
return|;
default|default:
if|if
condition|(
name|r_type
operator|>=
operator|(
name|unsigned
name|int
operator|)
name|R_SPARC_max_std
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"invalid relocation type %d"
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|r_type
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|R_SPARC_NONE
expr_stmt|;
block|}
return|return
operator|&
name|_bfd_sparc_elf_howto_table
index|[
name|r_type
index|]
return|;
block|}
block|}
end_function

begin_comment
comment|/* Both 32-bit and 64-bit sparc encode this in an identical manner,    so just take advantage of that.  */
end_comment

begin_define
define|#
directive|define
name|SPARC_ELF_R_TYPE
parameter_list|(
name|r_info
parameter_list|)
define|\
value|((r_info)& 0xff)
end_define

begin_function
name|void
name|_bfd_sparc_elf_info_to_howto
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|arelent
modifier|*
name|cache_ptr
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|dst
parameter_list|)
block|{
name|unsigned
name|int
name|r_type
init|=
name|SPARC_ELF_R_TYPE
argument_list|(
name|dst
operator|->
name|r_info
argument_list|)
decl_stmt|;
name|cache_ptr
operator|->
name|howto
operator|=
name|_bfd_sparc_elf_info_to_howto_ptr
argument_list|(
name|r_type
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The nop opcode we use.  */
end_comment

begin_define
define|#
directive|define
name|SPARC_NOP
value|0x01000000
end_define

begin_define
define|#
directive|define
name|SPARC_INSN_BYTES
value|4
end_define

begin_comment
comment|/* The SPARC linker needs to keep track of the number of relocs that it    decides to copy as dynamic relocs in check_relocs for each symbol.    This is so that it can later discard them if they are found to be    unnecessary.  We store the information in a field extending the    regular ELF linker hash table.  */
end_comment

begin_struct
struct|struct
name|_bfd_sparc_elf_dyn_relocs
block|{
name|struct
name|_bfd_sparc_elf_dyn_relocs
modifier|*
name|next
decl_stmt|;
comment|/* The input section of the reloc.  */
name|asection
modifier|*
name|sec
decl_stmt|;
comment|/* Total number of relocs copied for the input section.  */
name|bfd_size_type
name|count
decl_stmt|;
comment|/* Number of pc-relative relocs copied for the input section.  */
name|bfd_size_type
name|pc_count
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* SPARC ELF linker hash entry.  */
end_comment

begin_struct
struct|struct
name|_bfd_sparc_elf_link_hash_entry
block|{
name|struct
name|elf_link_hash_entry
name|elf
decl_stmt|;
comment|/* Track dynamic relocs copied for this symbol.  */
name|struct
name|_bfd_sparc_elf_dyn_relocs
modifier|*
name|dyn_relocs
decl_stmt|;
define|#
directive|define
name|GOT_UNKNOWN
value|0
define|#
directive|define
name|GOT_NORMAL
value|1
define|#
directive|define
name|GOT_TLS_GD
value|2
define|#
directive|define
name|GOT_TLS_IE
value|3
name|unsigned
name|char
name|tls_type
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|_bfd_sparc_elf_hash_entry
parameter_list|(
name|ent
parameter_list|)
value|((struct _bfd_sparc_elf_link_hash_entry *)(ent))
end_define

begin_struct
struct|struct
name|_bfd_sparc_elf_obj_tdata
block|{
name|struct
name|elf_obj_tdata
name|root
decl_stmt|;
comment|/* tls_type for each local got entry.  */
name|char
modifier|*
name|local_got_tls_type
decl_stmt|;
comment|/* TRUE if TLS GD relocs has been seen for this object.  */
name|bfd_boolean
name|has_tlsgd
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|_bfd_sparc_elf_tdata
parameter_list|(
name|abfd
parameter_list|)
define|\
value|((struct _bfd_sparc_elf_obj_tdata *) (abfd)->tdata.any)
end_define

begin_define
define|#
directive|define
name|_bfd_sparc_elf_local_got_tls_type
parameter_list|(
name|abfd
parameter_list|)
define|\
value|(_bfd_sparc_elf_tdata (abfd)->local_got_tls_type)
end_define

begin_function
name|bfd_boolean
name|_bfd_sparc_elf_mkobject
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
if|if
condition|(
name|abfd
operator|->
name|tdata
operator|.
name|any
operator|==
name|NULL
condition|)
block|{
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|_bfd_sparc_elf_obj_tdata
argument_list|)
decl_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|any
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|tdata
operator|.
name|any
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|bfd_elf_mkobject
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sparc_put_word_32
parameter_list|(
name|bfd
modifier|*
name|bfd
parameter_list|,
name|bfd_vma
name|val
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|bfd_put_32
argument_list|(
name|bfd
argument_list|,
name|val
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sparc_put_word_64
parameter_list|(
name|bfd
modifier|*
name|bfd
parameter_list|,
name|bfd_vma
name|val
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|bfd_put_64
argument_list|(
name|bfd
argument_list|,
name|val
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sparc_elf_append_rela
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|s
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|rel
parameter_list|)
block|{
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|loc
operator|=
name|s
operator|->
name|contents
operator|+
operator|(
name|s
operator|->
name|reloc_count
operator|++
operator|*
name|bed
operator|->
name|s
operator|->
name|sizeof_rela
operator|)
expr_stmt|;
name|bed
operator|->
name|s
operator|->
name|swap_reloca_out
argument_list|(
name|abfd
argument_list|,
name|rel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bfd_vma
name|sparc_elf_r_info_64
parameter_list|(
name|Elf_Internal_Rela
modifier|*
name|in_rel
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd_vma
name|index
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd_vma
name|type
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|ELF64_R_INFO
argument_list|(
name|index
argument_list|,
operator|(
name|in_rel
condition|?
name|ELF64_R_TYPE_INFO
argument_list|(
name|ELF64_R_TYPE_DATA
argument_list|(
name|in_rel
operator|->
name|r_info
argument_list|)
argument_list|,
name|type
argument_list|)
else|:
name|type
operator|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_vma
name|sparc_elf_r_info_32
parameter_list|(
name|Elf_Internal_Rela
modifier|*
name|in_rel
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd_vma
name|index
parameter_list|,
name|bfd_vma
name|type
parameter_list|)
block|{
return|return
name|ELF32_R_INFO
argument_list|(
name|index
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_vma
name|sparc_elf_r_symndx_64
parameter_list|(
name|bfd_vma
name|r_info
parameter_list|)
block|{
name|bfd_vma
name|r_symndx
init|=
name|ELF32_R_SYM
argument_list|(
name|r_info
argument_list|)
decl_stmt|;
return|return
operator|(
name|r_symndx
operator|>>
literal|24
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_vma
name|sparc_elf_r_symndx_32
parameter_list|(
name|bfd_vma
name|r_info
parameter_list|)
block|{
return|return
name|ELF32_R_SYM
argument_list|(
name|r_info
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* PLT/GOT stuff */
end_comment

begin_define
define|#
directive|define
name|PLT32_ENTRY_SIZE
value|12
end_define

begin_define
define|#
directive|define
name|PLT32_HEADER_SIZE
value|(4 * PLT32_ENTRY_SIZE)
end_define

begin_comment
comment|/* The first four entries in a 32-bit procedure linkage table are reserved,    and the initial contents are unimportant (we zero them out).    Subsequent entries look like this.  See the SVR4 ABI SPARC    supplement to see how this works.  */
end_comment

begin_comment
comment|/* sethi %hi(.-.plt0),%g1.  We fill in the address later.  */
end_comment

begin_define
define|#
directive|define
name|PLT32_ENTRY_WORD0
value|0x03000000
end_define

begin_comment
comment|/* b,a .plt0.  We fill in the offset later.  */
end_comment

begin_define
define|#
directive|define
name|PLT32_ENTRY_WORD1
value|0x30800000
end_define

begin_comment
comment|/* nop.  */
end_comment

begin_define
define|#
directive|define
name|PLT32_ENTRY_WORD2
value|SPARC_NOP
end_define

begin_function
specifier|static
name|int
name|sparc32_plt_entry_build
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|asection
modifier|*
name|splt
parameter_list|,
name|bfd_vma
name|offset
parameter_list|,
name|bfd_vma
name|max
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd_vma
modifier|*
name|r_offset
parameter_list|)
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|PLT32_ENTRY_WORD0
operator|+
name|offset
argument_list|,
name|splt
operator|->
name|contents
operator|+
name|offset
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|PLT32_ENTRY_WORD1
operator|+
operator|(
operator|(
operator|(
operator|-
operator|(
name|offset
operator|+
literal|4
operator|)
operator|)
operator|>>
literal|2
operator|)
operator|&
literal|0x3fffff
operator|)
operator|)
argument_list|,
name|splt
operator|->
name|contents
operator|+
name|offset
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|PLT32_ENTRY_WORD2
argument_list|,
name|splt
operator|->
name|contents
operator|+
name|offset
operator|+
literal|8
argument_list|)
expr_stmt|;
operator|*
name|r_offset
operator|=
name|offset
expr_stmt|;
return|return
name|offset
operator|/
name|PLT32_ENTRY_SIZE
operator|-
literal|4
return|;
block|}
end_function

begin_comment
comment|/* Both the headers and the entries are icache aligned.  */
end_comment

begin_define
define|#
directive|define
name|PLT64_ENTRY_SIZE
value|32
end_define

begin_define
define|#
directive|define
name|PLT64_HEADER_SIZE
value|(4 * PLT64_ENTRY_SIZE)
end_define

begin_define
define|#
directive|define
name|PLT64_LARGE_THRESHOLD
value|32768
end_define

begin_function
specifier|static
name|int
name|sparc64_plt_entry_build
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|asection
modifier|*
name|splt
parameter_list|,
name|bfd_vma
name|offset
parameter_list|,
name|bfd_vma
name|max
parameter_list|,
name|bfd_vma
modifier|*
name|r_offset
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|entry
init|=
name|splt
operator|->
name|contents
operator|+
name|offset
decl_stmt|;
specifier|const
name|unsigned
name|int
name|nop
init|=
name|SPARC_NOP
decl_stmt|;
name|int
name|index
decl_stmt|;
if|if
condition|(
name|offset
operator|<
operator|(
name|PLT64_LARGE_THRESHOLD
operator|*
name|PLT64_ENTRY_SIZE
operator|)
condition|)
block|{
name|unsigned
name|int
name|sethi
decl_stmt|,
name|ba
decl_stmt|;
operator|*
name|r_offset
operator|=
name|offset
expr_stmt|;
name|index
operator|=
operator|(
name|offset
operator|/
name|PLT64_ENTRY_SIZE
operator|)
expr_stmt|;
name|sethi
operator|=
literal|0x03000000
operator||
operator|(
name|index
operator|*
name|PLT64_ENTRY_SIZE
operator|)
expr_stmt|;
name|ba
operator|=
literal|0x30680000
operator||
operator|(
operator|(
operator|(
name|splt
operator|->
name|contents
operator|+
name|PLT64_ENTRY_SIZE
operator|)
operator|-
operator|(
name|entry
operator|+
literal|4
operator|)
operator|)
operator|/
literal|4
operator|&
literal|0x7ffff
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|sethi
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|ba
argument_list|,
name|entry
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|nop
argument_list|,
name|entry
operator|+
literal|8
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|nop
argument_list|,
name|entry
operator|+
literal|12
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|nop
argument_list|,
name|entry
operator|+
literal|16
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|nop
argument_list|,
name|entry
operator|+
literal|20
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|nop
argument_list|,
name|entry
operator|+
literal|24
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|nop
argument_list|,
name|entry
operator|+
literal|28
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|char
modifier|*
name|ptr
decl_stmt|;
name|unsigned
name|int
name|ldx
decl_stmt|;
name|int
name|block
decl_stmt|,
name|last_block
decl_stmt|,
name|ofs
decl_stmt|,
name|last_ofs
decl_stmt|,
name|chunks_this_block
decl_stmt|;
specifier|const
name|int
name|insn_chunk_size
init|=
operator|(
literal|6
operator|*
literal|4
operator|)
decl_stmt|;
specifier|const
name|int
name|ptr_chunk_size
init|=
operator|(
literal|1
operator|*
literal|8
operator|)
decl_stmt|;
specifier|const
name|int
name|entries_per_block
init|=
literal|160
decl_stmt|;
specifier|const
name|int
name|block_size
init|=
name|entries_per_block
operator|*
operator|(
name|insn_chunk_size
operator|+
name|ptr_chunk_size
operator|)
decl_stmt|;
comment|/* Entries 32768 and higher are grouped into blocks of 160. 	 The blocks are further subdivided into 160 sequences of 	 6 instructions and 160 pointers.  If a block does not require 	 the full 160 entries, let's say it requires N, then there 	 will be N sequences of 6 instructions and N pointers.  */
name|offset
operator|-=
operator|(
name|PLT64_LARGE_THRESHOLD
operator|*
name|PLT64_ENTRY_SIZE
operator|)
expr_stmt|;
name|max
operator|-=
operator|(
name|PLT64_LARGE_THRESHOLD
operator|*
name|PLT64_ENTRY_SIZE
operator|)
expr_stmt|;
name|block
operator|=
name|offset
operator|/
name|block_size
expr_stmt|;
name|last_block
operator|=
name|max
operator|/
name|block_size
expr_stmt|;
if|if
condition|(
name|block
operator|!=
name|last_block
condition|)
block|{
name|chunks_this_block
operator|=
literal|160
expr_stmt|;
block|}
else|else
block|{
name|last_ofs
operator|=
name|max
operator|%
name|block_size
expr_stmt|;
name|chunks_this_block
operator|=
name|last_ofs
operator|/
operator|(
name|insn_chunk_size
operator|+
name|ptr_chunk_size
operator|)
expr_stmt|;
block|}
name|ofs
operator|=
name|offset
operator|%
name|block_size
expr_stmt|;
name|index
operator|=
operator|(
name|PLT64_LARGE_THRESHOLD
operator|+
operator|(
name|block
operator|*
literal|160
operator|)
operator|+
operator|(
name|ofs
operator|/
name|insn_chunk_size
operator|)
operator|)
expr_stmt|;
name|ptr
operator|=
name|splt
operator|->
name|contents
operator|+
operator|(
name|PLT64_LARGE_THRESHOLD
operator|*
name|PLT64_ENTRY_SIZE
operator|)
operator|+
operator|(
name|block
operator|*
name|block_size
operator|)
operator|+
operator|(
name|chunks_this_block
operator|*
name|insn_chunk_size
operator|)
operator|+
operator|(
name|ofs
operator|/
name|insn_chunk_size
operator|)
operator|*
name|ptr_chunk_size
expr_stmt|;
operator|*
name|r_offset
operator|=
call|(
name|bfd_vma
call|)
argument_list|(
name|ptr
operator|-
name|splt
operator|->
name|contents
argument_list|)
expr_stmt|;
name|ldx
operator|=
literal|0xc25be000
operator||
operator|(
operator|(
name|ptr
operator|-
operator|(
name|entry
operator|+
literal|4
operator|)
operator|)
operator|&
literal|0x1fff
operator|)
expr_stmt|;
comment|/* mov %o7,%g5 	 call .+8 	 nop 	 ldx [%o7+P],%g1 	 jmpl %o7+%g1,%g1 	 mov %g5,%o7  */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0x8a10000f
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0x40000002
argument_list|,
name|entry
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|SPARC_NOP
argument_list|,
name|entry
operator|+
literal|8
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|ldx
argument_list|,
name|entry
operator|+
literal|12
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0x83c3c001
argument_list|,
name|entry
operator|+
literal|16
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0x9e100005
argument_list|,
name|entry
operator|+
literal|20
argument_list|)
expr_stmt|;
name|bfd_put_64
argument_list|(
name|output_bfd
argument_list|,
call|(
name|bfd_vma
call|)
argument_list|(
name|splt
operator|->
name|contents
operator|-
operator|(
name|entry
operator|+
literal|4
operator|)
argument_list|)
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
return|return
name|index
operator|-
literal|4
return|;
block|}
end_function

begin_comment
comment|/* The format of the first PLT entry in a VxWorks executable.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|bfd_vma
name|sparc_vxworks_exec_plt0_entry
index|[]
init|=
block|{
literal|0x05000000
block|,
comment|/* sethi  %hi(_GLOBAL_OFFSET_TABLE_+8), %g2 */
literal|0x8410a000
block|,
comment|/* or     %g2, %lo(_GLOBAL_OFFSET_TABLE_+8), %g2 */
literal|0xc4008000
block|,
comment|/* ld     [ %g2 ], %g2 */
literal|0x81c08000
block|,
comment|/* jmp    %g2 */
literal|0x01000000
comment|/* nop */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The format of subsequent PLT entries.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|bfd_vma
name|sparc_vxworks_exec_plt_entry
index|[]
init|=
block|{
literal|0x03000000
block|,
comment|/* sethi  %hi(_GLOBAL_OFFSET_TABLE_+f@got), %g1 */
literal|0x82106000
block|,
comment|/* or     %g1, %lo(_GLOBAL_OFFSET_TABLE_+f@got), %g1 */
literal|0xc2004000
block|,
comment|/* ld     [ %g1 ], %g1 */
literal|0x81c04000
block|,
comment|/* jmp    %g1 */
literal|0x01000000
block|,
comment|/* nop */
literal|0x03000000
block|,
comment|/* sethi  %hi(f@pltindex), %g1 */
literal|0x10800000
block|,
comment|/* b      _PLT_resolve */
literal|0x82106000
comment|/* or     %g1, %lo(f@pltindex), %g1 */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The format of the first PLT entry in a VxWorks shared object.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|bfd_vma
name|sparc_vxworks_shared_plt0_entry
index|[]
init|=
block|{
literal|0xc405e008
block|,
comment|/* ld     [ %l7 + 8 ], %g2 */
literal|0x81c08000
block|,
comment|/* jmp    %g2 */
literal|0x01000000
comment|/* nop */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The format of subsequent PLT entries.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|bfd_vma
name|sparc_vxworks_shared_plt_entry
index|[]
init|=
block|{
literal|0x03000000
block|,
comment|/* sethi  %hi(f@got), %g1 */
literal|0x82106000
block|,
comment|/* or     %g1, %lo(f@got), %g1 */
literal|0xc205c001
block|,
comment|/* ld     [ %l7 + %g1 ], %g1 */
literal|0x81c04000
block|,
comment|/* jmp    %g1 */
literal|0x01000000
block|,
comment|/* nop */
literal|0x03000000
block|,
comment|/* sethi  %hi(f@pltindex), %g1 */
literal|0x10800000
block|,
comment|/* b      _PLT_resolve */
literal|0x82106000
comment|/* or     %g1, %lo(f@pltindex), %g1 */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SPARC_ELF_PUT_WORD
parameter_list|(
name|htab
parameter_list|,
name|bfd
parameter_list|,
name|val
parameter_list|,
name|ptr
parameter_list|)
define|\
value|htab->put_word(bfd, val, ptr)
end_define

begin_define
define|#
directive|define
name|SPARC_ELF_R_INFO
parameter_list|(
name|htab
parameter_list|,
name|in_rel
parameter_list|,
name|index
parameter_list|,
name|type
parameter_list|)
define|\
value|htab->r_info(in_rel, index, type)
end_define

begin_define
define|#
directive|define
name|SPARC_ELF_R_SYMNDX
parameter_list|(
name|htab
parameter_list|,
name|r_info
parameter_list|)
define|\
value|htab->r_symndx(r_info)
end_define

begin_define
define|#
directive|define
name|SPARC_ELF_WORD_BYTES
parameter_list|(
name|htab
parameter_list|)
define|\
value|htab->bytes_per_word
end_define

begin_define
define|#
directive|define
name|SPARC_ELF_RELA_BYTES
parameter_list|(
name|htab
parameter_list|)
define|\
value|htab->bytes_per_rela
end_define

begin_define
define|#
directive|define
name|SPARC_ELF_DTPOFF_RELOC
parameter_list|(
name|htab
parameter_list|)
define|\
value|htab->dtpoff_reloc
end_define

begin_define
define|#
directive|define
name|SPARC_ELF_DTPMOD_RELOC
parameter_list|(
name|htab
parameter_list|)
define|\
value|htab->dtpmod_reloc
end_define

begin_define
define|#
directive|define
name|SPARC_ELF_TPOFF_RELOC
parameter_list|(
name|htab
parameter_list|)
define|\
value|htab->tpoff_reloc
end_define

begin_define
define|#
directive|define
name|SPARC_ELF_BUILD_PLT_ENTRY
parameter_list|(
name|htab
parameter_list|,
name|obfd
parameter_list|,
name|splt
parameter_list|,
name|off
parameter_list|,
name|max
parameter_list|,
name|r_off
parameter_list|)
define|\
value|htab->build_plt_entry (obfd, splt, off, max, r_off)
end_define

begin_comment
comment|/* Create an entry in an SPARC ELF linker hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|link_hash_newfunc
parameter_list|(
name|struct
name|bfd_hash_entry
modifier|*
name|entry
parameter_list|,
name|struct
name|bfd_hash_table
modifier|*
name|table
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
comment|/* Allocate the structure if it has not already been allocated by a      subclass.  */
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
name|entry
operator|=
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|_bfd_sparc_elf_link_hash_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
return|return
name|entry
return|;
block|}
comment|/* Call the allocation method of the superclass.  */
name|entry
operator|=
name|_bfd_elf_link_hash_newfunc
argument_list|(
name|entry
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|!=
name|NULL
condition|)
block|{
name|struct
name|_bfd_sparc_elf_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|_bfd_sparc_elf_link_hash_entry
operator|*
operator|)
name|entry
expr_stmt|;
name|eh
operator|->
name|dyn_relocs
operator|=
name|NULL
expr_stmt|;
name|eh
operator|->
name|tls_type
operator|=
name|GOT_UNKNOWN
expr_stmt|;
block|}
return|return
name|entry
return|;
block|}
end_function

begin_comment
comment|/* The name of the dynamic interpreter.  This is put in the .interp    section.  */
end_comment

begin_define
define|#
directive|define
name|ELF32_DYNAMIC_INTERPRETER
value|"/usr/lib/ld.so.1"
end_define

begin_define
define|#
directive|define
name|ELF64_DYNAMIC_INTERPRETER
value|"/usr/lib/sparcv9/ld.so.1"
end_define

begin_comment
comment|/* Create a SPARC ELF linker hash table.  */
end_comment

begin_function
name|struct
name|bfd_link_hash_table
modifier|*
name|_bfd_sparc_elf_link_hash_table_create
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|struct
name|_bfd_sparc_elf_link_hash_table
modifier|*
name|ret
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|_bfd_sparc_elf_link_hash_table
argument_list|)
decl_stmt|;
name|ret
operator|=
operator|(
expr|struct
name|_bfd_sparc_elf_link_hash_table
operator|*
operator|)
name|bfd_zmalloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|ABI_64_P
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|ret
operator|->
name|put_word
operator|=
name|sparc_put_word_64
expr_stmt|;
name|ret
operator|->
name|r_info
operator|=
name|sparc_elf_r_info_64
expr_stmt|;
name|ret
operator|->
name|r_symndx
operator|=
name|sparc_elf_r_symndx_64
expr_stmt|;
name|ret
operator|->
name|dtpoff_reloc
operator|=
name|R_SPARC_TLS_DTPOFF64
expr_stmt|;
name|ret
operator|->
name|dtpmod_reloc
operator|=
name|R_SPARC_TLS_DTPMOD64
expr_stmt|;
name|ret
operator|->
name|tpoff_reloc
operator|=
name|R_SPARC_TLS_TPOFF64
expr_stmt|;
name|ret
operator|->
name|word_align_power
operator|=
literal|3
expr_stmt|;
name|ret
operator|->
name|align_power_max
operator|=
literal|4
expr_stmt|;
name|ret
operator|->
name|bytes_per_word
operator|=
literal|8
expr_stmt|;
name|ret
operator|->
name|bytes_per_rela
operator|=
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
name|ret
operator|->
name|dynamic_interpreter
operator|=
name|ELF64_DYNAMIC_INTERPRETER
expr_stmt|;
name|ret
operator|->
name|dynamic_interpreter_size
operator|=
sizeof|sizeof
name|ELF64_DYNAMIC_INTERPRETER
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|->
name|put_word
operator|=
name|sparc_put_word_32
expr_stmt|;
name|ret
operator|->
name|r_info
operator|=
name|sparc_elf_r_info_32
expr_stmt|;
name|ret
operator|->
name|r_symndx
operator|=
name|sparc_elf_r_symndx_32
expr_stmt|;
name|ret
operator|->
name|dtpoff_reloc
operator|=
name|R_SPARC_TLS_DTPOFF32
expr_stmt|;
name|ret
operator|->
name|dtpmod_reloc
operator|=
name|R_SPARC_TLS_DTPMOD32
expr_stmt|;
name|ret
operator|->
name|tpoff_reloc
operator|=
name|R_SPARC_TLS_TPOFF32
expr_stmt|;
name|ret
operator|->
name|word_align_power
operator|=
literal|2
expr_stmt|;
name|ret
operator|->
name|align_power_max
operator|=
literal|3
expr_stmt|;
name|ret
operator|->
name|bytes_per_word
operator|=
literal|4
expr_stmt|;
name|ret
operator|->
name|bytes_per_rela
operator|=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
name|ret
operator|->
name|dynamic_interpreter
operator|=
name|ELF32_DYNAMIC_INTERPRETER
expr_stmt|;
name|ret
operator|->
name|dynamic_interpreter_size
operator|=
sizeof|sizeof
name|ELF32_DYNAMIC_INTERPRETER
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|_bfd_elf_link_hash_table_init
argument_list|(
operator|&
name|ret
operator|->
name|elf
argument_list|,
name|abfd
argument_list|,
name|link_hash_newfunc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|_bfd_sparc_elf_link_hash_entry
argument_list|)
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
operator|&
name|ret
operator|->
name|elf
operator|.
name|root
return|;
block|}
end_function

begin_comment
comment|/* Create .got and .rela.got sections in DYNOBJ, and set up    shortcuts to them in our hash table.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|create_got_section
parameter_list|(
name|bfd
modifier|*
name|dynobj
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|_bfd_sparc_elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
if|if
condition|(
operator|!
name|_bfd_elf_create_got_section
argument_list|(
name|dynobj
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|htab
operator|=
name|_bfd_sparc_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|htab
operator|->
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|htab
operator|->
name|sgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|htab
operator|->
name|srelgot
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|,
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_READONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|srelgot
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|htab
operator|->
name|srelgot
argument_list|,
name|htab
operator|->
name|word_align_power
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|htab
operator|->
name|is_vxworks
condition|)
block|{
name|htab
operator|->
name|sgotplt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got.plt"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|htab
operator|->
name|sgotplt
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Create .plt, .rela.plt, .got, .rela.got, .dynbss, and    .rela.bss sections in DYNOBJ, and set up shortcuts to them in our    hash table.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_sparc_elf_create_dynamic_sections
parameter_list|(
name|bfd
modifier|*
name|dynobj
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|_bfd_sparc_elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|htab
operator|=
name|_bfd_sparc_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|htab
operator|->
name|sgot
operator|&&
operator|!
name|create_got_section
argument_list|(
name|dynobj
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|_bfd_elf_create_dynamic_sections
argument_list|(
name|dynobj
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|htab
operator|->
name|splt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
name|htab
operator|->
name|srelplt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.plt"
argument_list|)
expr_stmt|;
name|htab
operator|->
name|sdynbss
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynbss"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
name|htab
operator|->
name|srelbss
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.bss"
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|is_vxworks
condition|)
block|{
if|if
condition|(
operator|!
name|elf_vxworks_create_dynamic_sections
argument_list|(
name|dynobj
argument_list|,
name|info
argument_list|,
operator|&
name|htab
operator|->
name|srelplt2
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
name|htab
operator|->
name|plt_header_size
operator|=
literal|4
operator|*
name|ARRAY_SIZE
argument_list|(
name|sparc_vxworks_shared_plt0_entry
argument_list|)
expr_stmt|;
name|htab
operator|->
name|plt_entry_size
operator|=
literal|4
operator|*
name|ARRAY_SIZE
argument_list|(
name|sparc_vxworks_shared_plt_entry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|htab
operator|->
name|plt_header_size
operator|=
literal|4
operator|*
name|ARRAY_SIZE
argument_list|(
name|sparc_vxworks_exec_plt0_entry
argument_list|)
expr_stmt|;
name|htab
operator|->
name|plt_entry_size
operator|=
literal|4
operator|*
name|ARRAY_SIZE
argument_list|(
name|sparc_vxworks_exec_plt_entry
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ABI_64_P
argument_list|(
name|dynobj
argument_list|)
condition|)
block|{
name|htab
operator|->
name|build_plt_entry
operator|=
name|sparc64_plt_entry_build
expr_stmt|;
name|htab
operator|->
name|plt_header_size
operator|=
name|PLT64_HEADER_SIZE
expr_stmt|;
name|htab
operator|->
name|plt_entry_size
operator|=
name|PLT64_ENTRY_SIZE
expr_stmt|;
block|}
else|else
block|{
name|htab
operator|->
name|build_plt_entry
operator|=
name|sparc32_plt_entry_build
expr_stmt|;
name|htab
operator|->
name|plt_header_size
operator|=
name|PLT32_HEADER_SIZE
expr_stmt|;
name|htab
operator|->
name|plt_entry_size
operator|=
name|PLT32_ENTRY_SIZE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|htab
operator|->
name|splt
operator|||
operator|!
name|htab
operator|->
name|srelplt
operator|||
operator|!
name|htab
operator|->
name|sdynbss
operator|||
operator|(
operator|!
name|info
operator|->
name|shared
operator|&&
operator|!
name|htab
operator|->
name|srelbss
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Copy the extra info we tack onto an elf_link_hash_entry.  */
end_comment

begin_function
name|void
name|_bfd_sparc_elf_copy_indirect_symbol
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|dir
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|ind
parameter_list|)
block|{
name|struct
name|_bfd_sparc_elf_link_hash_entry
modifier|*
name|edir
decl_stmt|,
modifier|*
name|eind
decl_stmt|;
name|edir
operator|=
operator|(
expr|struct
name|_bfd_sparc_elf_link_hash_entry
operator|*
operator|)
name|dir
expr_stmt|;
name|eind
operator|=
operator|(
expr|struct
name|_bfd_sparc_elf_link_hash_entry
operator|*
operator|)
name|ind
expr_stmt|;
if|if
condition|(
name|eind
operator|->
name|dyn_relocs
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|edir
operator|->
name|dyn_relocs
operator|!=
name|NULL
condition|)
block|{
name|struct
name|_bfd_sparc_elf_dyn_relocs
modifier|*
modifier|*
name|pp
decl_stmt|;
name|struct
name|_bfd_sparc_elf_dyn_relocs
modifier|*
name|p
decl_stmt|;
comment|/* Add reloc counts against the indirect sym to the direct sym 	     list.  Merge any entries against the same section.  */
for|for
control|(
name|pp
operator|=
operator|&
name|eind
operator|->
name|dyn_relocs
init|;
operator|(
name|p
operator|=
operator|*
name|pp
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
name|struct
name|_bfd_sparc_elf_dyn_relocs
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|q
operator|=
name|edir
operator|->
name|dyn_relocs
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|next
control|)
if|if
condition|(
name|q
operator|->
name|sec
operator|==
name|p
operator|->
name|sec
condition|)
block|{
name|q
operator|->
name|pc_count
operator|+=
name|p
operator|->
name|pc_count
expr_stmt|;
name|q
operator|->
name|count
operator|+=
name|p
operator|->
name|count
expr_stmt|;
operator|*
name|pp
operator|=
name|p
operator|->
name|next
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
name|pp
operator|=
operator|&
name|p
operator|->
name|next
expr_stmt|;
block|}
operator|*
name|pp
operator|=
name|edir
operator|->
name|dyn_relocs
expr_stmt|;
block|}
name|edir
operator|->
name|dyn_relocs
operator|=
name|eind
operator|->
name|dyn_relocs
expr_stmt|;
name|eind
operator|->
name|dyn_relocs
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ind
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|&&
name|dir
operator|->
name|got
operator|.
name|refcount
operator|<=
literal|0
condition|)
block|{
name|edir
operator|->
name|tls_type
operator|=
name|eind
operator|->
name|tls_type
expr_stmt|;
name|eind
operator|->
name|tls_type
operator|=
name|GOT_UNKNOWN
expr_stmt|;
block|}
name|_bfd_elf_link_hash_copy_indirect
argument_list|(
name|info
argument_list|,
name|dir
argument_list|,
name|ind
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sparc_elf_tls_transition
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|,
name|int
name|r_type
parameter_list|,
name|int
name|is_local
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ABI_64_P
argument_list|(
name|abfd
argument_list|)
operator|&&
name|r_type
operator|==
name|R_SPARC_TLS_GD_HI22
operator|&&
operator|!
name|_bfd_sparc_elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|has_tlsgd
condition|)
name|r_type
operator|=
name|R_SPARC_REV32
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
return|return
name|r_type
return|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_SPARC_TLS_GD_HI22
case|:
if|if
condition|(
name|is_local
condition|)
return|return
name|R_SPARC_TLS_LE_HIX22
return|;
return|return
name|R_SPARC_TLS_IE_HI22
return|;
case|case
name|R_SPARC_TLS_GD_LO10
case|:
if|if
condition|(
name|is_local
condition|)
return|return
name|R_SPARC_TLS_LE_LOX10
return|;
return|return
name|R_SPARC_TLS_IE_LO10
return|;
case|case
name|R_SPARC_TLS_IE_HI22
case|:
if|if
condition|(
name|is_local
condition|)
return|return
name|R_SPARC_TLS_LE_HIX22
return|;
return|return
name|r_type
return|;
case|case
name|R_SPARC_TLS_IE_LO10
case|:
if|if
condition|(
name|is_local
condition|)
return|return
name|R_SPARC_TLS_LE_LOX10
return|;
return|return
name|r_type
return|;
case|case
name|R_SPARC_TLS_LDM_HI22
case|:
return|return
name|R_SPARC_TLS_LE_HIX22
return|;
case|case
name|R_SPARC_TLS_LDM_LO10
case|:
return|return
name|R_SPARC_TLS_LE_LOX10
return|;
block|}
return|return
name|r_type
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Look through the relocs for a section during the first phase, and    allocate space in the global offset table or procedure linkage    table.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_sparc_elf_check_relocs
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
parameter_list|)
block|{
name|struct
name|_bfd_sparc_elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|bfd_vma
modifier|*
name|local_got_offsets
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel_end
decl_stmt|;
name|asection
modifier|*
name|sreloc
decl_stmt|;
name|int
name|num_relocs
decl_stmt|;
name|bfd_boolean
name|checked_tlsgd
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
return|return
name|TRUE
return|;
name|htab
operator|=
name|_bfd_sparc_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|local_got_offsets
operator|=
name|elf_local_got_offsets
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|sreloc
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ABI_64_P
argument_list|(
name|abfd
argument_list|)
condition|)
name|num_relocs
operator|=
name|NUM_SHDR_ENTRIES
argument_list|(
operator|&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|rel_hdr
argument_list|)
expr_stmt|;
else|else
name|num_relocs
operator|=
name|sec
operator|->
name|reloc_count
expr_stmt|;
name|rel_end
operator|=
name|relocs
operator|+
name|num_relocs
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|rel_end
condition|;
name|rel
operator|++
control|)
block|{
name|unsigned
name|int
name|r_type
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|r_symndx
operator|=
name|SPARC_ELF_R_SYMNDX
argument_list|(
name|htab
argument_list|,
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|SPARC_ELF_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|>=
name|NUM_SHDR_ENTRIES
argument_list|(
name|symtab_hdr
argument_list|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: bad symbol index: %d"
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|r_symndx
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
name|h
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
block|}
comment|/* Compatibility with old R_SPARC_REV32 reloc conflicting 	 with R_SPARC_TLS_GD_HI22.  */
if|if
condition|(
operator|!
name|ABI_64_P
argument_list|(
name|abfd
argument_list|)
operator|&&
operator|!
name|checked_tlsgd
condition|)
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_SPARC_TLS_GD_HI22
case|:
block|{
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relt
decl_stmt|;
for|for
control|(
name|relt
operator|=
name|rel
operator|+
literal|1
init|;
name|relt
operator|<
name|rel_end
condition|;
name|relt
operator|++
control|)
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|relt
operator|->
name|r_info
argument_list|)
operator|==
name|R_SPARC_TLS_GD_LO10
operator|||
name|ELF32_R_TYPE
argument_list|(
name|relt
operator|->
name|r_info
argument_list|)
operator|==
name|R_SPARC_TLS_GD_ADD
operator|||
name|ELF32_R_TYPE
argument_list|(
name|relt
operator|->
name|r_info
argument_list|)
operator|==
name|R_SPARC_TLS_GD_CALL
condition|)
break|break;
name|checked_tlsgd
operator|=
name|TRUE
expr_stmt|;
name|_bfd_sparc_elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|has_tlsgd
operator|=
name|relt
operator|<
name|rel_end
expr_stmt|;
block|}
break|break;
case|case
name|R_SPARC_TLS_GD_LO10
case|:
case|case
name|R_SPARC_TLS_GD_ADD
case|:
case|case
name|R_SPARC_TLS_GD_CALL
case|:
name|checked_tlsgd
operator|=
name|TRUE
expr_stmt|;
name|_bfd_sparc_elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|has_tlsgd
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
name|r_type
operator|=
name|sparc_elf_tls_transition
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
name|r_type
argument_list|,
name|h
operator|==
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_SPARC_TLS_LDM_HI22
case|:
case|case
name|R_SPARC_TLS_LDM_LO10
case|:
name|htab
operator|->
name|tls_ldm_got
operator|.
name|refcount
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|R_SPARC_TLS_LE_HIX22
case|:
case|case
name|R_SPARC_TLS_LE_LOX10
case|:
if|if
condition|(
name|info
operator|->
name|shared
condition|)
goto|goto
name|r_sparc_plt32
goto|;
break|break;
case|case
name|R_SPARC_TLS_IE_HI22
case|:
case|case
name|R_SPARC_TLS_IE_LO10
case|:
if|if
condition|(
name|info
operator|->
name|shared
condition|)
name|info
operator|->
name|flags
operator||=
name|DF_STATIC_TLS
expr_stmt|;
comment|/* Fall through */
case|case
name|R_SPARC_GOT10
case|:
case|case
name|R_SPARC_GOT13
case|:
case|case
name|R_SPARC_GOT22
case|:
case|case
name|R_SPARC_TLS_GD_HI22
case|:
case|case
name|R_SPARC_TLS_GD_LO10
case|:
comment|/* This symbol requires a global offset table entry.  */
block|{
name|int
name|tls_type
decl_stmt|,
name|old_tls_type
decl_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
default|default:
case|case
name|R_SPARC_GOT10
case|:
case|case
name|R_SPARC_GOT13
case|:
case|case
name|R_SPARC_GOT22
case|:
name|tls_type
operator|=
name|GOT_NORMAL
expr_stmt|;
break|break;
case|case
name|R_SPARC_TLS_GD_HI22
case|:
case|case
name|R_SPARC_TLS_GD_LO10
case|:
name|tls_type
operator|=
name|GOT_TLS_GD
expr_stmt|;
break|break;
case|case
name|R_SPARC_TLS_IE_HI22
case|:
case|case
name|R_SPARC_TLS_IE_LO10
case|:
name|tls_type
operator|=
name|GOT_TLS_IE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|h
operator|->
name|got
operator|.
name|refcount
operator|+=
literal|1
expr_stmt|;
name|old_tls_type
operator|=
name|_bfd_sparc_elf_hash_entry
argument_list|(
name|h
argument_list|)
operator|->
name|tls_type
expr_stmt|;
block|}
else|else
block|{
name|bfd_signed_vma
modifier|*
name|local_got_refcounts
decl_stmt|;
comment|/* This is a global offset table entry for a local symbol.  */
name|local_got_refcounts
operator|=
name|elf_local_got_refcounts
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_got_refcounts
operator|==
name|NULL
condition|)
block|{
name|bfd_size_type
name|size
decl_stmt|;
name|size
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|size
operator|*=
operator|(
sizeof|sizeof
argument_list|(
name|bfd_signed_vma
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|)
expr_stmt|;
name|local_got_refcounts
operator|=
operator|(
operator|(
name|bfd_signed_vma
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|local_got_refcounts
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|elf_local_got_refcounts
argument_list|(
name|abfd
argument_list|)
operator|=
name|local_got_refcounts
expr_stmt|;
name|_bfd_sparc_elf_local_got_tls_type
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|local_got_refcounts
operator|+
name|symtab_hdr
operator|->
name|sh_info
operator|)
expr_stmt|;
block|}
name|local_got_refcounts
index|[
name|r_symndx
index|]
operator|+=
literal|1
expr_stmt|;
name|old_tls_type
operator|=
name|_bfd_sparc_elf_local_got_tls_type
argument_list|(
name|abfd
argument_list|)
index|[
name|r_symndx
index|]
expr_stmt|;
block|}
comment|/* If a TLS symbol is accessed using IE at least once, 	       there is no point to use dynamic model for it.  */
if|if
condition|(
name|old_tls_type
operator|!=
name|tls_type
operator|&&
name|old_tls_type
operator|!=
name|GOT_UNKNOWN
operator|&&
operator|(
name|old_tls_type
operator|!=
name|GOT_TLS_GD
operator|||
name|tls_type
operator|!=
name|GOT_TLS_IE
operator|)
condition|)
block|{
if|if
condition|(
name|old_tls_type
operator|==
name|GOT_TLS_IE
operator|&&
name|tls_type
operator|==
name|GOT_TLS_GD
condition|)
name|tls_type
operator|=
name|old_tls_type
expr_stmt|;
else|else
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: `%s' accessed both as normal and thread local symbol"
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|h
condition|?
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
else|:
literal|"<local>"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
if|if
condition|(
name|old_tls_type
operator|!=
name|tls_type
condition|)
block|{
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|_bfd_sparc_elf_hash_entry
argument_list|(
name|h
argument_list|)
operator|->
name|tls_type
operator|=
name|tls_type
expr_stmt|;
else|else
name|_bfd_sparc_elf_local_got_tls_type
argument_list|(
name|abfd
argument_list|)
index|[
name|r_symndx
index|]
operator|=
name|tls_type
expr_stmt|;
block|}
block|}
if|if
condition|(
name|htab
operator|->
name|sgot
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
operator|==
name|NULL
condition|)
name|htab
operator|->
name|elf
operator|.
name|dynobj
operator|=
name|abfd
expr_stmt|;
if|if
condition|(
operator|!
name|create_got_section
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
break|break;
case|case
name|R_SPARC_TLS_GD_CALL
case|:
case|case
name|R_SPARC_TLS_LDM_CALL
case|:
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
comment|/* These are basically R_SPARC_TLS_WPLT30 relocs against 		 __tls_get_addr.  */
name|struct
name|bfd_link_hash_entry
modifier|*
name|bh
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
literal|"__tls_get_addr"
argument_list|,
literal|0
argument_list|,
name|bfd_und_section_ptr
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
operator|&
name|bh
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|bh
expr_stmt|;
block|}
else|else
break|break;
comment|/* Fall through */
case|case
name|R_SPARC_PLT32
case|:
case|case
name|R_SPARC_WPLT30
case|:
case|case
name|R_SPARC_HIPLT22
case|:
case|case
name|R_SPARC_LOPLT10
case|:
case|case
name|R_SPARC_PCPLT32
case|:
case|case
name|R_SPARC_PCPLT22
case|:
case|case
name|R_SPARC_PCPLT10
case|:
case|case
name|R_SPARC_PLT64
case|:
comment|/* This symbol requires a procedure linkage table entry.  We 	     actually build the entry in adjust_dynamic_symbol, 	     because this might be a case of linking PIC code without 	     linking in any dynamic objects, in which case we don't 	     need to generate a procedure linkage table after all.  */
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|ABI_64_P
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
comment|/* The Solaris native assembler will generate a WPLT30 		     reloc for a local symbol if you assemble a call from 		     one section to another when using -K pic.  We treat 		     it as WDISP30.  */
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|==
name|R_SPARC_PLT32
condition|)
goto|goto
name|r_sparc_plt32
goto|;
break|break;
block|}
comment|/* It does not make sense to have a procedure linkage                  table entry for a local symbol.  */
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|h
operator|->
name|needs_plt
operator|=
literal|1
expr_stmt|;
block|{
name|int
name|this_r_type
decl_stmt|;
name|this_r_type
operator|=
name|SPARC_ELF_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_r_type
operator|==
name|R_SPARC_PLT32
operator|||
name|this_r_type
operator|==
name|R_SPARC_PLT64
condition|)
goto|goto
name|r_sparc_plt32
goto|;
block|}
name|h
operator|->
name|plt
operator|.
name|refcount
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|R_SPARC_PC10
case|:
case|case
name|R_SPARC_PC22
case|:
case|case
name|R_SPARC_PC_HH22
case|:
case|case
name|R_SPARC_PC_HM10
case|:
case|case
name|R_SPARC_PC_LM22
case|:
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|h
operator|->
name|non_got_ref
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|)
operator|==
literal|0
condition|)
break|break;
comment|/* Fall through.  */
case|case
name|R_SPARC_DISP8
case|:
case|case
name|R_SPARC_DISP16
case|:
case|case
name|R_SPARC_DISP32
case|:
case|case
name|R_SPARC_DISP64
case|:
case|case
name|R_SPARC_WDISP30
case|:
case|case
name|R_SPARC_WDISP22
case|:
case|case
name|R_SPARC_WDISP19
case|:
case|case
name|R_SPARC_WDISP16
case|:
case|case
name|R_SPARC_8
case|:
case|case
name|R_SPARC_16
case|:
case|case
name|R_SPARC_32
case|:
case|case
name|R_SPARC_HI22
case|:
case|case
name|R_SPARC_22
case|:
case|case
name|R_SPARC_13
case|:
case|case
name|R_SPARC_LO10
case|:
case|case
name|R_SPARC_UA16
case|:
case|case
name|R_SPARC_UA32
case|:
case|case
name|R_SPARC_10
case|:
case|case
name|R_SPARC_11
case|:
case|case
name|R_SPARC_64
case|:
case|case
name|R_SPARC_OLO10
case|:
case|case
name|R_SPARC_HH22
case|:
case|case
name|R_SPARC_HM10
case|:
case|case
name|R_SPARC_LM22
case|:
case|case
name|R_SPARC_7
case|:
case|case
name|R_SPARC_5
case|:
case|case
name|R_SPARC_6
case|:
case|case
name|R_SPARC_HIX22
case|:
case|case
name|R_SPARC_LOX10
case|:
case|case
name|R_SPARC_H44
case|:
case|case
name|R_SPARC_M44
case|:
case|case
name|R_SPARC_L44
case|:
case|case
name|R_SPARC_UA64
case|:
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|h
operator|->
name|non_got_ref
operator|=
literal|1
expr_stmt|;
name|r_sparc_plt32
label|:
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|!
name|info
operator|->
name|shared
condition|)
block|{
comment|/* We may need a .plt entry if the function this reloc 		 refers to is in a shared lib.  */
name|h
operator|->
name|plt
operator|.
name|refcount
operator|+=
literal|1
expr_stmt|;
block|}
comment|/* If we are creating a shared library, and this is a reloc 	     against a global symbol, or a non PC relative reloc 	     against a local symbol, then we need to copy the reloc 	     into the shared library.  However, if we are linking with 	     -Bsymbolic, we do not need to copy a reloc against a 	     global symbol which is defined in an object we are 	     including in the link (i.e., DEF_REGULAR is set).  At 	     this point we have not seen all the input files, so it is 	     possible that DEF_REGULAR is not set now but will be set 	     later (it is never cleared).  In case of a weak definition, 	     DEF_REGULAR may be cleared later by a strong definition in 	     a shared library.  We account for that possibility below by 	     storing information in the relocs_copied field of the hash 	     table entry.  A similar situation occurs when creating 	     shared libraries and symbol visibility changes render the 	     symbol local.  	     If on the other hand, we are creating an executable, we 	     may need to keep relocations for symbols satisfied by a 	     dynamic library if we manage to avoid copy relocs for the 	     symbol.  */
if|if
condition|(
operator|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|!
name|_bfd_sparc_elf_howto_table
index|[
name|r_type
index|]
operator|.
name|pc_relative
operator|||
operator|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
operator|!
name|info
operator|->
name|symbolic
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|||
operator|!
name|h
operator|->
name|def_regular
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
operator|!
name|info
operator|->
name|shared
operator|&&
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
operator|&&
name|h
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|||
operator|!
name|h
operator|->
name|def_regular
operator|)
operator|)
condition|)
block|{
name|struct
name|_bfd_sparc_elf_dyn_relocs
modifier|*
name|p
decl_stmt|;
name|struct
name|_bfd_sparc_elf_dyn_relocs
modifier|*
modifier|*
name|head
decl_stmt|;
comment|/* When creating a shared object, we must copy these 		 relocs into the output file.  We create a reloc 		 section in dynobj and make room for the reloc.  */
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|name
operator|=
operator|(
name|bfd_elf_string_from_elf_section
argument_list|(
name|abfd
argument_list|,
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_shstrndx
argument_list|,
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|rel_hdr
operator|.
name|sh_name
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|BFD_ASSERT
argument_list|(
name|CONST_STRNEQ
argument_list|(
name|name
argument_list|,
literal|".rela"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|,
name|name
operator|+
literal|5
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
operator|==
name|NULL
condition|)
name|htab
operator|->
name|elf
operator|.
name|dynobj
operator|=
name|abfd
expr_stmt|;
name|dynobj
operator|=
name|htab
operator|->
name|elf
operator|.
name|dynobj
expr_stmt|;
name|sreloc
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
block|{
name|flagword
name|flags
decl_stmt|;
name|flags
operator|=
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_READONLY
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
name|flags
operator||=
name|SEC_ALLOC
operator||
name|SEC_LOAD
expr_stmt|;
name|sreloc
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|dynobj
argument_list|,
name|name
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|sreloc
argument_list|,
name|htab
operator|->
name|word_align_power
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|sreloc
operator|=
name|sreloc
expr_stmt|;
block|}
comment|/* If this is a global symbol, we count the number of 		 relocations we need for this symbol.  */
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|head
operator|=
operator|&
operator|(
operator|(
expr|struct
name|_bfd_sparc_elf_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|dyn_relocs
expr_stmt|;
else|else
block|{
comment|/* Track dynamic relocs needed for local syms too. 		     We really need local syms available to do this 		     easily.  Oh well.  */
name|asection
modifier|*
name|s
decl_stmt|;
name|void
modifier|*
name|vpp
decl_stmt|;
name|s
operator|=
name|bfd_section_from_r_symndx
argument_list|(
name|abfd
argument_list|,
operator|&
name|htab
operator|->
name|sym_sec
argument_list|,
name|sec
argument_list|,
name|r_symndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|vpp
operator|=
operator|&
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|local_dynrel
expr_stmt|;
name|head
operator|=
operator|(
expr|struct
name|_bfd_sparc_elf_dyn_relocs
operator|*
operator|*
operator|)
name|vpp
expr_stmt|;
block|}
name|p
operator|=
operator|*
name|head
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|p
operator|->
name|sec
operator|!=
name|sec
condition|)
block|{
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
expr|*
name|p
decl_stmt|;
name|p
operator|=
operator|(
operator|(
expr|struct
name|_bfd_sparc_elf_dyn_relocs
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|amt
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|p
operator|->
name|next
operator|=
operator|*
name|head
expr_stmt|;
operator|*
name|head
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|sec
operator|=
name|sec
expr_stmt|;
name|p
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|pc_count
operator|=
literal|0
expr_stmt|;
block|}
name|p
operator|->
name|count
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|_bfd_sparc_elf_howto_table
index|[
name|r_type
index|]
operator|.
name|pc_relative
condition|)
name|p
operator|->
name|pc_count
operator|+=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|R_SPARC_GNU_VTINHERIT
case|:
if|if
condition|(
operator|!
name|bfd_elf_gc_record_vtinherit
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|h
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|R_SPARC_GNU_VTENTRY
case|:
if|if
condition|(
operator|!
name|bfd_elf_gc_record_vtentry
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|h
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|R_SPARC_REGISTER
case|:
comment|/* Nothing to do.  */
break|break;
default|default:
break|break;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|asection
modifier|*
name|_bfd_sparc_elf_gc_mark_hook
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|rel
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|)
block|{
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
switch|switch
condition|(
name|SPARC_ELF_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_SPARC_GNU_VTINHERIT
case|:
case|case
name|R_SPARC_GNU_VTENTRY
case|:
return|return
name|NULL
return|;
block|}
return|return
name|_bfd_elf_gc_mark_hook
argument_list|(
name|sec
argument_list|,
name|info
argument_list|,
name|rel
argument_list|,
name|h
argument_list|,
name|sym
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Update the got entry reference counts for the section being removed.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_sparc_elf_gc_sweep_hook
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
parameter_list|)
block|{
name|struct
name|_bfd_sparc_elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|bfd_signed_vma
modifier|*
name|local_got_refcounts
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|,
modifier|*
name|relend
decl_stmt|;
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|local_dynrel
operator|=
name|NULL
expr_stmt|;
name|htab
operator|=
name|_bfd_sparc_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|local_got_refcounts
operator|=
name|elf_local_got_refcounts
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|unsigned
name|int
name|r_type
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
init|=
name|NULL
decl_stmt|;
name|r_symndx
operator|=
name|SPARC_ELF_R_SYMNDX
argument_list|(
name|htab
argument_list|,
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|>=
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|struct
name|_bfd_sparc_elf_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|struct
name|_bfd_sparc_elf_dyn_relocs
modifier|*
modifier|*
name|pp
decl_stmt|;
name|struct
name|_bfd_sparc_elf_dyn_relocs
modifier|*
name|p
decl_stmt|;
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|_bfd_sparc_elf_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
for|for
control|(
name|pp
operator|=
operator|&
name|eh
operator|->
name|dyn_relocs
init|;
operator|(
name|p
operator|=
operator|*
name|pp
operator|)
operator|!=
name|NULL
condition|;
name|pp
operator|=
operator|&
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|sec
operator|==
name|sec
condition|)
block|{
comment|/* Everything must go for SEC.  */
operator|*
name|pp
operator|=
name|p
operator|->
name|next
expr_stmt|;
break|break;
block|}
block|}
name|r_type
operator|=
name|SPARC_ELF_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|sparc_elf_tls_transition
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
name|r_type
argument_list|,
name|h
operator|!=
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_SPARC_TLS_LDM_HI22
case|:
case|case
name|R_SPARC_TLS_LDM_LO10
case|:
if|if
condition|(
name|_bfd_sparc_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|tls_ldm_got
operator|.
name|refcount
operator|>
literal|0
condition|)
name|_bfd_sparc_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|tls_ldm_got
operator|.
name|refcount
operator|-=
literal|1
expr_stmt|;
break|break;
case|case
name|R_SPARC_TLS_GD_HI22
case|:
case|case
name|R_SPARC_TLS_GD_LO10
case|:
case|case
name|R_SPARC_TLS_IE_HI22
case|:
case|case
name|R_SPARC_TLS_IE_LO10
case|:
case|case
name|R_SPARC_GOT10
case|:
case|case
name|R_SPARC_GOT13
case|:
case|case
name|R_SPARC_GOT22
case|:
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|refcount
operator|>
literal|0
condition|)
name|h
operator|->
name|got
operator|.
name|refcount
operator|--
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|local_got_refcounts
index|[
name|r_symndx
index|]
operator|>
literal|0
condition|)
name|local_got_refcounts
index|[
name|r_symndx
index|]
operator|--
expr_stmt|;
block|}
break|break;
case|case
name|R_SPARC_PC10
case|:
case|case
name|R_SPARC_PC22
case|:
case|case
name|R_SPARC_PC_HH22
case|:
case|case
name|R_SPARC_PC_HM10
case|:
case|case
name|R_SPARC_PC_LM22
case|:
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|)
operator|==
literal|0
condition|)
break|break;
comment|/* Fall through.  */
case|case
name|R_SPARC_DISP8
case|:
case|case
name|R_SPARC_DISP16
case|:
case|case
name|R_SPARC_DISP32
case|:
case|case
name|R_SPARC_DISP64
case|:
case|case
name|R_SPARC_WDISP30
case|:
case|case
name|R_SPARC_WDISP22
case|:
case|case
name|R_SPARC_WDISP19
case|:
case|case
name|R_SPARC_WDISP16
case|:
case|case
name|R_SPARC_8
case|:
case|case
name|R_SPARC_16
case|:
case|case
name|R_SPARC_32
case|:
case|case
name|R_SPARC_HI22
case|:
case|case
name|R_SPARC_22
case|:
case|case
name|R_SPARC_13
case|:
case|case
name|R_SPARC_LO10
case|:
case|case
name|R_SPARC_UA16
case|:
case|case
name|R_SPARC_UA32
case|:
case|case
name|R_SPARC_PLT32
case|:
case|case
name|R_SPARC_10
case|:
case|case
name|R_SPARC_11
case|:
case|case
name|R_SPARC_64
case|:
case|case
name|R_SPARC_OLO10
case|:
case|case
name|R_SPARC_HH22
case|:
case|case
name|R_SPARC_HM10
case|:
case|case
name|R_SPARC_LM22
case|:
case|case
name|R_SPARC_7
case|:
case|case
name|R_SPARC_5
case|:
case|case
name|R_SPARC_6
case|:
case|case
name|R_SPARC_HIX22
case|:
case|case
name|R_SPARC_LOX10
case|:
case|case
name|R_SPARC_H44
case|:
case|case
name|R_SPARC_M44
case|:
case|case
name|R_SPARC_L44
case|:
case|case
name|R_SPARC_UA64
case|:
if|if
condition|(
name|info
operator|->
name|shared
condition|)
break|break;
comment|/* Fall through.  */
case|case
name|R_SPARC_WPLT30
case|:
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|refcount
operator|>
literal|0
condition|)
name|h
operator|->
name|plt
operator|.
name|refcount
operator|--
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Adjust a symbol defined by a dynamic object and referenced by a    regular object.  The current definition is in some section of the    dynamic object, but we're not including those sections.  We have to    change the definition to something the rest of the link can    understand.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_sparc_elf_adjust_dynamic_symbol
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|)
block|{
name|struct
name|_bfd_sparc_elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|struct
name|_bfd_sparc_elf_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|struct
name|_bfd_sparc_elf_dyn_relocs
modifier|*
name|p
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|htab
operator|=
name|_bfd_sparc_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* Make sure we know what is going on here.  */
name|BFD_ASSERT
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|needs_plt
operator|||
name|h
operator|->
name|u
operator|.
name|weakdef
operator|!=
name|NULL
operator|||
operator|(
name|h
operator|->
name|def_dynamic
operator|&&
name|h
operator|->
name|ref_regular
operator|&&
operator|!
name|h
operator|->
name|def_regular
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* If this is a function, put it in the procedure linkage table.  We      will fill in the contents of the procedure linkage table later      (although we could actually do it here).  The STT_NOTYPE      condition is a hack specifically for the Oracle libraries      delivered for Solaris; for some inexplicable reason, they define      some of their functions as STT_NOTYPE when they really should be      STT_FUNC.  */
if|if
condition|(
name|h
operator|->
name|type
operator|==
name|STT_FUNC
operator|||
name|h
operator|->
name|needs_plt
operator|||
operator|(
name|h
operator|->
name|type
operator|==
name|STT_NOTYPE
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|flags
operator|&
name|SEC_CODE
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|refcount
operator|<=
literal|0
operator|||
operator|(
operator|!
name|info
operator|->
name|shared
operator|&&
operator|!
name|h
operator|->
name|def_dynamic
operator|&&
operator|!
name|h
operator|->
name|ref_dynamic
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefweak
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefined
operator|)
condition|)
block|{
comment|/* This case can occur if we saw a WPLT30 reloc in an input 	     file, but the symbol was never referred to by a dynamic 	     object, or if all references were garbage collected.  In 	     such a case, we don't actually need to build a procedure 	     linkage table, and we can just do a WDISP30 reloc instead.  */
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
name|h
operator|->
name|needs_plt
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
else|else
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* If this is a weak symbol, and there is a real definition, the      processor independent code will have arranged for us to see the      real definition first, and we can just use the same value.  */
if|if
condition|(
name|h
operator|->
name|u
operator|.
name|weakdef
operator|!=
name|NULL
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
argument_list|)
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* This is a reference to a symbol defined by a dynamic object which      is not a function.  */
comment|/* If we are creating a shared library, we must presume that the      only references to the symbol are via the global offset table.      For such cases we need not do anything here; the relocations will      be handled correctly by relocate_section.  */
if|if
condition|(
name|info
operator|->
name|shared
condition|)
return|return
name|TRUE
return|;
comment|/* If there are no references to this symbol that do not use the      GOT, we don't need to generate a copy reloc.  */
if|if
condition|(
operator|!
name|h
operator|->
name|non_got_ref
condition|)
return|return
name|TRUE
return|;
name|eh
operator|=
operator|(
expr|struct
name|_bfd_sparc_elf_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
for|for
control|(
name|p
operator|=
name|eh
operator|->
name|dyn_relocs
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|s
operator|=
name|p
operator|->
name|sec
operator|->
name|output_section
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|!=
literal|0
condition|)
break|break;
block|}
comment|/* If we didn't find any dynamic relocs in read-only sections, then      we'll be keeping the dynamic relocs and avoiding the copy reloc.  */
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|h
operator|->
name|non_got_ref
operator|=
literal|0
expr_stmt|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
name|h
operator|->
name|size
operator|==
literal|0
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"dynamic variable `%s' is zero size"
argument_list|)
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* We must allocate the symbol in our .dynbss section, which will      become part of the .bss section of the executable.  There will be      an entry for this symbol in the .dynsym section.  The dynamic      object will contain position independent code, so all references      from the dynamic object to this symbol will go through the global      offset table.  The dynamic linker will use the .dynsym entry to      determine the address it must put in the global offset table, so      both the dynamic object and the regular object will refer to the      same memory location for the variable.  */
comment|/* We must generate a R_SPARC_COPY reloc to tell the dynamic linker      to copy the initial value out of the dynamic object and into the      runtime process image.  We need to remember the offset into the      .rel.bss section we are going to use.  */
if|if
condition|(
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
name|htab
operator|->
name|srelbss
operator|->
name|size
operator|+=
name|SPARC_ELF_RELA_BYTES
argument_list|(
name|htab
argument_list|)
expr_stmt|;
name|h
operator|->
name|needs_copy
operator|=
literal|1
expr_stmt|;
block|}
name|s
operator|=
name|htab
operator|->
name|sdynbss
expr_stmt|;
return|return
name|_bfd_elf_adjust_dynamic_copy
argument_list|(
name|h
argument_list|,
name|s
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Allocate space in .plt, .got and associated reloc sections for    dynamic relocs.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|allocate_dynrelocs
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|PTR
name|inf
parameter_list|)
block|{
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|_bfd_sparc_elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|struct
name|_bfd_sparc_elf_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|struct
name|_bfd_sparc_elf_dyn_relocs
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
comment|/* When warning symbols are created, they **replace** the "real"        entry in the hash table, thus we never get to see the real        symbol in a hash traversal.  So look at it now.  */
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|info
operator|=
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|)
name|inf
expr_stmt|;
name|htab
operator|=
name|_bfd_sparc_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|elf
operator|.
name|dynamic_sections_created
operator|&&
name|h
operator|->
name|plt
operator|.
name|refcount
operator|>
literal|0
condition|)
block|{
comment|/* Make sure this symbol is output as a dynamic symbol. 	 Undefined weak syms won't yet be marked as dynamic.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|&&
operator|!
name|h
operator|->
name|forced_local
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|WILL_CALL_FINISH_DYNAMIC_SYMBOL
argument_list|(
literal|1
argument_list|,
name|info
operator|->
name|shared
argument_list|,
name|h
argument_list|)
condition|)
block|{
name|asection
modifier|*
name|s
init|=
name|htab
operator|->
name|splt
decl_stmt|;
comment|/* Allocate room for the header.  */
if|if
condition|(
name|s
operator|->
name|size
operator|==
literal|0
condition|)
block|{
name|s
operator|->
name|size
operator|=
name|htab
operator|->
name|plt_header_size
expr_stmt|;
comment|/* Allocate space for the .rela.plt.unloaded relocations.  */
if|if
condition|(
name|htab
operator|->
name|is_vxworks
operator|&&
operator|!
name|info
operator|->
name|shared
condition|)
name|htab
operator|->
name|srelplt2
operator|->
name|size
operator|=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
operator|*
literal|2
expr_stmt|;
block|}
comment|/* The procedure linkage table size is bounded by the magnitude 	     of the offset we can describe in the entry.  */
if|if
condition|(
name|s
operator|->
name|size
operator|>=
operator|(
name|SPARC_ELF_WORD_BYTES
argument_list|(
name|htab
argument_list|)
operator|==
literal|8
condition|?
operator|(
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
literal|31
operator|)
operator|<<
literal|1
operator|)
else|:
literal|0x400000
operator|)
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|SPARC_ELF_WORD_BYTES
argument_list|(
name|htab
argument_list|)
operator|==
literal|8
operator|&&
name|s
operator|->
name|size
operator|>=
name|PLT64_LARGE_THRESHOLD
operator|*
name|PLT64_ENTRY_SIZE
condition|)
block|{
name|bfd_vma
name|off
init|=
name|s
operator|->
name|size
operator|-
name|PLT64_LARGE_THRESHOLD
operator|*
name|PLT64_ENTRY_SIZE
decl_stmt|;
name|off
operator|=
operator|(
name|off
operator|%
operator|(
literal|160
operator|*
name|PLT64_ENTRY_SIZE
operator|)
operator|)
operator|/
name|PLT64_ENTRY_SIZE
expr_stmt|;
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
operator|(
name|s
operator|->
name|size
operator|-
operator|(
name|off
operator|*
literal|8
operator|)
operator|)
expr_stmt|;
block|}
else|else
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
name|s
operator|->
name|size
expr_stmt|;
comment|/* If this symbol is not defined in a regular file, and we are 	     not generating a shared library, then set the symbol to this 	     location in the .plt.  This is required to make function 	     pointers compare as equal between the normal executable and 	     the shared library.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
operator|&&
operator|!
name|h
operator|->
name|def_regular
condition|)
block|{
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|s
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|h
operator|->
name|plt
operator|.
name|offset
expr_stmt|;
block|}
comment|/* Make room for this entry.  */
name|s
operator|->
name|size
operator|+=
name|htab
operator|->
name|plt_entry_size
expr_stmt|;
comment|/* We also need to make an entry in the .rela.plt section.  */
name|htab
operator|->
name|srelplt
operator|->
name|size
operator|+=
name|SPARC_ELF_RELA_BYTES
argument_list|(
name|htab
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|is_vxworks
condition|)
block|{
comment|/* Allocate space for the .got.plt entry.  */
name|htab
operator|->
name|sgotplt
operator|->
name|size
operator|+=
literal|4
expr_stmt|;
comment|/* ...and for the .rela.plt.unloaded relocations.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
name|htab
operator|->
name|srelplt2
operator|->
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
operator|*
literal|3
expr_stmt|;
block|}
block|}
else|else
block|{
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
name|h
operator|->
name|needs_plt
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
name|h
operator|->
name|needs_plt
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If R_SPARC_TLS_IE_{HI22,LO10} symbol is now local to the binary,      make it a R_SPARC_TLS_LE_{HI22,LO10} requiring no TLS entry.  */
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|refcount
operator|>
literal|0
operator|&&
operator|!
name|info
operator|->
name|shared
operator|&&
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|&&
name|_bfd_sparc_elf_hash_entry
argument_list|(
name|h
argument_list|)
operator|->
name|tls_type
operator|==
name|GOT_TLS_IE
condition|)
name|h
operator|->
name|got
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|refcount
operator|>
literal|0
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_boolean
name|dyn
decl_stmt|;
name|int
name|tls_type
init|=
name|_bfd_sparc_elf_hash_entry
argument_list|(
name|h
argument_list|)
operator|->
name|tls_type
decl_stmt|;
comment|/* Make sure this symbol is output as a dynamic symbol. 	 Undefined weak syms won't yet be marked as dynamic.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|&&
operator|!
name|h
operator|->
name|forced_local
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
name|s
operator|=
name|htab
operator|->
name|sgot
expr_stmt|;
name|h
operator|->
name|got
operator|.
name|offset
operator|=
name|s
operator|->
name|size
expr_stmt|;
name|s
operator|->
name|size
operator|+=
name|SPARC_ELF_WORD_BYTES
argument_list|(
name|htab
argument_list|)
expr_stmt|;
comment|/* R_SPARC_TLS_GD_HI{22,LO10} needs 2 consecutive GOT slots.  */
if|if
condition|(
name|tls_type
operator|==
name|GOT_TLS_GD
condition|)
name|s
operator|->
name|size
operator|+=
name|SPARC_ELF_WORD_BYTES
argument_list|(
name|htab
argument_list|)
expr_stmt|;
name|dyn
operator|=
name|htab
operator|->
name|elf
operator|.
name|dynamic_sections_created
expr_stmt|;
comment|/* R_SPARC_TLS_IE_{HI22,LO10} needs one dynamic relocation, 	 R_SPARC_TLS_GD_{HI22,LO10} needs one if local symbol and two if 	 global.  */
if|if
condition|(
operator|(
name|tls_type
operator|==
name|GOT_TLS_GD
operator|&&
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|)
operator|||
name|tls_type
operator|==
name|GOT_TLS_IE
condition|)
name|htab
operator|->
name|srelgot
operator|->
name|size
operator|+=
name|SPARC_ELF_RELA_BYTES
argument_list|(
name|htab
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tls_type
operator|==
name|GOT_TLS_GD
condition|)
name|htab
operator|->
name|srelgot
operator|->
name|size
operator|+=
literal|2
operator|*
name|SPARC_ELF_RELA_BYTES
argument_list|(
name|htab
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|WILL_CALL_FINISH_DYNAMIC_SYMBOL
argument_list|(
name|dyn
argument_list|,
name|info
operator|->
name|shared
argument_list|,
name|h
argument_list|)
condition|)
name|htab
operator|->
name|srelgot
operator|->
name|size
operator|+=
name|SPARC_ELF_RELA_BYTES
argument_list|(
name|htab
argument_list|)
expr_stmt|;
block|}
else|else
name|h
operator|->
name|got
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|_bfd_sparc_elf_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
if|if
condition|(
name|eh
operator|->
name|dyn_relocs
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
comment|/* In the shared -Bsymbolic case, discard space allocated for      dynamic pc-relative relocs against symbols which turn out to be      defined in regular objects.  For the normal shared case, discard      space for pc-relative relocs that have become local due to symbol      visibility changes.  */
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|def_regular
operator|&&
operator|(
name|h
operator|->
name|forced_local
operator|||
name|info
operator|->
name|symbolic
operator|)
condition|)
block|{
name|struct
name|_bfd_sparc_elf_dyn_relocs
modifier|*
modifier|*
name|pp
decl_stmt|;
for|for
control|(
name|pp
operator|=
operator|&
name|eh
operator|->
name|dyn_relocs
init|;
operator|(
name|p
operator|=
operator|*
name|pp
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
name|p
operator|->
name|count
operator|-=
name|p
operator|->
name|pc_count
expr_stmt|;
name|p
operator|->
name|pc_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|count
operator|==
literal|0
condition|)
operator|*
name|pp
operator|=
name|p
operator|->
name|next
expr_stmt|;
else|else
name|pp
operator|=
operator|&
name|p
operator|->
name|next
expr_stmt|;
block|}
block|}
comment|/* Also discard relocs on undefined weak syms with non-default 	 visibility.  */
if|if
condition|(
name|eh
operator|->
name|dyn_relocs
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
block|{
if|if
condition|(
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|!=
name|STV_DEFAULT
condition|)
name|eh
operator|->
name|dyn_relocs
operator|=
name|NULL
expr_stmt|;
comment|/* Make sure undefined weak symbols are output as a dynamic 	     symbol in PIEs.  */
elseif|else
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|&&
operator|!
name|h
operator|->
name|forced_local
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
block|}
else|else
block|{
comment|/* For the non-shared case, discard space for relocs against 	 symbols which turn out to need copy relocs or are not 	 dynamic.  */
if|if
condition|(
operator|!
name|h
operator|->
name|non_got_ref
operator|&&
operator|(
operator|(
name|h
operator|->
name|def_dynamic
operator|&&
operator|!
name|h
operator|->
name|def_regular
operator|)
operator|||
operator|(
name|htab
operator|->
name|elf
operator|.
name|dynamic_sections_created
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* Make sure this symbol is output as a dynamic symbol. 	     Undefined weak syms won't yet be marked as dynamic.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|&&
operator|!
name|h
operator|->
name|forced_local
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* If that succeeded, we know we'll be keeping all the 	     relocs.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
condition|)
goto|goto
name|keep
goto|;
block|}
name|eh
operator|->
name|dyn_relocs
operator|=
name|NULL
expr_stmt|;
name|keep
label|:
empty_stmt|;
block|}
comment|/* Finally, allocate space.  */
for|for
control|(
name|p
operator|=
name|eh
operator|->
name|dyn_relocs
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|asection
modifier|*
name|sreloc
init|=
name|elf_section_data
argument_list|(
name|p
operator|->
name|sec
argument_list|)
operator|->
name|sreloc
decl_stmt|;
name|sreloc
operator|->
name|size
operator|+=
name|p
operator|->
name|count
operator|*
name|SPARC_ELF_RELA_BYTES
argument_list|(
name|htab
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Find any dynamic relocs that apply to read-only sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|readonly_dynrelocs
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|PTR
name|inf
parameter_list|)
block|{
name|struct
name|_bfd_sparc_elf_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|struct
name|_bfd_sparc_elf_dyn_relocs
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|_bfd_sparc_elf_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
for|for
control|(
name|p
operator|=
name|eh
operator|->
name|dyn_relocs
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|asection
modifier|*
name|s
init|=
name|p
operator|->
name|sec
operator|->
name|output_section
decl_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|bfd_link_info
modifier|*
name|info
init|=
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|)
name|inf
decl_stmt|;
name|info
operator|->
name|flags
operator||=
name|DF_TEXTREL
expr_stmt|;
comment|/* Not an error, just cut short the traversal.  */
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return true if the dynamic symbol for a given section should be    omitted when creating a shared library.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_sparc_elf_omit_section_dynsym
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|asection
modifier|*
name|p
parameter_list|)
block|{
comment|/* We keep the .got section symbol so that explicit relocations      against the _GLOBAL_OFFSET_TABLE_ symbol emitted in PIC mode      can be turned into relocations against the .got symbol.  */
if|if
condition|(
name|strcmp
argument_list|(
name|p
operator|->
name|name
argument_list|,
literal|".got"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|FALSE
return|;
return|return
name|_bfd_elf_link_omit_section_dynsym
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|p
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Set the sizes of the dynamic sections.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_sparc_elf_size_dynamic_sections
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|_bfd_sparc_elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|htab
operator|=
name|_bfd_sparc_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|dynobj
operator|=
name|htab
operator|->
name|elf
operator|.
name|dynobj
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|dynobj
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
comment|/* Set the contents of the .interp section to the interpreter.  */
if|if
condition|(
name|info
operator|->
name|executable
condition|)
block|{
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".interp"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|size
operator|=
name|htab
operator|->
name|dynamic_interpreter_size
expr_stmt|;
name|s
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|htab
operator|->
name|dynamic_interpreter
expr_stmt|;
block|}
block|}
comment|/* Set up .got offsets for local syms, and space for local dynamic      relocs.  */
for|for
control|(
name|ibfd
operator|=
name|info
operator|->
name|input_bfds
init|;
name|ibfd
operator|!=
name|NULL
condition|;
name|ibfd
operator|=
name|ibfd
operator|->
name|link_next
control|)
block|{
name|bfd_signed_vma
modifier|*
name|local_got
decl_stmt|;
name|bfd_signed_vma
modifier|*
name|end_local_got
decl_stmt|;
name|char
modifier|*
name|local_tls_type
decl_stmt|;
name|bfd_size_type
name|locsymcount
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|asection
modifier|*
name|srel
decl_stmt|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|ibfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
continue|continue;
for|for
control|(
name|s
operator|=
name|ibfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|struct
name|_bfd_sparc_elf_dyn_relocs
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|local_dynrel
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|bfd_is_abs_section
argument_list|(
name|p
operator|->
name|sec
argument_list|)
operator|&&
name|bfd_is_abs_section
argument_list|(
name|p
operator|->
name|sec
operator|->
name|output_section
argument_list|)
condition|)
block|{
comment|/* Input section has been discarded, either because 		     it is a copy of a linkonce section or due to 		     linker script /DISCARD/, so we'll be discarding 		     the relocs too.  */
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|count
operator|!=
literal|0
condition|)
block|{
name|srel
operator|=
name|elf_section_data
argument_list|(
name|p
operator|->
name|sec
argument_list|)
operator|->
name|sreloc
expr_stmt|;
name|srel
operator|->
name|size
operator|+=
name|p
operator|->
name|count
operator|*
name|SPARC_ELF_RELA_BYTES
argument_list|(
name|htab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|sec
operator|->
name|output_section
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|!=
literal|0
condition|)
name|info
operator|->
name|flags
operator||=
name|DF_TEXTREL
expr_stmt|;
block|}
block|}
block|}
name|local_got
operator|=
name|elf_local_got_refcounts
argument_list|(
name|ibfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|local_got
condition|)
continue|continue;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|locsymcount
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|end_local_got
operator|=
name|local_got
operator|+
name|locsymcount
expr_stmt|;
name|local_tls_type
operator|=
name|_bfd_sparc_elf_local_got_tls_type
argument_list|(
name|ibfd
argument_list|)
expr_stmt|;
name|s
operator|=
name|htab
operator|->
name|sgot
expr_stmt|;
name|srel
operator|=
name|htab
operator|->
name|srelgot
expr_stmt|;
for|for
control|(
init|;
name|local_got
operator|<
name|end_local_got
condition|;
operator|++
name|local_got
operator|,
operator|++
name|local_tls_type
control|)
block|{
if|if
condition|(
operator|*
name|local_got
operator|>
literal|0
condition|)
block|{
operator|*
name|local_got
operator|=
name|s
operator|->
name|size
expr_stmt|;
name|s
operator|->
name|size
operator|+=
name|SPARC_ELF_WORD_BYTES
argument_list|(
name|htab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|local_tls_type
operator|==
name|GOT_TLS_GD
condition|)
name|s
operator|->
name|size
operator|+=
name|SPARC_ELF_WORD_BYTES
argument_list|(
name|htab
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
operator|||
operator|*
name|local_tls_type
operator|==
name|GOT_TLS_GD
operator|||
operator|*
name|local_tls_type
operator|==
name|GOT_TLS_IE
condition|)
name|srel
operator|->
name|size
operator|+=
name|SPARC_ELF_RELA_BYTES
argument_list|(
name|htab
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|local_got
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|htab
operator|->
name|tls_ldm_got
operator|.
name|refcount
operator|>
literal|0
condition|)
block|{
comment|/* Allocate 2 got entries and 1 dynamic reloc for 	 R_SPARC_TLS_LDM_{HI22,LO10} relocs.  */
name|htab
operator|->
name|tls_ldm_got
operator|.
name|offset
operator|=
name|htab
operator|->
name|sgot
operator|->
name|size
expr_stmt|;
name|htab
operator|->
name|sgot
operator|->
name|size
operator|+=
operator|(
literal|2
operator|*
name|SPARC_ELF_WORD_BYTES
argument_list|(
name|htab
argument_list|)
operator|)
expr_stmt|;
name|htab
operator|->
name|srelgot
operator|->
name|size
operator|+=
name|SPARC_ELF_RELA_BYTES
argument_list|(
name|htab
argument_list|)
expr_stmt|;
block|}
else|else
name|htab
operator|->
name|tls_ldm_got
operator|.
name|offset
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Allocate global sym .plt and .got entries, and space for global      sym dynamic relocs.  */
name|elf_link_hash_traverse
argument_list|(
operator|&
name|htab
operator|->
name|elf
argument_list|,
name|allocate_dynrelocs
argument_list|,
operator|(
name|PTR
operator|)
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ABI_64_P
argument_list|(
name|output_bfd
argument_list|)
operator|&&
operator|!
name|htab
operator|->
name|is_vxworks
operator|&&
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
comment|/* Make space for the trailing nop in .plt.  */
if|if
condition|(
name|htab
operator|->
name|splt
operator|->
name|size
operator|>
literal|0
condition|)
name|htab
operator|->
name|splt
operator|->
name|size
operator|+=
literal|1
operator|*
name|SPARC_INSN_BYTES
expr_stmt|;
comment|/* If the .got section is more than 0x1000 bytes, we add 	 0x1000 to the value of _GLOBAL_OFFSET_TABLE_, so that 13 	 bit relocations have a greater chance of working.  	 FIXME: Make this optimization work for 64-bit too.  */
if|if
condition|(
name|htab
operator|->
name|sgot
operator|->
name|size
operator|>=
literal|0x1000
operator|&&
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|hgot
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|==
literal|0
condition|)
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|hgot
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
literal|0x1000
expr_stmt|;
block|}
comment|/* The check_relocs and adjust_dynamic_symbol entry points have      determined the sizes of the various dynamic sections.  Allocate      memory for them.  */
for|for
control|(
name|s
operator|=
name|dynobj
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LINKER_CREATED
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|s
operator|==
name|htab
operator|->
name|splt
operator|||
name|s
operator|==
name|htab
operator|->
name|sgot
operator|||
name|s
operator|==
name|htab
operator|->
name|sdynbss
operator|||
name|s
operator|==
name|htab
operator|->
name|sgotplt
condition|)
block|{
comment|/* Strip this section if we don't need it; see the 	     comment below.  */
block|}
elseif|else
if|if
condition|(
name|CONST_STRNEQ
argument_list|(
name|s
operator|->
name|name
argument_list|,
literal|".rela"
argument_list|)
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|size
operator|!=
literal|0
condition|)
block|{
comment|/* We use the reloc_count field as a counter if we need 		 to copy relocs into the output file.  */
name|s
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* It's not one of our sections.  */
continue|continue;
block|}
if|if
condition|(
name|s
operator|->
name|size
operator|==
literal|0
condition|)
block|{
comment|/* If we don't need this section, strip it from the 	     output file.  This is mostly to handle .rela.bss and 	     .rela.plt.  We must create both sections in 	     create_dynamic_sections, because they must be created 	     before the linker maps input sections to output 	     sections.  The linker does that before 	     adjust_dynamic_symbol is called, and it is that 	     function which decides whether anything needs to go 	     into these sections.  */
name|s
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* Allocate memory for the section contents.  Zero the memory 	 for the benefit of .rela.plt, which has 4 unused entries 	 at the beginning, and we don't want garbage.  */
name|s
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|dynobj
argument_list|,
name|s
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
comment|/* Add some entries to the .dynamic section.  We fill in the 	 values later, in _bfd_sparc_elf_finish_dynamic_sections, but we 	 must add the entries now so that we get the correct size for 	 the .dynamic section.  The DT_DEBUG entry is filled in by the 	 dynamic linker and used by the debugger.  */
define|#
directive|define
name|add_dynamic_entry
parameter_list|(
name|TAG
parameter_list|,
name|VAL
parameter_list|)
define|\
value|_bfd_elf_add_dynamic_entry (info, TAG, VAL)
if|if
condition|(
name|info
operator|->
name|executable
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_DEBUG
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|htab
operator|->
name|srelplt
operator|->
name|size
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PLTGOT
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PLTRELSZ
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PLTREL
argument_list|,
name|DT_RELA
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_JMPREL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELA
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELASZ
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELAENT
argument_list|,
name|SPARC_ELF_RELA_BYTES
argument_list|(
name|htab
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* If any dynamic relocs apply to a read-only section, 	 then we need a DT_TEXTREL entry.  */
if|if
condition|(
operator|(
name|info
operator|->
name|flags
operator|&
name|DF_TEXTREL
operator|)
operator|==
literal|0
condition|)
name|elf_link_hash_traverse
argument_list|(
operator|&
name|htab
operator|->
name|elf
argument_list|,
name|readonly_dynrelocs
argument_list|,
operator|(
name|PTR
operator|)
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|flags
operator|&
name|DF_TEXTREL
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_TEXTREL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|ABI_64_P
argument_list|(
name|output_bfd
argument_list|)
condition|)
block|{
name|int
name|reg
decl_stmt|;
name|struct
name|_bfd_sparc_elf_app_reg
modifier|*
name|app_regs
decl_stmt|;
name|struct
name|elf_strtab_hash
modifier|*
name|dynstr
decl_stmt|;
name|struct
name|elf_link_hash_table
modifier|*
name|eht
init|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
decl_stmt|;
comment|/* Add dynamic STT_REGISTER symbols and corresponding DT_SPARC_REGISTER 	     entries if needed.  */
name|app_regs
operator|=
name|_bfd_sparc_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|app_regs
expr_stmt|;
name|dynstr
operator|=
name|eht
operator|->
name|dynstr
expr_stmt|;
for|for
control|(
name|reg
operator|=
literal|0
init|;
name|reg
operator|<
literal|4
condition|;
name|reg
operator|++
control|)
if|if
condition|(
name|app_regs
index|[
name|reg
index|]
operator|.
name|name
operator|!=
name|NULL
condition|)
block|{
name|struct
name|elf_link_local_dynamic_entry
modifier|*
name|entry
decl_stmt|,
modifier|*
name|e
decl_stmt|;
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_SPARC_REGISTER
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|entry
operator|=
operator|(
expr|struct
name|elf_link_local_dynamic_entry
operator|*
operator|)
name|bfd_hash_allocate
argument_list|(
operator|&
name|info
operator|->
name|hash
operator|->
name|table
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* We cheat here a little bit: the symbol will not be local, so we 		   put it at the end of the dynlocal linked list.  We will fix it 		   later on, as we have to fix other fields anyway.  */
name|entry
operator|->
name|isym
operator|.
name|st_value
operator|=
name|reg
operator|<
literal|2
condition|?
name|reg
operator|+
literal|2
else|:
name|reg
operator|+
literal|4
expr_stmt|;
name|entry
operator|->
name|isym
operator|.
name|st_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|app_regs
index|[
name|reg
index|]
operator|.
name|name
operator|!=
literal|'\0'
condition|)
name|entry
operator|->
name|isym
operator|.
name|st_name
operator|=
name|_bfd_elf_strtab_add
argument_list|(
name|dynstr
argument_list|,
name|app_regs
index|[
name|reg
index|]
operator|.
name|name
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
else|else
name|entry
operator|->
name|isym
operator|.
name|st_name
operator|=
literal|0
expr_stmt|;
name|entry
operator|->
name|isym
operator|.
name|st_other
operator|=
literal|0
expr_stmt|;
name|entry
operator|->
name|isym
operator|.
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|app_regs
index|[
name|reg
index|]
operator|.
name|bind
argument_list|,
name|STT_REGISTER
argument_list|)
expr_stmt|;
name|entry
operator|->
name|isym
operator|.
name|st_shndx
operator|=
name|app_regs
index|[
name|reg
index|]
operator|.
name|shndx
expr_stmt|;
name|entry
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|entry
operator|->
name|input_bfd
operator|=
name|output_bfd
expr_stmt|;
name|entry
operator|->
name|input_indx
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|eht
operator|->
name|dynlocal
operator|==
name|NULL
condition|)
name|eht
operator|->
name|dynlocal
operator|=
name|entry
expr_stmt|;
else|else
block|{
for|for
control|(
name|e
operator|=
name|eht
operator|->
name|dynlocal
init|;
name|e
operator|->
name|next
condition|;
name|e
operator|=
name|e
operator|->
name|next
control|)
empty_stmt|;
name|e
operator|->
name|next
operator|=
name|entry
expr_stmt|;
block|}
name|eht
operator|->
name|dynsymcount
operator|++
expr_stmt|;
block|}
block|}
block|}
undef|#
directive|undef
name|add_dynamic_entry
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|bfd_boolean
name|_bfd_sparc_elf_new_section_hook
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|)
block|{
if|if
condition|(
operator|!
name|sec
operator|->
name|used_by_bfd
condition|)
block|{
name|struct
name|_bfd_sparc_elf_section_data
modifier|*
name|sdata
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
operator|*
name|sdata
argument_list|)
decl_stmt|;
name|sdata
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdata
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|sec
operator|->
name|used_by_bfd
operator|=
name|sdata
expr_stmt|;
block|}
return|return
name|_bfd_elf_new_section_hook
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|_bfd_sparc_elf_relax_section
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_section
modifier|*
name|section
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd_boolean
modifier|*
name|again
parameter_list|)
block|{
operator|*
name|again
operator|=
name|FALSE
expr_stmt|;
name|sec_do_relax
argument_list|(
name|section
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the base VMA address which should be subtracted from real addresses    when resolving @dtpoff relocation.    This is PT_TLS segment p_vaddr.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|dtpoff_base
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
comment|/* If tls_sec is NULL, we should have signalled an error already.  */
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|tls_sec
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
return|return
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|tls_sec
operator|->
name|vma
return|;
block|}
end_function

begin_comment
comment|/* Return the relocation value for @tpoff relocation    if STT_TLS virtual address is ADDRESS.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|tpoff
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd_vma
name|address
parameter_list|)
block|{
name|struct
name|elf_link_hash_table
modifier|*
name|htab
init|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
decl_stmt|;
comment|/* If tls_sec is NULL, we should have signalled an error already.  */
if|if
condition|(
name|htab
operator|->
name|tls_sec
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
return|return
name|address
operator|-
name|htab
operator|->
name|tls_size
operator|-
name|htab
operator|->
name|tls_sec
operator|->
name|vma
return|;
block|}
end_function

begin_comment
comment|/* Relocate a SPARC ELF section.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_sparc_elf_relocate_section
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|relocs
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|local_syms
parameter_list|,
name|asection
modifier|*
modifier|*
name|local_sections
parameter_list|)
block|{
name|struct
name|_bfd_sparc_elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|bfd_vma
modifier|*
name|local_got_offsets
decl_stmt|;
name|bfd_vma
name|got_base
decl_stmt|;
name|asection
modifier|*
name|sreloc
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relend
decl_stmt|;
name|int
name|num_relocs
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
name|htab
operator|=
name|_bfd_sparc_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|local_got_offsets
operator|=
name|elf_local_got_offsets
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|hgot
operator|==
name|NULL
condition|)
name|got_base
operator|=
literal|0
expr_stmt|;
else|else
name|got_base
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|hgot
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
name|sreloc
operator|=
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|sreloc
expr_stmt|;
name|rel
operator|=
name|relocs
expr_stmt|;
if|if
condition|(
name|ABI_64_P
argument_list|(
name|output_bfd
argument_list|)
condition|)
name|num_relocs
operator|=
name|NUM_SHDR_ENTRIES
argument_list|(
operator|&
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|rel_hdr
argument_list|)
expr_stmt|;
else|else
name|num_relocs
operator|=
name|input_section
operator|->
name|reloc_count
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|num_relocs
expr_stmt|;
for|for
control|(
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|int
name|r_type
decl_stmt|,
name|tls_type
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|,
name|off
decl_stmt|;
name|bfd_reloc_status_type
name|r
decl_stmt|;
name|bfd_boolean
name|is_plt
init|=
name|FALSE
decl_stmt|;
name|bfd_boolean
name|unresolved_reloc
decl_stmt|;
name|r_type
operator|=
name|SPARC_ELF_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_SPARC_GNU_VTINHERIT
operator|||
name|r_type
operator|==
name|R_SPARC_GNU_VTENTRY
condition|)
continue|continue;
if|if
condition|(
name|r_type
operator|<
literal|0
operator|||
name|r_type
operator|>=
operator|(
name|int
operator|)
name|R_SPARC_max_std
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|howto
operator|=
name|_bfd_sparc_elf_howto_table
operator|+
name|r_type
expr_stmt|;
name|r_symndx
operator|=
name|SPARC_ELF_R_SYMNDX
argument_list|(
name|htab
argument_list|,
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|h
operator|=
name|NULL
expr_stmt|;
name|sym
operator|=
name|NULL
expr_stmt|;
name|sec
operator|=
name|NULL
expr_stmt|;
name|unresolved_reloc
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|relocation
operator|=
name|_bfd_elf_rela_local_sym
argument_list|(
name|output_bfd
argument_list|,
name|sym
argument_list|,
operator|&
name|sec
argument_list|,
name|rel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bfd_boolean
name|warned
decl_stmt|;
name|RELOC_FOR_GLOBAL_SYMBOL
argument_list|(
name|info
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
argument_list|,
name|r_symndx
argument_list|,
name|symtab_hdr
argument_list|,
name|sym_hashes
argument_list|,
name|h
argument_list|,
name|sec
argument_list|,
name|relocation
argument_list|,
name|unresolved_reloc
argument_list|,
name|warned
argument_list|)
expr_stmt|;
if|if
condition|(
name|warned
condition|)
block|{
comment|/* To avoid generating warning messages about truncated 		 relocations, set the relocation's address to be the same as 		 the start of this section.  */
if|if
condition|(
name|input_section
operator|->
name|output_section
operator|!=
name|NULL
condition|)
name|relocation
operator|=
name|input_section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
else|else
name|relocation
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sec
operator|!=
name|NULL
operator|&&
name|elf_discarded_section
argument_list|(
name|sec
argument_list|)
condition|)
block|{
comment|/* For relocs against symbols from removed linkonce 	     sections, or sections discarded by a linker script, we 	     just want the section contents zeroed.  Avoid any 	     special processing.  */
name|_bfd_clear_contents
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|rel
operator|->
name|r_info
operator|=
literal|0
expr_stmt|;
name|rel
operator|->
name|r_addend
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
continue|continue;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_SPARC_GOT10
case|:
case|case
name|R_SPARC_GOT13
case|:
case|case
name|R_SPARC_GOT22
case|:
comment|/* Relocation is to the entry for this symbol in the global 	     offset table.  */
if|if
condition|(
name|htab
operator|->
name|sgot
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|bfd_boolean
name|dyn
decl_stmt|;
name|off
operator|=
name|h
operator|->
name|got
operator|.
name|offset
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|off
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|dyn
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
expr_stmt|;
if|if
condition|(
operator|!
name|WILL_CALL_FINISH_DYNAMIC_SYMBOL
argument_list|(
name|dyn
argument_list|,
name|info
operator|->
name|shared
argument_list|,
name|h
argument_list|)
operator|||
operator|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|info
operator|->
name|symbolic
operator|||
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|||
name|h
operator|->
name|forced_local
operator|)
operator|&&
name|h
operator|->
name|def_regular
operator|)
condition|)
block|{
comment|/* This is actually a static link, or it is a 		     -Bsymbolic link and the symbol is defined 		     locally, or the symbol was forced to be local 		     because of a version file.  We must initialize 		     this entry in the global offset table.  Since the 		     offset must always be a multiple of 8 for 64-bit 		     and 4 for 32-bit, we use the least significant bit 		     to record whether we have initialized it already.  		     When doing a dynamic link, we create a .rela.got 		     relocation entry to initialize the value.  This 		     is done in the finish_dynamic_symbol routine.  */
if|if
condition|(
operator|(
name|off
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|off
operator|&=
operator|~
literal|1
expr_stmt|;
else|else
block|{
name|SPARC_ELF_PUT_WORD
argument_list|(
name|htab
argument_list|,
name|output_bfd
argument_list|,
name|relocation
argument_list|,
name|htab
operator|->
name|sgot
operator|->
name|contents
operator|+
name|off
argument_list|)
expr_stmt|;
name|h
operator|->
name|got
operator|.
name|offset
operator||=
literal|1
expr_stmt|;
block|}
block|}
else|else
name|unresolved_reloc
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|BFD_ASSERT
argument_list|(
name|local_got_offsets
operator|!=
name|NULL
operator|&&
name|local_got_offsets
index|[
name|r_symndx
index|]
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|off
operator|=
name|local_got_offsets
index|[
name|r_symndx
index|]
expr_stmt|;
comment|/* The offset must always be a multiple of 8 on 64-bit and 		 4 on 32-bit.  We use the least significant bit to record 		 whether we have already processed this entry.  */
if|if
condition|(
operator|(
name|off
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|off
operator|&=
operator|~
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|Elf_Internal_Rela
name|outrel
decl_stmt|;
comment|/* We need to generate a R_SPARC_RELATIVE reloc 			 for the dynamic linker.  */
name|s
operator|=
name|htab
operator|->
name|srelgot
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|=
operator|(
name|htab
operator|->
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|sgot
operator|->
name|output_offset
operator|+
name|off
operator|)
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|SPARC_ELF_R_INFO
argument_list|(
name|htab
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|R_SPARC_RELATIVE
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
name|relocation
expr_stmt|;
name|relocation
operator|=
literal|0
expr_stmt|;
name|sparc_elf_append_rela
argument_list|(
name|output_bfd
argument_list|,
name|s
argument_list|,
operator|&
name|outrel
argument_list|)
expr_stmt|;
block|}
name|SPARC_ELF_PUT_WORD
argument_list|(
name|htab
argument_list|,
name|output_bfd
argument_list|,
name|relocation
argument_list|,
name|htab
operator|->
name|sgot
operator|->
name|contents
operator|+
name|off
argument_list|)
expr_stmt|;
name|local_got_offsets
index|[
name|r_symndx
index|]
operator||=
literal|1
expr_stmt|;
block|}
block|}
name|relocation
operator|=
name|htab
operator|->
name|sgot
operator|->
name|output_offset
operator|+
name|off
operator|-
name|got_base
expr_stmt|;
break|break;
case|case
name|R_SPARC_PLT32
case|:
case|case
name|R_SPARC_PLT64
case|:
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
name|h
operator|->
name|plt
operator|.
name|offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
name|r_type
operator|=
operator|(
name|r_type
operator|==
name|R_SPARC_PLT32
operator|)
condition|?
name|R_SPARC_32
else|:
name|R_SPARC_64
expr_stmt|;
goto|goto
name|r_sparc_plt32
goto|;
block|}
comment|/* Fall through.  */
case|case
name|R_SPARC_WPLT30
case|:
case|case
name|R_SPARC_HIPLT22
case|:
case|case
name|R_SPARC_LOPLT10
case|:
case|case
name|R_SPARC_PCPLT32
case|:
case|case
name|R_SPARC_PCPLT22
case|:
case|case
name|R_SPARC_PCPLT10
case|:
name|r_sparc_wplt30
label|:
comment|/* Relocation is to the entry for this symbol in the 	     procedure linkage table.  */
if|if
condition|(
operator|!
name|ABI_64_P
argument_list|(
name|output_bfd
argument_list|)
condition|)
block|{
comment|/* The Solaris native assembler will generate a WPLT30 reloc 		 for a local symbol if you assemble a call from one 		 section to another when using -K pic.  We treat it as 		 WDISP30.  */
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
break|break;
block|}
else|else
block|{
name|BFD_ASSERT
argument_list|(
name|h
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|||
name|htab
operator|->
name|splt
operator|==
name|NULL
condition|)
block|{
comment|/* We didn't make a PLT entry for this symbol.  This 		 happens when statically linking PIC code, or when 		 using -Bsymbolic.  */
break|break;
block|}
name|relocation
operator|=
operator|(
name|htab
operator|->
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|splt
operator|->
name|output_offset
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|)
expr_stmt|;
name|unresolved_reloc
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_SPARC_PLT32
operator|||
name|r_type
operator|==
name|R_SPARC_PLT64
condition|)
block|{
name|r_type
operator|=
name|r_type
operator|==
name|R_SPARC_PLT32
condition|?
name|R_SPARC_32
else|:
name|R_SPARC_64
expr_stmt|;
name|is_plt
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|r_sparc_plt32
goto|;
block|}
break|break;
case|case
name|R_SPARC_PC10
case|:
case|case
name|R_SPARC_PC22
case|:
case|case
name|R_SPARC_PC_HH22
case|:
case|case
name|R_SPARC_PC_HM10
case|:
case|case
name|R_SPARC_PC_LM22
case|:
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|)
operator|==
literal|0
condition|)
break|break;
comment|/* Fall through.  */
case|case
name|R_SPARC_DISP8
case|:
case|case
name|R_SPARC_DISP16
case|:
case|case
name|R_SPARC_DISP32
case|:
case|case
name|R_SPARC_DISP64
case|:
case|case
name|R_SPARC_WDISP30
case|:
case|case
name|R_SPARC_WDISP22
case|:
case|case
name|R_SPARC_WDISP19
case|:
case|case
name|R_SPARC_WDISP16
case|:
case|case
name|R_SPARC_8
case|:
case|case
name|R_SPARC_16
case|:
case|case
name|R_SPARC_32
case|:
case|case
name|R_SPARC_HI22
case|:
case|case
name|R_SPARC_22
case|:
case|case
name|R_SPARC_13
case|:
case|case
name|R_SPARC_LO10
case|:
case|case
name|R_SPARC_UA16
case|:
case|case
name|R_SPARC_UA32
case|:
case|case
name|R_SPARC_10
case|:
case|case
name|R_SPARC_11
case|:
case|case
name|R_SPARC_64
case|:
case|case
name|R_SPARC_OLO10
case|:
case|case
name|R_SPARC_HH22
case|:
case|case
name|R_SPARC_HM10
case|:
case|case
name|R_SPARC_LM22
case|:
case|case
name|R_SPARC_7
case|:
case|case
name|R_SPARC_5
case|:
case|case
name|R_SPARC_6
case|:
case|case
name|R_SPARC_HIX22
case|:
case|case
name|R_SPARC_LOX10
case|:
case|case
name|R_SPARC_H44
case|:
case|case
name|R_SPARC_M44
case|:
case|case
name|R_SPARC_L44
case|:
case|case
name|R_SPARC_UA64
case|:
name|r_sparc_plt32
label|:
if|if
condition|(
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|h
operator|==
name|NULL
operator|||
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_DEFAULT
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefweak
operator|)
operator|&&
operator|(
operator|!
name|howto
operator|->
name|pc_relative
operator|||
operator|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|&&
operator|(
operator|!
name|info
operator|->
name|symbolic
operator|||
operator|!
name|h
operator|->
name|def_regular
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
operator|!
name|info
operator|->
name|shared
operator|&&
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|&&
operator|!
name|h
operator|->
name|non_got_ref
operator|&&
operator|(
operator|(
name|h
operator|->
name|def_dynamic
operator|&&
operator|!
name|h
operator|->
name|def_regular
operator|)
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
operator|)
operator|)
condition|)
block|{
name|Elf_Internal_Rela
name|outrel
decl_stmt|;
name|bfd_boolean
name|skip
decl_stmt|,
name|relocate
init|=
name|FALSE
decl_stmt|;
comment|/* When generating a shared object, these relocations 		 are copied into the output file to be resolved at run 		 time.  */
name|BFD_ASSERT
argument_list|(
name|sreloc
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|skip
operator|=
name|FALSE
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|=
name|_bfd_elf_section_offset
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|outrel
operator|.
name|r_offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
name|skip
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|outrel
operator|.
name|r_offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|2
condition|)
name|skip
operator|=
name|TRUE
operator|,
name|relocate
operator|=
name|TRUE
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|+=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
comment|/* Optimize unaligned reloc usage now that we know where 		 it finally resides.  */
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_SPARC_16
case|:
if|if
condition|(
name|outrel
operator|.
name|r_offset
operator|&
literal|1
condition|)
name|r_type
operator|=
name|R_SPARC_UA16
expr_stmt|;
break|break;
case|case
name|R_SPARC_UA16
case|:
if|if
condition|(
operator|!
operator|(
name|outrel
operator|.
name|r_offset
operator|&
literal|1
operator|)
condition|)
name|r_type
operator|=
name|R_SPARC_16
expr_stmt|;
break|break;
case|case
name|R_SPARC_32
case|:
if|if
condition|(
name|outrel
operator|.
name|r_offset
operator|&
literal|3
condition|)
name|r_type
operator|=
name|R_SPARC_UA32
expr_stmt|;
break|break;
case|case
name|R_SPARC_UA32
case|:
if|if
condition|(
operator|!
operator|(
name|outrel
operator|.
name|r_offset
operator|&
literal|3
operator|)
condition|)
name|r_type
operator|=
name|R_SPARC_32
expr_stmt|;
break|break;
case|case
name|R_SPARC_64
case|:
if|if
condition|(
name|outrel
operator|.
name|r_offset
operator|&
literal|7
condition|)
name|r_type
operator|=
name|R_SPARC_UA64
expr_stmt|;
break|break;
case|case
name|R_SPARC_UA64
case|:
if|if
condition|(
operator|!
operator|(
name|outrel
operator|.
name|r_offset
operator|&
literal|7
operator|)
condition|)
name|r_type
operator|=
name|R_SPARC_64
expr_stmt|;
break|break;
case|case
name|R_SPARC_DISP8
case|:
case|case
name|R_SPARC_DISP16
case|:
case|case
name|R_SPARC_DISP32
case|:
case|case
name|R_SPARC_DISP64
case|:
comment|/* If the symbol is not dynamic, we should not keep 		     a dynamic relocation.  But an .rela.* slot has been 		     allocated for it, output R_SPARC_NONE. 		     FIXME: Add code tracking needed dynamic relocs as 		     e.g. i386 has.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
name|skip
operator|=
name|TRUE
operator|,
name|relocate
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|skip
condition|)
name|memset
argument_list|(
operator|&
name|outrel
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|outrel
argument_list|)
expr_stmt|;
comment|/* h->dynindx may be -1 if the symbol was marked to 		 become local.  */
elseif|else
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|!
name|is_plt
operator|&&
operator|(
operator|(
operator|!
name|info
operator|->
name|symbolic
operator|&&
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|)
operator|||
operator|!
name|h
operator|->
name|def_regular
operator|)
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|SPARC_ELF_R_INFO
argument_list|(
name|htab
argument_list|,
name|rel
argument_list|,
name|h
operator|->
name|dynindx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
name|rel
operator|->
name|r_addend
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|r_type
operator|==
name|R_SPARC_32
operator|||
name|r_type
operator|==
name|R_SPARC_64
condition|)
block|{
name|outrel
operator|.
name|r_info
operator|=
name|SPARC_ELF_R_INFO
argument_list|(
name|htab
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|R_SPARC_RELATIVE
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
name|relocation
operator|+
name|rel
operator|->
name|r_addend
expr_stmt|;
block|}
else|else
block|{
name|long
name|indx
decl_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
name|relocation
operator|+
name|rel
operator|->
name|r_addend
expr_stmt|;
if|if
condition|(
name|is_plt
condition|)
name|sec
operator|=
name|htab
operator|->
name|splt
expr_stmt|;
if|if
condition|(
name|bfd_is_abs_section
argument_list|(
name|sec
argument_list|)
condition|)
name|indx
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|sec
operator|==
name|NULL
operator|||
name|sec
operator|->
name|owner
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
else|else
block|{
name|asection
modifier|*
name|osec
decl_stmt|;
name|osec
operator|=
name|sec
operator|->
name|output_section
expr_stmt|;
name|indx
operator|=
name|elf_section_data
argument_list|(
name|osec
argument_list|)
operator|->
name|dynindx
expr_stmt|;
if|if
condition|(
name|indx
operator|==
literal|0
condition|)
block|{
name|osec
operator|=
name|htab
operator|->
name|elf
operator|.
name|text_index_section
expr_stmt|;
name|indx
operator|=
name|elf_section_data
argument_list|(
name|osec
argument_list|)
operator|->
name|dynindx
expr_stmt|;
block|}
comment|/* FIXME: we really should be able to link non-pic 			     shared libraries.  */
if|if
condition|(
name|indx
operator|==
literal|0
condition|)
block|{
name|BFD_FAIL
argument_list|()
expr_stmt|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: probably compiled without -fPIC?"
argument_list|)
argument_list|,
name|input_bfd
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* We are turning this relocation into one 			     against a section symbol, so subtract out 			     the output section's address but not the 			     offset of the input section in the output 			     section on OSes where ld.so doesn't expect 			     buggy relocs.  */
if|if
condition|(
name|bed
operator|->
name|elf_osabi
operator|==
name|ELFOSABI_FREEBSD
condition|)
name|outrel
operator|.
name|r_addend
operator|-=
name|osec
operator|->
name|vma
expr_stmt|;
block|}
name|outrel
operator|.
name|r_info
operator|=
name|SPARC_ELF_R_INFO
argument_list|(
name|htab
argument_list|,
name|rel
argument_list|,
name|indx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
block|}
block|}
name|sparc_elf_append_rela
argument_list|(
name|output_bfd
argument_list|,
name|sreloc
argument_list|,
operator|&
name|outrel
argument_list|)
expr_stmt|;
comment|/* This reloc will be computed at runtime, so there's no 		 need to do anything now.  */
if|if
condition|(
operator|!
name|relocate
condition|)
continue|continue;
block|}
break|break;
case|case
name|R_SPARC_TLS_GD_HI22
case|:
if|if
condition|(
operator|!
name|ABI_64_P
argument_list|(
name|input_bfd
argument_list|)
operator|&&
operator|!
name|_bfd_sparc_elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|has_tlsgd
condition|)
block|{
comment|/* R_SPARC_REV32 used the same reloc number as 		 R_SPARC_TLS_GD_HI22.  */
name|r_type
operator|=
name|R_SPARC_REV32
expr_stmt|;
break|break;
block|}
comment|/* Fall through */
case|case
name|R_SPARC_TLS_GD_LO10
case|:
case|case
name|R_SPARC_TLS_IE_HI22
case|:
case|case
name|R_SPARC_TLS_IE_LO10
case|:
name|r_type
operator|=
name|sparc_elf_tls_transition
argument_list|(
name|info
argument_list|,
name|input_bfd
argument_list|,
name|r_type
argument_list|,
name|h
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|tls_type
operator|=
name|GOT_UNKNOWN
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
operator|&&
name|local_got_offsets
condition|)
name|tls_type
operator|=
name|_bfd_sparc_elf_local_got_tls_type
argument_list|(
name|input_bfd
argument_list|)
index|[
name|r_symndx
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|tls_type
operator|=
name|_bfd_sparc_elf_hash_entry
argument_list|(
name|h
argument_list|)
operator|->
name|tls_type
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|shared
operator|&&
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|&&
name|tls_type
operator|==
name|GOT_TLS_IE
condition|)
switch|switch
condition|(
name|SPARC_ELF_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_SPARC_TLS_GD_HI22
case|:
case|case
name|R_SPARC_TLS_IE_HI22
case|:
name|r_type
operator|=
name|R_SPARC_TLS_LE_HIX22
expr_stmt|;
break|break;
default|default:
name|r_type
operator|=
name|R_SPARC_TLS_LE_LOX10
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|tls_type
operator|==
name|GOT_TLS_IE
condition|)
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_SPARC_TLS_GD_HI22
case|:
name|r_type
operator|=
name|R_SPARC_TLS_IE_HI22
expr_stmt|;
break|break;
case|case
name|R_SPARC_TLS_GD_LO10
case|:
name|r_type
operator|=
name|R_SPARC_TLS_IE_LO10
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|r_type
operator|==
name|R_SPARC_TLS_LE_HIX22
condition|)
block|{
name|relocation
operator|=
name|tpoff
argument_list|(
name|info
argument_list|,
name|relocation
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|r_type
operator|==
name|R_SPARC_TLS_LE_LOX10
condition|)
block|{
comment|/* Change add into xor.  */
name|relocation
operator|=
name|tpoff
argument_list|(
name|info
argument_list|,
name|relocation
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
operator||
literal|0x80182000
operator|)
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|off
operator|=
name|h
operator|->
name|got
operator|.
name|offset
expr_stmt|;
name|h
operator|->
name|got
operator|.
name|offset
operator||=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|BFD_ASSERT
argument_list|(
name|local_got_offsets
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|off
operator|=
name|local_got_offsets
index|[
name|r_symndx
index|]
expr_stmt|;
name|local_got_offsets
index|[
name|r_symndx
index|]
operator||=
literal|1
expr_stmt|;
block|}
name|r_sparc_tlsldm
label|:
if|if
condition|(
name|htab
operator|->
name|sgot
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|off
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|off
operator|&=
operator|~
literal|1
expr_stmt|;
else|else
block|{
name|Elf_Internal_Rela
name|outrel
decl_stmt|;
name|int
name|dr_type
decl_stmt|,
name|indx
decl_stmt|;
if|if
condition|(
name|htab
operator|->
name|srelgot
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|SPARC_ELF_PUT_WORD
argument_list|(
name|htab
argument_list|,
name|output_bfd
argument_list|,
literal|0
argument_list|,
name|htab
operator|->
name|sgot
operator|->
name|contents
operator|+
name|off
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|=
operator|(
name|htab
operator|->
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|sgot
operator|->
name|output_offset
operator|+
name|off
operator|)
expr_stmt|;
name|indx
operator|=
name|h
operator|&&
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
condition|?
name|h
operator|->
name|dynindx
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_SPARC_TLS_IE_HI22
operator|||
name|r_type
operator|==
name|R_SPARC_TLS_IE_LO10
condition|)
name|dr_type
operator|=
name|SPARC_ELF_TPOFF_RELOC
argument_list|(
name|htab
argument_list|)
expr_stmt|;
else|else
name|dr_type
operator|=
name|SPARC_ELF_DTPMOD_RELOC
argument_list|(
name|htab
argument_list|)
expr_stmt|;
if|if
condition|(
name|dr_type
operator|==
name|SPARC_ELF_TPOFF_RELOC
argument_list|(
name|htab
argument_list|)
operator|&&
name|indx
operator|==
literal|0
condition|)
name|outrel
operator|.
name|r_addend
operator|=
name|relocation
operator|-
name|dtpoff_base
argument_list|(
name|info
argument_list|)
expr_stmt|;
else|else
name|outrel
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|SPARC_ELF_R_INFO
argument_list|(
name|htab
argument_list|,
name|NULL
argument_list|,
name|indx
argument_list|,
name|dr_type
argument_list|)
expr_stmt|;
name|sparc_elf_append_rela
argument_list|(
name|output_bfd
argument_list|,
name|htab
operator|->
name|srelgot
argument_list|,
operator|&
name|outrel
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_SPARC_TLS_GD_HI22
operator|||
name|r_type
operator|==
name|R_SPARC_TLS_GD_LO10
condition|)
block|{
if|if
condition|(
name|indx
operator|==
literal|0
condition|)
block|{
name|BFD_ASSERT
argument_list|(
operator|!
name|unresolved_reloc
argument_list|)
expr_stmt|;
name|SPARC_ELF_PUT_WORD
argument_list|(
name|htab
argument_list|,
name|output_bfd
argument_list|,
name|relocation
operator|-
name|dtpoff_base
argument_list|(
name|info
argument_list|)
argument_list|,
operator|(
name|htab
operator|->
name|sgot
operator|->
name|contents
operator|+
name|off
operator|+
name|SPARC_ELF_WORD_BYTES
argument_list|(
name|htab
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SPARC_ELF_PUT_WORD
argument_list|(
name|htab
argument_list|,
name|output_bfd
argument_list|,
literal|0
argument_list|,
operator|(
name|htab
operator|->
name|sgot
operator|->
name|contents
operator|+
name|off
operator|+
name|SPARC_ELF_WORD_BYTES
argument_list|(
name|htab
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|SPARC_ELF_R_INFO
argument_list|(
name|htab
argument_list|,
name|NULL
argument_list|,
name|indx
argument_list|,
name|SPARC_ELF_DTPOFF_RELOC
argument_list|(
name|htab
argument_list|)
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|+=
name|SPARC_ELF_WORD_BYTES
argument_list|(
name|htab
argument_list|)
expr_stmt|;
name|sparc_elf_append_rela
argument_list|(
name|output_bfd
argument_list|,
name|htab
operator|->
name|srelgot
argument_list|,
operator|&
name|outrel
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|dr_type
operator|==
name|SPARC_ELF_DTPMOD_RELOC
argument_list|(
name|htab
argument_list|)
condition|)
block|{
name|SPARC_ELF_PUT_WORD
argument_list|(
name|htab
argument_list|,
name|output_bfd
argument_list|,
literal|0
argument_list|,
operator|(
name|htab
operator|->
name|sgot
operator|->
name|contents
operator|+
name|off
operator|+
name|SPARC_ELF_WORD_BYTES
argument_list|(
name|htab
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|off
operator|>=
operator|(
name|bfd_vma
operator|)
operator|-
literal|2
condition|)
name|abort
argument_list|()
expr_stmt|;
name|relocation
operator|=
name|htab
operator|->
name|sgot
operator|->
name|output_offset
operator|+
name|off
operator|-
name|got_base
expr_stmt|;
name|unresolved_reloc
operator|=
name|FALSE
expr_stmt|;
name|howto
operator|=
name|_bfd_sparc_elf_howto_table
operator|+
name|r_type
expr_stmt|;
break|break;
case|case
name|R_SPARC_TLS_LDM_HI22
case|:
case|case
name|R_SPARC_TLS_LDM_LO10
case|:
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|SPARC_NOP
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|off
operator|=
name|htab
operator|->
name|tls_ldm_got
operator|.
name|offset
expr_stmt|;
name|htab
operator|->
name|tls_ldm_got
operator|.
name|offset
operator||=
literal|1
expr_stmt|;
goto|goto
name|r_sparc_tlsldm
goto|;
case|case
name|R_SPARC_TLS_LDO_HIX22
case|:
case|case
name|R_SPARC_TLS_LDO_LOX10
case|:
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
name|relocation
operator|-=
name|dtpoff_base
argument_list|(
name|info
argument_list|)
expr_stmt|;
break|break;
block|}
name|r_type
operator|=
operator|(
name|r_type
operator|==
name|R_SPARC_TLS_LDO_HIX22
condition|?
name|R_SPARC_TLS_LE_HIX22
else|:
name|R_SPARC_TLS_LE_LOX10
operator|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|R_SPARC_TLS_LE_HIX22
case|:
case|case
name|R_SPARC_TLS_LE_LOX10
case|:
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
name|Elf_Internal_Rela
name|outrel
decl_stmt|;
name|bfd_boolean
name|skip
decl_stmt|,
name|relocate
init|=
name|FALSE
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|sreloc
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|skip
operator|=
name|FALSE
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|=
name|_bfd_elf_section_offset
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|outrel
operator|.
name|r_offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
name|skip
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|outrel
operator|.
name|r_offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|2
condition|)
name|skip
operator|=
name|TRUE
operator|,
name|relocate
operator|=
name|TRUE
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|+=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
if|if
condition|(
name|skip
condition|)
name|memset
argument_list|(
operator|&
name|outrel
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|outrel
argument_list|)
expr_stmt|;
else|else
block|{
name|outrel
operator|.
name|r_info
operator|=
name|SPARC_ELF_R_INFO
argument_list|(
name|htab
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
name|relocation
operator|-
name|dtpoff_base
argument_list|(
name|info
argument_list|)
operator|+
name|rel
operator|->
name|r_addend
expr_stmt|;
block|}
name|sparc_elf_append_rela
argument_list|(
name|output_bfd
argument_list|,
name|sreloc
argument_list|,
operator|&
name|outrel
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|relocation
operator|=
name|tpoff
argument_list|(
name|info
argument_list|,
name|relocation
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_SPARC_TLS_LDM_CALL
case|:
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
comment|/* mov %g0, %o0 */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
literal|0x90100000
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Fall through */
case|case
name|R_SPARC_TLS_GD_CALL
case|:
name|tls_type
operator|=
name|GOT_UNKNOWN
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
operator|&&
name|local_got_offsets
condition|)
name|tls_type
operator|=
name|_bfd_sparc_elf_local_got_tls_type
argument_list|(
name|input_bfd
argument_list|)
index|[
name|r_symndx
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|tls_type
operator|=
name|_bfd_sparc_elf_hash_entry
argument_list|(
name|h
argument_list|)
operator|->
name|tls_type
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|shared
operator|||
operator|(
name|r_type
operator|==
name|R_SPARC_TLS_GD_CALL
operator|&&
name|tls_type
operator|==
name|GOT_TLS_IE
operator|)
condition|)
block|{
name|bfd_vma
name|insn
decl_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|shared
operator|&&
operator|(
name|h
operator|==
name|NULL
operator|||
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|)
condition|)
block|{
comment|/* GD -> LE */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|SPARC_NOP
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* GD -> IE */
if|if
condition|(
name|rel
operator|+
literal|1
operator|<
name|relend
operator|&&
name|SPARC_ELF_R_TYPE
argument_list|(
name|rel
index|[
literal|1
index|]
operator|.
name|r_info
argument_list|)
operator|==
name|R_SPARC_TLS_GD_ADD
operator|&&
name|rel
index|[
literal|1
index|]
operator|.
name|r_offset
operator|==
name|rel
operator|->
name|r_offset
operator|+
literal|4
operator|&&
name|SPARC_ELF_R_SYMNDX
argument_list|(
name|htab
argument_list|,
name|rel
index|[
literal|1
index|]
operator|.
name|r_info
argument_list|)
operator|==
name|r_symndx
operator|&&
operator|(
operator|(
operator|(
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
index|[
literal|1
index|]
operator|.
name|r_offset
argument_list|)
operator|)
operator|>>
literal|25
operator|)
operator|&
literal|0x1f
operator|)
operator|==
literal|8
condition|)
block|{
comment|/* We have 		     call __tls_get_addr, %tgd_call(foo) 		      add %reg1, %reg2, %o0, %tgd_add(foo) 		     and change it into IE: 		     {ld,ldx} [%reg1 + %reg2], %o0, %tie_ldx(foo) 		     add %g7, %o0, %o0, %tie_add(foo). 		     add is 0x80000000 | (rd<< 25) | (rs1<< 14) | rs2, 		     ld is 0xc0000000 | (rd<< 25) | (rs1<< 14) | rs2, 		     ldx is 0xc0580000 | (rd<< 25) | (rs1<< 14) | rs2.  */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|insn
operator||
operator|(
name|ABI_64_P
argument_list|(
name|output_bfd
argument_list|)
condition|?
literal|0xc0580000
else|:
literal|0xc0000000
operator|)
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
literal|0x9001c008
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|+
literal|4
argument_list|)
expr_stmt|;
name|rel
operator|++
expr_stmt|;
continue|continue;
block|}
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
literal|0x9001c008
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|bfd_link_hash_lookup
argument_list|(
name|info
operator|->
name|hash
argument_list|,
literal|"__tls_get_addr"
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|h
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|R_SPARC_WPLT30
expr_stmt|;
name|howto
operator|=
name|_bfd_sparc_elf_howto_table
operator|+
name|r_type
expr_stmt|;
goto|goto
name|r_sparc_wplt30
goto|;
case|case
name|R_SPARC_TLS_GD_ADD
case|:
name|tls_type
operator|=
name|GOT_UNKNOWN
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
operator|&&
name|local_got_offsets
condition|)
name|tls_type
operator|=
name|_bfd_sparc_elf_local_got_tls_type
argument_list|(
name|input_bfd
argument_list|)
index|[
name|r_symndx
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|tls_type
operator|=
name|_bfd_sparc_elf_hash_entry
argument_list|(
name|h
argument_list|)
operator|->
name|tls_type
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|shared
operator|||
name|tls_type
operator|==
name|GOT_TLS_IE
condition|)
block|{
comment|/* add %reg1, %reg2, %reg3, %tgd_add(foo) 		 changed into IE: 		 {ld,ldx} [%reg1 + %reg2], %reg3, %tie_ldx(foo) 		 or LE: 		 add %g7, %reg2, %reg3.  */
name|bfd_vma
name|insn
init|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|)
operator|||
name|info
operator|->
name|shared
condition|)
name|relocation
operator|=
name|insn
operator||
operator|(
name|ABI_64_P
argument_list|(
name|output_bfd
argument_list|)
condition|?
literal|0xc0580000
else|:
literal|0xc0000000
operator|)
expr_stmt|;
else|else
name|relocation
operator|=
operator|(
name|insn
operator|&
operator|~
literal|0x7c000
operator|)
operator||
literal|0x1c000
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|relocation
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
block|}
continue|continue;
case|case
name|R_SPARC_TLS_LDM_ADD
case|:
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|SPARC_NOP
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|R_SPARC_TLS_LDO_ADD
case|:
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
comment|/* Change rs1 into %g7.  */
name|bfd_vma
name|insn
init|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
decl_stmt|;
name|insn
operator|=
operator|(
name|insn
operator|&
operator|~
literal|0x7c000
operator|)
operator||
literal|0x1c000
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|insn
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
block|}
continue|continue;
case|case
name|R_SPARC_TLS_IE_LD
case|:
case|case
name|R_SPARC_TLS_IE_LDX
case|:
if|if
condition|(
operator|!
name|info
operator|->
name|shared
operator|&&
operator|(
name|h
operator|==
name|NULL
operator|||
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|)
condition|)
block|{
name|bfd_vma
name|insn
init|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
decl_stmt|;
name|int
name|rs2
init|=
name|insn
operator|&
literal|0x1f
decl_stmt|;
name|int
name|rd
init|=
operator|(
name|insn
operator|>>
literal|25
operator|)
operator|&
literal|0x1f
decl_stmt|;
if|if
condition|(
name|rs2
operator|==
name|rd
condition|)
name|relocation
operator|=
name|SPARC_NOP
expr_stmt|;
else|else
name|relocation
operator|=
literal|0x80100000
operator||
operator|(
name|insn
operator|&
literal|0x3e00001f
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|relocation
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
block|}
continue|continue;
case|case
name|R_SPARC_TLS_IE_ADD
case|:
comment|/* Totally useless relocation.  */
continue|continue;
case|case
name|R_SPARC_TLS_DTPOFF32
case|:
case|case
name|R_SPARC_TLS_DTPOFF64
case|:
name|relocation
operator|-=
name|dtpoff_base
argument_list|(
name|info
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* Dynamic relocs are not propagated for SEC_DEBUGGING sections 	 because such sections are not SEC_ALLOC and thus ld.so will 	 not process them.  */
if|if
condition|(
name|unresolved_reloc
operator|&&
operator|!
operator|(
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_DEBUGGING
operator|)
operator|!=
literal|0
operator|&&
name|h
operator|->
name|def_dynamic
operator|)
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B(%A+0x%lx): unresolvable %s relocation against symbol `%s'"
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
name|long
operator|)
name|rel
operator|->
name|r_offset
argument_list|,
name|howto
operator|->
name|name
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
name|r
operator|=
name|bfd_reloc_continue
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_SPARC_OLO10
condition|)
block|{
name|bfd_vma
name|x
decl_stmt|;
if|if
condition|(
operator|!
name|ABI_64_P
argument_list|(
name|output_bfd
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|relocation
operator|+=
name|rel
operator|->
name|r_addend
expr_stmt|;
name|relocation
operator|=
operator|(
name|relocation
operator|&
literal|0x3ff
operator|)
operator|+
name|ELF64_R_TYPE_DATA
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|x
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
literal|0x1fff
operator|)
operator||
operator|(
name|relocation
operator|&
literal|0x1fff
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|r
operator|=
name|bfd_check_overflow
argument_list|(
name|howto
operator|->
name|complain_on_overflow
argument_list|,
name|howto
operator|->
name|bitsize
argument_list|,
name|howto
operator|->
name|rightshift
argument_list|,
name|bfd_arch_bits_per_address
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|relocation
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r_type
operator|==
name|R_SPARC_WDISP16
condition|)
block|{
name|bfd_vma
name|x
decl_stmt|;
name|relocation
operator|+=
name|rel
operator|->
name|r_addend
expr_stmt|;
name|relocation
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|relocation
operator|-=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|x
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|x
operator||=
operator|(
operator|(
operator|(
operator|(
name|relocation
operator|>>
literal|2
operator|)
operator|&
literal|0xc000
operator|)
operator|<<
literal|6
operator|)
operator||
operator|(
operator|(
name|relocation
operator|>>
literal|2
operator|)
operator|&
literal|0x3fff
operator|)
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|r
operator|=
name|bfd_check_overflow
argument_list|(
name|howto
operator|->
name|complain_on_overflow
argument_list|,
name|howto
operator|->
name|bitsize
argument_list|,
name|howto
operator|->
name|rightshift
argument_list|,
name|bfd_arch_bits_per_address
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|relocation
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r_type
operator|==
name|R_SPARC_REV32
condition|)
block|{
name|bfd_vma
name|x
decl_stmt|;
name|relocation
operator|=
name|relocation
operator|+
name|rel
operator|->
name|r_addend
expr_stmt|;
name|x
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|x
operator|=
name|x
operator|+
name|relocation
expr_stmt|;
name|bfd_putl32
argument_list|(
comment|/*input_bfd,*/
name|x
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|r
operator|=
name|bfd_reloc_ok
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r_type
operator|==
name|R_SPARC_TLS_LDO_HIX22
operator|||
name|r_type
operator|==
name|R_SPARC_TLS_LE_HIX22
condition|)
block|{
name|bfd_vma
name|x
decl_stmt|;
name|relocation
operator|+=
name|rel
operator|->
name|r_addend
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_SPARC_TLS_LE_HIX22
condition|)
name|relocation
operator|^=
name|MINUS_ONE
expr_stmt|;
name|x
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
literal|0x3fffff
operator|)
operator||
operator|(
operator|(
name|relocation
operator|>>
literal|10
operator|)
operator|&
literal|0x3fffff
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|r
operator|=
name|bfd_reloc_ok
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r_type
operator|==
name|R_SPARC_TLS_LDO_LOX10
operator|||
name|r_type
operator|==
name|R_SPARC_TLS_LE_LOX10
condition|)
block|{
name|bfd_vma
name|x
decl_stmt|;
name|relocation
operator|+=
name|rel
operator|->
name|r_addend
expr_stmt|;
name|relocation
operator|&=
literal|0x3ff
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_SPARC_TLS_LE_LOX10
condition|)
name|relocation
operator||=
literal|0x1c00
expr_stmt|;
name|x
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
literal|0x1fff
operator|)
operator||
name|relocation
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|r
operator|=
name|bfd_reloc_ok
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r_type
operator|==
name|R_SPARC_HIX22
condition|)
block|{
name|bfd_vma
name|x
decl_stmt|;
name|relocation
operator|+=
name|rel
operator|->
name|r_addend
expr_stmt|;
name|relocation
operator|=
name|relocation
operator|^
name|MINUS_ONE
expr_stmt|;
name|x
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
literal|0x3fffff
operator|)
operator||
operator|(
operator|(
name|relocation
operator|>>
literal|10
operator|)
operator|&
literal|0x3fffff
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|r
operator|=
name|bfd_check_overflow
argument_list|(
name|howto
operator|->
name|complain_on_overflow
argument_list|,
name|howto
operator|->
name|bitsize
argument_list|,
name|howto
operator|->
name|rightshift
argument_list|,
name|bfd_arch_bits_per_address
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|relocation
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r_type
operator|==
name|R_SPARC_LOX10
condition|)
block|{
name|bfd_vma
name|x
decl_stmt|;
name|relocation
operator|+=
name|rel
operator|->
name|r_addend
expr_stmt|;
name|relocation
operator|=
operator|(
name|relocation
operator|&
literal|0x3ff
operator|)
operator||
literal|0x1c00
expr_stmt|;
name|x
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
literal|0x1fff
operator|)
operator||
name|relocation
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|r
operator|=
name|bfd_reloc_ok
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|r_type
operator|==
name|R_SPARC_WDISP30
operator|||
name|r_type
operator|==
name|R_SPARC_WPLT30
operator|)
operator|&&
name|sec_do_relax
argument_list|(
name|input_section
argument_list|)
operator|&&
name|rel
operator|->
name|r_offset
operator|+
literal|4
operator|<
name|input_section
operator|->
name|size
condition|)
block|{
define|#
directive|define
name|G0
value|0
define|#
directive|define
name|O7
value|15
define|#
directive|define
name|XCC
value|(2<< 20)
define|#
directive|define
name|COND
parameter_list|(
name|x
parameter_list|)
value|(((x)&0xf)<<25)
define|#
directive|define
name|CONDA
value|COND(0x8)
define|#
directive|define
name|INSN_BPA
value|(F2(0,1) | CONDA | BPRED | XCC)
define|#
directive|define
name|INSN_BA
value|(F2(0,2) | CONDA)
define|#
directive|define
name|INSN_OR
value|F3(2, 0x2, 0)
define|#
directive|define
name|INSN_NOP
value|F2(0,4)
name|bfd_vma
name|x
decl_stmt|,
name|y
decl_stmt|;
comment|/* If the instruction is a call with either: 	     restore 	     arithmetic instruction with rd == %o7 	     where rs1 != %o7 and rs2 if it is register != %o7 	     then we can optimize if the call destination is near 	     by changing the call into a branch always.  */
name|x
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|y
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|&
name|OP
argument_list|(
operator|~
literal|0
argument_list|)
operator|)
operator|==
name|OP
argument_list|(
literal|1
argument_list|)
operator|&&
operator|(
name|y
operator|&
name|OP
argument_list|(
operator|~
literal|0
argument_list|)
operator|)
operator|==
name|OP
argument_list|(
literal|2
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|y
operator|&
name|OP3
argument_list|(
operator|~
literal|0
argument_list|)
operator|)
operator|==
name|OP3
argument_list|(
literal|0x3d
argument_list|)
comment|/* restore */
operator|||
operator|(
operator|(
name|y
operator|&
name|OP3
argument_list|(
literal|0x28
argument_list|)
operator|)
operator|==
literal|0
comment|/* arithmetic */
operator|&&
operator|(
name|y
operator|&
name|RD
argument_list|(
operator|~
literal|0
argument_list|)
operator|)
operator|==
name|RD
argument_list|(
name|O7
argument_list|)
operator|)
operator|)
operator|&&
operator|(
name|y
operator|&
name|RS1
argument_list|(
operator|~
literal|0
argument_list|)
operator|)
operator|!=
name|RS1
argument_list|(
name|O7
argument_list|)
operator|&&
operator|(
operator|(
name|y
operator|&
name|F3I
argument_list|(
operator|~
literal|0
argument_list|)
operator|)
operator|||
operator|(
name|y
operator|&
name|RS2
argument_list|(
operator|~
literal|0
argument_list|)
operator|)
operator|!=
name|RS2
argument_list|(
name|O7
argument_list|)
operator|)
condition|)
block|{
name|bfd_vma
name|reloc
decl_stmt|;
name|reloc
operator|=
name|relocation
operator|+
name|rel
operator|->
name|r_addend
operator|-
name|rel
operator|->
name|r_offset
expr_stmt|;
name|reloc
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
comment|/* Ensure the branch fits into simm22.  */
if|if
condition|(
operator|(
name|reloc
operator|&
literal|3
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|reloc
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
literal|0x7fffff
operator|)
operator|==
literal|0
operator|||
operator|(
operator|(
name|reloc
operator||
literal|0x7fffff
operator|)
operator|==
operator|~
operator|(
name|bfd_vma
operator|)
literal|0
operator|)
operator|)
condition|)
block|{
name|reloc
operator|>>=
literal|2
expr_stmt|;
comment|/* Check whether it fits into simm19.  */
if|if
condition|(
operator|(
operator|(
name|reloc
operator|&
literal|0x3c0000
operator|)
operator|==
literal|0
operator|||
operator|(
name|reloc
operator|&
literal|0x3c0000
operator|)
operator|==
literal|0x3c0000
operator|)
operator|&&
operator|(
name|ABI_64_P
argument_list|(
name|output_bfd
argument_list|)
operator|||
name|elf_elfheader
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_SPARC_32PLUS
operator|)
condition|)
name|x
operator|=
name|INSN_BPA
operator||
operator|(
name|reloc
operator|&
literal|0x7ffff
operator|)
expr_stmt|;
comment|/* ba,pt %xcc */
else|else
name|x
operator|=
name|INSN_BA
operator||
operator|(
name|reloc
operator|&
literal|0x3fffff
operator|)
expr_stmt|;
comment|/* ba */
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|r
operator|=
name|bfd_reloc_ok
expr_stmt|;
if|if
condition|(
name|rel
operator|->
name|r_offset
operator|>=
literal|4
operator|&&
operator|(
name|y
operator|&
operator|(
literal|0xffffffff
operator|^
name|RS1
argument_list|(
operator|~
literal|0
argument_list|)
operator|)
operator|)
operator|==
operator|(
name|INSN_OR
operator||
name|RD
argument_list|(
name|O7
argument_list|)
operator||
name|RS2
argument_list|(
name|G0
argument_list|)
operator|)
condition|)
block|{
name|bfd_vma
name|z
decl_stmt|;
name|unsigned
name|int
name|reg
decl_stmt|;
name|z
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|-
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|z
operator|&
operator|(
literal|0xffffffff
operator|^
name|RD
argument_list|(
operator|~
literal|0
argument_list|)
operator|)
operator|)
operator|!=
operator|(
name|INSN_OR
operator||
name|RS1
argument_list|(
name|O7
argument_list|)
operator||
name|RS2
argument_list|(
name|G0
argument_list|)
operator|)
condition|)
break|break;
comment|/* The sequence was 			     or %o7, %g0, %rN 			     call foo 			     or %rN, %g0, %o7  			     If call foo was replaced with ba, replace 			     or %rN, %g0, %o7 with nop.  */
name|reg
operator|=
operator|(
name|y
operator|&
name|RS1
argument_list|(
operator|~
literal|0
argument_list|)
operator|)
operator|>>
literal|14
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
operator|(
operator|(
name|z
operator|&
name|RD
argument_list|(
operator|~
literal|0
argument_list|)
operator|)
operator|>>
literal|25
operator|)
operator|||
name|reg
operator|==
name|G0
operator|||
name|reg
operator|==
name|O7
condition|)
break|break;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|INSN_NOP
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
name|r
operator|==
name|bfd_reloc_continue
condition|)
name|r
operator|=
name|_bfd_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|relocation
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|bfd_reloc_ok
condition|)
block|{
switch|switch
condition|(
name|r
condition|)
block|{
default|default:
case|case
name|bfd_reloc_outofrange
case|:
name|abort
argument_list|()
expr_stmt|;
case|case
name|bfd_reloc_overflow
case|:
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* The Solaris native linker silently disregards overflows.  		   We don't, but this breaks stabs debugging info, whose 		   relocations are only 32-bits wide.  Ignore overflows in 		   this case and also for discarded entries.  */
if|if
condition|(
operator|(
name|r_type
operator|==
name|R_SPARC_32
operator|||
name|r_type
operator|==
name|R_SPARC_DISP32
operator|)
operator|&&
operator|(
operator|(
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_DEBUGGING
operator|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|bfd_section_name
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
argument_list|,
literal|".stab"
argument_list|)
operator|==
literal|0
operator|)
operator|||
name|_bfd_elf_section_offset
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|)
condition|)
break|break;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
comment|/* Assume this is a call protected by other code that 		       detect the symbol is undefined.  If this is the case, 		       we can safely ignore the overflow.  If not, the 		       program is hosed anyway, and a little warning isn't 		       going to help.  */
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|&&
name|howto
operator|->
name|pc_relative
condition|)
break|break;
name|name
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|name
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_link
argument_list|,
name|sym
operator|->
name|st_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'\0'
condition|)
name|name
operator|=
name|bfd_section_name
argument_list|(
name|input_bfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|info
argument_list|,
operator|(
name|h
condition|?
operator|&
name|h
operator|->
name|root
else|:
name|NULL
operator|)
argument_list|,
name|name
argument_list|,
name|howto
operator|->
name|name
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
block|}
break|break;
block|}
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Build a VxWorks PLT entry.  PLT_INDEX is the index of the PLT entry    and PLT_OFFSET is the byte offset from the start of .plt.  GOT_OFFSET    is the offset of the associated .got.plt entry from    _GLOBAL_OFFSET_TABLE_.  */
end_comment

begin_function
specifier|static
name|void
name|sparc_vxworks_build_plt_entry
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd_vma
name|plt_offset
parameter_list|,
name|bfd_vma
name|plt_index
parameter_list|,
name|bfd_vma
name|got_offset
parameter_list|)
block|{
name|bfd_vma
name|got_base
decl_stmt|;
specifier|const
name|bfd_vma
modifier|*
name|plt_entry
decl_stmt|;
name|struct
name|_bfd_sparc_elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|Elf_Internal_Rela
name|rela
decl_stmt|;
name|htab
operator|=
name|_bfd_sparc_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
name|plt_entry
operator|=
name|sparc_vxworks_shared_plt_entry
expr_stmt|;
name|got_base
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|plt_entry
operator|=
name|sparc_vxworks_exec_plt_entry
expr_stmt|;
name|got_base
operator|=
operator|(
name|htab
operator|->
name|elf
operator|.
name|hgot
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|htab
operator|->
name|elf
operator|.
name|hgot
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|+
name|htab
operator|->
name|elf
operator|.
name|hgot
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
block|}
comment|/* Fill in the entry in the procedure linkage table.  */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|plt_entry
index|[
literal|0
index|]
operator|+
operator|(
operator|(
name|got_base
operator|+
name|got_offset
operator|)
operator|>>
literal|10
operator|)
argument_list|,
name|htab
operator|->
name|splt
operator|->
name|contents
operator|+
name|plt_offset
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|plt_entry
index|[
literal|1
index|]
operator|+
operator|(
operator|(
name|got_base
operator|+
name|got_offset
operator|)
operator|&
literal|0x3ff
operator|)
argument_list|,
name|htab
operator|->
name|splt
operator|->
name|contents
operator|+
name|plt_offset
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|plt_entry
index|[
literal|2
index|]
argument_list|,
name|htab
operator|->
name|splt
operator|->
name|contents
operator|+
name|plt_offset
operator|+
literal|8
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|plt_entry
index|[
literal|3
index|]
argument_list|,
name|htab
operator|->
name|splt
operator|->
name|contents
operator|+
name|plt_offset
operator|+
literal|12
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|plt_entry
index|[
literal|4
index|]
argument_list|,
name|htab
operator|->
name|splt
operator|->
name|contents
operator|+
name|plt_offset
operator|+
literal|16
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|plt_entry
index|[
literal|5
index|]
operator|+
operator|(
name|plt_index
operator|>>
literal|10
operator|)
argument_list|,
name|htab
operator|->
name|splt
operator|->
name|contents
operator|+
name|plt_offset
operator|+
literal|20
argument_list|)
expr_stmt|;
comment|/* PC-relative displacement for a branch to the start of      the PLT section.  */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|plt_entry
index|[
literal|6
index|]
operator|+
operator|(
operator|(
operator|(
operator|-
name|plt_offset
operator|-
literal|24
operator|)
operator|>>
literal|2
operator|)
operator|&
literal|0x003fffff
operator|)
argument_list|,
name|htab
operator|->
name|splt
operator|->
name|contents
operator|+
name|plt_offset
operator|+
literal|24
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|plt_entry
index|[
literal|7
index|]
operator|+
operator|(
name|plt_index
operator|&
literal|0x3ff
operator|)
argument_list|,
name|htab
operator|->
name|splt
operator|->
name|contents
operator|+
name|plt_offset
operator|+
literal|28
argument_list|)
expr_stmt|;
comment|/* Fill in the .got.plt entry, pointing initially at the      second half of the PLT entry.  */
name|BFD_ASSERT
argument_list|(
name|htab
operator|->
name|sgotplt
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|htab
operator|->
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|splt
operator|->
name|output_offset
operator|+
name|plt_offset
operator|+
literal|20
argument_list|,
name|htab
operator|->
name|sgotplt
operator|->
name|contents
operator|+
name|got_offset
argument_list|)
expr_stmt|;
comment|/* Add relocations to .rela.plt.unloaded.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
name|loc
operator|=
operator|(
name|htab
operator|->
name|srelplt2
operator|->
name|contents
operator|+
operator|(
literal|2
operator|+
literal|3
operator|*
name|plt_index
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
operator|)
expr_stmt|;
comment|/* Relocate the initial sethi.  */
name|rela
operator|.
name|r_offset
operator|=
operator|(
name|htab
operator|->
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|splt
operator|->
name|output_offset
operator|+
name|plt_offset
operator|)
expr_stmt|;
name|rela
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|hgot
operator|->
name|indx
argument_list|,
name|R_SPARC_HI22
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_addend
operator|=
name|got_offset
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rela
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|loc
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
comment|/* Likewise the following or.  */
name|rela
operator|.
name|r_offset
operator|+=
literal|4
expr_stmt|;
name|rela
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|hgot
operator|->
name|indx
argument_list|,
name|R_SPARC_LO10
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rela
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|loc
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
comment|/* Relocate the .got.plt entry.  */
name|rela
operator|.
name|r_offset
operator|=
operator|(
name|htab
operator|->
name|sgotplt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|sgotplt
operator|->
name|output_offset
operator|+
name|got_offset
operator|)
expr_stmt|;
name|rela
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|hplt
operator|->
name|indx
argument_list|,
name|R_SPARC_32
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_addend
operator|=
name|plt_offset
operator|+
literal|20
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rela
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Finish up dynamic symbol handling.  We set the contents of various    dynamic sections here.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_sparc_elf_finish_dynamic_symbol
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|)
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|struct
name|_bfd_sparc_elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
name|htab
operator|=
name|_bfd_sparc_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|dynobj
operator|=
name|htab
operator|->
name|elf
operator|.
name|dynobj
expr_stmt|;
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
name|asection
modifier|*
name|splt
decl_stmt|;
name|asection
modifier|*
name|srela
decl_stmt|;
name|Elf_Internal_Rela
name|rela
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|bfd_vma
name|r_offset
decl_stmt|,
name|got_offset
decl_stmt|;
name|int
name|rela_index
decl_stmt|;
comment|/* This symbol has an entry in the PLT.  Set it up.  */
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|splt
operator|=
name|htab
operator|->
name|splt
expr_stmt|;
name|srela
operator|=
name|htab
operator|->
name|srelplt
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|splt
operator|!=
name|NULL
operator|&&
name|srela
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Fill in the entry in the .rela.plt section.  */
if|if
condition|(
name|htab
operator|->
name|is_vxworks
condition|)
block|{
comment|/* Work out the index of this PLT entry.  */
name|rela_index
operator|=
operator|(
operator|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|-
name|htab
operator|->
name|plt_header_size
operator|)
operator|/
name|htab
operator|->
name|plt_entry_size
operator|)
expr_stmt|;
comment|/* Calculate the offset of the associated .got.plt entry. 	     The first three entries are reserved.  */
name|got_offset
operator|=
operator|(
name|rela_index
operator|+
literal|3
operator|)
operator|*
literal|4
expr_stmt|;
name|sparc_vxworks_build_plt_entry
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|h
operator|->
name|plt
operator|.
name|offset
argument_list|,
name|rela_index
argument_list|,
name|got_offset
argument_list|)
expr_stmt|;
comment|/* On VxWorks, the relocation points to the .got.plt entry, 	     not the .plt entry.  */
name|rela
operator|.
name|r_offset
operator|=
operator|(
name|htab
operator|->
name|sgotplt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|sgotplt
operator|->
name|output_offset
operator|+
name|got_offset
operator|)
expr_stmt|;
name|rela
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Fill in the entry in the procedure linkage table.  */
name|rela_index
operator|=
name|SPARC_ELF_BUILD_PLT_ENTRY
argument_list|(
name|htab
argument_list|,
name|output_bfd
argument_list|,
name|splt
argument_list|,
name|h
operator|->
name|plt
operator|.
name|offset
argument_list|,
name|splt
operator|->
name|size
argument_list|,
operator|&
name|r_offset
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_offset
operator|=
name|r_offset
operator|+
operator|(
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|splt
operator|->
name|output_offset
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|ABI_64_P
argument_list|(
name|output_bfd
argument_list|)
operator|||
name|h
operator|->
name|plt
operator|.
name|offset
operator|<
operator|(
name|PLT64_LARGE_THRESHOLD
operator|*
name|PLT64_ENTRY_SIZE
operator|)
condition|)
block|{
name|rela
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|rela
operator|.
name|r_addend
operator|=
operator|(
operator|-
operator|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
literal|4
operator|)
operator|-
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|-
name|splt
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
block|}
name|rela
operator|.
name|r_info
operator|=
name|SPARC_ELF_R_INFO
argument_list|(
name|htab
argument_list|,
name|NULL
argument_list|,
name|h
operator|->
name|dynindx
argument_list|,
name|R_SPARC_JMP_SLOT
argument_list|)
expr_stmt|;
comment|/* Adjust for the first 4 reserved elements in the .plt section 	 when setting the offset in the .rela.plt section. 	 Sun forgot to read their own ABI and copied elf32-sparc behaviour, 	 thus .plt[4] has corresponding .rela.plt[0] and so on.  */
name|loc
operator|=
name|srela
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
name|rela_index
operator|*
name|bed
operator|->
name|s
operator|->
name|sizeof_rela
expr_stmt|;
name|bed
operator|->
name|s
operator|->
name|swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rela
argument_list|,
name|loc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|h
operator|->
name|def_regular
condition|)
block|{
comment|/* Mark the symbol as undefined, rather than as defined in 	     the .plt section.  Leave the value alone.  */
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_UNDEF
expr_stmt|;
comment|/* If the symbol is weak, we do need to clear the value. 	     Otherwise, the PLT entry would provide a definition for 	     the symbol even if the symbol wasn't defined anywhere, 	     and so the symbol would never be NULL.  */
if|if
condition|(
operator|!
name|h
operator|->
name|ref_regular_nonweak
condition|)
name|sym
operator|->
name|st_value
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|&&
name|_bfd_sparc_elf_hash_entry
argument_list|(
name|h
argument_list|)
operator|->
name|tls_type
operator|!=
name|GOT_TLS_GD
operator|&&
name|_bfd_sparc_elf_hash_entry
argument_list|(
name|h
argument_list|)
operator|->
name|tls_type
operator|!=
name|GOT_TLS_IE
condition|)
block|{
name|asection
modifier|*
name|sgot
decl_stmt|;
name|asection
modifier|*
name|srela
decl_stmt|;
name|Elf_Internal_Rela
name|rela
decl_stmt|;
comment|/* This symbol has an entry in the GOT.  Set it up.  */
name|sgot
operator|=
name|htab
operator|->
name|sgot
expr_stmt|;
name|srela
operator|=
name|htab
operator|->
name|srelgot
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
operator|&&
name|srela
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_offset
operator|=
operator|(
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
operator|(
name|h
operator|->
name|got
operator|.
name|offset
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
literal|1
operator|)
operator|)
expr_stmt|;
comment|/* If this is a -Bsymbolic link, and the symbol is defined 	 locally, we just want to emit a RELATIVE reloc.  Likewise if 	 the symbol was forced to be local because of a version file. 	 The entry in the global offset table will already have been 	 initialized in the relocate_section function.  */
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|info
operator|->
name|symbolic
operator|||
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|)
operator|&&
name|h
operator|->
name|def_regular
condition|)
block|{
name|asection
modifier|*
name|sec
init|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
decl_stmt|;
name|rela
operator|.
name|r_info
operator|=
name|SPARC_ELF_R_INFO
argument_list|(
name|htab
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|R_SPARC_RELATIVE
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_addend
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
else|else
block|{
name|rela
operator|.
name|r_info
operator|=
name|SPARC_ELF_R_INFO
argument_list|(
name|htab
argument_list|,
name|NULL
argument_list|,
name|h
operator|->
name|dynindx
argument_list|,
name|R_SPARC_GLOB_DAT
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
block|}
name|SPARC_ELF_PUT_WORD
argument_list|(
name|htab
argument_list|,
name|output_bfd
argument_list|,
literal|0
argument_list|,
name|sgot
operator|->
name|contents
operator|+
operator|(
name|h
operator|->
name|got
operator|.
name|offset
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
literal|1
operator|)
argument_list|)
expr_stmt|;
name|sparc_elf_append_rela
argument_list|(
name|output_bfd
argument_list|,
name|srela
argument_list|,
operator|&
name|rela
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|->
name|needs_copy
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|Elf_Internal_Rela
name|rela
decl_stmt|;
comment|/* This symbols needs a copy reloc.  Set it up.  */
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
argument_list|,
literal|".rela.bss"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_offset
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|rela
operator|.
name|r_info
operator|=
name|SPARC_ELF_R_INFO
argument_list|(
name|htab
argument_list|,
name|NULL
argument_list|,
name|h
operator|->
name|dynindx
argument_list|,
name|R_SPARC_COPY
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
name|sparc_elf_append_rela
argument_list|(
name|output_bfd
argument_list|,
name|s
argument_list|,
operator|&
name|rela
argument_list|)
expr_stmt|;
block|}
comment|/* Mark some specially defined symbols as absolute.  On VxWorks,      _GLOBAL_OFFSET_TABLE_ is not absolute: it is relative to the      ".got" section.  Likewise _PROCEDURE_LINKAGE_TABLE_ and ".plt".  */
if|if
condition|(
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_DYNAMIC"
argument_list|)
operator|==
literal|0
operator|||
operator|(
operator|!
name|htab
operator|->
name|is_vxworks
operator|&&
operator|(
name|h
operator|==
name|htab
operator|->
name|elf
operator|.
name|hgot
operator|||
name|h
operator|==
name|htab
operator|->
name|elf
operator|.
name|hplt
operator|)
operator|)
condition|)
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_ABS
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Finish up the dynamic sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|sparc_finish_dyn
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd
modifier|*
name|dynobj
parameter_list|,
name|asection
modifier|*
name|sdyn
parameter_list|,
name|asection
modifier|*
name|splt
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|struct
name|_bfd_sparc_elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
name|bfd_byte
modifier|*
name|dyncon
decl_stmt|,
modifier|*
name|dynconend
decl_stmt|;
name|size_t
name|dynsize
decl_stmt|;
name|int
name|stt_regidx
init|=
operator|-
literal|1
decl_stmt|;
name|bfd_boolean
name|abi_64_p
decl_stmt|;
name|htab
operator|=
name|_bfd_sparc_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
name|dynsize
operator|=
name|bed
operator|->
name|s
operator|->
name|sizeof_dyn
expr_stmt|;
name|dynconend
operator|=
name|sdyn
operator|->
name|contents
operator|+
name|sdyn
operator|->
name|size
expr_stmt|;
name|abi_64_p
operator|=
name|ABI_64_P
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
for|for
control|(
name|dyncon
operator|=
name|sdyn
operator|->
name|contents
init|;
name|dyncon
operator|<
name|dynconend
condition|;
name|dyncon
operator|+=
name|dynsize
control|)
block|{
name|Elf_Internal_Dyn
name|dyn
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bfd_boolean
name|size
decl_stmt|;
name|bed
operator|->
name|s
operator|->
name|swap_dyn_in
argument_list|(
name|dynobj
argument_list|,
name|dyncon
argument_list|,
operator|&
name|dyn
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|is_vxworks
operator|&&
name|dyn
operator|.
name|d_tag
operator|==
name|DT_RELASZ
condition|)
block|{
comment|/* On VxWorks, DT_RELASZ should not include the relocations 	     in .rela.plt.  */
if|if
condition|(
name|htab
operator|->
name|srelplt
condition|)
block|{
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|-=
name|htab
operator|->
name|srelplt
operator|->
name|size
expr_stmt|;
name|bed
operator|->
name|s
operator|->
name|swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|htab
operator|->
name|is_vxworks
operator|&&
name|dyn
operator|.
name|d_tag
operator|==
name|DT_PLTGOT
condition|)
block|{
comment|/* On VxWorks, DT_PLTGOT should point to the start of the GOT, 	     not to the start of the PLT.  */
if|if
condition|(
name|htab
operator|->
name|sgotplt
condition|)
block|{
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
operator|(
name|htab
operator|->
name|sgotplt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|sgotplt
operator|->
name|output_offset
operator|)
expr_stmt|;
name|bed
operator|->
name|s
operator|->
name|swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|abi_64_p
operator|&&
name|dyn
operator|.
name|d_tag
operator|==
name|DT_SPARC_REGISTER
condition|)
block|{
if|if
condition|(
name|stt_regidx
operator|==
operator|-
literal|1
condition|)
block|{
name|stt_regidx
operator|=
name|_bfd_elf_link_lookup_local_dynindx
argument_list|(
name|info
argument_list|,
name|output_bfd
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|stt_regidx
operator|==
operator|-
literal|1
condition|)
return|return
name|FALSE
return|;
block|}
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|stt_regidx
operator|++
expr_stmt|;
name|bed
operator|->
name|s
operator|->
name|swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|dyn
operator|.
name|d_tag
condition|)
block|{
case|case
name|DT_PLTGOT
case|:
name|name
operator|=
literal|".plt"
expr_stmt|;
name|size
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|DT_PLTRELSZ
case|:
name|name
operator|=
literal|".rela.plt"
expr_stmt|;
name|size
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|DT_JMPREL
case|:
name|name
operator|=
literal|".rela.plt"
expr_stmt|;
name|size
operator|=
name|FALSE
expr_stmt|;
break|break;
default|default:
name|name
operator|=
name|NULL
expr_stmt|;
name|size
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|size
condition|)
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|s
operator|->
name|vma
expr_stmt|;
else|else
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|s
operator|->
name|size
expr_stmt|;
block|}
name|bed
operator|->
name|s
operator|->
name|swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Install the first PLT entry in a VxWorks executable and make sure that    .rela.plt.unloaded relocations have the correct symbol indexes.  */
end_comment

begin_function
specifier|static
name|void
name|sparc_vxworks_finish_exec_plt
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|_bfd_sparc_elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|Elf_Internal_Rela
name|rela
decl_stmt|;
name|bfd_vma
name|got_base
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|htab
operator|=
name|_bfd_sparc_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* Calculate the absolute value of _GLOBAL_OFFSET_TABLE_.  */
name|got_base
operator|=
operator|(
name|htab
operator|->
name|elf
operator|.
name|hgot
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|elf
operator|.
name|hgot
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|+
name|htab
operator|->
name|elf
operator|.
name|hgot
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|)
expr_stmt|;
comment|/* Install the initial PLT entry.  */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|sparc_vxworks_exec_plt0_entry
index|[
literal|0
index|]
operator|+
operator|(
operator|(
name|got_base
operator|+
literal|8
operator|)
operator|>>
literal|10
operator|)
argument_list|,
name|htab
operator|->
name|splt
operator|->
name|contents
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|sparc_vxworks_exec_plt0_entry
index|[
literal|1
index|]
operator|+
operator|(
operator|(
name|got_base
operator|+
literal|8
operator|)
operator|&
literal|0x3ff
operator|)
argument_list|,
name|htab
operator|->
name|splt
operator|->
name|contents
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|sparc_vxworks_exec_plt0_entry
index|[
literal|2
index|]
argument_list|,
name|htab
operator|->
name|splt
operator|->
name|contents
operator|+
literal|8
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|sparc_vxworks_exec_plt0_entry
index|[
literal|3
index|]
argument_list|,
name|htab
operator|->
name|splt
operator|->
name|contents
operator|+
literal|12
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|sparc_vxworks_exec_plt0_entry
index|[
literal|4
index|]
argument_list|,
name|htab
operator|->
name|splt
operator|->
name|contents
operator|+
literal|16
argument_list|)
expr_stmt|;
name|loc
operator|=
name|htab
operator|->
name|srelplt2
operator|->
name|contents
expr_stmt|;
comment|/* Add an unloaded relocation for the initial entry's "sethi".  */
name|rela
operator|.
name|r_offset
operator|=
operator|(
name|htab
operator|->
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|splt
operator|->
name|output_offset
operator|)
expr_stmt|;
name|rela
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|hgot
operator|->
name|indx
argument_list|,
name|R_SPARC_HI22
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_addend
operator|=
literal|8
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rela
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|loc
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
comment|/* Likewise the following "or".  */
name|rela
operator|.
name|r_offset
operator|+=
literal|4
expr_stmt|;
name|rela
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|hgot
operator|->
name|indx
argument_list|,
name|R_SPARC_LO10
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rela
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|loc
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
comment|/* Fix up the remaining .rela.plt.unloaded relocations.  They may have      the wrong symbol index for _G_O_T_ or _P_L_T_ depending on the order      in which symbols were output.  */
while|while
condition|(
name|loc
operator|<
name|htab
operator|->
name|srelplt2
operator|->
name|contents
operator|+
name|htab
operator|->
name|srelplt2
operator|->
name|size
condition|)
block|{
name|Elf_Internal_Rela
name|rel
decl_stmt|;
comment|/* The entry's initial "sethi" (against _G_O_T_).  */
name|bfd_elf32_swap_reloc_in
argument_list|(
name|output_bfd
argument_list|,
name|loc
argument_list|,
operator|&
name|rel
argument_list|)
expr_stmt|;
name|rel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|hgot
operator|->
name|indx
argument_list|,
name|R_SPARC_HI22
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloc_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|loc
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
comment|/* The following "or" (also against _G_O_T_).  */
name|bfd_elf32_swap_reloc_in
argument_list|(
name|output_bfd
argument_list|,
name|loc
argument_list|,
operator|&
name|rel
argument_list|)
expr_stmt|;
name|rel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|hgot
operator|->
name|indx
argument_list|,
name|R_SPARC_LO10
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloc_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|loc
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
comment|/* The .got.plt entry (against _P_L_T_).  */
name|bfd_elf32_swap_reloc_in
argument_list|(
name|output_bfd
argument_list|,
name|loc
argument_list|,
operator|&
name|rel
argument_list|)
expr_stmt|;
name|rel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|hplt
operator|->
name|indx
argument_list|,
name|R_SPARC_32
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloc_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|loc
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Install the first PLT entry in a VxWorks shared object.  */
end_comment

begin_function
specifier|static
name|void
name|sparc_vxworks_finish_shared_plt
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|_bfd_sparc_elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|htab
operator|=
name|_bfd_sparc_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|sparc_vxworks_shared_plt0_entry
argument_list|)
condition|;
name|i
operator|++
control|)
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|sparc_vxworks_shared_plt0_entry
index|[
name|i
index|]
argument_list|,
name|htab
operator|->
name|splt
operator|->
name|contents
operator|+
name|i
operator|*
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|bfd_boolean
name|_bfd_sparc_elf_finish_dynamic_sections
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|sdyn
decl_stmt|;
name|struct
name|_bfd_sparc_elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|htab
operator|=
name|_bfd_sparc_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|dynobj
operator|=
name|htab
operator|->
name|elf
operator|.
name|dynobj
expr_stmt|;
name|sdyn
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
name|asection
modifier|*
name|splt
decl_stmt|;
name|splt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|splt
operator|!=
name|NULL
operator|&&
name|sdyn
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sparc_finish_dyn
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|dynobj
argument_list|,
name|sdyn
argument_list|,
name|splt
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Initialize the contents of the .plt section.  */
if|if
condition|(
name|splt
operator|->
name|size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|htab
operator|->
name|is_vxworks
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|shared
condition|)
name|sparc_vxworks_finish_shared_plt
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|)
expr_stmt|;
else|else
name|sparc_vxworks_finish_exec_plt
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memset
argument_list|(
name|splt
operator|->
name|contents
argument_list|,
literal|0
argument_list|,
name|htab
operator|->
name|plt_header_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ABI_64_P
argument_list|(
name|output_bfd
argument_list|)
condition|)
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|SPARC_NOP
argument_list|,
name|splt
operator|->
name|contents
operator|+
name|splt
operator|->
name|size
operator|-
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
name|elf_section_data
argument_list|(
name|splt
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
operator|=
operator|(
name|htab
operator|->
name|is_vxworks
operator|||
operator|!
name|ABI_64_P
argument_list|(
name|output_bfd
argument_list|)
operator|)
condition|?
literal|0
else|:
name|htab
operator|->
name|plt_entry_size
expr_stmt|;
block|}
comment|/* Set the first entry in the global offset table to the address of      the dynamic section.  */
if|if
condition|(
name|htab
operator|->
name|sgot
operator|&&
name|htab
operator|->
name|sgot
operator|->
name|size
operator|>
literal|0
condition|)
block|{
name|bfd_vma
name|val
init|=
operator|(
name|sdyn
condition|?
name|sdyn
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sdyn
operator|->
name|output_offset
else|:
literal|0
operator|)
decl_stmt|;
name|SPARC_ELF_PUT_WORD
argument_list|(
name|htab
argument_list|,
name|output_bfd
argument_list|,
name|val
argument_list|,
name|htab
operator|->
name|sgot
operator|->
name|contents
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|htab
operator|->
name|sgot
condition|)
name|elf_section_data
argument_list|(
name|htab
operator|->
name|sgot
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
operator|=
name|SPARC_ELF_WORD_BYTES
argument_list|(
name|htab
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set the right machine number for a SPARC ELF file.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_sparc_elf_object_p
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
if|if
condition|(
name|ABI_64_P
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|unsigned
name|long
name|mach
init|=
name|bfd_mach_sparc_v9
decl_stmt|;
if|if
condition|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_SPARC_SUN_US3
condition|)
name|mach
operator|=
name|bfd_mach_sparc_v9b
expr_stmt|;
elseif|else
if|if
condition|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_SPARC_SUN_US1
condition|)
name|mach
operator|=
name|bfd_mach_sparc_v9a
expr_stmt|;
return|return
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_sparc
argument_list|,
name|mach
argument_list|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_machine
operator|==
name|EM_SPARC32PLUS
condition|)
block|{
if|if
condition|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_SPARC_SUN_US3
condition|)
return|return
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_sparc
argument_list|,
name|bfd_mach_sparc_v8plusb
argument_list|)
return|;
elseif|else
if|if
condition|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_SPARC_SUN_US1
condition|)
return|return
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_sparc
argument_list|,
name|bfd_mach_sparc_v8plusa
argument_list|)
return|;
elseif|else
if|if
condition|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_SPARC_32PLUS
condition|)
return|return
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_sparc
argument_list|,
name|bfd_mach_sparc_v8plus
argument_list|)
return|;
else|else
return|return
name|FALSE
return|;
block|}
elseif|else
if|if
condition|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_SPARC_LEDATA
condition|)
return|return
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_sparc
argument_list|,
name|bfd_mach_sparc_sparclite_le
argument_list|)
return|;
else|else
return|return
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_sparc
argument_list|,
name|bfd_mach_sparc
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return address for Ith PLT stub in section PLT, for relocation REL    or (bfd_vma) -1 if it should not be included.  */
end_comment

begin_function
name|bfd_vma
name|_bfd_sparc_elf_plt_sym_val
parameter_list|(
name|bfd_vma
name|i
parameter_list|,
specifier|const
name|asection
modifier|*
name|plt
parameter_list|,
specifier|const
name|arelent
modifier|*
name|rel
parameter_list|)
block|{
if|if
condition|(
name|ABI_64_P
argument_list|(
name|plt
operator|->
name|owner
argument_list|)
condition|)
block|{
name|bfd_vma
name|j
decl_stmt|;
name|i
operator|+=
name|PLT64_HEADER_SIZE
operator|/
name|PLT64_ENTRY_SIZE
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|PLT64_LARGE_THRESHOLD
condition|)
return|return
name|plt
operator|->
name|vma
operator|+
name|i
operator|*
name|PLT64_ENTRY_SIZE
return|;
name|j
operator|=
operator|(
name|i
operator|-
name|PLT64_LARGE_THRESHOLD
operator|)
operator|%
literal|160
expr_stmt|;
name|i
operator|-=
name|j
expr_stmt|;
return|return
name|plt
operator|->
name|vma
operator|+
name|i
operator|*
name|PLT64_ENTRY_SIZE
operator|+
name|j
operator|*
literal|4
operator|*
literal|6
return|;
block|}
else|else
return|return
name|rel
operator|->
name|address
return|;
block|}
end_function

end_unit

