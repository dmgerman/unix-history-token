begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD back-end for s-record objects.    Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,    2000, 2001, 2002    Free Software Foundation, Inc.    Written by Steve Chamberlain of Cygnus Support<sac@cygnus.com>.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* SUBSECTION 	S-Record handling  DESCRIPTION  	Ordinary S-Records cannot hold anything but addresses and 	data, so that's all that we implement.  	The only interesting thing is that S-Records may come out of 	order and there is no header, so an initial scan is required 	to discover the minimum and maximum addresses used to create 	the vma and size of the only section we create.  We 	arbitrarily call this section ".text".  	When bfd_get_section_contents is called the file is read 	again, and this time the data is placed into a bfd_alloc'd 	area.  	Any number of sections may be created for output, we save them 	up and output them when it's time to close the bfd.  	An s record looks like:  EXAMPLE 	S<type><length><address><data><checksum>  DESCRIPTION 	Where 	o length 	is the number of bytes following upto the checksum. Note that 	this is not the number of chars following, since it takes two 	chars to represent a byte. 	o type 	is one of: 	0) header record 	1) two byte address data record 	2) three byte address data record 	3) four byte address data record 	7) four byte address termination record 	8) three byte address termination record 	9) two byte address termination record  	o address 	is the start address of the data following, or in the case of 	a termination record, the start address of the image 	o data 	is the data. 	o checksum 	is the sum of all the raw byte data in the record, from the length 	upwards, modulo 256 and subtracted from 255.  SUBSECTION 	Symbol S-Record handling  DESCRIPTION 	Some ICE equipment understands an addition to the standard 	S-Record format; symbols and their addresses can be sent 	before the data.  	The format of this is: 	($$<modulename> 		(<space><symbol><address>)*) 	$$  	so a short symbol table could look like:  EXAMPLE 	$$ flash.x 	$$ flash.c 	  _port6 $0 	  _delay $4 	  _start $14 	  _etext $8036 	  _edata $8036  	  _end $8036 	$$  DESCRIPTION 	We allow symbols to be anywhere in the data stream - the module names 	are always ignored.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_decl_stmt
specifier|static
name|void
name|srec_get_symbol_info
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|symbol_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|srec_print_symbol
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|asymbol
operator|*
operator|,
name|bfd_print_symbol_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|srec_init
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|srec_mkobject
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|srec_get_byte
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|boolean
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|srec_bad_byte
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|unsigned
name|int
operator|,
name|int
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|srec_scan
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|bfd_target
modifier|*
name|srec_object_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|bfd_target
modifier|*
name|symbolsrec_object_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|srec_read_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_byte
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|srec_write_record
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|unsigned
name|int
operator|,
name|bfd_vma
operator|,
specifier|const
name|bfd_byte
operator|*
operator|,
specifier|const
name|bfd_byte
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|srec_write_header
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|srec_write_symbols
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|srec_new_symbol
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|srec_get_section_contents
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|,
name|file_ptr
operator|,
name|bfd_size_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|srec_set_arch_mach
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|enum
name|bfd_architecture
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|srec_set_section_contents
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|sec_ptr
operator|,
name|PTR
operator|,
name|file_ptr
operator|,
name|bfd_size_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|internal_srec_write_object_contents
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|srec_write_object_contents
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|symbolsrec_write_object_contents
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|srec_sizeof_headers
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|srec_get_symtab_upper_bound
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|srec_get_symtab
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Macros for converting between hex and binary.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|digs
index|[]
init|=
literal|"0123456789ABCDEF"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NIBBLE
parameter_list|(
name|x
parameter_list|)
value|hex_value(x)
end_define

begin_define
define|#
directive|define
name|HEX
parameter_list|(
name|buffer
parameter_list|)
value|((NIBBLE((buffer)[0])<<4) + NIBBLE((buffer)[1]))
end_define

begin_define
define|#
directive|define
name|TOHEX
parameter_list|(
name|d
parameter_list|,
name|x
parameter_list|,
name|ch
parameter_list|)
define|\
value|d[1] = digs[(x)& 0xf]; \ 	d[0] = digs[((x)>>4)&0xf]; \ 	ch += ((x)& 0xff);
end_define

begin_define
define|#
directive|define
name|ISHEX
parameter_list|(
name|x
parameter_list|)
value|hex_p(x)
end_define

begin_comment
comment|/* Initialize by filling in the hex conversion array.  */
end_comment

begin_function
specifier|static
name|void
name|srec_init
parameter_list|()
block|{
specifier|static
name|boolean
name|inited
init|=
name|false
decl_stmt|;
if|if
condition|(
name|inited
operator|==
name|false
condition|)
block|{
name|inited
operator|=
name|true
expr_stmt|;
name|hex_init
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The maximum number of address+data+crc bytes on a line is FF.  */
end_comment

begin_define
define|#
directive|define
name|MAXCHUNK
value|0xff
end_define

begin_comment
comment|/* Default size for a CHUNK.  */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_CHUNK
value|16
end_define

begin_comment
comment|/* The number of data bytes we actually fit onto a line on output.    This variable can be modified by objcopy's --srec-len parameter.    For a 0x75 byte record you should set --srec-len=0x70.  */
end_comment

begin_decl_stmt
name|unsigned
name|int
name|Chunk
init|=
name|DEFAULT_CHUNK
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The type of srec output (free or forced to S3).    This variable can be modified by objcopy's --srec-forceS3    parameter.  */
end_comment

begin_decl_stmt
name|boolean
name|S3Forced
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When writing an S-record file, the S-records can not be output as    they are seen.  This structure is used to hold them in memory.  */
end_comment

begin_struct
struct|struct
name|srec_data_list_struct
block|{
name|struct
name|srec_data_list_struct
modifier|*
name|next
decl_stmt|;
name|bfd_byte
modifier|*
name|data
decl_stmt|;
name|bfd_vma
name|where
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|srec_data_list_struct
name|srec_data_list_type
typedef|;
end_typedef

begin_comment
comment|/* When scanning the S-record file, a linked list of srec_symbol    structures is built to represent the symbol table (if there is    one).  */
end_comment

begin_struct
struct|struct
name|srec_symbol
block|{
name|struct
name|srec_symbol
modifier|*
name|next
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The S-record tdata information.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|srec_data_struct
block|{
name|srec_data_list_type
modifier|*
name|head
decl_stmt|;
name|srec_data_list_type
modifier|*
name|tail
decl_stmt|;
name|unsigned
name|int
name|type
decl_stmt|;
name|struct
name|srec_symbol
modifier|*
name|symbols
decl_stmt|;
name|struct
name|srec_symbol
modifier|*
name|symtail
decl_stmt|;
name|asymbol
modifier|*
name|csymbols
decl_stmt|;
block|}
name|tdata_type
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|boolean
name|srec_write_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|tdata_type
operator|*
operator|,
name|srec_data_list_type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|srec_write_terminator
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|tdata_type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set up the S-record tdata information.  */
end_comment

begin_function
specifier|static
name|boolean
name|srec_mkobject
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|srec_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|tdata
operator|.
name|srec_data
operator|==
name|NULL
condition|)
block|{
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
name|tdata_type
argument_list|)
decl_stmt|;
name|tdata_type
modifier|*
name|tdata
init|=
operator|(
name|tdata_type
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
decl_stmt|;
if|if
condition|(
name|tdata
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|abfd
operator|->
name|tdata
operator|.
name|srec_data
operator|=
name|tdata
expr_stmt|;
name|tdata
operator|->
name|type
operator|=
literal|1
expr_stmt|;
name|tdata
operator|->
name|head
operator|=
name|NULL
expr_stmt|;
name|tdata
operator|->
name|tail
operator|=
name|NULL
expr_stmt|;
name|tdata
operator|->
name|symbols
operator|=
name|NULL
expr_stmt|;
name|tdata
operator|->
name|symtail
operator|=
name|NULL
expr_stmt|;
name|tdata
operator|->
name|csymbols
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Read a byte from an S record file.  Set *ERRORPTR if an error    occurred.  Return EOF on error or end of file.  */
end_comment

begin_function
specifier|static
name|int
name|srec_get_byte
parameter_list|(
name|abfd
parameter_list|,
name|errorptr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|boolean
modifier|*
name|errorptr
decl_stmt|;
block|{
name|bfd_byte
name|c
decl_stmt|;
if|if
condition|(
name|bfd_bread
argument_list|(
operator|&
name|c
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_file_truncated
condition|)
operator|*
name|errorptr
operator|=
name|true
expr_stmt|;
return|return
name|EOF
return|;
block|}
return|return
call|(
name|int
call|)
argument_list|(
name|c
operator|&
literal|0xff
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Report a problem in an S record file.  FIXME: This probably should    not call fprintf, but we really do need some mechanism for printing    error messages.  */
end_comment

begin_function
specifier|static
name|void
name|srec_bad_byte
parameter_list|(
name|abfd
parameter_list|,
name|lineno
parameter_list|,
name|c
parameter_list|,
name|error
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|unsigned
name|int
name|lineno
decl_stmt|;
name|int
name|c
decl_stmt|;
name|boolean
name|error
decl_stmt|;
block|{
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
operator|!
name|error
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_file_truncated
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|buf
index|[
literal|10
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|ISPRINT
argument_list|(
name|c
argument_list|)
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"\\%03o"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|c
argument_list|)
expr_stmt|;
else|else
block|{
name|buf
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s:%d: Unexpected character `%s' in S-record file\n"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|lineno
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Add a new symbol found in an S-record file.  */
end_comment

begin_function
specifier|static
name|boolean
name|srec_new_symbol
parameter_list|(
name|abfd
parameter_list|,
name|name
parameter_list|,
name|val
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
block|{
name|struct
name|srec_symbol
modifier|*
name|n
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|srec_symbol
argument_list|)
decl_stmt|;
name|n
operator|=
operator|(
expr|struct
name|srec_symbol
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|n
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|n
operator|->
name|val
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|tdata
operator|.
name|srec_data
operator|->
name|symbols
operator|==
name|NULL
condition|)
name|abfd
operator|->
name|tdata
operator|.
name|srec_data
operator|->
name|symbols
operator|=
name|n
expr_stmt|;
else|else
name|abfd
operator|->
name|tdata
operator|.
name|srec_data
operator|->
name|symtail
operator|->
name|next
operator|=
name|n
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|srec_data
operator|->
name|symtail
operator|=
name|n
expr_stmt|;
name|n
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|++
name|abfd
operator|->
name|symcount
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Read the S record file and turn it into sections.  We create a new    section for each contiguous set of bytes.  */
end_comment

begin_function
specifier|static
name|boolean
name|srec_scan
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|unsigned
name|int
name|lineno
init|=
literal|1
decl_stmt|;
name|boolean
name|error
init|=
name|false
decl_stmt|;
name|bfd_byte
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|size_t
name|bufsize
init|=
literal|0
decl_stmt|;
name|asection
modifier|*
name|sec
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|symbuf
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
while|while
condition|(
operator|(
name|c
operator|=
name|srec_get_byte
argument_list|(
name|abfd
argument_list|,
operator|&
name|error
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
comment|/* We only build sections from contiguous S-records, so if this          is not an S-record, then stop building a section.  */
if|if
condition|(
name|c
operator|!=
literal|'S'
operator|&&
name|c
operator|!=
literal|'\r'
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
name|sec
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
default|default:
name|srec_bad_byte
argument_list|(
name|abfd
argument_list|,
name|lineno
argument_list|,
name|c
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
case|case
literal|'\n'
case|:
operator|++
name|lineno
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
break|break;
case|case
literal|'$'
case|:
comment|/* Starting a module name, which we ignore.  */
while|while
condition|(
operator|(
name|c
operator|=
name|srec_get_byte
argument_list|(
name|abfd
argument_list|,
operator|&
name|error
argument_list|)
operator|)
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
condition|)
empty_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
name|srec_bad_byte
argument_list|(
name|abfd
argument_list|,
name|lineno
argument_list|,
name|c
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
operator|++
name|lineno
expr_stmt|;
break|break;
case|case
literal|' '
case|:
do|do
block|{
name|bfd_size_type
name|alc
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|symname
decl_stmt|;
name|bfd_vma
name|symval
decl_stmt|;
comment|/* Starting a symbol definition.  */
while|while
condition|(
operator|(
name|c
operator|=
name|srec_get_byte
argument_list|(
name|abfd
argument_list|,
operator|&
name|error
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
operator|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|)
condition|)
empty_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\r'
condition|)
break|break;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
name|srec_bad_byte
argument_list|(
name|abfd
argument_list|,
name|lineno
argument_list|,
name|c
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|alc
operator|=
literal|10
expr_stmt|;
name|symbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|alc
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbuf
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|p
operator|=
name|symbuf
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|srec_get_byte
argument_list|(
name|abfd
argument_list|,
operator|&
name|error
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
operator|!
name|ISSPACE
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
call|(
name|bfd_size_type
call|)
argument_list|(
name|p
operator|-
name|symbuf
argument_list|)
operator|>=
name|alc
condition|)
block|{
name|char
modifier|*
name|n
decl_stmt|;
name|alc
operator|*=
literal|2
expr_stmt|;
name|n
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_realloc
argument_list|(
name|symbuf
argument_list|,
name|alc
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|p
operator|=
name|n
operator|+
operator|(
name|p
operator|-
name|symbuf
operator|)
expr_stmt|;
name|symbuf
operator|=
name|n
expr_stmt|;
block|}
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
name|srec_bad_byte
argument_list|(
name|abfd
argument_list|,
name|lineno
argument_list|,
name|c
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|symname
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
call|(
name|bfd_size_type
call|)
argument_list|(
name|p
operator|-
name|symbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|symname
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|strcpy
argument_list|(
name|symname
argument_list|,
name|symbuf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|symbuf
argument_list|)
expr_stmt|;
name|symbuf
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|srec_get_byte
argument_list|(
name|abfd
argument_list|,
operator|&
name|error
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
operator|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|)
condition|)
empty_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
name|srec_bad_byte
argument_list|(
name|abfd
argument_list|,
name|lineno
argument_list|,
name|c
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
comment|/* Skip a dollar sign before the hex value.  */
if|if
condition|(
name|c
operator|==
literal|'$'
condition|)
block|{
name|c
operator|=
name|srec_get_byte
argument_list|(
name|abfd
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
name|srec_bad_byte
argument_list|(
name|abfd
argument_list|,
name|lineno
argument_list|,
name|c
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
block|}
name|symval
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ISHEX
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|symval
operator|<<=
literal|4
expr_stmt|;
name|symval
operator|+=
name|NIBBLE
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
name|srec_get_byte
argument_list|(
name|abfd
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|srec_new_symbol
argument_list|(
name|abfd
argument_list|,
name|symname
argument_list|,
name|symval
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
do|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
do|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
operator|++
name|lineno
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|!=
literal|'\r'
condition|)
block|{
name|srec_bad_byte
argument_list|(
name|abfd
argument_list|,
name|lineno
argument_list|,
name|c
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
break|break;
case|case
literal|'S'
case|:
block|{
name|file_ptr
name|pos
decl_stmt|;
name|char
name|hdr
index|[
literal|3
index|]
decl_stmt|;
name|unsigned
name|int
name|bytes
decl_stmt|;
name|bfd_vma
name|address
decl_stmt|;
name|bfd_byte
modifier|*
name|data
decl_stmt|;
comment|/* Starting an S-record.  */
name|pos
operator|=
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|bfd_bread
argument_list|(
name|hdr
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|3
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|3
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|ISHEX
argument_list|(
name|hdr
index|[
literal|1
index|]
argument_list|)
operator|||
operator|!
name|ISHEX
argument_list|(
name|hdr
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ISHEX
argument_list|(
name|hdr
index|[
literal|1
index|]
argument_list|)
condition|)
name|c
operator|=
name|hdr
index|[
literal|1
index|]
expr_stmt|;
else|else
name|c
operator|=
name|hdr
index|[
literal|2
index|]
expr_stmt|;
name|srec_bad_byte
argument_list|(
name|abfd
argument_list|,
name|lineno
argument_list|,
name|c
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|bytes
operator|=
name|HEX
argument_list|(
name|hdr
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|*
literal|2
operator|>
name|bufsize
condition|)
block|{
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_malloc
argument_list|(
operator|(
name|bfd_size_type
operator|)
name|bytes
operator|*
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|bufsize
operator|=
name|bytes
operator|*
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|bfd_bread
argument_list|(
name|buf
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|bytes
operator|*
literal|2
argument_list|,
name|abfd
argument_list|)
operator|!=
name|bytes
operator|*
literal|2
condition|)
goto|goto
name|error_return
goto|;
comment|/* Ignore the checksum byte.  */
operator|--
name|bytes
expr_stmt|;
name|address
operator|=
literal|0
expr_stmt|;
name|data
operator|=
name|buf
expr_stmt|;
switch|switch
condition|(
name|hdr
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'0'
case|:
case|case
literal|'5'
case|:
comment|/* Prologue--ignore the file name, but stop building a                    section at this point.  */
name|sec
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
literal|'3'
case|:
name|address
operator|=
name|HEX
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|2
expr_stmt|;
operator|--
name|bytes
expr_stmt|;
comment|/* Fall through.  */
case|case
literal|'2'
case|:
name|address
operator|=
operator|(
name|address
operator|<<
literal|8
operator|)
operator||
name|HEX
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|2
expr_stmt|;
operator|--
name|bytes
expr_stmt|;
comment|/* Fall through.  */
case|case
literal|'1'
case|:
name|address
operator|=
operator|(
name|address
operator|<<
literal|8
operator|)
operator||
name|HEX
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|2
expr_stmt|;
name|address
operator|=
operator|(
name|address
operator|<<
literal|8
operator|)
operator||
name|HEX
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|2
expr_stmt|;
name|bytes
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
name|sec
operator|!=
name|NULL
operator|&&
name|sec
operator|->
name|vma
operator|+
name|sec
operator|->
name|_raw_size
operator|==
name|address
condition|)
block|{
comment|/* This data goes at the end of the section we are                        currently building.  */
name|sec
operator|->
name|_raw_size
operator|+=
name|bytes
expr_stmt|;
block|}
else|else
block|{
name|char
name|secbuf
index|[
literal|20
index|]
decl_stmt|;
name|char
modifier|*
name|secname
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|sprintf
argument_list|(
name|secbuf
argument_list|,
literal|".sec%d"
argument_list|,
name|bfd_count_sections
argument_list|(
name|abfd
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|amt
operator|=
name|strlen
argument_list|(
name|secbuf
argument_list|)
operator|+
literal|1
expr_stmt|;
name|secname
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|secname
argument_list|,
name|secbuf
argument_list|)
expr_stmt|;
name|sec
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
name|secname
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|sec
operator|->
name|flags
operator|=
name|SEC_HAS_CONTENTS
operator||
name|SEC_LOAD
operator||
name|SEC_ALLOC
expr_stmt|;
name|sec
operator|->
name|vma
operator|=
name|address
expr_stmt|;
name|sec
operator|->
name|lma
operator|=
name|address
expr_stmt|;
name|sec
operator|->
name|_raw_size
operator|=
name|bytes
expr_stmt|;
name|sec
operator|->
name|filepos
operator|=
name|pos
expr_stmt|;
block|}
break|break;
case|case
literal|'7'
case|:
name|address
operator|=
name|HEX
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|2
expr_stmt|;
comment|/* Fall through.  */
case|case
literal|'8'
case|:
name|address
operator|=
operator|(
name|address
operator|<<
literal|8
operator|)
operator||
name|HEX
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|2
expr_stmt|;
comment|/* Fall through.  */
case|case
literal|'9'
case|:
name|address
operator|=
operator|(
name|address
operator|<<
literal|8
operator|)
operator||
name|HEX
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|2
expr_stmt|;
name|address
operator|=
operator|(
name|address
operator|<<
literal|8
operator|)
operator||
name|HEX
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|2
expr_stmt|;
comment|/* This is a termination record.  */
name|abfd
operator|->
name|start_address
operator|=
name|address
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
break|break;
block|}
block|}
if|if
condition|(
name|error
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|true
return|;
name|error_return
label|:
if|if
condition|(
name|symbuf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|symbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Check whether an existing file is an S-record file.  */
end_comment

begin_function
specifier|static
specifier|const
name|bfd_target
modifier|*
name|srec_object_p
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|bfd_byte
name|b
index|[
literal|4
index|]
decl_stmt|;
name|srec_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bread
argument_list|(
name|b
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|4
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|b
index|[
literal|0
index|]
operator|!=
literal|'S'
operator|||
operator|!
name|ISHEX
argument_list|(
name|b
index|[
literal|1
index|]
argument_list|)
operator|||
operator|!
name|ISHEX
argument_list|(
name|b
index|[
literal|2
index|]
argument_list|)
operator|||
operator|!
name|ISHEX
argument_list|(
name|b
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|srec_mkobject
argument_list|(
name|abfd
argument_list|)
operator|||
operator|!
name|srec_scan
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|abfd
operator|->
name|symcount
operator|>
literal|0
condition|)
name|abfd
operator|->
name|flags
operator||=
name|HAS_SYMS
expr_stmt|;
return|return
name|abfd
operator|->
name|xvec
return|;
block|}
end_function

begin_comment
comment|/* Check whether an existing file is an S-record file with symbols.  */
end_comment

begin_function
specifier|static
specifier|const
name|bfd_target
modifier|*
name|symbolsrec_object_p
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|char
name|b
index|[
literal|2
index|]
decl_stmt|;
name|srec_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bread
argument_list|(
name|b
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|2
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|2
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|b
index|[
literal|0
index|]
operator|!=
literal|'$'
operator|||
name|b
index|[
literal|1
index|]
operator|!=
literal|'$'
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|srec_mkobject
argument_list|(
name|abfd
argument_list|)
operator|||
operator|!
name|srec_scan
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|abfd
operator|->
name|symcount
operator|>
literal|0
condition|)
name|abfd
operator|->
name|flags
operator||=
name|HAS_SYMS
expr_stmt|;
return|return
name|abfd
operator|->
name|xvec
return|;
block|}
end_function

begin_comment
comment|/* Read in the contents of a section in an S-record file.  */
end_comment

begin_function
specifier|static
name|boolean
name|srec_read_section
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|contents
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|bfd_size_type
name|sofar
init|=
literal|0
decl_stmt|;
name|boolean
name|error
init|=
name|false
decl_stmt|;
name|bfd_byte
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|size_t
name|bufsize
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|section
operator|->
name|filepos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
while|while
condition|(
operator|(
name|c
operator|=
name|srec_get_byte
argument_list|(
name|abfd
argument_list|,
operator|&
name|error
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
name|bfd_byte
name|hdr
index|[
literal|3
index|]
decl_stmt|;
name|unsigned
name|int
name|bytes
decl_stmt|;
name|bfd_vma
name|address
decl_stmt|;
name|bfd_byte
modifier|*
name|data
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\r'
operator|||
name|c
operator|==
literal|'\n'
condition|)
continue|continue;
comment|/* This is called after srec_scan has already been called, so we          ought to know the exact format.  */
name|BFD_ASSERT
argument_list|(
name|c
operator|==
literal|'S'
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_bread
argument_list|(
name|hdr
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|3
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|3
condition|)
goto|goto
name|error_return
goto|;
name|BFD_ASSERT
argument_list|(
name|ISHEX
argument_list|(
name|hdr
index|[
literal|1
index|]
argument_list|)
operator|&&
name|ISHEX
argument_list|(
name|hdr
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|bytes
operator|=
name|HEX
argument_list|(
name|hdr
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|*
literal|2
operator|>
name|bufsize
condition|)
block|{
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_malloc
argument_list|(
operator|(
name|bfd_size_type
operator|)
name|bytes
operator|*
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|bufsize
operator|=
name|bytes
operator|*
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|bfd_bread
argument_list|(
name|buf
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|bytes
operator|*
literal|2
argument_list|,
name|abfd
argument_list|)
operator|!=
name|bytes
operator|*
literal|2
condition|)
goto|goto
name|error_return
goto|;
name|address
operator|=
literal|0
expr_stmt|;
name|data
operator|=
name|buf
expr_stmt|;
switch|switch
condition|(
name|hdr
index|[
literal|0
index|]
condition|)
block|{
default|default:
name|BFD_ASSERT
argument_list|(
name|sofar
operator|==
name|section
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
literal|'3'
case|:
name|address
operator|=
name|HEX
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|2
expr_stmt|;
operator|--
name|bytes
expr_stmt|;
comment|/* Fall through.  */
case|case
literal|'2'
case|:
name|address
operator|=
operator|(
name|address
operator|<<
literal|8
operator|)
operator||
name|HEX
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|2
expr_stmt|;
operator|--
name|bytes
expr_stmt|;
comment|/* Fall through.  */
case|case
literal|'1'
case|:
name|address
operator|=
operator|(
name|address
operator|<<
literal|8
operator|)
operator||
name|HEX
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|2
expr_stmt|;
name|address
operator|=
operator|(
name|address
operator|<<
literal|8
operator|)
operator||
name|HEX
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|2
expr_stmt|;
name|bytes
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
name|address
operator|!=
name|section
operator|->
name|vma
operator|+
name|sofar
condition|)
block|{
comment|/* We've come to the end of this section.  */
name|BFD_ASSERT
argument_list|(
name|sofar
operator|==
name|section
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* Don't consider checksum.  */
operator|--
name|bytes
expr_stmt|;
while|while
condition|(
name|bytes
operator|--
operator|!=
literal|0
condition|)
block|{
name|contents
index|[
name|sofar
index|]
operator|=
name|HEX
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|2
expr_stmt|;
operator|++
name|sofar
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|error
condition|)
goto|goto
name|error_return
goto|;
name|BFD_ASSERT
argument_list|(
name|sofar
operator|==
name|section
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|true
return|;
name|error_return
label|:
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Get the contents of a section in an S-record file.  */
end_comment

begin_function
specifier|static
name|boolean
name|srec_get_section_contents
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|location
parameter_list|,
name|offset
parameter_list|,
name|count
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|PTR
name|location
decl_stmt|;
name|file_ptr
name|offset
decl_stmt|;
name|bfd_size_type
name|count
decl_stmt|;
block|{
if|if
condition|(
name|section
operator|->
name|used_by_bfd
operator|==
name|NULL
condition|)
block|{
name|section
operator|->
name|used_by_bfd
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|section
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|section
operator|->
name|used_by_bfd
operator|==
name|NULL
operator|&&
name|section
operator|->
name|_raw_size
operator|!=
literal|0
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|srec_read_section
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|section
operator|->
name|used_by_bfd
argument_list|)
condition|)
return|return
name|false
return|;
block|}
name|memcpy
argument_list|(
name|location
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|section
operator|->
name|used_by_bfd
operator|+
name|offset
argument_list|,
operator|(
name|size_t
operator|)
name|count
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Set the architecture.  We accept an unknown architecture here.  */
end_comment

begin_function
specifier|static
name|boolean
name|srec_set_arch_mach
parameter_list|(
name|abfd
parameter_list|,
name|arch
parameter_list|,
name|mach
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|enum
name|bfd_architecture
name|arch
decl_stmt|;
name|unsigned
name|long
name|mach
decl_stmt|;
block|{
if|if
condition|(
name|arch
operator|==
name|bfd_arch_unknown
condition|)
block|{
name|abfd
operator|->
name|arch_info
operator|=
operator|&
name|bfd_default_arch_struct
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|arch
argument_list|,
name|mach
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* We have to save up all the Srecords for a splurge before output.  */
end_comment

begin_function
specifier|static
name|boolean
name|srec_set_section_contents
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|location
parameter_list|,
name|offset
parameter_list|,
name|bytes_to_do
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|sec_ptr
name|section
decl_stmt|;
name|PTR
name|location
decl_stmt|;
name|file_ptr
name|offset
decl_stmt|;
name|bfd_size_type
name|bytes_to_do
decl_stmt|;
block|{
name|tdata_type
modifier|*
name|tdata
init|=
name|abfd
operator|->
name|tdata
operator|.
name|srec_data
decl_stmt|;
specifier|register
name|srec_data_list_type
modifier|*
name|entry
decl_stmt|;
name|entry
operator|=
operator|(
operator|(
name|srec_data_list_type
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_size_type
operator|)
sizeof|sizeof
argument_list|(
name|srec_data_list_type
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bytes_to_do
operator|&&
operator|(
name|section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|&&
operator|(
name|section
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
condition|)
block|{
name|bfd_byte
modifier|*
name|data
decl_stmt|;
name|data
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|bytes_to_do
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|memcpy
argument_list|(
operator|(
name|PTR
operator|)
name|data
argument_list|,
name|location
argument_list|,
operator|(
name|size_t
operator|)
name|bytes_to_do
argument_list|)
expr_stmt|;
comment|/* Ff S3Forced is true then always select S3 records, 	 regardless of the siez of the addresses.  */
if|if
condition|(
name|S3Forced
condition|)
name|tdata
operator|->
name|type
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|section
operator|->
name|lma
operator|+
name|offset
operator|+
name|bytes_to_do
operator|-
literal|1
operator|)
operator|<=
literal|0xffff
condition|)
empty_stmt|;
comment|/* The default, S1, is OK.  */
elseif|else
if|if
condition|(
operator|(
name|section
operator|->
name|lma
operator|+
name|offset
operator|+
name|bytes_to_do
operator|-
literal|1
operator|)
operator|<=
literal|0xffffff
operator|&&
name|tdata
operator|->
name|type
operator|<=
literal|2
condition|)
name|tdata
operator|->
name|type
operator|=
literal|2
expr_stmt|;
else|else
name|tdata
operator|->
name|type
operator|=
literal|3
expr_stmt|;
name|entry
operator|->
name|data
operator|=
name|data
expr_stmt|;
name|entry
operator|->
name|where
operator|=
name|section
operator|->
name|lma
operator|+
name|offset
expr_stmt|;
name|entry
operator|->
name|size
operator|=
name|bytes_to_do
expr_stmt|;
comment|/* Sort the records by address.  Optimize for the common case of          adding a record to the end of the list.  */
if|if
condition|(
name|tdata
operator|->
name|tail
operator|!=
name|NULL
operator|&&
name|entry
operator|->
name|where
operator|>=
name|tdata
operator|->
name|tail
operator|->
name|where
condition|)
block|{
name|tdata
operator|->
name|tail
operator|->
name|next
operator|=
name|entry
expr_stmt|;
name|entry
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|tdata
operator|->
name|tail
operator|=
name|entry
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|srec_data_list_type
modifier|*
modifier|*
name|look
decl_stmt|;
for|for
control|(
name|look
operator|=
operator|&
name|tdata
operator|->
name|head
init|;
operator|*
name|look
operator|!=
name|NULL
operator|&&
operator|(
operator|*
name|look
operator|)
operator|->
name|where
operator|<
name|entry
operator|->
name|where
condition|;
name|look
operator|=
operator|&
operator|(
operator|*
name|look
operator|)
operator|->
name|next
control|)
empty_stmt|;
name|entry
operator|->
name|next
operator|=
operator|*
name|look
expr_stmt|;
operator|*
name|look
operator|=
name|entry
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|next
operator|==
name|NULL
condition|)
name|tdata
operator|->
name|tail
operator|=
name|entry
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Write a record of type, of the supplied number of bytes. The    supplied bytes and length don't have a checksum. That's worked out    here.  */
end_comment

begin_function
specifier|static
name|boolean
name|srec_write_record
parameter_list|(
name|abfd
parameter_list|,
name|type
parameter_list|,
name|address
parameter_list|,
name|data
parameter_list|,
name|end
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|unsigned
name|int
name|type
decl_stmt|;
name|bfd_vma
name|address
decl_stmt|;
specifier|const
name|bfd_byte
modifier|*
name|data
decl_stmt|;
specifier|const
name|bfd_byte
modifier|*
name|end
decl_stmt|;
block|{
name|char
name|buffer
index|[
literal|2
operator|*
name|MAXCHUNK
operator|+
literal|6
index|]
decl_stmt|;
name|unsigned
name|int
name|check_sum
init|=
literal|0
decl_stmt|;
specifier|const
name|bfd_byte
modifier|*
name|src
init|=
name|data
decl_stmt|;
name|char
modifier|*
name|dst
init|=
name|buffer
decl_stmt|;
name|char
modifier|*
name|length
decl_stmt|;
name|bfd_size_type
name|wrlen
decl_stmt|;
operator|*
name|dst
operator|++
operator|=
literal|'S'
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
literal|'0'
operator|+
name|type
expr_stmt|;
name|length
operator|=
name|dst
expr_stmt|;
name|dst
operator|+=
literal|2
expr_stmt|;
comment|/* Leave room for dst.  */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|3
case|:
case|case
literal|7
case|:
name|TOHEX
argument_list|(
name|dst
argument_list|,
operator|(
name|address
operator|>>
literal|24
operator|)
argument_list|,
name|check_sum
argument_list|)
expr_stmt|;
name|dst
operator|+=
literal|2
expr_stmt|;
case|case
literal|8
case|:
case|case
literal|2
case|:
name|TOHEX
argument_list|(
name|dst
argument_list|,
operator|(
name|address
operator|>>
literal|16
operator|)
argument_list|,
name|check_sum
argument_list|)
expr_stmt|;
name|dst
operator|+=
literal|2
expr_stmt|;
case|case
literal|9
case|:
case|case
literal|1
case|:
case|case
literal|0
case|:
name|TOHEX
argument_list|(
name|dst
argument_list|,
operator|(
name|address
operator|>>
literal|8
operator|)
argument_list|,
name|check_sum
argument_list|)
expr_stmt|;
name|dst
operator|+=
literal|2
expr_stmt|;
name|TOHEX
argument_list|(
name|dst
argument_list|,
operator|(
name|address
operator|)
argument_list|,
name|check_sum
argument_list|)
expr_stmt|;
name|dst
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
for|for
control|(
name|src
operator|=
name|data
init|;
name|src
operator|<
name|end
condition|;
name|src
operator|++
control|)
block|{
name|TOHEX
argument_list|(
name|dst
argument_list|,
operator|*
name|src
argument_list|,
name|check_sum
argument_list|)
expr_stmt|;
name|dst
operator|+=
literal|2
expr_stmt|;
block|}
comment|/* Fill in the length.  */
name|TOHEX
argument_list|(
name|length
argument_list|,
operator|(
name|dst
operator|-
name|length
operator|)
operator|/
literal|2
argument_list|,
name|check_sum
argument_list|)
expr_stmt|;
name|check_sum
operator|&=
literal|0xff
expr_stmt|;
name|check_sum
operator|=
literal|255
operator|-
name|check_sum
expr_stmt|;
name|TOHEX
argument_list|(
name|dst
argument_list|,
name|check_sum
argument_list|,
name|check_sum
argument_list|)
expr_stmt|;
name|dst
operator|+=
literal|2
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
literal|'\r'
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
literal|'\n'
expr_stmt|;
name|wrlen
operator|=
name|dst
operator|-
name|buffer
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
operator|(
name|PTR
operator|)
name|buffer
argument_list|,
name|wrlen
argument_list|,
name|abfd
argument_list|)
operator|!=
name|wrlen
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|srec_write_header
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|unsigned
name|int
name|len
init|=
name|strlen
argument_list|(
name|abfd
operator|->
name|filename
argument_list|)
decl_stmt|;
comment|/* I'll put an arbitary 40 char limit on header size.  */
if|if
condition|(
name|len
operator|>
literal|40
condition|)
name|len
operator|=
literal|40
expr_stmt|;
return|return
name|srec_write_record
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|abfd
operator|->
name|filename
argument_list|,
name|abfd
operator|->
name|filename
operator|+
name|len
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|srec_write_section
parameter_list|(
name|abfd
parameter_list|,
name|tdata
parameter_list|,
name|list
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|tdata_type
modifier|*
name|tdata
decl_stmt|;
name|srec_data_list_type
modifier|*
name|list
decl_stmt|;
block|{
name|unsigned
name|int
name|octets_written
init|=
literal|0
decl_stmt|;
name|bfd_byte
modifier|*
name|location
init|=
name|list
operator|->
name|data
decl_stmt|;
comment|/* Validate number of data bytes to write.  The srec length byte      counts the address, data and crc bytes.  S1 (tdata->type == 1)      records have two address bytes, S2 (tdata->type == 2) records      have three, and S3 (tdata->type == 3) records have four.      The total length can't exceed 255, and a zero data length will      spin for a long time.  */
if|if
condition|(
name|Chunk
operator|==
literal|0
condition|)
name|Chunk
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|Chunk
operator|>
name|MAXCHUNK
operator|-
name|tdata
operator|->
name|type
operator|-
literal|2
condition|)
name|Chunk
operator|=
name|MAXCHUNK
operator|-
name|tdata
operator|->
name|type
operator|-
literal|2
expr_stmt|;
while|while
condition|(
name|octets_written
operator|<
name|list
operator|->
name|size
condition|)
block|{
name|bfd_vma
name|address
decl_stmt|;
name|unsigned
name|int
name|octets_this_chunk
init|=
name|list
operator|->
name|size
operator|-
name|octets_written
decl_stmt|;
if|if
condition|(
name|octets_this_chunk
operator|>
name|Chunk
condition|)
name|octets_this_chunk
operator|=
name|Chunk
expr_stmt|;
name|address
operator|=
name|list
operator|->
name|where
operator|+
name|octets_written
operator|/
name|bfd_octets_per_byte
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|srec_write_record
argument_list|(
name|abfd
argument_list|,
name|tdata
operator|->
name|type
argument_list|,
name|address
argument_list|,
name|location
argument_list|,
name|location
operator|+
name|octets_this_chunk
argument_list|)
condition|)
return|return
name|false
return|;
name|octets_written
operator|+=
name|octets_this_chunk
expr_stmt|;
name|location
operator|+=
name|octets_this_chunk
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|srec_write_terminator
parameter_list|(
name|abfd
parameter_list|,
name|tdata
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|tdata_type
modifier|*
name|tdata
decl_stmt|;
block|{
return|return
name|srec_write_record
argument_list|(
name|abfd
argument_list|,
literal|10
operator|-
name|tdata
operator|->
name|type
argument_list|,
name|abfd
operator|->
name|start_address
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|srec_write_symbols
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
comment|/* Dump out the symbols of a bfd.  */
name|int
name|i
decl_stmt|;
name|int
name|count
init|=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
if|if
condition|(
name|count
condition|)
block|{
name|bfd_size_type
name|len
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|table
init|=
name|bfd_get_outsymbols
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|abfd
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
literal|"$$ "
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|3
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|3
operator|||
name|bfd_bwrite
argument_list|(
name|abfd
operator|->
name|filename
argument_list|,
name|len
argument_list|,
name|abfd
argument_list|)
operator|!=
name|len
operator|||
name|bfd_bwrite
argument_list|(
literal|"\r\n"
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|2
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|2
condition|)
return|return
name|false
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|asymbol
modifier|*
name|s
init|=
name|table
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|bfd_is_local_label
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|)
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
name|BSF_DEBUGGING
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Just dump out non debug symbols.  */
name|char
name|buf
index|[
literal|42
index|]
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
literal|"  "
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|2
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|2
operator|||
name|bfd_bwrite
argument_list|(
name|s
operator|->
name|name
argument_list|,
name|len
argument_list|,
name|abfd
argument_list|)
operator|!=
name|len
condition|)
return|return
name|false
return|;
name|sprintf_vma
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
operator|(
name|s
operator|->
name|value
operator|+
name|s
operator|->
name|section
operator|->
name|output_section
operator|->
name|lma
operator|+
name|s
operator|->
name|section
operator|->
name|output_offset
operator|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|buf
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'0'
operator|&&
name|p
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
name|p
operator|++
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
index|[
name|len
index|]
operator|=
literal|'\r'
expr_stmt|;
name|p
index|[
name|len
operator|+
literal|1
index|]
operator|=
literal|'\n'
expr_stmt|;
operator|*
operator|--
name|p
operator|=
literal|' '
expr_stmt|;
name|len
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
name|p
argument_list|,
name|len
argument_list|,
name|abfd
argument_list|)
operator|!=
name|len
condition|)
return|return
name|false
return|;
block|}
block|}
if|if
condition|(
name|bfd_bwrite
argument_list|(
literal|"$$ \r\n"
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|5
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|5
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|internal_srec_write_object_contents
parameter_list|(
name|abfd
parameter_list|,
name|symbols
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|int
name|symbols
decl_stmt|;
block|{
name|tdata_type
modifier|*
name|tdata
init|=
name|abfd
operator|->
name|tdata
operator|.
name|srec_data
decl_stmt|;
name|srec_data_list_type
modifier|*
name|list
decl_stmt|;
if|if
condition|(
name|symbols
condition|)
block|{
if|if
condition|(
operator|!
name|srec_write_symbols
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|srec_write_header
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Now wander though all the sections provided and output them.  */
name|list
operator|=
name|tdata
operator|->
name|head
expr_stmt|;
while|while
condition|(
name|list
operator|!=
operator|(
name|srec_data_list_type
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|srec_write_section
argument_list|(
name|abfd
argument_list|,
name|tdata
argument_list|,
name|list
argument_list|)
condition|)
return|return
name|false
return|;
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
block|}
return|return
name|srec_write_terminator
argument_list|(
name|abfd
argument_list|,
name|tdata
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|srec_write_object_contents
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
return|return
name|internal_srec_write_object_contents
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|symbolsrec_write_object_contents
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
return|return
name|internal_srec_write_object_contents
argument_list|(
name|abfd
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|srec_sizeof_headers
parameter_list|(
name|abfd
parameter_list|,
name|exec
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|boolean
name|exec
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the amount of memory needed to read the symbol table.  */
end_comment

begin_function
specifier|static
name|long
name|srec_get_symtab_upper_bound
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
return|return
operator|(
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the symbol table.  */
end_comment

begin_function
specifier|static
name|long
name|srec_get_symtab
parameter_list|(
name|abfd
parameter_list|,
name|alocation
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|alocation
decl_stmt|;
block|{
name|bfd_size_type
name|symcount
init|=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|asymbol
modifier|*
name|csymbols
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|csymbols
operator|=
name|abfd
operator|->
name|tdata
operator|.
name|srec_data
operator|->
name|csymbols
expr_stmt|;
if|if
condition|(
name|csymbols
operator|==
name|NULL
condition|)
block|{
name|asymbol
modifier|*
name|c
decl_stmt|;
name|struct
name|srec_symbol
modifier|*
name|s
decl_stmt|;
name|csymbols
operator|=
operator|(
name|asymbol
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|symcount
operator|*
sizeof|sizeof
argument_list|(
name|asymbol
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|csymbols
operator|==
name|NULL
operator|&&
name|symcount
operator|!=
literal|0
condition|)
return|return
name|false
return|;
name|abfd
operator|->
name|tdata
operator|.
name|srec_data
operator|->
name|csymbols
operator|=
name|csymbols
expr_stmt|;
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|tdata
operator|.
name|srec_data
operator|->
name|symbols
operator|,
name|c
operator|=
name|csymbols
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
operator|,
operator|++
name|c
control|)
block|{
name|c
operator|->
name|the_bfd
operator|=
name|abfd
expr_stmt|;
name|c
operator|->
name|name
operator|=
name|s
operator|->
name|name
expr_stmt|;
name|c
operator|->
name|value
operator|=
name|s
operator|->
name|val
expr_stmt|;
name|c
operator|->
name|flags
operator|=
name|BSF_GLOBAL
expr_stmt|;
name|c
operator|->
name|section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
name|c
operator|->
name|udata
operator|.
name|p
operator|=
name|NULL
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|symcount
condition|;
name|i
operator|++
control|)
operator|*
name|alocation
operator|++
operator|=
name|csymbols
operator|++
expr_stmt|;
operator|*
name|alocation
operator|=
name|NULL
expr_stmt|;
return|return
name|symcount
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|srec_get_symbol_info
parameter_list|(
name|ignore_abfd
parameter_list|,
name|symbol
parameter_list|,
name|ret
parameter_list|)
name|bfd
modifier|*
name|ignore_abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|symbol_info
modifier|*
name|ret
decl_stmt|;
block|{
name|bfd_symbol_info
argument_list|(
name|symbol
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|srec_print_symbol
parameter_list|(
name|abfd
parameter_list|,
name|afile
parameter_list|,
name|symbol
parameter_list|,
name|how
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|afile
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|bfd_print_symbol_type
name|how
decl_stmt|;
block|{
name|FILE
modifier|*
name|file
init|=
operator|(
name|FILE
operator|*
operator|)
name|afile
decl_stmt|;
switch|switch
condition|(
name|how
condition|)
block|{
case|case
name|bfd_print_symbol_name
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|symbol
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
default|default:
name|bfd_print_symbol_vandf
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|file
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %-5s %s"
argument_list|,
name|symbol
operator|->
name|section
operator|->
name|name
argument_list|,
name|symbol
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|srec_close_and_cleanup
value|_bfd_generic_close_and_cleanup
end_define

begin_define
define|#
directive|define
name|srec_bfd_free_cached_info
value|_bfd_generic_bfd_free_cached_info
end_define

begin_define
define|#
directive|define
name|srec_new_section_hook
value|_bfd_generic_new_section_hook
end_define

begin_define
define|#
directive|define
name|srec_bfd_is_local_label_name
value|bfd_generic_is_local_label_name
end_define

begin_define
define|#
directive|define
name|srec_get_lineno
value|_bfd_nosymbols_get_lineno
end_define

begin_define
define|#
directive|define
name|srec_find_nearest_line
value|_bfd_nosymbols_find_nearest_line
end_define

begin_define
define|#
directive|define
name|srec_make_empty_symbol
value|_bfd_generic_make_empty_symbol
end_define

begin_define
define|#
directive|define
name|srec_bfd_make_debug_symbol
value|_bfd_nosymbols_bfd_make_debug_symbol
end_define

begin_define
define|#
directive|define
name|srec_read_minisymbols
value|_bfd_generic_read_minisymbols
end_define

begin_define
define|#
directive|define
name|srec_minisymbol_to_symbol
value|_bfd_generic_minisymbol_to_symbol
end_define

begin_define
define|#
directive|define
name|srec_get_reloc_upper_bound
define|\
value|((long (*) PARAMS ((bfd *, asection *))) bfd_0l)
end_define

begin_define
define|#
directive|define
name|srec_canonicalize_reloc
define|\
value|((long (*) PARAMS ((bfd *, asection *, arelent **, asymbol **))) bfd_0l)
end_define

begin_define
define|#
directive|define
name|srec_bfd_reloc_type_lookup
value|_bfd_norelocs_bfd_reloc_type_lookup
end_define

begin_define
define|#
directive|define
name|srec_get_section_contents_in_window
define|\
value|_bfd_generic_get_section_contents_in_window
end_define

begin_define
define|#
directive|define
name|srec_bfd_get_relocated_section_contents
define|\
value|bfd_generic_get_relocated_section_contents
end_define

begin_define
define|#
directive|define
name|srec_bfd_relax_section
value|bfd_generic_relax_section
end_define

begin_define
define|#
directive|define
name|srec_bfd_gc_sections
value|bfd_generic_gc_sections
end_define

begin_define
define|#
directive|define
name|srec_bfd_merge_sections
value|bfd_generic_merge_sections
end_define

begin_define
define|#
directive|define
name|srec_bfd_link_hash_table_create
value|_bfd_generic_link_hash_table_create
end_define

begin_define
define|#
directive|define
name|srec_bfd_link_add_symbols
value|_bfd_generic_link_add_symbols
end_define

begin_define
define|#
directive|define
name|srec_bfd_final_link
value|_bfd_generic_final_link
end_define

begin_define
define|#
directive|define
name|srec_bfd_link_split_section
value|_bfd_generic_link_split_section
end_define

begin_decl_stmt
specifier|const
name|bfd_target
name|srec_vec
init|=
block|{
literal|"srec"
block|,
comment|/* name */
name|bfd_target_srec_flavour
block|,
name|BFD_ENDIAN_UNKNOWN
block|,
comment|/* target byte order */
name|BFD_ENDIAN_UNKNOWN
block|,
comment|/* target headers byte order */
operator|(
name|HAS_RELOC
operator||
name|EXEC_P
operator||
comment|/* object flags */
name|HAS_LINENO
operator||
name|HAS_DEBUG
operator||
name|HAS_SYMS
operator||
name|HAS_LOCALS
operator||
name|WP_TEXT
operator||
name|D_PAGED
operator|)
block|,
operator|(
name|SEC_CODE
operator||
name|SEC_DATA
operator||
name|SEC_ROM
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator|)
block|,
comment|/* section flags */
literal|0
block|,
comment|/* leading underscore */
literal|' '
block|,
comment|/* ar_pad_char */
literal|16
block|,
comment|/* ar_max_namelen */
name|bfd_getb64
block|,
name|bfd_getb_signed_64
block|,
name|bfd_putb64
block|,
name|bfd_getb32
block|,
name|bfd_getb_signed_32
block|,
name|bfd_putb32
block|,
name|bfd_getb16
block|,
name|bfd_getb_signed_16
block|,
name|bfd_putb16
block|,
comment|/* data */
name|bfd_getb64
block|,
name|bfd_getb_signed_64
block|,
name|bfd_putb64
block|,
name|bfd_getb32
block|,
name|bfd_getb_signed_32
block|,
name|bfd_putb32
block|,
name|bfd_getb16
block|,
name|bfd_getb_signed_16
block|,
name|bfd_putb16
block|,
comment|/* hdrs */
block|{
name|_bfd_dummy_target
block|,
name|srec_object_p
block|,
comment|/* bfd_check_format */
name|_bfd_dummy_target
block|,
name|_bfd_dummy_target
block|,   }
block|,
block|{
name|bfd_false
block|,
name|srec_mkobject
block|,
name|_bfd_generic_mkarchive
block|,
name|bfd_false
block|,   }
block|,
block|{
comment|/* bfd_write_contents */
name|bfd_false
block|,
name|srec_write_object_contents
block|,
name|_bfd_write_archive_contents
block|,
name|bfd_false
block|,   }
block|,
name|BFD_JUMP_TABLE_GENERIC
argument_list|(
name|srec
argument_list|)
block|,
name|BFD_JUMP_TABLE_COPY
argument_list|(
name|_bfd_generic
argument_list|)
block|,
name|BFD_JUMP_TABLE_CORE
argument_list|(
name|_bfd_nocore
argument_list|)
block|,
name|BFD_JUMP_TABLE_ARCHIVE
argument_list|(
name|_bfd_noarchive
argument_list|)
block|,
name|BFD_JUMP_TABLE_SYMBOLS
argument_list|(
name|srec
argument_list|)
block|,
name|BFD_JUMP_TABLE_RELOCS
argument_list|(
name|srec
argument_list|)
block|,
name|BFD_JUMP_TABLE_WRITE
argument_list|(
name|srec
argument_list|)
block|,
name|BFD_JUMP_TABLE_LINK
argument_list|(
name|srec
argument_list|)
block|,
name|BFD_JUMP_TABLE_DYNAMIC
argument_list|(
name|_bfd_nodynamic
argument_list|)
block|,
name|NULL
block|,
operator|(
name|PTR
operator|)
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|bfd_target
name|symbolsrec_vec
init|=
block|{
literal|"symbolsrec"
block|,
comment|/* name */
name|bfd_target_srec_flavour
block|,
name|BFD_ENDIAN_UNKNOWN
block|,
comment|/* target byte order */
name|BFD_ENDIAN_UNKNOWN
block|,
comment|/* target headers byte order */
operator|(
name|HAS_RELOC
operator||
name|EXEC_P
operator||
comment|/* object flags */
name|HAS_LINENO
operator||
name|HAS_DEBUG
operator||
name|HAS_SYMS
operator||
name|HAS_LOCALS
operator||
name|WP_TEXT
operator||
name|D_PAGED
operator|)
block|,
operator|(
name|SEC_CODE
operator||
name|SEC_DATA
operator||
name|SEC_ROM
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator|)
block|,
comment|/* section flags */
literal|0
block|,
comment|/* leading underscore */
literal|' '
block|,
comment|/* ar_pad_char */
literal|16
block|,
comment|/* ar_max_namelen */
name|bfd_getb64
block|,
name|bfd_getb_signed_64
block|,
name|bfd_putb64
block|,
name|bfd_getb32
block|,
name|bfd_getb_signed_32
block|,
name|bfd_putb32
block|,
name|bfd_getb16
block|,
name|bfd_getb_signed_16
block|,
name|bfd_putb16
block|,
comment|/* data */
name|bfd_getb64
block|,
name|bfd_getb_signed_64
block|,
name|bfd_putb64
block|,
name|bfd_getb32
block|,
name|bfd_getb_signed_32
block|,
name|bfd_putb32
block|,
name|bfd_getb16
block|,
name|bfd_getb_signed_16
block|,
name|bfd_putb16
block|,
comment|/* hdrs */
block|{
name|_bfd_dummy_target
block|,
name|symbolsrec_object_p
block|,
comment|/* bfd_check_format */
name|_bfd_dummy_target
block|,
name|_bfd_dummy_target
block|,   }
block|,
block|{
name|bfd_false
block|,
name|srec_mkobject
block|,
name|_bfd_generic_mkarchive
block|,
name|bfd_false
block|,   }
block|,
block|{
comment|/* bfd_write_contents */
name|bfd_false
block|,
name|symbolsrec_write_object_contents
block|,
name|_bfd_write_archive_contents
block|,
name|bfd_false
block|,   }
block|,
name|BFD_JUMP_TABLE_GENERIC
argument_list|(
name|srec
argument_list|)
block|,
name|BFD_JUMP_TABLE_COPY
argument_list|(
name|_bfd_generic
argument_list|)
block|,
name|BFD_JUMP_TABLE_CORE
argument_list|(
name|_bfd_nocore
argument_list|)
block|,
name|BFD_JUMP_TABLE_ARCHIVE
argument_list|(
name|_bfd_noarchive
argument_list|)
block|,
name|BFD_JUMP_TABLE_SYMBOLS
argument_list|(
name|srec
argument_list|)
block|,
name|BFD_JUMP_TABLE_RELOCS
argument_list|(
name|srec
argument_list|)
block|,
name|BFD_JUMP_TABLE_WRITE
argument_list|(
name|srec
argument_list|)
block|,
name|BFD_JUMP_TABLE_LINK
argument_list|(
name|srec
argument_list|)
block|,
name|BFD_JUMP_TABLE_DYNAMIC
argument_list|(
name|_bfd_nodynamic
argument_list|)
block|,
name|NULL
block|,
operator|(
name|PTR
operator|)
literal|0
block|}
decl_stmt|;
end_decl_stmt

end_unit

