begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD back-end for IBM RS/6000 "XCOFF" files.    Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,    2000, 2001    Free Software Foundation, Inc.    FIXME: Can someone provide a transliteration of this name into ASCII?    Using the following chars caused a compiler warning on HIUX (so I replaced    them with octal escapes), and isn't useful without an understanding of what    character set it is.    Written by Metin G. Ozisik, Mimi Ph\373\364ng-Th\345o V\365,      and John Gilmore.    Archive support from Damon A. Permezel.    Contributed by IBM Corporation and Cygnus Support.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"coff/internal.h"
end_include

begin_include
include|#
directive|include
file|"coff/rs6000.h"
end_include

begin_include
include|#
directive|include
file|"libcoff.h"
end_include

begin_define
define|#
directive|define
name|TARGET_NAME
value|"aixcoff-rs6000"
end_define

begin_define
define|#
directive|define
name|TARGET_SYM
value|rs6000coff_vec
end_define

begin_include
include|#
directive|include
file|"xcoff-target.h"
end_include

begin_comment
comment|/* The main body of code is in coffcode.h.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|normalize_filename
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We use our own tdata type.  Its first field is the COFF tdata type,    so the COFF routines are compatible.  */
end_comment

begin_function
name|boolean
name|_bfd_xcoff_mkobject
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|coff_data_type
modifier|*
name|coff
decl_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|xcoff_obj_data
operator|=
operator|(
operator|(
expr|struct
name|xcoff_tdata
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|xcoff_tdata
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|tdata
operator|.
name|xcoff_obj_data
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|coff
operator|=
name|coff_data
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|coff
operator|->
name|symbols
operator|=
operator|(
name|coff_symbol_type
operator|*
operator|)
name|NULL
expr_stmt|;
name|coff
operator|->
name|conversion_table
operator|=
operator|(
name|unsigned
name|int
operator|*
operator|)
name|NULL
expr_stmt|;
name|coff
operator|->
name|raw_syments
operator|=
operator|(
expr|struct
name|coff_ptr_struct
operator|*
operator|)
name|NULL
expr_stmt|;
name|coff
operator|->
name|relocbase
operator|=
literal|0
expr_stmt|;
name|xcoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|modtype
operator|=
operator|(
literal|'1'
operator|<<
literal|8
operator|)
operator||
literal|'L'
expr_stmt|;
comment|/* We set cputype to -1 to indicate that it has not been      initialized.  */
name|xcoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|cputype
operator|=
operator|-
literal|1
expr_stmt|;
name|xcoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|csects
operator|=
name|NULL
expr_stmt|;
name|xcoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|debug_indices
operator|=
name|NULL
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Copy XCOFF data from one BFD to another.  */
end_comment

begin_function
name|boolean
name|_bfd_xcoff_copy_private_bfd_data
parameter_list|(
name|ibfd
parameter_list|,
name|obfd
parameter_list|)
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|bfd
modifier|*
name|obfd
decl_stmt|;
block|{
name|struct
name|xcoff_tdata
modifier|*
name|ix
decl_stmt|,
modifier|*
name|ox
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
if|if
condition|(
name|ibfd
operator|->
name|xvec
operator|!=
name|obfd
operator|->
name|xvec
condition|)
return|return
name|true
return|;
name|ix
operator|=
name|xcoff_data
argument_list|(
name|ibfd
argument_list|)
expr_stmt|;
name|ox
operator|=
name|xcoff_data
argument_list|(
name|obfd
argument_list|)
expr_stmt|;
name|ox
operator|->
name|full_aouthdr
operator|=
name|ix
operator|->
name|full_aouthdr
expr_stmt|;
name|ox
operator|->
name|toc
operator|=
name|ix
operator|->
name|toc
expr_stmt|;
if|if
condition|(
name|ix
operator|->
name|sntoc
operator|==
literal|0
condition|)
name|ox
operator|->
name|sntoc
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|sec
operator|=
name|coff_section_from_bfd_index
argument_list|(
name|ibfd
argument_list|,
name|ix
operator|->
name|sntoc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
name|ox
operator|->
name|sntoc
operator|=
literal|0
expr_stmt|;
else|else
name|ox
operator|->
name|sntoc
operator|=
name|sec
operator|->
name|output_section
operator|->
name|target_index
expr_stmt|;
block|}
if|if
condition|(
name|ix
operator|->
name|snentry
operator|==
literal|0
condition|)
name|ox
operator|->
name|snentry
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|sec
operator|=
name|coff_section_from_bfd_index
argument_list|(
name|ibfd
argument_list|,
name|ix
operator|->
name|snentry
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
name|ox
operator|->
name|snentry
operator|=
literal|0
expr_stmt|;
else|else
name|ox
operator|->
name|snentry
operator|=
name|sec
operator|->
name|output_section
operator|->
name|target_index
expr_stmt|;
block|}
name|ox
operator|->
name|text_align_power
operator|=
name|ix
operator|->
name|text_align_power
expr_stmt|;
name|ox
operator|->
name|data_align_power
operator|=
name|ix
operator|->
name|data_align_power
expr_stmt|;
name|ox
operator|->
name|modtype
operator|=
name|ix
operator|->
name|modtype
expr_stmt|;
name|ox
operator|->
name|cputype
operator|=
name|ix
operator|->
name|cputype
expr_stmt|;
name|ox
operator|->
name|maxdata
operator|=
name|ix
operator|->
name|maxdata
expr_stmt|;
name|ox
operator|->
name|maxstack
operator|=
name|ix
operator|->
name|maxstack
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* I don't think XCOFF really has a notion of local labels based on    name.  This will mean that ld -X doesn't actually strip anything.    The AIX native linker does not have a -X option, and it ignores the    -x option.  */
end_comment

begin_function
name|boolean
name|_bfd_xcoff_is_local_label_name
parameter_list|(
name|abfd
parameter_list|,
name|name
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|false
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|_bfd_xcoff_swap_sym_in
parameter_list|(
name|abfd
parameter_list|,
name|ext1
parameter_list|,
name|in1
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|ext1
decl_stmt|;
name|PTR
name|in1
decl_stmt|;
block|{
name|SYMENT
modifier|*
name|ext
init|=
operator|(
name|SYMENT
operator|*
operator|)
name|ext1
decl_stmt|;
name|struct
name|internal_syment
modifier|*
name|in
init|=
operator|(
expr|struct
name|internal_syment
operator|*
operator|)
name|in1
decl_stmt|;
if|if
condition|(
name|ext
operator|->
name|e
operator|.
name|e_name
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
name|memcpy
argument_list|(
name|in
operator|->
name|_n
operator|.
name|_n_name
argument_list|,
name|ext
operator|->
name|e
operator|.
name|e_name
argument_list|,
name|SYMNMLEN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|in
operator|->
name|_n
operator|.
name|_n_n
operator|.
name|_n_zeroes
operator|=
literal|0
expr_stmt|;
name|in
operator|->
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|e
operator|.
name|e
operator|.
name|e_offset
argument_list|)
expr_stmt|;
block|}
name|in
operator|->
name|n_value
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|e_value
argument_list|)
expr_stmt|;
name|in
operator|->
name|n_scnum
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|e_scnum
argument_list|)
expr_stmt|;
name|in
operator|->
name|n_type
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|e_type
argument_list|)
expr_stmt|;
name|in
operator|->
name|n_sclass
operator|=
name|bfd_h_get_8
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|e_sclass
argument_list|)
expr_stmt|;
name|in
operator|->
name|n_numaux
operator|=
name|bfd_h_get_8
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|e_numaux
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|unsigned
name|int
name|_bfd_xcoff_swap_sym_out
parameter_list|(
name|abfd
parameter_list|,
name|inp
parameter_list|,
name|extp
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|inp
decl_stmt|;
name|PTR
name|extp
decl_stmt|;
block|{
name|struct
name|internal_syment
modifier|*
name|in
init|=
operator|(
expr|struct
name|internal_syment
operator|*
operator|)
name|inp
decl_stmt|;
name|SYMENT
modifier|*
name|ext
init|=
operator|(
name|SYMENT
operator|*
operator|)
name|extp
decl_stmt|;
if|if
condition|(
name|in
operator|->
name|_n
operator|.
name|_n_name
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
name|memcpy
argument_list|(
name|ext
operator|->
name|e
operator|.
name|e_name
argument_list|,
name|in
operator|->
name|_n
operator|.
name|_n_name
argument_list|,
name|SYMNMLEN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|e
operator|.
name|e
operator|.
name|e_zeroes
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|e
operator|.
name|e
operator|.
name|e_offset
argument_list|)
expr_stmt|;
block|}
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|n_value
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|e_value
argument_list|)
expr_stmt|;
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|n_scnum
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|e_scnum
argument_list|)
expr_stmt|;
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|n_type
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|e_type
argument_list|)
expr_stmt|;
name|bfd_h_put_8
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|n_sclass
argument_list|,
name|ext
operator|->
name|e_sclass
argument_list|)
expr_stmt|;
name|bfd_h_put_8
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|n_numaux
argument_list|,
name|ext
operator|->
name|e_numaux
argument_list|)
expr_stmt|;
return|return
name|bfd_coff_symesz
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|PUTWORD
value|bfd_h_put_32
end_define

begin_define
define|#
directive|define
name|PUTHALF
value|bfd_h_put_16
end_define

begin_define
define|#
directive|define
name|PUTBYTE
value|bfd_h_put_8
end_define

begin_define
define|#
directive|define
name|GETWORD
value|bfd_h_get_32
end_define

begin_define
define|#
directive|define
name|GETHALF
value|bfd_h_get_16
end_define

begin_define
define|#
directive|define
name|GETBYTE
value|bfd_h_get_8
end_define

begin_function
name|void
name|_bfd_xcoff_swap_aux_in
parameter_list|(
name|abfd
parameter_list|,
name|ext1
parameter_list|,
name|type
parameter_list|,
name|class
parameter_list|,
name|indx
parameter_list|,
name|numaux
parameter_list|,
name|in1
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|ext1
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|class
decl_stmt|;
name|int
name|indx
decl_stmt|;
name|int
name|numaux
decl_stmt|;
name|PTR
name|in1
decl_stmt|;
block|{
name|AUXENT
modifier|*
name|ext
init|=
operator|(
name|AUXENT
operator|*
operator|)
name|ext1
decl_stmt|;
name|union
name|internal_auxent
modifier|*
name|in
init|=
operator|(
expr|union
name|internal_auxent
operator|*
operator|)
name|in1
decl_stmt|;
switch|switch
condition|(
name|class
condition|)
block|{
case|case
name|C_FILE
case|:
if|if
condition|(
name|ext
operator|->
name|x_file
operator|.
name|x_fname
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|in
operator|->
name|x_file
operator|.
name|x_n
operator|.
name|x_zeroes
operator|=
literal|0
expr_stmt|;
name|in
operator|->
name|x_file
operator|.
name|x_n
operator|.
name|x_offset
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|x_file
operator|.
name|x_n
operator|.
name|x_offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|numaux
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|indx
operator|==
literal|0
condition|)
name|memcpy
argument_list|(
name|in
operator|->
name|x_file
operator|.
name|x_fname
argument_list|,
name|ext
operator|->
name|x_file
operator|.
name|x_fname
argument_list|,
name|numaux
operator|*
sizeof|sizeof
argument_list|(
name|AUXENT
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|in
operator|->
name|x_file
operator|.
name|x_fname
argument_list|,
name|ext
operator|->
name|x_file
operator|.
name|x_fname
argument_list|,
name|FILNMLEN
argument_list|)
expr_stmt|;
block|}
block|}
goto|goto
name|end
goto|;
comment|/* RS/6000 "csect" auxents */
case|case
name|C_EXT
case|:
case|case
name|C_HIDEXT
case|:
if|if
condition|(
name|indx
operator|+
literal|1
operator|==
name|numaux
condition|)
block|{
name|in
operator|->
name|x_csect
operator|.
name|x_scnlen
operator|.
name|l
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|x_csect
operator|.
name|x_scnlen
argument_list|)
expr_stmt|;
name|in
operator|->
name|x_csect
operator|.
name|x_parmhash
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|x_csect
operator|.
name|x_parmhash
argument_list|)
expr_stmt|;
name|in
operator|->
name|x_csect
operator|.
name|x_snhash
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|x_csect
operator|.
name|x_snhash
argument_list|)
expr_stmt|;
comment|/* We don't have to hack bitfields in x_smtyp because it's 	     defined by shifts-and-ands, which are equivalent on all 	     byte orders.  */
name|in
operator|->
name|x_csect
operator|.
name|x_smtyp
operator|=
name|bfd_h_get_8
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|x_csect
operator|.
name|x_smtyp
argument_list|)
expr_stmt|;
name|in
operator|->
name|x_csect
operator|.
name|x_smclas
operator|=
name|bfd_h_get_8
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|x_csect
operator|.
name|x_smclas
argument_list|)
expr_stmt|;
name|in
operator|->
name|x_csect
operator|.
name|x_stab
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|x_csect
operator|.
name|x_stab
argument_list|)
expr_stmt|;
name|in
operator|->
name|x_csect
operator|.
name|x_snstab
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|x_csect
operator|.
name|x_snstab
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
break|break;
case|case
name|C_STAT
case|:
case|case
name|C_LEAFSTAT
case|:
case|case
name|C_HIDDEN
case|:
if|if
condition|(
name|type
operator|==
name|T_NULL
condition|)
block|{
name|in
operator|->
name|x_scn
operator|.
name|x_scnlen
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|x_scn
operator|.
name|x_scnlen
argument_list|)
expr_stmt|;
name|in
operator|->
name|x_scn
operator|.
name|x_nreloc
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|x_scn
operator|.
name|x_nreloc
argument_list|)
expr_stmt|;
name|in
operator|->
name|x_scn
operator|.
name|x_nlinno
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|x_scn
operator|.
name|x_nlinno
argument_list|)
expr_stmt|;
comment|/* PE defines some extra fields; we zero them out for              safety.  */
name|in
operator|->
name|x_scn
operator|.
name|x_checksum
operator|=
literal|0
expr_stmt|;
name|in
operator|->
name|x_scn
operator|.
name|x_associated
operator|=
literal|0
expr_stmt|;
name|in
operator|->
name|x_scn
operator|.
name|x_comdat
operator|=
literal|0
expr_stmt|;
goto|goto
name|end
goto|;
block|}
break|break;
block|}
name|in
operator|->
name|x_sym
operator|.
name|x_tagndx
operator|.
name|l
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|x_sym
operator|.
name|x_tagndx
argument_list|)
expr_stmt|;
name|in
operator|->
name|x_sym
operator|.
name|x_tvndx
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|x_sym
operator|.
name|x_tvndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|==
name|C_BLOCK
operator|||
name|class
operator|==
name|C_FCN
operator|||
name|ISFCN
argument_list|(
name|type
argument_list|)
operator|||
name|ISTAG
argument_list|(
name|class
argument_list|)
condition|)
block|{
name|in
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_lnnoptr
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_lnnoptr
argument_list|)
expr_stmt|;
name|in
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_endndx
operator|.
name|l
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_endndx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|in
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
index|[
literal|0
index|]
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|in
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
index|[
literal|1
index|]
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|in
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
index|[
literal|2
index|]
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|in
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
index|[
literal|3
index|]
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ISFCN
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|in
operator|->
name|x_sym
operator|.
name|x_misc
operator|.
name|x_fsize
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|x_sym
operator|.
name|x_misc
operator|.
name|x_fsize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|in
operator|->
name|x_sym
operator|.
name|x_misc
operator|.
name|x_lnsz
operator|.
name|x_lnno
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|x_sym
operator|.
name|x_misc
operator|.
name|x_lnsz
operator|.
name|x_lnno
argument_list|)
expr_stmt|;
name|in
operator|->
name|x_sym
operator|.
name|x_misc
operator|.
name|x_lnsz
operator|.
name|x_size
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|x_sym
operator|.
name|x_misc
operator|.
name|x_lnsz
operator|.
name|x_size
argument_list|)
expr_stmt|;
block|}
name|end
label|:
empty_stmt|;
comment|/* the semicolon is because MSVC doesn't like labels at      end of block.  */
block|}
end_function

begin_function
name|unsigned
name|int
name|_bfd_xcoff_swap_aux_out
parameter_list|(
name|abfd
parameter_list|,
name|inp
parameter_list|,
name|type
parameter_list|,
name|class
parameter_list|,
name|indx
parameter_list|,
name|numaux
parameter_list|,
name|extp
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|inp
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|class
decl_stmt|;
name|int
name|indx
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|numaux
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|PTR
name|extp
decl_stmt|;
block|{
name|union
name|internal_auxent
modifier|*
name|in
init|=
operator|(
expr|union
name|internal_auxent
operator|*
operator|)
name|inp
decl_stmt|;
name|AUXENT
modifier|*
name|ext
init|=
operator|(
name|AUXENT
operator|*
operator|)
name|extp
decl_stmt|;
name|memset
argument_list|(
operator|(
name|PTR
operator|)
name|ext
argument_list|,
literal|0
argument_list|,
name|bfd_coff_auxesz
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|class
condition|)
block|{
case|case
name|C_FILE
case|:
if|if
condition|(
name|in
operator|->
name|x_file
operator|.
name|x_fname
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|PUTWORD
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|x_file
operator|.
name|x_n
operator|.
name|x_zeroes
argument_list|)
expr_stmt|;
name|PUTWORD
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_file
operator|.
name|x_n
operator|.
name|x_offset
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|x_file
operator|.
name|x_n
operator|.
name|x_offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|ext
operator|->
name|x_file
operator|.
name|x_fname
argument_list|,
name|in
operator|->
name|x_file
operator|.
name|x_fname
argument_list|,
name|FILNMLEN
argument_list|)
expr_stmt|;
block|}
goto|goto
name|end
goto|;
comment|/* RS/6000 "csect" auxents */
case|case
name|C_EXT
case|:
case|case
name|C_HIDEXT
case|:
if|if
condition|(
name|indx
operator|+
literal|1
operator|==
name|numaux
condition|)
block|{
name|PUTWORD
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_csect
operator|.
name|x_scnlen
operator|.
name|l
argument_list|,
name|ext
operator|->
name|x_csect
operator|.
name|x_scnlen
argument_list|)
expr_stmt|;
name|PUTWORD
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_csect
operator|.
name|x_parmhash
argument_list|,
name|ext
operator|->
name|x_csect
operator|.
name|x_parmhash
argument_list|)
expr_stmt|;
name|PUTHALF
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_csect
operator|.
name|x_snhash
argument_list|,
name|ext
operator|->
name|x_csect
operator|.
name|x_snhash
argument_list|)
expr_stmt|;
comment|/* We don't have to hack bitfields in x_smtyp because it's 	   defined by shifts-and-ands, which are equivalent on all 	   byte orders.  */
name|PUTBYTE
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_csect
operator|.
name|x_smtyp
argument_list|,
name|ext
operator|->
name|x_csect
operator|.
name|x_smtyp
argument_list|)
expr_stmt|;
name|PUTBYTE
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_csect
operator|.
name|x_smclas
argument_list|,
name|ext
operator|->
name|x_csect
operator|.
name|x_smclas
argument_list|)
expr_stmt|;
name|PUTWORD
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_csect
operator|.
name|x_stab
argument_list|,
name|ext
operator|->
name|x_csect
operator|.
name|x_stab
argument_list|)
expr_stmt|;
name|PUTHALF
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_csect
operator|.
name|x_snstab
argument_list|,
name|ext
operator|->
name|x_csect
operator|.
name|x_snstab
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
break|break;
case|case
name|C_STAT
case|:
case|case
name|C_LEAFSTAT
case|:
case|case
name|C_HIDDEN
case|:
if|if
condition|(
name|type
operator|==
name|T_NULL
condition|)
block|{
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_scn
operator|.
name|x_scnlen
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|x_scn
operator|.
name|x_scnlen
argument_list|)
expr_stmt|;
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_scn
operator|.
name|x_nreloc
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|x_scn
operator|.
name|x_nreloc
argument_list|)
expr_stmt|;
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_scn
operator|.
name|x_nlinno
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|x_scn
operator|.
name|x_nlinno
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
break|break;
block|}
name|PUTWORD
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_sym
operator|.
name|x_tagndx
operator|.
name|l
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|x_sym
operator|.
name|x_tagndx
argument_list|)
expr_stmt|;
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_sym
operator|.
name|x_tvndx
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|x_sym
operator|.
name|x_tvndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|==
name|C_BLOCK
operator|||
name|class
operator|==
name|C_FCN
operator|||
name|ISFCN
argument_list|(
name|type
argument_list|)
operator|||
name|ISTAG
argument_list|(
name|class
argument_list|)
condition|)
block|{
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_lnnoptr
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_lnnoptr
argument_list|)
expr_stmt|;
name|PUTWORD
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_endndx
operator|.
name|l
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_endndx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
index|[
literal|0
index|]
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
index|[
literal|1
index|]
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
index|[
literal|2
index|]
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
index|[
literal|3
index|]
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ISFCN
argument_list|(
name|type
argument_list|)
condition|)
name|PUTWORD
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_sym
operator|.
name|x_misc
operator|.
name|x_fsize
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|x_sym
operator|.
name|x_misc
operator|.
name|x_fsize
argument_list|)
expr_stmt|;
else|else
block|{
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_sym
operator|.
name|x_misc
operator|.
name|x_lnsz
operator|.
name|x_lnno
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|x_sym
operator|.
name|x_misc
operator|.
name|x_lnsz
operator|.
name|x_lnno
argument_list|)
expr_stmt|;
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_sym
operator|.
name|x_misc
operator|.
name|x_lnsz
operator|.
name|x_size
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|x_sym
operator|.
name|x_misc
operator|.
name|x_lnsz
operator|.
name|x_size
argument_list|)
expr_stmt|;
block|}
name|end
label|:
return|return
name|bfd_coff_auxesz
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The XCOFF reloc table.  Actually, XCOFF relocations specify the    bitsize and whether they are signed or not, along with a    conventional type.  This table is for the types, which are used for    different algorithms for putting in the reloc.  Many of these    relocs need special_function entries, which I have not written.  */
end_comment

begin_comment
comment|/* In case we're on a 32-bit machine, construct a 64-bit "-1" value    from smaller values.  Start with zero, widen, *then* decrement.  */
end_comment

begin_define
define|#
directive|define
name|MINUS_ONE
value|(((bfd_vma)0) - 1)
end_define

begin_decl_stmt
name|reloc_howto_type
name|xcoff_howto_table
index|[]
init|=
block|{
comment|/* Standard 32 bit relocation.  */
name|HOWTO
argument_list|(
literal|0
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_POS"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 32 bit relocation, but store negative value.  */
name|HOWTO
argument_list|(
literal|1
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
operator|-
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_NEG"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 32 bit PC relative relocation.  */
name|HOWTO
argument_list|(
literal|2
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_REL"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16 bit TOC relative relocation.  */
name|HOWTO
argument_list|(
literal|3
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_TOC"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* I don't really know what this is.  */
name|HOWTO
argument_list|(
literal|4
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_RTB"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* External TOC relative symbol.  */
name|HOWTO
argument_list|(
literal|5
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_GL"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Local TOC relative symbol.  */
name|HOWTO
argument_list|(
literal|6
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_TCL"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
name|EMPTY_HOWTO
argument_list|(
literal|7
argument_list|)
block|,
comment|/* Non modifiable absolute branch.  */
name|HOWTO
argument_list|(
literal|8
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|26
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_BA"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0x3fffffc
argument_list|,
comment|/* src_mask */
literal|0x3fffffc
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
name|EMPTY_HOWTO
argument_list|(
literal|9
argument_list|)
block|,
comment|/* Non modifiable relative branch.  */
name|HOWTO
argument_list|(
literal|0xa
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|26
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_BR"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0x3fffffc
argument_list|,
comment|/* src_mask */
literal|0x3fffffc
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
name|EMPTY_HOWTO
argument_list|(
literal|0xb
argument_list|)
block|,
comment|/* Indirect load.  */
name|HOWTO
argument_list|(
literal|0xc
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_RL"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Load address.  */
name|HOWTO
argument_list|(
literal|0xd
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_RLA"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
name|EMPTY_HOWTO
argument_list|(
literal|0xe
argument_list|)
block|,
comment|/* Non-relocating reference.  */
name|HOWTO
argument_list|(
literal|0xf
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_REF"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
name|EMPTY_HOWTO
argument_list|(
literal|0x10
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|0x11
argument_list|)
block|,
comment|/* TOC relative indirect load.  */
name|HOWTO
argument_list|(
literal|0x12
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_TRL"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* TOC relative load address.  */
name|HOWTO
argument_list|(
literal|0x13
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_TRLA"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Modifiable relative branch.  */
name|HOWTO
argument_list|(
literal|0x14
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_RRTBI"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Modifiable absolute branch.  */
name|HOWTO
argument_list|(
literal|0x15
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_RRTBA"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Modifiable call absolute indirect.  */
name|HOWTO
argument_list|(
literal|0x16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_CAI"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Modifiable call relative.  */
name|HOWTO
argument_list|(
literal|0x17
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_CREL"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Modifiable branch absolute.  */
name|HOWTO
argument_list|(
literal|0x18
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|26
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_RBA"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Modifiable branch absolute.  */
name|HOWTO
argument_list|(
literal|0x19
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_RBAC"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Modifiable branch relative.  */
name|HOWTO
argument_list|(
literal|0x1a
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|26
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_RBR"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Modifiable branch absolute.  */
name|HOWTO
argument_list|(
literal|0x1b
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_RBRC"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
literal|0
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
argument|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
argument|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_POS"
argument_list|,
comment|/* name */
argument|true
argument_list|,
comment|/* partial_inplace */
argument|MINUS_ONE
argument_list|,
comment|/* src_mask */
argument|MINUS_ONE
argument_list|,
comment|/* dst_mask */
argument|false
argument_list|)
comment|/* pcrel_offset */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These are the first two like the above but for 16-bit relocs.  */
end_comment

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|xcoff_howto_table_16
index|[]
init|=
block|{
comment|/* Standard 16 bit relocation.  */
name|HOWTO
argument_list|(
literal|0
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_POS_16"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16 bit relocation, but store negative value.  */
name|HOWTO
argument_list|(
literal|1
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
operator|-
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_NEG_16"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16 bit PC relative relocation.  */
name|HOWTO
argument_list|(
literal|2
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
argument|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
argument|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_REL_16"
argument_list|,
comment|/* name */
argument|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
argument|false
argument_list|)
comment|/* pcrel_offset */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_bfd_xcoff_rtype2howto
parameter_list|(
name|relent
parameter_list|,
name|internal
parameter_list|)
name|arelent
modifier|*
name|relent
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|internal
decl_stmt|;
block|{
name|relent
operator|->
name|howto
operator|=
name|xcoff_howto_table
operator|+
name|internal
operator|->
name|r_type
expr_stmt|;
if|if
condition|(
name|relent
operator|->
name|howto
operator|->
name|bitsize
operator|!=
operator|(
operator|(
name|unsigned
name|int
operator|)
name|internal
operator|->
name|r_size
operator|&
literal|0x1f
operator|)
operator|+
literal|1
operator|&&
operator|(
name|internal
operator|->
name|r_type
operator|<
sizeof|sizeof
argument_list|(
name|xcoff_howto_table_16
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|xcoff_howto_table_16
index|[
literal|0
index|]
argument_list|)
operator|)
condition|)
name|relent
operator|->
name|howto
operator|=
name|xcoff_howto_table_16
operator|+
name|internal
operator|->
name|r_type
expr_stmt|;
comment|/* The r_size field of an XCOFF reloc encodes the bitsize of the      relocation, as well as indicating whether it is signed or not.      Doublecheck that the relocation information gathered from the      type matches this information.  The bitsize is not significant      for R_REF relocs.  */
if|if
condition|(
name|relent
operator|->
name|howto
operator|->
name|dst_mask
operator|!=
literal|0
operator|&&
operator|(
name|relent
operator|->
name|howto
operator|->
name|bitsize
operator|!=
operator|(
operator|(
name|unsigned
name|int
operator|)
name|internal
operator|->
name|r_size
operator|&
literal|0x3f
operator|)
operator|+
literal|1
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|#
directive|if
literal|0
block|if ((internal->r_size& 0x80) != 0       ? (relent->howto->complain_on_overflow != complain_overflow_signed)       : (relent->howto->complain_on_overflow != complain_overflow_bitfield))     abort ();
endif|#
directive|endif
block|}
end_function

begin_function
name|reloc_howto_type
modifier|*
name|_bfd_xcoff_reloc_type_lookup
parameter_list|(
name|abfd
parameter_list|,
name|code
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|BFD_RELOC_PPC_B26
case|:
return|return
operator|&
name|xcoff_howto_table
index|[
literal|0xa
index|]
return|;
case|case
name|BFD_RELOC_PPC_BA26
case|:
return|return
operator|&
name|xcoff_howto_table
index|[
literal|8
index|]
return|;
case|case
name|BFD_RELOC_PPC_TOC16
case|:
return|return
operator|&
name|xcoff_howto_table
index|[
literal|3
index|]
return|;
case|case
name|BFD_RELOC_32
case|:
case|case
name|BFD_RELOC_CTOR
case|:
return|return
operator|&
name|xcoff_howto_table
index|[
literal|0
index|]
return|;
case|case
name|BFD_RELOC_64
case|:
return|return
operator|&
name|xcoff_howto_table
index|[
literal|0x1c
index|]
return|;
default|default:
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* XCOFF archive support.  The original version of this code was by    Damon A. Permezel.  It was enhanced to permit cross support, and    writing archive files, by Ian Lance Taylor, Cygnus Support.     XCOFF uses its own archive format.  Everything is hooked together    with file offset links, so it is possible to rapidly update an    archive in place.  Of course, we don't do that.  An XCOFF archive    has a real file header, not just an ARMAG string.  The structure of    the file header and of each archive header appear below.     An XCOFF archive also has a member table, which is a list of    elements in the archive (you can get that by looking through the    linked list, but you have to read a lot more of the file).  The    member table has a normal archive header with an empty name.  It is    normally (and perhaps must be) the second to last entry in the    archive.  The member table data is almost printable ASCII.  It    starts with a 12 character decimal string which is the number of    entries in the table.  For each entry it has a 12 character decimal    string which is the offset in the archive of that member.  These    entries are followed by a series of null terminated strings which    are the member names for each entry.     Finally, an XCOFF archive has a global symbol table, which is what    we call the armap.  The global symbol table has a normal archive    header with an empty name.  It is normally (and perhaps must be)    the last entry in the archive.  The contents start with a four byte    binary number which is the number of entries.  This is followed by    a that many four byte binary numbers; each is the file offset of an    entry in the archive.  These numbers are followed by a series of    null terminated strings, which are symbol names.     AIX 4.3 introduced a new archive format which can handle larger    files and also 32- and 64-bit objects in the same archive.  The    things said above remain true except that there is now more than    one global symbol table.  The one is used to index 32-bit objects,    the other for 64-bit objects.     The new archives (recognizable by the new ARMAG string) has larger    field lengths so that we cannot really share any code.  Also we have    to take care that we are not generating the new form of archives    on AIX 4.2 or earlier systems.  */
end_comment

begin_comment
comment|/* XCOFF archives use this as a magic string.  Note that both strings    have the same length.  */
end_comment

begin_define
define|#
directive|define
name|XCOFFARMAG
value|"<aiaff>\012"
end_define

begin_define
define|#
directive|define
name|XCOFFARMAGBIG
value|"<bigaf>\012"
end_define

begin_define
define|#
directive|define
name|SXCOFFARMAG
value|8
end_define

begin_comment
comment|/* This terminates an XCOFF archive member name.  */
end_comment

begin_define
define|#
directive|define
name|XCOFFARFMAG
value|"`\012"
end_define

begin_define
define|#
directive|define
name|SXCOFFARFMAG
value|2
end_define

begin_comment
comment|/* XCOFF archives start with this (printable) structure.  */
end_comment

begin_struct
struct|struct
name|xcoff_ar_file_hdr
block|{
comment|/* Magic string.  */
name|char
name|magic
index|[
name|SXCOFFARMAG
index|]
decl_stmt|;
comment|/* Offset of the member table (decimal ASCII string).  */
name|char
name|memoff
index|[
literal|12
index|]
decl_stmt|;
comment|/* Offset of the global symbol table (decimal ASCII string).  */
name|char
name|symoff
index|[
literal|12
index|]
decl_stmt|;
comment|/* Offset of the first member in the archive (decimal ASCII string).  */
name|char
name|firstmemoff
index|[
literal|12
index|]
decl_stmt|;
comment|/* Offset of the last member in the archive (decimal ASCII string).  */
name|char
name|lastmemoff
index|[
literal|12
index|]
decl_stmt|;
comment|/* Offset of the first member on the free list (decimal ASCII      string).  */
name|char
name|freeoff
index|[
literal|12
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|SIZEOF_AR_FILE_HDR
value|(5 * 12 + SXCOFFARMAG)
end_define

begin_comment
comment|/* This is the equivalent data structure for the big archive format.  */
end_comment

begin_struct
struct|struct
name|xcoff_ar_file_hdr_big
block|{
comment|/* Magic string.  */
name|char
name|magic
index|[
name|SXCOFFARMAG
index|]
decl_stmt|;
comment|/* Offset of the member table (decimal ASCII string).  */
name|char
name|memoff
index|[
literal|20
index|]
decl_stmt|;
comment|/* Offset of the global symbol table for 32-bit objects (decimal ASCII      string).  */
name|char
name|symoff
index|[
literal|20
index|]
decl_stmt|;
comment|/* Offset of the global symbol table for 64-bit objects (decimal ASCII      string).  */
name|char
name|symoff64
index|[
literal|20
index|]
decl_stmt|;
comment|/* Offset of the first member in the archive (decimal ASCII string).  */
name|char
name|firstmemoff
index|[
literal|20
index|]
decl_stmt|;
comment|/* Offset of the last member in the archive (decimal ASCII string).  */
name|char
name|lastmemoff
index|[
literal|20
index|]
decl_stmt|;
comment|/* Offset of the first member on the free list (decimal ASCII      string).  */
name|char
name|freeoff
index|[
literal|20
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|SIZEOF_AR_FILE_HDR_BIG
value|(6 * 20 + SXCOFFARMAG)
end_define

begin_comment
comment|/* Each XCOFF archive member starts with this (printable) structure.  */
end_comment

begin_struct
struct|struct
name|xcoff_ar_hdr
block|{
comment|/* File size not including the header (decimal ASCII string).  */
name|char
name|size
index|[
literal|12
index|]
decl_stmt|;
comment|/* File offset of next archive member (decimal ASCII string).  */
name|char
name|nextoff
index|[
literal|12
index|]
decl_stmt|;
comment|/* File offset of previous archive member (decimal ASCII string).  */
name|char
name|prevoff
index|[
literal|12
index|]
decl_stmt|;
comment|/* File mtime (decimal ASCII string).  */
name|char
name|date
index|[
literal|12
index|]
decl_stmt|;
comment|/* File UID (decimal ASCII string).  */
name|char
name|uid
index|[
literal|12
index|]
decl_stmt|;
comment|/* File GID (decimal ASCII string).  */
name|char
name|gid
index|[
literal|12
index|]
decl_stmt|;
comment|/* File mode (octal ASCII string).  */
name|char
name|mode
index|[
literal|12
index|]
decl_stmt|;
comment|/* Length of file name (decimal ASCII string).  */
name|char
name|namlen
index|[
literal|4
index|]
decl_stmt|;
comment|/* This structure is followed by the file name.  The length of the      name is given in the namlen field.  If the length of the name is      odd, the name is followed by a null byte.  The name and optional      null byte are followed by XCOFFARFMAG, which is not included in      namlen.  The contents of the archive member follow; the number of      bytes is given in the size field.  */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|SIZEOF_AR_HDR
value|(7 * 12 + 4)
end_define

begin_comment
comment|/* The equivalent for the big archive format.  */
end_comment

begin_struct
struct|struct
name|xcoff_ar_hdr_big
block|{
comment|/* File size not including the header (decimal ASCII string).  */
name|char
name|size
index|[
literal|20
index|]
decl_stmt|;
comment|/* File offset of next archive member (decimal ASCII string).  */
name|char
name|nextoff
index|[
literal|20
index|]
decl_stmt|;
comment|/* File offset of previous archive member (decimal ASCII string).  */
name|char
name|prevoff
index|[
literal|20
index|]
decl_stmt|;
comment|/* File mtime (decimal ASCII string).  */
name|char
name|date
index|[
literal|12
index|]
decl_stmt|;
comment|/* File UID (decimal ASCII string).  */
name|char
name|uid
index|[
literal|12
index|]
decl_stmt|;
comment|/* File GID (decimal ASCII string).  */
name|char
name|gid
index|[
literal|12
index|]
decl_stmt|;
comment|/* File mode (octal ASCII string).  */
name|char
name|mode
index|[
literal|12
index|]
decl_stmt|;
comment|/* Length of file name (decimal ASCII string).  */
name|char
name|namlen
index|[
literal|4
index|]
decl_stmt|;
comment|/* This structure is followed by the file name.  The length of the      name is given in the namlen field.  If the length of the name is      odd, the name is followed by a null byte.  The name and optional      null byte are followed by XCOFFARFMAG, which is not included in      namlen.  The contents of the archive member follow; the number of      bytes is given in the size field.  */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|SIZEOF_AR_HDR_BIG
value|(3 * 20 + 4 * 12 + 4)
end_define

begin_comment
comment|/* We often have to distinguish between the old and big file format.    Make it a bit cleaner.  We can use `xcoff_ardata' here because the    `hdr' member has the same size and position in both formats.  */
end_comment

begin_define
define|#
directive|define
name|xcoff_big_format_p
parameter_list|(
name|abfd
parameter_list|)
define|\
value|(xcoff_ardata (abfd)->magic[1] == 'b')
end_define

begin_comment
comment|/* We store a copy of the xcoff_ar_file_hdr in the tdata field of the    artdata structure.  Similar for the big archive.  */
end_comment

begin_define
define|#
directive|define
name|xcoff_ardata
parameter_list|(
name|abfd
parameter_list|)
define|\
value|((struct xcoff_ar_file_hdr *) bfd_ardata (abfd)->tdata)
end_define

begin_define
define|#
directive|define
name|xcoff_ardata_big
parameter_list|(
name|abfd
parameter_list|)
define|\
value|((struct xcoff_ar_file_hdr_big *) bfd_ardata (abfd)->tdata)
end_define

begin_comment
comment|/* We store a copy of the xcoff_ar_hdr in the arelt_data field of an    archive element.  Similar for the big archive.  */
end_comment

begin_define
define|#
directive|define
name|arch_eltdata
parameter_list|(
name|bfd
parameter_list|)
value|((struct areltdata *) ((bfd)->arelt_data))
end_define

begin_define
define|#
directive|define
name|arch_xhdr
parameter_list|(
name|bfd
parameter_list|)
define|\
value|((struct xcoff_ar_hdr *) arch_eltdata (bfd)->arch_header)
end_define

begin_define
define|#
directive|define
name|arch_xhdr_big
parameter_list|(
name|bfd
parameter_list|)
define|\
value|((struct xcoff_ar_hdr_big *) arch_eltdata (bfd)->arch_header)
end_define

begin_comment
comment|/* Read in the armap of an XCOFF archive.  */
end_comment

begin_function
name|boolean
name|_bfd_xcoff_slurp_armap
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|file_ptr
name|off
decl_stmt|;
name|size_t
name|namlen
decl_stmt|;
name|bfd_size_type
name|sz
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|,
modifier|*
name|cend
decl_stmt|;
name|bfd_vma
name|c
decl_stmt|,
name|i
decl_stmt|;
name|carsym
modifier|*
name|arsym
decl_stmt|;
name|bfd_byte
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|xcoff_ardata
argument_list|(
name|abfd
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|bfd_has_map
argument_list|(
name|abfd
argument_list|)
operator|=
name|false
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
operator|!
name|xcoff_big_format_p
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
comment|/* This is for the old format.  */
name|struct
name|xcoff_ar_hdr
name|hdr
decl_stmt|;
name|off
operator|=
name|strtol
argument_list|(
name|xcoff_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symoff
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|off
operator|==
literal|0
condition|)
block|{
name|bfd_has_map
argument_list|(
name|abfd
argument_list|)
operator|=
name|false
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|off
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
comment|/* The symbol table starts with a normal archive header.  */
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|hdr
argument_list|,
name|SIZEOF_AR_HDR
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|SIZEOF_AR_HDR
condition|)
return|return
name|false
return|;
comment|/* Skip the name (normally empty).  */
name|namlen
operator|=
name|strtol
argument_list|(
name|hdr
operator|.
name|namlen
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
operator|(
name|namlen
operator|+
literal|1
operator|)
operator|&
operator|~
literal|1
operator|)
operator|+
name|SXCOFFARFMAG
argument_list|,
name|SEEK_CUR
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
name|sz
operator|=
name|strtol
argument_list|(
name|hdr
operator|.
name|size
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* Read in the entire symbol table.  */
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|contents
argument_list|,
literal|1
argument_list|,
name|sz
argument_list|,
name|abfd
argument_list|)
operator|!=
name|sz
condition|)
return|return
name|false
return|;
comment|/* The symbol table starts with a four byte count.  */
name|c
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|contents
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|*
literal|4
operator|>=
name|sz
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symdefs
operator|=
operator|(
operator|(
name|carsym
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|c
operator|*
sizeof|sizeof
argument_list|(
name|carsym
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symdefs
operator|==
name|NULL
condition|)
return|return
name|false
return|;
comment|/* After the count comes a list of four byte file offsets.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|arsym
operator|=
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symdefs
operator|,
name|p
operator|=
name|contents
operator|+
literal|4
init|;
name|i
operator|<
name|c
condition|;
operator|++
name|i
operator|,
operator|++
name|arsym
operator|,
name|p
operator|+=
literal|4
control|)
name|arsym
operator|->
name|file_offset
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This is for the new format.  */
name|struct
name|xcoff_ar_hdr_big
name|hdr
decl_stmt|;
name|off
operator|=
name|strtol
argument_list|(
name|xcoff_ardata_big
argument_list|(
name|abfd
argument_list|)
operator|->
name|symoff
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|off
operator|==
literal|0
condition|)
block|{
name|bfd_has_map
argument_list|(
name|abfd
argument_list|)
operator|=
name|false
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|off
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
comment|/* The symbol table starts with a normal archive header.  */
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|hdr
argument_list|,
name|SIZEOF_AR_HDR_BIG
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|SIZEOF_AR_HDR_BIG
condition|)
return|return
name|false
return|;
comment|/* Skip the name (normally empty).  */
name|namlen
operator|=
name|strtol
argument_list|(
name|hdr
operator|.
name|namlen
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
operator|(
name|namlen
operator|+
literal|1
operator|)
operator|&
operator|~
literal|1
operator|)
operator|+
name|SXCOFFARFMAG
argument_list|,
name|SEEK_CUR
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
comment|/* XXX This actually has to be a call to strtoll (at least on 32-bit 	 machines) since the field width is 20 and there numbers with more 	 than 32 bits can be represented.  */
name|sz
operator|=
name|strtol
argument_list|(
name|hdr
operator|.
name|size
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* Read in the entire symbol table.  */
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|contents
argument_list|,
literal|1
argument_list|,
name|sz
argument_list|,
name|abfd
argument_list|)
operator|!=
name|sz
condition|)
return|return
name|false
return|;
comment|/* The symbol table starts with an eight byte count.  */
name|c
operator|=
name|bfd_h_get_64
argument_list|(
name|abfd
argument_list|,
name|contents
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|*
literal|8
operator|>=
name|sz
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symdefs
operator|=
operator|(
operator|(
name|carsym
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|c
operator|*
sizeof|sizeof
argument_list|(
name|carsym
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symdefs
operator|==
name|NULL
condition|)
return|return
name|false
return|;
comment|/* After the count comes a list of eight byte file offsets.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|arsym
operator|=
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symdefs
operator|,
name|p
operator|=
name|contents
operator|+
literal|8
init|;
name|i
operator|<
name|c
condition|;
operator|++
name|i
operator|,
operator|++
name|arsym
operator|,
name|p
operator|+=
literal|8
control|)
name|arsym
operator|->
name|file_offset
operator|=
name|bfd_h_get_64
argument_list|(
name|abfd
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* After the file offsets come null terminated symbol names.  */
name|cend
operator|=
name|contents
operator|+
name|sz
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|arsym
operator|=
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symdefs
init|;
name|i
operator|<
name|c
condition|;
operator|++
name|i
operator|,
operator|++
name|arsym
operator|,
name|p
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
operator|+
literal|1
control|)
block|{
if|if
condition|(
name|p
operator|>=
name|cend
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|arsym
operator|->
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|p
expr_stmt|;
block|}
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symdef_count
operator|=
name|c
expr_stmt|;
name|bfd_has_map
argument_list|(
name|abfd
argument_list|)
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* See if this is an XCOFF archive.  */
end_comment

begin_function
specifier|const
name|bfd_target
modifier|*
name|_bfd_xcoff_archive_p
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|char
name|magic
index|[
name|SXCOFFARMAG
index|]
decl_stmt|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|magic
argument_list|,
name|SXCOFFARMAG
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|SXCOFFARMAG
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_system_call
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|magic
argument_list|,
name|XCOFFARMAG
argument_list|,
name|SXCOFFARMAG
argument_list|)
operator|!=
literal|0
operator|&&
name|strncmp
argument_list|(
name|magic
argument_list|,
name|XCOFFARMAGBIG
argument_list|,
name|SXCOFFARMAG
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* We are setting bfd_ardata(abfd) here, but since bfd_ardata      involves a cast, we can't do it as the left operand of      assignment.  */
name|abfd
operator|->
name|tdata
operator|.
name|aout_ar_data
operator|=
operator|(
expr|struct
name|artdata
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|artdata
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|==
operator|(
expr|struct
name|artdata
operator|*
operator|)
name|NULL
condition|)
return|return
name|NULL
return|;
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|cache
operator|=
name|NULL
expr_stmt|;
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|archive_head
operator|=
name|NULL
expr_stmt|;
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symdefs
operator|=
name|NULL
expr_stmt|;
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|extended_names
operator|=
name|NULL
expr_stmt|;
comment|/* Now handle the two formats.  */
if|if
condition|(
name|magic
index|[
literal|1
index|]
operator|!=
literal|'b'
condition|)
block|{
comment|/* This is the old format.  */
name|struct
name|xcoff_ar_file_hdr
name|hdr
decl_stmt|;
comment|/* Copy over the magic string.  */
name|memcpy
argument_list|(
name|hdr
operator|.
name|magic
argument_list|,
name|magic
argument_list|,
name|SXCOFFARMAG
argument_list|)
expr_stmt|;
comment|/* Now read the rest of the file header.  */
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|hdr
operator|.
name|memoff
argument_list|,
name|SIZEOF_AR_FILE_HDR
operator|-
name|SXCOFFARMAG
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|SIZEOF_AR_FILE_HDR
operator|-
name|SXCOFFARMAG
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_system_call
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|first_file_filepos
operator|=
name|strtol
argument_list|(
name|hdr
operator|.
name|firstmemoff
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|tdata
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|SIZEOF_AR_FILE_HDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|tdata
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|memcpy
argument_list|(
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|tdata
argument_list|,
operator|&
name|hdr
argument_list|,
name|SIZEOF_AR_FILE_HDR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This is the new format.  */
name|struct
name|xcoff_ar_file_hdr_big
name|hdr
decl_stmt|;
comment|/* Copy over the magic string.  */
name|memcpy
argument_list|(
name|hdr
operator|.
name|magic
argument_list|,
name|magic
argument_list|,
name|SXCOFFARMAG
argument_list|)
expr_stmt|;
comment|/* Now read the rest of the file header.  */
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|hdr
operator|.
name|memoff
argument_list|,
name|SIZEOF_AR_FILE_HDR_BIG
operator|-
name|SXCOFFARMAG
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|SIZEOF_AR_FILE_HDR_BIG
operator|-
name|SXCOFFARMAG
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_system_call
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* XXX This actually has to be a call to strtoll (at least on 32-bit 	 machines) since the field width is 20 and there numbers with more 	 than 32 bits can be represented.  */
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|first_file_filepos
operator|=
name|strtol
argument_list|(
name|hdr
operator|.
name|firstmemoff
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|tdata
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|SIZEOF_AR_FILE_HDR_BIG
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|tdata
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|memcpy
argument_list|(
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|tdata
argument_list|,
operator|&
name|hdr
argument_list|,
name|SIZEOF_AR_FILE_HDR_BIG
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|_bfd_xcoff_slurp_armap
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|aout_ar_data
operator|=
operator|(
expr|struct
name|artdata
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|abfd
operator|->
name|xvec
return|;
block|}
end_function

begin_comment
comment|/* Read the archive header in an XCOFF archive.  */
end_comment

begin_function
name|PTR
name|_bfd_xcoff_read_ar_hdr
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|size_t
name|namlen
decl_stmt|;
name|struct
name|areltdata
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
operator|(
expr|struct
name|areltdata
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|areltdata
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|xcoff_big_format_p
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|struct
name|xcoff_ar_hdr
name|hdr
decl_stmt|;
name|struct
name|xcoff_ar_hdr
modifier|*
name|hdrp
decl_stmt|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|hdr
argument_list|,
name|SIZEOF_AR_HDR
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|SIZEOF_AR_HDR
condition|)
block|{
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|namlen
operator|=
name|strtol
argument_list|(
name|hdr
operator|.
name|namlen
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|hdrp
operator|=
operator|(
expr|struct
name|xcoff_ar_hdr
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|SIZEOF_AR_HDR
operator|+
name|namlen
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdrp
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memcpy
argument_list|(
name|hdrp
argument_list|,
operator|&
name|hdr
argument_list|,
name|SIZEOF_AR_HDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hdrp
operator|+
name|SIZEOF_AR_HDR
argument_list|,
literal|1
argument_list|,
name|namlen
argument_list|,
name|abfd
argument_list|)
operator|!=
name|namlen
condition|)
block|{
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|(
operator|(
name|char
operator|*
operator|)
name|hdrp
operator|)
index|[
name|SIZEOF_AR_HDR
operator|+
name|namlen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ret
operator|->
name|arch_header
operator|=
operator|(
name|char
operator|*
operator|)
name|hdrp
expr_stmt|;
name|ret
operator|->
name|parsed_size
operator|=
name|strtol
argument_list|(
name|hdr
operator|.
name|size
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|ret
operator|->
name|filename
operator|=
operator|(
name|char
operator|*
operator|)
name|hdrp
operator|+
name|SIZEOF_AR_HDR
expr_stmt|;
block|}
else|else
block|{
name|struct
name|xcoff_ar_hdr_big
name|hdr
decl_stmt|;
name|struct
name|xcoff_ar_hdr_big
modifier|*
name|hdrp
decl_stmt|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|hdr
argument_list|,
name|SIZEOF_AR_HDR_BIG
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|SIZEOF_AR_HDR_BIG
condition|)
block|{
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|namlen
operator|=
name|strtol
argument_list|(
name|hdr
operator|.
name|namlen
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|hdrp
operator|=
operator|(
expr|struct
name|xcoff_ar_hdr_big
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|SIZEOF_AR_HDR_BIG
operator|+
name|namlen
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdrp
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memcpy
argument_list|(
name|hdrp
argument_list|,
operator|&
name|hdr
argument_list|,
name|SIZEOF_AR_HDR_BIG
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hdrp
operator|+
name|SIZEOF_AR_HDR_BIG
argument_list|,
literal|1
argument_list|,
name|namlen
argument_list|,
name|abfd
argument_list|)
operator|!=
name|namlen
condition|)
block|{
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|(
operator|(
name|char
operator|*
operator|)
name|hdrp
operator|)
index|[
name|SIZEOF_AR_HDR_BIG
operator|+
name|namlen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ret
operator|->
name|arch_header
operator|=
operator|(
name|char
operator|*
operator|)
name|hdrp
expr_stmt|;
comment|/* XXX This actually has to be a call to strtoll (at least on 32-bit 	 machines) since the field width is 20 and there numbers with more 	 than 32 bits can be represented.  */
name|ret
operator|->
name|parsed_size
operator|=
name|strtol
argument_list|(
name|hdr
operator|.
name|size
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|ret
operator|->
name|filename
operator|=
operator|(
name|char
operator|*
operator|)
name|hdrp
operator|+
name|SIZEOF_AR_HDR_BIG
expr_stmt|;
block|}
comment|/* Skip over the XCOFFARFMAG at the end of the file name.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|namlen
operator|&
literal|1
operator|)
operator|+
name|SXCOFFARFMAG
argument_list|,
name|SEEK_CUR
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|NULL
return|;
return|return
operator|(
name|PTR
operator|)
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Open the next element in an XCOFF archive.  */
end_comment

begin_function
name|bfd
modifier|*
name|_bfd_xcoff_openr_next_archived_file
parameter_list|(
name|archive
parameter_list|,
name|last_file
parameter_list|)
name|bfd
modifier|*
name|archive
decl_stmt|;
name|bfd
modifier|*
name|last_file
decl_stmt|;
block|{
name|file_ptr
name|filestart
decl_stmt|;
if|if
condition|(
name|xcoff_ardata
argument_list|(
name|archive
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|xcoff_big_format_p
argument_list|(
name|archive
argument_list|)
condition|)
block|{
if|if
condition|(
name|last_file
operator|==
name|NULL
condition|)
name|filestart
operator|=
name|bfd_ardata
argument_list|(
name|archive
argument_list|)
operator|->
name|first_file_filepos
expr_stmt|;
else|else
name|filestart
operator|=
name|strtol
argument_list|(
name|arch_xhdr
argument_list|(
name|last_file
argument_list|)
operator|->
name|nextoff
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|filestart
operator|==
literal|0
operator|||
name|filestart
operator|==
name|strtol
argument_list|(
name|xcoff_ardata
argument_list|(
name|archive
argument_list|)
operator|->
name|memoff
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
operator|||
name|filestart
operator|==
name|strtol
argument_list|(
name|xcoff_ardata
argument_list|(
name|archive
argument_list|)
operator|->
name|symoff
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_more_archived_files
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|last_file
operator|==
name|NULL
condition|)
name|filestart
operator|=
name|bfd_ardata
argument_list|(
name|archive
argument_list|)
operator|->
name|first_file_filepos
expr_stmt|;
else|else
comment|/* XXX These actually have to be a calls to strtoll (at least 	   on 32-bit machines) since the fields's width is 20 and 	   there numbers with more than 32 bits can be represented.  */
name|filestart
operator|=
name|strtol
argument_list|(
name|arch_xhdr_big
argument_list|(
name|last_file
argument_list|)
operator|->
name|nextoff
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* XXX These actually have to be calls to strtoll (at least on 32-bit 	 machines) since the fields's width is 20 and there numbers with more 	 than 32 bits can be represented.  */
if|if
condition|(
name|filestart
operator|==
literal|0
operator|||
name|filestart
operator|==
name|strtol
argument_list|(
name|xcoff_ardata_big
argument_list|(
name|archive
argument_list|)
operator|->
name|memoff
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
operator|||
name|filestart
operator|==
name|strtol
argument_list|(
name|xcoff_ardata_big
argument_list|(
name|archive
argument_list|)
operator|->
name|symoff
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_more_archived_files
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
return|return
name|_bfd_get_elt_at_filepos
argument_list|(
name|archive
argument_list|,
name|filestart
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Stat an element in an XCOFF archive.  */
end_comment

begin_function
name|int
name|_bfd_xcoff_generic_stat_arch_elt
parameter_list|(
name|abfd
parameter_list|,
name|s
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|stat
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|abfd
operator|->
name|arelt_data
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|xcoff_big_format_p
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|struct
name|xcoff_ar_hdr
modifier|*
name|hdrp
init|=
name|arch_xhdr
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|s
operator|->
name|st_mtime
operator|=
name|strtol
argument_list|(
name|hdrp
operator|->
name|date
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|s
operator|->
name|st_uid
operator|=
name|strtol
argument_list|(
name|hdrp
operator|->
name|uid
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|s
operator|->
name|st_gid
operator|=
name|strtol
argument_list|(
name|hdrp
operator|->
name|gid
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|s
operator|->
name|st_mode
operator|=
name|strtol
argument_list|(
name|hdrp
operator|->
name|mode
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|s
operator|->
name|st_size
operator|=
name|arch_eltdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|parsed_size
expr_stmt|;
block|}
else|else
block|{
name|struct
name|xcoff_ar_hdr_big
modifier|*
name|hdrp
init|=
name|arch_xhdr_big
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|s
operator|->
name|st_mtime
operator|=
name|strtol
argument_list|(
name|hdrp
operator|->
name|date
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|s
operator|->
name|st_uid
operator|=
name|strtol
argument_list|(
name|hdrp
operator|->
name|uid
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|s
operator|->
name|st_gid
operator|=
name|strtol
argument_list|(
name|hdrp
operator|->
name|gid
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|s
operator|->
name|st_mode
operator|=
name|strtol
argument_list|(
name|hdrp
operator|->
name|mode
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|s
operator|->
name|st_size
operator|=
name|arch_eltdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|parsed_size
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Normalize a file name for inclusion in an archive.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|normalize_filename
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|file
operator|=
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|filename
operator|=
name|strrchr
argument_list|(
name|file
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|filename
operator|!=
name|NULL
condition|)
name|filename
operator|++
expr_stmt|;
else|else
name|filename
operator|=
name|file
expr_stmt|;
return|return
name|filename
return|;
block|}
end_function

begin_comment
comment|/* Write out an XCOFF armap.  */
end_comment

begin_function
specifier|static
name|boolean
name|xcoff_write_armap_old
parameter_list|(
name|abfd
parameter_list|,
name|elength
parameter_list|,
name|map
parameter_list|,
name|orl_count
parameter_list|,
name|stridx
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|unsigned
name|int
name|elength
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|orl
modifier|*
name|map
decl_stmt|;
name|unsigned
name|int
name|orl_count
decl_stmt|;
name|int
name|stridx
decl_stmt|;
block|{
name|struct
name|xcoff_ar_hdr
name|hdr
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|bfd
modifier|*
name|sub
decl_stmt|;
name|file_ptr
name|fileoff
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|memset
argument_list|(
operator|&
name|hdr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|hdr
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|hdr
operator|.
name|size
argument_list|,
literal|"%ld"
argument_list|,
call|(
name|long
call|)
argument_list|(
literal|4
operator|+
name|orl_count
operator|*
literal|4
operator|+
name|stridx
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|hdr
operator|.
name|nextoff
argument_list|,
literal|"%d"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|hdr
operator|.
name|prevoff
argument_list|,
name|xcoff_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|memoff
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|hdr
operator|.
name|date
argument_list|,
literal|"%d"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|hdr
operator|.
name|uid
argument_list|,
literal|"%d"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|hdr
operator|.
name|gid
argument_list|,
literal|"%d"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|hdr
operator|.
name|mode
argument_list|,
literal|"%d"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|hdr
operator|.
name|namlen
argument_list|,
literal|"%d"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* We need spaces, not null bytes, in the header.  */
for|for
control|(
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|hdr
init|;
name|p
operator|<
operator|(
name|char
operator|*
operator|)
operator|&
name|hdr
operator|+
name|SIZEOF_AR_HDR
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
operator|*
name|p
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|hdr
argument_list|,
name|SIZEOF_AR_HDR
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|SIZEOF_AR_HDR
operator|||
name|bfd_write
argument_list|(
name|XCOFFARFMAG
argument_list|,
literal|1
argument_list|,
name|SXCOFFARFMAG
argument_list|,
name|abfd
argument_list|)
operator|!=
name|SXCOFFARFMAG
condition|)
return|return
name|false
return|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|orl_count
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
condition|)
return|return
name|false
return|;
name|sub
operator|=
name|abfd
operator|->
name|archive_head
expr_stmt|;
name|fileoff
operator|=
name|SIZEOF_AR_FILE_HDR
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|sub
operator|!=
name|NULL
operator|&&
name|i
operator|<
name|orl_count
condition|)
block|{
name|size_t
name|namlen
decl_stmt|;
while|while
condition|(
operator|(
operator|(
name|bfd
operator|*
operator|)
operator|(
name|map
index|[
name|i
index|]
operator|)
operator|.
name|pos
operator|)
operator|==
name|sub
condition|)
block|{
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|fileoff
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
condition|)
return|return
name|false
return|;
operator|++
name|i
expr_stmt|;
block|}
name|namlen
operator|=
name|strlen
argument_list|(
name|normalize_filename
argument_list|(
name|sub
argument_list|)
argument_list|)
expr_stmt|;
name|namlen
operator|=
operator|(
name|namlen
operator|+
literal|1
operator|)
operator|&
operator|~
literal|1
expr_stmt|;
name|fileoff
operator|+=
operator|(
name|SIZEOF_AR_HDR
operator|+
name|namlen
operator|+
name|SXCOFFARFMAG
operator|+
name|arelt_size
argument_list|(
name|sub
argument_list|)
operator|)
expr_stmt|;
name|fileoff
operator|=
operator|(
name|fileoff
operator|+
literal|1
operator|)
operator|&
operator|~
literal|1
expr_stmt|;
name|sub
operator|=
name|sub
operator|->
name|next
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|orl_count
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|size_t
name|namlen
decl_stmt|;
name|name
operator|=
operator|*
name|map
index|[
name|i
index|]
operator|.
name|name
expr_stmt|;
name|namlen
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
name|name
argument_list|,
literal|1
argument_list|,
name|namlen
operator|+
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|namlen
operator|+
literal|1
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
operator|(
name|stridx
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
name|char
name|b
decl_stmt|;
name|b
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|&
name|b
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|1
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Write a single armap in the big format.  */
end_comment

begin_function
specifier|static
name|boolean
name|xcoff_write_one_armap_big
parameter_list|(
name|abfd
parameter_list|,
name|map
parameter_list|,
name|orl_count
parameter_list|,
name|orl_ccount
parameter_list|,
name|stridx
parameter_list|,
name|bits64
parameter_list|,
name|prevoff
parameter_list|,
name|nextoff
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|orl
modifier|*
name|map
decl_stmt|;
name|unsigned
name|int
name|orl_count
decl_stmt|;
name|unsigned
name|int
name|orl_ccount
decl_stmt|;
name|unsigned
name|int
name|stridx
decl_stmt|;
name|int
name|bits64
decl_stmt|;
specifier|const
name|char
modifier|*
name|prevoff
decl_stmt|;
name|char
modifier|*
name|nextoff
decl_stmt|;
block|{
name|struct
name|xcoff_ar_hdr_big
name|hdr
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
specifier|const
name|bfd_arch_info_type
modifier|*
name|arch_info
init|=
name|NULL
decl_stmt|;
name|bfd
modifier|*
name|sub
decl_stmt|;
name|file_ptr
name|fileoff
decl_stmt|;
name|bfd
modifier|*
name|object_bfd
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|memset
argument_list|(
operator|&
name|hdr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|hdr
argument_list|)
expr_stmt|;
comment|/* XXX This call actually should use %lld (at least on 32-bit      machines) since the fields's width is 20 and there numbers with      more than 32 bits can be represented.  */
name|sprintf
argument_list|(
name|hdr
operator|.
name|size
argument_list|,
literal|"%ld"
argument_list|,
call|(
name|long
call|)
argument_list|(
literal|4
operator|+
name|orl_ccount
operator|*
literal|4
operator|+
name|stridx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bits64
condition|)
name|sprintf
argument_list|(
name|hdr
operator|.
name|nextoff
argument_list|,
literal|"%d"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|hdr
operator|.
name|nextoff
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|strtol
argument_list|(
name|prevoff
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
operator|+
literal|4
operator|+
name|orl_ccount
operator|*
literal|4
operator|+
name|stridx
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|hdr
operator|.
name|prevoff
argument_list|,
name|prevoff
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
operator|.
name|prevoff
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|hdr
operator|.
name|date
argument_list|,
literal|"%d"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|hdr
operator|.
name|uid
argument_list|,
literal|"%d"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|hdr
operator|.
name|gid
argument_list|,
literal|"%d"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|hdr
operator|.
name|mode
argument_list|,
literal|"%d"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|hdr
operator|.
name|namlen
argument_list|,
literal|"%d"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* We need spaces, not null bytes, in the header.  */
for|for
control|(
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|hdr
init|;
name|p
operator|<
operator|(
name|char
operator|*
operator|)
operator|&
name|hdr
operator|+
name|SIZEOF_AR_HDR_BIG
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
operator|*
name|p
operator|=
literal|' '
expr_stmt|;
name|memcpy
argument_list|(
name|nextoff
argument_list|,
name|hdr
operator|.
name|nextoff
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
operator|.
name|nextoff
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|hdr
argument_list|,
name|SIZEOF_AR_HDR_BIG
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|SIZEOF_AR_HDR_BIG
operator|||
name|bfd_write
argument_list|(
name|XCOFFARFMAG
argument_list|,
literal|1
argument_list|,
name|SXCOFFARFMAG
argument_list|,
name|abfd
argument_list|)
operator|!=
name|SXCOFFARFMAG
condition|)
return|return
name|false
return|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|orl_ccount
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
condition|)
return|return
name|false
return|;
name|sub
operator|=
name|abfd
operator|->
name|archive_head
expr_stmt|;
name|fileoff
operator|=
name|SIZEOF_AR_FILE_HDR_BIG
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|sub
operator|!=
name|NULL
operator|&&
name|i
operator|<
name|orl_count
condition|)
block|{
name|size_t
name|namlen
decl_stmt|;
if|if
condition|(
operator|(
name|bfd_arch_bits_per_address
argument_list|(
operator|(
name|bfd
operator|*
operator|)
name|map
index|[
name|i
index|]
operator|.
name|pos
argument_list|)
operator|==
literal|64
operator|)
operator|==
name|bits64
condition|)
while|while
condition|(
operator|(
operator|(
name|bfd
operator|*
operator|)
operator|(
name|map
index|[
name|i
index|]
operator|)
operator|.
name|pos
operator|)
operator|==
name|sub
condition|)
block|{
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|fileoff
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
condition|)
return|return
name|false
return|;
name|i
operator|++
expr_stmt|;
block|}
else|else
while|while
condition|(
operator|(
operator|(
name|bfd
operator|*
operator|)
operator|(
name|map
index|[
name|i
index|]
operator|)
operator|.
name|pos
operator|)
operator|==
name|sub
condition|)
name|i
operator|++
expr_stmt|;
name|namlen
operator|=
name|strlen
argument_list|(
name|normalize_filename
argument_list|(
name|sub
argument_list|)
argument_list|)
expr_stmt|;
name|namlen
operator|=
operator|(
name|namlen
operator|+
literal|1
operator|)
operator|&
operator|~
literal|1
expr_stmt|;
name|fileoff
operator|+=
operator|(
name|SIZEOF_AR_HDR_BIG
operator|+
name|namlen
operator|+
name|SXCOFFARFMAG
operator|+
name|arelt_size
argument_list|(
name|sub
argument_list|)
operator|)
expr_stmt|;
name|fileoff
operator|=
operator|(
name|fileoff
operator|+
literal|1
operator|)
operator|&
operator|~
literal|1
expr_stmt|;
name|sub
operator|=
name|sub
operator|->
name|next
expr_stmt|;
block|}
name|object_bfd
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|orl_count
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|size_t
name|namlen
decl_stmt|;
name|bfd
modifier|*
name|ob
init|=
operator|(
name|bfd
operator|*
operator|)
name|map
index|[
name|i
index|]
operator|.
name|pos
decl_stmt|;
if|if
condition|(
name|ob
operator|!=
name|object_bfd
condition|)
name|arch_info
operator|=
name|bfd_get_arch_info
argument_list|(
name|ob
argument_list|)
expr_stmt|;
if|if
condition|(
name|arch_info
operator|&&
operator|(
name|arch_info
operator|->
name|bits_per_address
operator|==
literal|64
operator|)
operator|!=
name|bits64
condition|)
continue|continue;
name|name
operator|=
operator|*
name|map
index|[
name|i
index|]
operator|.
name|name
expr_stmt|;
name|namlen
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
name|name
argument_list|,
literal|1
argument_list|,
name|namlen
operator|+
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|namlen
operator|+
literal|1
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
operator|(
name|stridx
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
name|char
name|b
decl_stmt|;
name|b
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|&
name|b
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|1
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|xcoff_write_armap_big
parameter_list|(
name|abfd
parameter_list|,
name|elength
parameter_list|,
name|map
parameter_list|,
name|orl_count
parameter_list|,
name|stridx
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|unsigned
name|int
name|elength
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|orl
modifier|*
name|map
decl_stmt|;
name|unsigned
name|int
name|orl_count
decl_stmt|;
name|int
name|stridx
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|orl_count_32
decl_stmt|,
name|orl_count_64
decl_stmt|;
name|unsigned
name|int
name|stridx_32
decl_stmt|,
name|stridx_64
decl_stmt|;
specifier|const
name|bfd_arch_info_type
modifier|*
name|arch_info
init|=
name|NULL
decl_stmt|;
name|bfd
modifier|*
name|object_bfd
decl_stmt|;
comment|/* First, we look through the symbols and work out which are      from 32-bit objects and which from 64-bit ones.  */
name|orl_count_32
operator|=
literal|0
expr_stmt|;
name|orl_count_64
operator|=
literal|0
expr_stmt|;
name|stridx_32
operator|=
literal|0
expr_stmt|;
name|stridx_64
operator|=
literal|0
expr_stmt|;
name|object_bfd
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|orl_count
condition|;
name|i
operator|++
control|)
block|{
name|bfd
modifier|*
name|ob
init|=
operator|(
name|bfd
operator|*
operator|)
name|map
index|[
name|i
index|]
operator|.
name|pos
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
if|if
condition|(
name|ob
operator|!=
name|object_bfd
condition|)
name|arch_info
operator|=
name|bfd_get_arch_info
argument_list|(
name|ob
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
operator|*
name|map
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|arch_info
operator|&&
name|arch_info
operator|->
name|bits_per_address
operator|==
literal|64
condition|)
block|{
name|orl_count_64
operator|++
expr_stmt|;
name|stridx_64
operator|+=
name|len
expr_stmt|;
block|}
else|else
block|{
name|orl_count_32
operator|++
expr_stmt|;
name|stridx_32
operator|+=
name|len
expr_stmt|;
block|}
name|object_bfd
operator|=
name|ob
expr_stmt|;
block|}
comment|/* A quick sanity check...  */
name|BFD_ASSERT
argument_list|(
name|orl_count_64
operator|+
name|orl_count_32
operator|==
name|orl_count
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|stridx_64
operator|+
name|stridx_32
operator|==
name|stridx
argument_list|)
expr_stmt|;
comment|/* Now write out each map.  */
if|if
condition|(
operator|!
name|xcoff_write_one_armap_big
argument_list|(
name|abfd
argument_list|,
name|map
argument_list|,
name|orl_count
argument_list|,
name|orl_count_32
argument_list|,
name|stridx_32
argument_list|,
name|false
argument_list|,
name|xcoff_ardata_big
argument_list|(
name|abfd
argument_list|)
operator|->
name|memoff
argument_list|,
name|xcoff_ardata_big
argument_list|(
name|abfd
argument_list|)
operator|->
name|symoff
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|xcoff_write_one_armap_big
argument_list|(
name|abfd
argument_list|,
name|map
argument_list|,
name|orl_count
argument_list|,
name|orl_count_64
argument_list|,
name|stridx_64
argument_list|,
name|true
argument_list|,
name|xcoff_ardata_big
argument_list|(
name|abfd
argument_list|)
operator|->
name|symoff
argument_list|,
name|xcoff_ardata_big
argument_list|(
name|abfd
argument_list|)
operator|->
name|symoff64
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_function
name|boolean
name|_bfd_xcoff_write_armap
parameter_list|(
name|abfd
parameter_list|,
name|elength
parameter_list|,
name|map
parameter_list|,
name|orl_count
parameter_list|,
name|stridx
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|unsigned
name|int
name|elength
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|orl
modifier|*
name|map
decl_stmt|;
name|unsigned
name|int
name|orl_count
decl_stmt|;
name|int
name|stridx
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|xcoff_big_format_p
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|xcoff_write_armap_old
argument_list|(
name|abfd
argument_list|,
name|elength
argument_list|,
name|map
argument_list|,
name|orl_count
argument_list|,
name|stridx
argument_list|)
return|;
else|else
return|return
name|xcoff_write_armap_big
argument_list|(
name|abfd
argument_list|,
name|elength
argument_list|,
name|map
argument_list|,
name|orl_count
argument_list|,
name|stridx
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Write out an XCOFF archive.  We always write an entire archive,    rather than fussing with the freelist and so forth.  */
end_comment

begin_function
specifier|static
name|boolean
name|xcoff_write_archive_contents_old
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|xcoff_ar_file_hdr
name|fhdr
decl_stmt|;
name|size_t
name|count
decl_stmt|;
name|size_t
name|total_namlen
decl_stmt|;
name|file_ptr
modifier|*
name|offsets
decl_stmt|;
name|boolean
name|makemap
decl_stmt|;
name|boolean
name|hasobjects
decl_stmt|;
name|file_ptr
name|prevoff
decl_stmt|,
name|nextoff
decl_stmt|;
name|bfd
modifier|*
name|sub
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|xcoff_ar_hdr
name|ahdr
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|decbuf
index|[
literal|13
index|]
decl_stmt|;
name|memset
argument_list|(
operator|&
name|fhdr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|fhdr
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|fhdr
operator|.
name|magic
argument_list|,
name|XCOFFARMAG
argument_list|,
name|SXCOFFARMAG
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|fhdr
operator|.
name|firstmemoff
argument_list|,
literal|"%d"
argument_list|,
name|SIZEOF_AR_FILE_HDR
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|fhdr
operator|.
name|freeoff
argument_list|,
literal|"%d"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|total_namlen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|sub
operator|=
name|abfd
operator|->
name|archive_head
init|;
name|sub
operator|!=
name|NULL
condition|;
name|sub
operator|=
name|sub
operator|->
name|next
control|)
block|{
operator|++
name|count
expr_stmt|;
name|total_namlen
operator|+=
name|strlen
argument_list|(
name|normalize_filename
argument_list|(
name|sub
argument_list|)
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
name|offsets
operator|=
operator|(
name|file_ptr
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
name|file_ptr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|offsets
operator|==
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|SIZEOF_AR_FILE_HDR
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
name|makemap
operator|=
name|bfd_has_map
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|hasobjects
operator|=
name|false
expr_stmt|;
name|prevoff
operator|=
literal|0
expr_stmt|;
name|nextoff
operator|=
name|SIZEOF_AR_FILE_HDR
expr_stmt|;
for|for
control|(
name|sub
operator|=
name|abfd
operator|->
name|archive_head
operator|,
name|i
operator|=
literal|0
init|;
name|sub
operator|!=
name|NULL
condition|;
name|sub
operator|=
name|sub
operator|->
name|next
operator|,
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|size_t
name|namlen
decl_stmt|;
name|struct
name|xcoff_ar_hdr
modifier|*
name|ahdrp
decl_stmt|;
name|bfd_size_type
name|remaining
decl_stmt|;
if|if
condition|(
name|makemap
operator|&&
operator|!
name|hasobjects
condition|)
block|{
if|if
condition|(
name|bfd_check_format
argument_list|(
name|sub
argument_list|,
name|bfd_object
argument_list|)
condition|)
name|hasobjects
operator|=
name|true
expr_stmt|;
block|}
name|name
operator|=
name|normalize_filename
argument_list|(
name|sub
argument_list|)
expr_stmt|;
name|namlen
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sub
operator|->
name|arelt_data
operator|!=
name|NULL
condition|)
name|ahdrp
operator|=
name|arch_xhdr
argument_list|(
name|sub
argument_list|)
expr_stmt|;
else|else
name|ahdrp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ahdrp
operator|==
name|NULL
condition|)
block|{
name|struct
name|stat
name|s
decl_stmt|;
name|memset
argument_list|(
operator|&
name|ahdr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ahdr
argument_list|)
expr_stmt|;
name|ahdrp
operator|=
operator|&
name|ahdr
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|bfd_get_filename
argument_list|(
name|sub
argument_list|)
argument_list|,
operator|&
name|s
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|sprintf
argument_list|(
name|ahdrp
operator|->
name|size
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|s
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ahdrp
operator|->
name|date
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|s
operator|.
name|st_mtime
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ahdrp
operator|->
name|uid
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|s
operator|.
name|st_uid
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ahdrp
operator|->
name|gid
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|s
operator|.
name|st_gid
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ahdrp
operator|->
name|mode
argument_list|,
literal|"%o"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|s
operator|.
name|st_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|sub
operator|->
name|arelt_data
operator|==
name|NULL
condition|)
block|{
name|sub
operator|->
name|arelt_data
operator|=
name|bfd_alloc
argument_list|(
name|sub
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|areltdata
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sub
operator|->
name|arelt_data
operator|==
name|NULL
condition|)
return|return
name|false
return|;
block|}
name|arch_eltdata
argument_list|(
name|sub
argument_list|)
operator|->
name|parsed_size
operator|=
name|s
operator|.
name|st_size
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|ahdrp
operator|->
name|prevoff
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|prevoff
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ahdrp
operator|->
name|namlen
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|namlen
argument_list|)
expr_stmt|;
comment|/* If the length of the name is odd, we write out the null byte          after the name as well.  */
name|namlen
operator|=
operator|(
name|namlen
operator|+
literal|1
operator|)
operator|&
operator|~
literal|1
expr_stmt|;
name|remaining
operator|=
name|arelt_size
argument_list|(
name|sub
argument_list|)
expr_stmt|;
name|size
operator|=
operator|(
name|SIZEOF_AR_HDR
operator|+
name|namlen
operator|+
name|SXCOFFARFMAG
operator|+
name|remaining
operator|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|nextoff
operator|==
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|offsets
index|[
name|i
index|]
operator|=
name|nextoff
expr_stmt|;
name|prevoff
operator|=
name|nextoff
expr_stmt|;
name|nextoff
operator|+=
name|size
operator|+
operator|(
name|size
operator|&
literal|1
operator|)
expr_stmt|;
name|sprintf
argument_list|(
name|ahdrp
operator|->
name|nextoff
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|nextoff
argument_list|)
expr_stmt|;
comment|/* We need spaces, not null bytes, in the header.  */
for|for
control|(
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|ahdrp
init|;
name|p
operator|<
operator|(
name|char
operator|*
operator|)
name|ahdrp
operator|+
name|SIZEOF_AR_HDR
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
operator|*
name|p
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|ahdrp
argument_list|,
literal|1
argument_list|,
name|SIZEOF_AR_HDR
argument_list|,
name|abfd
argument_list|)
operator|!=
name|SIZEOF_AR_HDR
operator|||
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|name
argument_list|,
literal|1
argument_list|,
name|namlen
argument_list|,
name|abfd
argument_list|)
operator|!=
name|namlen
operator|||
operator|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|XCOFFARFMAG
argument_list|,
literal|1
argument_list|,
name|SXCOFFARFMAG
argument_list|,
name|abfd
argument_list|)
operator|!=
name|SXCOFFARFMAG
operator|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|sub
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
while|while
condition|(
name|remaining
operator|!=
literal|0
condition|)
block|{
name|bfd_size_type
name|amt
decl_stmt|;
name|bfd_byte
name|buffer
index|[
name|DEFAULT_BUFFERSIZE
index|]
decl_stmt|;
name|amt
operator|=
sizeof|sizeof
name|buffer
expr_stmt|;
if|if
condition|(
name|amt
operator|>
name|remaining
condition|)
name|amt
operator|=
name|remaining
expr_stmt|;
if|if
condition|(
name|bfd_read
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|,
name|amt
argument_list|,
name|sub
argument_list|)
operator|!=
name|amt
operator|||
name|bfd_write
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
return|return
name|false
return|;
name|remaining
operator|-=
name|amt
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|size
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
name|bfd_byte
name|b
decl_stmt|;
name|b
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|&
name|b
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|1
condition|)
return|return
name|false
return|;
block|}
block|}
name|sprintf
argument_list|(
name|fhdr
operator|.
name|lastmemoff
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|prevoff
argument_list|)
expr_stmt|;
comment|/* Write out the member table.  */
name|BFD_ASSERT
argument_list|(
name|nextoff
operator|==
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|fhdr
operator|.
name|memoff
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|nextoff
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ahdr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ahdr
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ahdr
operator|.
name|size
argument_list|,
literal|"%ld"
argument_list|,
call|(
name|long
call|)
argument_list|(
literal|12
operator|+
name|count
operator|*
literal|12
operator|+
name|total_namlen
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ahdr
operator|.
name|prevoff
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|prevoff
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ahdr
operator|.
name|date
argument_list|,
literal|"%d"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ahdr
operator|.
name|uid
argument_list|,
literal|"%d"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ahdr
operator|.
name|gid
argument_list|,
literal|"%d"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ahdr
operator|.
name|mode
argument_list|,
literal|"%d"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ahdr
operator|.
name|namlen
argument_list|,
literal|"%d"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|size
operator|=
operator|(
name|SIZEOF_AR_HDR
operator|+
literal|12
operator|+
name|count
operator|*
literal|12
operator|+
name|total_namlen
operator|+
name|SXCOFFARFMAG
operator|)
expr_stmt|;
name|prevoff
operator|=
name|nextoff
expr_stmt|;
name|nextoff
operator|+=
name|size
operator|+
operator|(
name|size
operator|&
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|makemap
operator|&&
name|hasobjects
condition|)
name|sprintf
argument_list|(
name|ahdr
operator|.
name|nextoff
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|nextoff
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|ahdr
operator|.
name|nextoff
argument_list|,
literal|"%d"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* We need spaces, not null bytes, in the header.  */
for|for
control|(
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|ahdr
init|;
name|p
operator|<
operator|(
name|char
operator|*
operator|)
operator|&
name|ahdr
operator|+
name|SIZEOF_AR_HDR
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
operator|*
name|p
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|ahdr
argument_list|,
literal|1
argument_list|,
name|SIZEOF_AR_HDR
argument_list|,
name|abfd
argument_list|)
operator|!=
name|SIZEOF_AR_HDR
operator|||
operator|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|XCOFFARFMAG
argument_list|,
literal|1
argument_list|,
name|SXCOFFARFMAG
argument_list|,
name|abfd
argument_list|)
operator|!=
name|SXCOFFARFMAG
operator|)
condition|)
return|return
name|false
return|;
name|sprintf
argument_list|(
name|decbuf
argument_list|,
literal|"%-12ld"
argument_list|,
operator|(
name|long
operator|)
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|decbuf
argument_list|,
literal|1
argument_list|,
literal|12
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|12
condition|)
return|return
name|false
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|decbuf
argument_list|,
literal|"%-12ld"
argument_list|,
operator|(
name|long
operator|)
name|offsets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|decbuf
argument_list|,
literal|1
argument_list|,
literal|12
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|12
condition|)
return|return
name|false
return|;
block|}
for|for
control|(
name|sub
operator|=
name|abfd
operator|->
name|archive_head
init|;
name|sub
operator|!=
name|NULL
condition|;
name|sub
operator|=
name|sub
operator|->
name|next
control|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|size_t
name|namlen
decl_stmt|;
name|name
operator|=
name|normalize_filename
argument_list|(
name|sub
argument_list|)
expr_stmt|;
name|namlen
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|name
argument_list|,
literal|1
argument_list|,
name|namlen
operator|+
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|namlen
operator|+
literal|1
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
operator|(
name|size
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
name|bfd_byte
name|b
decl_stmt|;
name|b
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|b
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|1
condition|)
return|return
name|false
return|;
block|}
comment|/* Write out the armap, if appropriate.  */
if|if
condition|(
operator|!
name|makemap
operator|||
operator|!
name|hasobjects
condition|)
name|sprintf
argument_list|(
name|fhdr
operator|.
name|symoff
argument_list|,
literal|"%d"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|BFD_ASSERT
argument_list|(
name|nextoff
operator|==
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|fhdr
operator|.
name|symoff
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|nextoff
argument_list|)
expr_stmt|;
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|tdata
operator|=
operator|(
name|PTR
operator|)
operator|&
name|fhdr
expr_stmt|;
if|if
condition|(
operator|!
name|_bfd_compute_and_write_armap
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
block|}
comment|/* Write out the archive file header.  */
comment|/* We need spaces, not null bytes, in the header.  */
for|for
control|(
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|fhdr
init|;
name|p
operator|<
operator|(
name|char
operator|*
operator|)
operator|&
name|fhdr
operator|+
name|SIZEOF_AR_FILE_HDR
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
operator|*
name|p
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|fhdr
argument_list|,
name|SIZEOF_AR_FILE_HDR
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|SIZEOF_AR_FILE_HDR
operator|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|xcoff_write_archive_contents_big
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|xcoff_ar_file_hdr_big
name|fhdr
decl_stmt|;
name|size_t
name|count
decl_stmt|;
name|size_t
name|total_namlen
decl_stmt|;
name|file_ptr
modifier|*
name|offsets
decl_stmt|;
name|boolean
name|makemap
decl_stmt|;
name|boolean
name|hasobjects
decl_stmt|;
name|file_ptr
name|prevoff
decl_stmt|,
name|nextoff
decl_stmt|;
name|bfd
modifier|*
name|sub
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|xcoff_ar_hdr_big
name|ahdr
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|decbuf
index|[
literal|13
index|]
decl_stmt|;
name|memset
argument_list|(
operator|&
name|fhdr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|fhdr
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|fhdr
operator|.
name|magic
argument_list|,
name|XCOFFARMAGBIG
argument_list|,
name|SXCOFFARMAG
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|fhdr
operator|.
name|firstmemoff
argument_list|,
literal|"%d"
argument_list|,
name|SIZEOF_AR_FILE_HDR_BIG
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|fhdr
operator|.
name|freeoff
argument_list|,
literal|"%d"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|total_namlen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|sub
operator|=
name|abfd
operator|->
name|archive_head
init|;
name|sub
operator|!=
name|NULL
condition|;
name|sub
operator|=
name|sub
operator|->
name|next
control|)
block|{
operator|++
name|count
expr_stmt|;
name|total_namlen
operator|+=
name|strlen
argument_list|(
name|normalize_filename
argument_list|(
name|sub
argument_list|)
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
name|offsets
operator|=
operator|(
name|file_ptr
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
name|file_ptr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|offsets
operator|==
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|SIZEOF_AR_FILE_HDR_BIG
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
name|makemap
operator|=
name|bfd_has_map
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|hasobjects
operator|=
name|false
expr_stmt|;
name|prevoff
operator|=
literal|0
expr_stmt|;
name|nextoff
operator|=
name|SIZEOF_AR_FILE_HDR_BIG
expr_stmt|;
for|for
control|(
name|sub
operator|=
name|abfd
operator|->
name|archive_head
operator|,
name|i
operator|=
literal|0
init|;
name|sub
operator|!=
name|NULL
condition|;
name|sub
operator|=
name|sub
operator|->
name|next
operator|,
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|size_t
name|namlen
decl_stmt|;
name|struct
name|xcoff_ar_hdr_big
modifier|*
name|ahdrp
decl_stmt|;
name|bfd_size_type
name|remaining
decl_stmt|;
if|if
condition|(
name|makemap
operator|&&
operator|!
name|hasobjects
condition|)
block|{
if|if
condition|(
name|bfd_check_format
argument_list|(
name|sub
argument_list|,
name|bfd_object
argument_list|)
condition|)
name|hasobjects
operator|=
name|true
expr_stmt|;
block|}
name|name
operator|=
name|normalize_filename
argument_list|(
name|sub
argument_list|)
expr_stmt|;
name|namlen
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sub
operator|->
name|arelt_data
operator|!=
name|NULL
condition|)
name|ahdrp
operator|=
name|arch_xhdr_big
argument_list|(
name|sub
argument_list|)
expr_stmt|;
else|else
name|ahdrp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ahdrp
operator|==
name|NULL
condition|)
block|{
name|struct
name|stat
name|s
decl_stmt|;
name|memset
argument_list|(
operator|&
name|ahdr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ahdr
argument_list|)
expr_stmt|;
name|ahdrp
operator|=
operator|&
name|ahdr
expr_stmt|;
comment|/* XXX This should actually be a call to stat64 (at least on 	     32-bit machines).  */
if|if
condition|(
name|stat
argument_list|(
name|bfd_get_filename
argument_list|(
name|sub
argument_list|)
argument_list|,
operator|&
name|s
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* XXX This call actually should use %lld (at least on 32-bit 	     machines) since the fields's width is 20 and there numbers with 	     more than 32 bits can be represented.  */
name|sprintf
argument_list|(
name|ahdrp
operator|->
name|size
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|s
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ahdrp
operator|->
name|date
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|s
operator|.
name|st_mtime
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ahdrp
operator|->
name|uid
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|s
operator|.
name|st_uid
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ahdrp
operator|->
name|gid
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|s
operator|.
name|st_gid
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ahdrp
operator|->
name|mode
argument_list|,
literal|"%o"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|s
operator|.
name|st_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|sub
operator|->
name|arelt_data
operator|==
name|NULL
condition|)
block|{
name|sub
operator|->
name|arelt_data
operator|=
name|bfd_alloc
argument_list|(
name|sub
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|areltdata
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sub
operator|->
name|arelt_data
operator|==
name|NULL
condition|)
return|return
name|false
return|;
block|}
name|arch_eltdata
argument_list|(
name|sub
argument_list|)
operator|->
name|parsed_size
operator|=
name|s
operator|.
name|st_size
expr_stmt|;
block|}
comment|/* XXX These calls actually should use %lld (at least on 32-bit 	 machines) since the fields's width is 20 and there numbers with 	 more than 32 bits can be represented.  */
name|sprintf
argument_list|(
name|ahdrp
operator|->
name|prevoff
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|prevoff
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ahdrp
operator|->
name|namlen
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|namlen
argument_list|)
expr_stmt|;
comment|/* If the length of the name is odd, we write out the null byte          after the name as well.  */
name|namlen
operator|=
operator|(
name|namlen
operator|+
literal|1
operator|)
operator|&
operator|~
literal|1
expr_stmt|;
name|remaining
operator|=
name|arelt_size
argument_list|(
name|sub
argument_list|)
expr_stmt|;
name|size
operator|=
operator|(
name|SIZEOF_AR_HDR_BIG
operator|+
name|namlen
operator|+
name|SXCOFFARFMAG
operator|+
name|remaining
operator|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|nextoff
operator|==
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|offsets
index|[
name|i
index|]
operator|=
name|nextoff
expr_stmt|;
name|prevoff
operator|=
name|nextoff
expr_stmt|;
name|nextoff
operator|+=
name|size
operator|+
operator|(
name|size
operator|&
literal|1
operator|)
expr_stmt|;
name|sprintf
argument_list|(
name|ahdrp
operator|->
name|nextoff
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|nextoff
argument_list|)
expr_stmt|;
comment|/* We need spaces, not null bytes, in the header.  */
for|for
control|(
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|ahdrp
init|;
name|p
operator|<
operator|(
name|char
operator|*
operator|)
name|ahdrp
operator|+
name|SIZEOF_AR_HDR_BIG
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
operator|*
name|p
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|ahdrp
argument_list|,
literal|1
argument_list|,
name|SIZEOF_AR_HDR_BIG
argument_list|,
name|abfd
argument_list|)
operator|!=
name|SIZEOF_AR_HDR_BIG
operator|||
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|name
argument_list|,
literal|1
argument_list|,
name|namlen
argument_list|,
name|abfd
argument_list|)
operator|!=
name|namlen
operator|||
operator|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|XCOFFARFMAG
argument_list|,
literal|1
argument_list|,
name|SXCOFFARFMAG
argument_list|,
name|abfd
argument_list|)
operator|!=
name|SXCOFFARFMAG
operator|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|sub
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
while|while
condition|(
name|remaining
operator|!=
literal|0
condition|)
block|{
name|bfd_size_type
name|amt
decl_stmt|;
name|bfd_byte
name|buffer
index|[
name|DEFAULT_BUFFERSIZE
index|]
decl_stmt|;
name|amt
operator|=
sizeof|sizeof
name|buffer
expr_stmt|;
if|if
condition|(
name|amt
operator|>
name|remaining
condition|)
name|amt
operator|=
name|remaining
expr_stmt|;
if|if
condition|(
name|bfd_read
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|,
name|amt
argument_list|,
name|sub
argument_list|)
operator|!=
name|amt
operator|||
name|bfd_write
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
return|return
name|false
return|;
name|remaining
operator|-=
name|amt
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|size
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
name|bfd_byte
name|b
decl_stmt|;
name|b
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|&
name|b
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|1
condition|)
return|return
name|false
return|;
block|}
block|}
comment|/* XXX This call actually should use %lld (at least on 32-bit      machines) since the fields's width is 20 and there numbers with      more than 32 bits can be represented.  */
name|sprintf
argument_list|(
name|fhdr
operator|.
name|lastmemoff
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|prevoff
argument_list|)
expr_stmt|;
comment|/* Write out the member table.  */
name|BFD_ASSERT
argument_list|(
name|nextoff
operator|==
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX This call actually should use %lld (at least on 32-bit      machines) since the fields's width is 20 and there numbers with      more than 32 bits can be represented.  */
name|sprintf
argument_list|(
name|fhdr
operator|.
name|memoff
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|nextoff
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ahdr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ahdr
argument_list|)
expr_stmt|;
comment|/* XXX The next two calls actually should use %lld (at least on 32-bit      machines) since the fields's width is 20 and there numbers with      more than 32 bits can be represented.  */
name|sprintf
argument_list|(
name|ahdr
operator|.
name|size
argument_list|,
literal|"%ld"
argument_list|,
call|(
name|long
call|)
argument_list|(
literal|12
operator|+
name|count
operator|*
literal|12
operator|+
name|total_namlen
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ahdr
operator|.
name|prevoff
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|prevoff
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ahdr
operator|.
name|date
argument_list|,
literal|"%d"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ahdr
operator|.
name|uid
argument_list|,
literal|"%d"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ahdr
operator|.
name|gid
argument_list|,
literal|"%d"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ahdr
operator|.
name|mode
argument_list|,
literal|"%d"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ahdr
operator|.
name|namlen
argument_list|,
literal|"%d"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|size
operator|=
operator|(
name|SIZEOF_AR_HDR_BIG
operator|+
literal|12
operator|+
name|count
operator|*
literal|12
operator|+
name|total_namlen
operator|+
name|SXCOFFARFMAG
operator|)
expr_stmt|;
name|prevoff
operator|=
name|nextoff
expr_stmt|;
name|nextoff
operator|+=
name|size
operator|+
operator|(
name|size
operator|&
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|makemap
operator|&&
name|hasobjects
condition|)
comment|/* XXX This call actually should use %lld (at least on 32-bit        machines) since the fields's width is 20 and there numbers with        more than 32 bits can be represented.  */
name|sprintf
argument_list|(
name|ahdr
operator|.
name|nextoff
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|nextoff
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|ahdr
operator|.
name|nextoff
argument_list|,
literal|"%d"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* We need spaces, not null bytes, in the header.  */
for|for
control|(
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|ahdr
init|;
name|p
operator|<
operator|(
name|char
operator|*
operator|)
operator|&
name|ahdr
operator|+
name|SIZEOF_AR_HDR_BIG
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
operator|*
name|p
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|ahdr
argument_list|,
literal|1
argument_list|,
name|SIZEOF_AR_HDR_BIG
argument_list|,
name|abfd
argument_list|)
operator|!=
name|SIZEOF_AR_HDR_BIG
operator|||
operator|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|XCOFFARFMAG
argument_list|,
literal|1
argument_list|,
name|SXCOFFARFMAG
argument_list|,
name|abfd
argument_list|)
operator|!=
name|SXCOFFARFMAG
operator|)
condition|)
return|return
name|false
return|;
name|sprintf
argument_list|(
name|decbuf
argument_list|,
literal|"%-12ld"
argument_list|,
operator|(
name|long
operator|)
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|decbuf
argument_list|,
literal|1
argument_list|,
literal|12
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|12
condition|)
return|return
name|false
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|decbuf
argument_list|,
literal|"%-12ld"
argument_list|,
operator|(
name|long
operator|)
name|offsets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|decbuf
argument_list|,
literal|1
argument_list|,
literal|12
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|12
condition|)
return|return
name|false
return|;
block|}
for|for
control|(
name|sub
operator|=
name|abfd
operator|->
name|archive_head
init|;
name|sub
operator|!=
name|NULL
condition|;
name|sub
operator|=
name|sub
operator|->
name|next
control|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|size_t
name|namlen
decl_stmt|;
name|name
operator|=
name|normalize_filename
argument_list|(
name|sub
argument_list|)
expr_stmt|;
name|namlen
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|name
argument_list|,
literal|1
argument_list|,
name|namlen
operator|+
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|namlen
operator|+
literal|1
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
operator|(
name|size
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
name|bfd_byte
name|b
decl_stmt|;
name|b
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|b
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|1
condition|)
return|return
name|false
return|;
block|}
comment|/* Write out the armap, if appropriate.  */
if|if
condition|(
operator|!
name|makemap
operator|||
operator|!
name|hasobjects
condition|)
name|sprintf
argument_list|(
name|fhdr
operator|.
name|symoff
argument_list|,
literal|"%d"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|BFD_ASSERT
argument_list|(
name|nextoff
operator|==
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX This call actually should use %lld (at least on 32-bit 	 machines) since the fields's width is 20 and there numbers with 	 more than 32 bits can be represented.  */
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|tdata
operator|=
operator|(
name|PTR
operator|)
operator|&
name|fhdr
expr_stmt|;
if|if
condition|(
operator|!
name|_bfd_compute_and_write_armap
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
block|}
comment|/* Write out the archive file header.  */
comment|/* We need spaces, not null bytes, in the header.  */
for|for
control|(
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|fhdr
init|;
name|p
operator|<
operator|(
name|char
operator|*
operator|)
operator|&
name|fhdr
operator|+
name|SIZEOF_AR_FILE_HDR_BIG
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
operator|*
name|p
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|fhdr
argument_list|,
name|SIZEOF_AR_FILE_HDR_BIG
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|SIZEOF_AR_FILE_HDR_BIG
operator|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_function
name|boolean
name|_bfd_xcoff_write_archive_contents
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|xcoff_big_format_p
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|xcoff_write_archive_contents_old
argument_list|(
name|abfd
argument_list|)
return|;
else|else
return|return
name|xcoff_write_archive_contents_big
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* We can't use the usual coff_sizeof_headers routine, because AIX    always uses an a.out header.  */
end_comment

begin_function
name|int
name|_bfd_xcoff_sizeof_headers
parameter_list|(
name|abfd
parameter_list|,
name|reloc
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|boolean
name|reloc
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|size
decl_stmt|;
name|size
operator|=
name|FILHSZ
expr_stmt|;
if|if
condition|(
name|xcoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|full_aouthdr
condition|)
name|size
operator|+=
name|AOUTSZ
expr_stmt|;
else|else
name|size
operator|+=
name|SMALL_AOUTSZ
expr_stmt|;
name|size
operator|+=
name|abfd
operator|->
name|section_count
operator|*
name|SCNHSZ
expr_stmt|;
return|return
name|size
return|;
block|}
end_function

end_unit

