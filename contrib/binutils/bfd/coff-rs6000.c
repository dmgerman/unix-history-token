begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD back-end for IBM RS/6000 "XCOFF" files.    Copyright 1990-1999, 2000, 2001, 2002, 2003    Free Software Foundation, Inc.    FIXME: Can someone provide a transliteration of this name into ASCII?    Using the following chars caused a compiler warning on HIUX (so I replaced    them with octal escapes), and isn't useful without an understanding of what    character set it is.    Written by Metin G. Ozisik, Mimi Ph\373\364ng-Th\345o V\365,      and John Gilmore.    Archive support from Damon A. Permezel.    Contributed by IBM Corporation and Cygnus Support.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"coff/internal.h"
end_include

begin_include
include|#
directive|include
file|"coff/xcoff.h"
end_include

begin_include
include|#
directive|include
file|"coff/rs6000.h"
end_include

begin_include
include|#
directive|include
file|"libcoff.h"
end_include

begin_include
include|#
directive|include
file|"libxcoff.h"
end_include

begin_decl_stmt
specifier|extern
name|bfd_boolean
name|_bfd_xcoff_mkobject
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_boolean
name|_bfd_xcoff_copy_private_bfd_data
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_boolean
name|_bfd_xcoff_is_local_label_name
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|reloc_howto_type
modifier|*
name|_bfd_xcoff_reloc_type_lookup
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd_reloc_code_real_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_boolean
name|_bfd_xcoff_slurp_armap
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
specifier|const
name|bfd_target
modifier|*
name|_bfd_xcoff_archive_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|PTR
name|_bfd_xcoff_read_ar_hdr
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd
modifier|*
name|_bfd_xcoff_openr_next_archived_file
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|_bfd_xcoff_stat_arch_elt
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|stat
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_boolean
name|_bfd_xcoff_write_armap
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|unsigned
name|int
operator|,
expr|struct
name|orl
operator|*
operator|,
name|unsigned
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_boolean
name|_bfd_xcoff_write_archive_contents
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|_bfd_xcoff_sizeof_headers
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd_boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|_bfd_xcoff_swap_sym_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|int
name|_bfd_xcoff_swap_sym_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|_bfd_xcoff_swap_aux_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|int
name|_bfd_xcoff_swap_aux_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xcoff_swap_reloc_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|xcoff_swap_reloc_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declare xcoff_rtype2howto for coffcode.h macro.  */
end_comment

begin_decl_stmt
name|void
name|xcoff_rtype2howto
name|PARAMS
argument_list|(
operator|(
name|arelent
operator|*
operator|,
expr|struct
name|internal_reloc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* coffcode.h needs these to be defined.  */
end_comment

begin_define
define|#
directive|define
name|RS6000COFF_C
value|1
end_define

begin_define
define|#
directive|define
name|SELECT_RELOC
parameter_list|(
name|internal
parameter_list|,
name|howto
parameter_list|)
define|\
value|{									\     internal.r_type = howto->type;					\     internal.r_size =							\       ((howto->complain_on_overflow == complain_overflow_signed		\ 	? 0x80								\ 	: 0)								\        | (howto->bitsize - 1));						\   }
end_define

begin_define
define|#
directive|define
name|COFF_DEFAULT_SECTION_ALIGNMENT_POWER
value|(3)
end_define

begin_define
define|#
directive|define
name|COFF_LONG_FILENAMES
end_define

begin_define
define|#
directive|define
name|NO_COFF_SYMBOLS
end_define

begin_define
define|#
directive|define
name|RTYPE2HOWTO
parameter_list|(
name|cache_ptr
parameter_list|,
name|dst
parameter_list|)
value|xcoff_rtype2howto (cache_ptr, dst)
end_define

begin_define
define|#
directive|define
name|coff_mkobject
value|_bfd_xcoff_mkobject
end_define

begin_define
define|#
directive|define
name|coff_bfd_copy_private_bfd_data
value|_bfd_xcoff_copy_private_bfd_data
end_define

begin_define
define|#
directive|define
name|coff_bfd_is_local_label_name
value|_bfd_xcoff_is_local_label_name
end_define

begin_define
define|#
directive|define
name|coff_bfd_reloc_type_lookup
value|_bfd_xcoff_reloc_type_lookup
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|AIX_CORE
end_ifdef

begin_decl_stmt
specifier|extern
specifier|const
name|bfd_target
modifier|*
name|rs6000coff_core_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_boolean
name|rs6000coff_core_file_matches_executable_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|cbfd
operator|,
name|bfd
operator|*
name|ebfd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|rs6000coff_core_file_failing_command
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|rs6000coff_core_file_failing_signal
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CORE_FILE_P
value|rs6000coff_core_p
end_define

begin_define
define|#
directive|define
name|coff_core_file_failing_command
define|\
value|rs6000coff_core_file_failing_command
end_define

begin_define
define|#
directive|define
name|coff_core_file_failing_signal
define|\
value|rs6000coff_core_file_failing_signal
end_define

begin_define
define|#
directive|define
name|coff_core_file_matches_executable_p
define|\
value|rs6000coff_core_file_matches_executable_p
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CORE_FILE_P
value|_bfd_dummy_target
end_define

begin_define
define|#
directive|define
name|coff_core_file_failing_command
define|\
value|_bfd_nocore_core_file_failing_command
end_define

begin_define
define|#
directive|define
name|coff_core_file_failing_signal
define|\
value|_bfd_nocore_core_file_failing_signal
end_define

begin_define
define|#
directive|define
name|coff_core_file_matches_executable_p
define|\
value|_bfd_nocore_core_file_matches_executable_p
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|coff_SWAP_sym_in
value|_bfd_xcoff_swap_sym_in
end_define

begin_define
define|#
directive|define
name|coff_SWAP_sym_out
value|_bfd_xcoff_swap_sym_out
end_define

begin_define
define|#
directive|define
name|coff_SWAP_aux_in
value|_bfd_xcoff_swap_aux_in
end_define

begin_define
define|#
directive|define
name|coff_SWAP_aux_out
value|_bfd_xcoff_swap_aux_out
end_define

begin_define
define|#
directive|define
name|coff_swap_reloc_in
value|xcoff_swap_reloc_in
end_define

begin_define
define|#
directive|define
name|coff_swap_reloc_out
value|xcoff_swap_reloc_out
end_define

begin_define
define|#
directive|define
name|NO_COFF_RELOCS
end_define

begin_include
include|#
directive|include
file|"coffcode.h"
end_include

begin_comment
comment|/* The main body of code is in coffcode.h.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|normalize_filename
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|xcoff_write_armap_old
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|unsigned
name|int
operator|,
expr|struct
name|orl
operator|*
operator|,
name|unsigned
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|xcoff_write_armap_big
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|unsigned
name|int
operator|,
expr|struct
name|orl
operator|*
operator|,
name|unsigned
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|xcoff_write_archive_contents_old
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|xcoff_write_archive_contents_big
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xcoff_swap_ldhdr_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|PTR
operator|,
expr|struct
name|internal_ldhdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xcoff_swap_ldhdr_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
expr|struct
name|internal_ldhdr
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xcoff_swap_ldsym_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|PTR
operator|,
expr|struct
name|internal_ldsym
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xcoff_swap_ldsym_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
expr|struct
name|internal_ldsym
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xcoff_swap_ldrel_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|PTR
operator|,
expr|struct
name|internal_ldrel
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xcoff_swap_ldrel_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
expr|struct
name|internal_ldrel
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|xcoff_ppc_relocate_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
expr|struct
name|internal_reloc
operator|*
operator|,
expr|struct
name|internal_syment
operator|*
operator|,
name|asection
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|_bfd_xcoff_put_ldsymbol_name
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|xcoff_loader_info
operator|*
operator|,
expr|struct
name|internal_ldsym
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asection
modifier|*
name|xcoff_create_csect_from_smclas
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|union
name|internal_auxent
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|xcoff_is_lineno_count_overflow
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|xcoff_is_reloc_count_overflow
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|xcoff_loader_symbol_offset
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|internal_ldhdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|xcoff_loader_reloc_offset
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|internal_ldhdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|xcoff_generate_rtinit
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|bfd_boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|do_pad
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|do_copy
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|do_shared_object_padding
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|,
name|ufile_ptr
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Relocation functions */
end_comment

begin_decl_stmt
specifier|static
name|bfd_boolean
name|xcoff_reloc_type_br
name|PARAMS
argument_list|(
operator|(
name|XCOFF_RELOC_FUNCTION_ARGS
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|xcoff_complain_overflow_dont_func
name|PARAMS
argument_list|(
operator|(
name|XCOFF_COMPLAIN_FUNCTION_ARGS
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|xcoff_complain_overflow_bitfield_func
name|PARAMS
argument_list|(
operator|(
name|XCOFF_COMPLAIN_FUNCTION_ARGS
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|xcoff_complain_overflow_signed_func
name|PARAMS
argument_list|(
operator|(
name|XCOFF_COMPLAIN_FUNCTION_ARGS
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|xcoff_complain_overflow_unsigned_func
name|PARAMS
argument_list|(
operator|(
name|XCOFF_COMPLAIN_FUNCTION_ARGS
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_macro
name|bfd_boolean
argument_list|(
argument|*xcoff_calculate_relocation[XCOFF_MAX_CALCULATE_RELOCATION]
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
name|XCOFF_RELOC_FUNCTION_ARGS
operator|)
argument_list|)
operator|=
block|{
name|xcoff_reloc_type_pos
block|,
comment|/* R_POS   (0x00) */
name|xcoff_reloc_type_neg
block|,
comment|/* R_NEG   (0x01) */
name|xcoff_reloc_type_rel
block|,
comment|/* R_REL   (0x02) */
name|xcoff_reloc_type_toc
block|,
comment|/* R_TOC   (0x03) */
name|xcoff_reloc_type_fail
block|,
comment|/* R_RTB   (0x04) */
name|xcoff_reloc_type_toc
block|,
comment|/* R_GL    (0x05) */
name|xcoff_reloc_type_toc
block|,
comment|/* R_TCL   (0x06) */
name|xcoff_reloc_type_fail
block|,
comment|/*	    (0x07) */
name|xcoff_reloc_type_ba
block|,
comment|/* R_BA    (0x08) */
name|xcoff_reloc_type_fail
block|,
comment|/*	    (0x09) */
name|xcoff_reloc_type_br
block|,
comment|/* R_BR    (0x0a) */
name|xcoff_reloc_type_fail
block|,
comment|/*	    (0x0b) */
name|xcoff_reloc_type_pos
block|,
comment|/* R_RL    (0x0c) */
name|xcoff_reloc_type_pos
block|,
comment|/* R_RLA   (0x0d) */
name|xcoff_reloc_type_fail
block|,
comment|/*	    (0x0e) */
name|xcoff_reloc_type_noop
block|,
comment|/* R_REF   (0x0f) */
name|xcoff_reloc_type_fail
block|,
comment|/*	    (0x10) */
name|xcoff_reloc_type_fail
block|,
comment|/*	    (0x11) */
name|xcoff_reloc_type_toc
block|,
comment|/* R_TRL   (0x12) */
name|xcoff_reloc_type_toc
block|,
comment|/* R_TRLA  (0x13) */
name|xcoff_reloc_type_fail
block|,
comment|/* R_RRTBI (0x14) */
name|xcoff_reloc_type_fail
block|,
comment|/* R_RRTBA (0x15) */
name|xcoff_reloc_type_ba
block|,
comment|/* R_CAI   (0x16) */
name|xcoff_reloc_type_crel
block|,
comment|/* R_CREL  (0x17) */
name|xcoff_reloc_type_ba
block|,
comment|/* R_RBA   (0x18) */
name|xcoff_reloc_type_ba
block|,
comment|/* R_RBAC  (0x19) */
name|xcoff_reloc_type_br
block|,
comment|/* R_RBR   (0x1a) */
name|xcoff_reloc_type_ba
block|,
comment|/* R_RBRC  (0x1b) */
block|}
expr_stmt|;
end_expr_stmt

begin_macro
name|bfd_boolean
argument_list|(
argument|*xcoff_complain_overflow[XCOFF_MAX_COMPLAIN_OVERFLOW]
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
name|XCOFF_COMPLAIN_FUNCTION_ARGS
operator|)
argument_list|)
operator|=
block|{
name|xcoff_complain_overflow_dont_func
block|,
name|xcoff_complain_overflow_bitfield_func
block|,
name|xcoff_complain_overflow_signed_func
block|,
name|xcoff_complain_overflow_unsigned_func
block|, }
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* We use our own tdata type.  Its first field is the COFF tdata type,    so the COFF routines are compatible.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_xcoff_mkobject
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|coff_data_type
modifier|*
name|coff
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|xcoff_tdata
argument_list|)
decl_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|xcoff_obj_data
operator|=
operator|(
expr|struct
name|xcoff_tdata
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|tdata
operator|.
name|xcoff_obj_data
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|coff
operator|=
name|coff_data
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|coff
operator|->
name|symbols
operator|=
operator|(
name|coff_symbol_type
operator|*
operator|)
name|NULL
expr_stmt|;
name|coff
operator|->
name|conversion_table
operator|=
operator|(
name|unsigned
name|int
operator|*
operator|)
name|NULL
expr_stmt|;
name|coff
operator|->
name|raw_syments
operator|=
operator|(
expr|struct
name|coff_ptr_struct
operator|*
operator|)
name|NULL
expr_stmt|;
name|coff
operator|->
name|relocbase
operator|=
literal|0
expr_stmt|;
name|xcoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|modtype
operator|=
operator|(
literal|'1'
operator|<<
literal|8
operator|)
operator||
literal|'L'
expr_stmt|;
comment|/* We set cputype to -1 to indicate that it has not been      initialized.  */
name|xcoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|cputype
operator|=
operator|-
literal|1
expr_stmt|;
name|xcoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|csects
operator|=
name|NULL
expr_stmt|;
name|xcoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|debug_indices
operator|=
name|NULL
expr_stmt|;
comment|/* text section alignment is different than the default */
name|bfd_xcoff_text_align_power
argument_list|(
name|abfd
argument_list|)
operator|=
literal|2
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Copy XCOFF data from one BFD to another.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_xcoff_copy_private_bfd_data
parameter_list|(
name|ibfd
parameter_list|,
name|obfd
parameter_list|)
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|bfd
modifier|*
name|obfd
decl_stmt|;
block|{
name|struct
name|xcoff_tdata
modifier|*
name|ix
decl_stmt|,
modifier|*
name|ox
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
if|if
condition|(
name|ibfd
operator|->
name|xvec
operator|!=
name|obfd
operator|->
name|xvec
condition|)
return|return
name|TRUE
return|;
name|ix
operator|=
name|xcoff_data
argument_list|(
name|ibfd
argument_list|)
expr_stmt|;
name|ox
operator|=
name|xcoff_data
argument_list|(
name|obfd
argument_list|)
expr_stmt|;
name|ox
operator|->
name|full_aouthdr
operator|=
name|ix
operator|->
name|full_aouthdr
expr_stmt|;
name|ox
operator|->
name|toc
operator|=
name|ix
operator|->
name|toc
expr_stmt|;
if|if
condition|(
name|ix
operator|->
name|sntoc
operator|==
literal|0
condition|)
name|ox
operator|->
name|sntoc
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|sec
operator|=
name|coff_section_from_bfd_index
argument_list|(
name|ibfd
argument_list|,
name|ix
operator|->
name|sntoc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
name|ox
operator|->
name|sntoc
operator|=
literal|0
expr_stmt|;
else|else
name|ox
operator|->
name|sntoc
operator|=
name|sec
operator|->
name|output_section
operator|->
name|target_index
expr_stmt|;
block|}
if|if
condition|(
name|ix
operator|->
name|snentry
operator|==
literal|0
condition|)
name|ox
operator|->
name|snentry
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|sec
operator|=
name|coff_section_from_bfd_index
argument_list|(
name|ibfd
argument_list|,
name|ix
operator|->
name|snentry
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
name|ox
operator|->
name|snentry
operator|=
literal|0
expr_stmt|;
else|else
name|ox
operator|->
name|snentry
operator|=
name|sec
operator|->
name|output_section
operator|->
name|target_index
expr_stmt|;
block|}
name|bfd_xcoff_text_align_power
argument_list|(
name|obfd
argument_list|)
operator|=
name|bfd_xcoff_text_align_power
argument_list|(
name|ibfd
argument_list|)
expr_stmt|;
name|bfd_xcoff_data_align_power
argument_list|(
name|obfd
argument_list|)
operator|=
name|bfd_xcoff_data_align_power
argument_list|(
name|ibfd
argument_list|)
expr_stmt|;
name|ox
operator|->
name|modtype
operator|=
name|ix
operator|->
name|modtype
expr_stmt|;
name|ox
operator|->
name|cputype
operator|=
name|ix
operator|->
name|cputype
expr_stmt|;
name|ox
operator|->
name|maxdata
operator|=
name|ix
operator|->
name|maxdata
expr_stmt|;
name|ox
operator|->
name|maxstack
operator|=
name|ix
operator|->
name|maxstack
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* I don't think XCOFF really has a notion of local labels based on    name.  This will mean that ld -X doesn't actually strip anything.    The AIX native linker does not have a -X option, and it ignores the    -x option.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_xcoff_is_local_label_name
parameter_list|(
name|abfd
parameter_list|,
name|name
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|FALSE
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|_bfd_xcoff_swap_sym_in
parameter_list|(
name|abfd
parameter_list|,
name|ext1
parameter_list|,
name|in1
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|ext1
decl_stmt|;
name|PTR
name|in1
decl_stmt|;
block|{
name|SYMENT
modifier|*
name|ext
init|=
operator|(
name|SYMENT
operator|*
operator|)
name|ext1
decl_stmt|;
name|struct
name|internal_syment
modifier|*
name|in
init|=
operator|(
expr|struct
name|internal_syment
operator|*
operator|)
name|in1
decl_stmt|;
if|if
condition|(
name|ext
operator|->
name|e
operator|.
name|e_name
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
name|memcpy
argument_list|(
name|in
operator|->
name|_n
operator|.
name|_n_name
argument_list|,
name|ext
operator|->
name|e
operator|.
name|e_name
argument_list|,
name|SYMNMLEN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|in
operator|->
name|_n
operator|.
name|_n_n
operator|.
name|_n_zeroes
operator|=
literal|0
expr_stmt|;
name|in
operator|->
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|e
operator|.
name|e
operator|.
name|e_offset
argument_list|)
expr_stmt|;
block|}
name|in
operator|->
name|n_value
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|e_value
argument_list|)
expr_stmt|;
name|in
operator|->
name|n_scnum
operator|=
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|e_scnum
argument_list|)
expr_stmt|;
name|in
operator|->
name|n_type
operator|=
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|e_type
argument_list|)
expr_stmt|;
name|in
operator|->
name|n_sclass
operator|=
name|H_GET_8
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|e_sclass
argument_list|)
expr_stmt|;
name|in
operator|->
name|n_numaux
operator|=
name|H_GET_8
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|e_numaux
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|unsigned
name|int
name|_bfd_xcoff_swap_sym_out
parameter_list|(
name|abfd
parameter_list|,
name|inp
parameter_list|,
name|extp
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|inp
decl_stmt|;
name|PTR
name|extp
decl_stmt|;
block|{
name|struct
name|internal_syment
modifier|*
name|in
init|=
operator|(
expr|struct
name|internal_syment
operator|*
operator|)
name|inp
decl_stmt|;
name|SYMENT
modifier|*
name|ext
init|=
operator|(
name|SYMENT
operator|*
operator|)
name|extp
decl_stmt|;
if|if
condition|(
name|in
operator|->
name|_n
operator|.
name|_n_name
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
name|memcpy
argument_list|(
name|ext
operator|->
name|e
operator|.
name|e_name
argument_list|,
name|in
operator|->
name|_n
operator|.
name|_n_name
argument_list|,
name|SYMNMLEN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|,
name|ext
operator|->
name|e
operator|.
name|e
operator|.
name|e_zeroes
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
argument_list|,
name|ext
operator|->
name|e
operator|.
name|e
operator|.
name|e_offset
argument_list|)
expr_stmt|;
block|}
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|n_value
argument_list|,
name|ext
operator|->
name|e_value
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|n_scnum
argument_list|,
name|ext
operator|->
name|e_scnum
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|n_type
argument_list|,
name|ext
operator|->
name|e_type
argument_list|)
expr_stmt|;
name|H_PUT_8
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|n_sclass
argument_list|,
name|ext
operator|->
name|e_sclass
argument_list|)
expr_stmt|;
name|H_PUT_8
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|n_numaux
argument_list|,
name|ext
operator|->
name|e_numaux
argument_list|)
expr_stmt|;
return|return
name|bfd_coff_symesz
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|_bfd_xcoff_swap_aux_in
parameter_list|(
name|abfd
parameter_list|,
name|ext1
parameter_list|,
name|type
parameter_list|,
name|class
parameter_list|,
name|indx
parameter_list|,
name|numaux
parameter_list|,
name|in1
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|ext1
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|class
decl_stmt|;
name|int
name|indx
decl_stmt|;
name|int
name|numaux
decl_stmt|;
name|PTR
name|in1
decl_stmt|;
block|{
name|AUXENT
modifier|*
name|ext
init|=
operator|(
name|AUXENT
operator|*
operator|)
name|ext1
decl_stmt|;
name|union
name|internal_auxent
modifier|*
name|in
init|=
operator|(
expr|union
name|internal_auxent
operator|*
operator|)
name|in1
decl_stmt|;
switch|switch
condition|(
name|class
condition|)
block|{
case|case
name|C_FILE
case|:
if|if
condition|(
name|ext
operator|->
name|x_file
operator|.
name|x_fname
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|in
operator|->
name|x_file
operator|.
name|x_n
operator|.
name|x_zeroes
operator|=
literal|0
expr_stmt|;
name|in
operator|->
name|x_file
operator|.
name|x_n
operator|.
name|x_offset
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|x_file
operator|.
name|x_n
operator|.
name|x_offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|numaux
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|indx
operator|==
literal|0
condition|)
name|memcpy
argument_list|(
name|in
operator|->
name|x_file
operator|.
name|x_fname
argument_list|,
name|ext
operator|->
name|x_file
operator|.
name|x_fname
argument_list|,
name|numaux
operator|*
sizeof|sizeof
argument_list|(
name|AUXENT
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|in
operator|->
name|x_file
operator|.
name|x_fname
argument_list|,
name|ext
operator|->
name|x_file
operator|.
name|x_fname
argument_list|,
name|FILNMLEN
argument_list|)
expr_stmt|;
block|}
block|}
goto|goto
name|end
goto|;
comment|/* RS/6000 "csect" auxents */
case|case
name|C_EXT
case|:
case|case
name|C_HIDEXT
case|:
if|if
condition|(
name|indx
operator|+
literal|1
operator|==
name|numaux
condition|)
block|{
name|in
operator|->
name|x_csect
operator|.
name|x_scnlen
operator|.
name|l
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|x_csect
operator|.
name|x_scnlen
argument_list|)
expr_stmt|;
name|in
operator|->
name|x_csect
operator|.
name|x_parmhash
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|x_csect
operator|.
name|x_parmhash
argument_list|)
expr_stmt|;
name|in
operator|->
name|x_csect
operator|.
name|x_snhash
operator|=
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|x_csect
operator|.
name|x_snhash
argument_list|)
expr_stmt|;
comment|/* We don't have to hack bitfields in x_smtyp because it's 	     defined by shifts-and-ands, which are equivalent on all 	     byte orders.  */
name|in
operator|->
name|x_csect
operator|.
name|x_smtyp
operator|=
name|H_GET_8
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|x_csect
operator|.
name|x_smtyp
argument_list|)
expr_stmt|;
name|in
operator|->
name|x_csect
operator|.
name|x_smclas
operator|=
name|H_GET_8
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|x_csect
operator|.
name|x_smclas
argument_list|)
expr_stmt|;
name|in
operator|->
name|x_csect
operator|.
name|x_stab
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|x_csect
operator|.
name|x_stab
argument_list|)
expr_stmt|;
name|in
operator|->
name|x_csect
operator|.
name|x_snstab
operator|=
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|x_csect
operator|.
name|x_snstab
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
break|break;
case|case
name|C_STAT
case|:
case|case
name|C_LEAFSTAT
case|:
case|case
name|C_HIDDEN
case|:
if|if
condition|(
name|type
operator|==
name|T_NULL
condition|)
block|{
name|in
operator|->
name|x_scn
operator|.
name|x_scnlen
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|x_scn
operator|.
name|x_scnlen
argument_list|)
expr_stmt|;
name|in
operator|->
name|x_scn
operator|.
name|x_nreloc
operator|=
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|x_scn
operator|.
name|x_nreloc
argument_list|)
expr_stmt|;
name|in
operator|->
name|x_scn
operator|.
name|x_nlinno
operator|=
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|x_scn
operator|.
name|x_nlinno
argument_list|)
expr_stmt|;
comment|/* PE defines some extra fields; we zero them out for 	     safety.  */
name|in
operator|->
name|x_scn
operator|.
name|x_checksum
operator|=
literal|0
expr_stmt|;
name|in
operator|->
name|x_scn
operator|.
name|x_associated
operator|=
literal|0
expr_stmt|;
name|in
operator|->
name|x_scn
operator|.
name|x_comdat
operator|=
literal|0
expr_stmt|;
goto|goto
name|end
goto|;
block|}
break|break;
block|}
name|in
operator|->
name|x_sym
operator|.
name|x_tagndx
operator|.
name|l
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|x_sym
operator|.
name|x_tagndx
argument_list|)
expr_stmt|;
name|in
operator|->
name|x_sym
operator|.
name|x_tvndx
operator|=
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|x_sym
operator|.
name|x_tvndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|==
name|C_BLOCK
operator|||
name|class
operator|==
name|C_FCN
operator|||
name|ISFCN
argument_list|(
name|type
argument_list|)
operator|||
name|ISTAG
argument_list|(
name|class
argument_list|)
condition|)
block|{
name|in
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_lnnoptr
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_lnnoptr
argument_list|)
expr_stmt|;
name|in
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_endndx
operator|.
name|l
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_endndx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|in
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
index|[
literal|0
index|]
operator|=
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|in
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
index|[
literal|1
index|]
operator|=
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|in
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
index|[
literal|2
index|]
operator|=
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|in
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
index|[
literal|3
index|]
operator|=
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ISFCN
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|in
operator|->
name|x_sym
operator|.
name|x_misc
operator|.
name|x_fsize
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|x_sym
operator|.
name|x_misc
operator|.
name|x_fsize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|in
operator|->
name|x_sym
operator|.
name|x_misc
operator|.
name|x_lnsz
operator|.
name|x_lnno
operator|=
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|x_sym
operator|.
name|x_misc
operator|.
name|x_lnsz
operator|.
name|x_lnno
argument_list|)
expr_stmt|;
name|in
operator|->
name|x_sym
operator|.
name|x_misc
operator|.
name|x_lnsz
operator|.
name|x_size
operator|=
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|x_sym
operator|.
name|x_misc
operator|.
name|x_lnsz
operator|.
name|x_size
argument_list|)
expr_stmt|;
block|}
name|end
label|:
empty_stmt|;
comment|/* The semicolon is because MSVC doesn't like labels at      end of block.  */
block|}
end_function

begin_decl_stmt
name|unsigned
name|int
name|_bfd_xcoff_swap_aux_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|unsigned
name|int
name|_bfd_xcoff_swap_aux_out
parameter_list|(
name|abfd
parameter_list|,
name|inp
parameter_list|,
name|type
parameter_list|,
name|class
parameter_list|,
name|indx
parameter_list|,
name|numaux
parameter_list|,
name|extp
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|inp
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|class
decl_stmt|;
name|int
name|indx
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|numaux
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|PTR
name|extp
decl_stmt|;
block|{
name|union
name|internal_auxent
modifier|*
name|in
init|=
operator|(
expr|union
name|internal_auxent
operator|*
operator|)
name|inp
decl_stmt|;
name|AUXENT
modifier|*
name|ext
init|=
operator|(
name|AUXENT
operator|*
operator|)
name|extp
decl_stmt|;
name|memset
argument_list|(
operator|(
name|PTR
operator|)
name|ext
argument_list|,
literal|0
argument_list|,
name|bfd_coff_auxesz
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|class
condition|)
block|{
case|case
name|C_FILE
case|:
if|if
condition|(
name|in
operator|->
name|x_file
operator|.
name|x_fname
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|,
name|ext
operator|->
name|x_file
operator|.
name|x_n
operator|.
name|x_zeroes
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_file
operator|.
name|x_n
operator|.
name|x_offset
argument_list|,
name|ext
operator|->
name|x_file
operator|.
name|x_n
operator|.
name|x_offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|ext
operator|->
name|x_file
operator|.
name|x_fname
argument_list|,
name|in
operator|->
name|x_file
operator|.
name|x_fname
argument_list|,
name|FILNMLEN
argument_list|)
expr_stmt|;
block|}
goto|goto
name|end
goto|;
comment|/* RS/6000 "csect" auxents */
case|case
name|C_EXT
case|:
case|case
name|C_HIDEXT
case|:
if|if
condition|(
name|indx
operator|+
literal|1
operator|==
name|numaux
condition|)
block|{
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_csect
operator|.
name|x_scnlen
operator|.
name|l
argument_list|,
name|ext
operator|->
name|x_csect
operator|.
name|x_scnlen
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_csect
operator|.
name|x_parmhash
argument_list|,
name|ext
operator|->
name|x_csect
operator|.
name|x_parmhash
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_csect
operator|.
name|x_snhash
argument_list|,
name|ext
operator|->
name|x_csect
operator|.
name|x_snhash
argument_list|)
expr_stmt|;
comment|/* We don't have to hack bitfields in x_smtyp because it's 	     defined by shifts-and-ands, which are equivalent on all 	     byte orders.  */
name|H_PUT_8
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_csect
operator|.
name|x_smtyp
argument_list|,
name|ext
operator|->
name|x_csect
operator|.
name|x_smtyp
argument_list|)
expr_stmt|;
name|H_PUT_8
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_csect
operator|.
name|x_smclas
argument_list|,
name|ext
operator|->
name|x_csect
operator|.
name|x_smclas
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_csect
operator|.
name|x_stab
argument_list|,
name|ext
operator|->
name|x_csect
operator|.
name|x_stab
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_csect
operator|.
name|x_snstab
argument_list|,
name|ext
operator|->
name|x_csect
operator|.
name|x_snstab
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
break|break;
case|case
name|C_STAT
case|:
case|case
name|C_LEAFSTAT
case|:
case|case
name|C_HIDDEN
case|:
if|if
condition|(
name|type
operator|==
name|T_NULL
condition|)
block|{
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_scn
operator|.
name|x_scnlen
argument_list|,
name|ext
operator|->
name|x_scn
operator|.
name|x_scnlen
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_scn
operator|.
name|x_nreloc
argument_list|,
name|ext
operator|->
name|x_scn
operator|.
name|x_nreloc
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_scn
operator|.
name|x_nlinno
argument_list|,
name|ext
operator|->
name|x_scn
operator|.
name|x_nlinno
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
break|break;
block|}
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_sym
operator|.
name|x_tagndx
operator|.
name|l
argument_list|,
name|ext
operator|->
name|x_sym
operator|.
name|x_tagndx
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_sym
operator|.
name|x_tvndx
argument_list|,
name|ext
operator|->
name|x_sym
operator|.
name|x_tvndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|==
name|C_BLOCK
operator|||
name|class
operator|==
name|C_FCN
operator|||
name|ISFCN
argument_list|(
name|type
argument_list|)
operator|||
name|ISTAG
argument_list|(
name|class
argument_list|)
condition|)
block|{
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_lnnoptr
argument_list|,
name|ext
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_lnnoptr
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_endndx
operator|.
name|l
argument_list|,
name|ext
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_endndx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
index|[
literal|0
index|]
argument_list|,
name|ext
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
index|[
literal|1
index|]
argument_list|,
name|ext
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
index|[
literal|2
index|]
argument_list|,
name|ext
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
index|[
literal|3
index|]
argument_list|,
name|ext
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ISFCN
argument_list|(
name|type
argument_list|)
condition|)
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_sym
operator|.
name|x_misc
operator|.
name|x_fsize
argument_list|,
name|ext
operator|->
name|x_sym
operator|.
name|x_misc
operator|.
name|x_fsize
argument_list|)
expr_stmt|;
else|else
block|{
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_sym
operator|.
name|x_misc
operator|.
name|x_lnsz
operator|.
name|x_lnno
argument_list|,
name|ext
operator|->
name|x_sym
operator|.
name|x_misc
operator|.
name|x_lnsz
operator|.
name|x_lnno
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_sym
operator|.
name|x_misc
operator|.
name|x_lnsz
operator|.
name|x_size
argument_list|,
name|ext
operator|->
name|x_sym
operator|.
name|x_misc
operator|.
name|x_lnsz
operator|.
name|x_size
argument_list|)
expr_stmt|;
block|}
name|end
label|:
return|return
name|bfd_coff_auxesz
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The XCOFF reloc table.  Actually, XCOFF relocations specify the    bitsize and whether they are signed or not, along with a    conventional type.  This table is for the types, which are used for    different algorithms for putting in the reloc.  Many of these    relocs need special_function entries, which I have not written.  */
end_comment

begin_decl_stmt
name|reloc_howto_type
name|xcoff_howto_table
index|[]
init|=
block|{
comment|/* Standard 32 bit relocation.  */
name|HOWTO
argument_list|(
name|R_POS
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_POS"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 32 bit relocation, but store negative value.  */
name|HOWTO
argument_list|(
name|R_NEG
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
operator|-
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_NEG"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 32 bit PC relative relocation.  */
name|HOWTO
argument_list|(
name|R_REL
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_REL"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16 bit TOC relative relocation.  */
name|HOWTO
argument_list|(
name|R_TOC
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_TOC"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* I don't really know what this is.  */
name|HOWTO
argument_list|(
name|R_RTB
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_RTB"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* External TOC relative symbol.  */
name|HOWTO
argument_list|(
name|R_GL
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_GL"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Local TOC relative symbol.	 */
name|HOWTO
argument_list|(
name|R_TCL
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_TCL"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|EMPTY_HOWTO
argument_list|(
literal|7
argument_list|)
block|,
comment|/* Non modifiable absolute branch.  */
name|HOWTO
argument_list|(
name|R_BA
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|26
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_BA_26"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0x03fffffc
argument_list|,
comment|/* src_mask */
literal|0x03fffffc
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|EMPTY_HOWTO
argument_list|(
literal|9
argument_list|)
block|,
comment|/* Non modifiable relative branch.  */
name|HOWTO
argument_list|(
name|R_BR
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|26
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_BR"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0x03fffffc
argument_list|,
comment|/* src_mask */
literal|0x03fffffc
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|EMPTY_HOWTO
argument_list|(
literal|0xb
argument_list|)
block|,
comment|/* Indirect load.  */
name|HOWTO
argument_list|(
name|R_RL
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_RL"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Load address.  */
name|HOWTO
argument_list|(
name|R_RLA
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_RLA"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|EMPTY_HOWTO
argument_list|(
literal|0xe
argument_list|)
block|,
comment|/* Non-relocating reference.  */
name|HOWTO
argument_list|(
name|R_REF
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_REF"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|EMPTY_HOWTO
argument_list|(
literal|0x10
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|0x11
argument_list|)
block|,
comment|/* TOC relative indirect load.  */
name|HOWTO
argument_list|(
name|R_TRL
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_TRL"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* TOC relative load address.  */
name|HOWTO
argument_list|(
name|R_TRLA
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_TRLA"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Modifiable relative branch.  */
name|HOWTO
argument_list|(
name|R_RRTBI
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_RRTBI"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Modifiable absolute branch.  */
name|HOWTO
argument_list|(
name|R_RRTBA
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_RRTBA"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Modifiable call absolute indirect.  */
name|HOWTO
argument_list|(
name|R_CAI
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_CAI"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Modifiable call relative.  */
name|HOWTO
argument_list|(
name|R_CREL
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_CREL"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Modifiable branch absolute.  */
name|HOWTO
argument_list|(
name|R_RBA
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|26
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_RBA"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0x03fffffc
argument_list|,
comment|/* src_mask */
literal|0x03fffffc
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Modifiable branch absolute.  */
name|HOWTO
argument_list|(
name|R_RBAC
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_RBAC"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Modifiable branch relative.  */
name|HOWTO
argument_list|(
name|R_RBR
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|26
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_RBR_26"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0x03fffffc
argument_list|,
comment|/* src_mask */
literal|0x03fffffc
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Modifiable branch absolute.  */
name|HOWTO
argument_list|(
name|R_RBRC
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_RBRC"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16 bit Non modifiable absolute branch.  */
name|HOWTO
argument_list|(
name|R_BA
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_BA_16"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0xfffc
argument_list|,
comment|/* src_mask */
literal|0xfffc
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Modifiable branch relative.  */
name|HOWTO
argument_list|(
name|R_RBR
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_RBR_16"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Modifiable branch relative.  */
name|HOWTO
argument_list|(
name|R_RBA
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_RBA_16"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|xcoff_rtype2howto
parameter_list|(
name|relent
parameter_list|,
name|internal
parameter_list|)
name|arelent
modifier|*
name|relent
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|internal
decl_stmt|;
block|{
if|if
condition|(
name|internal
operator|->
name|r_type
operator|>
name|R_RBRC
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Default howto layout works most of the time */
name|relent
operator|->
name|howto
operator|=
operator|&
name|xcoff_howto_table
index|[
name|internal
operator|->
name|r_type
index|]
expr_stmt|;
comment|/* Special case some 16 bit reloc */
if|if
condition|(
literal|15
operator|==
operator|(
name|internal
operator|->
name|r_size
operator|&
literal|0x1f
operator|)
condition|)
block|{
if|if
condition|(
name|R_BA
operator|==
name|internal
operator|->
name|r_type
condition|)
name|relent
operator|->
name|howto
operator|=
operator|&
name|xcoff_howto_table
index|[
literal|0x1c
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|R_RBR
operator|==
name|internal
operator|->
name|r_type
condition|)
name|relent
operator|->
name|howto
operator|=
operator|&
name|xcoff_howto_table
index|[
literal|0x1d
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|R_RBA
operator|==
name|internal
operator|->
name|r_type
condition|)
name|relent
operator|->
name|howto
operator|=
operator|&
name|xcoff_howto_table
index|[
literal|0x1e
index|]
expr_stmt|;
block|}
comment|/* The r_size field of an XCOFF reloc encodes the bitsize of the      relocation, as well as indicating whether it is signed or not.      Doublecheck that the relocation information gathered from the      type matches this information.  The bitsize is not significant      for R_REF relocs.  */
if|if
condition|(
name|relent
operator|->
name|howto
operator|->
name|dst_mask
operator|!=
literal|0
operator|&&
operator|(
name|relent
operator|->
name|howto
operator|->
name|bitsize
operator|!=
operator|(
operator|(
name|unsigned
name|int
operator|)
name|internal
operator|->
name|r_size
operator|&
literal|0x1f
operator|)
operator|+
literal|1
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|reloc_howto_type
modifier|*
name|_bfd_xcoff_reloc_type_lookup
parameter_list|(
name|abfd
parameter_list|,
name|code
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|BFD_RELOC_PPC_B26
case|:
return|return
operator|&
name|xcoff_howto_table
index|[
literal|0xa
index|]
return|;
case|case
name|BFD_RELOC_PPC_BA16
case|:
return|return
operator|&
name|xcoff_howto_table
index|[
literal|0x1c
index|]
return|;
case|case
name|BFD_RELOC_PPC_BA26
case|:
return|return
operator|&
name|xcoff_howto_table
index|[
literal|8
index|]
return|;
case|case
name|BFD_RELOC_PPC_TOC16
case|:
return|return
operator|&
name|xcoff_howto_table
index|[
literal|3
index|]
return|;
case|case
name|BFD_RELOC_32
case|:
case|case
name|BFD_RELOC_CTOR
case|:
return|return
operator|&
name|xcoff_howto_table
index|[
literal|0
index|]
return|;
default|default:
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* XCOFF archive support.  The original version of this code was by    Damon A. Permezel.  It was enhanced to permit cross support, and    writing archive files, by Ian Lance Taylor, Cygnus Support.     XCOFF uses its own archive format.  Everything is hooked together    with file offset links, so it is possible to rapidly update an    archive in place.  Of course, we don't do that.  An XCOFF archive    has a real file header, not just an ARMAG string.  The structure of    the file header and of each archive header appear below.     An XCOFF archive also has a member table, which is a list of    elements in the archive (you can get that by looking through the    linked list, but you have to read a lot more of the file).  The    member table has a normal archive header with an empty name.  It is    normally (and perhaps must be) the second to last entry in the    archive.  The member table data is almost printable ASCII.  It    starts with a 12 character decimal string which is the number of    entries in the table.  For each entry it has a 12 character decimal    string which is the offset in the archive of that member.  These    entries are followed by a series of null terminated strings which    are the member names for each entry.     Finally, an XCOFF archive has a global symbol table, which is what    we call the armap.  The global symbol table has a normal archive    header with an empty name.  It is normally (and perhaps must be)    the last entry in the archive.  The contents start with a four byte    binary number which is the number of entries.  This is followed by    a that many four byte binary numbers; each is the file offset of an    entry in the archive.  These numbers are followed by a series of    null terminated strings, which are symbol names.     AIX 4.3 introduced a new archive format which can handle larger    files and also 32- and 64-bit objects in the same archive.  The    things said above remain true except that there is now more than    one global symbol table.  The one is used to index 32-bit objects,    the other for 64-bit objects.     The new archives (recognizable by the new ARMAG string) has larger    field lengths so that we cannot really share any code.  Also we have    to take care that we are not generating the new form of archives    on AIX 4.2 or earlier systems.  */
end_comment

begin_comment
comment|/* XCOFF archives use this as a magic string.  Note that both strings    have the same length.  */
end_comment

begin_comment
comment|/* Set the magic for archive.  */
end_comment

begin_function
name|bfd_boolean
name|bfd_xcoff_ar_archive_set_magic
parameter_list|(
name|abfd
parameter_list|,
name|magic
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|char
modifier|*
name|magic
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* Not supported yet.  */
return|return
name|FALSE
return|;
comment|/* bfd_xcoff_archive_set_magic (abfd, magic); */
block|}
end_function

begin_comment
comment|/* Read in the armap of an XCOFF archive.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_xcoff_slurp_armap
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|file_ptr
name|off
decl_stmt|;
name|size_t
name|namlen
decl_stmt|;
name|bfd_size_type
name|sz
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|,
modifier|*
name|cend
decl_stmt|;
name|bfd_vma
name|c
decl_stmt|,
name|i
decl_stmt|;
name|carsym
modifier|*
name|arsym
decl_stmt|;
name|bfd_byte
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|xcoff_ardata
argument_list|(
name|abfd
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|bfd_has_map
argument_list|(
name|abfd
argument_list|)
operator|=
name|FALSE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
operator|!
name|xcoff_big_format_p
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
comment|/* This is for the old format.  */
name|struct
name|xcoff_ar_hdr
name|hdr
decl_stmt|;
name|off
operator|=
name|strtol
argument_list|(
name|xcoff_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symoff
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|off
operator|==
literal|0
condition|)
block|{
name|bfd_has_map
argument_list|(
name|abfd
argument_list|)
operator|=
name|FALSE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|off
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
comment|/* The symbol table starts with a normal archive header.  */
if|if
condition|(
name|bfd_bread
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|hdr
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|SIZEOF_AR_HDR
argument_list|,
name|abfd
argument_list|)
operator|!=
name|SIZEOF_AR_HDR
condition|)
return|return
name|FALSE
return|;
comment|/* Skip the name (normally empty).  */
name|namlen
operator|=
name|strtol
argument_list|(
name|hdr
operator|.
name|namlen
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|off
operator|=
operator|(
operator|(
name|namlen
operator|+
literal|1
operator|)
operator|&
operator|~
operator|(
name|size_t
operator|)
literal|1
operator|)
operator|+
name|SXCOFFARFMAG
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|off
argument_list|,
name|SEEK_CUR
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
name|sz
operator|=
name|strtol
argument_list|(
name|hdr
operator|.
name|size
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* Read in the entire symbol table.  */
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|bfd_bread
argument_list|(
operator|(
name|PTR
operator|)
name|contents
argument_list|,
name|sz
argument_list|,
name|abfd
argument_list|)
operator|!=
name|sz
condition|)
return|return
name|FALSE
return|;
comment|/* The symbol table starts with a four byte count.  */
name|c
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|contents
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|*
literal|4
operator|>=
name|sz
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symdefs
operator|=
operator|(
operator|(
name|carsym
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|c
operator|*
sizeof|sizeof
argument_list|(
name|carsym
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symdefs
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* After the count comes a list of four byte file offsets.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|arsym
operator|=
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symdefs
operator|,
name|p
operator|=
name|contents
operator|+
literal|4
init|;
name|i
operator|<
name|c
condition|;
operator|++
name|i
operator|,
operator|++
name|arsym
operator|,
name|p
operator|+=
literal|4
control|)
name|arsym
operator|->
name|file_offset
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This is for the new format.  */
name|struct
name|xcoff_ar_hdr_big
name|hdr
decl_stmt|;
name|off
operator|=
name|strtol
argument_list|(
name|xcoff_ardata_big
argument_list|(
name|abfd
argument_list|)
operator|->
name|symoff
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|off
operator|==
literal|0
condition|)
block|{
name|bfd_has_map
argument_list|(
name|abfd
argument_list|)
operator|=
name|FALSE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|off
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
comment|/* The symbol table starts with a normal archive header.  */
if|if
condition|(
name|bfd_bread
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|hdr
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|SIZEOF_AR_HDR_BIG
argument_list|,
name|abfd
argument_list|)
operator|!=
name|SIZEOF_AR_HDR_BIG
condition|)
return|return
name|FALSE
return|;
comment|/* Skip the name (normally empty).  */
name|namlen
operator|=
name|strtol
argument_list|(
name|hdr
operator|.
name|namlen
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|off
operator|=
operator|(
operator|(
name|namlen
operator|+
literal|1
operator|)
operator|&
operator|~
operator|(
name|size_t
operator|)
literal|1
operator|)
operator|+
name|SXCOFFARFMAG
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|off
argument_list|,
name|SEEK_CUR
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
comment|/* XXX This actually has to be a call to strtoll (at least on 32-bit 	 machines) since the field width is 20 and there numbers with more 	 than 32 bits can be represented.  */
name|sz
operator|=
name|strtol
argument_list|(
name|hdr
operator|.
name|size
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* Read in the entire symbol table.  */
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|bfd_bread
argument_list|(
operator|(
name|PTR
operator|)
name|contents
argument_list|,
name|sz
argument_list|,
name|abfd
argument_list|)
operator|!=
name|sz
condition|)
return|return
name|FALSE
return|;
comment|/* The symbol table starts with an eight byte count.  */
name|c
operator|=
name|H_GET_64
argument_list|(
name|abfd
argument_list|,
name|contents
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|*
literal|8
operator|>=
name|sz
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symdefs
operator|=
operator|(
operator|(
name|carsym
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|c
operator|*
sizeof|sizeof
argument_list|(
name|carsym
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symdefs
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* After the count comes a list of eight byte file offsets.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|arsym
operator|=
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symdefs
operator|,
name|p
operator|=
name|contents
operator|+
literal|8
init|;
name|i
operator|<
name|c
condition|;
operator|++
name|i
operator|,
operator|++
name|arsym
operator|,
name|p
operator|+=
literal|8
control|)
name|arsym
operator|->
name|file_offset
operator|=
name|H_GET_64
argument_list|(
name|abfd
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* After the file offsets come null terminated symbol names.  */
name|cend
operator|=
name|contents
operator|+
name|sz
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|arsym
operator|=
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symdefs
init|;
name|i
operator|<
name|c
condition|;
operator|++
name|i
operator|,
operator|++
name|arsym
operator|,
name|p
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
operator|+
literal|1
control|)
block|{
if|if
condition|(
name|p
operator|>=
name|cend
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|arsym
operator|->
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|p
expr_stmt|;
block|}
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symdef_count
operator|=
name|c
expr_stmt|;
name|bfd_has_map
argument_list|(
name|abfd
argument_list|)
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* See if this is an XCOFF archive.  */
end_comment

begin_function
specifier|const
name|bfd_target
modifier|*
name|_bfd_xcoff_archive_p
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|artdata
modifier|*
name|tdata_hold
decl_stmt|;
name|char
name|magic
index|[
name|SXCOFFARMAG
index|]
decl_stmt|;
name|bfd_size_type
name|amt
init|=
name|SXCOFFARMAG
decl_stmt|;
if|if
condition|(
name|bfd_bread
argument_list|(
operator|(
name|PTR
operator|)
name|magic
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_system_call
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|magic
argument_list|,
name|XCOFFARMAG
argument_list|,
name|SXCOFFARMAG
argument_list|)
operator|!=
literal|0
operator|&&
name|strncmp
argument_list|(
name|magic
argument_list|,
name|XCOFFARMAGBIG
argument_list|,
name|SXCOFFARMAG
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|tdata_hold
operator|=
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|artdata
argument_list|)
expr_stmt|;
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
expr|struct
name|artdata
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|==
operator|(
expr|struct
name|artdata
operator|*
operator|)
name|NULL
condition|)
goto|goto
name|error_ret_restore
goto|;
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|cache
operator|=
name|NULL
expr_stmt|;
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|archive_head
operator|=
name|NULL
expr_stmt|;
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symdefs
operator|=
name|NULL
expr_stmt|;
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|extended_names
operator|=
name|NULL
expr_stmt|;
comment|/* Now handle the two formats.  */
if|if
condition|(
name|magic
index|[
literal|1
index|]
operator|!=
literal|'b'
condition|)
block|{
comment|/* This is the old format.  */
name|struct
name|xcoff_ar_file_hdr
name|hdr
decl_stmt|;
comment|/* Copy over the magic string.  */
name|memcpy
argument_list|(
name|hdr
operator|.
name|magic
argument_list|,
name|magic
argument_list|,
name|SXCOFFARMAG
argument_list|)
expr_stmt|;
comment|/* Now read the rest of the file header.  */
name|amt
operator|=
name|SIZEOF_AR_FILE_HDR
operator|-
name|SXCOFFARMAG
expr_stmt|;
if|if
condition|(
name|bfd_bread
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|hdr
operator|.
name|memoff
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_system_call
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
goto|goto
name|error_ret
goto|;
block|}
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|first_file_filepos
operator|=
name|strtol
argument_list|(
name|hdr
operator|.
name|firstmemoff
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|amt
operator|=
name|SIZEOF_AR_FILE_HDR
expr_stmt|;
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|tdata
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|tdata
operator|==
name|NULL
condition|)
goto|goto
name|error_ret
goto|;
name|memcpy
argument_list|(
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|tdata
argument_list|,
operator|&
name|hdr
argument_list|,
name|SIZEOF_AR_FILE_HDR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This is the new format.  */
name|struct
name|xcoff_ar_file_hdr_big
name|hdr
decl_stmt|;
comment|/* Copy over the magic string.  */
name|memcpy
argument_list|(
name|hdr
operator|.
name|magic
argument_list|,
name|magic
argument_list|,
name|SXCOFFARMAG
argument_list|)
expr_stmt|;
comment|/* Now read the rest of the file header.  */
name|amt
operator|=
name|SIZEOF_AR_FILE_HDR_BIG
operator|-
name|SXCOFFARMAG
expr_stmt|;
if|if
condition|(
name|bfd_bread
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|hdr
operator|.
name|memoff
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_system_call
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
goto|goto
name|error_ret
goto|;
block|}
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|first_file_filepos
operator|=
name|bfd_scan_vma
argument_list|(
name|hdr
operator|.
name|firstmemoff
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
literal|0
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|amt
operator|=
name|SIZEOF_AR_FILE_HDR_BIG
expr_stmt|;
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|tdata
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|tdata
operator|==
name|NULL
condition|)
goto|goto
name|error_ret
goto|;
name|memcpy
argument_list|(
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|tdata
argument_list|,
operator|&
name|hdr
argument_list|,
name|SIZEOF_AR_FILE_HDR_BIG
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|_bfd_xcoff_slurp_armap
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|error_ret
label|:
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|error_ret_restore
label|:
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|=
name|tdata_hold
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|abfd
operator|->
name|xvec
return|;
block|}
end_function

begin_comment
comment|/* Read the archive header in an XCOFF archive.  */
end_comment

begin_function
name|PTR
name|_bfd_xcoff_read_ar_hdr
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|bfd_size_type
name|namlen
decl_stmt|;
name|struct
name|areltdata
modifier|*
name|ret
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|areltdata
argument_list|)
decl_stmt|;
name|ret
operator|=
operator|(
expr|struct
name|areltdata
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|xcoff_big_format_p
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|struct
name|xcoff_ar_hdr
name|hdr
decl_stmt|;
name|struct
name|xcoff_ar_hdr
modifier|*
name|hdrp
decl_stmt|;
if|if
condition|(
name|bfd_bread
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|hdr
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|SIZEOF_AR_HDR
argument_list|,
name|abfd
argument_list|)
operator|!=
name|SIZEOF_AR_HDR
condition|)
block|{
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|namlen
operator|=
name|strtol
argument_list|(
name|hdr
operator|.
name|namlen
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|amt
operator|=
name|SIZEOF_AR_HDR
operator|+
name|namlen
operator|+
literal|1
expr_stmt|;
name|hdrp
operator|=
operator|(
expr|struct
name|xcoff_ar_hdr
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdrp
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memcpy
argument_list|(
name|hdrp
argument_list|,
operator|&
name|hdr
argument_list|,
name|SIZEOF_AR_HDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_bread
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hdrp
operator|+
name|SIZEOF_AR_HDR
argument_list|,
name|namlen
argument_list|,
name|abfd
argument_list|)
operator|!=
name|namlen
condition|)
block|{
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|(
operator|(
name|char
operator|*
operator|)
name|hdrp
operator|)
index|[
name|SIZEOF_AR_HDR
operator|+
name|namlen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ret
operator|->
name|arch_header
operator|=
operator|(
name|char
operator|*
operator|)
name|hdrp
expr_stmt|;
name|ret
operator|->
name|parsed_size
operator|=
name|strtol
argument_list|(
name|hdr
operator|.
name|size
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|ret
operator|->
name|filename
operator|=
operator|(
name|char
operator|*
operator|)
name|hdrp
operator|+
name|SIZEOF_AR_HDR
expr_stmt|;
block|}
else|else
block|{
name|struct
name|xcoff_ar_hdr_big
name|hdr
decl_stmt|;
name|struct
name|xcoff_ar_hdr_big
modifier|*
name|hdrp
decl_stmt|;
if|if
condition|(
name|bfd_bread
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|hdr
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|SIZEOF_AR_HDR_BIG
argument_list|,
name|abfd
argument_list|)
operator|!=
name|SIZEOF_AR_HDR_BIG
condition|)
block|{
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|namlen
operator|=
name|strtol
argument_list|(
name|hdr
operator|.
name|namlen
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|amt
operator|=
name|SIZEOF_AR_HDR_BIG
operator|+
name|namlen
operator|+
literal|1
expr_stmt|;
name|hdrp
operator|=
operator|(
expr|struct
name|xcoff_ar_hdr_big
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdrp
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memcpy
argument_list|(
name|hdrp
argument_list|,
operator|&
name|hdr
argument_list|,
name|SIZEOF_AR_HDR_BIG
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_bread
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hdrp
operator|+
name|SIZEOF_AR_HDR_BIG
argument_list|,
name|namlen
argument_list|,
name|abfd
argument_list|)
operator|!=
name|namlen
condition|)
block|{
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|(
operator|(
name|char
operator|*
operator|)
name|hdrp
operator|)
index|[
name|SIZEOF_AR_HDR_BIG
operator|+
name|namlen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ret
operator|->
name|arch_header
operator|=
operator|(
name|char
operator|*
operator|)
name|hdrp
expr_stmt|;
comment|/* XXX This actually has to be a call to strtoll (at least on 32-bit 	 machines) since the field width is 20 and there numbers with more 	 than 32 bits can be represented.  */
name|ret
operator|->
name|parsed_size
operator|=
name|strtol
argument_list|(
name|hdr
operator|.
name|size
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|ret
operator|->
name|filename
operator|=
operator|(
name|char
operator|*
operator|)
name|hdrp
operator|+
name|SIZEOF_AR_HDR_BIG
expr_stmt|;
block|}
comment|/* Skip over the XCOFFARFMAG at the end of the file name.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
call|(
name|file_ptr
call|)
argument_list|(
operator|(
name|namlen
operator|&
literal|1
operator|)
operator|+
name|SXCOFFARFMAG
argument_list|)
argument_list|,
name|SEEK_CUR
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|NULL
return|;
return|return
operator|(
name|PTR
operator|)
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Open the next element in an XCOFF archive.  */
end_comment

begin_function
name|bfd
modifier|*
name|_bfd_xcoff_openr_next_archived_file
parameter_list|(
name|archive
parameter_list|,
name|last_file
parameter_list|)
name|bfd
modifier|*
name|archive
decl_stmt|;
name|bfd
modifier|*
name|last_file
decl_stmt|;
block|{
name|file_ptr
name|filestart
decl_stmt|;
if|if
condition|(
name|xcoff_ardata
argument_list|(
name|archive
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|xcoff_big_format_p
argument_list|(
name|archive
argument_list|)
condition|)
block|{
if|if
condition|(
name|last_file
operator|==
name|NULL
condition|)
name|filestart
operator|=
name|bfd_ardata
argument_list|(
name|archive
argument_list|)
operator|->
name|first_file_filepos
expr_stmt|;
else|else
name|filestart
operator|=
name|strtol
argument_list|(
name|arch_xhdr
argument_list|(
name|last_file
argument_list|)
operator|->
name|nextoff
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|filestart
operator|==
literal|0
operator|||
name|filestart
operator|==
name|strtol
argument_list|(
name|xcoff_ardata
argument_list|(
name|archive
argument_list|)
operator|->
name|memoff
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
operator|||
name|filestart
operator|==
name|strtol
argument_list|(
name|xcoff_ardata
argument_list|(
name|archive
argument_list|)
operator|->
name|symoff
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_more_archived_files
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|last_file
operator|==
name|NULL
condition|)
name|filestart
operator|=
name|bfd_ardata
argument_list|(
name|archive
argument_list|)
operator|->
name|first_file_filepos
expr_stmt|;
else|else
comment|/* XXX These actually have to be a calls to strtoll (at least 	   on 32-bit machines) since the fields's width is 20 and 	   there numbers with more than 32 bits can be represented.  */
name|filestart
operator|=
name|strtol
argument_list|(
name|arch_xhdr_big
argument_list|(
name|last_file
argument_list|)
operator|->
name|nextoff
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* XXX These actually have to be calls to strtoll (at least on 32-bit 	 machines) since the fields's width is 20 and there numbers with more 	 than 32 bits can be represented.  */
if|if
condition|(
name|filestart
operator|==
literal|0
operator|||
name|filestart
operator|==
name|strtol
argument_list|(
name|xcoff_ardata_big
argument_list|(
name|archive
argument_list|)
operator|->
name|memoff
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
operator|||
name|filestart
operator|==
name|strtol
argument_list|(
name|xcoff_ardata_big
argument_list|(
name|archive
argument_list|)
operator|->
name|symoff
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_more_archived_files
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
return|return
name|_bfd_get_elt_at_filepos
argument_list|(
name|archive
argument_list|,
name|filestart
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Stat an element in an XCOFF archive.  */
end_comment

begin_function
name|int
name|_bfd_xcoff_stat_arch_elt
parameter_list|(
name|abfd
parameter_list|,
name|s
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|stat
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|abfd
operator|->
name|arelt_data
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|xcoff_big_format_p
argument_list|(
name|abfd
operator|->
name|my_archive
argument_list|)
condition|)
block|{
name|struct
name|xcoff_ar_hdr
modifier|*
name|hdrp
init|=
name|arch_xhdr
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|s
operator|->
name|st_mtime
operator|=
name|strtol
argument_list|(
name|hdrp
operator|->
name|date
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|s
operator|->
name|st_uid
operator|=
name|strtol
argument_list|(
name|hdrp
operator|->
name|uid
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|s
operator|->
name|st_gid
operator|=
name|strtol
argument_list|(
name|hdrp
operator|->
name|gid
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|s
operator|->
name|st_mode
operator|=
name|strtol
argument_list|(
name|hdrp
operator|->
name|mode
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|s
operator|->
name|st_size
operator|=
name|arch_eltdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|parsed_size
expr_stmt|;
block|}
else|else
block|{
name|struct
name|xcoff_ar_hdr_big
modifier|*
name|hdrp
init|=
name|arch_xhdr_big
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|s
operator|->
name|st_mtime
operator|=
name|strtol
argument_list|(
name|hdrp
operator|->
name|date
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|s
operator|->
name|st_uid
operator|=
name|strtol
argument_list|(
name|hdrp
operator|->
name|uid
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|s
operator|->
name|st_gid
operator|=
name|strtol
argument_list|(
name|hdrp
operator|->
name|gid
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|s
operator|->
name|st_mode
operator|=
name|strtol
argument_list|(
name|hdrp
operator|->
name|mode
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|s
operator|->
name|st_size
operator|=
name|arch_eltdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|parsed_size
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Normalize a file name for inclusion in an archive.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|normalize_filename
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|file
operator|=
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|filename
operator|=
name|strrchr
argument_list|(
name|file
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|filename
operator|!=
name|NULL
condition|)
name|filename
operator|++
expr_stmt|;
else|else
name|filename
operator|=
name|file
expr_stmt|;
return|return
name|filename
return|;
block|}
end_function

begin_comment
comment|/* Write out an XCOFF armap.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|xcoff_write_armap_old
parameter_list|(
name|abfd
parameter_list|,
name|elength
parameter_list|,
name|map
parameter_list|,
name|orl_count
parameter_list|,
name|stridx
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|unsigned
name|int
name|elength
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|orl
modifier|*
name|map
decl_stmt|;
name|unsigned
name|int
name|orl_count
decl_stmt|;
name|int
name|stridx
decl_stmt|;
block|{
name|struct
name|xcoff_ar_hdr
name|hdr
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|bfd
modifier|*
name|sub
decl_stmt|;
name|file_ptr
name|fileoff
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|memset
argument_list|(
operator|&
name|hdr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|hdr
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|hdr
operator|.
name|size
argument_list|,
literal|"%ld"
argument_list|,
call|(
name|long
call|)
argument_list|(
literal|4
operator|+
name|orl_count
operator|*
literal|4
operator|+
name|stridx
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|hdr
operator|.
name|nextoff
argument_list|,
literal|"%d"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|hdr
operator|.
name|prevoff
argument_list|,
name|xcoff_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|memoff
argument_list|,
name|XCOFFARMAG_ELEMENT_SIZE
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|hdr
operator|.
name|date
argument_list|,
literal|"%d"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|hdr
operator|.
name|uid
argument_list|,
literal|"%d"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|hdr
operator|.
name|gid
argument_list|,
literal|"%d"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|hdr
operator|.
name|mode
argument_list|,
literal|"%d"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|hdr
operator|.
name|namlen
argument_list|,
literal|"%d"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* We need spaces, not null bytes, in the header.  */
for|for
control|(
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|hdr
init|;
name|p
operator|<
operator|(
name|char
operator|*
operator|)
operator|&
name|hdr
operator|+
name|SIZEOF_AR_HDR
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
operator|*
name|p
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|hdr
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|SIZEOF_AR_HDR
argument_list|,
name|abfd
argument_list|)
operator|!=
name|SIZEOF_AR_HDR
operator|||
operator|(
name|bfd_bwrite
argument_list|(
name|XCOFFARFMAG
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|SXCOFFARFMAG
argument_list|,
name|abfd
argument_list|)
operator|!=
name|SXCOFFARFMAG
operator|)
condition|)
return|return
name|FALSE
return|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|orl_count
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
name|buf
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|4
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
condition|)
return|return
name|FALSE
return|;
name|sub
operator|=
name|abfd
operator|->
name|archive_head
expr_stmt|;
name|fileoff
operator|=
name|SIZEOF_AR_FILE_HDR
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|sub
operator|!=
name|NULL
operator|&&
name|i
operator|<
name|orl_count
condition|)
block|{
name|size_t
name|namlen
decl_stmt|;
while|while
condition|(
name|map
index|[
name|i
index|]
operator|.
name|u
operator|.
name|abfd
operator|==
name|sub
condition|)
block|{
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|fileoff
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
name|buf
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|4
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
condition|)
return|return
name|FALSE
return|;
operator|++
name|i
expr_stmt|;
block|}
name|namlen
operator|=
name|strlen
argument_list|(
name|normalize_filename
argument_list|(
name|sub
argument_list|)
argument_list|)
expr_stmt|;
name|namlen
operator|=
operator|(
name|namlen
operator|+
literal|1
operator|)
operator|&
operator|~
operator|(
name|size_t
operator|)
literal|1
expr_stmt|;
name|fileoff
operator|+=
operator|(
name|SIZEOF_AR_HDR
operator|+
name|namlen
operator|+
name|SXCOFFARFMAG
operator|+
name|arelt_size
argument_list|(
name|sub
argument_list|)
operator|)
expr_stmt|;
name|fileoff
operator|=
operator|(
name|fileoff
operator|+
literal|1
operator|)
operator|&
operator|~
literal|1
expr_stmt|;
name|sub
operator|=
name|sub
operator|->
name|next
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|orl_count
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|size_t
name|namlen
decl_stmt|;
name|name
operator|=
operator|*
name|map
index|[
name|i
index|]
operator|.
name|name
expr_stmt|;
name|namlen
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
name|name
argument_list|,
call|(
name|bfd_size_type
call|)
argument_list|(
name|namlen
operator|+
literal|1
argument_list|)
argument_list|,
name|abfd
argument_list|)
operator|!=
name|namlen
operator|+
literal|1
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|(
name|stridx
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
name|char
name|b
decl_stmt|;
name|b
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
operator|&
name|b
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|1
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|buff20
index|[
name|XCOFFARMAGBIG_ELEMENT_SIZE
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|FMT20
value|"%-20lld"
end_define

begin_define
define|#
directive|define
name|FMT12
value|"%-12d"
end_define

begin_define
define|#
directive|define
name|FMT12_OCTAL
value|"%-12o"
end_define

begin_define
define|#
directive|define
name|FMT4
value|"%-4d"
end_define

begin_define
define|#
directive|define
name|PRINT20
parameter_list|(
name|d
parameter_list|,
name|v
parameter_list|)
define|\
value|sprintf (buff20, FMT20, (long long)(v)), \   memcpy ((void *) (d), buff20, 20)
end_define

begin_define
define|#
directive|define
name|PRINT12
parameter_list|(
name|d
parameter_list|,
name|v
parameter_list|)
define|\
value|sprintf (buff20, FMT12, (int)(v)), \   memcpy ((void *) (d), buff20, 12)
end_define

begin_define
define|#
directive|define
name|PRINT12_OCTAL
parameter_list|(
name|d
parameter_list|,
name|v
parameter_list|)
define|\
value|sprintf (buff20, FMT12_OCTAL, (unsigned int)(v)), \   memcpy ((void *) (d), buff20, 12)
end_define

begin_define
define|#
directive|define
name|PRINT4
parameter_list|(
name|d
parameter_list|,
name|v
parameter_list|)
define|\
value|sprintf (buff20, FMT4, (int)(v)), \   memcpy ((void *) (d), buff20, 4)
end_define

begin_define
define|#
directive|define
name|READ20
parameter_list|(
name|d
parameter_list|,
name|v
parameter_list|)
define|\
value|buff20[20] = 0, \   memcpy (buff20, (d), 20), \   (v) = bfd_scan_vma (buff20, (const char **) NULL, 10)
end_define

begin_function
specifier|static
name|bfd_boolean
name|do_pad
parameter_list|(
name|abfd
parameter_list|,
name|number
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|unsigned
name|int
name|number
decl_stmt|;
block|{
name|bfd_byte
name|b
init|=
literal|0
decl_stmt|;
comment|/* Limit pad to<= 4096.  */
if|if
condition|(
name|number
operator|>
literal|4096
condition|)
return|return
name|FALSE
return|;
while|while
condition|(
name|number
operator|--
condition|)
if|if
condition|(
name|bfd_bwrite
argument_list|(
operator|&
name|b
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|1
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|do_copy
parameter_list|(
name|out_bfd
parameter_list|,
name|in_bfd
parameter_list|)
name|bfd
modifier|*
name|out_bfd
decl_stmt|;
name|bfd
modifier|*
name|in_bfd
decl_stmt|;
block|{
name|bfd_size_type
name|remaining
decl_stmt|;
name|bfd_byte
name|buffer
index|[
name|DEFAULT_BUFFERSIZE
index|]
decl_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|in_bfd
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
name|remaining
operator|=
name|arelt_size
argument_list|(
name|in_bfd
argument_list|)
expr_stmt|;
while|while
condition|(
name|remaining
operator|>=
name|DEFAULT_BUFFERSIZE
condition|)
block|{
if|if
condition|(
name|bfd_bread
argument_list|(
name|buffer
argument_list|,
name|DEFAULT_BUFFERSIZE
argument_list|,
name|in_bfd
argument_list|)
operator|!=
name|DEFAULT_BUFFERSIZE
operator|||
name|bfd_bwrite
argument_list|(
name|buffer
argument_list|,
name|DEFAULT_BUFFERSIZE
argument_list|,
name|out_bfd
argument_list|)
operator|!=
name|DEFAULT_BUFFERSIZE
condition|)
return|return
name|FALSE
return|;
name|remaining
operator|-=
name|DEFAULT_BUFFERSIZE
expr_stmt|;
block|}
if|if
condition|(
name|remaining
condition|)
block|{
if|if
condition|(
name|bfd_bread
argument_list|(
name|buffer
argument_list|,
name|remaining
argument_list|,
name|in_bfd
argument_list|)
operator|!=
name|remaining
operator|||
name|bfd_bwrite
argument_list|(
name|buffer
argument_list|,
name|remaining
argument_list|,
name|out_bfd
argument_list|)
operator|!=
name|remaining
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|do_shared_object_padding
parameter_list|(
name|out_bfd
parameter_list|,
name|in_bfd
parameter_list|,
name|offset
parameter_list|,
name|ar_header_size
parameter_list|)
name|bfd
modifier|*
name|out_bfd
decl_stmt|;
name|bfd
modifier|*
name|in_bfd
decl_stmt|;
name|ufile_ptr
modifier|*
name|offset
decl_stmt|;
name|int
name|ar_header_size
decl_stmt|;
block|{
if|if
condition|(
name|bfd_check_format
argument_list|(
name|in_bfd
argument_list|,
name|bfd_object
argument_list|)
operator|&&
name|bfd_get_flavour
argument_list|(
name|in_bfd
argument_list|)
operator|==
name|bfd_target_xcoff_flavour
operator|&&
operator|(
name|in_bfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
condition|)
block|{
name|bfd_size_type
name|pad
init|=
literal|0
decl_stmt|;
name|int
name|text_align_power
decl_stmt|;
name|text_align_power
operator|=
name|bfd_xcoff_text_align_power
argument_list|(
name|in_bfd
argument_list|)
expr_stmt|;
name|pad
operator|=
literal|1
operator|<<
name|text_align_power
expr_stmt|;
name|pad
operator|-=
operator|(
operator|*
name|offset
operator|+
name|ar_header_size
operator|)
operator|&
operator|(
name|pad
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|do_pad
argument_list|(
name|out_bfd
argument_list|,
name|pad
argument_list|)
condition|)
return|return
name|FALSE
return|;
operator|*
name|offset
operator|+=
name|pad
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|xcoff_write_armap_big
parameter_list|(
name|abfd
parameter_list|,
name|elength
parameter_list|,
name|map
parameter_list|,
name|orl_count
parameter_list|,
name|stridx
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|unsigned
name|int
name|elength
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|orl
modifier|*
name|map
decl_stmt|;
name|unsigned
name|int
name|orl_count
decl_stmt|;
name|int
name|stridx
decl_stmt|;
block|{
name|struct
name|xcoff_ar_file_hdr_big
modifier|*
name|fhdr
decl_stmt|;
name|bfd_vma
name|i
decl_stmt|,
name|sym_32
decl_stmt|,
name|sym_64
decl_stmt|,
name|str_32
decl_stmt|,
name|str_64
decl_stmt|;
specifier|const
name|bfd_arch_info_type
modifier|*
name|arch_info
init|=
name|NULL
decl_stmt|;
name|bfd
modifier|*
name|current_bfd
decl_stmt|;
name|size_t
name|string_length
decl_stmt|;
name|ufile_ptr
name|nextoff
decl_stmt|,
name|prevoff
decl_stmt|;
comment|/* First, we look through the symbols and work out which are      from 32-bit objects and which from 64-bit ones.  */
name|sym_32
operator|=
name|sym_64
operator|=
name|str_32
operator|=
name|str_64
operator|=
literal|0
expr_stmt|;
name|current_bfd
operator|=
name|abfd
operator|->
name|archive_head
expr_stmt|;
if|if
condition|(
name|current_bfd
operator|!=
name|NULL
condition|)
name|arch_info
operator|=
name|bfd_get_arch_info
argument_list|(
name|current_bfd
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|current_bfd
operator|!=
name|NULL
operator|&&
name|i
operator|<
name|orl_count
condition|)
block|{
while|while
condition|(
name|map
index|[
name|i
index|]
operator|.
name|u
operator|.
name|abfd
operator|==
name|current_bfd
condition|)
block|{
name|string_length
operator|=
name|strlen
argument_list|(
operator|*
name|map
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|arch_info
operator|->
name|bits_per_address
operator|==
literal|64
condition|)
block|{
name|sym_64
operator|++
expr_stmt|;
name|str_64
operator|+=
name|string_length
expr_stmt|;
block|}
else|else
block|{
name|sym_32
operator|++
expr_stmt|;
name|str_32
operator|+=
name|string_length
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
block|}
name|current_bfd
operator|=
name|current_bfd
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|current_bfd
operator|!=
name|NULL
condition|)
name|arch_info
operator|=
name|bfd_get_arch_info
argument_list|(
name|current_bfd
argument_list|)
expr_stmt|;
block|}
comment|/* A quick sanity check... */
name|BFD_ASSERT
argument_list|(
name|sym_64
operator|+
name|sym_32
operator|==
name|orl_count
argument_list|)
expr_stmt|;
comment|/* Explicit cast to int for compiler.  */
name|BFD_ASSERT
argument_list|(
call|(
name|int
call|)
argument_list|(
name|str_64
operator|+
name|str_32
argument_list|)
operator|==
name|stridx
argument_list|)
expr_stmt|;
name|fhdr
operator|=
name|xcoff_ardata_big
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* xcoff_write_archive_contents_big passes nextoff in symoff. */
name|READ20
argument_list|(
name|fhdr
operator|->
name|memoff
argument_list|,
name|prevoff
argument_list|)
expr_stmt|;
name|READ20
argument_list|(
name|fhdr
operator|->
name|symoff
argument_list|,
name|nextoff
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|nextoff
operator|==
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Write out the symbol table.      Layout :       standard big archive header      0x0000		      ar_size	[0x14]      0x0014		      ar_nxtmem [0x14]      0x0028		      ar_prvmem [0x14]      0x003C		      ar_date	[0x0C]      0x0048		      ar_uid	[0x0C]      0x0054		      ar_gid	[0x0C]      0x0060		      ar_mod	[0x0C]      0x006C		      ar_namelen[0x04]      0x0070		      ar_fmag	[SXCOFFARFMAG]       Symbol table      0x0072		      num_syms	[0x08], binary      0x0078		      offsets	[0x08 * num_syms], binary      0x0086 + 0x08 * num_syms names	[??]      ??			      pad to even bytes.   */
if|if
condition|(
name|sym_32
condition|)
block|{
name|struct
name|xcoff_ar_hdr_big
modifier|*
name|hdr
decl_stmt|;
name|bfd_byte
modifier|*
name|symbol_table
decl_stmt|;
name|bfd_byte
modifier|*
name|st
decl_stmt|;
name|file_ptr
name|fileoff
decl_stmt|;
name|bfd_vma
name|symbol_table_size
init|=
name|SIZEOF_AR_HDR_BIG
operator|+
name|SXCOFFARFMAG
operator|+
literal|8
operator|+
literal|8
operator|*
name|sym_32
operator|+
name|str_32
operator|+
operator|(
name|str_32
operator|&
literal|1
operator|)
decl_stmt|;
name|symbol_table
operator|=
name|NULL
expr_stmt|;
name|symbol_table
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_zmalloc
argument_list|(
name|symbol_table_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbol_table
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|hdr
operator|=
operator|(
expr|struct
name|xcoff_ar_hdr_big
operator|*
operator|)
name|symbol_table
expr_stmt|;
name|PRINT20
argument_list|(
name|hdr
operator|->
name|size
argument_list|,
literal|8
operator|+
literal|8
operator|*
name|sym_32
operator|+
name|str_32
operator|+
operator|(
name|str_32
operator|&
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_64
condition|)
name|PRINT20
argument_list|(
name|hdr
operator|->
name|nextoff
argument_list|,
name|nextoff
operator|+
name|symbol_table_size
argument_list|)
expr_stmt|;
else|else
name|PRINT20
argument_list|(
name|hdr
operator|->
name|nextoff
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PRINT20
argument_list|(
name|hdr
operator|->
name|prevoff
argument_list|,
name|prevoff
argument_list|)
expr_stmt|;
name|PRINT12
argument_list|(
name|hdr
operator|->
name|date
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PRINT12
argument_list|(
name|hdr
operator|->
name|uid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PRINT12
argument_list|(
name|hdr
operator|->
name|gid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PRINT12
argument_list|(
name|hdr
operator|->
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PRINT4
argument_list|(
name|hdr
operator|->
name|namlen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
operator|=
name|symbol_table
operator|+
name|SIZEOF_AR_HDR_BIG
expr_stmt|;
name|memcpy
argument_list|(
name|st
argument_list|,
name|XCOFFARFMAG
argument_list|,
name|SXCOFFARFMAG
argument_list|)
expr_stmt|;
name|st
operator|+=
name|SXCOFFARFMAG
expr_stmt|;
name|bfd_h_put_64
argument_list|(
name|abfd
argument_list|,
name|sym_32
argument_list|,
name|st
argument_list|)
expr_stmt|;
name|st
operator|+=
literal|8
expr_stmt|;
comment|/* loop over the 32 bit offsets */
name|current_bfd
operator|=
name|abfd
operator|->
name|archive_head
expr_stmt|;
if|if
condition|(
name|current_bfd
operator|!=
name|NULL
condition|)
name|arch_info
operator|=
name|bfd_get_arch_info
argument_list|(
name|current_bfd
argument_list|)
expr_stmt|;
name|fileoff
operator|=
name|SIZEOF_AR_FILE_HDR_BIG
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|current_bfd
operator|!=
name|NULL
operator|&&
name|i
operator|<
name|orl_count
condition|)
block|{
while|while
condition|(
name|map
index|[
name|i
index|]
operator|.
name|u
operator|.
name|abfd
operator|==
name|current_bfd
condition|)
block|{
if|if
condition|(
name|arch_info
operator|->
name|bits_per_address
operator|==
literal|32
condition|)
block|{
name|bfd_h_put_64
argument_list|(
name|abfd
argument_list|,
name|fileoff
argument_list|,
name|st
argument_list|)
expr_stmt|;
name|st
operator|+=
literal|8
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
block|}
name|string_length
operator|=
name|strlen
argument_list|(
name|normalize_filename
argument_list|(
name|current_bfd
argument_list|)
argument_list|)
expr_stmt|;
name|string_length
operator|+=
name|string_length
operator|&
literal|1
expr_stmt|;
name|fileoff
operator|+=
operator|(
name|SIZEOF_AR_HDR_BIG
operator|+
name|string_length
operator|+
name|SXCOFFARFMAG
operator|+
name|arelt_size
argument_list|(
name|current_bfd
argument_list|)
operator|)
expr_stmt|;
name|fileoff
operator|+=
name|fileoff
operator|&
literal|1
expr_stmt|;
name|current_bfd
operator|=
name|current_bfd
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|current_bfd
operator|!=
name|NULL
condition|)
name|arch_info
operator|=
name|bfd_get_arch_info
argument_list|(
name|current_bfd
argument_list|)
expr_stmt|;
block|}
comment|/* loop over the 32 bit symbol names */
name|current_bfd
operator|=
name|abfd
operator|->
name|archive_head
expr_stmt|;
if|if
condition|(
name|current_bfd
operator|!=
name|NULL
condition|)
name|arch_info
operator|=
name|bfd_get_arch_info
argument_list|(
name|current_bfd
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|current_bfd
operator|!=
name|NULL
operator|&&
name|i
operator|<
name|orl_count
condition|)
block|{
while|while
condition|(
name|map
index|[
name|i
index|]
operator|.
name|u
operator|.
name|abfd
operator|==
name|current_bfd
condition|)
block|{
if|if
condition|(
name|arch_info
operator|->
name|bits_per_address
operator|==
literal|32
condition|)
block|{
name|string_length
operator|=
name|sprintf
argument_list|(
name|st
argument_list|,
literal|"%s"
argument_list|,
operator|*
name|map
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|st
operator|+=
name|string_length
operator|+
literal|1
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
block|}
name|current_bfd
operator|=
name|current_bfd
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|current_bfd
operator|!=
name|NULL
condition|)
name|arch_info
operator|=
name|bfd_get_arch_info
argument_list|(
name|current_bfd
argument_list|)
expr_stmt|;
block|}
name|bfd_bwrite
argument_list|(
name|symbol_table
argument_list|,
name|symbol_table_size
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|symbol_table
argument_list|)
expr_stmt|;
name|symbol_table
operator|=
name|NULL
expr_stmt|;
name|prevoff
operator|=
name|nextoff
expr_stmt|;
name|nextoff
operator|=
name|nextoff
operator|+
name|symbol_table_size
expr_stmt|;
block|}
else|else
name|PRINT20
argument_list|(
name|fhdr
operator|->
name|symoff
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_64
condition|)
block|{
name|struct
name|xcoff_ar_hdr_big
modifier|*
name|hdr
decl_stmt|;
name|bfd_byte
modifier|*
name|symbol_table
decl_stmt|;
name|bfd_byte
modifier|*
name|st
decl_stmt|;
name|file_ptr
name|fileoff
decl_stmt|;
name|bfd_vma
name|symbol_table_size
init|=
name|SIZEOF_AR_HDR_BIG
operator|+
name|SXCOFFARFMAG
operator|+
literal|8
operator|+
literal|8
operator|*
name|sym_64
operator|+
name|str_64
operator|+
operator|(
name|str_64
operator|&
literal|1
operator|)
decl_stmt|;
name|symbol_table
operator|=
name|NULL
expr_stmt|;
name|symbol_table
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_zmalloc
argument_list|(
name|symbol_table_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbol_table
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|hdr
operator|=
operator|(
expr|struct
name|xcoff_ar_hdr_big
operator|*
operator|)
name|symbol_table
expr_stmt|;
name|PRINT20
argument_list|(
name|hdr
operator|->
name|size
argument_list|,
literal|8
operator|+
literal|8
operator|*
name|sym_64
operator|+
name|str_64
operator|+
operator|(
name|str_64
operator|&
literal|1
operator|)
argument_list|)
expr_stmt|;
name|PRINT20
argument_list|(
name|hdr
operator|->
name|nextoff
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PRINT20
argument_list|(
name|hdr
operator|->
name|prevoff
argument_list|,
name|prevoff
argument_list|)
expr_stmt|;
name|PRINT12
argument_list|(
name|hdr
operator|->
name|date
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PRINT12
argument_list|(
name|hdr
operator|->
name|uid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PRINT12
argument_list|(
name|hdr
operator|->
name|gid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PRINT12
argument_list|(
name|hdr
operator|->
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PRINT4
argument_list|(
name|hdr
operator|->
name|namlen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
operator|=
name|symbol_table
operator|+
name|SIZEOF_AR_HDR_BIG
expr_stmt|;
name|memcpy
argument_list|(
name|st
argument_list|,
name|XCOFFARFMAG
argument_list|,
name|SXCOFFARFMAG
argument_list|)
expr_stmt|;
name|st
operator|+=
name|SXCOFFARFMAG
expr_stmt|;
name|bfd_h_put_64
argument_list|(
name|abfd
argument_list|,
name|sym_64
argument_list|,
name|st
argument_list|)
expr_stmt|;
name|st
operator|+=
literal|8
expr_stmt|;
comment|/* loop over the 64 bit offsets */
name|current_bfd
operator|=
name|abfd
operator|->
name|archive_head
expr_stmt|;
if|if
condition|(
name|current_bfd
operator|!=
name|NULL
condition|)
name|arch_info
operator|=
name|bfd_get_arch_info
argument_list|(
name|current_bfd
argument_list|)
expr_stmt|;
name|fileoff
operator|=
name|SIZEOF_AR_FILE_HDR_BIG
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|current_bfd
operator|!=
name|NULL
operator|&&
name|i
operator|<
name|orl_count
condition|)
block|{
while|while
condition|(
name|map
index|[
name|i
index|]
operator|.
name|u
operator|.
name|abfd
operator|==
name|current_bfd
condition|)
block|{
if|if
condition|(
name|arch_info
operator|->
name|bits_per_address
operator|==
literal|64
condition|)
block|{
name|bfd_h_put_64
argument_list|(
name|abfd
argument_list|,
name|fileoff
argument_list|,
name|st
argument_list|)
expr_stmt|;
name|st
operator|+=
literal|8
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
block|}
name|string_length
operator|=
name|strlen
argument_list|(
name|normalize_filename
argument_list|(
name|current_bfd
argument_list|)
argument_list|)
expr_stmt|;
name|string_length
operator|+=
name|string_length
operator|&
literal|1
expr_stmt|;
name|fileoff
operator|+=
operator|(
name|SIZEOF_AR_HDR_BIG
operator|+
name|string_length
operator|+
name|SXCOFFARFMAG
operator|+
name|arelt_size
argument_list|(
name|current_bfd
argument_list|)
operator|)
expr_stmt|;
name|fileoff
operator|+=
name|fileoff
operator|&
literal|1
expr_stmt|;
name|current_bfd
operator|=
name|current_bfd
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|current_bfd
operator|!=
name|NULL
condition|)
name|arch_info
operator|=
name|bfd_get_arch_info
argument_list|(
name|current_bfd
argument_list|)
expr_stmt|;
block|}
comment|/* loop over the 64 bit symbol names */
name|current_bfd
operator|=
name|abfd
operator|->
name|archive_head
expr_stmt|;
if|if
condition|(
name|current_bfd
operator|!=
name|NULL
condition|)
name|arch_info
operator|=
name|bfd_get_arch_info
argument_list|(
name|current_bfd
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|current_bfd
operator|!=
name|NULL
operator|&&
name|i
operator|<
name|orl_count
condition|)
block|{
while|while
condition|(
name|map
index|[
name|i
index|]
operator|.
name|u
operator|.
name|abfd
operator|==
name|current_bfd
condition|)
block|{
if|if
condition|(
name|arch_info
operator|->
name|bits_per_address
operator|==
literal|64
condition|)
block|{
name|string_length
operator|=
name|sprintf
argument_list|(
name|st
argument_list|,
literal|"%s"
argument_list|,
operator|*
name|map
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|st
operator|+=
name|string_length
operator|+
literal|1
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
block|}
name|current_bfd
operator|=
name|current_bfd
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|current_bfd
operator|!=
name|NULL
condition|)
name|arch_info
operator|=
name|bfd_get_arch_info
argument_list|(
name|current_bfd
argument_list|)
expr_stmt|;
block|}
name|bfd_bwrite
argument_list|(
name|symbol_table
argument_list|,
name|symbol_table_size
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|symbol_table
argument_list|)
expr_stmt|;
name|symbol_table
operator|=
name|NULL
expr_stmt|;
name|PRINT20
argument_list|(
name|fhdr
operator|->
name|symoff64
argument_list|,
name|nextoff
argument_list|)
expr_stmt|;
block|}
else|else
name|PRINT20
argument_list|(
name|fhdr
operator|->
name|symoff64
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|_bfd_xcoff_write_armap
parameter_list|(
name|abfd
parameter_list|,
name|elength
parameter_list|,
name|map
parameter_list|,
name|orl_count
parameter_list|,
name|stridx
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|unsigned
name|int
name|elength
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|orl
modifier|*
name|map
decl_stmt|;
name|unsigned
name|int
name|orl_count
decl_stmt|;
name|int
name|stridx
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|xcoff_big_format_p
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|xcoff_write_armap_old
argument_list|(
name|abfd
argument_list|,
name|elength
argument_list|,
name|map
argument_list|,
name|orl_count
argument_list|,
name|stridx
argument_list|)
return|;
else|else
return|return
name|xcoff_write_armap_big
argument_list|(
name|abfd
argument_list|,
name|elength
argument_list|,
name|map
argument_list|,
name|orl_count
argument_list|,
name|stridx
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Write out an XCOFF archive.  We always write an entire archive,    rather than fussing with the freelist and so forth.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|xcoff_write_archive_contents_old
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|xcoff_ar_file_hdr
name|fhdr
decl_stmt|;
name|bfd_size_type
name|count
decl_stmt|;
name|bfd_size_type
name|total_namlen
decl_stmt|;
name|file_ptr
modifier|*
name|offsets
decl_stmt|;
name|bfd_boolean
name|makemap
decl_stmt|;
name|bfd_boolean
name|hasobjects
decl_stmt|;
name|ufile_ptr
name|prevoff
decl_stmt|,
name|nextoff
decl_stmt|;
name|bfd
modifier|*
name|sub
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|struct
name|xcoff_ar_hdr
name|ahdr
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|decbuf
index|[
name|XCOFFARMAG_ELEMENT_SIZE
operator|+
literal|1
index|]
decl_stmt|;
name|memset
argument_list|(
operator|&
name|fhdr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|fhdr
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|fhdr
operator|.
name|magic
argument_list|,
name|XCOFFARMAG
argument_list|,
name|SXCOFFARMAG
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|fhdr
operator|.
name|firstmemoff
argument_list|,
literal|"%d"
argument_list|,
name|SIZEOF_AR_FILE_HDR
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|fhdr
operator|.
name|freeoff
argument_list|,
literal|"%d"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|total_namlen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|sub
operator|=
name|abfd
operator|->
name|archive_head
init|;
name|sub
operator|!=
name|NULL
condition|;
name|sub
operator|=
name|sub
operator|->
name|next
control|)
block|{
operator|++
name|count
expr_stmt|;
name|total_namlen
operator|+=
name|strlen
argument_list|(
name|normalize_filename
argument_list|(
name|sub
argument_list|)
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
name|offsets
operator|=
operator|(
name|file_ptr
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
name|file_ptr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|offsets
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
name|SIZEOF_AR_FILE_HDR
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
name|makemap
operator|=
name|bfd_has_map
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|hasobjects
operator|=
name|FALSE
expr_stmt|;
name|prevoff
operator|=
literal|0
expr_stmt|;
name|nextoff
operator|=
name|SIZEOF_AR_FILE_HDR
expr_stmt|;
for|for
control|(
name|sub
operator|=
name|abfd
operator|->
name|archive_head
operator|,
name|i
operator|=
literal|0
init|;
name|sub
operator|!=
name|NULL
condition|;
name|sub
operator|=
name|sub
operator|->
name|next
operator|,
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bfd_size_type
name|namlen
decl_stmt|;
name|struct
name|xcoff_ar_hdr
modifier|*
name|ahdrp
decl_stmt|;
name|bfd_size_type
name|remaining
decl_stmt|;
if|if
condition|(
name|makemap
operator|&&
operator|!
name|hasobjects
condition|)
block|{
if|if
condition|(
name|bfd_check_format
argument_list|(
name|sub
argument_list|,
name|bfd_object
argument_list|)
condition|)
name|hasobjects
operator|=
name|TRUE
expr_stmt|;
block|}
name|name
operator|=
name|normalize_filename
argument_list|(
name|sub
argument_list|)
expr_stmt|;
name|namlen
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sub
operator|->
name|arelt_data
operator|!=
name|NULL
condition|)
name|ahdrp
operator|=
name|arch_xhdr
argument_list|(
name|sub
argument_list|)
expr_stmt|;
else|else
name|ahdrp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ahdrp
operator|==
name|NULL
condition|)
block|{
name|struct
name|stat
name|s
decl_stmt|;
name|memset
argument_list|(
operator|&
name|ahdr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ahdr
argument_list|)
expr_stmt|;
name|ahdrp
operator|=
operator|&
name|ahdr
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|bfd_get_filename
argument_list|(
name|sub
argument_list|)
argument_list|,
operator|&
name|s
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|sprintf
argument_list|(
name|ahdrp
operator|->
name|size
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|s
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ahdrp
operator|->
name|date
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|s
operator|.
name|st_mtime
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ahdrp
operator|->
name|uid
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|s
operator|.
name|st_uid
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ahdrp
operator|->
name|gid
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|s
operator|.
name|st_gid
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ahdrp
operator|->
name|mode
argument_list|,
literal|"%o"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|s
operator|.
name|st_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|sub
operator|->
name|arelt_data
operator|==
name|NULL
condition|)
block|{
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|areltdata
argument_list|)
expr_stmt|;
name|sub
operator|->
name|arelt_data
operator|=
name|bfd_alloc
argument_list|(
name|sub
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|sub
operator|->
name|arelt_data
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
name|arch_eltdata
argument_list|(
name|sub
argument_list|)
operator|->
name|parsed_size
operator|=
name|s
operator|.
name|st_size
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|ahdrp
operator|->
name|prevoff
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|prevoff
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ahdrp
operator|->
name|namlen
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|namlen
argument_list|)
expr_stmt|;
comment|/* If the length of the name is odd, we write out the null byte 	 after the name as well.  */
name|namlen
operator|=
operator|(
name|namlen
operator|+
literal|1
operator|)
operator|&
operator|~
operator|(
name|bfd_size_type
operator|)
literal|1
expr_stmt|;
name|remaining
operator|=
name|arelt_size
argument_list|(
name|sub
argument_list|)
expr_stmt|;
name|size
operator|=
operator|(
name|SIZEOF_AR_HDR
operator|+
name|namlen
operator|+
name|SXCOFFARFMAG
operator|+
name|remaining
operator|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|nextoff
operator|==
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|offsets
index|[
name|i
index|]
operator|=
name|nextoff
expr_stmt|;
name|prevoff
operator|=
name|nextoff
expr_stmt|;
name|nextoff
operator|+=
name|size
operator|+
operator|(
name|size
operator|&
literal|1
operator|)
expr_stmt|;
name|sprintf
argument_list|(
name|ahdrp
operator|->
name|nextoff
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|nextoff
argument_list|)
expr_stmt|;
comment|/* We need spaces, not null bytes, in the header.  */
for|for
control|(
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|ahdrp
init|;
name|p
operator|<
operator|(
name|char
operator|*
operator|)
name|ahdrp
operator|+
name|SIZEOF_AR_HDR
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
operator|*
name|p
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
operator|(
name|bfd_bwrite
argument_list|(
operator|(
name|PTR
operator|)
name|ahdrp
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|SIZEOF_AR_HDR
argument_list|,
name|abfd
argument_list|)
operator|!=
name|SIZEOF_AR_HDR
operator|)
operator|||
name|bfd_bwrite
argument_list|(
operator|(
name|PTR
operator|)
name|name
argument_list|,
name|namlen
argument_list|,
name|abfd
argument_list|)
operator|!=
name|namlen
operator|||
name|bfd_bwrite
argument_list|(
operator|(
name|PTR
operator|)
name|XCOFFARFMAG
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|SXCOFFARFMAG
argument_list|,
name|abfd
argument_list|)
operator|!=
name|SXCOFFARFMAG
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|sub
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|do_copy
argument_list|(
name|abfd
argument_list|,
name|sub
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|do_pad
argument_list|(
name|abfd
argument_list|,
name|size
operator|&
literal|1
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
name|sprintf
argument_list|(
name|fhdr
operator|.
name|lastmemoff
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|prevoff
argument_list|)
expr_stmt|;
comment|/* Write out the member table.  */
name|BFD_ASSERT
argument_list|(
name|nextoff
operator|==
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|fhdr
operator|.
name|memoff
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|nextoff
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ahdr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ahdr
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ahdr
operator|.
name|size
argument_list|,
literal|"%ld"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|XCOFFARMAG_ELEMENT_SIZE
operator|+
name|count
operator|*
name|XCOFFARMAG_ELEMENT_SIZE
operator|+
name|total_namlen
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ahdr
operator|.
name|prevoff
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|prevoff
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ahdr
operator|.
name|date
argument_list|,
literal|"%d"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ahdr
operator|.
name|uid
argument_list|,
literal|"%d"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ahdr
operator|.
name|gid
argument_list|,
literal|"%d"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ahdr
operator|.
name|mode
argument_list|,
literal|"%d"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ahdr
operator|.
name|namlen
argument_list|,
literal|"%d"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|size
operator|=
operator|(
name|SIZEOF_AR_HDR
operator|+
name|XCOFFARMAG_ELEMENT_SIZE
operator|+
name|count
operator|*
name|XCOFFARMAG_ELEMENT_SIZE
operator|+
name|total_namlen
operator|+
name|SXCOFFARFMAG
operator|)
expr_stmt|;
name|prevoff
operator|=
name|nextoff
expr_stmt|;
name|nextoff
operator|+=
name|size
operator|+
operator|(
name|size
operator|&
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|makemap
operator|&&
name|hasobjects
condition|)
name|sprintf
argument_list|(
name|ahdr
operator|.
name|nextoff
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|nextoff
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|ahdr
operator|.
name|nextoff
argument_list|,
literal|"%d"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* We need spaces, not null bytes, in the header.  */
for|for
control|(
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|ahdr
init|;
name|p
operator|<
operator|(
name|char
operator|*
operator|)
operator|&
name|ahdr
operator|+
name|SIZEOF_AR_HDR
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
operator|*
name|p
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
operator|(
name|bfd_bwrite
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|ahdr
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|SIZEOF_AR_HDR
argument_list|,
name|abfd
argument_list|)
operator|!=
name|SIZEOF_AR_HDR
operator|)
operator|||
operator|(
name|bfd_bwrite
argument_list|(
operator|(
name|PTR
operator|)
name|XCOFFARFMAG
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|SXCOFFARFMAG
argument_list|,
name|abfd
argument_list|)
operator|!=
name|SXCOFFARFMAG
operator|)
condition|)
return|return
name|FALSE
return|;
name|sprintf
argument_list|(
name|decbuf
argument_list|,
literal|"%-12ld"
argument_list|,
operator|(
name|long
operator|)
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
operator|(
name|PTR
operator|)
name|decbuf
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|XCOFFARMAG_ELEMENT_SIZE
argument_list|,
name|abfd
argument_list|)
operator|!=
name|XCOFFARMAG_ELEMENT_SIZE
condition|)
return|return
name|FALSE
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|size_t
operator|)
name|count
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|decbuf
argument_list|,
literal|"%-12ld"
argument_list|,
operator|(
name|long
operator|)
name|offsets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
operator|(
name|PTR
operator|)
name|decbuf
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|XCOFFARMAG_ELEMENT_SIZE
argument_list|,
name|abfd
argument_list|)
operator|!=
name|XCOFFARMAG_ELEMENT_SIZE
condition|)
return|return
name|FALSE
return|;
block|}
for|for
control|(
name|sub
operator|=
name|abfd
operator|->
name|archive_head
init|;
name|sub
operator|!=
name|NULL
condition|;
name|sub
operator|=
name|sub
operator|->
name|next
control|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bfd_size_type
name|namlen
decl_stmt|;
name|name
operator|=
name|normalize_filename
argument_list|(
name|sub
argument_list|)
expr_stmt|;
name|namlen
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
operator|(
name|PTR
operator|)
name|name
argument_list|,
name|namlen
operator|+
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|namlen
operator|+
literal|1
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|do_pad
argument_list|(
name|abfd
argument_list|,
name|size
operator|&
literal|1
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Write out the armap, if appropriate.  */
if|if
condition|(
operator|!
name|makemap
operator|||
operator|!
name|hasobjects
condition|)
name|sprintf
argument_list|(
name|fhdr
operator|.
name|symoff
argument_list|,
literal|"%d"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|BFD_ASSERT
argument_list|(
name|nextoff
operator|==
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|fhdr
operator|.
name|symoff
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|nextoff
argument_list|)
expr_stmt|;
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|tdata
operator|=
operator|(
name|PTR
operator|)
operator|&
name|fhdr
expr_stmt|;
if|if
condition|(
operator|!
name|_bfd_compute_and_write_armap
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Write out the archive file header.  */
comment|/* We need spaces, not null bytes, in the header.  */
for|for
control|(
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|fhdr
init|;
name|p
operator|<
operator|(
name|char
operator|*
operator|)
operator|&
name|fhdr
operator|+
name|SIZEOF_AR_FILE_HDR
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
operator|*
name|p
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|bfd_bwrite
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|fhdr
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|SIZEOF_AR_FILE_HDR
argument_list|,
name|abfd
argument_list|)
operator|!=
name|SIZEOF_AR_FILE_HDR
operator|)
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|xcoff_write_archive_contents_big
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|xcoff_ar_file_hdr_big
name|fhdr
decl_stmt|;
name|bfd_size_type
name|count
decl_stmt|;
name|bfd_size_type
name|total_namlen
decl_stmt|;
name|file_ptr
modifier|*
name|offsets
decl_stmt|;
name|bfd_boolean
name|makemap
decl_stmt|;
name|bfd_boolean
name|hasobjects
decl_stmt|;
name|ufile_ptr
name|prevoff
decl_stmt|,
name|nextoff
decl_stmt|;
name|bfd
modifier|*
name|current_bfd
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|struct
name|xcoff_ar_hdr_big
modifier|*
name|hdr
decl_stmt|,
name|ahdr
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
name|bfd_byte
modifier|*
name|member_table
decl_stmt|,
modifier|*
name|mt
decl_stmt|;
name|bfd_vma
name|member_table_size
decl_stmt|;
name|memset
argument_list|(
operator|&
name|fhdr
argument_list|,
literal|0
argument_list|,
name|SIZEOF_AR_FILE_HDR_BIG
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|fhdr
operator|.
name|magic
argument_list|,
name|XCOFFARMAGBIG
argument_list|,
name|SXCOFFARMAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
name|SIZEOF_AR_FILE_HDR_BIG
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
comment|/* Calculate count and total_namlen.  */
name|makemap
operator|=
name|bfd_has_map
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|hasobjects
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|current_bfd
operator|=
name|abfd
operator|->
name|archive_head
operator|,
name|count
operator|=
literal|0
operator|,
name|total_namlen
operator|=
literal|0
init|;
name|current_bfd
operator|!=
name|NULL
condition|;
name|current_bfd
operator|=
name|current_bfd
operator|->
name|next
operator|,
name|count
operator|++
control|)
block|{
name|total_namlen
operator|+=
name|strlen
argument_list|(
name|normalize_filename
argument_list|(
name|current_bfd
argument_list|)
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|makemap
operator|&&
operator|!
name|hasobjects
operator|&&
name|bfd_check_format
argument_list|(
name|current_bfd
argument_list|,
name|bfd_object
argument_list|)
condition|)
name|hasobjects
operator|=
name|TRUE
expr_stmt|;
block|}
name|offsets
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|count
condition|)
block|{
name|offsets
operator|=
operator|(
name|file_ptr
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
name|file_ptr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|offsets
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
name|prevoff
operator|=
literal|0
expr_stmt|;
name|nextoff
operator|=
name|SIZEOF_AR_FILE_HDR_BIG
expr_stmt|;
for|for
control|(
name|current_bfd
operator|=
name|abfd
operator|->
name|archive_head
operator|,
name|i
operator|=
literal|0
init|;
name|current_bfd
operator|!=
name|NULL
condition|;
name|current_bfd
operator|=
name|current_bfd
operator|->
name|next
operator|,
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bfd_size_type
name|namlen
decl_stmt|;
name|struct
name|xcoff_ar_hdr_big
modifier|*
name|ahdrp
decl_stmt|;
name|bfd_size_type
name|remaining
decl_stmt|;
name|name
operator|=
name|normalize_filename
argument_list|(
name|current_bfd
argument_list|)
expr_stmt|;
name|namlen
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_bfd
operator|->
name|arelt_data
operator|!=
name|NULL
condition|)
name|ahdrp
operator|=
name|arch_xhdr_big
argument_list|(
name|current_bfd
argument_list|)
expr_stmt|;
else|else
name|ahdrp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ahdrp
operator|==
name|NULL
condition|)
block|{
name|struct
name|stat
name|s
decl_stmt|;
name|ahdrp
operator|=
operator|&
name|ahdr
expr_stmt|;
comment|/* XXX This should actually be a call to stat64 (at least on 	     32-bit machines). 	     XXX This call will fail if the original object is not found.  */
if|if
condition|(
name|stat
argument_list|(
name|bfd_get_filename
argument_list|(
name|current_bfd
argument_list|)
argument_list|,
operator|&
name|s
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|PRINT20
argument_list|(
name|ahdrp
operator|->
name|size
argument_list|,
name|s
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|PRINT12
argument_list|(
name|ahdrp
operator|->
name|date
argument_list|,
name|s
operator|.
name|st_mtime
argument_list|)
expr_stmt|;
name|PRINT12
argument_list|(
name|ahdrp
operator|->
name|uid
argument_list|,
name|s
operator|.
name|st_uid
argument_list|)
expr_stmt|;
name|PRINT12
argument_list|(
name|ahdrp
operator|->
name|gid
argument_list|,
name|s
operator|.
name|st_gid
argument_list|)
expr_stmt|;
name|PRINT12_OCTAL
argument_list|(
name|ahdrp
operator|->
name|mode
argument_list|,
name|s
operator|.
name|st_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_bfd
operator|->
name|arelt_data
operator|==
name|NULL
condition|)
block|{
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|areltdata
argument_list|)
expr_stmt|;
name|current_bfd
operator|->
name|arelt_data
operator|=
name|bfd_alloc
argument_list|(
name|current_bfd
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_bfd
operator|->
name|arelt_data
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
name|arch_eltdata
argument_list|(
name|current_bfd
argument_list|)
operator|->
name|parsed_size
operator|=
name|s
operator|.
name|st_size
expr_stmt|;
block|}
name|PRINT20
argument_list|(
name|ahdrp
operator|->
name|prevoff
argument_list|,
name|prevoff
argument_list|)
expr_stmt|;
name|PRINT4
argument_list|(
name|ahdrp
operator|->
name|namlen
argument_list|,
name|namlen
argument_list|)
expr_stmt|;
comment|/* If the length of the name is odd, we write out the null byte 	 after the name as well.  */
name|namlen
operator|=
operator|(
name|namlen
operator|+
literal|1
operator|)
operator|&
operator|~
operator|(
name|bfd_size_type
operator|)
literal|1
expr_stmt|;
name|remaining
operator|=
name|arelt_size
argument_list|(
name|current_bfd
argument_list|)
expr_stmt|;
name|size
operator|=
operator|(
name|SIZEOF_AR_HDR_BIG
operator|+
name|namlen
operator|+
name|SXCOFFARFMAG
operator|+
name|remaining
operator|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|nextoff
operator|==
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check for xcoff shared objects. 	 Their text section needs to be aligned wrt the archive file position. 	 This requires extra padding before the archive header.  */
if|if
condition|(
operator|!
name|do_shared_object_padding
argument_list|(
name|abfd
argument_list|,
name|current_bfd
argument_list|,
operator|&
name|nextoff
argument_list|,
name|SIZEOF_AR_HDR_BIG
operator|+
name|namlen
operator|+
name|SXCOFFARFMAG
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|offsets
index|[
name|i
index|]
operator|=
name|nextoff
expr_stmt|;
name|prevoff
operator|=
name|nextoff
expr_stmt|;
name|nextoff
operator|+=
name|size
operator|+
operator|(
name|size
operator|&
literal|1
operator|)
expr_stmt|;
name|PRINT20
argument_list|(
name|ahdrp
operator|->
name|nextoff
argument_list|,
name|nextoff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bfd_bwrite
argument_list|(
operator|(
name|PTR
operator|)
name|ahdrp
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|SIZEOF_AR_HDR_BIG
argument_list|,
name|abfd
argument_list|)
operator|!=
name|SIZEOF_AR_HDR_BIG
operator|)
operator|||
name|bfd_bwrite
argument_list|(
operator|(
name|PTR
operator|)
name|name
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|namlen
argument_list|,
name|abfd
argument_list|)
operator|!=
name|namlen
operator|||
operator|(
name|bfd_bwrite
argument_list|(
operator|(
name|PTR
operator|)
name|XCOFFARFMAG
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|SXCOFFARFMAG
argument_list|,
name|abfd
argument_list|)
operator|!=
name|SXCOFFARFMAG
operator|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|current_bfd
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|do_copy
argument_list|(
name|abfd
argument_list|,
name|current_bfd
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|do_pad
argument_list|(
name|abfd
argument_list|,
name|size
operator|&
literal|1
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|count
condition|)
block|{
name|PRINT20
argument_list|(
name|fhdr
operator|.
name|firstmemoff
argument_list|,
name|offsets
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|PRINT20
argument_list|(
name|fhdr
operator|.
name|lastmemoff
argument_list|,
name|prevoff
argument_list|)
expr_stmt|;
block|}
comment|/* Write out the member table.      Layout :       standard big archive header      0x0000		      ar_size	[0x14]      0x0014		      ar_nxtmem [0x14]      0x0028		      ar_prvmem [0x14]      0x003C		      ar_date	[0x0C]      0x0048		      ar_uid	[0x0C]      0x0054		      ar_gid	[0x0C]      0x0060		      ar_mod	[0x0C]      0x006C		      ar_namelen[0x04]      0x0070		      ar_fmag	[0x02]       Member table      0x0072		      count	[0x14]      0x0086		      offsets	[0x14 * counts]      0x0086 + 0x14 * counts   names	[??]      ??			      pad to even bytes.    */
name|BFD_ASSERT
argument_list|(
name|nextoff
operator|==
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|member_table_size
operator|=
operator|(
name|SIZEOF_AR_HDR_BIG
operator|+
name|SXCOFFARFMAG
operator|+
name|XCOFFARMAGBIG_ELEMENT_SIZE
operator|+
name|count
operator|*
name|XCOFFARMAGBIG_ELEMENT_SIZE
operator|+
name|total_namlen
operator|)
expr_stmt|;
name|member_table_size
operator|+=
name|member_table_size
operator|&
literal|1
expr_stmt|;
name|member_table
operator|=
name|NULL
expr_stmt|;
name|member_table
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_zmalloc
argument_list|(
name|member_table_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|member_table
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|hdr
operator|=
operator|(
expr|struct
name|xcoff_ar_hdr_big
operator|*
operator|)
name|member_table
expr_stmt|;
name|PRINT20
argument_list|(
name|hdr
operator|->
name|size
argument_list|,
operator|(
name|XCOFFARMAGBIG_ELEMENT_SIZE
operator|+
name|count
operator|*
name|XCOFFARMAGBIG_ELEMENT_SIZE
operator|+
name|total_namlen
operator|+
operator|(
name|total_namlen
operator|&
literal|1
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|makemap
operator|&&
name|hasobjects
condition|)
name|PRINT20
argument_list|(
name|hdr
operator|->
name|nextoff
argument_list|,
name|nextoff
operator|+
name|member_table_size
argument_list|)
expr_stmt|;
else|else
name|PRINT20
argument_list|(
name|hdr
operator|->
name|nextoff
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PRINT20
argument_list|(
name|hdr
operator|->
name|prevoff
argument_list|,
name|prevoff
argument_list|)
expr_stmt|;
name|PRINT12
argument_list|(
name|hdr
operator|->
name|date
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PRINT12
argument_list|(
name|hdr
operator|->
name|uid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PRINT12
argument_list|(
name|hdr
operator|->
name|gid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PRINT12
argument_list|(
name|hdr
operator|->
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PRINT4
argument_list|(
name|hdr
operator|->
name|namlen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mt
operator|=
name|member_table
operator|+
name|SIZEOF_AR_HDR_BIG
expr_stmt|;
name|memcpy
argument_list|(
name|mt
argument_list|,
name|XCOFFARFMAG
argument_list|,
name|SXCOFFARFMAG
argument_list|)
expr_stmt|;
name|mt
operator|+=
name|SXCOFFARFMAG
expr_stmt|;
name|PRINT20
argument_list|(
name|mt
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|mt
operator|+=
name|XCOFFARMAGBIG_ELEMENT_SIZE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|size_t
operator|)
name|count
condition|;
name|i
operator|++
control|)
block|{
name|PRINT20
argument_list|(
name|mt
argument_list|,
name|offsets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|mt
operator|+=
name|XCOFFARMAGBIG_ELEMENT_SIZE
expr_stmt|;
block|}
if|if
condition|(
name|count
condition|)
block|{
name|free
argument_list|(
name|offsets
argument_list|)
expr_stmt|;
name|offsets
operator|=
name|NULL
expr_stmt|;
block|}
for|for
control|(
name|current_bfd
operator|=
name|abfd
operator|->
name|archive_head
init|;
name|current_bfd
operator|!=
name|NULL
condition|;
name|current_bfd
operator|=
name|current_bfd
operator|->
name|next
control|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|size_t
name|namlen
decl_stmt|;
name|name
operator|=
name|normalize_filename
argument_list|(
name|current_bfd
argument_list|)
expr_stmt|;
name|namlen
operator|=
name|sprintf
argument_list|(
name|mt
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|mt
operator|+=
name|namlen
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|bfd_bwrite
argument_list|(
name|member_table
argument_list|,
name|member_table_size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|member_table_size
condition|)
return|return
name|FALSE
return|;
name|free
argument_list|(
name|member_table
argument_list|)
expr_stmt|;
name|member_table
operator|=
name|NULL
expr_stmt|;
name|PRINT20
argument_list|(
name|fhdr
operator|.
name|memoff
argument_list|,
name|nextoff
argument_list|)
expr_stmt|;
name|prevoff
operator|=
name|nextoff
expr_stmt|;
name|nextoff
operator|+=
name|member_table_size
expr_stmt|;
comment|/* Write out the armap, if appropriate.  */
if|if
condition|(
operator|!
name|makemap
operator|||
operator|!
name|hasobjects
condition|)
name|PRINT20
argument_list|(
name|fhdr
operator|.
name|symoff
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|BFD_ASSERT
argument_list|(
name|nextoff
operator|==
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Save nextoff in fhdr.symoff so the armap routine can use it.  */
name|PRINT20
argument_list|(
name|fhdr
operator|.
name|symoff
argument_list|,
name|nextoff
argument_list|)
expr_stmt|;
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|tdata
operator|=
operator|(
name|PTR
operator|)
operator|&
name|fhdr
expr_stmt|;
if|if
condition|(
operator|!
name|_bfd_compute_and_write_armap
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Write out the archive file header.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|bfd_bwrite
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|fhdr
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|SIZEOF_AR_FILE_HDR_BIG
argument_list|,
name|abfd
argument_list|)
operator|!=
name|SIZEOF_AR_FILE_HDR_BIG
operator|)
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|_bfd_xcoff_write_archive_contents
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|xcoff_big_format_p
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|xcoff_write_archive_contents_old
argument_list|(
name|abfd
argument_list|)
return|;
else|else
return|return
name|xcoff_write_archive_contents_big
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* We can't use the usual coff_sizeof_headers routine, because AIX    always uses an a.out header.  */
end_comment

begin_function
name|int
name|_bfd_xcoff_sizeof_headers
parameter_list|(
name|abfd
parameter_list|,
name|reloc
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|bfd_boolean
name|reloc
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|size
decl_stmt|;
name|size
operator|=
name|FILHSZ
expr_stmt|;
if|if
condition|(
name|xcoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|full_aouthdr
condition|)
name|size
operator|+=
name|AOUTSZ
expr_stmt|;
else|else
name|size
operator|+=
name|SMALL_AOUTSZ
expr_stmt|;
name|size
operator|+=
name|abfd
operator|->
name|section_count
operator|*
name|SCNHSZ
expr_stmt|;
return|return
name|size
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Routines to swap information in the XCOFF .loader section.  If we    ever need to write an XCOFF loader, this stuff will need to be    moved to another file shared by the linker (which XCOFF calls the    ``binder'') and the loader.  */
end_comment

begin_comment
comment|/* Swap in the ldhdr structure.  */
end_comment

begin_function
specifier|static
name|void
name|xcoff_swap_ldhdr_in
parameter_list|(
name|abfd
parameter_list|,
name|s
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|PTR
name|s
decl_stmt|;
name|struct
name|internal_ldhdr
modifier|*
name|dst
decl_stmt|;
block|{
specifier|const
name|struct
name|external_ldhdr
modifier|*
name|src
init|=
operator|(
specifier|const
expr|struct
name|external_ldhdr
operator|*
operator|)
name|s
decl_stmt|;
name|dst
operator|->
name|l_version
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_version
argument_list|)
expr_stmt|;
name|dst
operator|->
name|l_nsyms
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_nsyms
argument_list|)
expr_stmt|;
name|dst
operator|->
name|l_nreloc
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_nreloc
argument_list|)
expr_stmt|;
name|dst
operator|->
name|l_istlen
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_istlen
argument_list|)
expr_stmt|;
name|dst
operator|->
name|l_nimpid
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_nimpid
argument_list|)
expr_stmt|;
name|dst
operator|->
name|l_impoff
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_impoff
argument_list|)
expr_stmt|;
name|dst
operator|->
name|l_stlen
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_stlen
argument_list|)
expr_stmt|;
name|dst
operator|->
name|l_stoff
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_stoff
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Swap out the ldhdr structure.  */
end_comment

begin_function
specifier|static
name|void
name|xcoff_swap_ldhdr_out
parameter_list|(
name|abfd
parameter_list|,
name|src
parameter_list|,
name|d
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|struct
name|internal_ldhdr
modifier|*
name|src
decl_stmt|;
name|PTR
name|d
decl_stmt|;
block|{
name|struct
name|external_ldhdr
modifier|*
name|dst
init|=
operator|(
expr|struct
name|external_ldhdr
operator|*
operator|)
name|d
decl_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|src
operator|->
name|l_version
argument_list|,
name|dst
operator|->
name|l_version
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_nsyms
argument_list|,
name|dst
operator|->
name|l_nsyms
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_nreloc
argument_list|,
name|dst
operator|->
name|l_nreloc
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_istlen
argument_list|,
name|dst
operator|->
name|l_istlen
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_nimpid
argument_list|,
name|dst
operator|->
name|l_nimpid
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_impoff
argument_list|,
name|dst
operator|->
name|l_impoff
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_stlen
argument_list|,
name|dst
operator|->
name|l_stlen
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_stoff
argument_list|,
name|dst
operator|->
name|l_stoff
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Swap in the ldsym structure.  */
end_comment

begin_function
specifier|static
name|void
name|xcoff_swap_ldsym_in
parameter_list|(
name|abfd
parameter_list|,
name|s
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|PTR
name|s
decl_stmt|;
name|struct
name|internal_ldsym
modifier|*
name|dst
decl_stmt|;
block|{
specifier|const
name|struct
name|external_ldsym
modifier|*
name|src
init|=
operator|(
specifier|const
expr|struct
name|external_ldsym
operator|*
operator|)
name|s
decl_stmt|;
if|if
condition|(
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|_l
operator|.
name|_l_l
operator|.
name|_l_zeroes
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|memcpy
argument_list|(
name|dst
operator|->
name|_l
operator|.
name|_l_name
argument_list|,
name|src
operator|->
name|_l
operator|.
name|_l_name
argument_list|,
name|SYMNMLEN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dst
operator|->
name|_l
operator|.
name|_l_l
operator|.
name|_l_zeroes
operator|=
literal|0
expr_stmt|;
name|dst
operator|->
name|_l
operator|.
name|_l_l
operator|.
name|_l_offset
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|_l
operator|.
name|_l_l
operator|.
name|_l_offset
argument_list|)
expr_stmt|;
block|}
name|dst
operator|->
name|l_value
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_value
argument_list|)
expr_stmt|;
name|dst
operator|->
name|l_scnum
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_scnum
argument_list|)
expr_stmt|;
name|dst
operator|->
name|l_smtype
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_smtype
argument_list|)
expr_stmt|;
name|dst
operator|->
name|l_smclas
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_smclas
argument_list|)
expr_stmt|;
name|dst
operator|->
name|l_ifile
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_ifile
argument_list|)
expr_stmt|;
name|dst
operator|->
name|l_parm
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_parm
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Swap out the ldsym structure.  */
end_comment

begin_function
specifier|static
name|void
name|xcoff_swap_ldsym_out
parameter_list|(
name|abfd
parameter_list|,
name|src
parameter_list|,
name|d
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|struct
name|internal_ldsym
modifier|*
name|src
decl_stmt|;
name|PTR
name|d
decl_stmt|;
block|{
name|struct
name|external_ldsym
modifier|*
name|dst
init|=
operator|(
expr|struct
name|external_ldsym
operator|*
operator|)
name|d
decl_stmt|;
if|if
condition|(
name|src
operator|->
name|_l
operator|.
name|_l_l
operator|.
name|_l_zeroes
operator|!=
literal|0
condition|)
name|memcpy
argument_list|(
name|dst
operator|->
name|_l
operator|.
name|_l_name
argument_list|,
name|src
operator|->
name|_l
operator|.
name|_l_name
argument_list|,
name|SYMNMLEN
argument_list|)
expr_stmt|;
else|else
block|{
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|dst
operator|->
name|_l
operator|.
name|_l_l
operator|.
name|_l_zeroes
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|src
operator|->
name|_l
operator|.
name|_l_l
operator|.
name|_l_offset
argument_list|,
name|dst
operator|->
name|_l
operator|.
name|_l_l
operator|.
name|_l_offset
argument_list|)
expr_stmt|;
block|}
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_value
argument_list|,
name|dst
operator|->
name|l_value
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|src
operator|->
name|l_scnum
argument_list|,
name|dst
operator|->
name|l_scnum
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_smtype
argument_list|,
name|dst
operator|->
name|l_smtype
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_smclas
argument_list|,
name|dst
operator|->
name|l_smclas
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_ifile
argument_list|,
name|dst
operator|->
name|l_ifile
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_parm
argument_list|,
name|dst
operator|->
name|l_parm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xcoff_swap_reloc_in
parameter_list|(
name|abfd
parameter_list|,
name|s
parameter_list|,
name|d
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|s
decl_stmt|;
name|PTR
name|d
decl_stmt|;
block|{
name|struct
name|external_reloc
modifier|*
name|src
init|=
operator|(
expr|struct
name|external_reloc
operator|*
operator|)
name|s
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|dst
init|=
operator|(
expr|struct
name|internal_reloc
operator|*
operator|)
name|d
decl_stmt|;
name|memset
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|internal_reloc
argument_list|)
argument_list|)
expr_stmt|;
name|dst
operator|->
name|r_vaddr
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|r_vaddr
argument_list|)
expr_stmt|;
name|dst
operator|->
name|r_symndx
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|r_symndx
argument_list|)
expr_stmt|;
name|dst
operator|->
name|r_size
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|r_size
argument_list|)
expr_stmt|;
name|dst
operator|->
name|r_type
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|r_type
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|xcoff_swap_reloc_out
parameter_list|(
name|abfd
parameter_list|,
name|s
parameter_list|,
name|d
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|s
decl_stmt|;
name|PTR
name|d
decl_stmt|;
block|{
name|struct
name|internal_reloc
modifier|*
name|src
init|=
operator|(
expr|struct
name|internal_reloc
operator|*
operator|)
name|s
decl_stmt|;
name|struct
name|external_reloc
modifier|*
name|dst
init|=
operator|(
expr|struct
name|external_reloc
operator|*
operator|)
name|d
decl_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|r_vaddr
argument_list|,
name|dst
operator|->
name|r_vaddr
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|r_symndx
argument_list|,
name|dst
operator|->
name|r_symndx
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|r_type
argument_list|,
name|dst
operator|->
name|r_type
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|r_size
argument_list|,
name|dst
operator|->
name|r_size
argument_list|)
expr_stmt|;
return|return
name|bfd_coff_relsz
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Swap in the ldrel structure.  */
end_comment

begin_function
specifier|static
name|void
name|xcoff_swap_ldrel_in
parameter_list|(
name|abfd
parameter_list|,
name|s
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|PTR
name|s
decl_stmt|;
name|struct
name|internal_ldrel
modifier|*
name|dst
decl_stmt|;
block|{
specifier|const
name|struct
name|external_ldrel
modifier|*
name|src
init|=
operator|(
specifier|const
expr|struct
name|external_ldrel
operator|*
operator|)
name|s
decl_stmt|;
name|dst
operator|->
name|l_vaddr
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_vaddr
argument_list|)
expr_stmt|;
name|dst
operator|->
name|l_symndx
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_symndx
argument_list|)
expr_stmt|;
name|dst
operator|->
name|l_rtype
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_rtype
argument_list|)
expr_stmt|;
name|dst
operator|->
name|l_rsecnm
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_rsecnm
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Swap out the ldrel structure.  */
end_comment

begin_function
specifier|static
name|void
name|xcoff_swap_ldrel_out
parameter_list|(
name|abfd
parameter_list|,
name|src
parameter_list|,
name|d
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|struct
name|internal_ldrel
modifier|*
name|src
decl_stmt|;
name|PTR
name|d
decl_stmt|;
block|{
name|struct
name|external_ldrel
modifier|*
name|dst
init|=
operator|(
expr|struct
name|external_ldrel
operator|*
operator|)
name|d
decl_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_vaddr
argument_list|,
name|dst
operator|->
name|l_vaddr
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|l_symndx
argument_list|,
name|dst
operator|->
name|l_symndx
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|src
operator|->
name|l_rtype
argument_list|,
name|dst
operator|->
name|l_rtype
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|src
operator|->
name|l_rsecnm
argument_list|,
name|dst
operator|->
name|l_rsecnm
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|bfd_boolean
name|xcoff_reloc_type_noop
parameter_list|(
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|rel
parameter_list|,
name|sym
parameter_list|,
name|howto
parameter_list|,
name|val
parameter_list|,
name|addend
parameter_list|,
name|relocation
parameter_list|,
name|contents
parameter_list|)
name|bfd
modifier|*
name|input_bfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|input_section
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|rel
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|internal_syment
modifier|*
name|sym
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|reloc_howto_struct
modifier|*
name|howto
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd_vma
name|val
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd_vma
name|addend
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd_vma
modifier|*
name|relocation
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|xcoff_reloc_type_fail
parameter_list|(
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|rel
parameter_list|,
name|sym
parameter_list|,
name|howto
parameter_list|,
name|val
parameter_list|,
name|addend
parameter_list|,
name|relocation
parameter_list|,
name|contents
parameter_list|)
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|rel
decl_stmt|;
name|struct
name|internal_syment
modifier|*
name|sym
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|reloc_howto_struct
modifier|*
name|howto
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd_vma
name|val
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd_vma
name|addend
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd_vma
modifier|*
name|relocation
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: unsupported relocation type 0x%02x"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|rel
operator|->
name|r_type
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|xcoff_reloc_type_pos
parameter_list|(
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|rel
parameter_list|,
name|sym
parameter_list|,
name|howto
parameter_list|,
name|val
parameter_list|,
name|addend
parameter_list|,
name|relocation
parameter_list|,
name|contents
parameter_list|)
name|bfd
modifier|*
name|input_bfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|input_section
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|rel
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|internal_syment
modifier|*
name|sym
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|reloc_howto_struct
modifier|*
name|howto
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|;
name|bfd_vma
modifier|*
name|relocation
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
operator|*
name|relocation
operator|=
name|val
operator|+
name|addend
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|xcoff_reloc_type_neg
parameter_list|(
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|rel
parameter_list|,
name|sym
parameter_list|,
name|howto
parameter_list|,
name|val
parameter_list|,
name|addend
parameter_list|,
name|relocation
parameter_list|,
name|contents
parameter_list|)
name|bfd
modifier|*
name|input_bfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|input_section
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|rel
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|internal_syment
modifier|*
name|sym
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|reloc_howto_struct
modifier|*
name|howto
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|;
name|bfd_vma
modifier|*
name|relocation
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
operator|*
name|relocation
operator|=
name|addend
operator|-
name|val
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|xcoff_reloc_type_rel
parameter_list|(
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|rel
parameter_list|,
name|sym
parameter_list|,
name|howto
parameter_list|,
name|val
parameter_list|,
name|addend
parameter_list|,
name|relocation
parameter_list|,
name|contents
parameter_list|)
name|bfd
modifier|*
name|input_bfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|rel
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|internal_syment
modifier|*
name|sym
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|reloc_howto_struct
modifier|*
name|howto
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|;
name|bfd_vma
modifier|*
name|relocation
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|howto
operator|->
name|pc_relative
operator|=
name|TRUE
expr_stmt|;
comment|/* A PC relative reloc includes the section address.  */
name|addend
operator|+=
name|input_section
operator|->
name|vma
expr_stmt|;
operator|*
name|relocation
operator|=
name|val
operator|+
name|addend
expr_stmt|;
operator|*
name|relocation
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|xcoff_reloc_type_toc
parameter_list|(
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|rel
parameter_list|,
name|sym
parameter_list|,
name|howto
parameter_list|,
name|val
parameter_list|,
name|addend
parameter_list|,
name|relocation
parameter_list|,
name|contents
parameter_list|)
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|rel
decl_stmt|;
name|struct
name|internal_syment
modifier|*
name|sym
decl_stmt|;
name|struct
name|reloc_howto_struct
modifier|*
name|howto
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
name|bfd_vma
name|addend
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd_vma
modifier|*
name|relocation
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|struct
name|xcoff_link_hash_entry
modifier|*
name|h
decl_stmt|;
if|if
condition|(
literal|0
operator|>
name|rel
operator|->
name|r_symndx
condition|)
return|return
name|FALSE
return|;
name|h
operator|=
name|obj_xcoff_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
index|[
name|rel
operator|->
name|r_symndx
index|]
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|smclas
operator|!=
name|XMC_TD
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|toc_section
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: TOC reloc at 0x%x to symbol `%s' with no TOC entry"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|rel
operator|->
name|r_vaddr
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|BFD_ASSERT
argument_list|(
operator|(
name|h
operator|->
name|flags
operator|&
name|XCOFF_SET_TOC
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|h
operator|->
name|toc_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|toc_section
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
operator|*
name|relocation
operator|=
operator|(
operator|(
name|val
operator|-
name|xcoff_data
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|toc
operator|)
operator|-
operator|(
name|sym
operator|->
name|n_value
operator|-
name|xcoff_data
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|toc
operator|)
operator|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|xcoff_reloc_type_ba
parameter_list|(
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|rel
parameter_list|,
name|sym
parameter_list|,
name|howto
parameter_list|,
name|val
parameter_list|,
name|addend
parameter_list|,
name|relocation
parameter_list|,
name|contents
parameter_list|)
name|bfd
modifier|*
name|input_bfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|input_section
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|rel
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|internal_syment
modifier|*
name|sym
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|reloc_howto_struct
modifier|*
name|howto
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|;
name|bfd_vma
modifier|*
name|relocation
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|howto
operator|->
name|src_mask
operator|&=
operator|~
literal|3
expr_stmt|;
name|howto
operator|->
name|dst_mask
operator|=
name|howto
operator|->
name|src_mask
expr_stmt|;
operator|*
name|relocation
operator|=
name|val
operator|+
name|addend
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|xcoff_reloc_type_br
parameter_list|(
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|rel
parameter_list|,
name|sym
parameter_list|,
name|howto
parameter_list|,
name|val
parameter_list|,
name|addend
parameter_list|,
name|relocation
parameter_list|,
name|contents
parameter_list|)
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|rel
decl_stmt|;
name|struct
name|internal_syment
modifier|*
name|sym
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|reloc_howto_struct
modifier|*
name|howto
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|;
name|bfd_vma
modifier|*
name|relocation
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
block|{
name|struct
name|xcoff_link_hash_entry
modifier|*
name|h
decl_stmt|;
if|if
condition|(
literal|0
operator|>
name|rel
operator|->
name|r_symndx
condition|)
return|return
name|FALSE
return|;
name|h
operator|=
name|obj_xcoff_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
index|[
name|rel
operator|->
name|r_symndx
index|]
expr_stmt|;
comment|/* If we see an R_BR or R_RBR reloc which is jumping to global      linkage code, and it is followed by an appropriate cror nop      instruction, we replace the cror with lwz r2,20(r1).  This      restores the TOC after the glink code.  Contrariwise, if the      call is followed by a lwz r2,20(r1), but the call is not      going to global linkage code, we can replace the load with a      cror.  */
if|if
condition|(
name|NULL
operator|!=
name|h
operator|&&
name|bfd_link_hash_defined
operator|==
name|h
operator|->
name|root
operator|.
name|type
operator|&&
operator|(
name|rel
operator|->
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
operator|+
literal|8
operator|<=
name|input_section
operator|->
name|_cooked_size
operator|)
condition|)
block|{
name|bfd_byte
modifier|*
name|pnext
decl_stmt|;
name|unsigned
name|long
name|next
decl_stmt|;
name|pnext
operator|=
name|contents
operator|+
operator|(
name|rel
operator|->
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
operator|)
operator|+
literal|4
expr_stmt|;
name|next
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|pnext
argument_list|)
expr_stmt|;
comment|/* The _ptrgl function is magic.  It is used by the AIX 	 compiler to call a function through a pointer.  */
if|if
condition|(
name|h
operator|->
name|smclas
operator|==
name|XMC_GL
operator|||
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"._ptrgl"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|next
operator|==
literal|0x4def7b82
comment|/* cror 15,15,15 */
operator|||
name|next
operator|==
literal|0x4ffffb82
comment|/* cror 31,31,31 */
operator|||
name|next
operator|==
literal|0x60000000
condition|)
comment|/* ori r0,r0,0 */
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
literal|0x80410014
argument_list|,
name|pnext
argument_list|)
expr_stmt|;
comment|/* lwz r1,20(r1) */
block|}
else|else
block|{
if|if
condition|(
name|next
operator|==
literal|0x80410014
condition|)
comment|/* lwz r1,20(r1) */
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
literal|0x60000000
argument_list|,
name|pnext
argument_list|)
expr_stmt|;
comment|/* ori r0,r0,0 */
block|}
block|}
elseif|else
if|if
condition|(
name|NULL
operator|!=
name|h
operator|&&
name|bfd_link_hash_undefined
operator|==
name|h
operator|->
name|root
operator|.
name|type
condition|)
block|{
comment|/* Normally, this relocation is against a defined symbol.  In the 	 case where this is a partial link and the output section offset 	 is greater than 2^25, the linker will return an invalid error 	 message that the relocation has been truncated.  Yes it has been 	 truncated but no it not important.  For this case, disable the 	 overflow checking. */
name|howto
operator|->
name|complain_on_overflow
operator|=
name|complain_overflow_dont
expr_stmt|;
block|}
name|howto
operator|->
name|pc_relative
operator|=
name|TRUE
expr_stmt|;
name|howto
operator|->
name|src_mask
operator|&=
operator|~
literal|3
expr_stmt|;
name|howto
operator|->
name|dst_mask
operator|=
name|howto
operator|->
name|src_mask
expr_stmt|;
comment|/* A PC relative reloc includes the section address.  */
name|addend
operator|+=
name|input_section
operator|->
name|vma
expr_stmt|;
operator|*
name|relocation
operator|=
name|val
operator|+
name|addend
expr_stmt|;
operator|*
name|relocation
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|xcoff_reloc_type_crel
parameter_list|(
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|rel
parameter_list|,
name|sym
parameter_list|,
name|howto
parameter_list|,
name|val
parameter_list|,
name|addend
parameter_list|,
name|relocation
parameter_list|,
name|contents
parameter_list|)
name|bfd
modifier|*
name|input_bfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|rel
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|internal_syment
modifier|*
name|sym
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|reloc_howto_struct
modifier|*
name|howto
decl_stmt|;
name|bfd_vma
name|val
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|;
name|bfd_vma
modifier|*
name|relocation
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|howto
operator|->
name|pc_relative
operator|=
name|TRUE
expr_stmt|;
name|howto
operator|->
name|src_mask
operator|&=
operator|~
literal|3
expr_stmt|;
name|howto
operator|->
name|dst_mask
operator|=
name|howto
operator|->
name|src_mask
expr_stmt|;
comment|/* A PC relative reloc includes the section address.  */
name|addend
operator|+=
name|input_section
operator|->
name|vma
expr_stmt|;
operator|*
name|relocation
operator|=
name|val
operator|+
name|addend
expr_stmt|;
operator|*
name|relocation
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|xcoff_complain_overflow_dont_func
parameter_list|(
name|input_bfd
parameter_list|,
name|val
parameter_list|,
name|relocation
parameter_list|,
name|howto
parameter_list|)
name|bfd
modifier|*
name|input_bfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd_vma
name|val
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd_vma
name|relocation
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|reloc_howto_struct
modifier|*
name|howto
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|xcoff_complain_overflow_bitfield_func
parameter_list|(
name|input_bfd
parameter_list|,
name|val
parameter_list|,
name|relocation
parameter_list|,
name|howto
parameter_list|)
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|struct
name|reloc_howto_struct
modifier|*
name|howto
decl_stmt|;
block|{
name|bfd_vma
name|addrmask
decl_stmt|,
name|fieldmask
decl_stmt|,
name|signmask
decl_stmt|,
name|ss
decl_stmt|;
name|bfd_vma
name|a
decl_stmt|,
name|b
decl_stmt|,
name|sum
decl_stmt|;
comment|/* Get the values to be added together.  For signed and unsigned      relocations, we assume that all values should be truncated to      the size of an address.  For bitfields, all the bits matter.      See also bfd_check_overflow.  */
name|fieldmask
operator|=
name|N_ONES
argument_list|(
name|howto
operator|->
name|bitsize
argument_list|)
expr_stmt|;
name|addrmask
operator|=
name|N_ONES
argument_list|(
name|bfd_arch_bits_per_address
argument_list|(
name|input_bfd
argument_list|)
argument_list|)
operator||
name|fieldmask
expr_stmt|;
name|a
operator|=
name|relocation
expr_stmt|;
name|b
operator|=
name|val
operator|&
name|howto
operator|->
name|src_mask
expr_stmt|;
comment|/* Much like unsigned, except no trimming with addrmask.  In      addition, the sum overflows if there is a carry out of      the bfd_vma, i.e., the sum is less than either input      operand.  */
name|a
operator|>>=
name|howto
operator|->
name|rightshift
expr_stmt|;
name|b
operator|>>=
name|howto
operator|->
name|bitpos
expr_stmt|;
comment|/* Bitfields are sometimes used for signed numbers; for      example, a 13-bit field sometimes represents values in      0..8191 and sometimes represents values in -4096..4095.      If the field is signed and a is -4095 (0x1001) and b is      -1 (0x1fff), the sum is -4096 (0x1000), but (0x1001 +      0x1fff is 0x3000).  It's not clear how to handle this      everywhere, since there is not way to know how many bits      are significant in the relocation, but the original code      assumed that it was fully sign extended, and we will keep      that assumption.  */
name|signmask
operator|=
operator|(
name|fieldmask
operator|>>
literal|1
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|a
operator|&
operator|~
name|fieldmask
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Some bits out of the field are set.  This might not 	 be a problem: if this is a signed bitfield, it is OK 	 iff all the high bits are set, including the sign 	 bit.  We'll try setting all but the most significant 	 bit in the original relocation value: if this is all 	 ones, we are OK, assuming a signed bitfield.  */
name|ss
operator|=
operator|(
name|signmask
operator|<<
name|howto
operator|->
name|rightshift
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|ss
operator||
name|relocation
operator|)
operator|!=
operator|~
operator|(
name|bfd_vma
operator|)
literal|0
condition|)
return|return
name|TRUE
return|;
name|a
operator|&=
name|fieldmask
expr_stmt|;
block|}
comment|/* We just assume (b& ~ fieldmask) == 0.  */
comment|/* We explicitly permit wrap around if this relocation      covers the high bit of an address.  The Linux kernel      relies on it, and it is the only way to write assembler      code which can run when loaded at a location 0x80000000      away from the location at which it is linked.  */
if|if
condition|(
name|howto
operator|->
name|bitsize
operator|+
name|howto
operator|->
name|rightshift
operator|==
name|bfd_arch_bits_per_address
argument_list|(
name|input_bfd
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|sum
operator|=
name|a
operator|+
name|b
expr_stmt|;
if|if
condition|(
name|sum
operator|<
name|a
operator|||
operator|(
name|sum
operator|&
operator|~
name|fieldmask
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* There was a carry out, or the field overflow.  Test 	 for signed operands again.  Here is the overflow test 	 is as for complain_overflow_signed.  */
if|if
condition|(
operator|(
operator|(
operator|~
operator|(
name|a
operator|^
name|b
operator|)
operator|)
operator|&
operator|(
name|a
operator|^
name|sum
operator|)
operator|)
operator|&
name|signmask
condition|)
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|xcoff_complain_overflow_signed_func
parameter_list|(
name|input_bfd
parameter_list|,
name|val
parameter_list|,
name|relocation
parameter_list|,
name|howto
parameter_list|)
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|struct
name|reloc_howto_struct
modifier|*
name|howto
decl_stmt|;
block|{
name|bfd_vma
name|addrmask
decl_stmt|,
name|fieldmask
decl_stmt|,
name|signmask
decl_stmt|,
name|ss
decl_stmt|;
name|bfd_vma
name|a
decl_stmt|,
name|b
decl_stmt|,
name|sum
decl_stmt|;
comment|/* Get the values to be added together.  For signed and unsigned      relocations, we assume that all values should be truncated to      the size of an address.  For bitfields, all the bits matter.      See also bfd_check_overflow.  */
name|fieldmask
operator|=
name|N_ONES
argument_list|(
name|howto
operator|->
name|bitsize
argument_list|)
expr_stmt|;
name|addrmask
operator|=
name|N_ONES
argument_list|(
name|bfd_arch_bits_per_address
argument_list|(
name|input_bfd
argument_list|)
argument_list|)
operator||
name|fieldmask
expr_stmt|;
name|a
operator|=
name|relocation
expr_stmt|;
name|b
operator|=
name|val
operator|&
name|howto
operator|->
name|src_mask
expr_stmt|;
name|a
operator|=
operator|(
name|a
operator|&
name|addrmask
operator|)
operator|>>
name|howto
operator|->
name|rightshift
expr_stmt|;
comment|/* If any sign bits are set, all sign bits must be set.      That is, A must be a valid negative address after      shifting.  */
name|signmask
operator|=
operator|~
operator|(
name|fieldmask
operator|>>
literal|1
operator|)
expr_stmt|;
name|ss
operator|=
name|a
operator|&
name|signmask
expr_stmt|;
if|if
condition|(
name|ss
operator|!=
literal|0
operator|&&
name|ss
operator|!=
operator|(
operator|(
name|addrmask
operator|>>
name|howto
operator|->
name|rightshift
operator|)
operator|&
name|signmask
operator|)
condition|)
return|return
name|TRUE
return|;
comment|/* We only need this next bit of code if the sign bit of B      is below the sign bit of A.  This would only happen if      SRC_MASK had fewer bits than BITSIZE.  Note that if      SRC_MASK has more bits than BITSIZE, we can get into      trouble; we would need to verify that B is in range, as      we do for A above.  */
name|signmask
operator|=
operator|(
operator|(
operator|~
name|howto
operator|->
name|src_mask
operator|)
operator|>>
literal|1
operator|)
operator|&
name|howto
operator|->
name|src_mask
expr_stmt|;
if|if
condition|(
operator|(
name|b
operator|&
name|signmask
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Set all the bits above the sign bit.  */
name|b
operator|-=
name|signmask
operator|<<=
literal|1
expr_stmt|;
block|}
name|b
operator|=
operator|(
name|b
operator|&
name|addrmask
operator|)
operator|>>
name|howto
operator|->
name|bitpos
expr_stmt|;
comment|/* Now we can do the addition.  */
name|sum
operator|=
name|a
operator|+
name|b
expr_stmt|;
comment|/* See if the result has the correct sign.  Bits above the      sign bit are junk now; ignore them.  If the sum is      positive, make sure we did not have all negative inputs;      if the sum is negative, make sure we did not have all      positive inputs.  The test below looks only at the sign      bits, and it really just      SIGN (A) == SIGN (B)&& SIGN (A) != SIGN (SUM)   */
name|signmask
operator|=
operator|(
name|fieldmask
operator|>>
literal|1
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|~
operator|(
name|a
operator|^
name|b
operator|)
operator|)
operator|&
operator|(
name|a
operator|^
name|sum
operator|)
operator|)
operator|&
name|signmask
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|xcoff_complain_overflow_unsigned_func
parameter_list|(
name|input_bfd
parameter_list|,
name|val
parameter_list|,
name|relocation
parameter_list|,
name|howto
parameter_list|)
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|struct
name|reloc_howto_struct
modifier|*
name|howto
decl_stmt|;
block|{
name|bfd_vma
name|addrmask
decl_stmt|,
name|fieldmask
decl_stmt|;
name|bfd_vma
name|a
decl_stmt|,
name|b
decl_stmt|,
name|sum
decl_stmt|;
comment|/* Get the values to be added together.  For signed and unsigned      relocations, we assume that all values should be truncated to      the size of an address.  For bitfields, all the bits matter.      See also bfd_check_overflow.  */
name|fieldmask
operator|=
name|N_ONES
argument_list|(
name|howto
operator|->
name|bitsize
argument_list|)
expr_stmt|;
name|addrmask
operator|=
name|N_ONES
argument_list|(
name|bfd_arch_bits_per_address
argument_list|(
name|input_bfd
argument_list|)
argument_list|)
operator||
name|fieldmask
expr_stmt|;
name|a
operator|=
name|relocation
expr_stmt|;
name|b
operator|=
name|val
operator|&
name|howto
operator|->
name|src_mask
expr_stmt|;
comment|/* Checking for an unsigned overflow is relatively easy:      trim the addresses and add, and trim the result as well.      Overflow is normally indicated when the result does not      fit in the field.  However, we also need to consider the      case when, e.g., fieldmask is 0x7fffffff or smaller, an      input is 0x80000000, and bfd_vma is only 32 bits; then we      will get sum == 0, but there is an overflow, since the      inputs did not fit in the field.  Instead of doing a      separate test, we can check for this by or-ing in the      operands when testing for the sum overflowing its final      field.  */
name|a
operator|=
operator|(
name|a
operator|&
name|addrmask
operator|)
operator|>>
name|howto
operator|->
name|rightshift
expr_stmt|;
name|b
operator|=
operator|(
name|b
operator|&
name|addrmask
operator|)
operator|>>
name|howto
operator|->
name|bitpos
expr_stmt|;
name|sum
operator|=
operator|(
name|a
operator|+
name|b
operator|)
operator|&
name|addrmask
expr_stmt|;
if|if
condition|(
operator|(
name|a
operator||
name|b
operator||
name|sum
operator|)
operator|&
operator|~
name|fieldmask
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* This is the relocation function for the RS/6000/POWER/PowerPC.    This is currently the only processor which uses XCOFF; I hope that    will never change.     I took the relocation type definitions from two documents:    the PowerPC AIX Version 4 Application Binary Interface, First    Edition (April 1992), and the PowerOpen ABI, Big-Endian    32-Bit Hardware Implementation (June 30, 1994).  Differences    between the documents are noted below.     Unsupported r_type's     R_RTB:    R_RRTBI:    R_RRTBA:     These relocs are defined by the PowerPC ABI to be    relative branches which use half of the difference    between the symbol and the program counter.  I can't    quite figure out when this is useful.  These relocs are    not defined by the PowerOpen ABI.     Supported r_type's     R_POS:    Simple positive relocation.     R_NEG:    Simple negative relocation.     R_REL:    Simple PC relative relocation.     R_TOC:    TOC relative relocation.  The value in the instruction in    the input file is the offset from the input file TOC to    the desired location.  We want the offset from the final    TOC to the desired location.  We have:    isym = iTOC + in    iinsn = in + o    osym = oTOC + on    oinsn = on + o    so we must change insn by on - in.     R_GL:    GL linkage relocation.  The value of this relocation    is the address of the entry in the TOC section.     R_TCL:    Local object TOC address.  I can't figure out the    difference between this and case R_GL.     R_TRL:    TOC relative relocation.  A TOC relative load instruction    which may be changed to a load address instruction.    FIXME: We don't currently implement this optimization.     R_TRLA:    TOC relative relocation.  This is a TOC relative load    address instruction which may be changed to a load    instruction.  FIXME: I don't know if this is the correct    implementation.     R_BA:    Absolute branch.  We don't want to mess with the lower    two bits of the instruction.     R_CAI:    The PowerPC ABI defines this as an absolute call which    may be modified to become a relative call.  The PowerOpen    ABI does not define this relocation type.     R_RBA:    Absolute branch which may be modified to become a    relative branch.     R_RBAC:    The PowerPC ABI defines this as an absolute branch to a    fixed address which may be modified to an absolute branch    to a symbol.  The PowerOpen ABI does not define this    relocation type.     R_RBRC:    The PowerPC ABI defines this as an absolute branch to a    fixed address which may be modified to a relative branch.    The PowerOpen ABI does not define this relocation type.     R_BR:    Relative branch.  We don't want to mess with the lower    two bits of the instruction.     R_CREL:    The PowerPC ABI defines this as a relative call which may    be modified to become an absolute call.  The PowerOpen    ABI does not define this relocation type.     R_RBR:    A relative branch which may be modified to become an    absolute branch.  FIXME: We don't implement this,    although we should for symbols of storage mapping class    XMC_XO.     R_RL:    The PowerPC AIX ABI describes this as a load which may be    changed to a load address.  The PowerOpen ABI says this    is the same as case R_POS.     R_RLA:    The PowerPC AIX ABI describes this as a load address    which may be changed to a load.  The PowerOpen ABI says    this is the same as R_POS. */
end_comment

begin_function
name|bfd_boolean
name|xcoff_ppc_relocate_section
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|contents
parameter_list|,
name|relocs
parameter_list|,
name|syms
parameter_list|,
name|sections
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|relocs
decl_stmt|;
name|struct
name|internal_syment
modifier|*
name|syms
decl_stmt|;
name|asection
modifier|*
modifier|*
name|sections
decl_stmt|;
block|{
name|struct
name|internal_reloc
modifier|*
name|rel
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|relend
decl_stmt|;
name|rel
operator|=
name|relocs
expr_stmt|;
name|relend
operator|=
name|rel
operator|+
name|input_section
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|long
name|symndx
decl_stmt|;
name|struct
name|xcoff_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|internal_syment
modifier|*
name|sym
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
name|struct
name|reloc_howto_struct
name|howto
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_vma
name|value_to_relocate
decl_stmt|;
name|bfd_vma
name|address
decl_stmt|;
name|bfd_byte
modifier|*
name|location
decl_stmt|;
comment|/* Relocation type R_REF is a special relocation type which is 	 merely used to prevent garbage collection from occurring for 	 the csect including the symbol which it references.  */
if|if
condition|(
name|rel
operator|->
name|r_type
operator|==
name|R_REF
condition|)
continue|continue;
comment|/* howto */
name|howto
operator|.
name|type
operator|=
name|rel
operator|->
name|r_type
expr_stmt|;
name|howto
operator|.
name|rightshift
operator|=
literal|0
expr_stmt|;
name|howto
operator|.
name|bitsize
operator|=
operator|(
name|rel
operator|->
name|r_size
operator|&
literal|0x1f
operator|)
operator|+
literal|1
expr_stmt|;
name|howto
operator|.
name|size
operator|=
name|howto
operator|.
name|bitsize
operator|>
literal|16
condition|?
literal|2
else|:
literal|1
expr_stmt|;
name|howto
operator|.
name|pc_relative
operator|=
name|FALSE
expr_stmt|;
name|howto
operator|.
name|bitpos
operator|=
literal|0
expr_stmt|;
name|howto
operator|.
name|complain_on_overflow
operator|=
operator|(
name|rel
operator|->
name|r_size
operator|&
literal|0x80
condition|?
name|complain_overflow_signed
else|:
name|complain_overflow_bitfield
operator|)
expr_stmt|;
name|howto
operator|.
name|special_function
operator|=
name|NULL
expr_stmt|;
name|howto
operator|.
name|name
operator|=
literal|"internal"
expr_stmt|;
name|howto
operator|.
name|partial_inplace
operator|=
name|TRUE
expr_stmt|;
name|howto
operator|.
name|src_mask
operator|=
name|howto
operator|.
name|dst_mask
operator|=
name|N_ONES
argument_list|(
name|howto
operator|.
name|bitsize
argument_list|)
expr_stmt|;
name|howto
operator|.
name|pcrel_offset
operator|=
name|FALSE
expr_stmt|;
comment|/* symbol */
name|val
operator|=
literal|0
expr_stmt|;
name|addend
operator|=
literal|0
expr_stmt|;
name|h
operator|=
name|NULL
expr_stmt|;
name|sym
operator|=
name|NULL
expr_stmt|;
name|symndx
operator|=
name|rel
operator|->
name|r_symndx
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|!=
name|symndx
condition|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|h
operator|=
name|obj_xcoff_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
index|[
name|symndx
index|]
expr_stmt|;
name|sym
operator|=
name|syms
operator|+
name|symndx
expr_stmt|;
name|addend
operator|=
operator|-
name|sym
operator|->
name|n_value
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|h
condition|)
block|{
name|sec
operator|=
name|sections
index|[
name|symndx
index|]
expr_stmt|;
comment|/* Hack to make sure we use the right TOC anchor value 		 if this reloc is against the TOC anchor.  */
if|if
condition|(
name|sec
operator|->
name|name
index|[
literal|3
index|]
operator|==
literal|'0'
operator|&&
name|strcmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
literal|".tc0"
argument_list|)
operator|==
literal|0
condition|)
name|val
operator|=
name|xcoff_data
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|toc
expr_stmt|;
else|else
name|val
operator|=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|sym
operator|->
name|n_value
operator|-
name|sec
operator|->
name|vma
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
block|{
name|sec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|val
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_common
condition|)
block|{
name|sec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
expr_stmt|;
name|val
operator|=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
literal|0
operator|==
operator|(
name|h
operator|->
name|flags
operator|&
operator|(
name|XCOFF_DEF_DYNAMIC
operator||
name|XCOFF_IMPORT
operator|)
operator|)
operator|)
operator|&&
operator|!
name|info
operator|->
name|relocatable
condition|)
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
argument_list|,
name|TRUE
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
comment|/* Don't try to process the reloc.  It can't help, and 		     it may generate another error.  */
continue|continue;
block|}
block|}
block|}
if|if
condition|(
name|rel
operator|->
name|r_type
operator|>=
name|XCOFF_MAX_CALCULATE_RELOCATION
operator|||
operator|!
operator|(
call|(
modifier|*
name|xcoff_calculate_relocation
index|[
name|rel
operator|->
name|r_type
index|]
call|)
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
name|rel
argument_list|,
name|sym
argument_list|,
operator|&
name|howto
argument_list|,
name|val
argument_list|,
name|addend
argument_list|,
operator|&
name|relocation
argument_list|,
name|contents
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
comment|/* address */
name|address
operator|=
name|rel
operator|->
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
expr_stmt|;
name|location
operator|=
name|contents
operator|+
name|address
expr_stmt|;
if|if
condition|(
name|address
operator|>
name|input_section
operator|->
name|_raw_size
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Get the value we are going to relocate.  */
if|if
condition|(
literal|1
operator|==
name|howto
operator|.
name|size
condition|)
name|value_to_relocate
operator|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|location
argument_list|)
expr_stmt|;
else|else
name|value_to_relocate
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|location
argument_list|)
expr_stmt|;
comment|/* overflow.  	 FIXME: We may drop bits during the addition 	 which we don't check for.  We must either check at every single 	 operation, which would be tedious, or we must do the computations 	 in a type larger than bfd_vma, which would be inefficient.  */
if|if
condition|(
operator|(
name|unsigned
name|int
operator|)
name|howto
operator|.
name|complain_on_overflow
operator|>=
name|XCOFF_MAX_COMPLAIN_OVERFLOW
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
call|(
modifier|*
name|xcoff_complain_overflow
index|[
name|howto
operator|.
name|complain_on_overflow
index|]
call|)
argument_list|(
name|input_bfd
argument_list|,
name|value_to_relocate
argument_list|,
name|relocation
argument_list|,
operator|&
name|howto
argument_list|)
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|buf
index|[
name|SYMNMLEN
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|reloc_type_name
index|[
literal|10
index|]
decl_stmt|;
if|if
condition|(
name|symndx
operator|==
operator|-
literal|1
condition|)
block|{
name|name
operator|=
literal|"*ABS*"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
block|}
else|else
block|{
name|name
operator|=
name|_bfd_coff_internal_syment_name
argument_list|(
name|input_bfd
argument_list|,
name|sym
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|name
operator|=
literal|"UNKNOWN"
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|reloc_type_name
argument_list|,
literal|"0x%02x"
argument_list|,
name|rel
operator|->
name|r_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|info
argument_list|,
name|name
argument_list|,
name|reloc_type_name
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Add RELOCATION to the right bits of VALUE_TO_RELOCATE.  */
name|value_to_relocate
operator|=
operator|(
operator|(
name|value_to_relocate
operator|&
operator|~
name|howto
operator|.
name|dst_mask
operator|)
operator||
operator|(
operator|(
operator|(
name|value_to_relocate
operator|&
name|howto
operator|.
name|src_mask
operator|)
operator|+
name|relocation
operator|)
operator|&
name|howto
operator|.
name|dst_mask
operator|)
operator|)
expr_stmt|;
comment|/* Put the value back in the object file.  */
if|if
condition|(
literal|1
operator|==
name|howto
operator|.
name|size
condition|)
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|value_to_relocate
argument_list|,
name|location
argument_list|)
expr_stmt|;
else|else
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|value_to_relocate
argument_list|,
name|location
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|_bfd_xcoff_put_ldsymbol_name
parameter_list|(
name|abfd
parameter_list|,
name|ldinfo
parameter_list|,
name|ldsym
parameter_list|,
name|name
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|xcoff_loader_info
modifier|*
name|ldinfo
decl_stmt|;
name|struct
name|internal_ldsym
modifier|*
name|ldsym
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|size_t
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
name|SYMNMLEN
condition|)
name|strncpy
argument_list|(
name|ldsym
operator|->
name|_l
operator|.
name|_l_name
argument_list|,
name|name
argument_list|,
name|SYMNMLEN
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|ldinfo
operator|->
name|string_size
operator|+
name|len
operator|+
literal|3
operator|>
name|ldinfo
operator|->
name|string_alc
condition|)
block|{
name|bfd_size_type
name|newalc
decl_stmt|;
name|bfd_byte
modifier|*
name|newstrings
decl_stmt|;
name|newalc
operator|=
name|ldinfo
operator|->
name|string_alc
operator|*
literal|2
expr_stmt|;
if|if
condition|(
name|newalc
operator|==
literal|0
condition|)
name|newalc
operator|=
literal|32
expr_stmt|;
while|while
condition|(
name|ldinfo
operator|->
name|string_size
operator|+
name|len
operator|+
literal|3
operator|>
name|newalc
condition|)
name|newalc
operator|*=
literal|2
expr_stmt|;
name|newstrings
operator|=
operator|(
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_realloc
argument_list|(
operator|(
name|PTR
operator|)
name|ldinfo
operator|->
name|strings
argument_list|,
name|newalc
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|newstrings
operator|==
name|NULL
condition|)
block|{
name|ldinfo
operator|->
name|failed
operator|=
name|TRUE
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|ldinfo
operator|->
name|string_alc
operator|=
name|newalc
expr_stmt|;
name|ldinfo
operator|->
name|strings
operator|=
name|newstrings
expr_stmt|;
block|}
name|bfd_put_16
argument_list|(
name|ldinfo
operator|->
name|output_bfd
argument_list|,
call|(
name|bfd_vma
call|)
argument_list|(
name|len
operator|+
literal|1
argument_list|)
argument_list|,
name|ldinfo
operator|->
name|strings
operator|+
name|ldinfo
operator|->
name|string_size
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ldinfo
operator|->
name|strings
operator|+
name|ldinfo
operator|->
name|string_size
operator|+
literal|2
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|ldsym
operator|->
name|_l
operator|.
name|_l_l
operator|.
name|_l_zeroes
operator|=
literal|0
expr_stmt|;
name|ldsym
operator|->
name|_l
operator|.
name|_l_l
operator|.
name|_l_offset
operator|=
name|ldinfo
operator|->
name|string_size
operator|+
literal|2
expr_stmt|;
name|ldinfo
operator|->
name|string_size
operator|+=
name|len
operator|+
literal|3
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|_bfd_xcoff_put_symbol_name
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_strtab_hash
modifier|*
name|strtab
parameter_list|,
name|struct
name|internal_syment
modifier|*
name|sym
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|<=
name|SYMNMLEN
condition|)
block|{
name|strncpy
argument_list|(
name|sym
operator|->
name|_n
operator|.
name|_n_name
argument_list|,
name|name
argument_list|,
name|SYMNMLEN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bfd_boolean
name|hash
decl_stmt|;
name|bfd_size_type
name|indx
decl_stmt|;
name|hash
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|BFD_TRADITIONAL_FORMAT
operator|)
operator|!=
literal|0
condition|)
name|hash
operator|=
name|FALSE
expr_stmt|;
name|indx
operator|=
name|_bfd_stringtab_add
argument_list|(
name|strtab
argument_list|,
name|name
argument_list|,
name|hash
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|indx
operator|==
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
condition|)
return|return
name|FALSE
return|;
name|sym
operator|->
name|_n
operator|.
name|_n_n
operator|.
name|_n_zeroes
operator|=
literal|0
expr_stmt|;
name|sym
operator|->
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
operator|=
name|STRING_SIZE_SIZE
operator|+
name|indx
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|asection
modifier|*
name|xcoff_create_csect_from_smclas
parameter_list|(
name|abfd
parameter_list|,
name|aux
parameter_list|,
name|symbol_name
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|union
name|internal_auxent
modifier|*
name|aux
decl_stmt|;
specifier|const
name|char
modifier|*
name|symbol_name
decl_stmt|;
block|{
name|asection
modifier|*
name|return_value
init|=
name|NULL
decl_stmt|;
comment|/* .sv64 = x_smclas == 17      This is an invalid csect for 32 bit apps.  */
specifier|static
specifier|const
name|char
modifier|*
name|names
index|[
literal|19
index|]
init|=
block|{
literal|".pr"
block|,
literal|".ro"
block|,
literal|".db"
block|,
literal|".tc"
block|,
literal|".ua"
block|,
literal|".rw"
block|,
literal|".gl"
block|,
literal|".xo"
block|,
literal|".sv"
block|,
literal|".bs"
block|,
literal|".ds"
block|,
literal|".uc"
block|,
literal|".ti"
block|,
literal|".tb"
block|,
name|NULL
block|,
literal|".tc0"
block|,
literal|".td"
block|,
name|NULL
block|,
literal|".sv3264"
block|}
decl_stmt|;
if|if
condition|(
operator|(
literal|19
operator|>=
name|aux
operator|->
name|x_csect
operator|.
name|x_smclas
operator|)
operator|&&
operator|(
name|NULL
operator|!=
name|names
index|[
name|aux
operator|->
name|x_csect
operator|.
name|x_smclas
index|]
operator|)
condition|)
block|{
name|return_value
operator|=
name|bfd_make_section_anyway
argument_list|(
name|abfd
argument_list|,
name|names
index|[
name|aux
operator|->
name|x_csect
operator|.
name|x_smclas
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: symbol `%s' has unrecognized smclas %d"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|symbol_name
argument_list|,
name|aux
operator|->
name|x_csect
operator|.
name|x_smclas
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
block|}
return|return
name|return_value
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|xcoff_is_lineno_count_overflow
parameter_list|(
name|abfd
parameter_list|,
name|value
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
block|{
if|if
condition|(
literal|0xffff
operator|<=
name|value
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|xcoff_is_reloc_count_overflow
parameter_list|(
name|abfd
parameter_list|,
name|value
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
block|{
if|if
condition|(
literal|0xffff
operator|<=
name|value
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_vma
name|xcoff_loader_symbol_offset
parameter_list|(
name|abfd
parameter_list|,
name|ldhdr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|internal_ldhdr
modifier|*
name|ldhdr
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|bfd_xcoff_ldhdrsz
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_vma
name|xcoff_loader_reloc_offset
parameter_list|(
name|abfd
parameter_list|,
name|ldhdr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|internal_ldhdr
modifier|*
name|ldhdr
decl_stmt|;
block|{
return|return
name|bfd_xcoff_ldhdrsz
argument_list|(
name|abfd
argument_list|)
operator|+
name|ldhdr
operator|->
name|l_nsyms
operator|*
name|bfd_xcoff_ldsymsz
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|xcoff_generate_rtinit
parameter_list|(
name|abfd
parameter_list|,
name|init
parameter_list|,
name|fini
parameter_list|,
name|rtld
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|char
modifier|*
name|init
decl_stmt|;
specifier|const
name|char
modifier|*
name|fini
decl_stmt|;
name|bfd_boolean
name|rtld
decl_stmt|;
block|{
name|bfd_byte
name|filehdr_ext
index|[
name|FILHSZ
index|]
decl_stmt|;
name|bfd_byte
name|scnhdr_ext
index|[
name|SCNHSZ
index|]
decl_stmt|;
name|bfd_byte
name|syment_ext
index|[
name|SYMESZ
operator|*
literal|10
index|]
decl_stmt|;
name|bfd_byte
name|reloc_ext
index|[
name|RELSZ
operator|*
literal|3
index|]
decl_stmt|;
name|bfd_byte
modifier|*
name|data_buffer
decl_stmt|;
name|bfd_size_type
name|data_buffer_size
decl_stmt|;
name|bfd_byte
modifier|*
name|string_table
init|=
name|NULL
decl_stmt|,
modifier|*
name|st_tmp
init|=
name|NULL
decl_stmt|;
name|bfd_size_type
name|string_table_size
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
name|size_t
name|initsz
decl_stmt|,
name|finisz
decl_stmt|;
name|struct
name|internal_filehdr
name|filehdr
decl_stmt|;
name|struct
name|internal_scnhdr
name|scnhdr
decl_stmt|;
name|struct
name|internal_syment
name|syment
decl_stmt|;
name|union
name|internal_auxent
name|auxent
decl_stmt|;
name|struct
name|internal_reloc
name|reloc
decl_stmt|;
name|char
modifier|*
name|data_name
init|=
literal|".data"
decl_stmt|;
name|char
modifier|*
name|rtinit_name
init|=
literal|"__rtinit"
decl_stmt|;
name|char
modifier|*
name|rtld_name
init|=
literal|"__rtld"
decl_stmt|;
if|if
condition|(
operator|!
name|bfd_xcoff_rtinit_size
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|initsz
operator|=
operator|(
name|init
operator|==
name|NULL
condition|?
literal|0
else|:
literal|1
operator|+
name|strlen
argument_list|(
name|init
argument_list|)
operator|)
expr_stmt|;
name|finisz
operator|=
operator|(
name|fini
operator|==
name|NULL
condition|?
literal|0
else|:
literal|1
operator|+
name|strlen
argument_list|(
name|fini
argument_list|)
operator|)
expr_stmt|;
comment|/* file header */
name|memset
argument_list|(
name|filehdr_ext
argument_list|,
literal|0
argument_list|,
name|FILHSZ
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|filehdr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|internal_filehdr
argument_list|)
argument_list|)
expr_stmt|;
name|filehdr
operator|.
name|f_magic
operator|=
name|bfd_xcoff_magic_number
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|filehdr
operator|.
name|f_nscns
operator|=
literal|1
expr_stmt|;
name|filehdr
operator|.
name|f_timdat
operator|=
literal|0
expr_stmt|;
name|filehdr
operator|.
name|f_nsyms
operator|=
literal|0
expr_stmt|;
comment|/* at least 6, no more than 10 */
name|filehdr
operator|.
name|f_symptr
operator|=
literal|0
expr_stmt|;
comment|/* set below */
name|filehdr
operator|.
name|f_opthdr
operator|=
literal|0
expr_stmt|;
name|filehdr
operator|.
name|f_flags
operator|=
literal|0
expr_stmt|;
comment|/* section header */
name|memset
argument_list|(
name|scnhdr_ext
argument_list|,
literal|0
argument_list|,
name|SCNHSZ
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|scnhdr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|internal_scnhdr
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|scnhdr
operator|.
name|s_name
argument_list|,
name|data_name
argument_list|,
name|strlen
argument_list|(
name|data_name
argument_list|)
argument_list|)
expr_stmt|;
name|scnhdr
operator|.
name|s_paddr
operator|=
literal|0
expr_stmt|;
name|scnhdr
operator|.
name|s_vaddr
operator|=
literal|0
expr_stmt|;
name|scnhdr
operator|.
name|s_size
operator|=
literal|0
expr_stmt|;
comment|/* set below */
name|scnhdr
operator|.
name|s_scnptr
operator|=
name|FILHSZ
operator|+
name|SCNHSZ
expr_stmt|;
name|scnhdr
operator|.
name|s_relptr
operator|=
literal|0
expr_stmt|;
comment|/* set below */
name|scnhdr
operator|.
name|s_lnnoptr
operator|=
literal|0
expr_stmt|;
name|scnhdr
operator|.
name|s_nreloc
operator|=
literal|0
expr_stmt|;
comment|/* either 1 or 2 */
name|scnhdr
operator|.
name|s_nlnno
operator|=
literal|0
expr_stmt|;
name|scnhdr
operator|.
name|s_flags
operator|=
name|STYP_DATA
expr_stmt|;
comment|/* .data      0x0000	      0x00000000 : rtl      0x0004	      0x00000010 : offset to init, or 0      0x0008	      0x00000028 : offset to fini, or 0      0x000C	      0x0000000C : size of descriptor      0x0010	      0x00000000 : init, needs a reloc      0x0014	      0x00000040 : offset to init name      0x0018	      0x00000000 : flags, padded to a word      0x001C	      0x00000000 : empty init      0x0020	      0x00000000 :      0x0024	      0x00000000 :      0x0028	      0x00000000 : fini, needs a reloc      0x002C	      0x00000??? : offset to fini name      0x0030	      0x00000000 : flags, padded to a word      0x0034	      0x00000000 : empty fini      0x0038	      0x00000000 :      0x003C	      0x00000000 :      0x0040	      init name      0x0040 + initsz  fini name */
name|data_buffer_size
operator|=
literal|0x0040
operator|+
name|initsz
operator|+
name|finisz
expr_stmt|;
name|data_buffer_size
operator|=
operator|(
name|data_buffer_size
operator|+
literal|7
operator|)
operator|&
operator|~
operator|(
name|bfd_size_type
operator|)
literal|7
expr_stmt|;
name|data_buffer
operator|=
name|NULL
expr_stmt|;
name|data_buffer
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_zmalloc
argument_list|(
name|data_buffer_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|data_buffer
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|initsz
condition|)
block|{
name|val
operator|=
literal|0x10
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|val
argument_list|,
operator|&
name|data_buffer
index|[
literal|0x04
index|]
argument_list|)
expr_stmt|;
name|val
operator|=
literal|0x40
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|val
argument_list|,
operator|&
name|data_buffer
index|[
literal|0x14
index|]
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|data_buffer
index|[
name|val
index|]
argument_list|,
name|init
argument_list|,
name|initsz
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|finisz
condition|)
block|{
name|val
operator|=
literal|0x28
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|val
argument_list|,
operator|&
name|data_buffer
index|[
literal|0x08
index|]
argument_list|)
expr_stmt|;
name|val
operator|=
literal|0x40
operator|+
name|initsz
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|val
argument_list|,
operator|&
name|data_buffer
index|[
literal|0x2C
index|]
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|data_buffer
index|[
name|val
index|]
argument_list|,
name|fini
argument_list|,
name|finisz
argument_list|)
expr_stmt|;
block|}
name|val
operator|=
literal|0x0C
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|val
argument_list|,
operator|&
name|data_buffer
index|[
literal|0x0C
index|]
argument_list|)
expr_stmt|;
name|scnhdr
operator|.
name|s_size
operator|=
name|data_buffer_size
expr_stmt|;
comment|/* string table */
name|string_table_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|initsz
operator|>
literal|9
condition|)
name|string_table_size
operator|+=
name|initsz
expr_stmt|;
if|if
condition|(
name|finisz
operator|>
literal|9
condition|)
name|string_table_size
operator|+=
name|finisz
expr_stmt|;
if|if
condition|(
name|string_table_size
condition|)
block|{
name|string_table_size
operator|+=
literal|4
expr_stmt|;
name|string_table
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_zmalloc
argument_list|(
name|string_table_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|string_table
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|val
operator|=
name|string_table_size
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|val
argument_list|,
operator|&
name|string_table
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|st_tmp
operator|=
name|string_table
operator|+
literal|4
expr_stmt|;
block|}
comment|/* symbols      0. .data csect      2. __rtinit      4. init function      6. fini function      8. __rtld  */
name|memset
argument_list|(
name|syment_ext
argument_list|,
literal|0
argument_list|,
literal|10
operator|*
name|SYMESZ
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|reloc_ext
argument_list|,
literal|0
argument_list|,
literal|3
operator|*
name|RELSZ
argument_list|)
expr_stmt|;
comment|/* .data csect */
name|memset
argument_list|(
operator|&
name|syment
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|internal_syment
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|auxent
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|internal_auxent
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|syment
operator|.
name|_n
operator|.
name|_n_name
argument_list|,
name|data_name
argument_list|,
name|strlen
argument_list|(
name|data_name
argument_list|)
argument_list|)
expr_stmt|;
name|syment
operator|.
name|n_scnum
operator|=
literal|1
expr_stmt|;
name|syment
operator|.
name|n_sclass
operator|=
name|C_HIDEXT
expr_stmt|;
name|syment
operator|.
name|n_numaux
operator|=
literal|1
expr_stmt|;
name|auxent
operator|.
name|x_csect
operator|.
name|x_scnlen
operator|.
name|l
operator|=
name|data_buffer_size
expr_stmt|;
name|auxent
operator|.
name|x_csect
operator|.
name|x_smtyp
operator|=
literal|3
operator|<<
literal|3
operator||
name|XTY_SD
expr_stmt|;
name|auxent
operator|.
name|x_csect
operator|.
name|x_smclas
operator|=
name|XMC_RW
expr_stmt|;
name|bfd_coff_swap_sym_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|syment
argument_list|,
operator|&
name|syment_ext
index|[
name|filehdr
operator|.
name|f_nsyms
operator|*
name|SYMESZ
index|]
argument_list|)
expr_stmt|;
name|bfd_coff_swap_aux_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|auxent
argument_list|,
name|syment
operator|.
name|n_type
argument_list|,
name|syment
operator|.
name|n_sclass
argument_list|,
literal|0
argument_list|,
name|syment
operator|.
name|n_numaux
argument_list|,
operator|&
name|syment_ext
index|[
operator|(
name|filehdr
operator|.
name|f_nsyms
operator|+
literal|1
operator|)
operator|*
name|SYMESZ
index|]
argument_list|)
expr_stmt|;
name|filehdr
operator|.
name|f_nsyms
operator|+=
literal|2
expr_stmt|;
comment|/* __rtinit */
name|memset
argument_list|(
operator|&
name|syment
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|internal_syment
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|auxent
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|internal_auxent
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|syment
operator|.
name|_n
operator|.
name|_n_name
argument_list|,
name|rtinit_name
argument_list|,
name|strlen
argument_list|(
name|rtinit_name
argument_list|)
argument_list|)
expr_stmt|;
name|syment
operator|.
name|n_scnum
operator|=
literal|1
expr_stmt|;
name|syment
operator|.
name|n_sclass
operator|=
name|C_EXT
expr_stmt|;
name|syment
operator|.
name|n_numaux
operator|=
literal|1
expr_stmt|;
name|auxent
operator|.
name|x_csect
operator|.
name|x_smtyp
operator|=
name|XTY_LD
expr_stmt|;
name|auxent
operator|.
name|x_csect
operator|.
name|x_smclas
operator|=
name|XMC_RW
expr_stmt|;
name|bfd_coff_swap_sym_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|syment
argument_list|,
operator|&
name|syment_ext
index|[
name|filehdr
operator|.
name|f_nsyms
operator|*
name|SYMESZ
index|]
argument_list|)
expr_stmt|;
name|bfd_coff_swap_aux_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|auxent
argument_list|,
name|syment
operator|.
name|n_type
argument_list|,
name|syment
operator|.
name|n_sclass
argument_list|,
literal|0
argument_list|,
name|syment
operator|.
name|n_numaux
argument_list|,
operator|&
name|syment_ext
index|[
operator|(
name|filehdr
operator|.
name|f_nsyms
operator|+
literal|1
operator|)
operator|*
name|SYMESZ
index|]
argument_list|)
expr_stmt|;
name|filehdr
operator|.
name|f_nsyms
operator|+=
literal|2
expr_stmt|;
comment|/* init */
if|if
condition|(
name|initsz
condition|)
block|{
name|memset
argument_list|(
operator|&
name|syment
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|internal_syment
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|auxent
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|internal_auxent
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|initsz
operator|>
literal|9
condition|)
block|{
name|syment
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
operator|=
name|st_tmp
operator|-
name|string_table
expr_stmt|;
name|memcpy
argument_list|(
name|st_tmp
argument_list|,
name|init
argument_list|,
name|initsz
argument_list|)
expr_stmt|;
name|st_tmp
operator|+=
name|initsz
expr_stmt|;
block|}
else|else
name|memcpy
argument_list|(
name|syment
operator|.
name|_n
operator|.
name|_n_name
argument_list|,
name|init
argument_list|,
name|initsz
operator|-
literal|1
argument_list|)
expr_stmt|;
name|syment
operator|.
name|n_sclass
operator|=
name|C_EXT
expr_stmt|;
name|syment
operator|.
name|n_numaux
operator|=
literal|1
expr_stmt|;
name|bfd_coff_swap_sym_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|syment
argument_list|,
operator|&
name|syment_ext
index|[
name|filehdr
operator|.
name|f_nsyms
operator|*
name|SYMESZ
index|]
argument_list|)
expr_stmt|;
name|bfd_coff_swap_aux_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|auxent
argument_list|,
name|syment
operator|.
name|n_type
argument_list|,
name|syment
operator|.
name|n_sclass
argument_list|,
literal|0
argument_list|,
name|syment
operator|.
name|n_numaux
argument_list|,
operator|&
name|syment_ext
index|[
operator|(
name|filehdr
operator|.
name|f_nsyms
operator|+
literal|1
operator|)
operator|*
name|SYMESZ
index|]
argument_list|)
expr_stmt|;
comment|/* reloc */
name|memset
argument_list|(
operator|&
name|reloc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|internal_reloc
argument_list|)
argument_list|)
expr_stmt|;
name|reloc
operator|.
name|r_vaddr
operator|=
literal|0x0010
expr_stmt|;
name|reloc
operator|.
name|r_symndx
operator|=
name|filehdr
operator|.
name|f_nsyms
expr_stmt|;
name|reloc
operator|.
name|r_type
operator|=
name|R_POS
expr_stmt|;
name|reloc
operator|.
name|r_size
operator|=
literal|31
expr_stmt|;
name|bfd_coff_swap_reloc_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|reloc
argument_list|,
operator|&
name|reloc_ext
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|filehdr
operator|.
name|f_nsyms
operator|+=
literal|2
expr_stmt|;
name|scnhdr
operator|.
name|s_nreloc
operator|+=
literal|1
expr_stmt|;
block|}
comment|/* fini */
if|if
condition|(
name|finisz
condition|)
block|{
name|memset
argument_list|(
operator|&
name|syment
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|internal_syment
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|auxent
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|internal_auxent
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|finisz
operator|>
literal|9
condition|)
block|{
name|syment
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
operator|=
name|st_tmp
operator|-
name|string_table
expr_stmt|;
name|memcpy
argument_list|(
name|st_tmp
argument_list|,
name|fini
argument_list|,
name|finisz
argument_list|)
expr_stmt|;
name|st_tmp
operator|+=
name|finisz
expr_stmt|;
block|}
else|else
name|memcpy
argument_list|(
name|syment
operator|.
name|_n
operator|.
name|_n_name
argument_list|,
name|fini
argument_list|,
name|finisz
operator|-
literal|1
argument_list|)
expr_stmt|;
name|syment
operator|.
name|n_sclass
operator|=
name|C_EXT
expr_stmt|;
name|syment
operator|.
name|n_numaux
operator|=
literal|1
expr_stmt|;
name|bfd_coff_swap_sym_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|syment
argument_list|,
operator|&
name|syment_ext
index|[
name|filehdr
operator|.
name|f_nsyms
operator|*
name|SYMESZ
index|]
argument_list|)
expr_stmt|;
name|bfd_coff_swap_aux_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|auxent
argument_list|,
name|syment
operator|.
name|n_type
argument_list|,
name|syment
operator|.
name|n_sclass
argument_list|,
literal|0
argument_list|,
name|syment
operator|.
name|n_numaux
argument_list|,
operator|&
name|syment_ext
index|[
operator|(
name|filehdr
operator|.
name|f_nsyms
operator|+
literal|1
operator|)
operator|*
name|SYMESZ
index|]
argument_list|)
expr_stmt|;
comment|/* reloc */
name|memset
argument_list|(
operator|&
name|reloc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|internal_reloc
argument_list|)
argument_list|)
expr_stmt|;
name|reloc
operator|.
name|r_vaddr
operator|=
literal|0x0028
expr_stmt|;
name|reloc
operator|.
name|r_symndx
operator|=
name|filehdr
operator|.
name|f_nsyms
expr_stmt|;
name|reloc
operator|.
name|r_type
operator|=
name|R_POS
expr_stmt|;
name|reloc
operator|.
name|r_size
operator|=
literal|31
expr_stmt|;
name|bfd_coff_swap_reloc_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|reloc
argument_list|,
operator|&
name|reloc_ext
index|[
name|scnhdr
operator|.
name|s_nreloc
operator|*
name|RELSZ
index|]
argument_list|)
expr_stmt|;
name|filehdr
operator|.
name|f_nsyms
operator|+=
literal|2
expr_stmt|;
name|scnhdr
operator|.
name|s_nreloc
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|rtld
condition|)
block|{
name|memset
argument_list|(
operator|&
name|syment
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|internal_syment
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|auxent
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|internal_auxent
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|syment
operator|.
name|_n
operator|.
name|_n_name
argument_list|,
name|rtld_name
argument_list|,
name|strlen
argument_list|(
name|rtld_name
argument_list|)
argument_list|)
expr_stmt|;
name|syment
operator|.
name|n_sclass
operator|=
name|C_EXT
expr_stmt|;
name|syment
operator|.
name|n_numaux
operator|=
literal|1
expr_stmt|;
name|bfd_coff_swap_sym_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|syment
argument_list|,
operator|&
name|syment_ext
index|[
name|filehdr
operator|.
name|f_nsyms
operator|*
name|SYMESZ
index|]
argument_list|)
expr_stmt|;
name|bfd_coff_swap_aux_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|auxent
argument_list|,
name|syment
operator|.
name|n_type
argument_list|,
name|syment
operator|.
name|n_sclass
argument_list|,
literal|0
argument_list|,
name|syment
operator|.
name|n_numaux
argument_list|,
operator|&
name|syment_ext
index|[
operator|(
name|filehdr
operator|.
name|f_nsyms
operator|+
literal|1
operator|)
operator|*
name|SYMESZ
index|]
argument_list|)
expr_stmt|;
comment|/* reloc */
name|memset
argument_list|(
operator|&
name|reloc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|internal_reloc
argument_list|)
argument_list|)
expr_stmt|;
name|reloc
operator|.
name|r_vaddr
operator|=
literal|0x0000
expr_stmt|;
name|reloc
operator|.
name|r_symndx
operator|=
name|filehdr
operator|.
name|f_nsyms
expr_stmt|;
name|reloc
operator|.
name|r_type
operator|=
name|R_POS
expr_stmt|;
name|reloc
operator|.
name|r_size
operator|=
literal|31
expr_stmt|;
name|bfd_coff_swap_reloc_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|reloc
argument_list|,
operator|&
name|reloc_ext
index|[
name|scnhdr
operator|.
name|s_nreloc
operator|*
name|RELSZ
index|]
argument_list|)
expr_stmt|;
name|filehdr
operator|.
name|f_nsyms
operator|+=
literal|2
expr_stmt|;
name|scnhdr
operator|.
name|s_nreloc
operator|+=
literal|1
expr_stmt|;
block|}
name|scnhdr
operator|.
name|s_relptr
operator|=
name|scnhdr
operator|.
name|s_scnptr
operator|+
name|data_buffer_size
expr_stmt|;
name|filehdr
operator|.
name|f_symptr
operator|=
name|scnhdr
operator|.
name|s_relptr
operator|+
name|scnhdr
operator|.
name|s_nreloc
operator|*
name|RELSZ
expr_stmt|;
name|bfd_coff_swap_filehdr_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|filehdr
argument_list|,
name|filehdr_ext
argument_list|)
expr_stmt|;
name|bfd_bwrite
argument_list|(
name|filehdr_ext
argument_list|,
name|FILHSZ
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|bfd_coff_swap_scnhdr_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|scnhdr
argument_list|,
name|scnhdr_ext
argument_list|)
expr_stmt|;
name|bfd_bwrite
argument_list|(
name|scnhdr_ext
argument_list|,
name|SCNHSZ
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|bfd_bwrite
argument_list|(
name|data_buffer
argument_list|,
name|data_buffer_size
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|bfd_bwrite
argument_list|(
name|reloc_ext
argument_list|,
name|scnhdr
operator|.
name|s_nreloc
operator|*
name|RELSZ
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|bfd_bwrite
argument_list|(
name|syment_ext
argument_list|,
name|filehdr
operator|.
name|f_nsyms
operator|*
name|SYMESZ
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|bfd_bwrite
argument_list|(
name|string_table
argument_list|,
name|string_table_size
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data_buffer
argument_list|)
expr_stmt|;
name|data_buffer
operator|=
name|NULL
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|xcoff_dynamic_reloc
init|=
name|HOWTO
argument_list|(
literal|0
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"R_POS"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pcrel_offset */
end_comment

begin_comment
comment|/*  glink     The first word of global linkage code must be modified by filling in    the correct TOC offset.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|xcoff_glink_code
index|[
literal|9
index|]
init|=
block|{
literal|0x81820000
block|,
comment|/* lwz r12,0(r2) */
literal|0x90410014
block|,
comment|/* stw r2,20(r1) */
literal|0x800c0000
block|,
comment|/* lwz r0,0(r12) */
literal|0x804c0004
block|,
comment|/* lwz r2,4(r12) */
literal|0x7c0903a6
block|,
comment|/* mtctr r0 */
literal|0x4e800420
block|,
comment|/* bctr */
literal|0x00000000
block|,
comment|/* start of traceback table */
literal|0x000c8000
block|,
comment|/* traceback table */
literal|0x00000000
block|,
comment|/* traceback table */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|xcoff_backend_data_rec
name|bfd_xcoff_backend_data
init|=
block|{
block|{
comment|/* COFF backend, defined in libcoff.h.  */
name|_bfd_xcoff_swap_aux_in
block|,
name|_bfd_xcoff_swap_sym_in
block|,
name|coff_swap_lineno_in
block|,
name|_bfd_xcoff_swap_aux_out
block|,
name|_bfd_xcoff_swap_sym_out
block|,
name|coff_swap_lineno_out
block|,
name|xcoff_swap_reloc_out
block|,
name|coff_swap_filehdr_out
block|,
name|coff_swap_aouthdr_out
block|,
name|coff_swap_scnhdr_out
block|,
name|FILHSZ
block|,
name|AOUTSZ
block|,
name|SCNHSZ
block|,
name|SYMESZ
block|,
name|AUXESZ
block|,
name|RELSZ
block|,
name|LINESZ
block|,
name|FILNMLEN
block|,
name|TRUE
block|,
comment|/* _bfd_coff_long_filenames */
name|FALSE
block|,
comment|/* _bfd_coff_long_section_names */
literal|3
block|,
comment|/* _bfd_coff_default_section_alignment_power */
name|FALSE
block|,
comment|/* _bfd_coff_force_symnames_in_strings */
literal|2
block|,
comment|/* _bfd_coff_debug_string_prefix_length */
name|coff_swap_filehdr_in
block|,
name|coff_swap_aouthdr_in
block|,
name|coff_swap_scnhdr_in
block|,
name|xcoff_swap_reloc_in
block|,
name|coff_bad_format_hook
block|,
name|coff_set_arch_mach_hook
block|,
name|coff_mkobject_hook
block|,
name|styp_to_sec_flags
block|,
name|coff_set_alignment_hook
block|,
name|coff_slurp_symbol_table
block|,
name|symname_in_debug_hook
block|,
name|coff_pointerize_aux_hook
block|,
name|coff_print_aux
block|,
name|dummy_reloc16_extra_cases
block|,
name|dummy_reloc16_estimate
block|,
name|NULL
block|,
comment|/* bfd_coff_sym_is_global */
name|coff_compute_section_file_positions
block|,
name|NULL
block|,
comment|/* _bfd_coff_start_final_link */
name|xcoff_ppc_relocate_section
block|,
name|coff_rtype_to_howto
block|,
name|NULL
block|,
comment|/* _bfd_coff_adjust_symndx */
name|_bfd_generic_link_add_one_symbol
block|,
name|coff_link_output_has_begun
block|,
name|coff_final_link_postscript
block|}
block|,
literal|0x01DF
block|,
comment|/* magic number */
name|bfd_arch_rs6000
block|,
name|bfd_mach_rs6k
block|,
comment|/* Function pointers to xcoff specific swap routines.  */
name|xcoff_swap_ldhdr_in
block|,
name|xcoff_swap_ldhdr_out
block|,
name|xcoff_swap_ldsym_in
block|,
name|xcoff_swap_ldsym_out
block|,
name|xcoff_swap_ldrel_in
block|,
name|xcoff_swap_ldrel_out
block|,
comment|/* Sizes.  */
name|LDHDRSZ
block|,
name|LDSYMSZ
block|,
name|LDRELSZ
block|,
literal|12
block|,
comment|/* _xcoff_function_descriptor_size */
name|SMALL_AOUTSZ
block|,
comment|/* Versions.  */
literal|1
block|,
comment|/* _xcoff_ldhdr_version */
name|_bfd_xcoff_put_symbol_name
block|,
name|_bfd_xcoff_put_ldsymbol_name
block|,
operator|&
name|xcoff_dynamic_reloc
block|,
name|xcoff_create_csect_from_smclas
block|,
comment|/* Lineno and reloc count overflow.  */
name|xcoff_is_lineno_count_overflow
block|,
name|xcoff_is_reloc_count_overflow
block|,
name|xcoff_loader_symbol_offset
block|,
name|xcoff_loader_reloc_offset
block|,
comment|/* glink.  */
operator|&
name|xcoff_glink_code
index|[
literal|0
index|]
block|,
literal|36
block|,
comment|/* _xcoff_glink_size */
comment|/* rtinit */
literal|64
block|,
comment|/* _xcoff_rtinit_size */
name|xcoff_generate_rtinit
block|,   }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The transfer vector that leads the outside world to all of the above.  */
end_comment

begin_decl_stmt
specifier|const
name|bfd_target
name|rs6000coff_vec
init|=
block|{
literal|"aixcoff-rs6000"
block|,
name|bfd_target_xcoff_flavour
block|,
name|BFD_ENDIAN_BIG
block|,
comment|/* data byte order is big */
name|BFD_ENDIAN_BIG
block|,
comment|/* header byte order is big */
operator|(
name|HAS_RELOC
operator||
name|EXEC_P
operator||
name|HAS_LINENO
operator||
name|HAS_DEBUG
operator||
name|DYNAMIC
operator||
name|HAS_SYMS
operator||
name|HAS_LOCALS
operator||
name|WP_TEXT
operator|)
block|,
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator||
name|SEC_CODE
operator||
name|SEC_DATA
block|,
literal|0
block|,
comment|/* leading char */
literal|'/'
block|,
comment|/* ar_pad_char */
literal|15
block|,
comment|/* ar_max_namelen */
comment|/* data */
name|bfd_getb64
block|,
name|bfd_getb_signed_64
block|,
name|bfd_putb64
block|,
name|bfd_getb32
block|,
name|bfd_getb_signed_32
block|,
name|bfd_putb32
block|,
name|bfd_getb16
block|,
name|bfd_getb_signed_16
block|,
name|bfd_putb16
block|,
comment|/* hdrs */
name|bfd_getb64
block|,
name|bfd_getb_signed_64
block|,
name|bfd_putb64
block|,
name|bfd_getb32
block|,
name|bfd_getb_signed_32
block|,
name|bfd_putb32
block|,
name|bfd_getb16
block|,
name|bfd_getb_signed_16
block|,
name|bfd_putb16
block|,
block|{
comment|/* bfd_check_format */
name|_bfd_dummy_target
block|,
name|coff_object_p
block|,
name|_bfd_xcoff_archive_p
block|,
name|CORE_FILE_P
block|}
block|,
block|{
comment|/* bfd_set_format */
name|bfd_false
block|,
name|coff_mkobject
block|,
name|_bfd_generic_mkarchive
block|,
name|bfd_false
block|}
block|,
block|{
comment|/* bfd_write_contents */
name|bfd_false
block|,
name|coff_write_object_contents
block|,
name|_bfd_xcoff_write_archive_contents
block|,
name|bfd_false
block|}
block|,
comment|/* Generic */
name|bfd_true
block|,
name|bfd_true
block|,
name|coff_new_section_hook
block|,
name|_bfd_generic_get_section_contents
block|,
name|_bfd_generic_get_section_contents_in_window
block|,
comment|/* Copy */
name|_bfd_xcoff_copy_private_bfd_data
block|,
operator|(
operator|(
name|bfd_boolean
argument_list|(
operator|*
argument_list|)
argument_list|(
name|bfd
operator|*
argument_list|,
name|bfd
operator|*
argument_list|)
operator|)
name|bfd_true
operator|)
block|,
operator|(
operator|(
name|bfd_boolean
argument_list|(
operator|*
argument_list|)
argument_list|(
name|bfd
operator|*
argument_list|,
name|asection
operator|*
argument_list|,
name|bfd
operator|*
argument_list|,
name|asection
operator|*
argument_list|)
operator|)
name|bfd_true
operator|)
block|,
operator|(
operator|(
name|bfd_boolean
argument_list|(
operator|*
argument_list|)
argument_list|(
name|bfd
operator|*
argument_list|,
name|asymbol
operator|*
argument_list|,
name|bfd
operator|*
argument_list|,
name|asymbol
operator|*
argument_list|)
operator|)
name|bfd_true
operator|)
block|,
operator|(
operator|(
name|bfd_boolean
argument_list|(
operator|*
argument_list|)
argument_list|(
name|bfd
operator|*
argument_list|,
name|flagword
argument_list|)
operator|)
name|bfd_true
operator|)
block|,
operator|(
operator|(
name|bfd_boolean
argument_list|(
operator|*
argument_list|)
argument_list|(
name|bfd
operator|*
argument_list|,
name|void
operator|*
argument_list|)
operator|)
name|bfd_true
operator|)
block|,
comment|/* Core */
name|coff_core_file_failing_command
block|,
name|coff_core_file_failing_signal
block|,
name|coff_core_file_matches_executable_p
block|,
comment|/* Archive */
name|_bfd_xcoff_slurp_armap
block|,
name|bfd_false
block|,
operator|(
operator|(
name|bfd_boolean
argument_list|(
operator|*
argument_list|)
argument_list|(
name|bfd
operator|*
argument_list|,
name|char
operator|*
operator|*
argument_list|,
name|bfd_size_type
operator|*
argument_list|,
specifier|const
name|char
operator|*
operator|*
argument_list|)
operator|)
name|bfd_false
operator|)
block|,
name|bfd_dont_truncate_arname
block|,
name|_bfd_xcoff_write_armap
block|,
name|_bfd_xcoff_read_ar_hdr
block|,
name|_bfd_xcoff_openr_next_archived_file
block|,
name|_bfd_generic_get_elt_at_index
block|,
name|_bfd_xcoff_stat_arch_elt
block|,
name|bfd_true
block|,
comment|/* Symbols */
name|coff_get_symtab_upper_bound
block|,
name|coff_canonicalize_symtab
block|,
name|coff_make_empty_symbol
block|,
name|coff_print_symbol
block|,
name|coff_get_symbol_info
block|,
name|_bfd_xcoff_is_local_label_name
block|,
name|coff_get_lineno
block|,
name|coff_find_nearest_line
block|,
name|coff_bfd_make_debug_symbol
block|,
name|_bfd_generic_read_minisymbols
block|,
name|_bfd_generic_minisymbol_to_symbol
block|,
comment|/* Reloc */
name|coff_get_reloc_upper_bound
block|,
name|coff_canonicalize_reloc
block|,
name|_bfd_xcoff_reloc_type_lookup
block|,
comment|/* Write */
name|coff_set_arch_mach
block|,
name|coff_set_section_contents
block|,
comment|/* Link */
name|_bfd_xcoff_sizeof_headers
block|,
name|bfd_generic_get_relocated_section_contents
block|,
name|bfd_generic_relax_section
block|,
name|_bfd_xcoff_bfd_link_hash_table_create
block|,
name|_bfd_generic_link_hash_table_free
block|,
name|_bfd_xcoff_bfd_link_add_symbols
block|,
name|_bfd_generic_link_just_syms
block|,
name|_bfd_xcoff_bfd_final_link
block|,
name|_bfd_generic_link_split_section
block|,
name|bfd_generic_gc_sections
block|,
name|bfd_generic_merge_sections
block|,
name|bfd_generic_discard_group
block|,
comment|/* Dynamic */
name|_bfd_xcoff_get_dynamic_symtab_upper_bound
block|,
name|_bfd_xcoff_canonicalize_dynamic_symtab
block|,
name|_bfd_xcoff_get_dynamic_reloc_upper_bound
block|,
name|_bfd_xcoff_canonicalize_dynamic_reloc
block|,
comment|/* Opposite endian version, none exists */
name|NULL
block|,
operator|(
name|void
operator|*
operator|)
operator|&
name|bfd_xcoff_backend_data
block|,   }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* xcoff-powermac target    Old target.    Only difference between this target and the rs6000 target is the    the default architecture and machine type used in coffcode.h     PowerPC Macs use the same magic numbers as RS/6000    (because that's how they were bootstrapped originally),    but they are always PowerPC architecture.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|xcoff_backend_data_rec
name|bfd_pmac_xcoff_backend_data
init|=
block|{
block|{
comment|/* COFF backend, defined in libcoff.h.  */
name|_bfd_xcoff_swap_aux_in
block|,
name|_bfd_xcoff_swap_sym_in
block|,
name|coff_swap_lineno_in
block|,
name|_bfd_xcoff_swap_aux_out
block|,
name|_bfd_xcoff_swap_sym_out
block|,
name|coff_swap_lineno_out
block|,
name|xcoff_swap_reloc_out
block|,
name|coff_swap_filehdr_out
block|,
name|coff_swap_aouthdr_out
block|,
name|coff_swap_scnhdr_out
block|,
name|FILHSZ
block|,
name|AOUTSZ
block|,
name|SCNHSZ
block|,
name|SYMESZ
block|,
name|AUXESZ
block|,
name|RELSZ
block|,
name|LINESZ
block|,
name|FILNMLEN
block|,
name|TRUE
block|,
comment|/* _bfd_coff_long_filenames */
name|FALSE
block|,
comment|/* _bfd_coff_long_section_names */
literal|3
block|,
comment|/* _bfd_coff_default_section_alignment_power */
name|FALSE
block|,
comment|/* _bfd_coff_force_symnames_in_strings */
literal|2
block|,
comment|/* _bfd_coff_debug_string_prefix_length */
name|coff_swap_filehdr_in
block|,
name|coff_swap_aouthdr_in
block|,
name|coff_swap_scnhdr_in
block|,
name|xcoff_swap_reloc_in
block|,
name|coff_bad_format_hook
block|,
name|coff_set_arch_mach_hook
block|,
name|coff_mkobject_hook
block|,
name|styp_to_sec_flags
block|,
name|coff_set_alignment_hook
block|,
name|coff_slurp_symbol_table
block|,
name|symname_in_debug_hook
block|,
name|coff_pointerize_aux_hook
block|,
name|coff_print_aux
block|,
name|dummy_reloc16_extra_cases
block|,
name|dummy_reloc16_estimate
block|,
name|NULL
block|,
comment|/* bfd_coff_sym_is_global */
name|coff_compute_section_file_positions
block|,
name|NULL
block|,
comment|/* _bfd_coff_start_final_link */
name|xcoff_ppc_relocate_section
block|,
name|coff_rtype_to_howto
block|,
name|NULL
block|,
comment|/* _bfd_coff_adjust_symndx */
name|_bfd_generic_link_add_one_symbol
block|,
name|coff_link_output_has_begun
block|,
name|coff_final_link_postscript
block|}
block|,
literal|0x01DF
block|,
comment|/* magic number */
name|bfd_arch_powerpc
block|,
name|bfd_mach_ppc
block|,
comment|/* Function pointers to xcoff specific swap routines.  */
name|xcoff_swap_ldhdr_in
block|,
name|xcoff_swap_ldhdr_out
block|,
name|xcoff_swap_ldsym_in
block|,
name|xcoff_swap_ldsym_out
block|,
name|xcoff_swap_ldrel_in
block|,
name|xcoff_swap_ldrel_out
block|,
comment|/* Sizes.  */
name|LDHDRSZ
block|,
name|LDSYMSZ
block|,
name|LDRELSZ
block|,
literal|12
block|,
comment|/* _xcoff_function_descriptor_size */
name|SMALL_AOUTSZ
block|,
comment|/* Versions.  */
literal|1
block|,
comment|/* _xcoff_ldhdr_version */
name|_bfd_xcoff_put_symbol_name
block|,
name|_bfd_xcoff_put_ldsymbol_name
block|,
operator|&
name|xcoff_dynamic_reloc
block|,
name|xcoff_create_csect_from_smclas
block|,
comment|/* Lineno and reloc count overflow.  */
name|xcoff_is_lineno_count_overflow
block|,
name|xcoff_is_reloc_count_overflow
block|,
name|xcoff_loader_symbol_offset
block|,
name|xcoff_loader_reloc_offset
block|,
comment|/* glink.  */
operator|&
name|xcoff_glink_code
index|[
literal|0
index|]
block|,
literal|36
block|,
comment|/* _xcoff_glink_size */
comment|/* rtinit */
literal|0
block|,
comment|/* _xcoff_rtinit_size */
name|xcoff_generate_rtinit
block|,   }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The transfer vector that leads the outside world to all of the above.  */
end_comment

begin_decl_stmt
specifier|const
name|bfd_target
name|pmac_xcoff_vec
init|=
block|{
literal|"xcoff-powermac"
block|,
name|bfd_target_xcoff_flavour
block|,
name|BFD_ENDIAN_BIG
block|,
comment|/* data byte order is big */
name|BFD_ENDIAN_BIG
block|,
comment|/* header byte order is big */
operator|(
name|HAS_RELOC
operator||
name|EXEC_P
operator||
name|HAS_LINENO
operator||
name|HAS_DEBUG
operator||
name|DYNAMIC
operator||
name|HAS_SYMS
operator||
name|HAS_LOCALS
operator||
name|WP_TEXT
operator|)
block|,
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator||
name|SEC_CODE
operator||
name|SEC_DATA
block|,
literal|0
block|,
comment|/* leading char */
literal|'/'
block|,
comment|/* ar_pad_char */
literal|15
block|,
comment|/* ar_max_namelen */
comment|/* data */
name|bfd_getb64
block|,
name|bfd_getb_signed_64
block|,
name|bfd_putb64
block|,
name|bfd_getb32
block|,
name|bfd_getb_signed_32
block|,
name|bfd_putb32
block|,
name|bfd_getb16
block|,
name|bfd_getb_signed_16
block|,
name|bfd_putb16
block|,
comment|/* hdrs */
name|bfd_getb64
block|,
name|bfd_getb_signed_64
block|,
name|bfd_putb64
block|,
name|bfd_getb32
block|,
name|bfd_getb_signed_32
block|,
name|bfd_putb32
block|,
name|bfd_getb16
block|,
name|bfd_getb_signed_16
block|,
name|bfd_putb16
block|,
block|{
comment|/* bfd_check_format */
name|_bfd_dummy_target
block|,
name|coff_object_p
block|,
name|_bfd_xcoff_archive_p
block|,
name|CORE_FILE_P
block|}
block|,
block|{
comment|/* bfd_set_format */
name|bfd_false
block|,
name|coff_mkobject
block|,
name|_bfd_generic_mkarchive
block|,
name|bfd_false
block|}
block|,
block|{
comment|/* bfd_write_contents */
name|bfd_false
block|,
name|coff_write_object_contents
block|,
name|_bfd_xcoff_write_archive_contents
block|,
name|bfd_false
block|}
block|,
comment|/* Generic */
name|bfd_true
block|,
name|bfd_true
block|,
name|coff_new_section_hook
block|,
name|_bfd_generic_get_section_contents
block|,
name|_bfd_generic_get_section_contents_in_window
block|,
comment|/* Copy */
name|_bfd_xcoff_copy_private_bfd_data
block|,
operator|(
operator|(
name|bfd_boolean
argument_list|(
operator|*
argument_list|)
argument_list|(
name|bfd
operator|*
argument_list|,
name|bfd
operator|*
argument_list|)
operator|)
name|bfd_true
operator|)
block|,
operator|(
operator|(
name|bfd_boolean
argument_list|(
operator|*
argument_list|)
argument_list|(
name|bfd
operator|*
argument_list|,
name|asection
operator|*
argument_list|,
name|bfd
operator|*
argument_list|,
name|asection
operator|*
argument_list|)
operator|)
name|bfd_true
operator|)
block|,
operator|(
operator|(
name|bfd_boolean
argument_list|(
operator|*
argument_list|)
argument_list|(
name|bfd
operator|*
argument_list|,
name|asymbol
operator|*
argument_list|,
name|bfd
operator|*
argument_list|,
name|asymbol
operator|*
argument_list|)
operator|)
name|bfd_true
operator|)
block|,
operator|(
operator|(
name|bfd_boolean
argument_list|(
operator|*
argument_list|)
argument_list|(
name|bfd
operator|*
argument_list|,
name|flagword
argument_list|)
operator|)
name|bfd_true
operator|)
block|,
operator|(
operator|(
name|bfd_boolean
argument_list|(
operator|*
argument_list|)
argument_list|(
name|bfd
operator|*
argument_list|,
name|void
operator|*
argument_list|)
operator|)
name|bfd_true
operator|)
block|,
comment|/* Core */
name|coff_core_file_failing_command
block|,
name|coff_core_file_failing_signal
block|,
name|coff_core_file_matches_executable_p
block|,
comment|/* Archive */
name|_bfd_xcoff_slurp_armap
block|,
name|bfd_false
block|,
operator|(
operator|(
name|bfd_boolean
argument_list|(
operator|*
argument_list|)
argument_list|(
name|bfd
operator|*
argument_list|,
name|char
operator|*
operator|*
argument_list|,
name|bfd_size_type
operator|*
argument_list|,
specifier|const
name|char
operator|*
operator|*
argument_list|)
operator|)
name|bfd_false
operator|)
block|,
name|bfd_dont_truncate_arname
block|,
name|_bfd_xcoff_write_armap
block|,
name|_bfd_xcoff_read_ar_hdr
block|,
name|_bfd_xcoff_openr_next_archived_file
block|,
name|_bfd_generic_get_elt_at_index
block|,
name|_bfd_xcoff_stat_arch_elt
block|,
name|bfd_true
block|,
comment|/* Symbols */
name|coff_get_symtab_upper_bound
block|,
name|coff_canonicalize_symtab
block|,
name|coff_make_empty_symbol
block|,
name|coff_print_symbol
block|,
name|coff_get_symbol_info
block|,
name|_bfd_xcoff_is_local_label_name
block|,
name|coff_get_lineno
block|,
name|coff_find_nearest_line
block|,
name|coff_bfd_make_debug_symbol
block|,
name|_bfd_generic_read_minisymbols
block|,
name|_bfd_generic_minisymbol_to_symbol
block|,
comment|/* Reloc */
name|coff_get_reloc_upper_bound
block|,
name|coff_canonicalize_reloc
block|,
name|_bfd_xcoff_reloc_type_lookup
block|,
comment|/* Write */
name|coff_set_arch_mach
block|,
name|coff_set_section_contents
block|,
comment|/* Link */
name|_bfd_xcoff_sizeof_headers
block|,
name|bfd_generic_get_relocated_section_contents
block|,
name|bfd_generic_relax_section
block|,
name|_bfd_xcoff_bfd_link_hash_table_create
block|,
name|_bfd_generic_link_hash_table_free
block|,
name|_bfd_xcoff_bfd_link_add_symbols
block|,
name|_bfd_generic_link_just_syms
block|,
name|_bfd_xcoff_bfd_final_link
block|,
name|_bfd_generic_link_split_section
block|,
name|bfd_generic_gc_sections
block|,
name|bfd_generic_merge_sections
block|,
name|bfd_generic_discard_group
block|,
comment|/* Dynamic */
name|_bfd_xcoff_get_dynamic_symtab_upper_bound
block|,
name|_bfd_xcoff_canonicalize_dynamic_symtab
block|,
name|_bfd_xcoff_get_dynamic_reloc_upper_bound
block|,
name|_bfd_xcoff_canonicalize_dynamic_reloc
block|,
comment|/* Opposite endian version, none exists */
name|NULL
block|,
operator|(
name|void
operator|*
operator|)
operator|&
name|bfd_pmac_xcoff_backend_data
block|,   }
decl_stmt|;
end_decl_stmt

end_unit

