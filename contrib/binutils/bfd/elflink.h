begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ELF linker support.    Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002    Free Software Foundation, Inc.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* ELF linker code.  */
end_comment

begin_comment
comment|/* This struct is used to pass information to routines called via    elf_link_hash_traverse which must return failure.  */
end_comment

begin_struct
struct|struct
name|elf_info_failed
block|{
name|boolean
name|failed
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|bfd_elf_version_tree
modifier|*
name|verdefs
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|boolean
name|is_global_data_symbol_definition
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf_link_is_defined_archive_symbol
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|carsym
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf_link_add_object_symbols
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf_link_add_archive_symbols
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf_merge_symbol
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|,
name|asection
operator|*
operator|*
operator|,
name|bfd_vma
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|*
operator|,
name|boolean
operator|*
operator|,
name|boolean
operator|*
operator|,
name|boolean
operator|*
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf_add_default_symbol
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|,
name|asection
operator|*
operator|*
operator|,
name|bfd_vma
operator|*
operator|,
name|boolean
operator|*
operator|,
name|boolean
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf_export_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf_finalize_dynstr
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf_fix_symbol_flags
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
expr|struct
name|elf_info_failed
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf_adjust_dynamic_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf_link_find_version_dependencies
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf_link_assign_sym_version
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf_collect_hash_codes
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf_link_read_relocs_from_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf_Internal_Shdr
operator|*
operator|,
name|PTR
operator|,
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|compute_bucket_count
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|elf_link_output_relocs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|Elf_Internal_Shdr
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf_link_size_reloc_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf_Internal_Shdr
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|elf_link_adjust_relocs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf_Internal_Shdr
operator|*
operator|,
name|unsigned
name|int
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|elf_link_sort_cmp1
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|elf_link_sort_cmp2
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|elf_link_sort_relocs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|asection
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf_section_ignore_discarded_relocs
name|PARAMS
argument_list|(
operator|(
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Given an ELF BFD, add symbols to the global hash table as    appropriate.  */
end_comment

begin_function
name|boolean
name|elf_bfd_link_add_symbols
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
switch|switch
condition|(
name|bfd_get_format
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
case|case
name|bfd_object
case|:
return|return
name|elf_link_add_object_symbols
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
return|;
case|case
name|bfd_archive
case|:
return|return
name|elf_link_add_archive_symbols
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
return|;
default|default:
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return true iff this is a non-common, definition of a non-function symbol.  */
end_comment

begin_function
specifier|static
name|boolean
name|is_global_data_symbol_definition
parameter_list|(
name|abfd
parameter_list|,
name|sym
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
block|{
comment|/* Local symbols do not count, but target specific ones might.  */
if|if
condition|(
name|ELF_ST_BIND
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|!=
name|STB_GLOBAL
operator|&&
name|ELF_ST_BIND
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|<
name|STB_LOOS
condition|)
return|return
name|false
return|;
comment|/* Function symbols do not count.  */
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_FUNC
condition|)
return|return
name|false
return|;
comment|/* If the section is undefined, then so is the symbol.  */
if|if
condition|(
name|sym
operator|->
name|st_shndx
operator|==
name|SHN_UNDEF
condition|)
return|return
name|false
return|;
comment|/* If the symbol is defined in the common section, then      it is a common definition and so does not count.  */
if|if
condition|(
name|sym
operator|->
name|st_shndx
operator|==
name|SHN_COMMON
condition|)
return|return
name|false
return|;
comment|/* If the symbol is in a target specific section then we      must rely upon the backend to tell us what it is.  */
if|if
condition|(
name|sym
operator|->
name|st_shndx
operator|>=
name|SHN_LORESERVE
operator|&&
name|sym
operator|->
name|st_shndx
operator|<
name|SHN_ABS
condition|)
comment|/* FIXME - this function is not coded yet:         return _bfd_is_global_symbol_definition (abfd, sym);         Instead for now assume that the definition is not global,        Even if this is wrong, at least the linker will behave        in the same way that it used to do.  */
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Search the symbol table of the archive element of the archive ABFD    whose archive map contains a mention of SYMDEF, and determine if    the symbol is defined in this element.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf_link_is_defined_archive_symbol
parameter_list|(
name|abfd
parameter_list|,
name|symdef
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|carsym
modifier|*
name|symdef
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|shndx_hdr
decl_stmt|;
name|Elf_External_Sym
modifier|*
name|esym
decl_stmt|;
name|Elf_External_Sym
modifier|*
name|esymend
decl_stmt|;
name|Elf_External_Sym
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|Elf_External_Sym_Shndx
modifier|*
name|shndx_buf
init|=
name|NULL
decl_stmt|;
name|Elf_External_Sym_Shndx
modifier|*
name|shndx
decl_stmt|;
name|bfd_size_type
name|symcount
decl_stmt|;
name|bfd_size_type
name|extsymcount
decl_stmt|;
name|bfd_size_type
name|extsymoff
decl_stmt|;
name|boolean
name|result
init|=
name|false
decl_stmt|;
name|file_ptr
name|pos
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|abfd
operator|=
name|_bfd_get_elt_at_filepos
argument_list|(
name|abfd
argument_list|,
name|symdef
operator|->
name|file_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|abfd
operator|==
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|bfd_check_format
argument_list|(
name|abfd
argument_list|,
name|bfd_object
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* If we have already included the element containing this symbol in the      link then we do not need to include it again.  Just claim that any symbol      it contains is not a definition, so that our caller will not decide to      (re)include this element.  */
if|if
condition|(
name|abfd
operator|->
name|archive_pass
condition|)
return|return
name|false
return|;
comment|/* Select the appropriate symbol table.  */
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|==
literal|0
operator|||
name|elf_dynsymtab
argument_list|(
name|abfd
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|shndx_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_shndx_hdr
expr_stmt|;
block|}
else|else
block|{
name|hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|dynsymtab_hdr
expr_stmt|;
name|shndx_hdr
operator|=
name|NULL
expr_stmt|;
block|}
name|symcount
operator|=
name|hdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
expr_stmt|;
comment|/* The sh_info field of the symtab header tells us where the      external symbols start.  We don't care about the local symbols.  */
if|if
condition|(
name|elf_bad_symtab
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|extsymcount
operator|=
name|symcount
expr_stmt|;
name|extsymoff
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|extsymcount
operator|=
name|symcount
operator|-
name|hdr
operator|->
name|sh_info
expr_stmt|;
name|extsymoff
operator|=
name|hdr
operator|->
name|sh_info
expr_stmt|;
block|}
name|amt
operator|=
name|extsymcount
operator|*
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|Elf_External_Sym
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
operator|&&
name|extsymcount
operator|!=
literal|0
condition|)
return|return
name|false
return|;
comment|/* Read in the symbol table.      FIXME:  This ought to be cached somewhere.  */
name|pos
operator|=
name|hdr
operator|->
name|sh_offset
operator|+
name|extsymoff
operator|*
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|pos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bread
argument_list|(
operator|(
name|PTR
operator|)
name|buf
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
goto|goto
name|error_exit
goto|;
if|if
condition|(
name|shndx_hdr
operator|!=
name|NULL
operator|&&
name|shndx_hdr
operator|->
name|sh_size
operator|!=
literal|0
condition|)
block|{
name|amt
operator|=
name|extsymcount
operator|*
sizeof|sizeof
argument_list|(
name|Elf_External_Sym_Shndx
argument_list|)
expr_stmt|;
name|shndx_buf
operator|=
operator|(
name|Elf_External_Sym_Shndx
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|shndx_buf
operator|==
name|NULL
operator|&&
name|extsymcount
operator|!=
literal|0
condition|)
goto|goto
name|error_exit
goto|;
name|pos
operator|=
name|shndx_hdr
operator|->
name|sh_offset
operator|+
name|extsymoff
operator|*
sizeof|sizeof
argument_list|(
name|Elf_External_Sym_Shndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|pos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bread
argument_list|(
operator|(
name|PTR
operator|)
name|shndx_buf
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
goto|goto
name|error_exit
goto|;
block|}
comment|/* Scan the symbol table looking for SYMDEF.  */
name|esymend
operator|=
name|buf
operator|+
name|extsymcount
expr_stmt|;
for|for
control|(
name|esym
operator|=
name|buf
operator|,
name|shndx
operator|=
name|shndx_buf
init|;
name|esym
operator|<
name|esymend
condition|;
name|esym
operator|++
operator|,
name|shndx
operator|=
operator|(
name|shndx
operator|!=
name|NULL
condition|?
name|shndx
operator|+
literal|1
else|:
name|NULL
operator|)
control|)
block|{
name|Elf_Internal_Sym
name|sym
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|elf_swap_symbol_in
argument_list|(
name|abfd
argument_list|,
name|esym
argument_list|,
name|shndx
argument_list|,
operator|&
name|sym
argument_list|)
expr_stmt|;
name|name
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|sh_link
argument_list|,
name|sym
operator|.
name|st_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
condition|)
break|break;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|symdef
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|result
operator|=
name|is_global_data_symbol_definition
argument_list|(
name|abfd
argument_list|,
operator|&
name|sym
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|error_exit
label|:
if|if
condition|(
name|shndx_buf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|shndx_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add symbols from an ELF archive file to the linker hash table.  We    don't use _bfd_generic_link_add_archive_symbols because of a    problem which arises on UnixWare.  The UnixWare libc.so is an    archive which includes an entry libc.so.1 which defines a bunch of    symbols.  The libc.so archive also includes a number of other    object files, which also define symbols, some of which are the same    as those defined in libc.so.1.  Correct linking requires that we    consider each object file in turn, and include it if it defines any    symbols we need.  _bfd_generic_link_add_archive_symbols does not do    this; it looks through the list of undefined symbols, and includes    any object file which defines them.  When this algorithm is used on    UnixWare, it winds up pulling in libc.so.1 early and defining a    bunch of symbols.  This means that some of the other objects in the    archive are not included in the link, which is incorrect since they    precede libc.so.1 in the archive.     Fortunately, ELF archive handling is simpler than that done by    _bfd_generic_link_add_archive_symbols, which has to allow for a.out    oddities.  In ELF, if we find a symbol in the archive map, and the    symbol is currently undefined, we know that we must pull in that    object file.     Unfortunately, we do have to make multiple passes over the symbol    table until nothing further is resolved.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf_link_add_archive_symbols
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|symindex
name|c
decl_stmt|;
name|boolean
modifier|*
name|defined
init|=
name|NULL
decl_stmt|;
name|boolean
modifier|*
name|included
init|=
name|NULL
decl_stmt|;
name|carsym
modifier|*
name|symdefs
decl_stmt|;
name|boolean
name|loop
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
if|if
condition|(
operator|!
name|bfd_has_map
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
comment|/* An empty archive is a special case.  */
if|if
condition|(
name|bfd_openr_next_archived_file
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd
operator|*
operator|)
name|NULL
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|true
return|;
name|bfd_set_error
argument_list|(
name|bfd_error_no_armap
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Keep track of all symbols we know to be already defined, and all      files we know to be already included.  This is to speed up the      second and subsequent passes.  */
name|c
operator|=
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symdef_count
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
return|return
name|true
return|;
name|amt
operator|=
name|c
expr_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
name|boolean
argument_list|)
expr_stmt|;
name|defined
operator|=
operator|(
name|boolean
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
name|included
operator|=
operator|(
name|boolean
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|defined
operator|==
operator|(
name|boolean
operator|*
operator|)
name|NULL
operator|||
name|included
operator|==
operator|(
name|boolean
operator|*
operator|)
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|memset
argument_list|(
name|defined
argument_list|,
literal|0
argument_list|,
operator|(
name|size_t
operator|)
name|amt
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|included
argument_list|,
literal|0
argument_list|,
operator|(
name|size_t
operator|)
name|amt
argument_list|)
expr_stmt|;
name|symdefs
operator|=
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symdefs
expr_stmt|;
do|do
block|{
name|file_ptr
name|last
decl_stmt|;
name|symindex
name|i
decl_stmt|;
name|carsym
modifier|*
name|symdef
decl_stmt|;
name|carsym
modifier|*
name|symdefend
decl_stmt|;
name|loop
operator|=
name|false
expr_stmt|;
name|last
operator|=
operator|-
literal|1
expr_stmt|;
name|symdef
operator|=
name|symdefs
expr_stmt|;
name|symdefend
operator|=
name|symdef
operator|+
name|c
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|symdef
operator|<
name|symdefend
condition|;
name|symdef
operator|++
operator|,
name|i
operator|++
control|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|bfd
modifier|*
name|element
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|undefs_tail
decl_stmt|;
name|symindex
name|mark
decl_stmt|;
if|if
condition|(
name|defined
index|[
name|i
index|]
operator|||
name|included
index|[
name|i
index|]
condition|)
continue|continue;
if|if
condition|(
name|symdef
operator|->
name|file_offset
operator|==
name|last
condition|)
block|{
name|included
index|[
name|i
index|]
operator|=
name|true
expr_stmt|;
continue|continue;
block|}
name|h
operator|=
name|elf_link_hash_lookup
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|symdef
operator|->
name|name
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|copy
decl_stmt|;
comment|/* If this is a default version (the name contains @@), 		 look up the symbol again without the version.  The 		 effect is that references to the symbol without the 		 version will be matched by the default symbol in the 		 archive.  */
name|p
operator|=
name|strchr
argument_list|(
name|symdef
operator|->
name|name
argument_list|,
name|ELF_VER_CHR
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|p
index|[
literal|1
index|]
operator|!=
name|ELF_VER_CHR
condition|)
continue|continue;
name|copy
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
call|(
name|bfd_size_type
call|)
argument_list|(
name|p
operator|-
name|symdef
operator|->
name|name
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|copy
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|memcpy
argument_list|(
name|copy
argument_list|,
name|symdef
operator|->
name|name
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|p
operator|-
name|symdef
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|copy
index|[
name|p
operator|-
name|symdef
operator|->
name|name
index|]
operator|=
literal|'\0'
expr_stmt|;
name|h
operator|=
name|elf_link_hash_lookup
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|copy
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|copy
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_common
condition|)
block|{
comment|/* We currently have a common symbol.  The archive map contains 		 a reference to this symbol, so we may want to include it.  We 		 only want to include it however, if this archive element 		 contains a definition of the symbol, not just another common 		 declaration of it.  		 Unfortunately some archivers (including GNU ar) will put 		 declarations of common symbols into their archive maps, as 		 well as real definitions, so we cannot just go by the archive 		 map alone.  Instead we must read in the element's symbol 		 table and check that to see what kind of symbol definition 		 this is.  */
if|if
condition|(
operator|!
name|elf_link_is_defined_archive_symbol
argument_list|(
name|abfd
argument_list|,
name|symdef
argument_list|)
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefined
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefweak
condition|)
name|defined
index|[
name|i
index|]
operator|=
name|true
expr_stmt|;
continue|continue;
block|}
comment|/* We need to include this archive member.  */
name|element
operator|=
name|_bfd_get_elt_at_filepos
argument_list|(
name|abfd
argument_list|,
name|symdef
operator|->
name|file_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|element
operator|==
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|bfd_check_format
argument_list|(
name|element
argument_list|,
name|bfd_object
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* Doublecheck that we have not included this object 	     already--it should be impossible, but there may be 	     something wrong with the archive.  */
if|if
condition|(
name|element
operator|->
name|archive_pass
operator|!=
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|element
operator|->
name|archive_pass
operator|=
literal|1
expr_stmt|;
name|undefs_tail
operator|=
name|info
operator|->
name|hash
operator|->
name|undefs_tail
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|add_archive_element
call|)
argument_list|(
name|info
argument_list|,
name|element
argument_list|,
name|symdef
operator|->
name|name
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|elf_link_add_object_symbols
argument_list|(
name|element
argument_list|,
name|info
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* If there are any new undefined symbols, we need to make 	     another pass through the archive in order to see whether 	     they can be defined.  FIXME: This isn't perfect, because 	     common symbols wind up on undefs_tail and because an 	     undefined symbol which is defined later on in this pass 	     does not require another pass.  This isn't a bug, but it 	     does make the code less efficient than it could be.  */
if|if
condition|(
name|undefs_tail
operator|!=
name|info
operator|->
name|hash
operator|->
name|undefs_tail
condition|)
name|loop
operator|=
name|true
expr_stmt|;
comment|/* Look backward to mark all symbols from this object file 	     which we have already seen in this pass.  */
name|mark
operator|=
name|i
expr_stmt|;
do|do
block|{
name|included
index|[
name|mark
index|]
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|mark
operator|==
literal|0
condition|)
break|break;
operator|--
name|mark
expr_stmt|;
block|}
do|while
condition|(
name|symdefs
index|[
name|mark
index|]
operator|.
name|file_offset
operator|==
name|symdef
operator|->
name|file_offset
condition|)
do|;
comment|/* We mark subsequent symbols from this object file as we go 	     on through the loop.  */
name|last
operator|=
name|symdef
operator|->
name|file_offset
expr_stmt|;
block|}
block|}
do|while
condition|(
name|loop
condition|)
do|;
name|free
argument_list|(
name|defined
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|included
argument_list|)
expr_stmt|;
return|return
name|true
return|;
name|error_return
label|:
if|if
condition|(
name|defined
operator|!=
operator|(
name|boolean
operator|*
operator|)
name|NULL
condition|)
name|free
argument_list|(
name|defined
argument_list|)
expr_stmt|;
if|if
condition|(
name|included
operator|!=
operator|(
name|boolean
operator|*
operator|)
name|NULL
condition|)
name|free
argument_list|(
name|included
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* This function is called when we want to define a new symbol.  It    handles the various cases which arise when we find a definition in    a dynamic object, or when there is already a definition in a    dynamic object.  The new symbol is described by NAME, SYM, PSEC,    and PVALUE.  We set SYM_HASH to the hash table entry.  We set    OVERRIDE if the old symbol is overriding a new definition.  We set    TYPE_CHANGE_OK if it is OK for the type to change.  We set    SIZE_CHANGE_OK if it is OK for the size to change.  By OK to    change, we mean that we shouldn't warn if the type or size does    change. DT_NEEDED indicates if it comes from a DT_NEEDED entry of    a shared object.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf_merge_symbol
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|name
parameter_list|,
name|sym
parameter_list|,
name|psec
parameter_list|,
name|pvalue
parameter_list|,
name|sym_hash
parameter_list|,
name|override
parameter_list|,
name|type_change_ok
parameter_list|,
name|size_change_ok
parameter_list|,
name|dt_needed
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|asection
modifier|*
modifier|*
name|psec
decl_stmt|;
name|bfd_vma
modifier|*
name|pvalue
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hash
decl_stmt|;
name|boolean
modifier|*
name|override
decl_stmt|;
name|boolean
modifier|*
name|type_change_ok
decl_stmt|;
name|boolean
modifier|*
name|size_change_ok
decl_stmt|;
name|boolean
name|dt_needed
decl_stmt|;
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|int
name|bind
decl_stmt|;
name|bfd
modifier|*
name|oldbfd
decl_stmt|;
name|boolean
name|newdyn
decl_stmt|,
name|olddyn
decl_stmt|,
name|olddef
decl_stmt|,
name|newdef
decl_stmt|,
name|newdyncommon
decl_stmt|,
name|olddyncommon
decl_stmt|;
operator|*
name|override
operator|=
name|false
expr_stmt|;
name|sec
operator|=
operator|*
name|psec
expr_stmt|;
name|bind
operator|=
name|ELF_ST_BIND
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_is_und_section
argument_list|(
name|sec
argument_list|)
condition|)
name|h
operator|=
name|elf_link_hash_lookup
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|name
argument_list|,
name|true
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
else|else
name|h
operator|=
operator|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|bfd_wrapped_link_hash_lookup
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|name
argument_list|,
name|true
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
return|return
name|false
return|;
operator|*
name|sym_hash
operator|=
name|h
expr_stmt|;
comment|/* This code is for coping with dynamic objects, and is only useful      if we are doing an ELF link.  */
if|if
condition|(
name|info
operator|->
name|hash
operator|->
name|creator
operator|!=
name|abfd
operator|->
name|xvec
condition|)
return|return
name|true
return|;
comment|/* For merging, we only care about real symbols.  */
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
comment|/* If we just created the symbol, mark it as being an ELF symbol.      Other than that, there is nothing to do--there is no merge issue      with a newly defined symbol--so we just return.  */
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_new
condition|)
block|{
name|h
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_NON_ELF
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* OLDBFD is a BFD associated with the existing symbol.  */
switch|switch
condition|(
name|h
operator|->
name|root
operator|.
name|type
condition|)
block|{
default|default:
name|oldbfd
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|bfd_link_hash_undefined
case|:
case|case
name|bfd_link_hash_undefweak
case|:
name|oldbfd
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|undef
operator|.
name|abfd
expr_stmt|;
break|break;
case|case
name|bfd_link_hash_defined
case|:
case|case
name|bfd_link_hash_defweak
case|:
name|oldbfd
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
expr_stmt|;
break|break;
case|case
name|bfd_link_hash_common
case|:
name|oldbfd
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
operator|->
name|owner
expr_stmt|;
break|break;
block|}
comment|/* In cases involving weak versioned symbols, we may wind up trying      to merge a symbol with itself.  Catch that here, to avoid the      confusion that results if we try to override a symbol with      itself.  The additional tests catch cases like      _GLOBAL_OFFSET_TABLE_, which are regular symbols defined in a      dynamic object, which we do want to handle here.  */
if|if
condition|(
name|abfd
operator|==
name|oldbfd
operator|&&
operator|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|==
literal|0
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
condition|)
return|return
name|true
return|;
comment|/* NEWDYN and OLDDYN indicate whether the new or old symbol,      respectively, is from a dynamic object.  */
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
condition|)
name|newdyn
operator|=
name|true
expr_stmt|;
else|else
name|newdyn
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|oldbfd
operator|!=
name|NULL
condition|)
name|olddyn
operator|=
operator|(
name|oldbfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
expr_stmt|;
else|else
block|{
name|asection
modifier|*
name|hsec
decl_stmt|;
comment|/* This code handles the special SHN_MIPS_{TEXT,DATA} section 	 indices used by MIPS ELF.  */
switch|switch
condition|(
name|h
operator|->
name|root
operator|.
name|type
condition|)
block|{
default|default:
name|hsec
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|bfd_link_hash_defined
case|:
case|case
name|bfd_link_hash_defweak
case|:
name|hsec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
break|break;
case|case
name|bfd_link_hash_common
case|:
name|hsec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|hsec
operator|==
name|NULL
condition|)
name|olddyn
operator|=
name|false
expr_stmt|;
else|else
name|olddyn
operator|=
operator|(
name|hsec
operator|->
name|symbol
operator|->
name|flags
operator|&
name|BSF_DYNAMIC
operator|)
operator|!=
literal|0
expr_stmt|;
block|}
comment|/* NEWDEF and OLDDEF indicate whether the new or old symbol,      respectively, appear to be a definition rather than reference.  */
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|sec
argument_list|)
operator|||
name|bfd_is_com_section
argument_list|(
name|sec
argument_list|)
condition|)
name|newdef
operator|=
name|false
expr_stmt|;
else|else
name|newdef
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_common
condition|)
name|olddef
operator|=
name|false
expr_stmt|;
else|else
name|olddef
operator|=
name|true
expr_stmt|;
comment|/* NEWDYNCOMMON and OLDDYNCOMMON indicate whether the new or old      symbol, respectively, appears to be a common symbol in a dynamic      object.  If a symbol appears in an uninitialized section, and is      not weak, and is not a function, then it may be a common symbol      which was resolved when the dynamic object was created.  We want      to treat such symbols specially, because they raise special      considerations when setting the symbol size: if the symbol      appears as a common symbol in a regular object, and the size in      the regular object is larger, we must make sure that we use the      larger size.  This problematic case can always be avoided in C,      but it must be handled correctly when using Fortran shared      libraries.       Note that if NEWDYNCOMMON is set, NEWDEF will be set, and      likewise for OLDDYNCOMMON and OLDDEF.       Note that this test is just a heuristic, and that it is quite      possible to have an uninitialized symbol in a shared object which      is really a definition, rather than a common symbol.  This could      lead to some minor confusion when the symbol really is a common      symbol in some regular object.  However, I think it will be      harmless.  */
if|if
condition|(
name|newdyn
operator|&&
name|newdef
operator|&&
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|==
literal|0
operator|&&
name|sym
operator|->
name|st_size
operator|>
literal|0
operator|&&
name|bind
operator|!=
name|STB_WEAK
operator|&&
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|!=
name|STT_FUNC
condition|)
name|newdyncommon
operator|=
name|true
expr_stmt|;
else|else
name|newdyncommon
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|olddyn
operator|&&
name|olddef
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|==
literal|0
operator|&&
name|h
operator|->
name|size
operator|>
literal|0
operator|&&
name|h
operator|->
name|type
operator|!=
name|STT_FUNC
condition|)
name|olddyncommon
operator|=
name|true
expr_stmt|;
else|else
name|olddyncommon
operator|=
name|false
expr_stmt|;
comment|/* It's OK to change the type if either the existing symbol or the      new symbol is weak unless it comes from a DT_NEEDED entry of      a shared object, in which case, the DT_NEEDED entry may not be      required at the run time.  */
if|if
condition|(
operator|(
operator|!
name|dt_needed
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|||
name|bind
operator|==
name|STB_WEAK
condition|)
operator|*
name|type_change_ok
operator|=
name|true
expr_stmt|;
comment|/* It's OK to change the size if either the existing symbol or the      new symbol is weak, or if the old symbol is undefined.  */
if|if
condition|(
operator|*
name|type_change_ok
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
condition|)
operator|*
name|size_change_ok
operator|=
name|true
expr_stmt|;
comment|/* If both the old and the new symbols look like common symbols in a      dynamic object, set the size of the symbol to the larger of the      two.  */
if|if
condition|(
name|olddyncommon
operator|&&
name|newdyncommon
operator|&&
name|sym
operator|->
name|st_size
operator|!=
name|h
operator|->
name|size
condition|)
block|{
comment|/* Since we think we have two common symbols, issue a multiple 	 common warning if desired.  Note that we only warn if the 	 size is different.  If the size is the same, we simply let 	 the old symbol override the new one as normally happens with 	 symbols defined in dynamic objects.  */
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|multiple_common
call|)
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|oldbfd
argument_list|,
name|bfd_link_hash_common
argument_list|,
name|h
operator|->
name|size
argument_list|,
name|abfd
argument_list|,
name|bfd_link_hash_common
argument_list|,
name|sym
operator|->
name|st_size
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|sym
operator|->
name|st_size
operator|>
name|h
operator|->
name|size
condition|)
name|h
operator|->
name|size
operator|=
name|sym
operator|->
name|st_size
expr_stmt|;
operator|*
name|size_change_ok
operator|=
name|true
expr_stmt|;
block|}
comment|/* If we are looking at a dynamic object, and we have found a      definition, we need to see if the symbol was already defined by      some other object.  If so, we want to use the existing      definition, and we do not want to report a multiple symbol      definition error; we do this by clobbering *PSEC to be      bfd_und_section_ptr.       We treat a common symbol as a definition if the symbol in the      shared library is a function, since common symbols always      represent variables; this can cause confusion in principle, but      any such confusion would seem to indicate an erroneous program or      shared library.  We also permit a common symbol in a regular      object to override a weak symbol in a shared object.       We prefer a non-weak definition in a shared library to a weak      definition in the executable unless it comes from a DT_NEEDED      entry of a shared object, in which case, the DT_NEEDED entry      may not be required at the run time.  */
if|if
condition|(
name|newdyn
operator|&&
name|newdef
operator|&&
operator|(
name|olddef
operator|||
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_common
operator|&&
operator|(
name|bind
operator|==
name|STB_WEAK
operator|||
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_FUNC
operator|)
operator|)
operator|)
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
operator|||
name|dt_needed
operator|||
name|bind
operator|==
name|STB_WEAK
operator|)
condition|)
block|{
operator|*
name|override
operator|=
name|true
expr_stmt|;
name|newdef
operator|=
name|false
expr_stmt|;
name|newdyncommon
operator|=
name|false
expr_stmt|;
operator|*
name|psec
operator|=
name|sec
operator|=
name|bfd_und_section_ptr
expr_stmt|;
operator|*
name|size_change_ok
operator|=
name|true
expr_stmt|;
comment|/* If we get here when the old symbol is a common symbol, then 	 we are explicitly letting it override a weak symbol or 	 function in a dynamic object, and we don't want to warn about 	 a type change.  If the old symbol is a defined symbol, a type 	 change warning may still be appropriate.  */
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_common
condition|)
operator|*
name|type_change_ok
operator|=
name|true
expr_stmt|;
block|}
comment|/* Handle the special case of an old common symbol merging with a      new symbol which looks like a common symbol in a shared object.      We change *PSEC and *PVALUE to make the new symbol look like a      common symbol, and let _bfd_generic_link_add_one_symbol will do      the right thing.  */
if|if
condition|(
name|newdyncommon
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_common
condition|)
block|{
operator|*
name|override
operator|=
name|true
expr_stmt|;
name|newdef
operator|=
name|false
expr_stmt|;
name|newdyncommon
operator|=
name|false
expr_stmt|;
operator|*
name|pvalue
operator|=
name|sym
operator|->
name|st_size
expr_stmt|;
operator|*
name|psec
operator|=
name|sec
operator|=
name|bfd_com_section_ptr
expr_stmt|;
operator|*
name|size_change_ok
operator|=
name|true
expr_stmt|;
block|}
comment|/* If the old symbol is from a dynamic object, and the new symbol is      a definition which is not from a dynamic object, then the new      symbol overrides the old symbol.  Symbols from regular files      always take precedence over symbols from dynamic objects, even if      they are defined after the dynamic object in the link.       As above, we again permit a common symbol in a regular object to      override a definition in a shared object if the shared object      symbol is a function or is weak.       As above, we permit a non-weak definition in a shared object to      override a weak definition in a regular object.  */
if|if
condition|(
operator|!
name|newdyn
operator|&&
operator|(
name|newdef
operator|||
operator|(
name|bfd_is_com_section
argument_list|(
name|sec
argument_list|)
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|||
name|h
operator|->
name|type
operator|==
name|STT_FUNC
operator|)
operator|)
operator|)
operator|&&
name|olddyn
operator|&&
name|olddef
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|bind
operator|!=
name|STB_WEAK
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
condition|)
block|{
comment|/* Change the hash table entry to undefined, and let 	 _bfd_generic_link_add_one_symbol do the right thing with the 	 new definition.  */
name|h
operator|->
name|root
operator|.
name|type
operator|=
name|bfd_link_hash_undefined
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|undef
operator|.
name|abfd
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
expr_stmt|;
operator|*
name|size_change_ok
operator|=
name|true
expr_stmt|;
name|olddef
operator|=
name|false
expr_stmt|;
name|olddyncommon
operator|=
name|false
expr_stmt|;
comment|/* We again permit a type change when a common symbol may be 	 overriding a function.  */
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|sec
argument_list|)
condition|)
operator|*
name|type_change_ok
operator|=
name|true
expr_stmt|;
comment|/* This union may have been set to be non-NULL when this symbol 	 was seen in a dynamic object.  We must force the union to be 	 NULL, so that it is correct for a regular symbol.  */
name|h
operator|->
name|verinfo
operator|.
name|vertree
operator|=
name|NULL
expr_stmt|;
comment|/* In this special case, if H is the target of an indirection, 	 we want the caller to frob with H rather than with the 	 indirect symbol.  That will permit the caller to redefine the 	 target of the indirection, rather than the indirect symbol 	 itself.  FIXME: This will break the -y option if we store a 	 symbol with a different name.  */
operator|*
name|sym_hash
operator|=
name|h
expr_stmt|;
block|}
comment|/* Handle the special case of a new common symbol merging with an      old symbol that looks like it might be a common symbol defined in      a shared object.  Note that we have already handled the case in      which a new common symbol should simply override the definition      in the shared library.  */
if|if
condition|(
operator|!
name|newdyn
operator|&&
name|bfd_is_com_section
argument_list|(
name|sec
argument_list|)
operator|&&
name|olddyncommon
condition|)
block|{
comment|/* It would be best if we could set the hash table entry to a 	 common symbol, but we don't know what to use for the section 	 or the alignment.  */
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|multiple_common
call|)
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|oldbfd
argument_list|,
name|bfd_link_hash_common
argument_list|,
name|h
operator|->
name|size
argument_list|,
name|abfd
argument_list|,
name|bfd_link_hash_common
argument_list|,
name|sym
operator|->
name|st_size
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
comment|/* If the predumed common symbol in the dynamic object is 	 larger, pretend that the new symbol has its size.  */
if|if
condition|(
name|h
operator|->
name|size
operator|>
operator|*
name|pvalue
condition|)
operator|*
name|pvalue
operator|=
name|h
operator|->
name|size
expr_stmt|;
comment|/* FIXME: We no longer know the alignment required by the symbol 	 in the dynamic object, so we just wind up using the one from 	 the regular object.  */
name|olddef
operator|=
name|false
expr_stmt|;
name|olddyncommon
operator|=
name|false
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|type
operator|=
name|bfd_link_hash_undefined
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|undef
operator|.
name|abfd
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
expr_stmt|;
operator|*
name|size_change_ok
operator|=
name|true
expr_stmt|;
operator|*
name|type_change_ok
operator|=
name|true
expr_stmt|;
name|h
operator|->
name|verinfo
operator|.
name|vertree
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Handle the special case of a weak definition in a regular object      followed by a non-weak definition in a shared object.  In this      case, we prefer the definition in the shared object unless it      comes from a DT_NEEDED entry of a shared object, in which case,      the DT_NEEDED entry may not be required at the run time.  */
if|if
condition|(
name|olddef
operator|&&
operator|!
name|dt_needed
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|&&
name|newdef
operator|&&
name|newdyn
operator|&&
name|bind
operator|!=
name|STB_WEAK
condition|)
block|{
comment|/* To make this work we have to frob the flags so that the rest 	 of the code does not think we are using the regular 	 definition.  */
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|!=
literal|0
condition|)
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_REF_REGULAR
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|!=
literal|0
condition|)
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_REF_DYNAMIC
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
operator|(
name|ELF_LINK_HASH_DEF_REGULAR
operator||
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
expr_stmt|;
comment|/* If H is the target of an indirection, we want the caller to 	 use H rather than the indirect symbol.  Otherwise if we are 	 defining a new indirect symbol we will wind up attaching it 	 to the entry we are overriding.  */
operator|*
name|sym_hash
operator|=
name|h
expr_stmt|;
block|}
comment|/* Handle the special case of a non-weak definition in a shared      object followed by a weak definition in a regular object.  In      this case we prefer to definition in the shared object.  To make      this work we have to tell the caller to not treat the new symbol      as a definition.  */
if|if
condition|(
name|olddef
operator|&&
name|olddyn
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
operator|&&
name|newdef
operator|&&
operator|!
name|newdyn
operator|&&
name|bind
operator|==
name|STB_WEAK
condition|)
operator|*
name|override
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* This function is called to create an indirect symbol from the    default for the symbol with the default version if needed. The    symbol is described by H, NAME, SYM, SEC, VALUE, and OVERRIDE.  We    set DYNSYM if the new indirect symbol is dynamic. DT_NEEDED    indicates if it comes from a DT_NEEDED entry of a shared object.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf_add_default_symbol
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|h
parameter_list|,
name|name
parameter_list|,
name|sym
parameter_list|,
name|sec
parameter_list|,
name|value
parameter_list|,
name|dynsym
parameter_list|,
name|override
parameter_list|,
name|dt_needed
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|asection
modifier|*
modifier|*
name|sec
decl_stmt|;
name|bfd_vma
modifier|*
name|value
decl_stmt|;
name|boolean
modifier|*
name|dynsym
decl_stmt|;
name|boolean
name|override
decl_stmt|;
name|boolean
name|dt_needed
decl_stmt|;
block|{
name|boolean
name|type_change_ok
decl_stmt|;
name|boolean
name|size_change_ok
decl_stmt|;
name|char
modifier|*
name|shortname
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|hi
decl_stmt|;
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
name|boolean
name|collect
decl_stmt|;
name|boolean
name|dynamic
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* If this symbol has a version, and it is the default version, we      create an indirect symbol from the default name to the fully      decorated name.  This will cause external references which do not      specify a version to be bound to this version of the symbol.  */
name|p
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
name|ELF_VER_CHR
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|p
index|[
literal|1
index|]
operator|!=
name|ELF_VER_CHR
condition|)
return|return
name|true
return|;
if|if
condition|(
name|override
condition|)
block|{
comment|/* We are overridden by an old defition. We need to check if we 	 need to crreate the indirect symbol from the default name.  */
name|hi
operator|=
name|elf_link_hash_lookup
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|name
argument_list|,
name|true
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|hi
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|hi
operator|==
name|h
condition|)
return|return
name|true
return|;
while|while
condition|(
name|hi
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|hi
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
block|{
name|hi
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|hi
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|hi
operator|==
name|h
condition|)
return|return
name|true
return|;
block|}
block|}
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|collect
operator|=
name|bed
operator|->
name|collect
expr_stmt|;
name|dynamic
operator|=
operator|(
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
expr_stmt|;
name|shortname
operator|=
name|bfd_hash_allocate
argument_list|(
operator|&
name|info
operator|->
name|hash
operator|->
name|table
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|p
operator|-
name|name
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|shortname
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|strncpy
argument_list|(
name|shortname
argument_list|,
name|name
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|p
operator|-
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|shortname
index|[
name|p
operator|-
name|name
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* We are going to create a new symbol.  Merge it with any existing      symbol with this name.  For the purposes of the merge, act as      though we were defining the symbol we just defined, although we      actually going to define an indirect symbol.  */
name|type_change_ok
operator|=
name|false
expr_stmt|;
name|size_change_ok
operator|=
name|false
expr_stmt|;
if|if
condition|(
operator|!
name|elf_merge_symbol
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|shortname
argument_list|,
name|sym
argument_list|,
name|sec
argument_list|,
name|value
argument_list|,
operator|&
name|hi
argument_list|,
operator|&
name|override
argument_list|,
operator|&
name|type_change_ok
argument_list|,
operator|&
name|size_change_ok
argument_list|,
name|dt_needed
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|override
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
name|shortname
argument_list|,
name|BSF_INDIRECT
argument_list|,
name|bfd_ind_section_ptr
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|name
argument_list|,
name|false
argument_list|,
name|collect
argument_list|,
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|*
operator|)
operator|&
name|hi
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
comment|/* In this case the symbol named SHORTNAME is overriding the 	 indirect symbol we want to add.  We were planning on making 	 SHORTNAME an indirect symbol referring to NAME.  SHORTNAME 	 is the name without a version.  NAME is the fully versioned 	 name, and it is the default version.  	 Overriding means that we already saw a definition for the 	 symbol SHORTNAME in a regular object, and it is overriding 	 the symbol defined in the dynamic object.  	 When this happens, we actually want to change NAME, the 	 symbol we just added, to refer to SHORTNAME.  This will cause 	 references to NAME in the shared object to become references 	 to SHORTNAME in the regular object.  This is what we expect 	 when we override a function in a shared object: that the 	 references in the shared object will be mapped to the 	 definition in the regular object.  */
while|while
condition|(
name|hi
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|hi
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|hi
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|hi
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|type
operator|=
name|bfd_link_hash_indirect
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
operator|=
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|)
name|hi
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
condition|)
block|{
name|h
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_HASH_DEF_DYNAMIC
expr_stmt|;
name|hi
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_REF_DYNAMIC
expr_stmt|;
if|if
condition|(
name|hi
operator|->
name|elf_link_hash_flags
operator|&
operator|(
name|ELF_LINK_HASH_REF_REGULAR
operator||
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|_bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|hi
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
comment|/* Now set HI to H, so that the following code will set the 	 other fields correctly.  */
name|hi
operator|=
name|h
expr_stmt|;
block|}
comment|/* If there is a duplicate definition somewhere, then HI may not      point to an indirect symbol.  We will have reported an error to      the user in that case.  */
if|if
condition|(
name|hi
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|ht
decl_stmt|;
comment|/* If the symbol became indirect, then we assume that we have 	 not seen a definition before.  */
name|BFD_ASSERT
argument_list|(
operator|(
name|hi
operator|->
name|elf_link_hash_flags
operator|&
operator|(
name|ELF_LINK_HASH_DEF_DYNAMIC
operator||
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ht
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|hi
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
call|(
modifier|*
name|bed
operator|->
name|elf_backend_copy_indirect_symbol
call|)
argument_list|(
name|ht
argument_list|,
name|hi
argument_list|)
expr_stmt|;
comment|/* See if the new flags lead us to realize that the symbol must 	 be dynamic.  */
if|if
condition|(
operator|!
operator|*
name|dynsym
condition|)
block|{
if|if
condition|(
operator|!
name|dynamic
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|shared
operator|||
operator|(
operator|(
name|hi
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_REF_DYNAMIC
operator|)
operator|!=
literal|0
operator|)
condition|)
operator|*
name|dynsym
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|hi
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_REF_REGULAR
operator|)
operator|!=
literal|0
condition|)
operator|*
name|dynsym
operator|=
name|true
expr_stmt|;
block|}
block|}
block|}
comment|/* We also need to define an indirection from the nondefault version      of the symbol.  */
name|shortname
operator|=
name|bfd_hash_allocate
argument_list|(
operator|&
name|info
operator|->
name|hash
operator|->
name|table
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|shortname
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|strncpy
argument_list|(
name|shortname
argument_list|,
name|name
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|p
operator|-
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|shortname
operator|+
operator|(
name|p
operator|-
name|name
operator|)
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Once again, merge with any existing symbol.  */
name|type_change_ok
operator|=
name|false
expr_stmt|;
name|size_change_ok
operator|=
name|false
expr_stmt|;
if|if
condition|(
operator|!
name|elf_merge_symbol
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|shortname
argument_list|,
name|sym
argument_list|,
name|sec
argument_list|,
name|value
argument_list|,
operator|&
name|hi
argument_list|,
operator|&
name|override
argument_list|,
operator|&
name|type_change_ok
argument_list|,
operator|&
name|size_change_ok
argument_list|,
name|dt_needed
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|override
condition|)
block|{
comment|/* Here SHORTNAME is a versioned name, so we don't expect to see 	 the type of override we do in the case above.  */
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: warning: unexpected redefinition of `%s'"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|shortname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
name|shortname
argument_list|,
name|BSF_INDIRECT
argument_list|,
name|bfd_ind_section_ptr
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|name
argument_list|,
name|false
argument_list|,
name|collect
argument_list|,
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|*
operator|)
operator|&
name|hi
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
comment|/* If there is a duplicate definition somewhere, then HI may not 	 point to an indirect symbol.  We will have reported an error 	 to the user in that case.  */
if|if
condition|(
name|hi
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
condition|)
block|{
comment|/* If the symbol became indirect, then we assume that we have 	     not seen a definition before.  */
name|BFD_ASSERT
argument_list|(
operator|(
name|hi
operator|->
name|elf_link_hash_flags
operator|&
operator|(
name|ELF_LINK_HASH_DEF_DYNAMIC
operator||
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
call|(
modifier|*
name|bed
operator|->
name|elf_backend_copy_indirect_symbol
call|)
argument_list|(
name|h
argument_list|,
name|hi
argument_list|)
expr_stmt|;
comment|/* See if the new flags lead us to realize that the symbol 	     must be dynamic.  */
if|if
condition|(
operator|!
operator|*
name|dynsym
condition|)
block|{
if|if
condition|(
operator|!
name|dynamic
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|shared
operator|||
operator|(
operator|(
name|hi
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_REF_DYNAMIC
operator|)
operator|!=
literal|0
operator|)
condition|)
operator|*
name|dynsym
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|hi
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_REF_REGULAR
operator|)
operator|!=
literal|0
condition|)
operator|*
name|dynsym
operator|=
name|true
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Add symbols from an ELF object file to the linker hash table.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf_link_add_object_symbols
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|boolean
argument_list|(
argument|*add_symbol_hook
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
specifier|const
name|Elf_Internal_Sym
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|flagword
operator|*
operator|,
name|asection
operator|*
operator|*
operator|,
name|bfd_vma
operator|*
operator|)
argument_list|)
expr_stmt|;
name|boolean
argument_list|(
argument|*check_relocs
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|asection
operator|*
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
expr_stmt|;
name|boolean
name|collect
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|shndx_hdr
decl_stmt|;
name|bfd_size_type
name|symcount
decl_stmt|;
name|bfd_size_type
name|extsymcount
decl_stmt|;
name|bfd_size_type
name|extsymoff
decl_stmt|;
name|Elf_External_Sym
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|Elf_External_Sym_Shndx
modifier|*
name|shndx_buf
init|=
name|NULL
decl_stmt|;
name|Elf_External_Sym_Shndx
modifier|*
name|shndx
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hash
decl_stmt|;
name|boolean
name|dynamic
decl_stmt|;
name|Elf_External_Versym
modifier|*
name|extversym
init|=
name|NULL
decl_stmt|;
name|Elf_External_Versym
modifier|*
name|ever
decl_stmt|;
name|Elf_External_Dyn
modifier|*
name|dynbuf
init|=
name|NULL
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|weaks
decl_stmt|;
name|Elf_External_Sym
modifier|*
name|esym
decl_stmt|;
name|Elf_External_Sym
modifier|*
name|esymend
decl_stmt|;
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
name|boolean
name|dt_needed
decl_stmt|;
name|struct
name|elf_link_hash_table
modifier|*
name|hash_table
decl_stmt|;
name|file_ptr
name|pos
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|hash_table
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|add_symbol_hook
operator|=
name|bed
operator|->
name|elf_add_symbol_hook
expr_stmt|;
name|collect
operator|=
name|bed
operator|->
name|collect
expr_stmt|;
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|==
literal|0
condition|)
name|dynamic
operator|=
name|false
expr_stmt|;
else|else
block|{
name|dynamic
operator|=
name|true
expr_stmt|;
comment|/* You can't use -r against a dynamic object.  Also, there's no 	 hope of using a dynamic object which does not exactly match 	 the format of the output file.  */
if|if
condition|(
name|info
operator|->
name|relocateable
operator|||
name|info
operator|->
name|hash
operator|->
name|creator
operator|!=
name|abfd
operator|->
name|xvec
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
block|}
comment|/* As a GNU extension, any input sections which are named      .gnu.warning.SYMBOL are treated as warning symbols for the given      symbol.  This differs from .gnu.warning sections, which generate      warnings when they are included in an output file.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".gnu.warning."
argument_list|,
sizeof|sizeof
expr|".gnu.warning."
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|msg
decl_stmt|;
name|bfd_size_type
name|sz
decl_stmt|;
name|name
operator|+=
sizeof|sizeof
expr|".gnu.warning."
operator|-
literal|1
expr_stmt|;
comment|/* If this is a shared object, then look up the symbol 		 in the hash table.  If it is there, and it is already 		 been defined, then we will not be using the entry 		 from this shared object, so we don't need to warn. 		 FIXME: If we see the definition in a regular object 		 later on, we will warn, but we shouldn't.  The only 		 fix is to keep track of what warnings we are supposed 		 to emit, and then handle them all at the end of the 		 link.  */
if|if
condition|(
name|dynamic
operator|&&
name|abfd
operator|->
name|xvec
operator|==
name|info
operator|->
name|hash
operator|->
name|creator
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
name|elf_link_hash_lookup
argument_list|(
name|hash_table
argument_list|,
name|name
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* FIXME: What about bfd_link_hash_common?  */
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
condition|)
block|{
comment|/* We don't want to issue this warning.  Clobber 			 the section size so that the warning does not 			 get copied into the output file.  */
name|s
operator|->
name|_raw_size
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
block|}
name|sz
operator|=
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|sz
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|msg
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|sz
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
name|msg
index|[
name|sz
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
name|name
argument_list|,
name|BSF_WARNING
argument_list|,
name|s
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|msg
argument_list|,
name|false
argument_list|,
name|collect
argument_list|,
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|*
operator|)
name|NULL
argument_list|)
operator|)
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|info
operator|->
name|relocateable
condition|)
block|{
comment|/* Clobber the section size so that the warning does 		     not get copied into the output file.  */
name|s
operator|->
name|_raw_size
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* If this is a dynamic object, we always link against the .dynsym      symbol table, not the .symtab symbol table.  The dynamic linker      will only see the .dynsym symbol table, so there is no reason to      look at .symtab for a dynamic object.  */
if|if
condition|(
operator|!
name|dynamic
operator|||
name|elf_dynsymtab
argument_list|(
name|abfd
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|shndx_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_shndx_hdr
expr_stmt|;
block|}
else|else
block|{
name|hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|dynsymtab_hdr
expr_stmt|;
name|shndx_hdr
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|dynamic
condition|)
block|{
comment|/* Read in any version definitions.  */
if|if
condition|(
operator|!
name|_bfd_elf_slurp_version_tables
argument_list|(
name|abfd
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* Read in the symbol versions, but don't bother to convert them 	 to internal format.  */
if|if
condition|(
name|elf_dynversym
argument_list|(
name|abfd
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|versymhdr
decl_stmt|;
name|versymhdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|dynversym_hdr
expr_stmt|;
name|extversym
operator|=
operator|(
name|Elf_External_Versym
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|versymhdr
operator|->
name|sh_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|extversym
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|amt
operator|=
name|versymhdr
operator|->
name|sh_size
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|versymhdr
operator|->
name|sh_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bread
argument_list|(
operator|(
name|PTR
operator|)
name|extversym
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
goto|goto
name|error_return
goto|;
block|}
block|}
name|symcount
operator|=
name|hdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
expr_stmt|;
comment|/* The sh_info field of the symtab header tells us where the      external symbols start.  We don't care about the local symbols at      this point.  */
if|if
condition|(
name|elf_bad_symtab
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|extsymcount
operator|=
name|symcount
expr_stmt|;
name|extsymoff
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|extsymcount
operator|=
name|symcount
operator|-
name|hdr
operator|->
name|sh_info
expr_stmt|;
name|extsymoff
operator|=
name|hdr
operator|->
name|sh_info
expr_stmt|;
block|}
name|amt
operator|=
name|extsymcount
operator|*
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|Elf_External_Sym
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
operator|&&
name|extsymcount
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|shndx_hdr
operator|!=
name|NULL
operator|&&
name|shndx_hdr
operator|->
name|sh_size
operator|!=
literal|0
condition|)
block|{
name|amt
operator|=
name|extsymcount
operator|*
sizeof|sizeof
argument_list|(
name|Elf_External_Sym_Shndx
argument_list|)
expr_stmt|;
name|shndx_buf
operator|=
operator|(
name|Elf_External_Sym_Shndx
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|shndx_buf
operator|==
name|NULL
operator|&&
name|extsymcount
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
block|}
comment|/* We store a pointer to the hash table entry for each external      symbol.  */
name|amt
operator|=
name|extsymcount
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|elf_link_hash_entry
operator|*
argument_list|)
expr_stmt|;
name|sym_hash
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_hash
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
operator|=
name|sym_hash
expr_stmt|;
name|dt_needed
operator|=
name|false
expr_stmt|;
if|if
condition|(
operator|!
name|dynamic
condition|)
block|{
comment|/* If we are creating a shared library, create all the dynamic 	 sections immediately.  We need to attach them to something, 	 so we attach them to this BFD, provided it is the right 	 format.  FIXME: If there are no input BFD's of the same 	 format as the output, we can't make a shared library.  */
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
name|is_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|&&
operator|!
name|hash_table
operator|->
name|dynamic_sections_created
operator|&&
name|abfd
operator|->
name|xvec
operator|==
name|info
operator|->
name|hash
operator|->
name|creator
condition|)
block|{
if|if
condition|(
operator|!
name|elf_link_create_dynamic_sections
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|is_elf_hash_table
argument_list|(
name|info
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
else|else
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|boolean
name|add_needed
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bfd_size_type
name|oldsize
decl_stmt|;
name|bfd_size_type
name|strindex
decl_stmt|;
comment|/* Find the name to use in a DT_NEEDED entry that refers to this 	 object.  If the object has a DT_SONAME entry, we use it. 	 Otherwise, if the generic linker stuck something in 	 elf_dt_name, we use that.  Otherwise, we just use the file 	 name.  If the generic linker put a null string into 	 elf_dt_name, we don't make a DT_NEEDED entry at all, even if 	 there is a DT_SONAME entry.  */
name|add_needed
operator|=
name|true
expr_stmt|;
name|name
operator|=
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_dt_name
argument_list|(
name|abfd
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|name
operator|=
name|elf_dt_name
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|elf_dt_soname
argument_list|(
name|abfd
argument_list|)
operator|!=
name|NULL
condition|)
name|dt_needed
operator|=
name|true
expr_stmt|;
name|add_needed
operator|=
name|false
expr_stmt|;
block|}
block|}
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
name|Elf_External_Dyn
modifier|*
name|extdyn
decl_stmt|;
name|Elf_External_Dyn
modifier|*
name|extdynend
decl_stmt|;
name|int
name|elfsec
decl_stmt|;
name|unsigned
name|long
name|shlink
decl_stmt|;
name|int
name|rpath
decl_stmt|;
name|int
name|runpath
decl_stmt|;
name|dynbuf
operator|=
operator|(
name|Elf_External_Dyn
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynbuf
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
operator|(
name|PTR
operator|)
name|dynbuf
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|s
operator|->
name|_raw_size
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
name|elfsec
operator|=
name|_bfd_elf_section_from_bfd_section
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|elfsec
operator|==
operator|-
literal|1
condition|)
goto|goto
name|error_return
goto|;
name|shlink
operator|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
index|[
name|elfsec
index|]
operator|->
name|sh_link
expr_stmt|;
block|{
comment|/* The shared libraries distributed with hpux11 have a bogus 	       sh_link field for the ".dynamic" section.  This code detects 	       when SHLINK refers to a section that is not a string table 	       and tries to find the string table for the ".dynsym" section 	       instead.  */
name|Elf_Internal_Shdr
modifier|*
name|shdr
init|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
index|[
name|shlink
index|]
decl_stmt|;
if|if
condition|(
name|shdr
operator|->
name|sh_type
operator|!=
name|SHT_STRTAB
condition|)
block|{
name|asection
modifier|*
name|ds
init|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynsym"
argument_list|)
decl_stmt|;
name|int
name|elfdsec
init|=
name|_bfd_elf_section_from_bfd_section
argument_list|(
name|abfd
argument_list|,
name|ds
argument_list|)
decl_stmt|;
if|if
condition|(
name|elfdsec
operator|==
operator|-
literal|1
condition|)
goto|goto
name|error_return
goto|;
name|shlink
operator|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
index|[
name|elfdsec
index|]
operator|->
name|sh_link
expr_stmt|;
block|}
block|}
name|extdyn
operator|=
name|dynbuf
expr_stmt|;
name|extdynend
operator|=
name|extdyn
operator|+
name|s
operator|->
name|_raw_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf_External_Dyn
argument_list|)
expr_stmt|;
name|rpath
operator|=
literal|0
expr_stmt|;
name|runpath
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|extdyn
operator|<
name|extdynend
condition|;
name|extdyn
operator|++
control|)
block|{
name|Elf_Internal_Dyn
name|dyn
decl_stmt|;
name|elf_swap_dyn_in
argument_list|(
name|abfd
argument_list|,
name|extdyn
argument_list|,
operator|&
name|dyn
argument_list|)
expr_stmt|;
if|if
condition|(
name|dyn
operator|.
name|d_tag
operator|==
name|DT_SONAME
condition|)
block|{
name|unsigned
name|int
name|tagv
init|=
name|dyn
operator|.
name|d_un
operator|.
name|d_val
decl_stmt|;
name|name
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|abfd
argument_list|,
name|shlink
argument_list|,
name|tagv
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
block|}
if|if
condition|(
name|dyn
operator|.
name|d_tag
operator|==
name|DT_NEEDED
condition|)
block|{
name|struct
name|bfd_link_needed_list
modifier|*
name|n
decl_stmt|,
modifier|*
modifier|*
name|pn
decl_stmt|;
name|char
modifier|*
name|fnm
decl_stmt|,
modifier|*
name|anm
decl_stmt|;
name|unsigned
name|int
name|tagv
init|=
name|dyn
operator|.
name|d_un
operator|.
name|d_val
decl_stmt|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|bfd_link_needed_list
argument_list|)
expr_stmt|;
name|n
operator|=
operator|(
expr|struct
name|bfd_link_needed_list
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
name|fnm
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|abfd
argument_list|,
name|shlink
argument_list|,
name|tagv
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
operator|||
name|fnm
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|anm
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|strlen
argument_list|(
name|fnm
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|anm
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|strcpy
argument_list|(
name|anm
argument_list|,
name|fnm
argument_list|)
expr_stmt|;
name|n
operator|->
name|name
operator|=
name|anm
expr_stmt|;
name|n
operator|->
name|by
operator|=
name|abfd
expr_stmt|;
name|n
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|pn
operator|=
operator|&
name|hash_table
operator|->
name|needed
init|;
operator|*
name|pn
operator|!=
name|NULL
condition|;
name|pn
operator|=
operator|&
operator|(
operator|*
name|pn
operator|)
operator|->
name|next
control|)
empty_stmt|;
operator|*
name|pn
operator|=
name|n
expr_stmt|;
block|}
if|if
condition|(
name|dyn
operator|.
name|d_tag
operator|==
name|DT_RUNPATH
condition|)
block|{
name|struct
name|bfd_link_needed_list
modifier|*
name|n
decl_stmt|,
modifier|*
modifier|*
name|pn
decl_stmt|;
name|char
modifier|*
name|fnm
decl_stmt|,
modifier|*
name|anm
decl_stmt|;
name|unsigned
name|int
name|tagv
init|=
name|dyn
operator|.
name|d_un
operator|.
name|d_val
decl_stmt|;
comment|/* When we see DT_RPATH before DT_RUNPATH, we have 		     to clear runpath.  Do _NOT_ bfd_release, as that 		     frees all more recently bfd_alloc'd blocks as 		     well.  */
if|if
condition|(
name|rpath
operator|&&
name|hash_table
operator|->
name|runpath
condition|)
name|hash_table
operator|->
name|runpath
operator|=
name|NULL
expr_stmt|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|bfd_link_needed_list
argument_list|)
expr_stmt|;
name|n
operator|=
operator|(
expr|struct
name|bfd_link_needed_list
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
name|fnm
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|abfd
argument_list|,
name|shlink
argument_list|,
name|tagv
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
operator|||
name|fnm
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|anm
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|strlen
argument_list|(
name|fnm
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|anm
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|strcpy
argument_list|(
name|anm
argument_list|,
name|fnm
argument_list|)
expr_stmt|;
name|n
operator|->
name|name
operator|=
name|anm
expr_stmt|;
name|n
operator|->
name|by
operator|=
name|abfd
expr_stmt|;
name|n
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|pn
operator|=
operator|&
name|hash_table
operator|->
name|runpath
init|;
operator|*
name|pn
operator|!=
name|NULL
condition|;
name|pn
operator|=
operator|&
operator|(
operator|*
name|pn
operator|)
operator|->
name|next
control|)
empty_stmt|;
operator|*
name|pn
operator|=
name|n
expr_stmt|;
name|runpath
operator|=
literal|1
expr_stmt|;
name|rpath
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Ignore DT_RPATH if we have seen DT_RUNPATH.  */
if|if
condition|(
operator|!
name|runpath
operator|&&
name|dyn
operator|.
name|d_tag
operator|==
name|DT_RPATH
condition|)
block|{
name|struct
name|bfd_link_needed_list
modifier|*
name|n
decl_stmt|,
modifier|*
modifier|*
name|pn
decl_stmt|;
name|char
modifier|*
name|fnm
decl_stmt|,
modifier|*
name|anm
decl_stmt|;
name|unsigned
name|int
name|tagv
init|=
name|dyn
operator|.
name|d_un
operator|.
name|d_val
decl_stmt|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|bfd_link_needed_list
argument_list|)
expr_stmt|;
name|n
operator|=
operator|(
expr|struct
name|bfd_link_needed_list
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
name|fnm
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|abfd
argument_list|,
name|shlink
argument_list|,
name|tagv
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
operator|||
name|fnm
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|anm
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|strlen
argument_list|(
name|fnm
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|anm
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|strcpy
argument_list|(
name|anm
argument_list|,
name|fnm
argument_list|)
expr_stmt|;
name|n
operator|->
name|name
operator|=
name|anm
expr_stmt|;
name|n
operator|->
name|by
operator|=
name|abfd
expr_stmt|;
name|n
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|pn
operator|=
operator|&
name|hash_table
operator|->
name|runpath
init|;
operator|*
name|pn
operator|!=
name|NULL
condition|;
name|pn
operator|=
operator|&
operator|(
operator|*
name|pn
operator|)
operator|->
name|next
control|)
empty_stmt|;
operator|*
name|pn
operator|=
name|n
expr_stmt|;
name|rpath
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|dynbuf
argument_list|)
expr_stmt|;
name|dynbuf
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* We do not want to include any of the sections in a dynamic 	 object in the output file.  We hack by simply clobbering the 	 list of sections in the BFD.  This could be handled more 	 cleanly by, say, a new section flag; the existing 	 SEC_NEVER_LOAD flag is not the one we want, because that one 	 still implies that the section takes up space in the output 	 file.  */
name|bfd_section_list_clear
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* If this is the first dynamic object found in the link, create 	 the special sections required for dynamic linking.  */
if|if
condition|(
operator|!
name|hash_table
operator|->
name|dynamic_sections_created
condition|)
if|if
condition|(
operator|!
name|elf_link_create_dynamic_sections
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|add_needed
condition|)
block|{
comment|/* Add a DT_NEEDED entry for this dynamic object.  */
name|oldsize
operator|=
name|_bfd_elf_strtab_size
argument_list|(
name|hash_table
operator|->
name|dynstr
argument_list|)
expr_stmt|;
name|strindex
operator|=
name|_bfd_elf_strtab_add
argument_list|(
name|hash_table
operator|->
name|dynstr
argument_list|,
name|name
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|strindex
operator|==
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|oldsize
operator|==
name|_bfd_elf_strtab_size
argument_list|(
name|hash_table
operator|->
name|dynstr
argument_list|)
condition|)
block|{
name|asection
modifier|*
name|sdyn
decl_stmt|;
name|Elf_External_Dyn
modifier|*
name|dyncon
decl_stmt|,
modifier|*
name|dynconend
decl_stmt|;
comment|/* The hash table size did not change, which means that 		 the dynamic object name was already entered.  If we 		 have already included this dynamic object in the 		 link, just ignore it.  There is no reason to include 		 a particular dynamic object more than once.  */
name|sdyn
operator|=
name|bfd_get_section_by_name
argument_list|(
name|hash_table
operator|->
name|dynobj
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sdyn
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dyncon
operator|=
operator|(
name|Elf_External_Dyn
operator|*
operator|)
name|sdyn
operator|->
name|contents
expr_stmt|;
name|dynconend
operator|=
operator|(
name|Elf_External_Dyn
operator|*
operator|)
operator|(
name|sdyn
operator|->
name|contents
operator|+
name|sdyn
operator|->
name|_raw_size
operator|)
expr_stmt|;
for|for
control|(
init|;
name|dyncon
operator|<
name|dynconend
condition|;
name|dyncon
operator|++
control|)
block|{
name|Elf_Internal_Dyn
name|dyn
decl_stmt|;
name|elf_swap_dyn_in
argument_list|(
name|hash_table
operator|->
name|dynobj
argument_list|,
name|dyncon
argument_list|,
operator|&
name|dyn
argument_list|)
expr_stmt|;
if|if
condition|(
name|dyn
operator|.
name|d_tag
operator|==
name|DT_NEEDED
operator|&&
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|==
name|strindex
condition|)
block|{
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|extversym
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|extversym
argument_list|)
expr_stmt|;
name|_bfd_elf_strtab_delref
argument_list|(
name|hash_table
operator|->
name|dynstr
argument_list|,
name|strindex
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
operator|(
name|bfd_vma
operator|)
name|DT_NEEDED
argument_list|,
name|strindex
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
comment|/* Save the SONAME, if there is one, because sometimes the 	 linker emulation code will need to know it.  */
if|if
condition|(
operator|*
name|name
operator|==
literal|'\0'
condition|)
name|name
operator|=
name|basename
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|elf_dt_name
argument_list|(
name|abfd
argument_list|)
operator|=
name|name
expr_stmt|;
block|}
name|pos
operator|=
name|hdr
operator|->
name|sh_offset
operator|+
name|extsymoff
operator|*
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
expr_stmt|;
name|amt
operator|=
name|extsymcount
operator|*
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|pos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bread
argument_list|(
operator|(
name|PTR
operator|)
name|buf
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|shndx_hdr
operator|!=
name|NULL
operator|&&
name|shndx_hdr
operator|->
name|sh_size
operator|!=
literal|0
condition|)
block|{
name|amt
operator|=
name|extsymcount
operator|*
sizeof|sizeof
argument_list|(
name|Elf_External_Sym_Shndx
argument_list|)
expr_stmt|;
name|pos
operator|=
name|shndx_hdr
operator|->
name|sh_offset
operator|+
name|extsymoff
operator|*
sizeof|sizeof
argument_list|(
name|Elf_External_Sym_Shndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|pos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bread
argument_list|(
operator|(
name|PTR
operator|)
name|shndx_buf
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
goto|goto
name|error_return
goto|;
block|}
name|weaks
operator|=
name|NULL
expr_stmt|;
name|ever
operator|=
name|extversym
operator|!=
name|NULL
condition|?
name|extversym
operator|+
name|extsymoff
else|:
name|NULL
expr_stmt|;
name|esymend
operator|=
name|buf
operator|+
name|extsymcount
expr_stmt|;
for|for
control|(
name|esym
operator|=
name|buf
operator|,
name|shndx
operator|=
name|shndx_buf
init|;
name|esym
operator|<
name|esymend
condition|;
name|esym
operator|++
operator|,
name|sym_hash
operator|++
operator|,
name|ever
operator|=
operator|(
name|ever
operator|!=
name|NULL
condition|?
name|ever
operator|+
literal|1
else|:
name|NULL
operator|)
operator|,
name|shndx
operator|=
operator|(
name|shndx
operator|!=
name|NULL
condition|?
name|shndx
operator|+
literal|1
else|:
name|NULL
operator|)
control|)
block|{
name|Elf_Internal_Sym
name|sym
decl_stmt|;
name|int
name|bind
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|boolean
name|definition
decl_stmt|;
name|boolean
name|size_change_ok
decl_stmt|,
name|type_change_ok
decl_stmt|;
name|boolean
name|new_weakdef
decl_stmt|;
name|unsigned
name|int
name|old_alignment
decl_stmt|;
name|boolean
name|override
decl_stmt|;
name|override
operator|=
name|false
expr_stmt|;
name|elf_swap_symbol_in
argument_list|(
name|abfd
argument_list|,
name|esym
argument_list|,
name|shndx
argument_list|,
operator|&
name|sym
argument_list|)
expr_stmt|;
name|flags
operator|=
name|BSF_NO_FLAGS
expr_stmt|;
name|sec
operator|=
name|NULL
expr_stmt|;
name|value
operator|=
name|sym
operator|.
name|st_value
expr_stmt|;
operator|*
name|sym_hash
operator|=
name|NULL
expr_stmt|;
name|bind
operator|=
name|ELF_ST_BIND
argument_list|(
name|sym
operator|.
name|st_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|bind
operator|==
name|STB_LOCAL
condition|)
block|{
comment|/* This should be impossible, since ELF requires that all 	     global symbols follow all local symbols, and that sh_info 	     point to the first global symbol.  Unfortunatealy, Irix 5 	     screws this up.  */
continue|continue;
block|}
elseif|else
if|if
condition|(
name|bind
operator|==
name|STB_GLOBAL
condition|)
block|{
if|if
condition|(
name|sym
operator|.
name|st_shndx
operator|!=
name|SHN_UNDEF
operator|&&
name|sym
operator|.
name|st_shndx
operator|!=
name|SHN_COMMON
condition|)
name|flags
operator|=
name|BSF_GLOBAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bind
operator|==
name|STB_WEAK
condition|)
name|flags
operator|=
name|BSF_WEAK
expr_stmt|;
else|else
block|{
comment|/* Leave it up to the processor backend.  */
block|}
if|if
condition|(
name|sym
operator|.
name|st_shndx
operator|==
name|SHN_UNDEF
condition|)
name|sec
operator|=
name|bfd_und_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|sym
operator|.
name|st_shndx
operator|<
name|SHN_LORESERVE
operator|||
name|sym
operator|.
name|st_shndx
operator|>
name|SHN_HIRESERVE
condition|)
block|{
name|sec
operator|=
name|section_from_elf_index
argument_list|(
name|abfd
argument_list|,
name|sym
operator|.
name|st_shndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
name|sec
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
operator|(
name|EXEC_P
operator||
name|DYNAMIC
operator|)
operator|)
operator|!=
literal|0
condition|)
name|value
operator|-=
name|sec
operator|->
name|vma
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sym
operator|.
name|st_shndx
operator|==
name|SHN_ABS
condition|)
name|sec
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|sym
operator|.
name|st_shndx
operator|==
name|SHN_COMMON
condition|)
block|{
name|sec
operator|=
name|bfd_com_section_ptr
expr_stmt|;
comment|/* What ELF calls the size we call the value.  What ELF 	     calls the value we call the alignment.  */
name|value
operator|=
name|sym
operator|.
name|st_size
expr_stmt|;
block|}
else|else
block|{
comment|/* Leave it up to the processor backend.  */
block|}
name|name
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|sh_link
argument_list|,
name|sym
operator|.
name|st_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|add_symbol_hook
condition|)
block|{
if|if
condition|(
operator|!
call|(
modifier|*
name|add_symbol_hook
call|)
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
operator|&
name|sym
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|flags
argument_list|,
operator|&
name|sec
argument_list|,
operator|&
name|value
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* The hook function sets the name to NULL if this symbol 	     should be skipped for some reason.  */
if|if
condition|(
name|name
operator|==
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
condition|)
continue|continue;
block|}
comment|/* Sanity check that all possibilities were handled.  */
if|if
condition|(
name|sec
operator|==
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|sec
argument_list|)
operator|||
name|bfd_is_com_section
argument_list|(
name|sec
argument_list|)
condition|)
name|definition
operator|=
name|false
expr_stmt|;
else|else
name|definition
operator|=
name|true
expr_stmt|;
name|size_change_ok
operator|=
name|false
expr_stmt|;
name|type_change_ok
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|type_change_ok
expr_stmt|;
name|old_alignment
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|hash
operator|->
name|creator
operator|->
name|flavour
operator|==
name|bfd_target_elf_flavour
condition|)
block|{
name|Elf_Internal_Versym
name|iver
decl_stmt|;
name|unsigned
name|int
name|vernum
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ever
operator|!=
name|NULL
condition|)
block|{
name|_bfd_elf_swap_versym_in
argument_list|(
name|abfd
argument_list|,
name|ever
argument_list|,
operator|&
name|iver
argument_list|)
expr_stmt|;
name|vernum
operator|=
name|iver
operator|.
name|vs_vers
operator|&
name|VERSYM_VERSION
expr_stmt|;
comment|/* If this is a hidden symbol, or if it is not version 		 1, we append the version name to the symbol name. 		 However, we do not modify a non-hidden absolute 		 symbol, because it might be the version symbol 		 itself.  FIXME: What if it isn't?  */
if|if
condition|(
operator|(
name|iver
operator|.
name|vs_vers
operator|&
name|VERSYM_HIDDEN
operator|)
operator|!=
literal|0
operator|||
operator|(
name|vernum
operator|>
literal|1
operator|&&
operator|!
name|bfd_is_abs_section
argument_list|(
name|sec
argument_list|)
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|verstr
decl_stmt|;
name|unsigned
name|int
name|namelen
decl_stmt|;
name|bfd_size_type
name|newlen
decl_stmt|;
name|char
modifier|*
name|newname
decl_stmt|,
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|sym
operator|.
name|st_shndx
operator|!=
name|SHN_UNDEF
condition|)
block|{
if|if
condition|(
name|vernum
operator|>
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|dynverdef_hdr
operator|.
name|sh_info
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: %s: invalid version %u (max %d)"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|name
argument_list|,
name|vernum
argument_list|,
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|dynverdef_hdr
operator|.
name|sh_info
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
elseif|else
if|if
condition|(
name|vernum
operator|>
literal|1
condition|)
name|verstr
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|verdef
index|[
name|vernum
operator|-
literal|1
index|]
operator|.
name|vd_nodename
expr_stmt|;
else|else
name|verstr
operator|=
literal|""
expr_stmt|;
block|}
else|else
block|{
comment|/* We cannot simply test for the number of 			 entries in the VERNEED section since the 			 numbers for the needed versions do not start 			 at 0.  */
name|Elf_Internal_Verneed
modifier|*
name|t
decl_stmt|;
name|verstr
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|t
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|verref
init|;
name|t
operator|!=
name|NULL
condition|;
name|t
operator|=
name|t
operator|->
name|vn_nextref
control|)
block|{
name|Elf_Internal_Vernaux
modifier|*
name|a
decl_stmt|;
for|for
control|(
name|a
operator|=
name|t
operator|->
name|vn_auxptr
init|;
name|a
operator|!=
name|NULL
condition|;
name|a
operator|=
name|a
operator|->
name|vna_nextptr
control|)
block|{
if|if
condition|(
name|a
operator|->
name|vna_other
operator|==
name|vernum
condition|)
block|{
name|verstr
operator|=
name|a
operator|->
name|vna_nodename
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|a
operator|!=
name|NULL
condition|)
break|break;
block|}
if|if
condition|(
name|verstr
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: %s: invalid needed version %d"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|name
argument_list|,
name|vernum
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
block|}
name|namelen
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|newlen
operator|=
name|namelen
operator|+
name|strlen
argument_list|(
name|verstr
argument_list|)
operator|+
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|iver
operator|.
name|vs_vers
operator|&
name|VERSYM_HIDDEN
operator|)
operator|==
literal|0
condition|)
operator|++
name|newlen
expr_stmt|;
name|newname
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|newlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|newname
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|strcpy
argument_list|(
name|newname
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|p
operator|=
name|newname
operator|+
name|namelen
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|ELF_VER_CHR
expr_stmt|;
comment|/* If this is a defined non-hidden version symbol, 		     we add another @ to the name.  This indicates the 		     default version of the symbol.  */
if|if
condition|(
operator|(
name|iver
operator|.
name|vs_vers
operator|&
name|VERSYM_HIDDEN
operator|)
operator|==
literal|0
operator|&&
name|sym
operator|.
name|st_shndx
operator|!=
name|SHN_UNDEF
condition|)
operator|*
name|p
operator|++
operator|=
name|ELF_VER_CHR
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|verstr
argument_list|)
expr_stmt|;
name|name
operator|=
name|newname
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|elf_merge_symbol
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|name
argument_list|,
operator|&
name|sym
argument_list|,
operator|&
name|sec
argument_list|,
operator|&
name|value
argument_list|,
name|sym_hash
argument_list|,
operator|&
name|override
argument_list|,
operator|&
name|type_change_ok
argument_list|,
operator|&
name|size_change_ok
argument_list|,
name|dt_needed
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|override
condition|)
name|definition
operator|=
name|false
expr_stmt|;
name|h
operator|=
operator|*
name|sym_hash
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
comment|/* Remember the old alignment if this is a common symbol, so 	     that we don't reduce the alignment later on.  We can't 	     check later, because _bfd_generic_link_add_one_symbol 	     will set a default for the alignment which we want to 	     override.  */
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_common
condition|)
name|old_alignment
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|alignment_power
expr_stmt|;
if|if
condition|(
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|verdef
operator|!=
name|NULL
operator|&&
operator|!
name|override
operator|&&
name|vernum
operator|>
literal|1
operator|&&
name|definition
condition|)
name|h
operator|->
name|verinfo
operator|.
name|verdef
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|verdef
index|[
name|vernum
operator|-
literal|1
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
name|name
argument_list|,
name|flags
argument_list|,
name|sec
argument_list|,
name|value
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|false
argument_list|,
name|collect
argument_list|,
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|*
operator|)
name|sym_hash
argument_list|)
operator|)
condition|)
goto|goto
name|error_return
goto|;
name|h
operator|=
operator|*
name|sym_hash
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
operator|*
name|sym_hash
operator|=
name|h
expr_stmt|;
name|new_weakdef
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|dynamic
operator|&&
name|definition
operator|&&
operator|(
name|flags
operator|&
name|BSF_WEAK
operator|)
operator|!=
literal|0
operator|&&
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|.
name|st_info
argument_list|)
operator|!=
name|STT_FUNC
operator|&&
name|info
operator|->
name|hash
operator|->
name|creator
operator|->
name|flavour
operator|==
name|bfd_target_elf_flavour
operator|&&
name|h
operator|->
name|weakdef
operator|==
name|NULL
condition|)
block|{
comment|/* Keep a list of all weak defined non function symbols from 	     a dynamic object, using the weakdef field.  Later in this 	     function we will set the weakdef field to the correct 	     value.  We only put non-function symbols from dynamic 	     objects on this list, because that happens to be the only 	     time we need to know the normal symbol corresponding to a 	     weak symbol, and the information is time consuming to 	     figure out.  If the weakdef field is not already NULL, 	     then this symbol was already defined by some previous 	     dynamic object, and we will be using that previous 	     definition anyhow.  */
name|h
operator|->
name|weakdef
operator|=
name|weaks
expr_stmt|;
name|weaks
operator|=
name|h
expr_stmt|;
name|new_weakdef
operator|=
name|true
expr_stmt|;
block|}
comment|/* Set the alignment of a common symbol.  */
if|if
condition|(
name|sym
operator|.
name|st_shndx
operator|==
name|SHN_COMMON
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_common
condition|)
block|{
name|unsigned
name|int
name|align
decl_stmt|;
name|align
operator|=
name|bfd_log2
argument_list|(
name|sym
operator|.
name|st_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|align
operator|>
name|old_alignment
comment|/* Permit an alignment power of zero if an alignment of one 		 is specified and no other alignments have been specified.  */
operator|||
operator|(
name|sym
operator|.
name|st_value
operator|==
literal|1
operator|&&
name|old_alignment
operator|==
literal|0
operator|)
condition|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|alignment_power
operator|=
name|align
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|hash
operator|->
name|creator
operator|->
name|flavour
operator|==
name|bfd_target_elf_flavour
condition|)
block|{
name|int
name|old_flags
decl_stmt|;
name|boolean
name|dynsym
decl_stmt|;
name|int
name|new_flag
decl_stmt|;
comment|/* Remember the symbol size and type.  */
if|if
condition|(
name|sym
operator|.
name|st_size
operator|!=
literal|0
operator|&&
operator|(
name|definition
operator|||
name|h
operator|->
name|size
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|size
operator|!=
literal|0
operator|&&
name|h
operator|->
name|size
operator|!=
name|sym
operator|.
name|st_size
operator|&&
operator|!
name|size_change_ok
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Warning: size of symbol `%s' changed from %lu to %lu in %s"
argument_list|)
argument_list|,
name|name
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|h
operator|->
name|size
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|sym
operator|.
name|st_size
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|->
name|size
operator|=
name|sym
operator|.
name|st_size
expr_stmt|;
block|}
comment|/* If this is a common symbol, then we always want H->SIZE 	     to be the size of the common symbol.  The code just above 	     won't fix the size if a common symbol becomes larger.  We 	     don't warn about a size change here, because that is 	     covered by --warn-common.  */
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_common
condition|)
name|h
operator|->
name|size
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|size
expr_stmt|;
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|.
name|st_info
argument_list|)
operator|!=
name|STT_NOTYPE
operator|&&
operator|(
name|definition
operator|||
name|h
operator|->
name|type
operator|==
name|STT_NOTYPE
operator|)
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|type
operator|!=
name|STT_NOTYPE
operator|&&
name|h
operator|->
name|type
operator|!=
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|.
name|st_info
argument_list|)
operator|&&
operator|!
name|type_change_ok
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Warning: type of symbol `%s' changed from %d to %d in %s"
argument_list|)
argument_list|,
name|name
argument_list|,
name|h
operator|->
name|type
argument_list|,
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|.
name|st_info
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|.
name|st_info
argument_list|)
expr_stmt|;
block|}
comment|/* If st_other has a processor-specific meaning, specific code 	     might be needed here.  */
if|if
condition|(
name|sym
operator|.
name|st_other
operator|!=
literal|0
condition|)
block|{
comment|/* Combine visibilities, using the most constraining one.  */
name|unsigned
name|char
name|hvis
init|=
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
decl_stmt|;
name|unsigned
name|char
name|symvis
init|=
name|ELF_ST_VISIBILITY
argument_list|(
name|sym
operator|.
name|st_other
argument_list|)
decl_stmt|;
if|if
condition|(
name|symvis
operator|&&
operator|(
name|hvis
operator|>
name|symvis
operator|||
name|hvis
operator|==
literal|0
operator|)
condition|)
name|h
operator|->
name|other
operator|=
name|sym
operator|.
name|st_other
expr_stmt|;
comment|/* If neither has visibility, use the st_other of the 		 definition.  This is an arbitrary choice, since the 		 other bits have no general meaning.  */
if|if
condition|(
operator|!
name|symvis
operator|&&
operator|!
name|hvis
operator|&&
operator|(
name|definition
operator|||
name|h
operator|->
name|other
operator|==
literal|0
operator|)
condition|)
name|h
operator|->
name|other
operator|=
name|sym
operator|.
name|st_other
expr_stmt|;
block|}
comment|/* Set a flag in the hash table entry indicating the type of 	     reference or definition we just found.  Keep a count of 	     the number of dynamic symbols we find.  A dynamic symbol 	     is one which is referenced or defined by both a regular 	     object and a shared object.  */
name|old_flags
operator|=
name|h
operator|->
name|elf_link_hash_flags
expr_stmt|;
name|dynsym
operator|=
name|false
expr_stmt|;
if|if
condition|(
operator|!
name|dynamic
condition|)
block|{
if|if
condition|(
operator|!
name|definition
condition|)
block|{
name|new_flag
operator|=
name|ELF_LINK_HASH_REF_REGULAR
expr_stmt|;
if|if
condition|(
name|bind
operator|!=
name|STB_WEAK
condition|)
name|new_flag
operator||=
name|ELF_LINK_HASH_REF_REGULAR_NONWEAK
expr_stmt|;
block|}
else|else
name|new_flag
operator|=
name|ELF_LINK_HASH_DEF_REGULAR
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
operator|||
operator|(
name|old_flags
operator|&
operator|(
name|ELF_LINK_HASH_DEF_DYNAMIC
operator||
name|ELF_LINK_HASH_REF_DYNAMIC
operator|)
operator|)
operator|!=
literal|0
condition|)
name|dynsym
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|definition
condition|)
name|new_flag
operator|=
name|ELF_LINK_HASH_REF_DYNAMIC
expr_stmt|;
else|else
name|new_flag
operator|=
name|ELF_LINK_HASH_DEF_DYNAMIC
expr_stmt|;
if|if
condition|(
operator|(
name|old_flags
operator|&
operator|(
name|ELF_LINK_HASH_DEF_REGULAR
operator||
name|ELF_LINK_HASH_REF_REGULAR
operator|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|h
operator|->
name|weakdef
operator|!=
name|NULL
operator|&&
operator|!
name|new_weakdef
operator|&&
name|h
operator|->
name|weakdef
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|)
condition|)
name|dynsym
operator|=
name|true
expr_stmt|;
block|}
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|new_flag
expr_stmt|;
comment|/* Check to see if we need to add an indirect symbol for 	     the default name.  */
if|if
condition|(
name|definition
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_common
condition|)
if|if
condition|(
operator|!
name|elf_add_default_symbol
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|h
argument_list|,
name|name
argument_list|,
operator|&
name|sym
argument_list|,
operator|&
name|sec
argument_list|,
operator|&
name|value
argument_list|,
operator|&
name|dynsym
argument_list|,
name|override
argument_list|,
name|dt_needed
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|dynsym
operator|&&
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|_bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|h
operator|->
name|weakdef
operator|!=
name|NULL
operator|&&
operator|!
name|new_weakdef
operator|&&
name|h
operator|->
name|weakdef
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|_bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|weakdef
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|dynsym
operator|&&
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
condition|)
comment|/* If the symbol already has a dynamic index, but 	       visibility says it should not be visible, turn it into 	       a local symbol.  */
switch|switch
condition|(
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
condition|)
block|{
case|case
name|STV_INTERNAL
case|:
case|case
name|STV_HIDDEN
case|:
call|(
modifier|*
name|bed
operator|->
name|elf_backend_hide_symbol
call|)
argument_list|(
name|info
argument_list|,
name|h
argument_list|,
name|true
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dt_needed
operator|&&
name|definition
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_REF_REGULAR
operator|)
operator|!=
literal|0
condition|)
block|{
name|bfd_size_type
name|oldsize
decl_stmt|;
name|bfd_size_type
name|strindex
decl_stmt|;
if|if
condition|(
operator|!
name|is_elf_hash_table
argument_list|(
name|info
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* The symbol from a DT_NEEDED object is referenced from 		 the regular object to create a dynamic executable. We 		 have to make sure there is a DT_NEEDED entry for it.  */
name|dt_needed
operator|=
name|false
expr_stmt|;
name|oldsize
operator|=
name|_bfd_elf_strtab_size
argument_list|(
name|hash_table
operator|->
name|dynstr
argument_list|)
expr_stmt|;
name|strindex
operator|=
name|_bfd_elf_strtab_add
argument_list|(
name|hash_table
operator|->
name|dynstr
argument_list|,
name|elf_dt_soname
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|strindex
operator|==
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|oldsize
operator|==
name|_bfd_elf_strtab_size
argument_list|(
name|hash_table
operator|->
name|dynstr
argument_list|)
condition|)
block|{
name|asection
modifier|*
name|sdyn
decl_stmt|;
name|Elf_External_Dyn
modifier|*
name|dyncon
decl_stmt|,
modifier|*
name|dynconend
decl_stmt|;
name|sdyn
operator|=
name|bfd_get_section_by_name
argument_list|(
name|hash_table
operator|->
name|dynobj
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sdyn
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dyncon
operator|=
operator|(
name|Elf_External_Dyn
operator|*
operator|)
name|sdyn
operator|->
name|contents
expr_stmt|;
name|dynconend
operator|=
operator|(
name|Elf_External_Dyn
operator|*
operator|)
operator|(
name|sdyn
operator|->
name|contents
operator|+
name|sdyn
operator|->
name|_raw_size
operator|)
expr_stmt|;
for|for
control|(
init|;
name|dyncon
operator|<
name|dynconend
condition|;
name|dyncon
operator|++
control|)
block|{
name|Elf_Internal_Dyn
name|dyn
decl_stmt|;
name|elf_swap_dyn_in
argument_list|(
name|hash_table
operator|->
name|dynobj
argument_list|,
name|dyncon
argument_list|,
operator|&
name|dyn
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|dyn
operator|.
name|d_tag
operator|!=
name|DT_NEEDED
operator|||
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|!=
name|strindex
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
operator|(
name|bfd_vma
operator|)
name|DT_NEEDED
argument_list|,
name|strindex
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
block|}
block|}
comment|/* Now set the weakdefs field correctly for all the weak defined      symbols we found.  The only way to do this is to search all the      symbols.  Since we only need the information for non functions in      dynamic objects, that's the only time we actually put anything on      the list WEAKS.  We need this information so that if a regular      object refers to a symbol defined weakly in a dynamic object, the      real symbol in the dynamic object is also put in the dynamic      symbols; we also must arrange for both symbols to point to the      same memory location.  We could handle the general case of symbol      aliasing, but a general symbol alias can only be generated in      assembler code, handling it correctly would be very time      consuming, and other ELF linkers don't handle general aliasing      either.  */
while|while
condition|(
name|weaks
operator|!=
name|NULL
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|hlook
decl_stmt|;
name|asection
modifier|*
name|slook
decl_stmt|;
name|bfd_vma
name|vlook
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|hpp
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|hppend
decl_stmt|;
name|hlook
operator|=
name|weaks
expr_stmt|;
name|weaks
operator|=
name|hlook
operator|->
name|weakdef
expr_stmt|;
name|hlook
operator|->
name|weakdef
operator|=
name|NULL
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|hlook
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|hlook
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|||
name|hlook
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_common
operator|||
name|hlook
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
argument_list|)
expr_stmt|;
name|slook
operator|=
name|hlook
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|vlook
operator|=
name|hlook
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
name|hpp
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|hppend
operator|=
name|hpp
operator|+
name|extsymcount
expr_stmt|;
for|for
control|(
init|;
name|hpp
operator|<
name|hppend
condition|;
name|hpp
operator|++
control|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
operator|*
name|hpp
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|!=
name|hlook
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|&&
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|==
name|slook
operator|&&
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|==
name|vlook
condition|)
block|{
name|hlook
operator|->
name|weakdef
operator|=
name|h
expr_stmt|;
comment|/* If the weak definition is in the list of dynamic 		 symbols, make sure the real definition is put there 		 as well.  */
if|if
condition|(
name|hlook
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|&&
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|_bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
comment|/* If the real definition is in the list of dynamic 		 symbols, make sure the weak definition is put there 		 as well.  If we don't do this, then the dynamic 		 loader might not merge the entries for the real 		 definition and the weak definition.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|&&
name|hlook
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|_bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|hlook
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
break|break;
block|}
block|}
block|}
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|extversym
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|extversym
argument_list|)
expr_stmt|;
name|extversym
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* If this object is the same format as the output object, and it is      not a shared library, then let the backend look through the      relocs.       This is required to build global offset table entries and to      arrange for dynamic relocs.  It is not required for the      particular common case of linking non PIC code, even when linking      against shared libraries, but unfortunately there is no way of      knowing whether an object file has been compiled PIC or not.      Looking through the relocs is not particularly time consuming.      The problem is that we must either (1) keep the relocs in memory,      which causes the linker to require additional runtime memory or      (2) read the relocs twice from the input file, which wastes time.      This would be a good case for using mmap.       I have no idea how to handle linking PIC code into a file of a      different format.  It probably can't be done.  */
name|check_relocs
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|check_relocs
expr_stmt|;
if|if
condition|(
operator|!
name|dynamic
operator|&&
name|abfd
operator|->
name|xvec
operator|==
name|info
operator|->
name|hash
operator|->
name|creator
operator|&&
name|check_relocs
operator|!=
name|NULL
condition|)
block|{
name|asection
modifier|*
name|o
decl_stmt|;
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|;
name|boolean
name|ok
decl_stmt|;
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
operator|||
name|o
operator|->
name|reloc_count
operator|==
literal|0
operator|||
operator|(
operator|(
name|info
operator|->
name|strip
operator|==
name|strip_all
operator|||
name|info
operator|->
name|strip
operator|==
name|strip_debugger
operator|)
operator|&&
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_DEBUGGING
operator|)
operator|!=
literal|0
operator|)
operator|||
name|bfd_is_abs_section
argument_list|(
name|o
operator|->
name|output_section
argument_list|)
condition|)
continue|continue;
name|internal_relocs
operator|=
operator|(
name|NAME
argument_list|(
name|_bfd_elf
argument_list|,
name|link_read_relocs
argument_list|)
argument_list|(
name|abfd
argument_list|,
name|o
argument_list|,
operator|(
name|PTR
operator|)
name|NULL
argument_list|,
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
name|NULL
argument_list|,
name|info
operator|->
name|keep_memory
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|ok
operator|=
call|(
modifier|*
name|check_relocs
call|)
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|o
argument_list|,
name|internal_relocs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
goto|goto
name|error_return
goto|;
block|}
block|}
comment|/* If this is a non-traditional, non-relocateable link, try to      optimize the handling of the .stab/.stabstr sections.  */
if|if
condition|(
operator|!
name|dynamic
operator|&&
operator|!
name|info
operator|->
name|relocateable
operator|&&
operator|!
name|info
operator|->
name|traditional_format
operator|&&
name|info
operator|->
name|hash
operator|->
name|creator
operator|->
name|flavour
operator|==
name|bfd_target_elf_flavour
operator|&&
name|is_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|&&
operator|(
name|info
operator|->
name|strip
operator|!=
name|strip_all
operator|&&
name|info
operator|->
name|strip
operator|!=
name|strip_debugger
operator|)
condition|)
block|{
name|asection
modifier|*
name|stab
decl_stmt|,
modifier|*
name|stabstr
decl_stmt|;
name|stab
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".stab"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stab
operator|!=
name|NULL
operator|&&
operator|!
operator|(
name|stab
operator|->
name|flags
operator|&
name|SEC_MERGE
operator|)
condition|)
block|{
name|stabstr
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".stabstr"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stabstr
operator|!=
name|NULL
condition|)
block|{
name|struct
name|bfd_elf_section_data
modifier|*
name|secdata
decl_stmt|;
name|secdata
operator|=
name|elf_section_data
argument_list|(
name|stab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|_bfd_link_section_stabs
argument_list|(
name|abfd
argument_list|,
operator|&
name|hash_table
operator|->
name|stab_info
argument_list|,
name|stab
argument_list|,
name|stabstr
argument_list|,
operator|&
name|secdata
operator|->
name|sec_info
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|secdata
operator|->
name|sec_info
condition|)
name|secdata
operator|->
name|sec_info_type
operator|=
name|ELF_INFO_TYPE_STABS
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|info
operator|->
name|relocateable
operator|&&
operator|!
name|dynamic
operator|&&
name|is_elf_hash_table
argument_list|(
name|info
argument_list|)
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
if|if
condition|(
name|s
operator|->
name|flags
operator|&
name|SEC_MERGE
condition|)
block|{
name|struct
name|bfd_elf_section_data
modifier|*
name|secdata
decl_stmt|;
name|secdata
operator|=
name|elf_section_data
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|_bfd_merge_section
argument_list|(
name|abfd
argument_list|,
operator|&
name|hash_table
operator|->
name|merge_info
argument_list|,
name|s
argument_list|,
operator|&
name|secdata
operator|->
name|sec_info
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
elseif|else
if|if
condition|(
name|secdata
operator|->
name|sec_info
condition|)
name|secdata
operator|->
name|sec_info_type
operator|=
name|ELF_INFO_TYPE_MERGE
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
name|error_return
label|:
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynbuf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|dynbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|extversym
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|extversym
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Create some sections which will be filled in with dynamic linking    information.  ABFD is an input file which requires dynamic sections    to be created.  The dynamic sections take up virtual memory space    when the final executable is run, so we need to create them before    addresses are assigned to the output sections.  We work out the    actual contents and size of these sections later.  */
end_comment

begin_function
name|boolean
name|elf_link_create_dynamic_sections
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|flagword
name|flags
decl_stmt|;
specifier|register
name|asection
modifier|*
name|s
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
if|if
condition|(
operator|!
name|is_elf_hash_table
argument_list|(
name|info
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
return|return
name|true
return|;
comment|/* Make sure that all dynamic sections use the same input BFD.  */
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
operator|==
name|NULL
condition|)
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
operator|=
name|abfd
expr_stmt|;
else|else
name|abfd
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
comment|/* Note that we set the SEC_IN_MEMORY flag for all of these      sections.  */
name|flags
operator|=
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator|)
expr_stmt|;
comment|/* A dynamically linked executable has a .interp section, but a      shared library does not.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".interp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|flags
operator||
name|SEC_READONLY
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|info
operator|->
name|traditional_format
operator|&&
name|info
operator|->
name|hash
operator|->
name|creator
operator|->
name|flavour
operator|==
name|bfd_target_elf_flavour
condition|)
block|{
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".eh_frame_hdr"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|flags
operator||
name|SEC_READONLY
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|false
return|;
block|}
comment|/* Create sections to hold version informations.  These are removed      if they are not needed.  */
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".gnu.version_d"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|flags
operator||
name|SEC_READONLY
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|LOG_FILE_ALIGN
argument_list|)
condition|)
return|return
name|false
return|;
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".gnu.version"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|flags
operator||
name|SEC_READONLY
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|false
return|;
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".gnu.version_r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|flags
operator||
name|SEC_READONLY
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|LOG_FILE_ALIGN
argument_list|)
condition|)
return|return
name|false
return|;
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".dynsym"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|flags
operator||
name|SEC_READONLY
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|LOG_FILE_ALIGN
argument_list|)
condition|)
return|return
name|false
return|;
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".dynstr"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|flags
operator||
name|SEC_READONLY
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Create a strtab to hold the dynamic symbol names.  */
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
operator|==
name|NULL
condition|)
block|{
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
operator|=
name|_bfd_elf_strtab_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
operator|==
name|NULL
condition|)
return|return
name|false
return|;
block|}
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|flags
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|LOG_FILE_ALIGN
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* The special symbol _DYNAMIC is always set to the start of the      .dynamic section.  This call occurs before we have processed the      symbols for any dynamic object, so we don't have to worry about      overriding a dynamic definition.  We could set _DYNAMIC in a      linker script, but we only want to define it if we are, in fact,      creating a .dynamic section.  We don't want to define it if there      is no .dynamic section, since on some ELF platforms the start up      code examines it to decide how to initialize the process.  */
name|h
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
literal|"_DYNAMIC"
argument_list|,
name|BSF_GLOBAL
argument_list|,
name|s
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|false
argument_list|,
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|collect
argument_list|,
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|*
operator|)
operator|&
name|h
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_DEF_REGULAR
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|STT_OBJECT
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
operator|!
name|_bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|false
return|;
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".hash"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|flags
operator||
name|SEC_READONLY
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|LOG_FILE_ALIGN
argument_list|)
condition|)
return|return
name|false
return|;
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
operator|=
name|bed
operator|->
name|s
operator|->
name|sizeof_hash_entry
expr_stmt|;
comment|/* Let the backend create the rest of the sections.  This lets the      backend set the right flags.  The backend will normally create      the .got and .plt sections.  */
if|if
condition|(
operator|!
call|(
modifier|*
name|bed
operator|->
name|elf_backend_create_dynamic_sections
call|)
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|false
return|;
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Add an entry to the .dynamic table.  */
end_comment

begin_function
name|boolean
name|elf_add_dynamic_entry
parameter_list|(
name|info
parameter_list|,
name|tag
parameter_list|,
name|val
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd_vma
name|tag
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
block|{
name|Elf_Internal_Dyn
name|dyn
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_size_type
name|newsize
decl_stmt|;
name|bfd_byte
modifier|*
name|newcontents
decl_stmt|;
if|if
condition|(
operator|!
name|is_elf_hash_table
argument_list|(
name|info
argument_list|)
condition|)
return|return
name|false
return|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|newsize
operator|=
name|s
operator|->
name|_raw_size
operator|+
sizeof|sizeof
argument_list|(
name|Elf_External_Dyn
argument_list|)
expr_stmt|;
name|newcontents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_realloc
argument_list|(
name|s
operator|->
name|contents
argument_list|,
name|newsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|newcontents
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|dyn
operator|.
name|d_tag
operator|=
name|tag
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|val
expr_stmt|;
name|elf_swap_dyn_out
argument_list|(
name|dynobj
argument_list|,
operator|&
name|dyn
argument_list|,
operator|(
name|Elf_External_Dyn
operator|*
operator|)
operator|(
name|newcontents
operator|+
name|s
operator|->
name|_raw_size
operator|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|=
name|newsize
expr_stmt|;
name|s
operator|->
name|contents
operator|=
name|newcontents
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Record a new local dynamic symbol.  */
end_comment

begin_function
name|boolean
name|elf_link_record_local_dynamic_symbol
parameter_list|(
name|info
parameter_list|,
name|input_bfd
parameter_list|,
name|input_indx
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|long
name|input_indx
decl_stmt|;
block|{
name|struct
name|elf_link_local_dynamic_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|elf_link_hash_table
modifier|*
name|eht
decl_stmt|;
name|struct
name|elf_strtab_hash
modifier|*
name|dynstr
decl_stmt|;
name|Elf_External_Sym
name|esym
decl_stmt|;
name|Elf_External_Sym_Shndx
name|eshndx
decl_stmt|;
name|Elf_External_Sym_Shndx
modifier|*
name|shndx
decl_stmt|;
name|unsigned
name|long
name|dynstr_index
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|file_ptr
name|pos
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
if|if
condition|(
operator|!
name|is_elf_hash_table
argument_list|(
name|info
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* See if the entry exists already.  */
for|for
control|(
name|entry
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynlocal
init|;
name|entry
condition|;
name|entry
operator|=
name|entry
operator|->
name|next
control|)
if|if
condition|(
name|entry
operator|->
name|input_bfd
operator|==
name|input_bfd
operator|&&
name|entry
operator|->
name|input_indx
operator|==
name|input_indx
condition|)
return|return
name|true
return|;
name|entry
operator|=
operator|(
expr|struct
name|elf_link_local_dynamic_entry
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|bfd_size_type
operator|)
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
return|return
name|false
return|;
comment|/* Go find the symbol, so that we can find it's name.  */
name|amt
operator|=
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
expr_stmt|;
name|pos
operator|=
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
operator|.
name|sh_offset
operator|+
name|input_indx
operator|*
name|amt
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|input_bfd
argument_list|,
name|pos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bread
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|esym
argument_list|,
name|amt
argument_list|,
name|input_bfd
argument_list|)
operator|!=
name|amt
condition|)
return|return
name|false
return|;
name|shndx
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_shndx_hdr
operator|.
name|sh_size
operator|!=
literal|0
condition|)
block|{
name|amt
operator|=
sizeof|sizeof
argument_list|(
name|Elf_External_Sym_Shndx
argument_list|)
expr_stmt|;
name|pos
operator|=
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_shndx_hdr
operator|.
name|sh_offset
expr_stmt|;
name|pos
operator|+=
name|input_indx
operator|*
name|amt
expr_stmt|;
name|shndx
operator|=
operator|&
name|eshndx
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|input_bfd
argument_list|,
name|pos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bread
argument_list|(
operator|(
name|PTR
operator|)
name|shndx
argument_list|,
name|amt
argument_list|,
name|input_bfd
argument_list|)
operator|!=
name|amt
condition|)
return|return
name|false
return|;
block|}
name|elf_swap_symbol_in
argument_list|(
name|input_bfd
argument_list|,
operator|&
name|esym
argument_list|,
name|shndx
argument_list|,
operator|&
name|entry
operator|->
name|isym
argument_list|)
expr_stmt|;
name|name
operator|=
operator|(
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
operator|.
name|sh_link
argument_list|,
name|entry
operator|->
name|isym
operator|.
name|st_name
argument_list|)
operator|)
expr_stmt|;
name|dynstr
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
expr_stmt|;
if|if
condition|(
name|dynstr
operator|==
name|NULL
condition|)
block|{
comment|/* Create a strtab to hold the dynamic symbol names.  */
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
operator|=
name|dynstr
operator|=
name|_bfd_elf_strtab_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|dynstr
operator|==
name|NULL
condition|)
return|return
name|false
return|;
block|}
name|dynstr_index
operator|=
name|_bfd_elf_strtab_add
argument_list|(
name|dynstr
argument_list|,
name|name
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynstr_index
operator|==
operator|(
name|unsigned
name|long
operator|)
operator|-
literal|1
condition|)
return|return
name|false
return|;
name|entry
operator|->
name|isym
operator|.
name|st_name
operator|=
name|dynstr_index
expr_stmt|;
name|eht
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|entry
operator|->
name|next
operator|=
name|eht
operator|->
name|dynlocal
expr_stmt|;
name|eht
operator|->
name|dynlocal
operator|=
name|entry
expr_stmt|;
name|entry
operator|->
name|input_bfd
operator|=
name|input_bfd
expr_stmt|;
name|entry
operator|->
name|input_indx
operator|=
name|input_indx
expr_stmt|;
name|eht
operator|->
name|dynsymcount
operator|++
expr_stmt|;
comment|/* Whatever binding the symbol had before, it's now local.  */
name|entry
operator|->
name|isym
operator|.
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_LOCAL
argument_list|,
name|ELF_ST_TYPE
argument_list|(
name|entry
operator|->
name|isym
operator|.
name|st_info
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The dynindx will be set at the end of size_dynamic_sections.  */
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read and swap the relocs from the section indicated by SHDR.  This    may be either a REL or a RELA section.  The relocations are    translated into RELA relocations and stored in INTERNAL_RELOCS,    which should have already been allocated to contain enough space.    The EXTERNAL_RELOCS are a buffer where the external form of the    relocations should be stored.     Returns false if something goes wrong.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf_link_read_relocs_from_section
parameter_list|(
name|abfd
parameter_list|,
name|shdr
parameter_list|,
name|external_relocs
parameter_list|,
name|internal_relocs
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|shdr
decl_stmt|;
name|PTR
name|external_relocs
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|;
block|{
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
comment|/* If there aren't any relocations, that's OK.  */
if|if
condition|(
operator|!
name|shdr
condition|)
return|return
name|true
return|;
comment|/* Position ourselves at the start of the section.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|shdr
operator|->
name|sh_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
comment|/* Read the relocations.  */
if|if
condition|(
name|bfd_bread
argument_list|(
name|external_relocs
argument_list|,
name|shdr
operator|->
name|sh_size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|shdr
operator|->
name|sh_size
condition|)
return|return
name|false
return|;
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* Convert the external relocations to the internal format.  */
if|if
condition|(
name|shdr
operator|->
name|sh_entsize
operator|==
sizeof|sizeof
argument_list|(
name|Elf_External_Rel
argument_list|)
condition|)
block|{
name|Elf_External_Rel
modifier|*
name|erel
decl_stmt|;
name|Elf_External_Rel
modifier|*
name|erelend
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irela
decl_stmt|;
name|Elf_Internal_Rel
modifier|*
name|irel
decl_stmt|;
name|erel
operator|=
operator|(
name|Elf_External_Rel
operator|*
operator|)
name|external_relocs
expr_stmt|;
name|erelend
operator|=
name|erel
operator|+
name|NUM_SHDR_ENTRIES
argument_list|(
name|shdr
argument_list|)
expr_stmt|;
name|irela
operator|=
name|internal_relocs
expr_stmt|;
name|amt
operator|=
name|bed
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Internal_Rel
argument_list|)
expr_stmt|;
name|irel
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|erel
operator|<
name|erelend
condition|;
name|erel
operator|++
operator|,
name|irela
operator|+=
name|bed
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
control|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|bed
operator|->
name|s
operator|->
name|swap_reloc_in
condition|)
call|(
modifier|*
name|bed
operator|->
name|s
operator|->
name|swap_reloc_in
call|)
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|erel
argument_list|,
name|irel
argument_list|)
expr_stmt|;
else|else
name|elf_swap_reloc_in
argument_list|(
name|abfd
argument_list|,
name|erel
argument_list|,
name|irel
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bed
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
condition|;
operator|++
name|i
control|)
block|{
name|irela
index|[
name|i
index|]
operator|.
name|r_offset
operator|=
name|irel
index|[
name|i
index|]
operator|.
name|r_offset
expr_stmt|;
name|irela
index|[
name|i
index|]
operator|.
name|r_info
operator|=
name|irel
index|[
name|i
index|]
operator|.
name|r_info
expr_stmt|;
name|irela
index|[
name|i
index|]
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|Elf_External_Rela
modifier|*
name|erela
decl_stmt|;
name|Elf_External_Rela
modifier|*
name|erelaend
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irela
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|shdr
operator|->
name|sh_entsize
operator|==
sizeof|sizeof
argument_list|(
name|Elf_External_Rela
argument_list|)
argument_list|)
expr_stmt|;
name|erela
operator|=
operator|(
name|Elf_External_Rela
operator|*
operator|)
name|external_relocs
expr_stmt|;
name|erelaend
operator|=
name|erela
operator|+
name|NUM_SHDR_ENTRIES
argument_list|(
name|shdr
argument_list|)
expr_stmt|;
name|irela
operator|=
name|internal_relocs
expr_stmt|;
for|for
control|(
init|;
name|erela
operator|<
name|erelaend
condition|;
name|erela
operator|++
operator|,
name|irela
operator|+=
name|bed
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
control|)
block|{
if|if
condition|(
name|bed
operator|->
name|s
operator|->
name|swap_reloca_in
condition|)
call|(
modifier|*
name|bed
operator|->
name|s
operator|->
name|swap_reloca_in
call|)
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|erela
argument_list|,
name|irela
argument_list|)
expr_stmt|;
else|else
name|elf_swap_reloca_in
argument_list|(
name|abfd
argument_list|,
name|erela
argument_list|,
name|irela
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Read and swap the relocs for a section O.  They may have been    cached.  If the EXTERNAL_RELOCS and INTERNAL_RELOCS arguments are    not NULL, they are used as buffers to read into.  They are known to    be large enough.  If the INTERNAL_RELOCS relocs argument is NULL,    the return value is allocated using either malloc or bfd_alloc,    according to the KEEP_MEMORY argument.  If O has two relocation    sections (both REL and RELA relocations), then the REL_HDR    relocations will appear first in INTERNAL_RELOCS, followed by the    REL_HDR2 relocations.  */
end_comment

begin_decl_stmt
name|Elf_Internal_Rela
modifier|*
name|NAME
argument_list|(
name|_bfd_elf
argument_list|,
name|link_read_relocs
argument_list|)
argument_list|(
name|abfd
argument_list|,
name|o
argument_list|,
name|external_relocs
argument_list|,
name|internal_relocs
argument_list|,
name|keep_memory
argument_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|asection
modifier|*
name|o
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PTR
name|external_relocs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|keep_memory
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Elf_Internal_Shdr
modifier|*
name|rel_hdr
decl_stmt|;
name|PTR
name|alloc1
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|alloc2
init|=
name|NULL
decl_stmt|;
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
if|if
condition|(
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|relocs
operator|!=
name|NULL
condition|)
return|return
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|relocs
return|;
if|if
condition|(
name|o
operator|->
name|reloc_count
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
name|rel_hdr
operator|=
operator|&
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_hdr
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
block|{
name|bfd_size_type
name|size
decl_stmt|;
name|size
operator|=
name|o
operator|->
name|reloc_count
expr_stmt|;
name|size
operator|*=
name|bed
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Internal_Rela
argument_list|)
expr_stmt|;
if|if
condition|(
name|keep_memory
condition|)
name|internal_relocs
operator|=
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
name|internal_relocs
operator|=
name|alloc2
operator|=
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
block|}
if|if
condition|(
name|external_relocs
operator|==
name|NULL
condition|)
block|{
name|bfd_size_type
name|size
init|=
name|rel_hdr
operator|->
name|sh_size
decl_stmt|;
if|if
condition|(
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_hdr2
condition|)
name|size
operator|+=
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_hdr2
operator|->
name|sh_size
expr_stmt|;
name|alloc1
operator|=
operator|(
name|PTR
operator|)
name|bfd_malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|alloc1
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|external_relocs
operator|=
name|alloc1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|elf_link_read_relocs_from_section
argument_list|(
name|abfd
argument_list|,
name|rel_hdr
argument_list|,
name|external_relocs
argument_list|,
name|internal_relocs
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|elf_link_read_relocs_from_section
argument_list|(
name|abfd
argument_list|,
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_hdr2
argument_list|,
operator|(
operator|(
name|bfd_byte
operator|*
operator|)
name|external_relocs
operator|)
operator|+
name|rel_hdr
operator|->
name|sh_size
argument_list|,
name|internal_relocs
operator|+
operator|(
name|NUM_SHDR_ENTRIES
argument_list|(
name|rel_hdr
argument_list|)
operator|*
name|bed
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
operator|)
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* Cache the results for next time, if we can.  */
if|if
condition|(
name|keep_memory
condition|)
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|relocs
operator|=
name|internal_relocs
expr_stmt|;
if|if
condition|(
name|alloc1
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|alloc1
argument_list|)
expr_stmt|;
comment|/* Don't free alloc2, since if it was allocated we are passing it      back (under the name of internal_relocs).  */
return|return
name|internal_relocs
return|;
name|error_return
label|:
if|if
condition|(
name|alloc1
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|alloc1
argument_list|)
expr_stmt|;
if|if
condition|(
name|alloc2
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|alloc2
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Record an assignment to a symbol made by a linker script.  We need    this in case some dynamic object refers to this symbol.  */
end_comment

begin_decl_stmt
name|boolean
name|NAME
argument_list|(
name|bfd_elf
argument_list|,
name|record_link_assignment
argument_list|)
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|name
argument_list|,
name|provide
argument_list|)
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|provide
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|hash
operator|->
name|creator
operator|->
name|flavour
operator|!=
name|bfd_target_elf_flavour
condition|)
return|return
name|true
return|;
name|h
operator|=
name|elf_link_hash_lookup
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|name
argument_list|,
name|true
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_new
condition|)
name|h
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_NON_ELF
expr_stmt|;
comment|/* If this symbol is being provided by the linker script, and it is      currently defined by a dynamic object, but not by a regular      object, then mark it as undefined so that the generic linker will      force the correct value.  */
if|if
condition|(
name|provide
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
condition|)
name|h
operator|->
name|root
operator|.
name|type
operator|=
name|bfd_link_hash_undefined
expr_stmt|;
comment|/* If this symbol is not being provided by the linker script, and it is      currently defined by a dynamic object, but not by a regular object,      then clear out any version information because the symbol will not be      associated with the dynamic object any more.  */
if|if
condition|(
operator|!
name|provide
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
condition|)
name|h
operator|->
name|verinfo
operator|.
name|verdef
operator|=
name|NULL
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_DEF_REGULAR
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
operator|(
name|ELF_LINK_HASH_DEF_DYNAMIC
operator||
name|ELF_LINK_HASH_REF_DYNAMIC
operator|)
operator|)
operator|!=
literal|0
operator|||
name|info
operator|->
name|shared
operator|)
operator|&&
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|_bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* If this is a weak defined symbol, and we know a corresponding 	 real symbol from the same dynamic object, make sure the real 	 symbol is also made into a dynamic symbol.  */
if|if
condition|(
name|h
operator|->
name|weakdef
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|weakdef
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|_bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|weakdef
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
return|return
name|true
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* This structure is used to pass information to    elf_link_assign_sym_version.  */
end_comment

begin_struct
struct|struct
name|elf_assign_sym_version_info
block|{
comment|/* Output BFD.  */
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
comment|/* General link information.  */
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
comment|/* Version tree.  */
name|struct
name|bfd_elf_version_tree
modifier|*
name|verdefs
decl_stmt|;
comment|/* Whether we had a failure.  */
name|boolean
name|failed
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This structure is used to pass information to    elf_link_find_version_dependencies.  */
end_comment

begin_struct
struct|struct
name|elf_find_verdep_info
block|{
comment|/* Output BFD.  */
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
comment|/* General link information.  */
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
comment|/* The number of dependencies.  */
name|unsigned
name|int
name|vers
decl_stmt|;
comment|/* Whether we had a failure.  */
name|boolean
name|failed
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Array used to determine the number of hash table buckets to use    based on the number of symbols there are.  If there are fewer than    3 symbols we use 1 bucket, fewer than 17 symbols we use 3 buckets,    fewer than 37 we use 17 buckets, and so forth.  We never use more    than 32771 buckets.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|size_t
name|elf_buckets
index|[]
init|=
block|{
literal|1
block|,
literal|3
block|,
literal|17
block|,
literal|37
block|,
literal|67
block|,
literal|97
block|,
literal|131
block|,
literal|197
block|,
literal|263
block|,
literal|521
block|,
literal|1031
block|,
literal|2053
block|,
literal|4099
block|,
literal|8209
block|,
literal|16411
block|,
literal|32771
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Compute bucket count for hashing table.  We do not use a static set    of possible tables sizes anymore.  Instead we determine for all    possible reasonable sizes of the table the outcome (i.e., the    number of collisions etc) and choose the best solution.  The    weighting functions are not too simple to allow the table to grow    without bounds.  Instead one of the weighting factors is the size.    Therefore the result is always a good payoff between few collisions    (= short chain lengths) and table size.  */
end_comment

begin_function
specifier|static
name|size_t
name|compute_bucket_count
parameter_list|(
name|info
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|size_t
name|dynsymcount
init|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynsymcount
decl_stmt|;
name|size_t
name|best_size
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|int
modifier|*
name|hashcodes
decl_stmt|;
name|unsigned
name|long
name|int
modifier|*
name|hashcodesp
decl_stmt|;
name|unsigned
name|long
name|int
name|i
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
comment|/* Compute the hash values for all exported symbols.  At the same      time store the values in an array so that we could use them for      optimizations.  */
name|amt
operator|=
name|dynsymcount
expr_stmt|;
name|amt
operator|*=
expr|sizeof
operator|(
name|unsigned
name|long
name|int
operator|)
expr_stmt|;
name|hashcodes
operator|=
operator|(
name|unsigned
name|long
name|int
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|hashcodes
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|hashcodesp
operator|=
name|hashcodes
expr_stmt|;
comment|/* Put all hash values in HASHCODES.  */
name|elf_link_hash_traverse
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|elf_collect_hash_codes
argument_list|,
operator|&
name|hashcodesp
argument_list|)
expr_stmt|;
comment|/* We have a problem here.  The following code to optimize the table    size requires an integer type with more the 32 bits.  If    BFD_HOST_U_64_BIT is set we know about such a type.  */
ifdef|#
directive|ifdef
name|BFD_HOST_U_64_BIT
if|if
condition|(
name|info
operator|->
name|optimize
operator|==
name|true
condition|)
block|{
name|unsigned
name|long
name|int
name|nsyms
init|=
name|hashcodesp
operator|-
name|hashcodes
decl_stmt|;
name|size_t
name|minsize
decl_stmt|;
name|size_t
name|maxsize
decl_stmt|;
name|BFD_HOST_U_64_BIT
name|best_chlen
init|=
operator|~
operator|(
operator|(
name|BFD_HOST_U_64_BIT
operator|)
literal|0
operator|)
decl_stmt|;
name|unsigned
name|long
name|int
modifier|*
name|counts
decl_stmt|;
comment|/* Possible optimization parameters: if we have NSYMS symbols we say 	 that the hashing table must at least have NSYMS/4 and at most 	 2*NSYMS buckets.  */
name|minsize
operator|=
name|nsyms
operator|/
literal|4
expr_stmt|;
if|if
condition|(
name|minsize
operator|==
literal|0
condition|)
name|minsize
operator|=
literal|1
expr_stmt|;
name|best_size
operator|=
name|maxsize
operator|=
name|nsyms
operator|*
literal|2
expr_stmt|;
comment|/* Create array where we count the collisions in.  We must use bfd_malloc 	 since the size could be large.  */
name|amt
operator|=
name|maxsize
expr_stmt|;
name|amt
operator|*=
expr|sizeof
operator|(
name|unsigned
name|long
name|int
operator|)
expr_stmt|;
name|counts
operator|=
operator|(
name|unsigned
name|long
name|int
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|counts
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|hashcodes
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Compute the "optimal" size for the hash table.  The criteria is a 	 minimal chain length.  The minor criteria is (of course) the size 	 of the table.  */
for|for
control|(
name|i
operator|=
name|minsize
init|;
name|i
operator|<
name|maxsize
condition|;
operator|++
name|i
control|)
block|{
comment|/* Walk through the array of hashcodes and count the collisions.  */
name|BFD_HOST_U_64_BIT
name|max
decl_stmt|;
name|unsigned
name|long
name|int
name|j
decl_stmt|;
name|unsigned
name|long
name|int
name|fact
decl_stmt|;
name|memset
argument_list|(
name|counts
argument_list|,
literal|'\0'
argument_list|,
name|i
operator|*
expr|sizeof
operator|(
name|unsigned
name|long
name|int
operator|)
argument_list|)
expr_stmt|;
comment|/* Determine how often each hash bucket is used.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nsyms
condition|;
operator|++
name|j
control|)
operator|++
name|counts
index|[
name|hashcodes
index|[
name|j
index|]
operator|%
name|i
index|]
expr_stmt|;
comment|/* For the weight function we need some information about the 	     pagesize on the target.  This is information need not be 100% 	     accurate.  Since this information is not available (so far) we 	     define it here to a reasonable default value.  If it is crucial 	     to have a better value some day simply define this value.  */
ifndef|#
directive|ifndef
name|BFD_TARGET_PAGESIZE
define|#
directive|define
name|BFD_TARGET_PAGESIZE
value|(4096)
endif|#
directive|endif
comment|/* We in any case need 2 + NSYMS entries for the size values and 	     the chains.  */
name|max
operator|=
operator|(
literal|2
operator|+
name|nsyms
operator|)
operator|*
operator|(
name|ARCH_SIZE
operator|/
literal|8
operator|)
expr_stmt|;
if|#
directive|if
literal|1
comment|/* Variant 1: optimize for short chains.  We add the squares 	     of all the chain lengths (which favous many small chain 	     over a few long chains).  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
operator|++
name|j
control|)
name|max
operator|+=
name|counts
index|[
name|j
index|]
operator|*
name|counts
index|[
name|j
index|]
expr_stmt|;
comment|/* This adds penalties for the overall size of the table.  */
name|fact
operator|=
name|i
operator|/
operator|(
name|BFD_TARGET_PAGESIZE
operator|/
operator|(
name|ARCH_SIZE
operator|/
literal|8
operator|)
operator|)
operator|+
literal|1
expr_stmt|;
name|max
operator|*=
name|fact
operator|*
name|fact
expr_stmt|;
else|#
directive|else
comment|/* Variant 2: Optimize a lot more for small table.  Here we 	     also add squares of the size but we also add penalties for 	     empty slots (the +1 term).  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
operator|++
name|j
control|)
name|max
operator|+=
operator|(
literal|1
operator|+
name|counts
index|[
name|j
index|]
operator|)
operator|*
operator|(
literal|1
operator|+
name|counts
index|[
name|j
index|]
operator|)
expr_stmt|;
comment|/* The overall size of the table is considered, but not as 	     strong as in variant 1, where it is squared.  */
name|fact
operator|=
name|i
operator|/
operator|(
name|BFD_TARGET_PAGESIZE
operator|/
operator|(
name|ARCH_SIZE
operator|/
literal|8
operator|)
operator|)
operator|+
literal|1
expr_stmt|;
name|max
operator|*=
name|fact
expr_stmt|;
endif|#
directive|endif
comment|/* Compare with current best results.  */
if|if
condition|(
name|max
operator|<
name|best_chlen
condition|)
block|{
name|best_chlen
operator|=
name|max
expr_stmt|;
name|best_size
operator|=
name|i
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|counts
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* defined (BFD_HOST_U_64_BIT) */
block|{
comment|/* This is the fallback solution if no 64bit type is available or if we 	 are not supposed to spend much time on optimizations.  We select the 	 bucket count using a fixed set of numbers.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|elf_buckets
index|[
name|i
index|]
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|best_size
operator|=
name|elf_buckets
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|dynsymcount
operator|<
name|elf_buckets
index|[
name|i
operator|+
literal|1
index|]
condition|)
break|break;
block|}
block|}
comment|/* Free the arrays we needed.  */
name|free
argument_list|(
name|hashcodes
argument_list|)
expr_stmt|;
return|return
name|best_size
return|;
block|}
end_function

begin_comment
comment|/* Set up the sizes and contents of the ELF dynamic sections.  This is    called by the ELF linker emulation before_allocation routine.  We    must set the sizes of the sections before the linker sets the    addresses of the various sections.  */
end_comment

begin_decl_stmt
name|boolean
name|NAME
argument_list|(
name|bfd_elf
argument_list|,
name|size_dynamic_sections
argument_list|)
argument_list|(
name|output_bfd
argument_list|,
name|soname
argument_list|,
name|rpath
argument_list|,
name|filter_shlib
argument_list|,
name|auxiliary_filters
argument_list|,
name|info
argument_list|,
name|sinterpptr
argument_list|,
name|verdefs
argument_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|soname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|rpath
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|filter_shlib
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|auxiliary_filters
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|asection
modifier|*
modifier|*
name|sinterpptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|bfd_elf_version_tree
modifier|*
name|verdefs
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|bfd_size_type
name|soname_indx
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
name|struct
name|elf_assign_sym_version_info
name|asvinfo
decl_stmt|;
operator|*
name|sinterpptr
operator|=
name|NULL
expr_stmt|;
name|soname_indx
operator|=
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|hash
operator|->
name|creator
operator|->
name|flavour
operator|!=
name|bfd_target_elf_flavour
condition|)
return|return
name|true
return|;
if|if
condition|(
operator|!
name|is_elf_hash_table
argument_list|(
name|info
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Any syms created from now on start with -1 in      got.refcount/offset and plt.refcount/offset.  */
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|init_refcount
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* The backend may have to create some sections regardless of whether      we're dynamic or not.  */
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|bed
operator|->
name|elf_backend_always_size_sections
operator|&&
operator|!
call|(
modifier|*
name|bed
operator|->
name|elf_backend_always_size_sections
call|)
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|false
return|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
comment|/* If there were no dynamic objects in the link, there is nothing to      do here.  */
if|if
condition|(
name|dynobj
operator|==
name|NULL
condition|)
return|return
name|true
return|;
if|if
condition|(
operator|!
name|_bfd_elf_maybe_strip_eh_frame_hdr
argument_list|(
name|info
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
name|struct
name|elf_info_failed
name|eif
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|asection
modifier|*
name|dynstr
decl_stmt|;
operator|*
name|sinterpptr
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".interp"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
operator|*
name|sinterpptr
operator|!=
name|NULL
operator|||
name|info
operator|->
name|shared
argument_list|)
expr_stmt|;
if|if
condition|(
name|soname
operator|!=
name|NULL
condition|)
block|{
name|soname_indx
operator|=
name|_bfd_elf_strtab_add
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
argument_list|,
name|soname
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|soname_indx
operator|==
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
operator|||
operator|!
name|elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
operator|(
name|bfd_vma
operator|)
name|DT_SONAME
argument_list|,
name|soname_indx
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|info
operator|->
name|symbolic
condition|)
block|{
if|if
condition|(
operator|!
name|elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
operator|(
name|bfd_vma
operator|)
name|DT_SYMBOLIC
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
name|info
operator|->
name|flags
operator||=
name|DF_SYMBOLIC
expr_stmt|;
block|}
if|if
condition|(
name|rpath
operator|!=
name|NULL
condition|)
block|{
name|bfd_size_type
name|indx
decl_stmt|;
name|indx
operator|=
name|_bfd_elf_strtab_add
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
argument_list|,
name|rpath
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|new_dtags
condition|)
name|_bfd_elf_strtab_addref
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
argument_list|,
name|indx
argument_list|)
expr_stmt|;
if|if
condition|(
name|indx
operator|==
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
operator|||
operator|!
name|elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
operator|(
name|bfd_vma
operator|)
name|DT_RPATH
argument_list|,
name|indx
argument_list|)
operator|||
operator|(
name|info
operator|->
name|new_dtags
operator|&&
operator|!
name|elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
operator|(
name|bfd_vma
operator|)
name|DT_RUNPATH
argument_list|,
name|indx
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|filter_shlib
operator|!=
name|NULL
condition|)
block|{
name|bfd_size_type
name|indx
decl_stmt|;
name|indx
operator|=
name|_bfd_elf_strtab_add
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
argument_list|,
name|filter_shlib
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|indx
operator|==
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
operator|||
operator|!
name|elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
operator|(
name|bfd_vma
operator|)
name|DT_FILTER
argument_list|,
name|indx
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|auxiliary_filters
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|auxiliary_filters
init|;
operator|*
name|p
operator|!=
name|NULL
condition|;
name|p
operator|++
control|)
block|{
name|bfd_size_type
name|indx
decl_stmt|;
name|indx
operator|=
name|_bfd_elf_strtab_add
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
argument_list|,
operator|*
name|p
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|indx
operator|==
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
operator|||
operator|!
name|elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
operator|(
name|bfd_vma
operator|)
name|DT_AUXILIARY
argument_list|,
name|indx
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
name|eif
operator|.
name|info
operator|=
name|info
expr_stmt|;
name|eif
operator|.
name|verdefs
operator|=
name|verdefs
expr_stmt|;
name|eif
operator|.
name|failed
operator|=
name|false
expr_stmt|;
comment|/* If we are supposed to export all symbols into the dynamic symbol 	 table (this is not the normal case), then do so.  */
if|if
condition|(
name|info
operator|->
name|export_dynamic
condition|)
block|{
name|elf_link_hash_traverse
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|elf_export_symbol
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|eif
argument_list|)
expr_stmt|;
if|if
condition|(
name|eif
operator|.
name|failed
condition|)
return|return
name|false
return|;
block|}
comment|/* Attach all the symbols to their version information.  */
name|asvinfo
operator|.
name|output_bfd
operator|=
name|output_bfd
expr_stmt|;
name|asvinfo
operator|.
name|info
operator|=
name|info
expr_stmt|;
name|asvinfo
operator|.
name|verdefs
operator|=
name|verdefs
expr_stmt|;
name|asvinfo
operator|.
name|failed
operator|=
name|false
expr_stmt|;
name|elf_link_hash_traverse
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|elf_link_assign_sym_version
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|asvinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|asvinfo
operator|.
name|failed
condition|)
return|return
name|false
return|;
comment|/* Find all symbols which were defined in a dynamic object and make 	 the backend pick a reasonable value for them.  */
name|elf_link_hash_traverse
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|elf_adjust_dynamic_symbol
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|eif
argument_list|)
expr_stmt|;
if|if
condition|(
name|eif
operator|.
name|failed
condition|)
return|return
name|false
return|;
comment|/* Add some entries to the .dynamic section.  We fill in some of the 	 values later, in elf_bfd_final_link, but we must add the entries 	 now so that we know the final size of the .dynamic section.  */
comment|/* If there are initialization and/or finalization functions to 	 call then add the corresponding DT_INIT/DT_FINI entries.  */
name|h
operator|=
operator|(
name|info
operator|->
name|init_function
condition|?
name|elf_link_hash_lookup
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|info
operator|->
name|init_function
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
else|:
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
operator|(
name|ELF_LINK_HASH_REF_REGULAR
operator||
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
operator|(
name|bfd_vma
operator|)
name|DT_INIT
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
block|}
name|h
operator|=
operator|(
name|info
operator|->
name|fini_function
condition|?
name|elf_link_hash_lookup
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|info
operator|->
name|fini_function
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
else|:
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
operator|(
name|ELF_LINK_HASH_REF_REGULAR
operator||
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
operator|(
name|bfd_vma
operator|)
name|DT_FINI
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
literal|".preinit_array"
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* DT_PREINIT_ARRAY is not allowed in shared library.  */
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
name|bfd
modifier|*
name|sub
decl_stmt|;
name|asection
modifier|*
name|o
decl_stmt|;
for|for
control|(
name|sub
operator|=
name|info
operator|->
name|input_bfds
init|;
name|sub
operator|!=
name|NULL
condition|;
name|sub
operator|=
name|sub
operator|->
name|link_next
control|)
for|for
control|(
name|o
operator|=
name|sub
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
if|if
condition|(
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_type
operator|==
name|SHT_PREINIT_ARRAY
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: .preinit_array section is not allowed in DSO"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|sub
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|bfd_set_error
argument_list|(
name|bfd_error_nonrepresentable_section
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
operator|(
name|bfd_vma
operator|)
name|DT_PREINIT_ARRAY
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
operator|||
operator|!
name|elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
operator|(
name|bfd_vma
operator|)
name|DT_PREINIT_ARRAYSZ
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
literal|".init_array"
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
operator|(
name|bfd_vma
operator|)
name|DT_INIT_ARRAY
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
operator|||
operator|!
name|elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
operator|(
name|bfd_vma
operator|)
name|DT_INIT_ARRAYSZ
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
literal|".fini_array"
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
operator|(
name|bfd_vma
operator|)
name|DT_FINI_ARRAY
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
operator|||
operator|!
name|elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
operator|(
name|bfd_vma
operator|)
name|DT_FINI_ARRAYSZ
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
block|}
name|dynstr
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynstr"
argument_list|)
expr_stmt|;
comment|/* If .dynstr is excluded from the link, we don't want any of 	 these tags.  Strictly, we should be checking each section 	 individually;  This quick check covers for the case where 	 someone does a /DISCARD/ : { *(*) }.  */
if|if
condition|(
name|dynstr
operator|!=
name|NULL
operator|&&
name|dynstr
operator|->
name|output_section
operator|!=
name|bfd_abs_section_ptr
condition|)
block|{
name|bfd_size_type
name|strsize
decl_stmt|;
name|strsize
operator|=
name|_bfd_elf_strtab_size
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
operator|(
name|bfd_vma
operator|)
name|DT_HASH
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
operator|||
operator|!
name|elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
operator|(
name|bfd_vma
operator|)
name|DT_STRTAB
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
operator|||
operator|!
name|elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
operator|(
name|bfd_vma
operator|)
name|DT_SYMTAB
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
operator|||
operator|!
name|elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
operator|(
name|bfd_vma
operator|)
name|DT_STRSZ
argument_list|,
name|strsize
argument_list|)
operator|||
operator|!
name|elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
operator|(
name|bfd_vma
operator|)
name|DT_SYMENT
argument_list|,
operator|(
name|bfd_vma
operator|)
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
comment|/* The backend must work out the sizes of all the other dynamic      sections.  */
if|if
condition|(
name|bed
operator|->
name|elf_backend_size_dynamic_sections
operator|&&
operator|!
call|(
modifier|*
name|bed
operator|->
name|elf_backend_size_dynamic_sections
call|)
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
name|bfd_size_type
name|dynsymcount
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|size_t
name|bucketcount
init|=
literal|0
decl_stmt|;
name|size_t
name|hash_entry_size
decl_stmt|;
name|unsigned
name|int
name|dtagcount
decl_stmt|;
comment|/* Set up the version definition section.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".gnu.version_d"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* We may have created additional version definitions if we are 	 just linking a regular application.  */
name|verdefs
operator|=
name|asvinfo
operator|.
name|verdefs
expr_stmt|;
comment|/* Skip anonymous version tag.  */
if|if
condition|(
name|verdefs
operator|!=
name|NULL
operator|&&
name|verdefs
operator|->
name|vernum
operator|==
literal|0
condition|)
name|verdefs
operator|=
name|verdefs
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|verdefs
operator|==
name|NULL
condition|)
name|_bfd_strip_section_from_output
argument_list|(
name|info
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|else
block|{
name|unsigned
name|int
name|cdefs
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
name|struct
name|bfd_elf_version_tree
modifier|*
name|t
decl_stmt|;
name|bfd_byte
modifier|*
name|p
decl_stmt|;
name|Elf_Internal_Verdef
name|def
decl_stmt|;
name|Elf_Internal_Verdaux
name|defaux
decl_stmt|;
name|cdefs
operator|=
literal|0
expr_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
comment|/* Make space for the base version.  */
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf_External_Verdef
argument_list|)
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf_External_Verdaux
argument_list|)
expr_stmt|;
operator|++
name|cdefs
expr_stmt|;
for|for
control|(
name|t
operator|=
name|verdefs
init|;
name|t
operator|!=
name|NULL
condition|;
name|t
operator|=
name|t
operator|->
name|next
control|)
block|{
name|struct
name|bfd_elf_version_deps
modifier|*
name|n
decl_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf_External_Verdef
argument_list|)
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf_External_Verdaux
argument_list|)
expr_stmt|;
operator|++
name|cdefs
expr_stmt|;
for|for
control|(
name|n
operator|=
name|t
operator|->
name|deps
init|;
name|n
operator|!=
name|NULL
condition|;
name|n
operator|=
name|n
operator|->
name|next
control|)
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf_External_Verdaux
argument_list|)
expr_stmt|;
block|}
name|s
operator|->
name|_raw_size
operator|=
name|size
expr_stmt|;
name|s
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|output_bfd
argument_list|,
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|contents
operator|==
name|NULL
operator|&&
name|s
operator|->
name|_raw_size
operator|!=
literal|0
condition|)
return|return
name|false
return|;
comment|/* Fill in the version definition section.  */
name|p
operator|=
name|s
operator|->
name|contents
expr_stmt|;
name|def
operator|.
name|vd_version
operator|=
name|VER_DEF_CURRENT
expr_stmt|;
name|def
operator|.
name|vd_flags
operator|=
name|VER_FLG_BASE
expr_stmt|;
name|def
operator|.
name|vd_ndx
operator|=
literal|1
expr_stmt|;
name|def
operator|.
name|vd_cnt
operator|=
literal|1
expr_stmt|;
name|def
operator|.
name|vd_aux
operator|=
sizeof|sizeof
argument_list|(
name|Elf_External_Verdef
argument_list|)
expr_stmt|;
name|def
operator|.
name|vd_next
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|Elf_External_Verdef
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|Elf_External_Verdaux
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|soname_indx
operator|!=
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
condition|)
block|{
name|_bfd_elf_strtab_addref
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
argument_list|,
name|soname_indx
argument_list|)
expr_stmt|;
name|def
operator|.
name|vd_hash
operator|=
name|bfd_elf_hash
argument_list|(
name|soname
argument_list|)
expr_stmt|;
name|defaux
operator|.
name|vda_name
operator|=
name|soname_indx
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bfd_size_type
name|indx
decl_stmt|;
name|name
operator|=
name|basename
argument_list|(
name|output_bfd
operator|->
name|filename
argument_list|)
expr_stmt|;
name|def
operator|.
name|vd_hash
operator|=
name|bfd_elf_hash
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|indx
operator|=
name|_bfd_elf_strtab_add
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
argument_list|,
name|name
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|indx
operator|==
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
condition|)
return|return
name|false
return|;
name|defaux
operator|.
name|vda_name
operator|=
name|indx
expr_stmt|;
block|}
name|defaux
operator|.
name|vda_next
operator|=
literal|0
expr_stmt|;
name|_bfd_elf_swap_verdef_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|def
argument_list|,
operator|(
name|Elf_External_Verdef
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|Elf_External_Verdef
argument_list|)
expr_stmt|;
name|_bfd_elf_swap_verdaux_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|defaux
argument_list|,
operator|(
name|Elf_External_Verdaux
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|Elf_External_Verdaux
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|verdefs
init|;
name|t
operator|!=
name|NULL
condition|;
name|t
operator|=
name|t
operator|->
name|next
control|)
block|{
name|unsigned
name|int
name|cdeps
decl_stmt|;
name|struct
name|bfd_elf_version_deps
modifier|*
name|n
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|cdeps
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
name|t
operator|->
name|deps
init|;
name|n
operator|!=
name|NULL
condition|;
name|n
operator|=
name|n
operator|->
name|next
control|)
operator|++
name|cdeps
expr_stmt|;
comment|/* Add a symbol representing this version.  */
name|h
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|dynobj
argument_list|,
name|t
operator|->
name|name
argument_list|,
name|BSF_GLOBAL
argument_list|,
name|bfd_abs_section_ptr
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|false
argument_list|,
name|get_elf_backend_data
argument_list|(
name|dynobj
argument_list|)
operator|->
name|collect
argument_list|,
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|*
operator|)
operator|&
name|h
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
name|h
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_NON_ELF
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_DEF_REGULAR
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|STT_OBJECT
expr_stmt|;
name|h
operator|->
name|verinfo
operator|.
name|vertree
operator|=
name|t
expr_stmt|;
if|if
condition|(
operator|!
name|_bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|false
return|;
name|def
operator|.
name|vd_version
operator|=
name|VER_DEF_CURRENT
expr_stmt|;
name|def
operator|.
name|vd_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|globals
operator|==
name|NULL
operator|&&
name|t
operator|->
name|locals
operator|==
name|NULL
operator|&&
operator|!
name|t
operator|->
name|used
condition|)
name|def
operator|.
name|vd_flags
operator||=
name|VER_FLG_WEAK
expr_stmt|;
name|def
operator|.
name|vd_ndx
operator|=
name|t
operator|->
name|vernum
operator|+
literal|1
expr_stmt|;
name|def
operator|.
name|vd_cnt
operator|=
name|cdeps
operator|+
literal|1
expr_stmt|;
name|def
operator|.
name|vd_hash
operator|=
name|bfd_elf_hash
argument_list|(
name|t
operator|->
name|name
argument_list|)
expr_stmt|;
name|def
operator|.
name|vd_aux
operator|=
sizeof|sizeof
argument_list|(
name|Elf_External_Verdef
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|next
operator|!=
name|NULL
condition|)
name|def
operator|.
name|vd_next
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|Elf_External_Verdef
argument_list|)
operator|+
operator|(
name|cdeps
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|Elf_External_Verdaux
argument_list|)
operator|)
expr_stmt|;
else|else
name|def
operator|.
name|vd_next
operator|=
literal|0
expr_stmt|;
name|_bfd_elf_swap_verdef_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|def
argument_list|,
operator|(
name|Elf_External_Verdef
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|Elf_External_Verdef
argument_list|)
expr_stmt|;
name|defaux
operator|.
name|vda_name
operator|=
name|h
operator|->
name|dynstr_index
expr_stmt|;
name|_bfd_elf_strtab_addref
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
argument_list|,
name|h
operator|->
name|dynstr_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|deps
operator|==
name|NULL
condition|)
name|defaux
operator|.
name|vda_next
operator|=
literal|0
expr_stmt|;
else|else
name|defaux
operator|.
name|vda_next
operator|=
sizeof|sizeof
argument_list|(
name|Elf_External_Verdaux
argument_list|)
expr_stmt|;
name|t
operator|->
name|name_indx
operator|=
name|defaux
operator|.
name|vda_name
expr_stmt|;
name|_bfd_elf_swap_verdaux_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|defaux
argument_list|,
operator|(
name|Elf_External_Verdaux
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|Elf_External_Verdaux
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
name|t
operator|->
name|deps
init|;
name|n
operator|!=
name|NULL
condition|;
name|n
operator|=
name|n
operator|->
name|next
control|)
block|{
if|if
condition|(
name|n
operator|->
name|version_needed
operator|==
name|NULL
condition|)
block|{
comment|/* This can happen if there was an error in the 			 version script.  */
name|defaux
operator|.
name|vda_name
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|defaux
operator|.
name|vda_name
operator|=
name|n
operator|->
name|version_needed
operator|->
name|name_indx
expr_stmt|;
name|_bfd_elf_strtab_addref
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
argument_list|,
name|defaux
operator|.
name|vda_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|->
name|next
operator|==
name|NULL
condition|)
name|defaux
operator|.
name|vda_next
operator|=
literal|0
expr_stmt|;
else|else
name|defaux
operator|.
name|vda_next
operator|=
sizeof|sizeof
argument_list|(
name|Elf_External_Verdaux
argument_list|)
expr_stmt|;
name|_bfd_elf_swap_verdaux_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|defaux
argument_list|,
operator|(
name|Elf_External_Verdaux
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|Elf_External_Verdaux
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
operator|(
name|bfd_vma
operator|)
name|DT_VERDEF
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
operator|||
operator|!
name|elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
operator|(
name|bfd_vma
operator|)
name|DT_VERDEFNUM
argument_list|,
operator|(
name|bfd_vma
operator|)
name|cdefs
argument_list|)
condition|)
return|return
name|false
return|;
name|elf_tdata
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|cverdefs
operator|=
name|cdefs
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|new_dtags
operator|&&
name|info
operator|->
name|flags
condition|)
block|{
if|if
condition|(
operator|!
name|elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
operator|(
name|bfd_vma
operator|)
name|DT_FLAGS
argument_list|,
name|info
operator|->
name|flags
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|info
operator|->
name|flags_1
condition|)
block|{
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
name|info
operator|->
name|flags_1
operator|&=
operator|~
operator|(
name|DF_1_INITFIRST
operator||
name|DF_1_NODELETE
operator||
name|DF_1_NOOPEN
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
operator|(
name|bfd_vma
operator|)
name|DT_FLAGS_1
argument_list|,
name|info
operator|->
name|flags_1
argument_list|)
condition|)
return|return
name|false
return|;
block|}
comment|/* Work out the size of the version reference section.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".gnu.version_r"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|{
name|struct
name|elf_find_verdep_info
name|sinfo
decl_stmt|;
name|sinfo
operator|.
name|output_bfd
operator|=
name|output_bfd
expr_stmt|;
name|sinfo
operator|.
name|info
operator|=
name|info
expr_stmt|;
name|sinfo
operator|.
name|vers
operator|=
name|elf_tdata
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|cverdefs
expr_stmt|;
if|if
condition|(
name|sinfo
operator|.
name|vers
operator|==
literal|0
condition|)
name|sinfo
operator|.
name|vers
operator|=
literal|1
expr_stmt|;
name|sinfo
operator|.
name|failed
operator|=
name|false
expr_stmt|;
name|elf_link_hash_traverse
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|elf_link_find_version_dependencies
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|sinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_tdata
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|verref
operator|==
name|NULL
condition|)
name|_bfd_strip_section_from_output
argument_list|(
name|info
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|else
block|{
name|Elf_Internal_Verneed
modifier|*
name|t
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
name|unsigned
name|int
name|crefs
decl_stmt|;
name|bfd_byte
modifier|*
name|p
decl_stmt|;
comment|/* Build the version definition section.  */
name|size
operator|=
literal|0
expr_stmt|;
name|crefs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|t
operator|=
name|elf_tdata
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|verref
init|;
name|t
operator|!=
name|NULL
condition|;
name|t
operator|=
name|t
operator|->
name|vn_nextref
control|)
block|{
name|Elf_Internal_Vernaux
modifier|*
name|a
decl_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf_External_Verneed
argument_list|)
expr_stmt|;
operator|++
name|crefs
expr_stmt|;
for|for
control|(
name|a
operator|=
name|t
operator|->
name|vn_auxptr
init|;
name|a
operator|!=
name|NULL
condition|;
name|a
operator|=
name|a
operator|->
name|vna_nextptr
control|)
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf_External_Vernaux
argument_list|)
expr_stmt|;
block|}
name|s
operator|->
name|_raw_size
operator|=
name|size
expr_stmt|;
name|s
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|output_bfd
argument_list|,
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|p
operator|=
name|s
operator|->
name|contents
expr_stmt|;
for|for
control|(
name|t
operator|=
name|elf_tdata
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|verref
init|;
name|t
operator|!=
name|NULL
condition|;
name|t
operator|=
name|t
operator|->
name|vn_nextref
control|)
block|{
name|unsigned
name|int
name|caux
decl_stmt|;
name|Elf_Internal_Vernaux
modifier|*
name|a
decl_stmt|;
name|bfd_size_type
name|indx
decl_stmt|;
name|caux
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|a
operator|=
name|t
operator|->
name|vn_auxptr
init|;
name|a
operator|!=
name|NULL
condition|;
name|a
operator|=
name|a
operator|->
name|vna_nextptr
control|)
operator|++
name|caux
expr_stmt|;
name|t
operator|->
name|vn_version
operator|=
name|VER_NEED_CURRENT
expr_stmt|;
name|t
operator|->
name|vn_cnt
operator|=
name|caux
expr_stmt|;
name|indx
operator|=
name|_bfd_elf_strtab_add
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
argument_list|,
name|elf_dt_name
argument_list|(
name|t
operator|->
name|vn_bfd
argument_list|)
operator|!=
name|NULL
condition|?
name|elf_dt_name
argument_list|(
name|t
operator|->
name|vn_bfd
argument_list|)
else|:
name|basename
argument_list|(
name|t
operator|->
name|vn_bfd
operator|->
name|filename
argument_list|)
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|indx
operator|==
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
condition|)
return|return
name|false
return|;
name|t
operator|->
name|vn_file
operator|=
name|indx
expr_stmt|;
name|t
operator|->
name|vn_aux
operator|=
sizeof|sizeof
argument_list|(
name|Elf_External_Verneed
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|vn_nextref
operator|==
name|NULL
condition|)
name|t
operator|->
name|vn_next
operator|=
literal|0
expr_stmt|;
else|else
name|t
operator|->
name|vn_next
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|Elf_External_Verneed
argument_list|)
operator|+
name|caux
operator|*
sizeof|sizeof
argument_list|(
name|Elf_External_Vernaux
argument_list|)
operator|)
expr_stmt|;
name|_bfd_elf_swap_verneed_out
argument_list|(
name|output_bfd
argument_list|,
name|t
argument_list|,
operator|(
name|Elf_External_Verneed
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|Elf_External_Verneed
argument_list|)
expr_stmt|;
for|for
control|(
name|a
operator|=
name|t
operator|->
name|vn_auxptr
init|;
name|a
operator|!=
name|NULL
condition|;
name|a
operator|=
name|a
operator|->
name|vna_nextptr
control|)
block|{
name|a
operator|->
name|vna_hash
operator|=
name|bfd_elf_hash
argument_list|(
name|a
operator|->
name|vna_nodename
argument_list|)
expr_stmt|;
name|indx
operator|=
name|_bfd_elf_strtab_add
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
argument_list|,
name|a
operator|->
name|vna_nodename
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|indx
operator|==
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
condition|)
return|return
name|false
return|;
name|a
operator|->
name|vna_name
operator|=
name|indx
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|vna_nextptr
operator|==
name|NULL
condition|)
name|a
operator|->
name|vna_next
operator|=
literal|0
expr_stmt|;
else|else
name|a
operator|->
name|vna_next
operator|=
sizeof|sizeof
argument_list|(
name|Elf_External_Vernaux
argument_list|)
expr_stmt|;
name|_bfd_elf_swap_vernaux_out
argument_list|(
name|output_bfd
argument_list|,
name|a
argument_list|,
operator|(
name|Elf_External_Vernaux
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|Elf_External_Vernaux
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
operator|(
name|bfd_vma
operator|)
name|DT_VERNEED
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
operator|||
operator|!
name|elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
operator|(
name|bfd_vma
operator|)
name|DT_VERNEEDNUM
argument_list|,
operator|(
name|bfd_vma
operator|)
name|crefs
argument_list|)
condition|)
return|return
name|false
return|;
name|elf_tdata
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|cverrefs
operator|=
name|crefs
expr_stmt|;
block|}
block|}
comment|/* Assign dynsym indicies.  In a shared library we generate a 	 section symbol for each output section, which come first. 	 Next come all of the back-end allocated local dynamic syms, 	 followed by the rest of the global symbols.  */
name|dynsymcount
operator|=
name|_bfd_elf_link_renumber_dynsyms
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|)
expr_stmt|;
comment|/* Work out the size of the symbol version section.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".gnu.version"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynsymcount
operator|==
literal|0
operator|||
operator|(
name|verdefs
operator|==
name|NULL
operator|&&
name|elf_tdata
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|verref
operator|==
name|NULL
operator|)
condition|)
block|{
name|_bfd_strip_section_from_output
argument_list|(
name|info
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* The DYNSYMCOUNT might have changed if we were going to 	     output a dynamic symbol table entry for S.  */
name|dynsymcount
operator|=
name|_bfd_elf_link_renumber_dynsyms
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|->
name|_raw_size
operator|=
name|dynsymcount
operator|*
sizeof|sizeof
argument_list|(
name|Elf_External_Versym
argument_list|)
expr_stmt|;
name|s
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|output_bfd
argument_list|,
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
operator|(
name|bfd_vma
operator|)
name|DT_VERSYM
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
block|}
comment|/* Set the size of the .dynsym and .hash sections.  We counted 	 the number of dynamic symbols in elf_link_add_object_symbols. 	 We will build the contents of .dynsym and .hash when we build 	 the final symbol table, because until then we do not know the 	 correct value to give the symbols.  We built the .dynstr 	 section as we went along in elf_link_add_object_symbols.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynsym"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|=
name|dynsymcount
operator|*
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
expr_stmt|;
name|s
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|output_bfd
argument_list|,
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|contents
operator|==
name|NULL
operator|&&
name|s
operator|->
name|_raw_size
operator|!=
literal|0
condition|)
return|return
name|false
return|;
if|if
condition|(
name|dynsymcount
operator|!=
literal|0
condition|)
block|{
name|Elf_Internal_Sym
name|isym
decl_stmt|;
comment|/* The first entry in .dynsym is a dummy symbol.  */
name|isym
operator|.
name|st_value
operator|=
literal|0
expr_stmt|;
name|isym
operator|.
name|st_size
operator|=
literal|0
expr_stmt|;
name|isym
operator|.
name|st_name
operator|=
literal|0
expr_stmt|;
name|isym
operator|.
name|st_info
operator|=
literal|0
expr_stmt|;
name|isym
operator|.
name|st_other
operator|=
literal|0
expr_stmt|;
name|isym
operator|.
name|st_shndx
operator|=
literal|0
expr_stmt|;
name|elf_swap_symbol_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|isym
argument_list|,
operator|(
name|PTR
operator|)
name|s
operator|->
name|contents
argument_list|,
operator|(
name|PTR
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Compute the size of the hashing table.  As a side effect this 	 computes the hash values for all the names we export.  */
name|bucketcount
operator|=
name|compute_bucket_count
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".hash"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|hash_entry_size
operator|=
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|=
operator|(
operator|(
literal|2
operator|+
name|bucketcount
operator|+
name|dynsymcount
operator|)
operator|*
name|hash_entry_size
operator|)
expr_stmt|;
name|s
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|output_bfd
argument_list|,
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|memset
argument_list|(
name|s
operator|->
name|contents
argument_list|,
literal|0
argument_list|,
operator|(
name|size_t
operator|)
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
name|bfd_put
argument_list|(
literal|8
operator|*
name|hash_entry_size
argument_list|,
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|bucketcount
argument_list|,
name|s
operator|->
name|contents
argument_list|)
expr_stmt|;
name|bfd_put
argument_list|(
literal|8
operator|*
name|hash_entry_size
argument_list|,
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|dynsymcount
argument_list|,
name|s
operator|->
name|contents
operator|+
name|hash_entry_size
argument_list|)
expr_stmt|;
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|bucketcount
operator|=
name|bucketcount
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynstr"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|elf_finalize_dynstr
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|=
name|_bfd_elf_strtab_size
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
argument_list|)
expr_stmt|;
for|for
control|(
name|dtagcount
operator|=
literal|0
init|;
name|dtagcount
operator|<=
name|info
operator|->
name|spare_dynamic_tags
condition|;
operator|++
name|dtagcount
control|)
if|if
condition|(
operator|!
name|elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
operator|(
name|bfd_vma
operator|)
name|DT_NULL
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* This function is used to adjust offsets into .dynstr for    dynamic symbols.  This is called via elf_link_hash_traverse.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|elf_adjust_dynstr_offsets
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|boolean
name|elf_adjust_dynstr_offsets
parameter_list|(
name|h
parameter_list|,
name|data
parameter_list|)
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
name|struct
name|elf_strtab_hash
modifier|*
name|dynstr
init|=
operator|(
expr|struct
name|elf_strtab_hash
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
condition|)
name|h
operator|->
name|dynstr_index
operator|=
name|_bfd_elf_strtab_offset
argument_list|(
name|dynstr
argument_list|,
name|h
operator|->
name|dynstr_index
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Assign string offsets in .dynstr, update all structures referencing    them.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf_finalize_dynstr
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|struct
name|elf_link_local_dynamic_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|elf_strtab_hash
modifier|*
name|dynstr
init|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
decl_stmt|;
name|bfd
modifier|*
name|dynobj
init|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|sdyn
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
name|Elf_External_Dyn
modifier|*
name|dyncon
decl_stmt|,
modifier|*
name|dynconend
decl_stmt|;
name|_bfd_elf_strtab_finalize
argument_list|(
name|dynstr
argument_list|)
expr_stmt|;
name|size
operator|=
name|_bfd_elf_strtab_size
argument_list|(
name|dynstr
argument_list|)
expr_stmt|;
comment|/* Update all .dynamic entries referencing .dynstr strings.  */
name|sdyn
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sdyn
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dyncon
operator|=
operator|(
name|Elf_External_Dyn
operator|*
operator|)
name|sdyn
operator|->
name|contents
expr_stmt|;
name|dynconend
operator|=
operator|(
name|Elf_External_Dyn
operator|*
operator|)
operator|(
name|sdyn
operator|->
name|contents
operator|+
name|sdyn
operator|->
name|_raw_size
operator|)
expr_stmt|;
for|for
control|(
init|;
name|dyncon
operator|<
name|dynconend
condition|;
name|dyncon
operator|++
control|)
block|{
name|Elf_Internal_Dyn
name|dyn
decl_stmt|;
name|elf_swap_dyn_in
argument_list|(
name|dynobj
argument_list|,
name|dyncon
argument_list|,
operator|&
name|dyn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dyn
operator|.
name|d_tag
condition|)
block|{
case|case
name|DT_STRSZ
case|:
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|size
expr_stmt|;
name|elf_swap_dyn_out
argument_list|(
name|dynobj
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_NEEDED
case|:
case|case
name|DT_SONAME
case|:
case|case
name|DT_RPATH
case|:
case|case
name|DT_RUNPATH
case|:
case|case
name|DT_FILTER
case|:
case|case
name|DT_AUXILIARY
case|:
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|_bfd_elf_strtab_offset
argument_list|(
name|dynstr
argument_list|,
name|dyn
operator|.
name|d_un
operator|.
name|d_val
argument_list|)
expr_stmt|;
name|elf_swap_dyn_out
argument_list|(
name|dynobj
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
comment|/* Now update local dynamic symbols.  */
for|for
control|(
name|entry
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynlocal
init|;
name|entry
condition|;
name|entry
operator|=
name|entry
operator|->
name|next
control|)
name|entry
operator|->
name|isym
operator|.
name|st_name
operator|=
name|_bfd_elf_strtab_offset
argument_list|(
name|dynstr
argument_list|,
name|entry
operator|->
name|isym
operator|.
name|st_name
argument_list|)
expr_stmt|;
comment|/* And the rest of dynamic symbols.  */
name|elf_link_hash_traverse
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|elf_adjust_dynstr_offsets
argument_list|,
name|dynstr
argument_list|)
expr_stmt|;
comment|/* Adjust version definitions.  */
if|if
condition|(
name|elf_tdata
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|cverdefs
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_byte
modifier|*
name|p
decl_stmt|;
name|bfd_size_type
name|i
decl_stmt|;
name|Elf_Internal_Verdef
name|def
decl_stmt|;
name|Elf_Internal_Verdaux
name|defaux
decl_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".gnu.version_d"
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|s
operator|->
name|contents
expr_stmt|;
do|do
block|{
name|_bfd_elf_swap_verdef_in
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|Elf_External_Verdef
operator|*
operator|)
name|p
argument_list|,
operator|&
name|def
argument_list|)
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|Elf_External_Verdef
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|def
operator|.
name|vd_cnt
condition|;
operator|++
name|i
control|)
block|{
name|_bfd_elf_swap_verdaux_in
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|Elf_External_Verdaux
operator|*
operator|)
name|p
argument_list|,
operator|&
name|defaux
argument_list|)
expr_stmt|;
name|defaux
operator|.
name|vda_name
operator|=
name|_bfd_elf_strtab_offset
argument_list|(
name|dynstr
argument_list|,
name|defaux
operator|.
name|vda_name
argument_list|)
expr_stmt|;
name|_bfd_elf_swap_verdaux_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|defaux
argument_list|,
operator|(
name|Elf_External_Verdaux
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|Elf_External_Verdaux
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|def
operator|.
name|vd_next
condition|)
do|;
block|}
comment|/* Adjust version references.  */
if|if
condition|(
name|elf_tdata
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|verref
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_byte
modifier|*
name|p
decl_stmt|;
name|bfd_size_type
name|i
decl_stmt|;
name|Elf_Internal_Verneed
name|need
decl_stmt|;
name|Elf_Internal_Vernaux
name|needaux
decl_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".gnu.version_r"
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|s
operator|->
name|contents
expr_stmt|;
do|do
block|{
name|_bfd_elf_swap_verneed_in
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|Elf_External_Verneed
operator|*
operator|)
name|p
argument_list|,
operator|&
name|need
argument_list|)
expr_stmt|;
name|need
operator|.
name|vn_file
operator|=
name|_bfd_elf_strtab_offset
argument_list|(
name|dynstr
argument_list|,
name|need
operator|.
name|vn_file
argument_list|)
expr_stmt|;
name|_bfd_elf_swap_verneed_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|need
argument_list|,
operator|(
name|Elf_External_Verneed
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|Elf_External_Verneed
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|need
operator|.
name|vn_cnt
condition|;
operator|++
name|i
control|)
block|{
name|_bfd_elf_swap_vernaux_in
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|Elf_External_Vernaux
operator|*
operator|)
name|p
argument_list|,
operator|&
name|needaux
argument_list|)
expr_stmt|;
name|needaux
operator|.
name|vna_name
operator|=
name|_bfd_elf_strtab_offset
argument_list|(
name|dynstr
argument_list|,
name|needaux
operator|.
name|vna_name
argument_list|)
expr_stmt|;
name|_bfd_elf_swap_vernaux_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|needaux
argument_list|,
operator|(
name|Elf_External_Vernaux
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|Elf_External_Vernaux
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|need
operator|.
name|vn_next
condition|)
do|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Fix up the flags for a symbol.  This handles various cases which    can only be fixed after all the input files are seen.  This is    currently called by both adjust_dynamic_symbol and    assign_sym_version, which is unnecessary but perhaps more robust in    the face of future changes.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf_fix_symbol_flags
parameter_list|(
name|h
parameter_list|,
name|eif
parameter_list|)
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|elf_info_failed
modifier|*
name|eif
decl_stmt|;
block|{
comment|/* If this symbol was mentioned in a non-ELF file, try to set      DEF_REGULAR and REF_REGULAR correctly.  This is the only way to      permit a non-ELF file to correctly refer to a symbol defined in      an ELF dynamic object.  */
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_NON_ELF
operator|)
operator|!=
literal|0
condition|)
block|{
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defined
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
condition|)
name|h
operator|->
name|elf_link_hash_flags
operator||=
operator|(
name|ELF_LINK_HASH_REF_REGULAR
operator||
name|ELF_LINK_HASH_REF_REGULAR_NONWEAK
operator|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
operator|!=
name|NULL
operator|&&
operator|(
name|bfd_get_flavour
argument_list|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
argument_list|)
operator|==
name|bfd_target_elf_flavour
operator|)
condition|)
name|h
operator|->
name|elf_link_hash_flags
operator||=
operator|(
name|ELF_LINK_HASH_REF_REGULAR
operator||
name|ELF_LINK_HASH_REF_REGULAR_NONWEAK
operator|)
expr_stmt|;
else|else
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_DEF_REGULAR
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|&&
operator|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_REF_DYNAMIC
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|_bfd_elf_link_record_dynamic_symbol
argument_list|(
name|eif
operator|->
name|info
argument_list|,
name|h
argument_list|)
condition|)
block|{
name|eif
operator|->
name|failed
operator|=
name|true
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
block|}
else|else
block|{
comment|/* Unfortunately, ELF_LINK_NON_ELF is only correct if the symbol 	 was first seen in a non-ELF file.  Fortunately, if the symbol 	 was first seen in an ELF file, we're probably OK unless the 	 symbol was defined in a non-ELF file.  Catch that case here. 	 FIXME: We're still in trouble if the symbol was first seen in 	 a dynamic object, and then later in a non-ELF regular object.  */
if|if
condition|(
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
operator|!=
name|NULL
condition|?
operator|(
name|bfd_get_flavour
argument_list|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
argument_list|)
operator|!=
name|bfd_target_elf_flavour
operator|)
else|:
operator|(
name|bfd_is_abs_section
argument_list|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
argument_list|)
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|==
literal|0
operator|)
operator|)
condition|)
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_DEF_REGULAR
expr_stmt|;
block|}
comment|/* If this is a final link, and the symbol was defined as a common      symbol in a regular object file, and there was no definition in      any dynamic object, then the linker will have allocated space for      the symbol in a common section but the ELF_LINK_HASH_DEF_REGULAR      flag will not have been set.  */
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_REF_REGULAR
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|==
literal|0
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|==
literal|0
condition|)
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_DEF_REGULAR
expr_stmt|;
comment|/* If -Bsymbolic was used (which means to bind references to global      symbols to the definition within the shared object), and this      symbol was defined in a regular object, then it actually doesn't      need a PLT entry, and we can accomplish that by forcing it local.      Likewise, if the symbol has hidden or internal visibility.      FIXME: It might be that we also do not need a PLT for other      non-hidden visibilities, but we would have to tell that to the      backend specifically; we can't just clear PLT-related data here.  */
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_NEEDS_PLT
operator|)
operator|!=
literal|0
operator|&&
name|eif
operator|->
name|info
operator|->
name|shared
operator|&&
name|is_elf_hash_table
argument_list|(
name|eif
operator|->
name|info
argument_list|)
operator|&&
operator|(
name|eif
operator|->
name|info
operator|->
name|symbolic
operator|||
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_INTERNAL
operator|||
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_HIDDEN
operator|)
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
name|boolean
name|force_local
decl_stmt|;
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|elf_hash_table
argument_list|(
name|eif
operator|->
name|info
argument_list|)
operator|->
name|dynobj
argument_list|)
expr_stmt|;
name|force_local
operator|=
operator|(
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_INTERNAL
operator|||
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_HIDDEN
operator|)
expr_stmt|;
call|(
modifier|*
name|bed
operator|->
name|elf_backend_hide_symbol
call|)
argument_list|(
name|eif
operator|->
name|info
argument_list|,
name|h
argument_list|,
name|force_local
argument_list|)
expr_stmt|;
block|}
comment|/* If this is a weak defined symbol in a dynamic object, and we know      the real definition in the dynamic object, copy interesting flags      over to the real definition.  */
if|if
condition|(
name|h
operator|->
name|weakdef
operator|!=
name|NULL
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|weakdef
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
argument_list|)
expr_stmt|;
name|weakdef
operator|=
name|h
operator|->
name|weakdef
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|weakdef
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
argument_list|)
expr_stmt|;
comment|/* If the real definition is defined by a regular object file, 	 don't do anything special.  See the longer description in 	 elf_adjust_dynamic_symbol, below.  */
if|if
condition|(
operator|(
name|weakdef
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|!=
literal|0
condition|)
name|h
operator|->
name|weakdef
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|elf_hash_table
argument_list|(
name|eif
operator|->
name|info
argument_list|)
operator|->
name|dynobj
argument_list|)
expr_stmt|;
call|(
modifier|*
name|bed
operator|->
name|elf_backend_copy_indirect_symbol
call|)
argument_list|(
name|weakdef
argument_list|,
name|h
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Make the backend pick a good value for a dynamic symbol.  This is    called via elf_link_hash_traverse, and also calls itself    recursively.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf_adjust_dynamic_symbol
parameter_list|(
name|h
parameter_list|,
name|data
parameter_list|)
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
name|struct
name|elf_info_failed
modifier|*
name|eif
init|=
operator|(
expr|struct
name|elf_info_failed
operator|*
operator|)
name|data
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
block|{
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
name|h
operator|->
name|got
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* When warning symbols are created, they **replace** the "real" 	 entry in the hash table, thus we never get to see the real 	 symbol in a hash traversal.  So look at it now.  */
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
block|}
comment|/* Ignore indirect symbols.  These are added by the versioning code.  */
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
condition|)
return|return
name|true
return|;
if|if
condition|(
operator|!
name|is_elf_hash_table
argument_list|(
name|eif
operator|->
name|info
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Fix the symbol flags.  */
if|if
condition|(
operator|!
name|elf_fix_symbol_flags
argument_list|(
name|h
argument_list|,
name|eif
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* If this symbol does not require a PLT entry, and it is not      defined by a dynamic object, or is not referenced by a regular      object, ignore it.  We do have to handle a weak defined symbol,      even if no regular object refers to it, if we decided to add it      to the dynamic symbol table.  FIXME: Do we normally need to worry      about symbols which are defined by one dynamic object and      referenced by another one?  */
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_NEEDS_PLT
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|!=
literal|0
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|==
literal|0
operator|||
operator|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_REF_REGULAR
operator|)
operator|==
literal|0
operator|&&
operator|(
name|h
operator|->
name|weakdef
operator|==
name|NULL
operator|||
name|h
operator|->
name|weakdef
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
block|{
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* If we've already adjusted this symbol, don't do it again.  This      can happen via a recursive call.  */
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DYNAMIC_ADJUSTED
operator|)
operator|!=
literal|0
condition|)
return|return
name|true
return|;
comment|/* Don't look at this symbol again.  Note that we must set this      after checking the above conditions, because we may look at a      symbol once, decide not to do anything, and then get called      recursively later after REF_REGULAR is set below.  */
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_DYNAMIC_ADJUSTED
expr_stmt|;
comment|/* If this is a weak definition, and we know a real definition, and      the real symbol is not itself defined by a regular object file,      then get a good value for the real definition.  We handle the      real symbol first, for the convenience of the backend routine.       Note that there is a confusing case here.  If the real definition      is defined by a regular object file, we don't get the real symbol      from the dynamic object, but we do get the weak symbol.  If the      processor backend uses a COPY reloc, then if some routine in the      dynamic object changes the real symbol, we will not see that      change in the corresponding weak symbol.  This is the way other      ELF linkers work as well, and seems to be a result of the shared      library model.       I will clarify this issue.  Most SVR4 shared libraries define the      variable _timezone and define timezone as a weak synonym.  The      tzset call changes _timezone.  If you write        extern int timezone;        int _timezone = 5;        int main () { tzset (); printf ("%d %d\n", timezone, _timezone); }      you might expect that, since timezone is a synonym for _timezone,      the same number will print both times.  However, if the processor      backend uses a COPY reloc, then actually timezone will be copied      into your process image, and, since you define _timezone      yourself, _timezone will not.  Thus timezone and _timezone will      wind up at different memory locations.  The tzset call will set      _timezone, leaving timezone unchanged.  */
if|if
condition|(
name|h
operator|->
name|weakdef
operator|!=
name|NULL
condition|)
block|{
comment|/* If we get to this point, we know there is an implicit 	 reference by a regular object file via the weak symbol H. 	 FIXME: Is this really true?  What if the traversal finds 	 H->WEAKDEF before it finds H?  */
name|h
operator|->
name|weakdef
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_REF_REGULAR
expr_stmt|;
if|if
condition|(
operator|!
name|elf_adjust_dynamic_symbol
argument_list|(
name|h
operator|->
name|weakdef
argument_list|,
operator|(
name|PTR
operator|)
name|eif
argument_list|)
condition|)
return|return
name|false
return|;
block|}
comment|/* If a symbol has no type and no size and does not require a PLT      entry, then we are probably about to do the wrong thing here: we      are probably going to create a COPY reloc for an empty object.      This case can arise when a shared object is built with assembly      code, and the assembly code fails to set the symbol type.  */
if|if
condition|(
name|h
operator|->
name|size
operator|==
literal|0
operator|&&
name|h
operator|->
name|type
operator|==
name|STT_NOTYPE
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_NEEDS_PLT
operator|)
operator|==
literal|0
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"warning: type and size of dynamic symbol `%s' are not defined"
argument_list|)
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|eif
operator|->
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|dynobj
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|bed
operator|->
name|elf_backend_adjust_dynamic_symbol
call|)
argument_list|(
name|eif
operator|->
name|info
argument_list|,
name|h
argument_list|)
condition|)
block|{
name|eif
operator|->
name|failed
operator|=
name|true
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This routine is used to export all defined symbols into the dynamic    symbol table.  It is called via elf_link_hash_traverse.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf_export_symbol
parameter_list|(
name|h
parameter_list|,
name|data
parameter_list|)
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
name|struct
name|elf_info_failed
modifier|*
name|eif
init|=
operator|(
expr|struct
name|elf_info_failed
operator|*
operator|)
name|data
decl_stmt|;
comment|/* Ignore indirect symbols.  These are added by the versioning code.  */
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
condition|)
return|return
name|true
return|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
operator|(
name|ELF_LINK_HASH_DEF_REGULAR
operator||
name|ELF_LINK_HASH_REF_REGULAR
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|bfd_elf_version_tree
modifier|*
name|t
decl_stmt|;
name|struct
name|bfd_elf_version_expr
modifier|*
name|d
decl_stmt|;
for|for
control|(
name|t
operator|=
name|eif
operator|->
name|verdefs
init|;
name|t
operator|!=
name|NULL
condition|;
name|t
operator|=
name|t
operator|->
name|next
control|)
block|{
if|if
condition|(
name|t
operator|->
name|globals
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|d
operator|=
name|t
operator|->
name|globals
init|;
name|d
operator|!=
name|NULL
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
if|if
condition|(
call|(
modifier|*
name|d
operator|->
name|match
call|)
argument_list|(
name|d
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
condition|)
goto|goto
name|doit
goto|;
block|}
block|}
if|if
condition|(
name|t
operator|->
name|locals
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|d
operator|=
name|t
operator|->
name|locals
init|;
name|d
operator|!=
name|NULL
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
if|if
condition|(
call|(
modifier|*
name|d
operator|->
name|match
call|)
argument_list|(
name|d
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
condition|)
return|return
name|true
return|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|eif
operator|->
name|verdefs
condition|)
block|{
name|doit
label|:
if|if
condition|(
operator|!
name|_bfd_elf_link_record_dynamic_symbol
argument_list|(
name|eif
operator|->
name|info
argument_list|,
name|h
argument_list|)
condition|)
block|{
name|eif
operator|->
name|failed
operator|=
name|true
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Look through the symbols which are defined in other shared    libraries and referenced here.  Update the list of version    dependencies.  This will be put into the .gnu.version_r section.    This function is called via elf_link_hash_traverse.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf_link_find_version_dependencies
parameter_list|(
name|h
parameter_list|,
name|data
parameter_list|)
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
name|struct
name|elf_find_verdep_info
modifier|*
name|rinfo
init|=
operator|(
expr|struct
name|elf_find_verdep_info
operator|*
operator|)
name|data
decl_stmt|;
name|Elf_Internal_Verneed
modifier|*
name|t
decl_stmt|;
name|Elf_Internal_Vernaux
modifier|*
name|a
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
comment|/* We only care about symbols defined in shared objects with version      information.  */
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|==
literal|0
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|!=
literal|0
operator|||
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|||
name|h
operator|->
name|verinfo
operator|.
name|verdef
operator|==
name|NULL
condition|)
return|return
name|true
return|;
comment|/* See if we already know about this version.  */
for|for
control|(
name|t
operator|=
name|elf_tdata
argument_list|(
name|rinfo
operator|->
name|output_bfd
argument_list|)
operator|->
name|verref
init|;
name|t
operator|!=
name|NULL
condition|;
name|t
operator|=
name|t
operator|->
name|vn_nextref
control|)
block|{
if|if
condition|(
name|t
operator|->
name|vn_bfd
operator|!=
name|h
operator|->
name|verinfo
operator|.
name|verdef
operator|->
name|vd_bfd
condition|)
continue|continue;
for|for
control|(
name|a
operator|=
name|t
operator|->
name|vn_auxptr
init|;
name|a
operator|!=
name|NULL
condition|;
name|a
operator|=
name|a
operator|->
name|vna_nextptr
control|)
if|if
condition|(
name|a
operator|->
name|vna_nodename
operator|==
name|h
operator|->
name|verinfo
operator|.
name|verdef
operator|->
name|vd_nodename
condition|)
return|return
name|true
return|;
break|break;
block|}
comment|/* This is a new version.  Add it to tree we are building.  */
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
block|{
name|amt
operator|=
sizeof|sizeof
expr|*
name|t
expr_stmt|;
name|t
operator|=
operator|(
name|Elf_Internal_Verneed
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|rinfo
operator|->
name|output_bfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
block|{
name|rinfo
operator|->
name|failed
operator|=
name|true
expr_stmt|;
return|return
name|false
return|;
block|}
name|t
operator|->
name|vn_bfd
operator|=
name|h
operator|->
name|verinfo
operator|.
name|verdef
operator|->
name|vd_bfd
expr_stmt|;
name|t
operator|->
name|vn_nextref
operator|=
name|elf_tdata
argument_list|(
name|rinfo
operator|->
name|output_bfd
argument_list|)
operator|->
name|verref
expr_stmt|;
name|elf_tdata
argument_list|(
name|rinfo
operator|->
name|output_bfd
argument_list|)
operator|->
name|verref
operator|=
name|t
expr_stmt|;
block|}
name|amt
operator|=
sizeof|sizeof
expr|*
name|a
expr_stmt|;
name|a
operator|=
operator|(
name|Elf_Internal_Vernaux
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|rinfo
operator|->
name|output_bfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
comment|/* Note that we are copying a string pointer here, and testing it      above.  If bfd_elf_string_from_elf_section is ever changed to      discard the string data when low in memory, this will have to be      fixed.  */
name|a
operator|->
name|vna_nodename
operator|=
name|h
operator|->
name|verinfo
operator|.
name|verdef
operator|->
name|vd_nodename
expr_stmt|;
name|a
operator|->
name|vna_flags
operator|=
name|h
operator|->
name|verinfo
operator|.
name|verdef
operator|->
name|vd_flags
expr_stmt|;
name|a
operator|->
name|vna_nextptr
operator|=
name|t
operator|->
name|vn_auxptr
expr_stmt|;
name|h
operator|->
name|verinfo
operator|.
name|verdef
operator|->
name|vd_exp_refno
operator|=
name|rinfo
operator|->
name|vers
expr_stmt|;
operator|++
name|rinfo
operator|->
name|vers
expr_stmt|;
name|a
operator|->
name|vna_other
operator|=
name|h
operator|->
name|verinfo
operator|.
name|verdef
operator|->
name|vd_exp_refno
operator|+
literal|1
expr_stmt|;
name|t
operator|->
name|vn_auxptr
operator|=
name|a
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Figure out appropriate versions for all the symbols.  We may not    have the version number script until we have read all of the input    files, so until that point we don't know which symbols should be    local.  This function is called via elf_link_hash_traverse.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf_link_assign_sym_version
parameter_list|(
name|h
parameter_list|,
name|data
parameter_list|)
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
name|struct
name|elf_assign_sym_version_info
modifier|*
name|sinfo
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
name|struct
name|elf_info_failed
name|eif
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|sinfo
operator|=
operator|(
expr|struct
name|elf_assign_sym_version_info
operator|*
operator|)
name|data
expr_stmt|;
name|info
operator|=
name|sinfo
operator|->
name|info
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
comment|/* Fix the symbol flags.  */
name|eif
operator|.
name|failed
operator|=
name|false
expr_stmt|;
name|eif
operator|.
name|info
operator|=
name|info
expr_stmt|;
if|if
condition|(
operator|!
name|elf_fix_symbol_flags
argument_list|(
name|h
argument_list|,
operator|&
name|eif
argument_list|)
condition|)
block|{
if|if
condition|(
name|eif
operator|.
name|failed
condition|)
name|sinfo
operator|->
name|failed
operator|=
name|true
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* We only need version numbers for symbols defined in regular      objects.  */
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
condition|)
return|return
name|true
return|;
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|sinfo
operator|->
name|output_bfd
argument_list|)
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|ELF_VER_CHR
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|verinfo
operator|.
name|vertree
operator|==
name|NULL
condition|)
block|{
name|struct
name|bfd_elf_version_tree
modifier|*
name|t
decl_stmt|;
name|boolean
name|hidden
decl_stmt|;
name|hidden
operator|=
name|true
expr_stmt|;
comment|/* There are two consecutive ELF_VER_CHR characters if this is 	 not a hidden symbol.  */
operator|++
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
name|ELF_VER_CHR
condition|)
block|{
name|hidden
operator|=
name|false
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
comment|/* If there is no version string, we can just return out.  */
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|hidden
condition|)
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HIDDEN
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* Look for the version.  If we find it, it is no longer weak.  */
for|for
control|(
name|t
operator|=
name|sinfo
operator|->
name|verdefs
init|;
name|t
operator|!=
name|NULL
condition|;
name|t
operator|=
name|t
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|t
operator|->
name|name
argument_list|,
name|p
argument_list|)
operator|==
literal|0
condition|)
block|{
name|size_t
name|len
decl_stmt|;
name|char
modifier|*
name|alc
decl_stmt|;
name|struct
name|bfd_elf_version_expr
modifier|*
name|d
decl_stmt|;
name|len
operator|=
name|p
operator|-
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
name|alc
operator|=
name|bfd_malloc
argument_list|(
operator|(
name|bfd_size_type
operator|)
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|alc
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|strncpy
argument_list|(
name|alc
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|alc
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|alc
index|[
name|len
operator|-
literal|2
index|]
operator|==
name|ELF_VER_CHR
condition|)
name|alc
index|[
name|len
operator|-
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|h
operator|->
name|verinfo
operator|.
name|vertree
operator|=
name|t
expr_stmt|;
name|t
operator|->
name|used
operator|=
name|true
expr_stmt|;
name|d
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|globals
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|d
operator|=
name|t
operator|->
name|globals
init|;
name|d
operator|!=
name|NULL
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
if|if
condition|(
call|(
modifier|*
name|d
operator|->
name|match
call|)
argument_list|(
name|d
argument_list|,
name|alc
argument_list|)
condition|)
break|break;
block|}
comment|/* See if there is anything to force this symbol to 		 local scope.  */
if|if
condition|(
name|d
operator|==
name|NULL
operator|&&
name|t
operator|->
name|locals
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|d
operator|=
name|t
operator|->
name|locals
init|;
name|d
operator|!=
name|NULL
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
if|if
condition|(
call|(
modifier|*
name|d
operator|->
name|match
call|)
argument_list|(
name|d
argument_list|,
name|alc
argument_list|)
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|&&
name|info
operator|->
name|shared
operator|&&
operator|!
name|info
operator|->
name|export_dynamic
condition|)
block|{
call|(
modifier|*
name|bed
operator|->
name|elf_backend_hide_symbol
call|)
argument_list|(
name|info
argument_list|,
name|h
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
name|free
argument_list|(
name|alc
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* If we are building an application, we need to create a 	 version node for this version.  */
if|if
condition|(
name|t
operator|==
name|NULL
operator|&&
operator|!
name|info
operator|->
name|shared
condition|)
block|{
name|struct
name|bfd_elf_version_tree
modifier|*
modifier|*
name|pp
decl_stmt|;
name|int
name|version_index
decl_stmt|;
comment|/* If we aren't going to export this symbol, we don't need 	     to worry about it.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
return|return
name|true
return|;
name|amt
operator|=
sizeof|sizeof
expr|*
name|t
expr_stmt|;
name|t
operator|=
operator|(
operator|(
expr|struct
name|bfd_elf_version_tree
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|sinfo
operator|->
name|output_bfd
argument_list|,
name|amt
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
block|{
name|sinfo
operator|->
name|failed
operator|=
name|true
expr_stmt|;
return|return
name|false
return|;
block|}
name|t
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|t
operator|->
name|name
operator|=
name|p
expr_stmt|;
name|t
operator|->
name|globals
operator|=
name|NULL
expr_stmt|;
name|t
operator|->
name|locals
operator|=
name|NULL
expr_stmt|;
name|t
operator|->
name|deps
operator|=
name|NULL
expr_stmt|;
name|t
operator|->
name|name_indx
operator|=
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
expr_stmt|;
name|t
operator|->
name|used
operator|=
name|true
expr_stmt|;
name|version_index
operator|=
literal|1
expr_stmt|;
comment|/* Don't count anonymous version tag.  */
if|if
condition|(
name|sinfo
operator|->
name|verdefs
operator|!=
name|NULL
operator|&&
name|sinfo
operator|->
name|verdefs
operator|->
name|vernum
operator|==
literal|0
condition|)
name|version_index
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|pp
operator|=
operator|&
name|sinfo
operator|->
name|verdefs
init|;
operator|*
name|pp
operator|!=
name|NULL
condition|;
name|pp
operator|=
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|next
control|)
operator|++
name|version_index
expr_stmt|;
name|t
operator|->
name|vernum
operator|=
name|version_index
expr_stmt|;
operator|*
name|pp
operator|=
name|t
expr_stmt|;
name|h
operator|->
name|verinfo
operator|.
name|vertree
operator|=
name|t
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
block|{
comment|/* We could not find the version for a symbol when 	     generating a shared archive.  Return an error.  */
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: undefined versioned symbol name %s"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|sinfo
operator|->
name|output_bfd
argument_list|)
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
name|sinfo
operator|->
name|failed
operator|=
name|true
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|hidden
condition|)
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HIDDEN
expr_stmt|;
block|}
comment|/* If we don't have a version for this symbol, see if we can find      something.  */
if|if
condition|(
name|h
operator|->
name|verinfo
operator|.
name|vertree
operator|==
name|NULL
operator|&&
name|sinfo
operator|->
name|verdefs
operator|!=
name|NULL
condition|)
block|{
name|struct
name|bfd_elf_version_tree
modifier|*
name|t
decl_stmt|;
name|struct
name|bfd_elf_version_tree
modifier|*
name|deflt
decl_stmt|;
name|struct
name|bfd_elf_version_expr
modifier|*
name|d
decl_stmt|;
comment|/* See if can find what version this symbol is in.  If the 	 symbol is supposed to be local, then don't actually register 	 it.  */
name|deflt
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|t
operator|=
name|sinfo
operator|->
name|verdefs
init|;
name|t
operator|!=
name|NULL
condition|;
name|t
operator|=
name|t
operator|->
name|next
control|)
block|{
if|if
condition|(
name|t
operator|->
name|globals
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|d
operator|=
name|t
operator|->
name|globals
init|;
name|d
operator|!=
name|NULL
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
if|if
condition|(
call|(
modifier|*
name|d
operator|->
name|match
call|)
argument_list|(
name|d
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
condition|)
block|{
name|h
operator|->
name|verinfo
operator|.
name|vertree
operator|=
name|t
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|d
operator|!=
name|NULL
condition|)
break|break;
block|}
if|if
condition|(
name|t
operator|->
name|locals
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|d
operator|=
name|t
operator|->
name|locals
init|;
name|d
operator|!=
name|NULL
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
if|if
condition|(
name|d
operator|->
name|pattern
index|[
literal|0
index|]
operator|==
literal|'*'
operator|&&
name|d
operator|->
name|pattern
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|deflt
operator|=
name|t
expr_stmt|;
elseif|else
if|if
condition|(
call|(
modifier|*
name|d
operator|->
name|match
call|)
argument_list|(
name|d
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
condition|)
block|{
name|h
operator|->
name|verinfo
operator|.
name|vertree
operator|=
name|t
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|&&
name|info
operator|->
name|shared
operator|&&
operator|!
name|info
operator|->
name|export_dynamic
condition|)
block|{
call|(
modifier|*
name|bed
operator|->
name|elf_backend_hide_symbol
call|)
argument_list|(
name|info
argument_list|,
name|h
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|d
operator|!=
name|NULL
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|deflt
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|verinfo
operator|.
name|vertree
operator|==
name|NULL
condition|)
block|{
name|h
operator|->
name|verinfo
operator|.
name|vertree
operator|=
name|deflt
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|&&
name|info
operator|->
name|shared
operator|&&
operator|!
name|info
operator|->
name|export_dynamic
condition|)
block|{
call|(
modifier|*
name|bed
operator|->
name|elf_backend_hide_symbol
call|)
argument_list|(
name|info
argument_list|,
name|h
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Final phase of ELF linker.  */
end_comment

begin_comment
comment|/* A structure we use to avoid passing large numbers of arguments.  */
end_comment

begin_struct
struct|struct
name|elf_final_link_info
block|{
comment|/* General link information.  */
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
comment|/* Output BFD.  */
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
comment|/* Symbol string table.  */
name|struct
name|bfd_strtab_hash
modifier|*
name|symstrtab
decl_stmt|;
comment|/* .dynsym section.  */
name|asection
modifier|*
name|dynsym_sec
decl_stmt|;
comment|/* .hash section.  */
name|asection
modifier|*
name|hash_sec
decl_stmt|;
comment|/* symbol version section (.gnu.version).  */
name|asection
modifier|*
name|symver_sec
decl_stmt|;
comment|/* Buffer large enough to hold contents of any section.  */
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
comment|/* Buffer large enough to hold external relocs of any section.  */
name|PTR
name|external_relocs
decl_stmt|;
comment|/* Buffer large enough to hold internal relocs of any section.  */
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|;
comment|/* Buffer large enough to hold external local symbols of any input      BFD.  */
name|Elf_External_Sym
modifier|*
name|external_syms
decl_stmt|;
comment|/* And a buffer for symbol section indices.  */
name|Elf_External_Sym_Shndx
modifier|*
name|locsym_shndx
decl_stmt|;
comment|/* Buffer large enough to hold internal local symbols of any input      BFD.  */
name|Elf_Internal_Sym
modifier|*
name|internal_syms
decl_stmt|;
comment|/* Array large enough to hold a symbol index for each local symbol      of any input BFD.  */
name|long
modifier|*
name|indices
decl_stmt|;
comment|/* Array large enough to hold a section pointer for each local      symbol of any input BFD.  */
name|asection
modifier|*
modifier|*
name|sections
decl_stmt|;
comment|/* Buffer to hold swapped out symbols.  */
name|Elf_External_Sym
modifier|*
name|symbuf
decl_stmt|;
comment|/* And one for symbol section indices.  */
name|Elf_External_Sym_Shndx
modifier|*
name|symshndxbuf
decl_stmt|;
comment|/* Number of swapped out symbols in buffer.  */
name|size_t
name|symbuf_count
decl_stmt|;
comment|/* Number of symbols which fit in symbuf.  */
name|size_t
name|symbuf_size
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|boolean
name|elf_link_output_sym
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_final_link_info
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf_link_flush_output_syms
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_final_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf_link_output_extsym
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf_link_sec_merge_syms
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf_link_input_bfd
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_final_link_info
operator|*
operator|,
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf_reloc_link_order
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|asection
operator|*
operator|,
expr|struct
name|bfd_link_order
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This struct is used to pass information to elf_link_output_extsym.  */
end_comment

begin_struct
struct|struct
name|elf_outext_info
block|{
name|boolean
name|failed
decl_stmt|;
name|boolean
name|localsyms
decl_stmt|;
name|struct
name|elf_final_link_info
modifier|*
name|finfo
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Compute the size of, and allocate space for, REL_HDR which is the    section header for a section containing relocations for O.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf_link_size_reloc_section
parameter_list|(
name|abfd
parameter_list|,
name|rel_hdr
parameter_list|,
name|o
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|rel_hdr
decl_stmt|;
name|asection
modifier|*
name|o
decl_stmt|;
block|{
name|bfd_size_type
name|reloc_count
decl_stmt|;
name|bfd_size_type
name|num_rel_hashes
decl_stmt|;
comment|/* Figure out how many relocations there will be.  */
if|if
condition|(
name|rel_hdr
operator|==
operator|&
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_hdr
condition|)
name|reloc_count
operator|=
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_count
expr_stmt|;
else|else
name|reloc_count
operator|=
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_count2
expr_stmt|;
name|num_rel_hashes
operator|=
name|o
operator|->
name|reloc_count
expr_stmt|;
if|if
condition|(
name|num_rel_hashes
operator|<
name|reloc_count
condition|)
name|num_rel_hashes
operator|=
name|reloc_count
expr_stmt|;
comment|/* That allows us to calculate the size of the section.  */
name|rel_hdr
operator|->
name|sh_size
operator|=
name|rel_hdr
operator|->
name|sh_entsize
operator|*
name|reloc_count
expr_stmt|;
comment|/* The contents field must last into write_object_contents, so we      allocate it with bfd_alloc rather than malloc.  Also since we      cannot be sure that the contents will actually be filled in,      we zero the allocated space.  */
name|rel_hdr
operator|->
name|contents
operator|=
operator|(
name|PTR
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|rel_hdr
operator|->
name|sh_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|rel_hdr
operator|->
name|contents
operator|==
name|NULL
operator|&&
name|rel_hdr
operator|->
name|sh_size
operator|!=
literal|0
condition|)
return|return
name|false
return|;
comment|/* We only allocate one set of hash entries, so we only do it the      first time we are called.  */
if|if
condition|(
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_hashes
operator|==
name|NULL
operator|&&
name|num_rel_hashes
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|*
operator|)
name|bfd_zmalloc
argument_list|(
name|num_rel_hashes
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|elf_link_hash_entry
operator|*
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_hashes
operator|=
name|p
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* When performing a relocateable link, the input relocations are    preserved.  But, if they reference global symbols, the indices    referenced must be updated.  Update all the relocations in    REL_HDR (there are COUNT of them), using the data in REL_HASH.  */
end_comment

begin_function
specifier|static
name|void
name|elf_link_adjust_relocs
parameter_list|(
name|abfd
parameter_list|,
name|rel_hdr
parameter_list|,
name|count
parameter_list|,
name|rel_hash
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|rel_hdr
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|rel_hash
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|Elf_Internal_Rel
modifier|*
name|irel
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irela
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
name|Elf_Internal_Rel
argument_list|)
operator|*
name|bed
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
decl_stmt|;
name|irel
operator|=
operator|(
name|Elf_Internal_Rel
operator|*
operator|)
name|bfd_zmalloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|irel
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Error: out of memory"
argument_list|)
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|amt
operator|=
sizeof|sizeof
argument_list|(
name|Elf_Internal_Rela
argument_list|)
operator|*
name|bed
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
expr_stmt|;
name|irela
operator|=
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
name|bfd_zmalloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|irela
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Error: out of memory"
argument_list|)
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|rel_hash
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|rel_hash
operator|==
name|NULL
condition|)
continue|continue;
name|BFD_ASSERT
argument_list|(
operator|(
operator|*
name|rel_hash
operator|)
operator|->
name|indx
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rel_hdr
operator|->
name|sh_entsize
operator|==
sizeof|sizeof
argument_list|(
name|Elf_External_Rel
argument_list|)
condition|)
block|{
name|Elf_External_Rel
modifier|*
name|erel
decl_stmt|;
name|unsigned
name|int
name|j
decl_stmt|;
name|erel
operator|=
operator|(
name|Elf_External_Rel
operator|*
operator|)
name|rel_hdr
operator|->
name|contents
operator|+
name|i
expr_stmt|;
if|if
condition|(
name|bed
operator|->
name|s
operator|->
name|swap_reloc_in
condition|)
call|(
modifier|*
name|bed
operator|->
name|s
operator|->
name|swap_reloc_in
call|)
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|erel
argument_list|,
name|irel
argument_list|)
expr_stmt|;
else|else
name|elf_swap_reloc_in
argument_list|(
name|abfd
argument_list|,
name|erel
argument_list|,
name|irel
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|bed
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
condition|;
name|j
operator|++
control|)
name|irel
index|[
name|j
index|]
operator|.
name|r_info
operator|=
name|ELF_R_INFO
argument_list|(
operator|(
operator|*
name|rel_hash
operator|)
operator|->
name|indx
argument_list|,
name|ELF_R_TYPE
argument_list|(
name|irel
index|[
name|j
index|]
operator|.
name|r_info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bed
operator|->
name|s
operator|->
name|swap_reloc_out
condition|)
call|(
modifier|*
name|bed
operator|->
name|s
operator|->
name|swap_reloc_out
call|)
argument_list|(
name|abfd
argument_list|,
name|irel
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|erel
argument_list|)
expr_stmt|;
else|else
name|elf_swap_reloc_out
argument_list|(
name|abfd
argument_list|,
name|irel
argument_list|,
name|erel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Elf_External_Rela
modifier|*
name|erela
decl_stmt|;
name|unsigned
name|int
name|j
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|rel_hdr
operator|->
name|sh_entsize
operator|==
sizeof|sizeof
argument_list|(
name|Elf_External_Rela
argument_list|)
argument_list|)
expr_stmt|;
name|erela
operator|=
operator|(
name|Elf_External_Rela
operator|*
operator|)
name|rel_hdr
operator|->
name|contents
operator|+
name|i
expr_stmt|;
if|if
condition|(
name|bed
operator|->
name|s
operator|->
name|swap_reloca_in
condition|)
call|(
modifier|*
name|bed
operator|->
name|s
operator|->
name|swap_reloca_in
call|)
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|erela
argument_list|,
name|irela
argument_list|)
expr_stmt|;
else|else
name|elf_swap_reloca_in
argument_list|(
name|abfd
argument_list|,
name|erela
argument_list|,
name|irela
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|bed
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
condition|;
name|j
operator|++
control|)
name|irela
index|[
name|j
index|]
operator|.
name|r_info
operator|=
name|ELF_R_INFO
argument_list|(
operator|(
operator|*
name|rel_hash
operator|)
operator|->
name|indx
argument_list|,
name|ELF_R_TYPE
argument_list|(
name|irela
index|[
name|j
index|]
operator|.
name|r_info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bed
operator|->
name|s
operator|->
name|swap_reloca_out
condition|)
call|(
modifier|*
name|bed
operator|->
name|s
operator|->
name|swap_reloca_out
call|)
argument_list|(
name|abfd
argument_list|,
name|irela
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|erela
argument_list|)
expr_stmt|;
else|else
name|elf_swap_reloca_out
argument_list|(
name|abfd
argument_list|,
name|irela
argument_list|,
name|erela
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|irel
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|irela
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|elf_link_sort_rela
block|{
name|bfd_vma
name|offset
decl_stmt|;
name|enum
name|elf_reloc_type_class
name|type
decl_stmt|;
union|union
block|{
name|Elf_Internal_Rel
name|rel
decl_stmt|;
name|Elf_Internal_Rela
name|rela
decl_stmt|;
block|}
name|u
union|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|elf_link_sort_cmp1
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
specifier|const
name|PTR
name|A
decl_stmt|;
specifier|const
name|PTR
name|B
decl_stmt|;
block|{
name|struct
name|elf_link_sort_rela
modifier|*
name|a
init|=
operator|(
expr|struct
name|elf_link_sort_rela
operator|*
operator|)
name|A
decl_stmt|;
name|struct
name|elf_link_sort_rela
modifier|*
name|b
init|=
operator|(
expr|struct
name|elf_link_sort_rela
operator|*
operator|)
name|B
decl_stmt|;
name|int
name|relativea
decl_stmt|,
name|relativeb
decl_stmt|;
name|relativea
operator|=
name|a
operator|->
name|type
operator|==
name|reloc_class_relative
expr_stmt|;
name|relativeb
operator|=
name|b
operator|->
name|type
operator|==
name|reloc_class_relative
expr_stmt|;
if|if
condition|(
name|relativea
operator|<
name|relativeb
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|relativea
operator|>
name|relativeb
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|ELF_R_SYM
argument_list|(
name|a
operator|->
name|u
operator|.
name|rel
operator|.
name|r_info
argument_list|)
operator|<
name|ELF_R_SYM
argument_list|(
name|b
operator|->
name|u
operator|.
name|rel
operator|.
name|r_info
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|ELF_R_SYM
argument_list|(
name|a
operator|->
name|u
operator|.
name|rel
operator|.
name|r_info
argument_list|)
operator|>
name|ELF_R_SYM
argument_list|(
name|b
operator|->
name|u
operator|.
name|rel
operator|.
name|r_info
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|a
operator|->
name|u
operator|.
name|rel
operator|.
name|r_offset
operator|<
name|b
operator|->
name|u
operator|.
name|rel
operator|.
name|r_offset
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|a
operator|->
name|u
operator|.
name|rel
operator|.
name|r_offset
operator|>
name|b
operator|->
name|u
operator|.
name|rel
operator|.
name|r_offset
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|elf_link_sort_cmp2
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
specifier|const
name|PTR
name|A
decl_stmt|;
specifier|const
name|PTR
name|B
decl_stmt|;
block|{
name|struct
name|elf_link_sort_rela
modifier|*
name|a
init|=
operator|(
expr|struct
name|elf_link_sort_rela
operator|*
operator|)
name|A
decl_stmt|;
name|struct
name|elf_link_sort_rela
modifier|*
name|b
init|=
operator|(
expr|struct
name|elf_link_sort_rela
operator|*
operator|)
name|B
decl_stmt|;
name|int
name|copya
decl_stmt|,
name|copyb
decl_stmt|;
if|if
condition|(
name|a
operator|->
name|offset
operator|<
name|b
operator|->
name|offset
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|a
operator|->
name|offset
operator|>
name|b
operator|->
name|offset
condition|)
return|return
literal|1
return|;
name|copya
operator|=
operator|(
name|a
operator|->
name|type
operator|==
name|reloc_class_copy
operator|)
operator|*
literal|2
operator|+
operator|(
name|a
operator|->
name|type
operator|==
name|reloc_class_plt
operator|)
expr_stmt|;
name|copyb
operator|=
operator|(
name|b
operator|->
name|type
operator|==
name|reloc_class_copy
operator|)
operator|*
literal|2
operator|+
operator|(
name|b
operator|->
name|type
operator|==
name|reloc_class_plt
operator|)
expr_stmt|;
if|if
condition|(
name|copya
operator|<
name|copyb
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|copya
operator|>
name|copyb
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|a
operator|->
name|u
operator|.
name|rel
operator|.
name|r_offset
operator|<
name|b
operator|->
name|u
operator|.
name|rel
operator|.
name|r_offset
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|a
operator|->
name|u
operator|.
name|rel
operator|.
name|r_offset
operator|>
name|b
operator|->
name|u
operator|.
name|rel
operator|.
name|r_offset
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|elf_link_sort_relocs
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|psec
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|asection
modifier|*
modifier|*
name|psec
decl_stmt|;
block|{
name|bfd
modifier|*
name|dynobj
init|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|reldyn
decl_stmt|,
modifier|*
name|o
decl_stmt|;
name|boolean
name|rel
init|=
name|false
decl_stmt|;
name|bfd_size_type
name|count
decl_stmt|,
name|size
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|j
decl_stmt|,
name|ret
decl_stmt|;
name|struct
name|elf_link_sort_rela
modifier|*
name|rela
decl_stmt|;
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|reldyn
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".rela.dyn"
argument_list|)
expr_stmt|;
if|if
condition|(
name|reldyn
operator|==
name|NULL
operator|||
name|reldyn
operator|->
name|_raw_size
operator|==
literal|0
condition|)
block|{
name|reldyn
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".rel.dyn"
argument_list|)
expr_stmt|;
if|if
condition|(
name|reldyn
operator|==
name|NULL
operator|||
name|reldyn
operator|->
name|_raw_size
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|rel
operator|=
name|true
expr_stmt|;
name|count
operator|=
name|reldyn
operator|->
name|_raw_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf_External_Rel
argument_list|)
expr_stmt|;
block|}
else|else
name|count
operator|=
name|reldyn
operator|->
name|_raw_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf_External_Rela
argument_list|)
expr_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|o
operator|=
name|dynobj
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_LINKER_CREATED
operator|)
operator|)
operator|==
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_LINKER_CREATED
operator|)
operator|&&
name|o
operator|->
name|output_section
operator|==
name|reldyn
condition|)
name|size
operator|+=
name|o
operator|->
name|_raw_size
expr_stmt|;
if|if
condition|(
name|size
operator|!=
name|reldyn
operator|->
name|_raw_size
condition|)
return|return
literal|0
return|;
name|rela
operator|=
operator|(
expr|struct
name|elf_link_sort_rela
operator|*
operator|)
name|bfd_zmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|rela
argument_list|)
operator|*
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|rela
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|warning
call|)
argument_list|(
name|info
argument_list|,
name|_
argument_list|(
literal|"Not enough memory to sort relocations"
argument_list|)
argument_list|,
literal|0
argument_list|,
name|abfd
argument_list|,
literal|0
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|o
operator|=
name|dynobj
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_LINKER_CREATED
operator|)
operator|)
operator|==
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_LINKER_CREATED
operator|)
operator|&&
name|o
operator|->
name|output_section
operator|==
name|reldyn
condition|)
block|{
if|if
condition|(
name|rel
condition|)
block|{
name|Elf_External_Rel
modifier|*
name|erel
decl_stmt|,
modifier|*
name|erelend
decl_stmt|;
name|struct
name|elf_link_sort_rela
modifier|*
name|s
decl_stmt|;
name|erel
operator|=
operator|(
name|Elf_External_Rel
operator|*
operator|)
name|o
operator|->
name|contents
expr_stmt|;
name|erelend
operator|=
operator|(
name|Elf_External_Rel
operator|*
operator|)
operator|(
name|o
operator|->
name|contents
operator|+
name|o
operator|->
name|_raw_size
operator|)
expr_stmt|;
name|s
operator|=
name|rela
operator|+
name|o
operator|->
name|output_offset
operator|/
sizeof|sizeof
argument_list|(
name|Elf_External_Rel
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|erel
operator|<
name|erelend
condition|;
name|erel
operator|++
operator|,
name|s
operator|++
control|)
block|{
if|if
condition|(
name|bed
operator|->
name|s
operator|->
name|swap_reloc_in
condition|)
call|(
modifier|*
name|bed
operator|->
name|s
operator|->
name|swap_reloc_in
call|)
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|erel
argument_list|,
operator|&
name|s
operator|->
name|u
operator|.
name|rel
argument_list|)
expr_stmt|;
else|else
name|elf_swap_reloc_in
argument_list|(
name|abfd
argument_list|,
name|erel
argument_list|,
operator|&
name|s
operator|->
name|u
operator|.
name|rel
argument_list|)
expr_stmt|;
name|s
operator|->
name|type
operator|=
call|(
modifier|*
name|bed
operator|->
name|elf_backend_reloc_type_class
call|)
argument_list|(
operator|&
name|s
operator|->
name|u
operator|.
name|rela
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|Elf_External_Rela
modifier|*
name|erela
decl_stmt|,
modifier|*
name|erelaend
decl_stmt|;
name|struct
name|elf_link_sort_rela
modifier|*
name|s
decl_stmt|;
name|erela
operator|=
operator|(
name|Elf_External_Rela
operator|*
operator|)
name|o
operator|->
name|contents
expr_stmt|;
name|erelaend
operator|=
operator|(
name|Elf_External_Rela
operator|*
operator|)
operator|(
name|o
operator|->
name|contents
operator|+
name|o
operator|->
name|_raw_size
operator|)
expr_stmt|;
name|s
operator|=
name|rela
operator|+
name|o
operator|->
name|output_offset
operator|/
sizeof|sizeof
argument_list|(
name|Elf_External_Rela
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|erela
operator|<
name|erelaend
condition|;
name|erela
operator|++
operator|,
name|s
operator|++
control|)
block|{
if|if
condition|(
name|bed
operator|->
name|s
operator|->
name|swap_reloca_in
condition|)
call|(
modifier|*
name|bed
operator|->
name|s
operator|->
name|swap_reloca_in
call|)
argument_list|(
name|dynobj
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|erela
argument_list|,
operator|&
name|s
operator|->
name|u
operator|.
name|rela
argument_list|)
expr_stmt|;
else|else
name|elf_swap_reloca_in
argument_list|(
name|dynobj
argument_list|,
name|erela
argument_list|,
operator|&
name|s
operator|->
name|u
operator|.
name|rela
argument_list|)
expr_stmt|;
name|s
operator|->
name|type
operator|=
call|(
modifier|*
name|bed
operator|->
name|elf_backend_reloc_type_class
call|)
argument_list|(
operator|&
name|s
operator|->
name|u
operator|.
name|rela
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|qsort
argument_list|(
name|rela
argument_list|,
operator|(
name|size_t
operator|)
name|count
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rela
argument_list|)
argument_list|,
name|elf_link_sort_cmp1
argument_list|)
expr_stmt|;
for|for
control|(
name|ret
operator|=
literal|0
init|;
name|ret
operator|<
name|count
operator|&&
name|rela
index|[
name|ret
index|]
operator|.
name|type
operator|==
name|reloc_class_relative
condition|;
name|ret
operator|++
control|)
empty_stmt|;
for|for
control|(
name|i
operator|=
name|ret
operator|,
name|j
operator|=
name|ret
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ELF_R_SYM
argument_list|(
name|rela
index|[
name|i
index|]
operator|.
name|u
operator|.
name|rel
operator|.
name|r_info
argument_list|)
operator|!=
name|ELF_R_SYM
argument_list|(
name|rela
index|[
name|j
index|]
operator|.
name|u
operator|.
name|rel
operator|.
name|r_info
argument_list|)
condition|)
name|j
operator|=
name|i
expr_stmt|;
name|rela
index|[
name|i
index|]
operator|.
name|offset
operator|=
name|rela
index|[
name|j
index|]
operator|.
name|u
operator|.
name|rel
operator|.
name|r_offset
expr_stmt|;
block|}
name|qsort
argument_list|(
name|rela
operator|+
name|ret
argument_list|,
operator|(
name|size_t
operator|)
name|count
operator|-
name|ret
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rela
argument_list|)
argument_list|,
name|elf_link_sort_cmp2
argument_list|)
expr_stmt|;
for|for
control|(
name|o
operator|=
name|dynobj
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_LINKER_CREATED
operator|)
operator|)
operator|==
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_LINKER_CREATED
operator|)
operator|&&
name|o
operator|->
name|output_section
operator|==
name|reldyn
condition|)
block|{
if|if
condition|(
name|rel
condition|)
block|{
name|Elf_External_Rel
modifier|*
name|erel
decl_stmt|,
modifier|*
name|erelend
decl_stmt|;
name|struct
name|elf_link_sort_rela
modifier|*
name|s
decl_stmt|;
name|erel
operator|=
operator|(
name|Elf_External_Rel
operator|*
operator|)
name|o
operator|->
name|contents
expr_stmt|;
name|erelend
operator|=
operator|(
name|Elf_External_Rel
operator|*
operator|)
operator|(
name|o
operator|->
name|contents
operator|+
name|o
operator|->
name|_raw_size
operator|)
expr_stmt|;
name|s
operator|=
name|rela
operator|+
name|o
operator|->
name|output_offset
operator|/
sizeof|sizeof
argument_list|(
name|Elf_External_Rel
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|erel
operator|<
name|erelend
condition|;
name|erel
operator|++
operator|,
name|s
operator|++
control|)
block|{
if|if
condition|(
name|bed
operator|->
name|s
operator|->
name|swap_reloc_out
condition|)
call|(
modifier|*
name|bed
operator|->
name|s
operator|->
name|swap_reloc_out
call|)
argument_list|(
name|abfd
argument_list|,
operator|&
name|s
operator|->
name|u
operator|.
name|rel
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|erel
argument_list|)
expr_stmt|;
else|else
name|elf_swap_reloc_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|s
operator|->
name|u
operator|.
name|rel
argument_list|,
name|erel
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|Elf_External_Rela
modifier|*
name|erela
decl_stmt|,
modifier|*
name|erelaend
decl_stmt|;
name|struct
name|elf_link_sort_rela
modifier|*
name|s
decl_stmt|;
name|erela
operator|=
operator|(
name|Elf_External_Rela
operator|*
operator|)
name|o
operator|->
name|contents
expr_stmt|;
name|erelaend
operator|=
operator|(
name|Elf_External_Rela
operator|*
operator|)
operator|(
name|o
operator|->
name|contents
operator|+
name|o
operator|->
name|_raw_size
operator|)
expr_stmt|;
name|s
operator|=
name|rela
operator|+
name|o
operator|->
name|output_offset
operator|/
sizeof|sizeof
argument_list|(
name|Elf_External_Rela
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|erela
operator|<
name|erelaend
condition|;
name|erela
operator|++
operator|,
name|s
operator|++
control|)
block|{
if|if
condition|(
name|bed
operator|->
name|s
operator|->
name|swap_reloca_out
condition|)
call|(
modifier|*
name|bed
operator|->
name|s
operator|->
name|swap_reloca_out
call|)
argument_list|(
name|dynobj
argument_list|,
operator|&
name|s
operator|->
name|u
operator|.
name|rela
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|erela
argument_list|)
expr_stmt|;
else|else
name|elf_swap_reloca_out
argument_list|(
name|dynobj
argument_list|,
operator|&
name|s
operator|->
name|u
operator|.
name|rela
argument_list|,
name|erela
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|free
argument_list|(
name|rela
argument_list|)
expr_stmt|;
operator|*
name|psec
operator|=
name|reldyn
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Do the final step of an ELF link.  */
end_comment

begin_function
name|boolean
name|elf_bfd_final_link
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|boolean
name|dynamic
decl_stmt|;
name|boolean
name|emit_relocs
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|struct
name|elf_final_link_info
name|finfo
decl_stmt|;
specifier|register
name|asection
modifier|*
name|o
decl_stmt|;
specifier|register
name|struct
name|bfd_link_order
modifier|*
name|p
decl_stmt|;
specifier|register
name|bfd
modifier|*
name|sub
decl_stmt|;
name|bfd_size_type
name|max_contents_size
decl_stmt|;
name|bfd_size_type
name|max_external_reloc_size
decl_stmt|;
name|bfd_size_type
name|max_internal_reloc_count
decl_stmt|;
name|bfd_size_type
name|max_sym_count
decl_stmt|;
name|bfd_size_type
name|max_sym_shndx_count
decl_stmt|;
name|file_ptr
name|off
decl_stmt|;
name|Elf_Internal_Sym
name|elfsym
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symstrtab_hdr
decl_stmt|;
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|struct
name|elf_outext_info
name|eoinfo
decl_stmt|;
name|boolean
name|merged
decl_stmt|;
name|size_t
name|relativecount
init|=
literal|0
decl_stmt|;
name|asection
modifier|*
name|reldyn
init|=
literal|0
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
if|if
condition|(
operator|!
name|is_elf_hash_table
argument_list|(
name|info
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
name|abfd
operator|->
name|flags
operator||=
name|DYNAMIC
expr_stmt|;
name|dynamic
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
expr_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|emit_relocs
operator|=
operator|(
name|info
operator|->
name|relocateable
operator|||
name|info
operator|->
name|emitrelocations
operator|||
name|bed
operator|->
name|elf_backend_emit_relocs
operator|)
expr_stmt|;
name|finfo
operator|.
name|info
operator|=
name|info
expr_stmt|;
name|finfo
operator|.
name|output_bfd
operator|=
name|abfd
expr_stmt|;
name|finfo
operator|.
name|symstrtab
operator|=
name|elf_stringtab_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|symstrtab
operator|==
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|dynamic
condition|)
block|{
name|finfo
operator|.
name|dynsym_sec
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|hash_sec
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|symver_sec
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|finfo
operator|.
name|dynsym_sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynsym"
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|hash_sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".hash"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|finfo
operator|.
name|dynsym_sec
operator|!=
name|NULL
operator|&&
name|finfo
operator|.
name|hash_sec
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|symver_sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".gnu.version"
argument_list|)
expr_stmt|;
comment|/* Note that it is OK if symver_sec is NULL.  */
block|}
name|finfo
operator|.
name|contents
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|external_relocs
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|internal_relocs
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|external_syms
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|locsym_shndx
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|internal_syms
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|indices
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|sections
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|symbuf
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|symshndxbuf
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|symbuf_count
operator|=
literal|0
expr_stmt|;
comment|/* Count up the number of relocations we will output for each output      section, so that we know the sizes of the reloc sections.  We      also figure out some maximum sizes.  */
name|max_contents_size
operator|=
literal|0
expr_stmt|;
name|max_external_reloc_size
operator|=
literal|0
expr_stmt|;
name|max_internal_reloc_count
operator|=
literal|0
expr_stmt|;
name|max_sym_count
operator|=
literal|0
expr_stmt|;
name|max_sym_shndx_count
operator|=
literal|0
expr_stmt|;
name|merged
operator|=
name|false
expr_stmt|;
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
name|o
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|o
operator|->
name|link_order_head
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_section_reloc_link_order
operator|||
name|p
operator|->
name|type
operator|==
name|bfd_symbol_reloc_link_order
condition|)
operator|++
name|o
operator|->
name|reloc_count
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_indirect_link_order
condition|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|sec
operator|=
name|p
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
expr_stmt|;
comment|/* Mark all sections which are to be included in the 		 link.  This will normally be every section.  We need 		 to do this so that we can identify any sections which 		 the linker has decided to not include.  */
name|sec
operator|->
name|linker_mark
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|flags
operator|&
name|SEC_MERGE
condition|)
name|merged
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|relocateable
operator|||
name|info
operator|->
name|emitrelocations
condition|)
name|o
operator|->
name|reloc_count
operator|+=
name|sec
operator|->
name|reloc_count
expr_stmt|;
elseif|else
if|if
condition|(
name|bed
operator|->
name|elf_backend_count_relocs
condition|)
block|{
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|;
name|relocs
operator|=
operator|(
name|NAME
argument_list|(
name|_bfd_elf
argument_list|,
name|link_read_relocs
argument_list|)
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
operator|(
name|PTR
operator|)
name|NULL
argument_list|,
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
name|NULL
argument_list|,
name|info
operator|->
name|keep_memory
argument_list|)
operator|)
expr_stmt|;
name|o
operator|->
name|reloc_count
operator|+=
call|(
modifier|*
name|bed
operator|->
name|elf_backend_count_relocs
call|)
argument_list|(
name|sec
argument_list|,
name|relocs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|relocs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sec
operator|->
name|_raw_size
operator|>
name|max_contents_size
condition|)
name|max_contents_size
operator|=
name|sec
operator|->
name|_raw_size
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|_cooked_size
operator|>
name|max_contents_size
condition|)
name|max_contents_size
operator|=
name|sec
operator|->
name|_cooked_size
expr_stmt|;
comment|/* We are interested in just local symbols, not all 		 symbols.  */
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|sec
operator|->
name|owner
argument_list|)
operator|==
name|bfd_target_elf_flavour
operator|&&
operator|(
name|sec
operator|->
name|owner
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|==
literal|0
condition|)
block|{
name|size_t
name|sym_count
decl_stmt|;
if|if
condition|(
name|elf_bad_symtab
argument_list|(
name|sec
operator|->
name|owner
argument_list|)
condition|)
name|sym_count
operator|=
operator|(
name|elf_tdata
argument_list|(
name|sec
operator|->
name|owner
argument_list|)
operator|->
name|symtab_hdr
operator|.
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
operator|)
expr_stmt|;
else|else
name|sym_count
operator|=
name|elf_tdata
argument_list|(
name|sec
operator|->
name|owner
argument_list|)
operator|->
name|symtab_hdr
operator|.
name|sh_info
expr_stmt|;
if|if
condition|(
name|sym_count
operator|>
name|max_sym_count
condition|)
name|max_sym_count
operator|=
name|sym_count
expr_stmt|;
if|if
condition|(
name|sym_count
operator|>
name|max_sym_shndx_count
operator|&&
name|elf_symtab_shndx
argument_list|(
name|sec
operator|->
name|owner
argument_list|)
operator|!=
literal|0
condition|)
name|max_sym_shndx_count
operator|=
name|sym_count
expr_stmt|;
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|!=
literal|0
condition|)
block|{
name|size_t
name|ext_size
decl_stmt|;
name|ext_size
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|rel_hdr
operator|.
name|sh_size
expr_stmt|;
if|if
condition|(
name|ext_size
operator|>
name|max_external_reloc_size
condition|)
name|max_external_reloc_size
operator|=
name|ext_size
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|reloc_count
operator|>
name|max_internal_reloc_count
condition|)
name|max_internal_reloc_count
operator|=
name|sec
operator|->
name|reloc_count
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|o
operator|->
name|reloc_count
operator|>
literal|0
condition|)
name|o
operator|->
name|flags
operator||=
name|SEC_RELOC
expr_stmt|;
else|else
block|{
comment|/* Explicitly clear the SEC_RELOC flag.  The linker tends to 	     set it (this is probably a bug) and if it is set 	     assign_section_numbers will create a reloc section.  */
name|o
operator|->
name|flags
operator|&=
operator|~
name|SEC_RELOC
expr_stmt|;
block|}
comment|/* If the SEC_ALLOC flag is not set, force the section VMA to 	 zero.  This is done in elf_fake_sections as well, but forcing 	 the VMA to 0 here will ensure that relocs against these 	 sections are handled correctly.  */
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|==
literal|0
operator|&&
operator|!
name|o
operator|->
name|user_set_vma
condition|)
name|o
operator|->
name|vma
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|info
operator|->
name|relocateable
operator|&&
name|merged
condition|)
name|elf_link_hash_traverse
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|elf_link_sec_merge_syms
argument_list|,
operator|(
name|PTR
operator|)
name|abfd
argument_list|)
expr_stmt|;
comment|/* Figure out the file positions for everything but the symbol table      and the relocs.  We set symcount to force assign_section_numbers      to create a symbol table.  */
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|=
name|info
operator|->
name|strip
operator|==
name|strip_all
condition|?
literal|0
else|:
literal|1
expr_stmt|;
name|BFD_ASSERT
argument_list|(
operator|!
name|abfd
operator|->
name|output_has_begun
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|_bfd_elf_compute_section_file_positions
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* Figure out how many relocations we will have in each section.      Just using RELOC_COUNT isn't good enough since that doesn't      maintain a separate value for REL vs. RELA relocations.  */
if|if
condition|(
name|emit_relocs
condition|)
for|for
control|(
name|sub
operator|=
name|info
operator|->
name|input_bfds
init|;
name|sub
operator|!=
name|NULL
condition|;
name|sub
operator|=
name|sub
operator|->
name|link_next
control|)
for|for
control|(
name|o
operator|=
name|sub
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
name|asection
modifier|*
name|output_section
decl_stmt|;
if|if
condition|(
operator|!
name|o
operator|->
name|linker_mark
condition|)
block|{
comment|/* This section was omitted from the link.  */
continue|continue;
block|}
name|output_section
operator|=
name|o
operator|->
name|output_section
expr_stmt|;
if|if
condition|(
name|output_section
operator|!=
name|NULL
operator|&&
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|bfd_elf_section_data
modifier|*
name|esdi
init|=
name|elf_section_data
argument_list|(
name|o
argument_list|)
decl_stmt|;
name|struct
name|bfd_elf_section_data
modifier|*
name|esdo
init|=
name|elf_section_data
argument_list|(
name|output_section
argument_list|)
decl_stmt|;
name|unsigned
name|int
modifier|*
name|rel_count
decl_stmt|;
name|unsigned
name|int
modifier|*
name|rel_count2
decl_stmt|;
name|bfd_size_type
name|entsize
decl_stmt|;
name|bfd_size_type
name|entsize2
decl_stmt|;
comment|/* We must be careful to add the relocations from the 		 input section to the right output count.  */
name|entsize
operator|=
name|esdi
operator|->
name|rel_hdr
operator|.
name|sh_entsize
expr_stmt|;
name|entsize2
operator|=
name|esdi
operator|->
name|rel_hdr2
condition|?
name|esdi
operator|->
name|rel_hdr2
operator|->
name|sh_entsize
else|:
literal|0
expr_stmt|;
name|BFD_ASSERT
argument_list|(
operator|(
name|entsize
operator|==
sizeof|sizeof
argument_list|(
name|Elf_External_Rel
argument_list|)
operator|||
name|entsize
operator|==
sizeof|sizeof
argument_list|(
name|Elf_External_Rela
argument_list|)
operator|)
operator|&&
name|entsize2
operator|!=
name|entsize
operator|&&
operator|(
name|entsize2
operator|==
literal|0
operator|||
name|entsize2
operator|==
sizeof|sizeof
argument_list|(
name|Elf_External_Rel
argument_list|)
operator|||
name|entsize2
operator|==
sizeof|sizeof
argument_list|(
name|Elf_External_Rela
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entsize
operator|==
name|esdo
operator|->
name|rel_hdr
operator|.
name|sh_entsize
condition|)
block|{
name|rel_count
operator|=
operator|&
name|esdo
operator|->
name|rel_count
expr_stmt|;
name|rel_count2
operator|=
operator|&
name|esdo
operator|->
name|rel_count2
expr_stmt|;
block|}
else|else
block|{
name|rel_count
operator|=
operator|&
name|esdo
operator|->
name|rel_count2
expr_stmt|;
name|rel_count2
operator|=
operator|&
name|esdo
operator|->
name|rel_count
expr_stmt|;
block|}
operator|*
name|rel_count
operator|+=
name|NUM_SHDR_ENTRIES
argument_list|(
operator|&
name|esdi
operator|->
name|rel_hdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|esdi
operator|->
name|rel_hdr2
condition|)
operator|*
name|rel_count2
operator|+=
name|NUM_SHDR_ENTRIES
argument_list|(
name|esdi
operator|->
name|rel_hdr2
argument_list|)
expr_stmt|;
name|output_section
operator|->
name|flags
operator||=
name|SEC_RELOC
expr_stmt|;
block|}
block|}
comment|/* That created the reloc sections.  Set their sizes, and assign      them file positions, and allocate some buffers.  */
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|elf_link_size_reloc_section
argument_list|(
name|abfd
argument_list|,
operator|&
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_hdr
argument_list|,
name|o
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_hdr2
operator|&&
operator|!
name|elf_link_size_reloc_section
argument_list|(
name|abfd
argument_list|,
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_hdr2
argument_list|,
name|o
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
comment|/* Now, reset REL_COUNT and REL_COUNT2 so that we can use them 	 to count upwards while actually outputting the relocations.  */
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_count
operator|=
literal|0
expr_stmt|;
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_count2
operator|=
literal|0
expr_stmt|;
block|}
name|_bfd_elf_assign_file_positions_for_relocs
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* We have now assigned file positions for all the sections except      .symtab and .strtab.  We start the .symtab section at the current      file position, and write directly to it.  We build the .strtab      section in memory.  */
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|=
literal|0
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
comment|/* sh_name is set in prep_headers.  */
name|symtab_hdr
operator|->
name|sh_type
operator|=
name|SHT_SYMTAB
expr_stmt|;
name|symtab_hdr
operator|->
name|sh_flags
operator|=
literal|0
expr_stmt|;
name|symtab_hdr
operator|->
name|sh_addr
operator|=
literal|0
expr_stmt|;
name|symtab_hdr
operator|->
name|sh_size
operator|=
literal|0
expr_stmt|;
name|symtab_hdr
operator|->
name|sh_entsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
expr_stmt|;
comment|/* sh_link is set in assign_section_numbers.  */
comment|/* sh_info is set below.  */
comment|/* sh_offset is set just below.  */
name|symtab_hdr
operator|->
name|sh_addralign
operator|=
name|bed
operator|->
name|s
operator|->
name|file_align
expr_stmt|;
name|off
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|next_file_pos
expr_stmt|;
name|off
operator|=
name|_bfd_elf_assign_file_position_for_section
argument_list|(
name|symtab_hdr
argument_list|,
name|off
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* Note that at this point elf_tdata (abfd)->next_file_pos is      incorrect.  We do not yet know the size of the .symtab section.      We correct next_file_pos below, after we do know the size.  */
comment|/* Allocate a buffer to hold swapped out symbols.  This is to avoid      continuously seeking to the right position in the file.  */
if|if
condition|(
operator|!
name|info
operator|->
name|keep_memory
operator|||
name|max_sym_count
operator|<
literal|20
condition|)
name|finfo
operator|.
name|symbuf_size
operator|=
literal|20
expr_stmt|;
else|else
name|finfo
operator|.
name|symbuf_size
operator|=
name|max_sym_count
expr_stmt|;
name|amt
operator|=
name|finfo
operator|.
name|symbuf_size
expr_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|symbuf
operator|=
operator|(
name|Elf_External_Sym
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|symbuf
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|elf_numsections
argument_list|(
name|abfd
argument_list|)
operator|>
name|SHN_LORESERVE
condition|)
block|{
name|amt
operator|=
name|finfo
operator|.
name|symbuf_size
expr_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
name|Elf_External_Sym_Shndx
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|symshndxbuf
operator|=
operator|(
name|Elf_External_Sym_Shndx
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|symshndxbuf
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
block|}
comment|/* Start writing out the symbol table.  The first symbol is always a      dummy symbol.  */
if|if
condition|(
name|info
operator|->
name|strip
operator|!=
name|strip_all
operator|||
name|emit_relocs
condition|)
block|{
name|elfsym
operator|.
name|st_value
operator|=
literal|0
expr_stmt|;
name|elfsym
operator|.
name|st_size
operator|=
literal|0
expr_stmt|;
name|elfsym
operator|.
name|st_info
operator|=
literal|0
expr_stmt|;
name|elfsym
operator|.
name|st_other
operator|=
literal|0
expr_stmt|;
name|elfsym
operator|.
name|st_shndx
operator|=
name|SHN_UNDEF
expr_stmt|;
if|if
condition|(
operator|!
name|elf_link_output_sym
argument_list|(
operator|&
name|finfo
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|elfsym
argument_list|,
name|bfd_und_section_ptr
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
if|#
directive|if
literal|0
comment|/* Some standard ELF linkers do this, but we don't because it causes      bootstrap comparison failures.  */
comment|/* Output a file symbol for the output file as the second symbol.      We output this even if we are discarding local symbols, although      I'm not sure if this is correct.  */
block|elfsym.st_value = 0;   elfsym.st_size = 0;   elfsym.st_info = ELF_ST_INFO (STB_LOCAL, STT_FILE);   elfsym.st_other = 0;   elfsym.st_shndx = SHN_ABS;   if (! elf_link_output_sym (&finfo, bfd_get_filename (abfd),&elfsym, bfd_abs_section_ptr))     goto error_return;
endif|#
directive|endif
comment|/* Output a symbol for each section.  We output these even if we are      discarding local symbols, since they are used for relocs.  These      symbols have no names.  We store the index of each one in the      index field of the section, so that we can find it again when      outputting relocs.  */
if|if
condition|(
name|info
operator|->
name|strip
operator|!=
name|strip_all
operator|||
name|emit_relocs
condition|)
block|{
name|elfsym
operator|.
name|st_size
operator|=
literal|0
expr_stmt|;
name|elfsym
operator|.
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_LOCAL
argument_list|,
name|STT_SECTION
argument_list|)
expr_stmt|;
name|elfsym
operator|.
name|st_other
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|elf_numsections
argument_list|(
name|abfd
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|o
operator|=
name|section_from_elf_index
argument_list|(
name|abfd
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|!=
name|NULL
condition|)
name|o
operator|->
name|target_index
operator|=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|elfsym
operator|.
name|st_shndx
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|relocateable
operator|||
name|o
operator|==
name|NULL
condition|)
name|elfsym
operator|.
name|st_value
operator|=
literal|0
expr_stmt|;
else|else
name|elfsym
operator|.
name|st_value
operator|=
name|o
operator|->
name|vma
expr_stmt|;
if|if
condition|(
operator|!
name|elf_link_output_sym
argument_list|(
operator|&
name|finfo
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|elfsym
argument_list|,
name|o
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|i
operator|==
name|SHN_LORESERVE
condition|)
name|i
operator|+=
name|SHN_HIRESERVE
operator|+
literal|1
operator|-
name|SHN_LORESERVE
expr_stmt|;
block|}
block|}
comment|/* Allocate some memory to hold information read in from the input      files.  */
if|if
condition|(
name|max_contents_size
operator|!=
literal|0
condition|)
block|{
name|finfo
operator|.
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|max_contents_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|contents
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
block|}
if|if
condition|(
name|max_external_reloc_size
operator|!=
literal|0
condition|)
block|{
name|finfo
operator|.
name|external_relocs
operator|=
operator|(
name|PTR
operator|)
name|bfd_malloc
argument_list|(
name|max_external_reloc_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|external_relocs
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
block|}
if|if
condition|(
name|max_internal_reloc_count
operator|!=
literal|0
condition|)
block|{
name|amt
operator|=
name|max_internal_reloc_count
operator|*
name|bed
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
expr_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
name|Elf_Internal_Rela
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|internal_relocs
operator|=
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|internal_relocs
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
block|}
if|if
condition|(
name|max_sym_count
operator|!=
literal|0
condition|)
block|{
name|amt
operator|=
name|max_sym_count
operator|*
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|external_syms
operator|=
operator|(
name|Elf_External_Sym
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|external_syms
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|amt
operator|=
name|max_sym_count
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Internal_Sym
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|internal_syms
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|internal_syms
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|amt
operator|=
name|max_sym_count
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|indices
operator|=
operator|(
name|long
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|indices
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|amt
operator|=
name|max_sym_count
operator|*
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|sections
operator|=
operator|(
name|asection
operator|*
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|sections
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
block|}
if|if
condition|(
name|max_sym_shndx_count
operator|!=
literal|0
condition|)
block|{
name|amt
operator|=
name|max_sym_shndx_count
operator|*
sizeof|sizeof
argument_list|(
name|Elf_External_Sym_Shndx
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|locsym_shndx
operator|=
operator|(
name|Elf_External_Sym_Shndx
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|locsym_shndx
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
block|}
comment|/* Since ELF permits relocations to be against local symbols, we      must have the local symbols available when we do the relocations.      Since we would rather only read the local symbols once, and we      would rather not keep them in memory, we handle all the      relocations for a single input file at the same time.       Unfortunately, there is no way to know the total number of local      symbols until we have seen all of them, and the local symbol      indices precede the global symbol indices.  This means that when      we are generating relocateable output, and we see a reloc against      a global symbol, we can not know the symbol index until we have      finished examining all the local symbols to see which ones we are      going to output.  To deal with this, we keep the relocations in      memory, and don't output them until the end of the link.  This is      an unfortunate waste of memory, but I don't see a good way around      it.  Fortunately, it only happens when performing a relocateable      link, which is not the common case.  FIXME: If keep_memory is set      we could write the relocs out and then read them again; I don't      know how bad the memory loss will be.  */
for|for
control|(
name|sub
operator|=
name|info
operator|->
name|input_bfds
init|;
name|sub
operator|!=
name|NULL
condition|;
name|sub
operator|=
name|sub
operator|->
name|link_next
control|)
name|sub
operator|->
name|output_has_begun
operator|=
name|false
expr_stmt|;
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
for|for
control|(
name|p
operator|=
name|o
operator|->
name|link_order_head
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|rhdr
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_indirect_link_order
operator|&&
operator|(
name|bfd_get_flavour
argument_list|(
name|p
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
operator|->
name|owner
argument_list|)
operator|==
name|bfd_target_elf_flavour
operator|)
operator|&&
operator|(
operator|(
operator|(
name|rhdr
operator|=
operator|&
name|elf_section_data
argument_list|(
name|p
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
argument_list|)
operator|->
name|rel_hdr
operator|)
operator|->
name|sh_entsize
operator|==
literal|0
operator|)
operator|||
name|rhdr
operator|->
name|sh_entsize
operator|==
sizeof|sizeof
argument_list|(
name|Elf_External_Rel
argument_list|)
operator|||
name|rhdr
operator|->
name|sh_entsize
operator|==
sizeof|sizeof
argument_list|(
name|Elf_External_Rela
argument_list|)
operator|)
operator|&&
operator|(
operator|(
operator|(
name|rhdr
operator|=
name|elf_section_data
argument_list|(
name|p
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
argument_list|)
operator|->
name|rel_hdr2
operator|)
operator|==
name|NULL
operator|)
operator|||
name|rhdr
operator|->
name|sh_entsize
operator|==
sizeof|sizeof
argument_list|(
name|Elf_External_Rel
argument_list|)
operator|||
name|rhdr
operator|->
name|sh_entsize
operator|==
sizeof|sizeof
argument_list|(
name|Elf_External_Rela
argument_list|)
operator|)
condition|)
block|{
name|sub
operator|=
name|p
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
operator|->
name|owner
expr_stmt|;
if|if
condition|(
operator|!
name|sub
operator|->
name|output_has_begun
condition|)
block|{
if|if
condition|(
operator|!
name|elf_link_input_bfd
argument_list|(
operator|&
name|finfo
argument_list|,
name|sub
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
name|sub
operator|->
name|output_has_begun
operator|=
name|true
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_section_reloc_link_order
operator|||
name|p
operator|->
name|type
operator|==
name|bfd_symbol_reloc_link_order
condition|)
block|{
if|if
condition|(
operator|!
name|elf_reloc_link_order
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|o
argument_list|,
name|p
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|_bfd_default_link_order
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|o
argument_list|,
name|p
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
block|}
block|}
comment|/* Output any global symbols that got converted to local in a      version script or due to symbol visibility.  We do this in a      separate step since ELF requires all local symbols to appear      prior to any global symbols.  FIXME: We should only do this if      some global symbols were, in fact, converted to become local.      FIXME: Will this work correctly with the Irix 5 linker?  */
name|eoinfo
operator|.
name|failed
operator|=
name|false
expr_stmt|;
name|eoinfo
operator|.
name|finfo
operator|=
operator|&
name|finfo
expr_stmt|;
name|eoinfo
operator|.
name|localsyms
operator|=
name|true
expr_stmt|;
name|elf_link_hash_traverse
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|elf_link_output_extsym
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|eoinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|eoinfo
operator|.
name|failed
condition|)
return|return
name|false
return|;
comment|/* That wrote out all the local symbols.  Finish up the symbol table      with the global symbols. Even if we want to strip everything we      can, we still need to deal with those global symbols that got      converted to local in a version script.  */
comment|/* The sh_info field records the index of the first non local symbol.  */
name|symtab_hdr
operator|->
name|sh_info
operator|=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynamic
operator|&&
name|finfo
operator|.
name|dynsym_sec
operator|->
name|output_section
operator|!=
name|bfd_abs_section_ptr
condition|)
block|{
name|Elf_Internal_Sym
name|sym
decl_stmt|;
name|Elf_External_Sym
modifier|*
name|dynsym
init|=
operator|(
name|Elf_External_Sym
operator|*
operator|)
name|finfo
operator|.
name|dynsym_sec
operator|->
name|contents
decl_stmt|;
name|long
name|last_local
init|=
literal|0
decl_stmt|;
comment|/* Write out the section symbols for the output sections.  */
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|sym
operator|.
name|st_size
operator|=
literal|0
expr_stmt|;
name|sym
operator|.
name|st_name
operator|=
literal|0
expr_stmt|;
name|sym
operator|.
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_LOCAL
argument_list|,
name|STT_SECTION
argument_list|)
expr_stmt|;
name|sym
operator|.
name|st_other
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|int
name|indx
decl_stmt|;
name|Elf_External_Sym
modifier|*
name|dest
decl_stmt|;
name|indx
operator|=
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|this_idx
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|indx
operator|>
literal|0
argument_list|)
expr_stmt|;
name|sym
operator|.
name|st_shndx
operator|=
name|indx
expr_stmt|;
name|sym
operator|.
name|st_value
operator|=
name|s
operator|->
name|vma
expr_stmt|;
name|dest
operator|=
name|dynsym
operator|+
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|dynindx
expr_stmt|;
name|elf_swap_symbol_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|sym
argument_list|,
operator|(
name|PTR
operator|)
name|dest
argument_list|,
operator|(
name|PTR
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
name|last_local
operator|=
name|bfd_count_sections
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
comment|/* Write out the local dynsyms.  */
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynlocal
condition|)
block|{
name|struct
name|elf_link_local_dynamic_entry
modifier|*
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynlocal
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next
control|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|Elf_External_Sym
modifier|*
name|dest
decl_stmt|;
name|sym
operator|.
name|st_size
operator|=
name|e
operator|->
name|isym
operator|.
name|st_size
expr_stmt|;
name|sym
operator|.
name|st_other
operator|=
name|e
operator|->
name|isym
operator|.
name|st_other
expr_stmt|;
comment|/* Copy the internal symbol as is. 		 Note that we saved a word of storage and overwrote 		 the original st_name with the dynstr_index.  */
name|sym
operator|=
name|e
operator|->
name|isym
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|isym
operator|.
name|st_shndx
operator|!=
name|SHN_UNDEF
operator|&&
operator|(
name|e
operator|->
name|isym
operator|.
name|st_shndx
operator|<
name|SHN_LORESERVE
operator|||
name|e
operator|->
name|isym
operator|.
name|st_shndx
operator|>
name|SHN_HIRESERVE
operator|)
condition|)
block|{
name|s
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|e
operator|->
name|input_bfd
argument_list|,
name|e
operator|->
name|isym
operator|.
name|st_shndx
argument_list|)
expr_stmt|;
name|sym
operator|.
name|st_shndx
operator|=
name|elf_section_data
argument_list|(
name|s
operator|->
name|output_section
argument_list|)
operator|->
name|this_idx
expr_stmt|;
name|sym
operator|.
name|st_value
operator|=
operator|(
name|s
operator|->
name|output_section
operator|->
name|vma
operator|+
name|s
operator|->
name|output_offset
operator|+
name|e
operator|->
name|isym
operator|.
name|st_value
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|last_local
operator|<
name|e
operator|->
name|dynindx
condition|)
name|last_local
operator|=
name|e
operator|->
name|dynindx
expr_stmt|;
name|dest
operator|=
name|dynsym
operator|+
name|e
operator|->
name|dynindx
expr_stmt|;
name|elf_swap_symbol_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|sym
argument_list|,
operator|(
name|PTR
operator|)
name|dest
argument_list|,
operator|(
name|PTR
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|elf_section_data
argument_list|(
name|finfo
operator|.
name|dynsym_sec
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_info
operator|=
name|last_local
operator|+
literal|1
expr_stmt|;
block|}
comment|/* We get the global symbols from the hash table.  */
name|eoinfo
operator|.
name|failed
operator|=
name|false
expr_stmt|;
name|eoinfo
operator|.
name|localsyms
operator|=
name|false
expr_stmt|;
name|eoinfo
operator|.
name|finfo
operator|=
operator|&
name|finfo
expr_stmt|;
name|elf_link_hash_traverse
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|elf_link_output_extsym
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|eoinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|eoinfo
operator|.
name|failed
condition|)
return|return
name|false
return|;
comment|/* If backend needs to output some symbols not present in the hash      table, do it now.  */
if|if
condition|(
name|bed
operator|->
name|elf_backend_output_arch_syms
condition|)
block|{
typedef|typedef
name|boolean
argument_list|(
argument|*out_sym_func
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
specifier|const
name|char
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|bed
operator|->
name|elf_backend_output_arch_syms
call|)
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|finfo
argument_list|,
operator|(
name|out_sym_func
operator|)
name|elf_link_output_sym
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
block|}
comment|/* Flush all symbols to the file.  */
if|if
condition|(
operator|!
name|elf_link_flush_output_syms
argument_list|(
operator|&
name|finfo
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Now we know the size of the symtab section.  */
name|off
operator|+=
name|symtab_hdr
operator|->
name|sh_size
expr_stmt|;
comment|/* Finish up and write out the symbol string table (.strtab)      section.  */
name|symstrtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|strtab_hdr
expr_stmt|;
comment|/* sh_name was set in prep_headers.  */
name|symstrtab_hdr
operator|->
name|sh_type
operator|=
name|SHT_STRTAB
expr_stmt|;
name|symstrtab_hdr
operator|->
name|sh_flags
operator|=
literal|0
expr_stmt|;
name|symstrtab_hdr
operator|->
name|sh_addr
operator|=
literal|0
expr_stmt|;
name|symstrtab_hdr
operator|->
name|sh_size
operator|=
name|_bfd_stringtab_size
argument_list|(
name|finfo
operator|.
name|symstrtab
argument_list|)
expr_stmt|;
name|symstrtab_hdr
operator|->
name|sh_entsize
operator|=
literal|0
expr_stmt|;
name|symstrtab_hdr
operator|->
name|sh_link
operator|=
literal|0
expr_stmt|;
name|symstrtab_hdr
operator|->
name|sh_info
operator|=
literal|0
expr_stmt|;
comment|/* sh_offset is set just below.  */
name|symstrtab_hdr
operator|->
name|sh_addralign
operator|=
literal|1
expr_stmt|;
name|off
operator|=
name|_bfd_elf_assign_file_position_for_section
argument_list|(
name|symstrtab_hdr
argument_list|,
name|off
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|next_file_pos
operator|=
name|off
expr_stmt|;
if|if
condition|(
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|symstrtab_hdr
operator|->
name|sh_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
operator|!
name|_bfd_stringtab_emit
argument_list|(
name|abfd
argument_list|,
name|finfo
operator|.
name|symstrtab
argument_list|)
condition|)
return|return
name|false
return|;
block|}
comment|/* Adjust the relocs to have the correct symbol indices.  */
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|elf_link_adjust_relocs
argument_list|(
name|abfd
argument_list|,
operator|&
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_hdr
argument_list|,
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_count
argument_list|,
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_hashes
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_hdr2
operator|!=
name|NULL
condition|)
name|elf_link_adjust_relocs
argument_list|(
name|abfd
argument_list|,
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_hdr2
argument_list|,
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_count2
argument_list|,
operator|(
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_hashes
operator|+
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_count
operator|)
argument_list|)
expr_stmt|;
comment|/* Set the reloc_count field to 0 to prevent write_relocs from 	 trying to swap the relocs out itself.  */
name|o
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|dynamic
operator|&&
name|info
operator|->
name|combreloc
operator|&&
name|dynobj
operator|!=
name|NULL
condition|)
name|relativecount
operator|=
name|elf_link_sort_relocs
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
operator|&
name|reldyn
argument_list|)
expr_stmt|;
comment|/* If we are linking against a dynamic object, or generating a      shared library, finish up the dynamic linking information.  */
if|if
condition|(
name|dynamic
condition|)
block|{
name|Elf_External_Dyn
modifier|*
name|dyncon
decl_stmt|,
modifier|*
name|dynconend
decl_stmt|;
comment|/* Fix up .dynamic entries.  */
name|o
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|o
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dyncon
operator|=
operator|(
name|Elf_External_Dyn
operator|*
operator|)
name|o
operator|->
name|contents
expr_stmt|;
name|dynconend
operator|=
operator|(
name|Elf_External_Dyn
operator|*
operator|)
operator|(
name|o
operator|->
name|contents
operator|+
name|o
operator|->
name|_raw_size
operator|)
expr_stmt|;
for|for
control|(
init|;
name|dyncon
operator|<
name|dynconend
condition|;
name|dyncon
operator|++
control|)
block|{
name|Elf_Internal_Dyn
name|dyn
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|int
name|type
decl_stmt|;
name|elf_swap_dyn_in
argument_list|(
name|dynobj
argument_list|,
name|dyncon
argument_list|,
operator|&
name|dyn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dyn
operator|.
name|d_tag
condition|)
block|{
default|default:
break|break;
case|case
name|DT_NULL
case|:
if|if
condition|(
name|relativecount
operator|>
literal|0
operator|&&
name|dyncon
operator|+
literal|1
operator|<
name|dynconend
condition|)
block|{
switch|switch
condition|(
name|elf_section_data
argument_list|(
name|reldyn
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_type
condition|)
block|{
case|case
name|SHT_REL
case|:
name|dyn
operator|.
name|d_tag
operator|=
name|DT_RELCOUNT
expr_stmt|;
break|break;
case|case
name|SHT_RELA
case|:
name|dyn
operator|.
name|d_tag
operator|=
name|DT_RELACOUNT
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|dyn
operator|.
name|d_tag
operator|!=
name|DT_NULL
condition|)
block|{
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|relativecount
expr_stmt|;
name|elf_swap_dyn_out
argument_list|(
name|dynobj
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
name|relativecount
operator|=
literal|0
expr_stmt|;
block|}
block|}
break|break;
case|case
name|DT_INIT
case|:
name|name
operator|=
name|info
operator|->
name|init_function
expr_stmt|;
goto|goto
name|get_sym
goto|;
case|case
name|DT_FINI
case|:
name|name
operator|=
name|info
operator|->
name|fini_function
expr_stmt|;
name|get_sym
label|:
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
name|elf_link_hash_lookup
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|name
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
condition|)
block|{
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
name|o
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|output_section
operator|!=
name|NULL
condition|)
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|+=
operator|(
name|o
operator|->
name|output_section
operator|->
name|vma
operator|+
name|o
operator|->
name|output_offset
operator|)
expr_stmt|;
else|else
block|{
comment|/* The symbol is imported from another shared 			   library and does not apply to this one.  */
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
literal|0
expr_stmt|;
block|}
name|elf_swap_dyn_out
argument_list|(
name|dynobj
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|DT_PREINIT_ARRAYSZ
case|:
name|name
operator|=
literal|".preinit_array"
expr_stmt|;
goto|goto
name|get_size
goto|;
case|case
name|DT_INIT_ARRAYSZ
case|:
name|name
operator|=
literal|".init_array"
expr_stmt|;
goto|goto
name|get_size
goto|;
case|case
name|DT_FINI_ARRAYSZ
case|:
name|name
operator|=
literal|".fini_array"
expr_stmt|;
name|get_size
label|:
name|o
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|o
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|_raw_size
operator|==
literal|0
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"warning: %s section has zero size"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|o
operator|->
name|_raw_size
expr_stmt|;
name|elf_swap_dyn_out
argument_list|(
name|dynobj
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_PREINIT_ARRAY
case|:
name|name
operator|=
literal|".preinit_array"
expr_stmt|;
goto|goto
name|get_vma
goto|;
case|case
name|DT_INIT_ARRAY
case|:
name|name
operator|=
literal|".init_array"
expr_stmt|;
goto|goto
name|get_vma
goto|;
case|case
name|DT_FINI_ARRAY
case|:
name|name
operator|=
literal|".fini_array"
expr_stmt|;
goto|goto
name|get_vma
goto|;
case|case
name|DT_HASH
case|:
name|name
operator|=
literal|".hash"
expr_stmt|;
goto|goto
name|get_vma
goto|;
case|case
name|DT_STRTAB
case|:
name|name
operator|=
literal|".dynstr"
expr_stmt|;
goto|goto
name|get_vma
goto|;
case|case
name|DT_SYMTAB
case|:
name|name
operator|=
literal|".dynsym"
expr_stmt|;
goto|goto
name|get_vma
goto|;
case|case
name|DT_VERDEF
case|:
name|name
operator|=
literal|".gnu.version_d"
expr_stmt|;
goto|goto
name|get_vma
goto|;
case|case
name|DT_VERNEED
case|:
name|name
operator|=
literal|".gnu.version_r"
expr_stmt|;
goto|goto
name|get_vma
goto|;
case|case
name|DT_VERSYM
case|:
name|name
operator|=
literal|".gnu.version"
expr_stmt|;
name|get_vma
label|:
name|o
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|o
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|o
operator|->
name|vma
expr_stmt|;
name|elf_swap_dyn_out
argument_list|(
name|dynobj
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_REL
case|:
case|case
name|DT_RELA
case|:
case|case
name|DT_RELSZ
case|:
case|case
name|DT_RELASZ
case|:
if|if
condition|(
name|dyn
operator|.
name|d_tag
operator|==
name|DT_REL
operator|||
name|dyn
operator|.
name|d_tag
operator|==
name|DT_RELSZ
condition|)
name|type
operator|=
name|SHT_REL
expr_stmt|;
else|else
name|type
operator|=
name|SHT_RELA
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|elf_numsections
argument_list|(
name|abfd
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
name|hdr
operator|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|sh_type
operator|==
name|type
operator|&&
operator|(
name|hdr
operator|->
name|sh_flags
operator|&
name|SHF_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|dyn
operator|.
name|d_tag
operator|==
name|DT_RELSZ
operator|||
name|dyn
operator|.
name|d_tag
operator|==
name|DT_RELASZ
condition|)
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|+=
name|hdr
operator|->
name|sh_size
expr_stmt|;
else|else
block|{
if|if
condition|(
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|==
literal|0
operator|||
name|hdr
operator|->
name|sh_addr
operator|<
name|dyn
operator|.
name|d_un
operator|.
name|d_val
condition|)
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|hdr
operator|->
name|sh_addr
expr_stmt|;
block|}
block|}
block|}
name|elf_swap_dyn_out
argument_list|(
name|dynobj
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* If we have created any dynamic sections, then output them.  */
if|if
condition|(
name|dynobj
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
call|(
modifier|*
name|bed
operator|->
name|elf_backend_finish_dynamic_sections
call|)
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
for|for
control|(
name|o
operator|=
name|dynobj
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|==
literal|0
operator|||
name|o
operator|->
name|_raw_size
operator|==
literal|0
operator|||
name|o
operator|->
name|output_section
operator|==
name|bfd_abs_section_ptr
condition|)
continue|continue;
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_LINKER_CREATED
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* At this point, we are only interested in sections 		 created by elf_link_create_dynamic_sections.  */
continue|continue;
block|}
if|if
condition|(
operator|(
name|elf_section_data
argument_list|(
name|o
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_type
operator|!=
name|SHT_STRTAB
operator|)
operator|||
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|o
argument_list|)
argument_list|,
literal|".dynstr"
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|o
operator|->
name|output_section
argument_list|,
name|o
operator|->
name|contents
argument_list|,
operator|(
name|file_ptr
operator|)
name|o
operator|->
name|output_offset
argument_list|,
name|o
operator|->
name|_raw_size
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
else|else
block|{
comment|/* The contents of the .dynstr section are actually in a 		 stringtab.  */
name|off
operator|=
name|elf_section_data
argument_list|(
name|o
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_offset
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|off
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
operator|!
name|_bfd_elf_strtab_emit
argument_list|(
name|abfd
argument_list|,
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
block|}
block|}
comment|/* If we have optimized stabs strings, output them.  */
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|stab_info
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|_bfd_write_stab_strings
argument_list|(
name|abfd
argument_list|,
operator|&
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|stab_info
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
if|if
condition|(
name|info
operator|->
name|eh_frame_hdr
operator|&&
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
condition|)
block|{
name|o
operator|=
name|bfd_get_section_by_name
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
argument_list|,
literal|".eh_frame_hdr"
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|&&
operator|(
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|sec_info_type
operator|==
name|ELF_INFO_TYPE_EH_FRAME_HDR
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|_bfd_elf_write_section_eh_frame_hdr
argument_list|(
name|abfd
argument_list|,
name|o
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
block|}
if|if
condition|(
name|finfo
operator|.
name|symstrtab
operator|!=
name|NULL
condition|)
name|_bfd_stringtab_free
argument_list|(
name|finfo
operator|.
name|symstrtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|contents
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|contents
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|external_relocs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|external_relocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|internal_relocs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|internal_relocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|external_syms
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|external_syms
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|locsym_shndx
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|locsym_shndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|internal_syms
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|internal_syms
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|indices
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|indices
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|sections
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|sections
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|symbuf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|symbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|symshndxbuf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|symbuf
argument_list|)
expr_stmt|;
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|!=
literal|0
operator|&&
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_hashes
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_hashes
argument_list|)
expr_stmt|;
block|}
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|linker
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
name|error_return
label|:
if|if
condition|(
name|finfo
operator|.
name|symstrtab
operator|!=
name|NULL
condition|)
name|_bfd_stringtab_free
argument_list|(
name|finfo
operator|.
name|symstrtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|contents
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|contents
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|external_relocs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|external_relocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|internal_relocs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|internal_relocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|external_syms
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|external_syms
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|locsym_shndx
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|locsym_shndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|internal_syms
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|internal_syms
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|indices
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|indices
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|sections
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|sections
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|symbuf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|symbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|symshndxbuf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|symbuf
argument_list|)
expr_stmt|;
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|!=
literal|0
operator|&&
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_hashes
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_hashes
argument_list|)
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Add a symbol to the output symbol table.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf_link_output_sym
parameter_list|(
name|finfo
parameter_list|,
name|name
parameter_list|,
name|elfsym
parameter_list|,
name|input_sec
parameter_list|)
name|struct
name|elf_final_link_info
modifier|*
name|finfo
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|elfsym
decl_stmt|;
name|asection
modifier|*
name|input_sec
decl_stmt|;
block|{
name|Elf_External_Sym
modifier|*
name|dest
decl_stmt|;
name|Elf_External_Sym_Shndx
modifier|*
name|destshndx
decl_stmt|;
name|boolean
argument_list|(
argument|*output_symbol_hook
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|,
specifier|const
name|char
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
expr_stmt|;
name|output_symbol_hook
operator|=
name|get_elf_backend_data
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|)
operator|->
name|elf_backend_link_output_symbol_hook
expr_stmt|;
if|if
condition|(
name|output_symbol_hook
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|output_symbol_hook
call|)
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|,
name|finfo
operator|->
name|info
argument_list|,
name|name
argument_list|,
name|elfsym
argument_list|,
name|input_sec
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|name
operator|==
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
operator|||
operator|*
name|name
operator|==
literal|'\0'
condition|)
name|elfsym
operator|->
name|st_name
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|input_sec
operator|->
name|flags
operator|&
name|SEC_EXCLUDE
condition|)
name|elfsym
operator|->
name|st_name
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|elfsym
operator|->
name|st_name
operator|=
operator|(
name|unsigned
name|long
operator|)
name|_bfd_stringtab_add
argument_list|(
name|finfo
operator|->
name|symstrtab
argument_list|,
name|name
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|elfsym
operator|->
name|st_name
operator|==
operator|(
name|unsigned
name|long
operator|)
operator|-
literal|1
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|finfo
operator|->
name|symbuf_count
operator|>=
name|finfo
operator|->
name|symbuf_size
condition|)
block|{
if|if
condition|(
operator|!
name|elf_link_flush_output_syms
argument_list|(
name|finfo
argument_list|)
condition|)
return|return
name|false
return|;
block|}
name|dest
operator|=
name|finfo
operator|->
name|symbuf
operator|+
name|finfo
operator|->
name|symbuf_count
expr_stmt|;
name|destshndx
operator|=
name|finfo
operator|->
name|symshndxbuf
expr_stmt|;
if|if
condition|(
name|destshndx
operator|!=
name|NULL
condition|)
name|destshndx
operator|+=
name|finfo
operator|->
name|symbuf_count
expr_stmt|;
name|elf_swap_symbol_out
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|,
name|elfsym
argument_list|,
operator|(
name|PTR
operator|)
name|dest
argument_list|,
operator|(
name|PTR
operator|)
name|destshndx
argument_list|)
expr_stmt|;
operator|++
name|finfo
operator|->
name|symbuf_count
expr_stmt|;
operator|++
name|bfd_get_symcount
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Flush the output symbols to the file.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf_link_flush_output_syms
parameter_list|(
name|finfo
parameter_list|)
name|struct
name|elf_final_link_info
modifier|*
name|finfo
decl_stmt|;
block|{
if|if
condition|(
name|finfo
operator|->
name|symbuf_count
operator|>
literal|0
condition|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
name|file_ptr
name|pos
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|pos
operator|=
name|hdr
operator|->
name|sh_offset
operator|+
name|hdr
operator|->
name|sh_size
expr_stmt|;
name|amt
operator|=
name|finfo
operator|->
name|symbuf_count
operator|*
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|,
name|pos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bwrite
argument_list|(
operator|(
name|PTR
operator|)
name|finfo
operator|->
name|symbuf
argument_list|,
name|amt
argument_list|,
name|finfo
operator|->
name|output_bfd
argument_list|)
operator|!=
name|amt
condition|)
return|return
name|false
return|;
name|hdr
operator|->
name|sh_size
operator|+=
name|amt
expr_stmt|;
if|if
condition|(
name|finfo
operator|->
name|symshndxbuf
operator|!=
name|NULL
condition|)
block|{
name|hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|)
operator|->
name|symtab_shndx_hdr
expr_stmt|;
name|pos
operator|=
name|hdr
operator|->
name|sh_offset
operator|+
name|hdr
operator|->
name|sh_size
expr_stmt|;
name|amt
operator|=
name|finfo
operator|->
name|symbuf_count
operator|*
sizeof|sizeof
argument_list|(
name|Elf_External_Sym_Shndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|,
name|pos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|bfd_bwrite
argument_list|(
operator|(
name|PTR
operator|)
name|finfo
operator|->
name|symshndxbuf
argument_list|,
name|amt
argument_list|,
name|finfo
operator|->
name|output_bfd
argument_list|)
operator|!=
name|amt
operator|)
condition|)
return|return
name|false
return|;
name|hdr
operator|->
name|sh_size
operator|+=
name|amt
expr_stmt|;
block|}
name|finfo
operator|->
name|symbuf_count
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Adjust all external symbols pointing into SEC_MERGE sections    to reflect the object merging within the sections.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf_link_sec_merge_syms
parameter_list|(
name|h
parameter_list|,
name|data
parameter_list|)
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
operator|(
operator|(
name|sec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|)
operator|->
name|flags
operator|&
name|SEC_MERGE
operator|)
operator|&&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|sec_info_type
operator|==
name|ELF_INFO_TYPE_MERGE
condition|)
block|{
name|bfd
modifier|*
name|output_bfd
init|=
operator|(
name|bfd
operator|*
operator|)
name|data
decl_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|_bfd_merged_section_offset
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
argument_list|,
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|sec_info
argument_list|,
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Add an external symbol to the symbol table.  This is called from    the hash table traversal routine.  When generating a shared object,    we go through the symbol table twice.  The first time we output    anything that might have been forced to local scope in a version    script.  The second time we output the symbols that are still    global symbols.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf_link_output_extsym
parameter_list|(
name|h
parameter_list|,
name|data
parameter_list|)
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
name|struct
name|elf_outext_info
modifier|*
name|eoinfo
init|=
operator|(
expr|struct
name|elf_outext_info
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|elf_final_link_info
modifier|*
name|finfo
init|=
name|eoinfo
operator|->
name|finfo
decl_stmt|;
name|boolean
name|strip
decl_stmt|;
name|Elf_Internal_Sym
name|sym
decl_stmt|;
name|asection
modifier|*
name|input_sec
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
block|{
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_new
condition|)
return|return
name|true
return|;
block|}
comment|/* Decide whether to output this symbol in this pass.  */
if|if
condition|(
name|eoinfo
operator|->
name|localsyms
condition|)
block|{
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_FORCED_LOCAL
operator|)
operator|==
literal|0
condition|)
return|return
name|true
return|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_FORCED_LOCAL
operator|)
operator|!=
literal|0
condition|)
return|return
name|true
return|;
block|}
comment|/* If we are not creating a shared library, and this symbol is      referenced by a shared library but is not defined anywhere, then      warn that it is undefined.  If we do not do this, the runtime      linker will complain that the symbol is undefined when the      program is run.  We don't have to worry about symbols that are      referenced by regular files, because we will already have issued      warnings for them.  */
if|if
condition|(
operator|!
name|finfo
operator|->
name|info
operator|->
name|relocateable
operator|&&
operator|!
name|finfo
operator|->
name|info
operator|->
name|allow_shlib_undefined
operator|&&
operator|!
name|finfo
operator|->
name|info
operator|->
name|shared
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_REF_DYNAMIC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_REF_REGULAR
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|finfo
operator|->
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|finfo
operator|->
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|undef
operator|.
name|abfd
argument_list|,
operator|(
name|asection
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|true
argument_list|)
operator|)
condition|)
block|{
name|eoinfo
operator|->
name|failed
operator|=
name|true
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
comment|/* We don't want to output symbols that have never been mentioned by      a regular file, or that we have been told to strip.  However, if      h->indx is set to -2, the symbol is used by a reloc and we must      output it.  */
if|if
condition|(
name|h
operator|->
name|indx
operator|==
operator|-
literal|2
condition|)
name|strip
operator|=
name|false
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_REF_DYNAMIC
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_REF_REGULAR
operator|)
operator|==
literal|0
condition|)
name|strip
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|finfo
operator|->
name|info
operator|->
name|strip
operator|==
name|strip_all
operator|||
operator|(
name|finfo
operator|->
name|info
operator|->
name|strip
operator|==
name|strip_some
operator|&&
name|bfd_hash_lookup
argument_list|(
name|finfo
operator|->
name|info
operator|->
name|keep_hash
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
operator|==
name|NULL
operator|)
condition|)
name|strip
operator|=
name|true
expr_stmt|;
else|else
name|strip
operator|=
name|false
expr_stmt|;
comment|/* If we're stripping it, and it's not a dynamic symbol, there's      nothing else to do unless it is a forced local symbol.  */
if|if
condition|(
name|strip
operator|&&
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_FORCED_LOCAL
operator|)
operator|==
literal|0
condition|)
return|return
name|true
return|;
name|sym
operator|.
name|st_value
operator|=
literal|0
expr_stmt|;
name|sym
operator|.
name|st_size
operator|=
name|h
operator|->
name|size
expr_stmt|;
name|sym
operator|.
name|st_other
operator|=
name|h
operator|->
name|other
expr_stmt|;
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_FORCED_LOCAL
operator|)
operator|!=
literal|0
condition|)
name|sym
operator|.
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_LOCAL
argument_list|,
name|h
operator|->
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
name|sym
operator|.
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_WEAK
argument_list|,
name|h
operator|->
name|type
argument_list|)
expr_stmt|;
else|else
name|sym
operator|.
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_GLOBAL
argument_list|,
name|h
operator|->
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|h
operator|->
name|root
operator|.
name|type
condition|)
block|{
default|default:
case|case
name|bfd_link_hash_new
case|:
case|case
name|bfd_link_hash_warning
case|:
name|abort
argument_list|()
expr_stmt|;
return|return
name|false
return|;
case|case
name|bfd_link_hash_undefined
case|:
case|case
name|bfd_link_hash_undefweak
case|:
name|input_sec
operator|=
name|bfd_und_section_ptr
expr_stmt|;
name|sym
operator|.
name|st_shndx
operator|=
name|SHN_UNDEF
expr_stmt|;
break|break;
case|case
name|bfd_link_hash_defined
case|:
case|case
name|bfd_link_hash_defweak
case|:
block|{
name|input_sec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
if|if
condition|(
name|input_sec
operator|->
name|output_section
operator|!=
name|NULL
condition|)
block|{
name|sym
operator|.
name|st_shndx
operator|=
name|_bfd_elf_section_from_bfd_section
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|,
name|input_sec
operator|->
name|output_section
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|.
name|st_shndx
operator|==
name|SHN_BAD
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: could not find output section %s for input section %s"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|)
argument_list|,
name|input_sec
operator|->
name|output_section
operator|->
name|name
argument_list|,
name|input_sec
operator|->
name|name
argument_list|)
expr_stmt|;
name|eoinfo
operator|->
name|failed
operator|=
name|true
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* ELF symbols in relocateable files are section relative, 	       but in nonrelocateable files they are virtual 	       addresses.  */
name|sym
operator|.
name|st_value
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|input_sec
operator|->
name|output_offset
expr_stmt|;
if|if
condition|(
operator|!
name|finfo
operator|->
name|info
operator|->
name|relocateable
condition|)
name|sym
operator|.
name|st_value
operator|+=
name|input_sec
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
block|}
else|else
block|{
name|BFD_ASSERT
argument_list|(
name|input_sec
operator|->
name|owner
operator|==
name|NULL
operator|||
operator|(
name|input_sec
operator|->
name|owner
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|sym
operator|.
name|st_shndx
operator|=
name|SHN_UNDEF
expr_stmt|;
name|input_sec
operator|=
name|bfd_und_section_ptr
expr_stmt|;
block|}
block|}
break|break;
case|case
name|bfd_link_hash_common
case|:
name|input_sec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
expr_stmt|;
name|sym
operator|.
name|st_shndx
operator|=
name|SHN_COMMON
expr_stmt|;
name|sym
operator|.
name|st_value
operator|=
literal|1
operator|<<
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|alignment_power
expr_stmt|;
break|break;
case|case
name|bfd_link_hash_indirect
case|:
comment|/* These symbols are created by symbol versioning.  They point 	 to the decorated version of the name.  For example, if the 	 symbol foo@@GNU_1.2 is the default, which should be used when 	 foo is used with no version, then we add an indirect symbol 	 foo which points to foo@@GNU_1.2.  We ignore these symbols, 	 since the indirected symbol is already in the hash table.  */
return|return
name|true
return|;
block|}
comment|/* Give the processor backend a chance to tweak the symbol value,      and also to finish up anything that needs to be done for this      symbol.  FIXME: Not calling elf_backend_finish_dynamic_symbol for      forced local syms when non-shared is due to a historical quirk.  */
if|if
condition|(
operator|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_FORCED_LOCAL
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|finfo
operator|->
name|info
operator|->
name|shared
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_FORCED_LOCAL
operator|)
operator|==
literal|0
operator|)
operator|&&
name|elf_hash_table
argument_list|(
name|finfo
operator|->
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|bed
operator|->
name|elf_backend_finish_dynamic_symbol
call|)
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|,
name|finfo
operator|->
name|info
argument_list|,
name|h
argument_list|,
operator|&
name|sym
argument_list|)
operator|)
condition|)
block|{
name|eoinfo
operator|->
name|failed
operator|=
name|true
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
comment|/* If we are marking the symbol as undefined, and there are no      non-weak references to this symbol from a regular object, then      mark the symbol as weak undefined; if there are non-weak      references, mark the symbol as strong.  We can't do this earlier,      because it might not be marked as undefined until the      finish_dynamic_symbol routine gets through with it.  */
if|if
condition|(
name|sym
operator|.
name|st_shndx
operator|==
name|SHN_UNDEF
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_REF_REGULAR
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ELF_ST_BIND
argument_list|(
name|sym
operator|.
name|st_info
argument_list|)
operator|==
name|STB_GLOBAL
operator|||
name|ELF_ST_BIND
argument_list|(
name|sym
operator|.
name|st_info
argument_list|)
operator|==
name|STB_WEAK
operator|)
condition|)
block|{
name|int
name|bindtype
decl_stmt|;
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_REF_REGULAR_NONWEAK
operator|)
operator|!=
literal|0
condition|)
name|bindtype
operator|=
name|STB_GLOBAL
expr_stmt|;
else|else
name|bindtype
operator|=
name|STB_WEAK
expr_stmt|;
name|sym
operator|.
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|bindtype
argument_list|,
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|.
name|st_info
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If a symbol is not defined locally, we clear the visibility      field.  */
if|if
condition|(
operator|!
name|finfo
operator|->
name|info
operator|->
name|relocateable
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
condition|)
name|sym
operator|.
name|st_other
operator|^=
name|ELF_ST_VISIBILITY
argument_list|(
name|sym
operator|.
name|st_other
argument_list|)
expr_stmt|;
comment|/* If this symbol should be put in the .dynsym section, then put it      there now.  We have already know the symbol index.  We also fill      in the entry in the .hash section.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|&&
name|elf_hash_table
argument_list|(
name|finfo
operator|->
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
name|size_t
name|bucketcount
decl_stmt|;
name|size_t
name|bucket
decl_stmt|;
name|size_t
name|hash_entry_size
decl_stmt|;
name|bfd_byte
modifier|*
name|bucketpos
decl_stmt|;
name|bfd_vma
name|chain
decl_stmt|;
name|Elf_External_Sym
modifier|*
name|esym
decl_stmt|;
name|sym
operator|.
name|st_name
operator|=
name|h
operator|->
name|dynstr_index
expr_stmt|;
name|esym
operator|=
operator|(
name|Elf_External_Sym
operator|*
operator|)
name|finfo
operator|->
name|dynsym_sec
operator|->
name|contents
operator|+
name|h
operator|->
name|dynindx
expr_stmt|;
name|elf_swap_symbol_out
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|,
operator|&
name|sym
argument_list|,
operator|(
name|PTR
operator|)
name|esym
argument_list|,
operator|(
name|PTR
operator|)
literal|0
argument_list|)
expr_stmt|;
name|bucketcount
operator|=
name|elf_hash_table
argument_list|(
name|finfo
operator|->
name|info
argument_list|)
operator|->
name|bucketcount
expr_stmt|;
name|bucket
operator|=
name|h
operator|->
name|elf_hash_value
operator|%
name|bucketcount
expr_stmt|;
name|hash_entry_size
operator|=
name|elf_section_data
argument_list|(
name|finfo
operator|->
name|hash_sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
expr_stmt|;
name|bucketpos
operator|=
operator|(
operator|(
name|bfd_byte
operator|*
operator|)
name|finfo
operator|->
name|hash_sec
operator|->
name|contents
operator|+
operator|(
name|bucket
operator|+
literal|2
operator|)
operator|*
name|hash_entry_size
operator|)
expr_stmt|;
name|chain
operator|=
name|bfd_get
argument_list|(
literal|8
operator|*
name|hash_entry_size
argument_list|,
name|finfo
operator|->
name|output_bfd
argument_list|,
name|bucketpos
argument_list|)
expr_stmt|;
name|bfd_put
argument_list|(
literal|8
operator|*
name|hash_entry_size
argument_list|,
name|finfo
operator|->
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|h
operator|->
name|dynindx
argument_list|,
name|bucketpos
argument_list|)
expr_stmt|;
name|bfd_put
argument_list|(
literal|8
operator|*
name|hash_entry_size
argument_list|,
name|finfo
operator|->
name|output_bfd
argument_list|,
name|chain
argument_list|,
operator|(
operator|(
name|bfd_byte
operator|*
operator|)
name|finfo
operator|->
name|hash_sec
operator|->
name|contents
operator|+
operator|(
name|bucketcount
operator|+
literal|2
operator|+
name|h
operator|->
name|dynindx
operator|)
operator|*
name|hash_entry_size
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|->
name|symver_sec
operator|!=
name|NULL
operator|&&
name|finfo
operator|->
name|symver_sec
operator|->
name|contents
operator|!=
name|NULL
condition|)
block|{
name|Elf_Internal_Versym
name|iversym
decl_stmt|;
name|Elf_External_Versym
modifier|*
name|eversym
decl_stmt|;
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|verinfo
operator|.
name|verdef
operator|==
name|NULL
condition|)
name|iversym
operator|.
name|vs_vers
operator|=
literal|0
expr_stmt|;
else|else
name|iversym
operator|.
name|vs_vers
operator|=
name|h
operator|->
name|verinfo
operator|.
name|verdef
operator|->
name|vd_exp_refno
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|h
operator|->
name|verinfo
operator|.
name|vertree
operator|==
name|NULL
condition|)
name|iversym
operator|.
name|vs_vers
operator|=
literal|1
expr_stmt|;
else|else
name|iversym
operator|.
name|vs_vers
operator|=
name|h
operator|->
name|verinfo
operator|.
name|vertree
operator|->
name|vernum
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HIDDEN
operator|)
operator|!=
literal|0
condition|)
name|iversym
operator|.
name|vs_vers
operator||=
name|VERSYM_HIDDEN
expr_stmt|;
name|eversym
operator|=
operator|(
name|Elf_External_Versym
operator|*
operator|)
name|finfo
operator|->
name|symver_sec
operator|->
name|contents
expr_stmt|;
name|eversym
operator|+=
name|h
operator|->
name|dynindx
expr_stmt|;
name|_bfd_elf_swap_versym_out
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|,
operator|&
name|iversym
argument_list|,
name|eversym
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If we're stripping it, then it was just a dynamic symbol, and      there's nothing else to do.  */
if|if
condition|(
name|strip
condition|)
return|return
name|true
return|;
name|h
operator|->
name|indx
operator|=
name|bfd_get_symcount
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|elf_link_output_sym
argument_list|(
name|finfo
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
operator|&
name|sym
argument_list|,
name|input_sec
argument_list|)
condition|)
block|{
name|eoinfo
operator|->
name|failed
operator|=
name|true
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Copy the relocations indicated by the INTERNAL_RELOCS (which    originated from the section given by INPUT_REL_HDR) to the    OUTPUT_BFD.  */
end_comment

begin_function
specifier|static
name|void
name|elf_link_output_relocs
parameter_list|(
name|output_bfd
parameter_list|,
name|input_section
parameter_list|,
name|input_rel_hdr
parameter_list|,
name|internal_relocs
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|input_rel_hdr
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|;
block|{
name|Elf_Internal_Rela
modifier|*
name|irela
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irelaend
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|output_rel_hdr
decl_stmt|;
name|asection
modifier|*
name|output_section
decl_stmt|;
name|unsigned
name|int
modifier|*
name|rel_countp
init|=
name|NULL
decl_stmt|;
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|output_section
operator|=
name|input_section
operator|->
name|output_section
expr_stmt|;
name|output_rel_hdr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|elf_section_data
argument_list|(
name|output_section
argument_list|)
operator|->
name|rel_hdr
operator|.
name|sh_entsize
operator|==
name|input_rel_hdr
operator|->
name|sh_entsize
condition|)
block|{
name|output_rel_hdr
operator|=
operator|&
name|elf_section_data
argument_list|(
name|output_section
argument_list|)
operator|->
name|rel_hdr
expr_stmt|;
name|rel_countp
operator|=
operator|&
name|elf_section_data
argument_list|(
name|output_section
argument_list|)
operator|->
name|rel_count
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|elf_section_data
argument_list|(
name|output_section
argument_list|)
operator|->
name|rel_hdr2
operator|&&
operator|(
name|elf_section_data
argument_list|(
name|output_section
argument_list|)
operator|->
name|rel_hdr2
operator|->
name|sh_entsize
operator|==
name|input_rel_hdr
operator|->
name|sh_entsize
operator|)
condition|)
block|{
name|output_rel_hdr
operator|=
name|elf_section_data
argument_list|(
name|output_section
argument_list|)
operator|->
name|rel_hdr2
expr_stmt|;
name|rel_countp
operator|=
operator|&
name|elf_section_data
argument_list|(
name|output_section
argument_list|)
operator|->
name|rel_count2
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
name|output_rel_hdr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
name|irela
operator|=
name|internal_relocs
expr_stmt|;
name|irelaend
operator|=
name|irela
operator|+
name|NUM_SHDR_ENTRIES
argument_list|(
name|input_rel_hdr
argument_list|)
operator|*
name|bed
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
expr_stmt|;
if|if
condition|(
name|input_rel_hdr
operator|->
name|sh_entsize
operator|==
sizeof|sizeof
argument_list|(
name|Elf_External_Rel
argument_list|)
condition|)
block|{
name|Elf_External_Rel
modifier|*
name|erel
decl_stmt|;
name|Elf_Internal_Rel
modifier|*
name|irel
decl_stmt|;
name|amt
operator|=
name|bed
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Internal_Rel
argument_list|)
expr_stmt|;
name|irel
operator|=
operator|(
name|Elf_Internal_Rel
operator|*
operator|)
name|bfd_zmalloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|irel
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Error: out of memory"
argument_list|)
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|erel
operator|=
operator|(
operator|(
name|Elf_External_Rel
operator|*
operator|)
name|output_rel_hdr
operator|->
name|contents
operator|+
operator|*
name|rel_countp
operator|)
expr_stmt|;
for|for
control|(
init|;
name|irela
operator|<
name|irelaend
condition|;
name|irela
operator|+=
name|bed
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
operator|,
name|erel
operator|++
control|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bed
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
condition|;
name|i
operator|++
control|)
block|{
name|irel
index|[
name|i
index|]
operator|.
name|r_offset
operator|=
name|irela
index|[
name|i
index|]
operator|.
name|r_offset
expr_stmt|;
name|irel
index|[
name|i
index|]
operator|.
name|r_info
operator|=
name|irela
index|[
name|i
index|]
operator|.
name|r_info
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|irela
index|[
name|i
index|]
operator|.
name|r_addend
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bed
operator|->
name|s
operator|->
name|swap_reloc_out
condition|)
call|(
modifier|*
name|bed
operator|->
name|s
operator|->
name|swap_reloc_out
call|)
argument_list|(
name|output_bfd
argument_list|,
name|irel
argument_list|,
operator|(
name|PTR
operator|)
name|erel
argument_list|)
expr_stmt|;
else|else
name|elf_swap_reloc_out
argument_list|(
name|output_bfd
argument_list|,
name|irel
argument_list|,
name|erel
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|irel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Elf_External_Rela
modifier|*
name|erela
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|input_rel_hdr
operator|->
name|sh_entsize
operator|==
sizeof|sizeof
argument_list|(
name|Elf_External_Rela
argument_list|)
argument_list|)
expr_stmt|;
name|erela
operator|=
operator|(
operator|(
name|Elf_External_Rela
operator|*
operator|)
name|output_rel_hdr
operator|->
name|contents
operator|+
operator|*
name|rel_countp
operator|)
expr_stmt|;
for|for
control|(
init|;
name|irela
operator|<
name|irelaend
condition|;
name|irela
operator|+=
name|bed
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
operator|,
name|erela
operator|++
control|)
if|if
condition|(
name|bed
operator|->
name|s
operator|->
name|swap_reloca_out
condition|)
call|(
modifier|*
name|bed
operator|->
name|s
operator|->
name|swap_reloca_out
call|)
argument_list|(
name|output_bfd
argument_list|,
name|irela
argument_list|,
operator|(
name|PTR
operator|)
name|erela
argument_list|)
expr_stmt|;
else|else
name|elf_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
name|irela
argument_list|,
name|erela
argument_list|)
expr_stmt|;
block|}
comment|/* Bump the counter, so that we know where to add the next set of      relocations.  */
operator|*
name|rel_countp
operator|+=
name|NUM_SHDR_ENTRIES
argument_list|(
name|input_rel_hdr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Link an input file into the linker output file.  This function    handles all the sections and relocations of the input file at once.    This is so that we only have to read the local symbols once, and    don't have to keep them in memory.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf_link_input_bfd
parameter_list|(
name|finfo
parameter_list|,
name|input_bfd
parameter_list|)
name|struct
name|elf_final_link_info
modifier|*
name|finfo
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
block|{
name|boolean
argument_list|(
argument|*relocate_section
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|,
name|asection
operator|*
operator|*
operator|)
argument_list|)
expr_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|shndx_hdr
decl_stmt|;
name|size_t
name|locsymcount
decl_stmt|;
name|size_t
name|extsymoff
decl_stmt|;
name|Elf_External_Sym
modifier|*
name|external_syms
decl_stmt|;
name|Elf_External_Sym
modifier|*
name|esym
decl_stmt|;
name|Elf_External_Sym
modifier|*
name|esymend
decl_stmt|;
name|Elf_External_Sym_Shndx
modifier|*
name|shndx_buf
decl_stmt|;
name|Elf_External_Sym_Shndx
modifier|*
name|shndx
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isym
decl_stmt|;
name|long
modifier|*
name|pindex
decl_stmt|;
name|asection
modifier|*
modifier|*
name|ppsection
decl_stmt|;
name|asection
modifier|*
name|o
decl_stmt|;
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
name|boolean
name|emit_relocs
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|output_bfd
operator|=
name|finfo
operator|->
name|output_bfd
expr_stmt|;
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
name|relocate_section
operator|=
name|bed
operator|->
name|elf_backend_relocate_section
expr_stmt|;
comment|/* If this is a dynamic object, we don't want to do anything here:      we don't want the local symbols, and we don't want the section      contents.  */
if|if
condition|(
operator|(
name|input_bfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
condition|)
return|return
name|true
return|;
name|emit_relocs
operator|=
operator|(
name|finfo
operator|->
name|info
operator|->
name|relocateable
operator|||
name|finfo
operator|->
name|info
operator|->
name|emitrelocations
operator|||
name|bed
operator|->
name|elf_backend_emit_relocs
operator|)
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
if|if
condition|(
name|elf_bad_symtab
argument_list|(
name|input_bfd
argument_list|)
condition|)
block|{
name|locsymcount
operator|=
name|symtab_hdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
expr_stmt|;
name|extsymoff
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|locsymcount
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|extsymoff
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
block|}
comment|/* Read the local symbols.  */
if|if
condition|(
name|symtab_hdr
operator|->
name|contents
operator|!=
name|NULL
condition|)
name|external_syms
operator|=
operator|(
name|Elf_External_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
elseif|else
if|if
condition|(
name|locsymcount
operator|==
literal|0
condition|)
name|external_syms
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|bfd_size_type
name|amt
init|=
name|locsymcount
operator|*
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
decl_stmt|;
name|external_syms
operator|=
name|finfo
operator|->
name|external_syms
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bread
argument_list|(
name|external_syms
argument_list|,
name|amt
argument_list|,
name|input_bfd
argument_list|)
operator|!=
name|amt
condition|)
return|return
name|false
return|;
block|}
name|shndx_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_shndx_hdr
expr_stmt|;
name|shndx_buf
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|shndx_hdr
operator|->
name|sh_size
operator|!=
literal|0
operator|&&
name|locsymcount
operator|!=
literal|0
condition|)
block|{
name|bfd_size_type
name|amt
init|=
name|locsymcount
operator|*
sizeof|sizeof
argument_list|(
name|Elf_External_Sym_Shndx
argument_list|)
decl_stmt|;
name|shndx_buf
operator|=
name|finfo
operator|->
name|locsym_shndx
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|input_bfd
argument_list|,
name|shndx_hdr
operator|->
name|sh_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bread
argument_list|(
name|shndx_buf
argument_list|,
name|amt
argument_list|,
name|input_bfd
argument_list|)
operator|!=
name|amt
condition|)
return|return
name|false
return|;
block|}
comment|/* Swap in the local symbols and write out the ones which we know      are going into the output file.  */
for|for
control|(
name|esym
operator|=
name|external_syms
operator|,
name|esymend
operator|=
name|esym
operator|+
name|locsymcount
operator|,
name|isym
operator|=
name|finfo
operator|->
name|internal_syms
operator|,
name|pindex
operator|=
name|finfo
operator|->
name|indices
operator|,
name|ppsection
operator|=
name|finfo
operator|->
name|sections
operator|,
name|shndx
operator|=
name|shndx_buf
init|;
name|esym
operator|<
name|esymend
condition|;
name|esym
operator|++
operator|,
name|isym
operator|++
operator|,
name|pindex
operator|++
operator|,
name|ppsection
operator|++
operator|,
name|shndx
operator|=
operator|(
name|shndx
operator|!=
name|NULL
condition|?
name|shndx
operator|+
literal|1
else|:
name|NULL
operator|)
control|)
block|{
name|asection
modifier|*
name|isec
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|Elf_Internal_Sym
name|osym
decl_stmt|;
name|elf_swap_symbol_in
argument_list|(
name|input_bfd
argument_list|,
name|esym
argument_list|,
name|shndx
argument_list|,
name|isym
argument_list|)
expr_stmt|;
operator|*
name|pindex
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|elf_bad_symtab
argument_list|(
name|input_bfd
argument_list|)
condition|)
block|{
if|if
condition|(
name|ELF_ST_BIND
argument_list|(
name|isym
operator|->
name|st_info
argument_list|)
operator|!=
name|STB_LOCAL
condition|)
block|{
operator|*
name|ppsection
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_UNDEF
condition|)
name|isec
operator|=
name|bfd_und_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|<
name|SHN_LORESERVE
operator|||
name|isym
operator|->
name|st_shndx
operator|>
name|SHN_HIRESERVE
condition|)
block|{
name|isec
operator|=
name|section_from_elf_index
argument_list|(
name|input_bfd
argument_list|,
name|isym
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|isec
operator|&&
name|elf_section_data
argument_list|(
name|isec
argument_list|)
operator|->
name|sec_info_type
operator|==
name|ELF_INFO_TYPE_MERGE
operator|&&
name|ELF_ST_TYPE
argument_list|(
name|isym
operator|->
name|st_info
argument_list|)
operator|!=
name|STT_SECTION
condition|)
name|isym
operator|->
name|st_value
operator|=
name|_bfd_merged_section_offset
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|isec
argument_list|,
name|elf_section_data
argument_list|(
name|isec
argument_list|)
operator|->
name|sec_info
argument_list|,
name|isym
operator|->
name|st_value
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_ABS
condition|)
name|isec
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_COMMON
condition|)
name|isec
operator|=
name|bfd_com_section_ptr
expr_stmt|;
else|else
block|{
comment|/* Who knows?  */
name|isec
operator|=
name|NULL
expr_stmt|;
block|}
operator|*
name|ppsection
operator|=
name|isec
expr_stmt|;
comment|/* Don't output the first, undefined, symbol.  */
if|if
condition|(
name|esym
operator|==
name|external_syms
condition|)
continue|continue;
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|isym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_SECTION
condition|)
block|{
comment|/* We never output section symbols.  Instead, we use the 	     section symbol of the corresponding section in the output 	     file.  */
continue|continue;
block|}
comment|/* If we are stripping all symbols, we don't want to output this 	 one.  */
if|if
condition|(
name|finfo
operator|->
name|info
operator|->
name|strip
operator|==
name|strip_all
condition|)
continue|continue;
comment|/* If we are discarding all local symbols, we don't want to 	 output this one.  If we are generating a relocateable output 	 file, then some of the local symbols may be required by 	 relocs; we output them below as we discover that they are 	 needed.  */
if|if
condition|(
name|finfo
operator|->
name|info
operator|->
name|discard
operator|==
name|discard_all
condition|)
continue|continue;
comment|/* If this symbol is defined in a section which we are 	 discarding, we don't need to keep it, but note that 	 linker_mark is only reliable for sections that have contents. 	 For the benefit of the MIPS ELF linker, we check SEC_EXCLUDE 	 as well as linker_mark.  */
if|if
condition|(
operator|(
name|isym
operator|->
name|st_shndx
operator|<
name|SHN_LORESERVE
operator|||
name|isym
operator|->
name|st_shndx
operator|>
name|SHN_HIRESERVE
operator|)
operator|&&
name|isec
operator|!=
name|NULL
operator|&&
operator|(
operator|(
operator|!
name|isec
operator|->
name|linker_mark
operator|&&
operator|(
name|isec
operator|->
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|!
name|finfo
operator|->
name|info
operator|->
name|relocateable
operator|&&
operator|(
name|isec
operator|->
name|flags
operator|&
name|SEC_EXCLUDE
operator|)
operator|!=
literal|0
operator|)
operator|)
condition|)
continue|continue;
comment|/* Get the name of the symbol.  */
name|name
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_link
argument_list|,
name|isym
operator|->
name|st_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|false
return|;
comment|/* See if we are discarding symbols with this name.  */
if|if
condition|(
operator|(
name|finfo
operator|->
name|info
operator|->
name|strip
operator|==
name|strip_some
operator|&&
operator|(
name|bfd_hash_lookup
argument_list|(
name|finfo
operator|->
name|info
operator|->
name|keep_hash
argument_list|,
name|name
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
operator|==
name|NULL
operator|)
operator|)
operator|||
operator|(
operator|(
operator|(
name|finfo
operator|->
name|info
operator|->
name|discard
operator|==
name|discard_sec_merge
operator|&&
operator|(
name|isec
operator|->
name|flags
operator|&
name|SEC_MERGE
operator|)
operator|&&
operator|!
name|finfo
operator|->
name|info
operator|->
name|relocateable
operator|)
operator|||
name|finfo
operator|->
name|info
operator|->
name|discard
operator|==
name|discard_l
operator|)
operator|&&
name|bfd_is_local_label_name
argument_list|(
name|input_bfd
argument_list|,
name|name
argument_list|)
operator|)
condition|)
continue|continue;
comment|/* If we get here, we are going to output this symbol.  */
name|osym
operator|=
operator|*
name|isym
expr_stmt|;
comment|/* Adjust the section index for the output file.  */
name|osym
operator|.
name|st_shndx
operator|=
name|_bfd_elf_section_from_bfd_section
argument_list|(
name|output_bfd
argument_list|,
name|isec
operator|->
name|output_section
argument_list|)
expr_stmt|;
if|if
condition|(
name|osym
operator|.
name|st_shndx
operator|==
name|SHN_BAD
condition|)
return|return
name|false
return|;
operator|*
name|pindex
operator|=
name|bfd_get_symcount
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
comment|/* ELF symbols in relocateable files are section relative, but 	 in executable files they are virtual addresses.  Note that 	 this code assumes that all ELF sections have an associated 	 BFD section with a reasonable value for output_offset; below 	 we assume that they also have a reasonable value for 	 output_section.  Any special sections must be set up to meet 	 these requirements.  */
name|osym
operator|.
name|st_value
operator|+=
name|isec
operator|->
name|output_offset
expr_stmt|;
if|if
condition|(
operator|!
name|finfo
operator|->
name|info
operator|->
name|relocateable
condition|)
name|osym
operator|.
name|st_value
operator|+=
name|isec
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
if|if
condition|(
operator|!
name|elf_link_output_sym
argument_list|(
name|finfo
argument_list|,
name|name
argument_list|,
operator|&
name|osym
argument_list|,
name|isec
argument_list|)
condition|)
return|return
name|false
return|;
block|}
comment|/* Relocate the contents of each section.  */
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
for|for
control|(
name|o
operator|=
name|input_bfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
if|if
condition|(
operator|!
name|o
operator|->
name|linker_mark
condition|)
block|{
comment|/* This section was omitted from the link.  */
continue|continue;
block|}
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|==
literal|0
operator|||
operator|(
name|o
operator|->
name|_raw_size
operator|==
literal|0
operator|&&
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_LINKER_CREATED
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Section was created by elf_link_create_dynamic_sections 	     or somesuch.  */
continue|continue;
block|}
comment|/* Get the contents of the section.  They have been cached by a 	 relaxation routine.  Note that o is a section in an input 	 file, so the contents field will not have been set by any of 	 the routines which work on output files.  */
if|if
condition|(
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|NULL
condition|)
name|contents
operator|=
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
expr_stmt|;
else|else
block|{
name|contents
operator|=
name|finfo
operator|->
name|contents
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|input_bfd
argument_list|,
name|o
argument_list|,
name|contents
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|o
operator|->
name|_raw_size
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|!=
literal|0
condition|)
block|{
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|;
comment|/* Get the swapped relocs.  */
name|internal_relocs
operator|=
operator|(
name|NAME
argument_list|(
name|_bfd_elf
argument_list|,
name|link_read_relocs
argument_list|)
argument_list|(
name|input_bfd
argument_list|,
name|o
argument_list|,
name|finfo
operator|->
name|external_relocs
argument_list|,
name|finfo
operator|->
name|internal_relocs
argument_list|,
name|false
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
operator|&&
name|o
operator|->
name|reloc_count
operator|>
literal|0
condition|)
return|return
name|false
return|;
comment|/* Run through the relocs looking for any against symbols 	     from discarded sections and section symbols from 	     removed link-once sections.  Complain about relocs 	     against discarded sections.  Zero relocs against removed 	     link-once sections.  We should really complain if 	     anything in the final link tries to use it, but 	     DWARF-based exception handling might have an entry in 	     .eh_frame to describe a routine in the linkonce section, 	     and it turns out to be hard to remove the .eh_frame 	     entry too.  FIXME.  */
if|if
condition|(
operator|!
name|finfo
operator|->
name|info
operator|->
name|relocateable
operator|&&
operator|!
name|elf_section_ignore_discarded_relocs
argument_list|(
name|o
argument_list|)
condition|)
block|{
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|,
modifier|*
name|relend
decl_stmt|;
name|rel
operator|=
name|internal_relocs
expr_stmt|;
name|relend
operator|=
name|rel
operator|+
name|o
operator|->
name|reloc_count
operator|*
name|bed
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
expr_stmt|;
for|for
control|(
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|unsigned
name|long
name|r_symndx
init|=
name|ELF_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
decl_stmt|;
if|if
condition|(
name|r_symndx
operator|>=
name|locsymcount
operator|||
operator|(
name|elf_bad_symtab
argument_list|(
name|input_bfd
argument_list|)
operator|&&
name|finfo
operator|->
name|sections
index|[
name|r_symndx
index|]
operator|==
name|NULL
operator|)
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|extsymoff
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
comment|/* Complain if the definition comes from a 			 discarded section.  */
if|if
condition|(
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
name|elf_discarded_section
argument_list|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
argument_list|)
condition|)
block|{
if|#
directive|if
name|BFD_VERSION_DATE
operator|<
literal|20031005
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_DEBUGGING
operator|)
operator|!=
literal|0
condition|)
block|{
if|#
directive|if
name|BFD_VERSION_DATE
operator|>
literal|20021005
call|(
modifier|*
name|finfo
operator|->
name|info
operator|->
name|callbacks
operator|->
name|warning
call|)
argument_list|(
name|finfo
operator|->
name|info
argument_list|,
name|_
argument_list|(
literal|"warning: relocation against removed section; zeroing"
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|input_bfd
argument_list|,
name|o
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|BFD_ASSERT
argument_list|(
name|r_symndx
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|rel
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rel
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|finfo
operator|->
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|finfo
operator|->
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|input_bfd
argument_list|,
name|o
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|true
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
block|}
block|}
block|}
else|else
block|{
name|asection
modifier|*
name|sec
init|=
name|finfo
operator|->
name|sections
index|[
name|r_symndx
index|]
decl_stmt|;
if|if
condition|(
name|sec
operator|!=
name|NULL
operator|&&
name|elf_discarded_section
argument_list|(
name|sec
argument_list|)
condition|)
block|{
if|#
directive|if
name|BFD_VERSION_DATE
operator|<
literal|20031005
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_DEBUGGING
operator|)
operator|!=
literal|0
operator|||
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_LINK_ONCE
operator|)
operator|!=
literal|0
condition|)
block|{
if|#
directive|if
name|BFD_VERSION_DATE
operator|>
literal|20021005
call|(
modifier|*
name|finfo
operator|->
name|info
operator|->
name|callbacks
operator|->
name|warning
call|)
argument_list|(
name|finfo
operator|->
name|info
argument_list|,
name|_
argument_list|(
literal|"warning: relocation against removed section"
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|input_bfd
argument_list|,
name|o
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|BFD_ASSERT
argument_list|(
name|r_symndx
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|rel
operator|->
name|r_info
operator|=
name|ELF_R_INFO
argument_list|(
literal|0
argument_list|,
name|ELF_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
argument_list|)
expr_stmt|;
name|rel
operator|->
name|r_addend
operator|=
literal|0
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|boolean
name|ok
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
init|=
name|_
argument_list|(
literal|"local symbols in discarded section %s"
argument_list|)
decl_stmt|;
name|bfd_size_type
name|amt
init|=
name|strlen
argument_list|(
name|sec
operator|->
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|msg
argument_list|)
operator|-
literal|1
decl_stmt|;
name|char
modifier|*
name|buf
init|=
operator|(
name|char
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
decl_stmt|;
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
name|msg
argument_list|,
name|sec
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|sec
operator|->
name|name
expr_stmt|;
name|ok
operator|=
call|(
modifier|*
name|finfo
operator|->
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|finfo
operator|->
name|info
argument_list|,
name|buf
argument_list|,
name|input_bfd
argument_list|,
name|o
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
name|sec
operator|->
name|name
condition|)
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|false
return|;
block|}
block|}
block|}
block|}
block|}
comment|/* Relocate the section by invoking a back end routine.  	     The back end routine is responsible for adjusting the 	     section contents as necessary, and (if using Rela relocs 	     and generating a relocateable output file) adjusting the 	     reloc addend as necessary.  	     The back end routine does not have to worry about setting 	     the reloc address or the reloc symbol index.  	     The back end routine is given a pointer to the swapped in 	     internal symbols, and can access the hash table entries 	     for the external symbols via elf_sym_hashes (input_bfd).  	     When generating relocateable output, the back end routine 	     must handle STB_LOCAL/STT_SECTION symbols specially.  The 	     output symbol is going to be a section symbol 	     corresponding to the output section, which will require 	     the addend to be adjusted.  */
if|if
condition|(
operator|!
call|(
modifier|*
name|relocate_section
call|)
argument_list|(
name|output_bfd
argument_list|,
name|finfo
operator|->
name|info
argument_list|,
name|input_bfd
argument_list|,
name|o
argument_list|,
name|contents
argument_list|,
name|internal_relocs
argument_list|,
name|finfo
operator|->
name|internal_syms
argument_list|,
name|finfo
operator|->
name|sections
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|emit_relocs
condition|)
block|{
name|Elf_Internal_Rela
modifier|*
name|irela
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irelaend
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|rel_hash
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|input_rel_hdr
decl_stmt|;
name|unsigned
name|int
name|next_erel
decl_stmt|;
name|void
argument_list|(
argument|*reloc_emitter
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|Elf_Internal_Shdr
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* Adjust the reloc addresses and symbol indices.  */
name|irela
operator|=
name|internal_relocs
expr_stmt|;
name|irelaend
operator|=
name|irela
operator|+
name|o
operator|->
name|reloc_count
operator|*
name|bed
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
expr_stmt|;
name|rel_hash
operator|=
operator|(
name|elf_section_data
argument_list|(
name|o
operator|->
name|output_section
argument_list|)
operator|->
name|rel_hashes
operator|+
name|elf_section_data
argument_list|(
name|o
operator|->
name|output_section
argument_list|)
operator|->
name|rel_count
operator|+
name|elf_section_data
argument_list|(
name|o
operator|->
name|output_section
argument_list|)
operator|->
name|rel_count2
operator|)
expr_stmt|;
for|for
control|(
name|next_erel
operator|=
literal|0
init|;
name|irela
operator|<
name|irelaend
condition|;
name|irela
operator|++
operator|,
name|next_erel
operator|++
control|)
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
if|if
condition|(
name|next_erel
operator|==
name|bed
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
condition|)
block|{
name|rel_hash
operator|++
expr_stmt|;
name|next_erel
operator|=
literal|0
expr_stmt|;
block|}
name|irela
operator|->
name|r_offset
operator|+=
name|o
operator|->
name|output_offset
expr_stmt|;
comment|/* Relocs in an executable have to be virtual addresses.  */
if|if
condition|(
name|finfo
operator|->
name|info
operator|->
name|emitrelocations
condition|)
name|irela
operator|->
name|r_offset
operator|+=
name|o
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|r_symndx
operator|=
name|ELF_R_SYM
argument_list|(
name|irela
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|r_symndx
operator|>=
name|locsymcount
operator|||
operator|(
name|elf_bad_symtab
argument_list|(
name|input_bfd
argument_list|)
operator|&&
name|finfo
operator|->
name|sections
index|[
name|r_symndx
index|]
operator|==
name|NULL
operator|)
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|rh
decl_stmt|;
name|unsigned
name|long
name|indx
decl_stmt|;
comment|/* This is a reloc against a global symbol.  We 			 have not yet output all the local symbols, so 			 we do not know the symbol index of any global 			 symbol.  We set the rel_hash entry for this 			 reloc to point to the global hash table entry 			 for this symbol.  The symbol index is then 			 set at the end of elf_bfd_final_link.  */
name|indx
operator|=
name|r_symndx
operator|-
name|extsymoff
expr_stmt|;
name|rh
operator|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
index|[
name|indx
index|]
expr_stmt|;
while|while
condition|(
name|rh
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|rh
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|rh
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|rh
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
comment|/* Setting the index to -2 tells 			 elf_link_output_extsym that this symbol is 			 used by a reloc.  */
name|BFD_ASSERT
argument_list|(
name|rh
operator|->
name|indx
operator|<
literal|0
argument_list|)
expr_stmt|;
name|rh
operator|->
name|indx
operator|=
operator|-
literal|2
expr_stmt|;
operator|*
name|rel_hash
operator|=
name|rh
expr_stmt|;
continue|continue;
block|}
comment|/* This is a reloc against a local symbol.  */
operator|*
name|rel_hash
operator|=
name|NULL
expr_stmt|;
name|isym
operator|=
name|finfo
operator|->
name|internal_syms
operator|+
name|r_symndx
expr_stmt|;
name|sec
operator|=
name|finfo
operator|->
name|sections
index|[
name|r_symndx
index|]
expr_stmt|;
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|isym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_SECTION
condition|)
block|{
comment|/* I suppose the backend ought to fill in the 			 section of any STT_SECTION symbol against a 			 processor specific section.  If we have 			 discarded a section, the output_section will 			 be the absolute section.  */
if|if
condition|(
name|sec
operator|!=
name|NULL
operator|&&
operator|(
name|bfd_is_abs_section
argument_list|(
name|sec
argument_list|)
operator|||
operator|(
name|sec
operator|->
name|output_section
operator|!=
name|NULL
operator|&&
name|bfd_is_abs_section
argument_list|(
name|sec
operator|->
name|output_section
argument_list|)
operator|)
operator|)
condition|)
name|r_symndx
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|sec
operator|==
name|NULL
operator|||
name|sec
operator|->
name|owner
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
else|else
block|{
name|r_symndx
operator|=
name|sec
operator|->
name|output_section
operator|->
name|target_index
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|r_symndx
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|finfo
operator|->
name|indices
index|[
name|r_symndx
index|]
operator|==
operator|-
literal|1
condition|)
block|{
name|unsigned
name|long
name|shlink
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|asection
modifier|*
name|osec
decl_stmt|;
if|if
condition|(
name|finfo
operator|->
name|info
operator|->
name|strip
operator|==
name|strip_all
condition|)
block|{
comment|/* You can't do ld -r -s.  */
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* This symbol was skipped earlier, but 			     since it is needed by a reloc, we 			     must output it now.  */
name|shlink
operator|=
name|symtab_hdr
operator|->
name|sh_link
expr_stmt|;
name|name
operator|=
operator|(
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|shlink
argument_list|,
name|isym
operator|->
name|st_name
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|osec
operator|=
name|sec
operator|->
name|output_section
expr_stmt|;
name|isym
operator|->
name|st_shndx
operator|=
name|_bfd_elf_section_from_bfd_section
argument_list|(
name|output_bfd
argument_list|,
name|osec
argument_list|)
expr_stmt|;
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_BAD
condition|)
return|return
name|false
return|;
name|isym
operator|->
name|st_value
operator|+=
name|sec
operator|->
name|output_offset
expr_stmt|;
if|if
condition|(
operator|!
name|finfo
operator|->
name|info
operator|->
name|relocateable
condition|)
name|isym
operator|->
name|st_value
operator|+=
name|osec
operator|->
name|vma
expr_stmt|;
name|finfo
operator|->
name|indices
index|[
name|r_symndx
index|]
operator|=
name|bfd_get_symcount
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|elf_link_output_sym
argument_list|(
name|finfo
argument_list|,
name|name
argument_list|,
name|isym
argument_list|,
name|sec
argument_list|)
condition|)
return|return
name|false
return|;
block|}
name|r_symndx
operator|=
name|finfo
operator|->
name|indices
index|[
name|r_symndx
index|]
expr_stmt|;
block|}
name|irela
operator|->
name|r_info
operator|=
name|ELF_R_INFO
argument_list|(
name|r_symndx
argument_list|,
name|ELF_R_TYPE
argument_list|(
name|irela
operator|->
name|r_info
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Swap out the relocs.  */
if|if
condition|(
name|bed
operator|->
name|elf_backend_emit_relocs
operator|&&
operator|!
operator|(
name|finfo
operator|->
name|info
operator|->
name|relocateable
operator|||
name|finfo
operator|->
name|info
operator|->
name|emitrelocations
operator|)
condition|)
name|reloc_emitter
operator|=
name|bed
operator|->
name|elf_backend_emit_relocs
expr_stmt|;
else|else
name|reloc_emitter
operator|=
name|elf_link_output_relocs
expr_stmt|;
name|input_rel_hdr
operator|=
operator|&
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_hdr
expr_stmt|;
call|(
modifier|*
name|reloc_emitter
call|)
argument_list|(
name|output_bfd
argument_list|,
name|o
argument_list|,
name|input_rel_hdr
argument_list|,
name|internal_relocs
argument_list|)
expr_stmt|;
name|input_rel_hdr
operator|=
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_hdr2
expr_stmt|;
if|if
condition|(
name|input_rel_hdr
condition|)
block|{
name|internal_relocs
operator|+=
operator|(
name|NUM_SHDR_ENTRIES
argument_list|(
name|input_rel_hdr
argument_list|)
operator|*
name|bed
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
operator|)
expr_stmt|;
name|reloc_emitter
argument_list|(
name|output_bfd
argument_list|,
name|o
argument_list|,
name|input_rel_hdr
argument_list|,
name|internal_relocs
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Write out the modified section contents.  */
if|if
condition|(
name|bed
operator|->
name|elf_backend_write_section
operator|&&
call|(
modifier|*
name|bed
operator|->
name|elf_backend_write_section
call|)
argument_list|(
name|output_bfd
argument_list|,
name|o
argument_list|,
name|contents
argument_list|)
condition|)
block|{
comment|/* Section written out.  */
block|}
else|else
switch|switch
condition|(
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|sec_info_type
condition|)
block|{
case|case
name|ELF_INFO_TYPE_STABS
case|:
if|if
condition|(
operator|!
operator|(
name|_bfd_write_section_stabs
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|elf_hash_table
argument_list|(
name|finfo
operator|->
name|info
argument_list|)
operator|->
name|stab_info
argument_list|,
name|o
argument_list|,
operator|&
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|sec_info
argument_list|,
name|contents
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|ELF_INFO_TYPE_MERGE
case|:
if|if
condition|(
operator|!
operator|(
name|_bfd_write_merged_section
argument_list|(
name|output_bfd
argument_list|,
name|o
argument_list|,
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|sec_info
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|ELF_INFO_TYPE_EH_FRAME
case|:
block|{
name|asection
modifier|*
name|ehdrsec
decl_stmt|;
name|ehdrsec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|elf_hash_table
argument_list|(
name|finfo
operator|->
name|info
argument_list|)
operator|->
name|dynobj
argument_list|,
literal|".eh_frame_hdr"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|_bfd_elf_write_section_eh_frame
argument_list|(
name|output_bfd
argument_list|,
name|o
argument_list|,
name|ehdrsec
argument_list|,
name|contents
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
block|}
break|break;
default|default:
block|{
name|bfd_size_type
name|sec_size
decl_stmt|;
name|sec_size
operator|=
operator|(
name|o
operator|->
name|_cooked_size
operator|!=
literal|0
condition|?
name|o
operator|->
name|_cooked_size
else|:
name|o
operator|->
name|_raw_size
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_EXCLUDE
operator|)
operator|&&
operator|!
name|bfd_set_section_contents
argument_list|(
name|output_bfd
argument_list|,
name|o
operator|->
name|output_section
argument_list|,
name|contents
argument_list|,
operator|(
name|file_ptr
operator|)
name|o
operator|->
name|output_offset
argument_list|,
name|sec_size
argument_list|)
condition|)
return|return
name|false
return|;
block|}
break|break;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Generate a reloc when linking an ELF file.  This is a reloc    requested by the linker, and does come from any input file.  This    is used to build constructor and destructor tables when linking    with -Ur.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf_reloc_link_order
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|output_section
parameter_list|,
name|link_order
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|asection
modifier|*
name|output_section
decl_stmt|;
name|struct
name|bfd_link_order
modifier|*
name|link_order
decl_stmt|;
block|{
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|long
name|indx
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|rel_hash_ptr
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|rel_hdr
decl_stmt|;
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|output_bfd
argument_list|)
decl_stmt|;
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|output_bfd
argument_list|,
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|reloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|howto
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|addend
operator|=
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|addend
expr_stmt|;
comment|/* Figure out the symbol index.  */
name|rel_hash_ptr
operator|=
operator|(
name|elf_section_data
argument_list|(
name|output_section
argument_list|)
operator|->
name|rel_hashes
operator|+
name|elf_section_data
argument_list|(
name|output_section
argument_list|)
operator|->
name|rel_count
operator|+
name|elf_section_data
argument_list|(
name|output_section
argument_list|)
operator|->
name|rel_count2
operator|)
expr_stmt|;
if|if
condition|(
name|link_order
operator|->
name|type
operator|==
name|bfd_section_reloc_link_order
condition|)
block|{
name|indx
operator|=
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|u
operator|.
name|section
operator|->
name|target_index
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|indx
operator|!=
literal|0
argument_list|)
expr_stmt|;
operator|*
name|rel_hash_ptr
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
comment|/* Treat a reloc against a defined symbol as though it were 	 actually against the section.  */
name|h
operator|=
operator|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|bfd_wrapped_link_hash_lookup
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|u
operator|.
name|name
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
condition|)
block|{
name|asection
modifier|*
name|section
decl_stmt|;
name|section
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|indx
operator|=
name|section
operator|->
name|output_section
operator|->
name|target_index
expr_stmt|;
operator|*
name|rel_hash_ptr
operator|=
name|NULL
expr_stmt|;
comment|/* It seems that we ought to add the symbol value to the 	     addend here, but in practice it has already been added 	     because it was passed to constructor_callback.  */
name|addend
operator|+=
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|section
operator|->
name|output_offset
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
comment|/* Setting the index to -2 tells elf_link_output_extsym that 	     this symbol is used by a reloc.  */
name|h
operator|->
name|indx
operator|=
operator|-
literal|2
expr_stmt|;
operator|*
name|rel_hash_ptr
operator|=
name|h
expr_stmt|;
name|indx
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|unattached_reloc
call|)
argument_list|(
name|info
argument_list|,
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|u
operator|.
name|name
argument_list|,
operator|(
name|bfd
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|asection
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
name|indx
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* If this is an inplace reloc, we must write the addend into the      object file.  */
if|if
condition|(
name|howto
operator|->
name|partial_inplace
operator|&&
name|addend
operator|!=
literal|0
condition|)
block|{
name|bfd_size_type
name|size
decl_stmt|;
name|bfd_reloc_status_type
name|rstat
decl_stmt|;
name|bfd_byte
modifier|*
name|buf
decl_stmt|;
name|boolean
name|ok
decl_stmt|;
specifier|const
name|char
modifier|*
name|sym_name
decl_stmt|;
name|size
operator|=
name|bfd_get_reloc_size
argument_list|(
name|howto
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_zmalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
operator|(
name|bfd_byte
operator|*
operator|)
name|NULL
condition|)
return|return
name|false
return|;
name|rstat
operator|=
name|_bfd_relocate_contents
argument_list|(
name|howto
argument_list|,
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|addend
argument_list|,
name|buf
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rstat
condition|)
block|{
case|case
name|bfd_reloc_ok
case|:
break|break;
default|default:
case|case
name|bfd_reloc_outofrange
case|:
name|abort
argument_list|()
expr_stmt|;
case|case
name|bfd_reloc_overflow
case|:
if|if
condition|(
name|link_order
operator|->
name|type
operator|==
name|bfd_section_reloc_link_order
condition|)
name|sym_name
operator|=
name|bfd_section_name
argument_list|(
name|output_bfd
argument_list|,
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|u
operator|.
name|section
argument_list|)
expr_stmt|;
else|else
name|sym_name
operator|=
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|u
operator|.
name|name
expr_stmt|;
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|info
argument_list|,
name|sym_name
argument_list|,
name|howto
operator|->
name|name
argument_list|,
name|addend
argument_list|,
operator|(
name|bfd
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|asection
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
operator|)
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
break|break;
block|}
name|ok
operator|=
name|bfd_set_section_contents
argument_list|(
name|output_bfd
argument_list|,
name|output_section
argument_list|,
operator|(
name|PTR
operator|)
name|buf
argument_list|,
operator|(
name|file_ptr
operator|)
name|link_order
operator|->
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|false
return|;
block|}
comment|/* The address of a reloc is relative to the section in a      relocateable file, and is a virtual address in an executable      file.  */
name|offset
operator|=
name|link_order
operator|->
name|offset
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|relocateable
condition|)
name|offset
operator|+=
name|output_section
operator|->
name|vma
expr_stmt|;
name|rel_hdr
operator|=
operator|&
name|elf_section_data
argument_list|(
name|output_section
argument_list|)
operator|->
name|rel_hdr
expr_stmt|;
if|if
condition|(
name|rel_hdr
operator|->
name|sh_type
operator|==
name|SHT_REL
condition|)
block|{
name|bfd_size_type
name|size
decl_stmt|;
name|Elf_Internal_Rel
modifier|*
name|irel
decl_stmt|;
name|Elf_External_Rel
modifier|*
name|erel
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|size
operator|=
name|bed
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Internal_Rel
argument_list|)
expr_stmt|;
name|irel
operator|=
operator|(
name|Elf_Internal_Rel
operator|*
operator|)
name|bfd_zmalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|irel
operator|==
name|NULL
condition|)
return|return
name|false
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bed
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
condition|;
name|i
operator|++
control|)
name|irel
index|[
name|i
index|]
operator|.
name|r_offset
operator|=
name|offset
expr_stmt|;
name|irel
index|[
literal|0
index|]
operator|.
name|r_info
operator|=
name|ELF_R_INFO
argument_list|(
name|indx
argument_list|,
name|howto
operator|->
name|type
argument_list|)
expr_stmt|;
name|erel
operator|=
operator|(
operator|(
name|Elf_External_Rel
operator|*
operator|)
name|rel_hdr
operator|->
name|contents
operator|+
name|elf_section_data
argument_list|(
name|output_section
argument_list|)
operator|->
name|rel_count
operator|)
expr_stmt|;
if|if
condition|(
name|bed
operator|->
name|s
operator|->
name|swap_reloc_out
condition|)
call|(
modifier|*
name|bed
operator|->
name|s
operator|->
name|swap_reloc_out
call|)
argument_list|(
name|output_bfd
argument_list|,
name|irel
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|erel
argument_list|)
expr_stmt|;
else|else
name|elf_swap_reloc_out
argument_list|(
name|output_bfd
argument_list|,
name|irel
argument_list|,
name|erel
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|irel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bfd_size_type
name|size
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irela
decl_stmt|;
name|Elf_External_Rela
modifier|*
name|erela
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|size
operator|=
name|bed
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Internal_Rela
argument_list|)
expr_stmt|;
name|irela
operator|=
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
name|bfd_zmalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|irela
operator|==
name|NULL
condition|)
return|return
name|false
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bed
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
condition|;
name|i
operator|++
control|)
name|irela
index|[
name|i
index|]
operator|.
name|r_offset
operator|=
name|offset
expr_stmt|;
name|irela
index|[
literal|0
index|]
operator|.
name|r_info
operator|=
name|ELF_R_INFO
argument_list|(
name|indx
argument_list|,
name|howto
operator|->
name|type
argument_list|)
expr_stmt|;
name|irela
index|[
literal|0
index|]
operator|.
name|r_addend
operator|=
name|addend
expr_stmt|;
name|erela
operator|=
operator|(
operator|(
name|Elf_External_Rela
operator|*
operator|)
name|rel_hdr
operator|->
name|contents
operator|+
name|elf_section_data
argument_list|(
name|output_section
argument_list|)
operator|->
name|rel_count
operator|)
expr_stmt|;
if|if
condition|(
name|bed
operator|->
name|s
operator|->
name|swap_reloca_out
condition|)
call|(
modifier|*
name|bed
operator|->
name|s
operator|->
name|swap_reloca_out
call|)
argument_list|(
name|output_bfd
argument_list|,
name|irela
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|erela
argument_list|)
expr_stmt|;
else|else
name|elf_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
name|irela
argument_list|,
name|erela
argument_list|)
expr_stmt|;
block|}
operator|++
name|elf_section_data
argument_list|(
name|output_section
argument_list|)
operator|->
name|rel_count
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Allocate a pointer to live in a linker created section.  */
end_comment

begin_function
name|boolean
name|elf_create_pointer_linker_section
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|lsect
parameter_list|,
name|h
parameter_list|,
name|rel
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|elf_linker_section_t
modifier|*
name|lsect
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
block|{
name|elf_linker_section_pointers_t
modifier|*
modifier|*
name|ptr_linker_section_ptr
init|=
name|NULL
decl_stmt|;
name|elf_linker_section_pointers_t
modifier|*
name|linker_section_ptr
decl_stmt|;
name|unsigned
name|long
name|r_symndx
init|=
name|ELF_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|lsect
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Is this a global symbol?  */
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
comment|/* Has this symbol already been allocated?  If so, our work is done.  */
if|if
condition|(
name|_bfd_elf_find_pointer_linker_section
argument_list|(
name|h
operator|->
name|linker_section_pointer
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|,
name|lsect
operator|->
name|which
argument_list|)
condition|)
return|return
name|true
return|;
name|ptr_linker_section_ptr
operator|=
operator|&
name|h
operator|->
name|linker_section_pointer
expr_stmt|;
comment|/* Make sure this symbol is output as a dynamic symbol.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|lsect
operator|->
name|rel_section
condition|)
name|lsect
operator|->
name|rel_section
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf_External_Rela
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Allocation of a pointer to a local symbol.  */
name|elf_linker_section_pointers_t
modifier|*
modifier|*
name|ptr
init|=
name|elf_local_ptr_offsets
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
comment|/* Allocate a table to hold the local symbols if first time.  */
if|if
condition|(
operator|!
name|ptr
condition|)
block|{
name|unsigned
name|int
name|num_symbols
init|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
operator|.
name|sh_info
decl_stmt|;
specifier|register
name|unsigned
name|int
name|i
decl_stmt|;
name|amt
operator|=
name|num_symbols
expr_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
name|elf_linker_section_pointers_t
operator|*
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
name|elf_linker_section_pointers_t
operator|*
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
return|return
name|false
return|;
name|elf_local_ptr_offsets
argument_list|(
name|abfd
argument_list|)
operator|=
name|ptr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_symbols
condition|;
name|i
operator|++
control|)
name|ptr
index|[
name|i
index|]
operator|=
operator|(
name|elf_linker_section_pointers_t
operator|*
operator|)
literal|0
expr_stmt|;
block|}
comment|/* Has this symbol already been allocated?  If so, our work is done.  */
if|if
condition|(
name|_bfd_elf_find_pointer_linker_section
argument_list|(
name|ptr
index|[
name|r_symndx
index|]
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|,
name|lsect
operator|->
name|which
argument_list|)
condition|)
return|return
name|true
return|;
name|ptr_linker_section_ptr
operator|=
operator|&
name|ptr
index|[
name|r_symndx
index|]
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
comment|/* If we are generating a shared object, we need to 	     output a R_<xxx>_RELATIVE reloc so that the 	     dynamic linker can adjust this GOT entry.  */
name|BFD_ASSERT
argument_list|(
name|lsect
operator|->
name|rel_section
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|lsect
operator|->
name|rel_section
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf_External_Rela
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Allocate space for a pointer in the linker section, and allocate      a new pointer record from internal memory.  */
name|BFD_ASSERT
argument_list|(
name|ptr_linker_section_ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
name|elf_linker_section_pointers_t
argument_list|)
expr_stmt|;
name|linker_section_ptr
operator|=
operator|(
name|elf_linker_section_pointers_t
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|linker_section_ptr
condition|)
return|return
name|false
return|;
name|linker_section_ptr
operator|->
name|next
operator|=
operator|*
name|ptr_linker_section_ptr
expr_stmt|;
name|linker_section_ptr
operator|->
name|addend
operator|=
name|rel
operator|->
name|r_addend
expr_stmt|;
name|linker_section_ptr
operator|->
name|which
operator|=
name|lsect
operator|->
name|which
expr_stmt|;
name|linker_section_ptr
operator|->
name|written_address_p
operator|=
name|false
expr_stmt|;
operator|*
name|ptr_linker_section_ptr
operator|=
name|linker_section_ptr
expr_stmt|;
if|#
directive|if
literal|0
block|if (lsect->hole_size&& lsect->hole_offset< lsect->max_hole_offset)     {       linker_section_ptr->offset = (lsect->section->_raw_size 				    - lsect->hole_size + (ARCH_SIZE / 8));       lsect->hole_offset += ARCH_SIZE / 8;       lsect->sym_offset  += ARCH_SIZE / 8;       if (lsect->sym_hash) 	{
comment|/* Bump up symbol value if needed.  */
block|lsect->sym_hash->root.u.def.value += ARCH_SIZE / 8;
ifdef|#
directive|ifdef
name|DEBUG
block|fprintf (stderr, "Bump up %s by %ld, current value = %ld\n", 		   lsect->sym_hash->root.root.string, 		   (long) ARCH_SIZE / 8, 		   (long) lsect->sym_hash->root.u.def.value);
endif|#
directive|endif
block|}     }   else
endif|#
directive|endif
name|linker_section_ptr
operator|->
name|offset
operator|=
name|lsect
operator|->
name|section
operator|->
name|_raw_size
expr_stmt|;
name|lsect
operator|->
name|section
operator|->
name|_raw_size
operator|+=
name|ARCH_SIZE
operator|/
literal|8
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Create pointer in linker section %s, offset = %ld, section size = %ld\n"
argument_list|,
name|lsect
operator|->
name|name
argument_list|,
operator|(
name|long
operator|)
name|linker_section_ptr
operator|->
name|offset
argument_list|,
operator|(
name|long
operator|)
name|lsect
operator|->
name|section
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
name|ARCH_SIZE
operator|==
literal|64
end_if

begin_define
define|#
directive|define
name|bfd_put_ptr
parameter_list|(
name|BFD
parameter_list|,
name|VAL
parameter_list|,
name|ADDR
parameter_list|)
value|bfd_put_64 (BFD, VAL, ADDR)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|ARCH_SIZE
operator|==
literal|32
end_if

begin_define
define|#
directive|define
name|bfd_put_ptr
parameter_list|(
name|BFD
parameter_list|,
name|VAL
parameter_list|,
name|ADDR
parameter_list|)
value|bfd_put_32 (BFD, VAL, ADDR)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Fill in the address for a pointer generated in a linker section.  */
end_comment

begin_function
name|bfd_vma
name|elf_finish_pointer_linker_section
parameter_list|(
name|output_bfd
parameter_list|,
name|input_bfd
parameter_list|,
name|info
parameter_list|,
name|lsect
parameter_list|,
name|h
parameter_list|,
name|relocation
parameter_list|,
name|rel
parameter_list|,
name|relative_reloc
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|elf_linker_section_t
modifier|*
name|lsect
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|int
name|relative_reloc
decl_stmt|;
block|{
name|elf_linker_section_pointers_t
modifier|*
name|linker_section_ptr
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|lsect
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
comment|/* Handle global symbol.  */
name|linker_section_ptr
operator|=
operator|(
name|_bfd_elf_find_pointer_linker_section
argument_list|(
name|h
operator|->
name|linker_section_pointer
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|,
name|lsect
operator|->
name|which
argument_list|)
operator|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|linker_section_ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
operator|||
operator|(
name|info
operator|->
name|shared
operator|&&
name|info
operator|->
name|symbolic
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|)
condition|)
block|{
comment|/* This is actually a static link, or it is a 	     -Bsymbolic link and the symbol is defined 	     locally.  We must initialize this entry in the 	     global section.  	     When doing a dynamic link, we create a .rela.<xxx> 	     relocation entry to initialize the value.  This 	     is done in the finish_dynamic_symbol routine.  */
if|if
condition|(
operator|!
name|linker_section_ptr
operator|->
name|written_address_p
condition|)
block|{
name|linker_section_ptr
operator|->
name|written_address_p
operator|=
name|true
expr_stmt|;
name|bfd_put_ptr
argument_list|(
name|output_bfd
argument_list|,
name|relocation
operator|+
name|linker_section_ptr
operator|->
name|addend
argument_list|,
operator|(
name|lsect
operator|->
name|section
operator|->
name|contents
operator|+
name|linker_section_ptr
operator|->
name|offset
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* Handle local symbol.  */
name|unsigned
name|long
name|r_symndx
init|=
name|ELF_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|elf_local_ptr_offsets
argument_list|(
name|input_bfd
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|elf_local_ptr_offsets
argument_list|(
name|input_bfd
argument_list|)
index|[
name|r_symndx
index|]
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|linker_section_ptr
operator|=
operator|(
name|_bfd_elf_find_pointer_linker_section
argument_list|(
name|elf_local_ptr_offsets
argument_list|(
name|input_bfd
argument_list|)
index|[
name|r_symndx
index|]
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|,
name|lsect
operator|->
name|which
argument_list|)
operator|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|linker_section_ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Write out pointer if it hasn't been rewritten out before.  */
if|if
condition|(
operator|!
name|linker_section_ptr
operator|->
name|written_address_p
condition|)
block|{
name|linker_section_ptr
operator|->
name|written_address_p
operator|=
name|true
expr_stmt|;
name|bfd_put_ptr
argument_list|(
name|output_bfd
argument_list|,
name|relocation
operator|+
name|linker_section_ptr
operator|->
name|addend
argument_list|,
name|lsect
operator|->
name|section
operator|->
name|contents
operator|+
name|linker_section_ptr
operator|->
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
name|asection
modifier|*
name|srel
init|=
name|lsect
operator|->
name|rel_section
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|outrel
decl_stmt|;
name|Elf_External_Rela
modifier|*
name|erel
decl_stmt|;
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|output_bfd
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
name|Elf_Internal_Rela
argument_list|)
operator|*
name|bed
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
expr_stmt|;
name|outrel
operator|=
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
name|bfd_zmalloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|outrel
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Error: out of memory"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* We need to generate a relative reloc for the dynamic 		 linker.  */
if|if
condition|(
operator|!
name|srel
condition|)
block|{
name|srel
operator|=
name|bfd_get_section_by_name
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
argument_list|,
name|lsect
operator|->
name|rel_name
argument_list|)
expr_stmt|;
name|lsect
operator|->
name|rel_section
operator|=
name|srel
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
name|srel
operator|!=
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bed
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
condition|;
name|i
operator|++
control|)
name|outrel
index|[
name|i
index|]
operator|.
name|r_offset
operator|=
operator|(
name|lsect
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|lsect
operator|->
name|section
operator|->
name|output_offset
operator|+
name|linker_section_ptr
operator|->
name|offset
operator|)
expr_stmt|;
name|outrel
index|[
literal|0
index|]
operator|.
name|r_info
operator|=
name|ELF_R_INFO
argument_list|(
literal|0
argument_list|,
name|relative_reloc
argument_list|)
expr_stmt|;
name|outrel
index|[
literal|0
index|]
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
name|erel
operator|=
operator|(
name|Elf_External_Rela
operator|*
operator|)
name|lsect
operator|->
name|section
operator|->
name|contents
expr_stmt|;
name|erel
operator|+=
name|elf_section_data
argument_list|(
name|lsect
operator|->
name|section
argument_list|)
operator|->
name|rel_count
expr_stmt|;
name|elf_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
name|outrel
argument_list|,
name|erel
argument_list|)
expr_stmt|;
operator|++
name|elf_section_data
argument_list|(
name|lsect
operator|->
name|section
argument_list|)
operator|->
name|rel_count
expr_stmt|;
name|free
argument_list|(
name|outrel
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|relocation
operator|=
operator|(
name|lsect
operator|->
name|section
operator|->
name|output_offset
operator|+
name|linker_section_ptr
operator|->
name|offset
operator|-
name|lsect
operator|->
name|hole_offset
operator|-
name|lsect
operator|->
name|sym_offset
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Finish pointer in linker section %s, offset = %ld (0x%lx)\n"
argument_list|,
name|lsect
operator|->
name|name
argument_list|,
operator|(
name|long
operator|)
name|relocation
argument_list|,
operator|(
name|long
operator|)
name|relocation
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Subtract out the addend, because it will get added back in by the normal      processing.  */
return|return
name|relocation
operator|-
name|linker_section_ptr
operator|->
name|addend
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Garbage collect unused sections.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|elf_gc_mark
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
name|info
operator|,
name|asection
operator|*
name|sec
operator|,
name|asection
operator|*
operator|(
operator|*
name|gc_mark_hook
operator|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|)
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf_gc_sweep
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
name|info
operator|,
name|boolean
argument_list|(
argument|*gc_sweep_hook
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|,
name|asection
operator|*
name|o
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
name|relocs
operator|)
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf_gc_sweep_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
name|h
operator|,
name|PTR
name|idxptr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf_gc_allocate_got_offsets
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
name|h
operator|,
name|PTR
name|offarg
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf_gc_propagate_vtable_entries_used
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
name|h
operator|,
name|PTR
name|dummy
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf_gc_smash_unused_vtentry_relocs
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
name|h
operator|,
name|PTR
name|dummy
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The mark phase of garbage collection.  For a given section, mark    it and any sections in this section's group, and all the sections    which define symbols to which it refers.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|elf_gc_mark
argument_list|(
name|info
argument_list|,
name|sec
argument_list|,
name|gc_mark_hook
argument_list|)
decl|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|asection
modifier|*
name|sec
decl_stmt|;
end_decl_stmt

begin_macro
name|asection
end_macro

begin_expr_stmt
operator|*
operator|(
operator|*
name|gc_mark_hook
operator|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|boolean
name|ret
decl_stmt|;
name|asection
modifier|*
name|group_sec
decl_stmt|;
name|sec
operator|->
name|gc_mark
operator|=
literal|1
expr_stmt|;
comment|/* Mark all the sections in the group.  */
name|group_sec
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|next_in_group
expr_stmt|;
if|if
condition|(
name|group_sec
operator|&&
operator|!
name|group_sec
operator|->
name|gc_mark
condition|)
if|if
condition|(
operator|!
name|elf_gc_mark
argument_list|(
name|info
argument_list|,
name|group_sec
argument_list|,
name|gc_mark_hook
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Look through the section relocs.  */
name|ret
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|!=
literal|0
operator|&&
name|sec
operator|->
name|reloc_count
operator|>
literal|0
condition|)
block|{
name|Elf_Internal_Rela
modifier|*
name|relstart
decl_stmt|,
modifier|*
name|rel
decl_stmt|,
modifier|*
name|relend
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|shndx_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|size_t
name|nlocsyms
decl_stmt|;
name|size_t
name|extsymoff
decl_stmt|;
name|Elf_External_Sym
modifier|*
name|locsyms
decl_stmt|,
modifier|*
name|freesyms
init|=
name|NULL
decl_stmt|;
name|Elf_External_Sym_Shndx
modifier|*
name|locsym_shndx
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
init|=
name|sec
operator|->
name|owner
decl_stmt|;
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|input_bfd
argument_list|)
decl_stmt|;
comment|/* GCFIXME: how to arrange so that relocs and symbols are not 	 reread continually?  */
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
comment|/* Read the local symbols.  */
if|if
condition|(
name|elf_bad_symtab
argument_list|(
name|input_bfd
argument_list|)
condition|)
block|{
name|nlocsyms
operator|=
name|symtab_hdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
expr_stmt|;
name|extsymoff
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|extsymoff
operator|=
name|nlocsyms
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
if|if
condition|(
name|symtab_hdr
operator|->
name|contents
condition|)
name|locsyms
operator|=
operator|(
name|Elf_External_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
elseif|else
if|if
condition|(
name|nlocsyms
operator|==
literal|0
condition|)
name|locsyms
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|bfd_size_type
name|amt
init|=
name|nlocsyms
operator|*
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
decl_stmt|;
name|locsyms
operator|=
name|freesyms
operator|=
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|freesyms
operator|==
name|NULL
operator|||
name|bfd_seek
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bread
argument_list|(
name|locsyms
argument_list|,
name|amt
argument_list|,
name|input_bfd
argument_list|)
operator|!=
name|amt
condition|)
block|{
name|ret
operator|=
name|false
expr_stmt|;
goto|goto
name|out1
goto|;
block|}
block|}
name|shndx_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_shndx_hdr
expr_stmt|;
name|locsym_shndx
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|shndx_hdr
operator|->
name|sh_size
operator|!=
literal|0
operator|&&
name|nlocsyms
operator|!=
literal|0
condition|)
block|{
name|bfd_size_type
name|amt
init|=
name|nlocsyms
operator|*
sizeof|sizeof
argument_list|(
name|Elf_External_Sym_Shndx
argument_list|)
decl_stmt|;
name|locsym_shndx
operator|=
operator|(
name|Elf_External_Sym_Shndx
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|input_bfd
argument_list|,
name|shndx_hdr
operator|->
name|sh_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bread
argument_list|(
name|locsym_shndx
argument_list|,
name|amt
argument_list|,
name|input_bfd
argument_list|)
operator|!=
name|amt
condition|)
return|return
name|false
return|;
block|}
comment|/* Read the relocations.  */
name|relstart
operator|=
operator|(
name|NAME
argument_list|(
name|_bfd_elf
argument_list|,
name|link_read_relocs
argument_list|)
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|sec
argument_list|,
name|NULL
argument_list|,
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
name|NULL
argument_list|,
name|info
operator|->
name|keep_memory
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|relstart
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|false
expr_stmt|;
goto|goto
name|out1
goto|;
block|}
name|relend
operator|=
name|relstart
operator|+
name|sec
operator|->
name|reloc_count
operator|*
name|bed
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relstart
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|asection
modifier|*
name|rsec
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|Elf_Internal_Sym
name|s
decl_stmt|;
name|r_symndx
operator|=
name|ELF_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|elf_bad_symtab
argument_list|(
name|sec
operator|->
name|owner
argument_list|)
condition|)
block|{
name|elf_swap_symbol_in
argument_list|(
name|input_bfd
argument_list|,
name|locsyms
operator|+
name|r_symndx
argument_list|,
name|locsym_shndx
operator|+
operator|(
name|locsym_shndx
condition|?
name|r_symndx
else|:
literal|0
operator|)
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ELF_ST_BIND
argument_list|(
name|s
operator|.
name|st_info
argument_list|)
operator|==
name|STB_LOCAL
condition|)
name|rsec
operator|=
call|(
modifier|*
name|gc_mark_hook
call|)
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|info
argument_list|,
name|rel
argument_list|,
name|NULL
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
else|else
block|{
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|extsymoff
index|]
expr_stmt|;
name|rsec
operator|=
call|(
modifier|*
name|gc_mark_hook
call|)
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|info
argument_list|,
name|rel
argument_list|,
name|h
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|r_symndx
operator|>=
name|nlocsyms
condition|)
block|{
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|extsymoff
index|]
expr_stmt|;
name|rsec
operator|=
call|(
modifier|*
name|gc_mark_hook
call|)
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|info
argument_list|,
name|rel
argument_list|,
name|h
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|elf_swap_symbol_in
argument_list|(
name|input_bfd
argument_list|,
name|locsyms
operator|+
name|r_symndx
argument_list|,
name|locsym_shndx
operator|+
operator|(
name|locsym_shndx
condition|?
name|r_symndx
else|:
literal|0
operator|)
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|rsec
operator|=
call|(
modifier|*
name|gc_mark_hook
call|)
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|info
argument_list|,
name|rel
argument_list|,
name|NULL
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rsec
operator|&&
operator|!
name|rsec
operator|->
name|gc_mark
condition|)
block|{
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|rsec
operator|->
name|owner
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
name|rsec
operator|->
name|gc_mark
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|elf_gc_mark
argument_list|(
name|info
argument_list|,
name|rsec
argument_list|,
name|gc_mark_hook
argument_list|)
condition|)
block|{
name|ret
operator|=
name|false
expr_stmt|;
goto|goto
name|out2
goto|;
block|}
block|}
block|}
name|out2
label|:
if|if
condition|(
operator|!
name|info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|relstart
argument_list|)
expr_stmt|;
name|out1
label|:
if|if
condition|(
name|freesyms
condition|)
name|free
argument_list|(
name|freesyms
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_block

begin_comment
comment|/* The sweep phase of garbage collection.  Remove all garbage sections.  */
end_comment

begin_function_decl
specifier|static
name|boolean
name|elf_gc_sweep
parameter_list|(
name|info
parameter_list|,
name|gc_sweep_hook
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
function_decl|boolean
parameter_list|(
function_decl|*gc_sweep_hook
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|,
name|asection
operator|*
name|o
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
name|relocs
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|bfd
modifier|*
name|sub
decl_stmt|;
for|for
control|(
name|sub
operator|=
name|info
operator|->
name|input_bfds
init|;
name|sub
operator|!=
name|NULL
condition|;
name|sub
operator|=
name|sub
operator|->
name|link_next
control|)
block|{
name|asection
modifier|*
name|o
decl_stmt|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|sub
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
continue|continue;
for|for
control|(
name|o
operator|=
name|sub
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
comment|/* Keep special sections.  Keep .debug sections.  */
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_LINKER_CREATED
operator|)
operator|||
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_DEBUGGING
operator|)
condition|)
name|o
operator|->
name|gc_mark
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|gc_mark
condition|)
continue|continue;
comment|/* Skip sweeping sections already excluded.  */
if|if
condition|(
name|o
operator|->
name|flags
operator|&
name|SEC_EXCLUDE
condition|)
continue|continue;
comment|/* Since this is early in the link process, it is simple 	     to remove a section from the output.  */
name|o
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
comment|/* But we also have to update some of the relocation 	     info we collected before.  */
if|if
condition|(
name|gc_sweep_hook
operator|&&
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|&&
name|o
operator|->
name|reloc_count
operator|>
literal|0
condition|)
block|{
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|;
name|boolean
name|r
decl_stmt|;
name|internal_relocs
operator|=
operator|(
name|NAME
argument_list|(
name|_bfd_elf
argument_list|,
name|link_read_relocs
argument_list|)
argument_list|(
name|o
operator|->
name|owner
argument_list|,
name|o
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|info
operator|->
name|keep_memory
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|r
operator|=
call|(
modifier|*
name|gc_sweep_hook
call|)
argument_list|(
name|o
operator|->
name|owner
argument_list|,
name|info
argument_list|,
name|o
argument_list|,
name|internal_relocs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
return|return
name|false
return|;
block|}
block|}
block|}
comment|/* Remove the symbols that were in the swept sections from the dynamic      symbol table.  GCFIXME: Anyone know how to get them out of the      static symbol table as well?  */
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|elf_link_hash_traverse
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|elf_gc_sweep_symbol
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|i
argument_list|)
expr_stmt|;
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynsymcount
operator|=
name|i
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_block

begin_comment
comment|/* Sweep symbols in swept sections.  Called via elf_link_hash_traverse.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf_gc_sweep_symbol
parameter_list|(
name|h
parameter_list|,
name|idxptr
parameter_list|)
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|PTR
name|idxptr
decl_stmt|;
block|{
name|int
modifier|*
name|idx
init|=
operator|(
name|int
operator|*
operator|)
name|idxptr
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|&&
operator|(
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defined
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
operator|)
operator|||
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|gc_mark
operator|)
condition|)
name|h
operator|->
name|dynindx
operator|=
operator|(
operator|*
name|idx
operator|)
operator|++
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Propogate collected vtable information.  This is called through    elf_link_hash_traverse.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf_gc_propagate_vtable_entries_used
parameter_list|(
name|h
parameter_list|,
name|okp
parameter_list|)
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|PTR
name|okp
decl_stmt|;
block|{
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
comment|/* Those that are not vtables.  */
if|if
condition|(
name|h
operator|->
name|vtable_parent
operator|==
name|NULL
condition|)
return|return
name|true
return|;
comment|/* Those vtables that do not have parents, we cannot merge.  */
if|if
condition|(
name|h
operator|->
name|vtable_parent
operator|==
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
operator|-
literal|1
condition|)
return|return
name|true
return|;
comment|/* If we've already been done, exit.  */
if|if
condition|(
name|h
operator|->
name|vtable_entries_used
operator|&&
name|h
operator|->
name|vtable_entries_used
index|[
operator|-
literal|1
index|]
condition|)
return|return
name|true
return|;
comment|/* Make sure the parent's table is up to date.  */
name|elf_gc_propagate_vtable_entries_used
argument_list|(
name|h
operator|->
name|vtable_parent
argument_list|,
name|okp
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|vtable_entries_used
operator|==
name|NULL
condition|)
block|{
comment|/* None of this table's entries were referenced.  Re-use the 	 parent's table.  */
name|h
operator|->
name|vtable_entries_used
operator|=
name|h
operator|->
name|vtable_parent
operator|->
name|vtable_entries_used
expr_stmt|;
name|h
operator|->
name|vtable_entries_size
operator|=
name|h
operator|->
name|vtable_parent
operator|->
name|vtable_entries_size
expr_stmt|;
block|}
else|else
block|{
name|size_t
name|n
decl_stmt|;
name|boolean
modifier|*
name|cu
decl_stmt|,
modifier|*
name|pu
decl_stmt|;
comment|/* Or the parent's entries into ours.  */
name|cu
operator|=
name|h
operator|->
name|vtable_entries_used
expr_stmt|;
name|cu
index|[
operator|-
literal|1
index|]
operator|=
name|true
expr_stmt|;
name|pu
operator|=
name|h
operator|->
name|vtable_parent
operator|->
name|vtable_entries_used
expr_stmt|;
if|if
condition|(
name|pu
operator|!=
name|NULL
condition|)
block|{
name|asection
modifier|*
name|sec
init|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
decl_stmt|;
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|sec
operator|->
name|owner
argument_list|)
decl_stmt|;
name|int
name|file_align
init|=
name|bed
operator|->
name|s
operator|->
name|file_align
decl_stmt|;
name|n
operator|=
name|h
operator|->
name|vtable_parent
operator|->
name|vtable_entries_size
operator|/
name|file_align
expr_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
block|{
if|if
condition|(
operator|*
name|pu
condition|)
operator|*
name|cu
operator|=
name|true
expr_stmt|;
name|pu
operator|++
expr_stmt|;
name|cu
operator|++
expr_stmt|;
block|}
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|elf_gc_smash_unused_vtentry_relocs
parameter_list|(
name|h
parameter_list|,
name|okp
parameter_list|)
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|PTR
name|okp
decl_stmt|;
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_vma
name|hstart
decl_stmt|,
name|hend
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relstart
decl_stmt|,
modifier|*
name|relend
decl_stmt|,
modifier|*
name|rel
decl_stmt|;
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
name|int
name|file_align
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
comment|/* Take care of both those symbols that do not describe vtables as      well as those that are not loaded.  */
if|if
condition|(
name|h
operator|->
name|vtable_parent
operator|==
name|NULL
condition|)
return|return
name|true
return|;
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
argument_list|)
expr_stmt|;
name|sec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|hstart
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
name|hend
operator|=
name|hstart
operator|+
name|h
operator|->
name|size
expr_stmt|;
name|relstart
operator|=
operator|(
name|NAME
argument_list|(
name|_bfd_elf
argument_list|,
name|link_read_relocs
argument_list|)
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|sec
argument_list|,
name|NULL
argument_list|,
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
name|NULL
argument_list|,
name|true
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|relstart
condition|)
return|return
operator|*
operator|(
name|boolean
operator|*
operator|)
name|okp
operator|=
name|false
return|;
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|sec
operator|->
name|owner
argument_list|)
expr_stmt|;
name|file_align
operator|=
name|bed
operator|->
name|s
operator|->
name|file_align
expr_stmt|;
name|relend
operator|=
name|relstart
operator|+
name|sec
operator|->
name|reloc_count
operator|*
name|bed
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relstart
init|;
name|rel
operator|<
name|relend
condition|;
operator|++
name|rel
control|)
if|if
condition|(
name|rel
operator|->
name|r_offset
operator|>=
name|hstart
operator|&&
name|rel
operator|->
name|r_offset
operator|<
name|hend
condition|)
block|{
comment|/* If the entry is in use, do nothing.  */
if|if
condition|(
name|h
operator|->
name|vtable_entries_used
operator|&&
operator|(
name|rel
operator|->
name|r_offset
operator|-
name|hstart
operator|)
operator|<
name|h
operator|->
name|vtable_entries_size
condition|)
block|{
name|bfd_vma
name|entry
init|=
operator|(
name|rel
operator|->
name|r_offset
operator|-
name|hstart
operator|)
operator|/
name|file_align
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|vtable_entries_used
index|[
name|entry
index|]
condition|)
continue|continue;
block|}
comment|/* Otherwise, kill it.  */
name|rel
operator|->
name|r_offset
operator|=
name|rel
operator|->
name|r_info
operator|=
name|rel
operator|->
name|r_addend
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Do mark and sweep of unused sections.  */
end_comment

begin_function
name|boolean
name|elf_gc_sections
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|boolean
name|ok
init|=
name|true
decl_stmt|;
name|bfd
modifier|*
name|sub
decl_stmt|;
name|asection
operator|*
operator|(
operator|*
name|gc_mark_hook
operator|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
name|h
operator|,
name|Elf_Internal_Sym
operator|*
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|can_gc_sections
operator|||
name|info
operator|->
name|relocateable
operator|||
name|info
operator|->
name|emitrelocations
operator|||
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
return|return
name|true
return|;
comment|/* Apply transitive closure to the vtable entry usage info.  */
name|elf_link_hash_traverse
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|elf_gc_propagate_vtable_entries_used
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|false
return|;
comment|/* Kill the vtable relocations that were not used.  */
name|elf_link_hash_traverse
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|elf_gc_smash_unused_vtentry_relocs
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|false
return|;
comment|/* Grovel through relocs to find out who stays ...  */
name|gc_mark_hook
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|gc_mark_hook
expr_stmt|;
for|for
control|(
name|sub
operator|=
name|info
operator|->
name|input_bfds
init|;
name|sub
operator|!=
name|NULL
condition|;
name|sub
operator|=
name|sub
operator|->
name|link_next
control|)
block|{
name|asection
modifier|*
name|o
decl_stmt|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|sub
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
continue|continue;
for|for
control|(
name|o
operator|=
name|sub
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
if|if
condition|(
name|o
operator|->
name|flags
operator|&
name|SEC_KEEP
condition|)
if|if
condition|(
operator|!
name|elf_gc_mark
argument_list|(
name|info
argument_list|,
name|o
argument_list|,
name|gc_mark_hook
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
comment|/* ... and mark SEC_EXCLUDE for those that go.  */
if|if
condition|(
operator|!
name|elf_gc_sweep
argument_list|(
name|info
argument_list|,
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|gc_sweep_hook
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Called from check_relocs to record the existance of a VTINHERIT reloc.  */
end_comment

begin_function
name|boolean
name|elf_gc_record_vtinherit
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|h
parameter_list|,
name|offset
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
block|{
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|,
modifier|*
modifier|*
name|sym_hashes_end
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|search
decl_stmt|,
modifier|*
name|child
decl_stmt|;
name|bfd_size_type
name|extsymcount
decl_stmt|;
comment|/* The sh_info field of the symtab header tells us where the      external symbols start.  We don't care about the local symbols at      this point.  */
name|extsymcount
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
operator|.
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|elf_bad_symtab
argument_list|(
name|abfd
argument_list|)
condition|)
name|extsymcount
operator|-=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
operator|.
name|sh_info
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|sym_hashes_end
operator|=
name|sym_hashes
operator|+
name|extsymcount
expr_stmt|;
comment|/* Hunt down the child symbol, which is in this section at the same      offset as the relocation.  */
for|for
control|(
name|search
operator|=
name|sym_hashes
init|;
name|search
operator|!=
name|sym_hashes_end
condition|;
operator|++
name|search
control|)
block|{
if|if
condition|(
operator|(
name|child
operator|=
operator|*
name|search
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|child
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|child
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
name|child
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|==
name|sec
operator|&&
name|child
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|==
name|offset
condition|)
goto|goto
name|win
goto|;
block|}
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"%s: %s+%lu: No symbol found for INHERIT"
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|sec
operator|->
name|name
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|offset
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
name|false
return|;
name|win
label|:
if|if
condition|(
operator|!
name|h
condition|)
block|{
comment|/* This *should* only be the absolute section.  It could potentially 	 be that someone has defined a non-global vtable though, which 	 would be bad.  It isn't worth paging in the local symbols to be 	 sure though; that case should simply be handled by the assembler.  */
name|child
operator|->
name|vtable_parent
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|child
operator|->
name|vtable_parent
operator|=
name|h
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Called from check_relocs to record the existance of a VTENTRY reloc.  */
end_comment

begin_function
name|boolean
name|elf_gc_record_vtentry
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|h
parameter_list|,
name|addend
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|sec
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|;
block|{
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|int
name|file_align
init|=
name|bed
operator|->
name|s
operator|->
name|file_align
decl_stmt|;
if|if
condition|(
name|addend
operator|>=
name|h
operator|->
name|vtable_entries_size
condition|)
block|{
name|size_t
name|size
decl_stmt|,
name|bytes
decl_stmt|;
name|boolean
modifier|*
name|ptr
init|=
name|h
operator|->
name|vtable_entries_used
decl_stmt|;
comment|/* While the symbol is undefined, we have to be prepared to handle 	 a zero size.  */
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
condition|)
name|size
operator|=
name|addend
expr_stmt|;
else|else
block|{
name|size
operator|=
name|h
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|size
operator|<
name|addend
condition|)
block|{
comment|/* Oops!  We've got a reference past the defined end of 		 the table.  This is probably a bug -- shall we warn?  */
name|size
operator|=
name|addend
expr_stmt|;
block|}
block|}
comment|/* Allocate one extra entry for use as a "done" flag for the 	 consolidation pass.  */
name|bytes
operator|=
operator|(
name|size
operator|/
name|file_align
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|boolean
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
condition|)
block|{
name|ptr
operator|=
name|bfd_realloc
argument_list|(
name|ptr
operator|-
literal|1
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
block|{
name|size_t
name|oldbytes
decl_stmt|;
name|oldbytes
operator|=
operator|(
operator|(
name|h
operator|->
name|vtable_entries_size
operator|/
name|file_align
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|boolean
argument_list|)
operator|)
expr_stmt|;
name|memset
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
name|ptr
operator|)
operator|+
name|oldbytes
argument_list|,
literal|0
argument_list|,
name|bytes
operator|-
name|oldbytes
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|ptr
operator|=
name|bfd_zmalloc
argument_list|(
operator|(
name|bfd_size_type
operator|)
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
return|return
name|false
return|;
comment|/* And arrange for that done flag to be at index -1.  */
name|h
operator|->
name|vtable_entries_used
operator|=
name|ptr
operator|+
literal|1
expr_stmt|;
name|h
operator|->
name|vtable_entries_size
operator|=
name|size
expr_stmt|;
block|}
name|h
operator|->
name|vtable_entries_used
index|[
name|addend
operator|/
name|file_align
index|]
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* And an accompanying bit to work out final got entry offsets once    we're done.  Should be called from final_link.  */
end_comment

begin_function
name|boolean
name|elf_gc_common_finalize_got_offsets
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|bfd
modifier|*
name|i
decl_stmt|;
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|bfd_vma
name|gotoff
decl_stmt|;
comment|/* The GOT offset is relative to the .got section, but the GOT header is      put into the .got.plt section, if the backend uses it.  */
if|if
condition|(
name|bed
operator|->
name|want_got_plt
condition|)
name|gotoff
operator|=
literal|0
expr_stmt|;
else|else
name|gotoff
operator|=
name|bed
operator|->
name|got_header_size
expr_stmt|;
comment|/* Do the local .got entries first.  */
for|for
control|(
name|i
operator|=
name|info
operator|->
name|input_bfds
init|;
name|i
condition|;
name|i
operator|=
name|i
operator|->
name|link_next
control|)
block|{
name|bfd_signed_vma
modifier|*
name|local_got
decl_stmt|;
name|bfd_size_type
name|j
decl_stmt|,
name|locsymcount
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|i
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
continue|continue;
name|local_got
operator|=
name|elf_local_got_refcounts
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|local_got
condition|)
continue|continue;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|i
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
if|if
condition|(
name|elf_bad_symtab
argument_list|(
name|i
argument_list|)
condition|)
name|locsymcount
operator|=
name|symtab_hdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
expr_stmt|;
else|else
name|locsymcount
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|locsymcount
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|local_got
index|[
name|j
index|]
operator|>
literal|0
condition|)
block|{
name|local_got
index|[
name|j
index|]
operator|=
name|gotoff
expr_stmt|;
name|gotoff
operator|+=
name|ARCH_SIZE
operator|/
literal|8
expr_stmt|;
block|}
else|else
name|local_got
index|[
name|j
index|]
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
block|}
block|}
comment|/* Then the global .got entries.  .plt refcounts are handled by      adjust_dynamic_symbol  */
name|elf_link_hash_traverse
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|elf_gc_allocate_got_offsets
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|gotoff
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* We need a special top-level link routine to convert got reference counts    to real got offsets.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf_gc_allocate_got_offsets
parameter_list|(
name|h
parameter_list|,
name|offarg
parameter_list|)
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|PTR
name|offarg
decl_stmt|;
block|{
name|bfd_vma
modifier|*
name|off
init|=
operator|(
name|bfd_vma
operator|*
operator|)
name|offarg
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|refcount
operator|>
literal|0
condition|)
block|{
name|h
operator|->
name|got
operator|.
name|offset
operator|=
name|off
index|[
literal|0
index|]
expr_stmt|;
name|off
index|[
literal|0
index|]
operator|+=
name|ARCH_SIZE
operator|/
literal|8
expr_stmt|;
block|}
else|else
name|h
operator|->
name|got
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Many folk need no more in the way of final link than this, once    got entry reference counting is enabled.  */
end_comment

begin_function
name|boolean
name|elf_gc_common_final_link
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|elf_gc_common_finalize_got_offsets
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Invoke the regular ELF backend linker to do all the work.  */
return|return
name|elf_bfd_final_link
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This function will be called though elf_link_hash_traverse to store    all hash value of the exported symbols in an array.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf_collect_hash_codes
parameter_list|(
name|h
parameter_list|,
name|data
parameter_list|)
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
name|unsigned
name|long
modifier|*
modifier|*
name|valuep
init|=
operator|(
name|unsigned
name|long
operator|*
operator|*
operator|)
name|data
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|long
name|ha
decl_stmt|;
name|char
modifier|*
name|alc
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
comment|/* Ignore indirect symbols.  These are added by the versioning code.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
return|return
name|true
return|;
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
name|ELF_VER_CHR
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|alc
operator|=
name|bfd_malloc
argument_list|(
call|(
name|bfd_size_type
call|)
argument_list|(
name|p
operator|-
name|name
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|alc
argument_list|,
name|name
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|p
operator|-
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|alc
index|[
name|p
operator|-
name|name
index|]
operator|=
literal|'\0'
expr_stmt|;
name|name
operator|=
name|alc
expr_stmt|;
block|}
comment|/* Compute the hash value.  */
name|ha
operator|=
name|bfd_elf_hash
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* Store the found hash value in the array given as the argument.  */
operator|*
operator|(
operator|*
name|valuep
operator|)
operator|++
operator|=
name|ha
expr_stmt|;
comment|/* And store it in the struct so that we can put it in the hash table      later.  */
name|h
operator|->
name|elf_hash_value
operator|=
name|ha
expr_stmt|;
if|if
condition|(
name|alc
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|alc
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
name|boolean
name|elf_reloc_symbol_deleted_p
parameter_list|(
name|offset
parameter_list|,
name|cookie
parameter_list|)
name|bfd_vma
name|offset
decl_stmt|;
name|PTR
name|cookie
decl_stmt|;
block|{
name|struct
name|elf_reloc_cookie
modifier|*
name|rcookie
init|=
operator|(
expr|struct
name|elf_reloc_cookie
operator|*
operator|)
name|cookie
decl_stmt|;
if|if
condition|(
name|rcookie
operator|->
name|bad_symtab
condition|)
name|rcookie
operator|->
name|rel
operator|=
name|rcookie
operator|->
name|rels
expr_stmt|;
for|for
control|(
init|;
name|rcookie
operator|->
name|rel
operator|<
name|rcookie
operator|->
name|relend
condition|;
name|rcookie
operator|->
name|rel
operator|++
control|)
block|{
name|unsigned
name|long
name|r_symndx
init|=
name|ELF_R_SYM
argument_list|(
name|rcookie
operator|->
name|rel
operator|->
name|r_info
argument_list|)
decl_stmt|;
name|Elf_Internal_Sym
name|isym
decl_stmt|;
if|if
condition|(
operator|!
name|rcookie
operator|->
name|bad_symtab
condition|)
if|if
condition|(
name|rcookie
operator|->
name|rel
operator|->
name|r_offset
operator|>
name|offset
condition|)
return|return
name|false
return|;
if|if
condition|(
name|rcookie
operator|->
name|rel
operator|->
name|r_offset
operator|!=
name|offset
condition|)
continue|continue;
if|if
condition|(
name|rcookie
operator|->
name|locsyms
operator|&&
name|r_symndx
operator|<
name|rcookie
operator|->
name|locsymcount
condition|)
block|{
name|Elf_External_Sym
modifier|*
name|lsym
decl_stmt|;
name|Elf_External_Sym_Shndx
modifier|*
name|lshndx
decl_stmt|;
name|lsym
operator|=
operator|(
name|Elf_External_Sym
operator|*
operator|)
name|rcookie
operator|->
name|locsyms
operator|+
name|r_symndx
expr_stmt|;
name|lshndx
operator|=
operator|(
name|Elf_External_Sym_Shndx
operator|*
operator|)
name|rcookie
operator|->
name|locsym_shndx
expr_stmt|;
if|if
condition|(
name|lshndx
operator|!=
name|NULL
condition|)
name|lshndx
operator|+=
name|r_symndx
expr_stmt|;
name|elf_swap_symbol_in
argument_list|(
name|rcookie
operator|->
name|abfd
argument_list|,
name|lsym
argument_list|,
name|lshndx
argument_list|,
operator|&
name|isym
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r_symndx
operator|>=
name|rcookie
operator|->
name|locsymcount
operator|||
operator|(
name|rcookie
operator|->
name|locsyms
operator|&&
name|ELF_ST_BIND
argument_list|(
name|isym
operator|.
name|st_info
argument_list|)
operator|!=
name|STB_LOCAL
operator|)
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
name|rcookie
operator|->
name|sym_hashes
index|[
name|r_symndx
operator|-
name|rcookie
operator|->
name|extsymoff
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
name|elf_discarded_section
argument_list|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
argument_list|)
condition|)
return|return
name|true
return|;
else|else
return|return
name|false
return|;
block|}
elseif|else
if|if
condition|(
name|rcookie
operator|->
name|locsyms
condition|)
block|{
comment|/* It's not a relocation against a global symbol, 	     but it could be a relocation against a local 	     symbol for a discarded section.  */
name|asection
modifier|*
name|isec
decl_stmt|;
comment|/* Need to: get the symbol; get the section.  */
if|if
condition|(
name|isym
operator|.
name|st_shndx
operator|<
name|SHN_LORESERVE
operator|||
name|isym
operator|.
name|st_shndx
operator|>
name|SHN_HIRESERVE
condition|)
block|{
name|isec
operator|=
name|section_from_elf_index
argument_list|(
name|rcookie
operator|->
name|abfd
argument_list|,
name|isym
operator|.
name|st_shndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|isec
operator|!=
name|NULL
operator|&&
name|elf_discarded_section
argument_list|(
name|isec
argument_list|)
condition|)
return|return
name|true
return|;
block|}
block|}
return|return
name|false
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Discard unneeded references to discarded sections.    Returns true if any section's size was changed.  */
end_comment

begin_comment
comment|/* This function assumes that the relocations are in sorted order,    which is true for all known assemblers.  */
end_comment

begin_function
name|boolean
name|elf_bfd_discard_info
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|struct
name|elf_reloc_cookie
name|cookie
decl_stmt|;
name|asection
modifier|*
name|stab
decl_stmt|,
modifier|*
name|eh
decl_stmt|,
modifier|*
name|ehdr
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|shndx_hdr
decl_stmt|;
name|Elf_External_Sym
modifier|*
name|freesyms
decl_stmt|;
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|boolean
name|ret
init|=
name|false
decl_stmt|;
name|boolean
name|strip
init|=
name|info
operator|->
name|strip
operator|==
name|strip_all
operator|||
name|info
operator|->
name|strip
operator|==
name|strip_debugger
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocateable
operator|||
name|info
operator|->
name|traditional_format
operator|||
name|info
operator|->
name|hash
operator|->
name|creator
operator|->
name|flavour
operator|!=
name|bfd_target_elf_flavour
operator|||
operator|!
name|is_elf_hash_table
argument_list|(
name|info
argument_list|)
condition|)
return|return
name|false
return|;
name|ehdr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
operator|!=
name|NULL
condition|)
name|ehdr
operator|=
name|bfd_get_section_by_name
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
argument_list|,
literal|".eh_frame_hdr"
argument_list|)
expr_stmt|;
for|for
control|(
name|abfd
operator|=
name|info
operator|->
name|input_bfds
init|;
name|abfd
operator|!=
name|NULL
condition|;
name|abfd
operator|=
name|abfd
operator|->
name|link_next
control|)
block|{
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|abfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
continue|continue;
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
condition|)
continue|continue;
name|eh
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ehdr
condition|)
block|{
name|eh
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".eh_frame"
argument_list|)
expr_stmt|;
if|if
condition|(
name|eh
operator|&&
name|eh
operator|->
name|_raw_size
operator|==
literal|0
condition|)
name|eh
operator|=
name|NULL
expr_stmt|;
block|}
name|stab
operator|=
name|strip
condition|?
name|NULL
else|:
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".stab"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|stab
operator|||
name|elf_section_data
argument_list|(
name|stab
argument_list|)
operator|->
name|sec_info_type
operator|!=
name|ELF_INFO_TYPE_STABS
operator|)
operator|&&
operator|!
name|eh
operator|&&
operator|(
name|strip
operator|||
operator|!
name|bed
operator|->
name|elf_backend_discard_info
operator|)
condition|)
continue|continue;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|shndx_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_shndx_hdr
expr_stmt|;
name|cookie
operator|.
name|abfd
operator|=
name|abfd
expr_stmt|;
name|cookie
operator|.
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|cookie
operator|.
name|bad_symtab
operator|=
name|elf_bad_symtab
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|cookie
operator|.
name|bad_symtab
condition|)
block|{
name|cookie
operator|.
name|locsymcount
operator|=
name|symtab_hdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
expr_stmt|;
name|cookie
operator|.
name|extsymoff
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|cookie
operator|.
name|locsymcount
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|cookie
operator|.
name|extsymoff
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
block|}
name|freesyms
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|symtab_hdr
operator|->
name|contents
condition|)
name|cookie
operator|.
name|locsyms
operator|=
operator|(
name|void
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
elseif|else
if|if
condition|(
name|cookie
operator|.
name|locsymcount
operator|==
literal|0
condition|)
name|cookie
operator|.
name|locsyms
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|bfd_size_type
name|amt
init|=
name|cookie
operator|.
name|locsymcount
operator|*
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
decl_stmt|;
name|cookie
operator|.
name|locsyms
operator|=
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|cookie
operator|.
name|locsyms
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|freesyms
operator|=
name|cookie
operator|.
name|locsyms
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bread
argument_list|(
name|cookie
operator|.
name|locsyms
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
block|{
name|error_ret_free_loc
label|:
name|free
argument_list|(
name|cookie
operator|.
name|locsyms
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
name|cookie
operator|.
name|locsym_shndx
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|shndx_hdr
operator|->
name|sh_size
operator|!=
literal|0
operator|&&
name|cookie
operator|.
name|locsymcount
operator|!=
literal|0
condition|)
block|{
name|bfd_size_type
name|amt
decl_stmt|;
name|amt
operator|=
name|cookie
operator|.
name|locsymcount
operator|*
sizeof|sizeof
argument_list|(
name|Elf_External_Sym_Shndx
argument_list|)
expr_stmt|;
name|cookie
operator|.
name|locsym_shndx
operator|=
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|cookie
operator|.
name|locsym_shndx
operator|==
name|NULL
condition|)
goto|goto
name|error_ret_free_loc
goto|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|shndx_hdr
operator|->
name|sh_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bread
argument_list|(
name|cookie
operator|.
name|locsym_shndx
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
block|{
name|free
argument_list|(
name|cookie
operator|.
name|locsym_shndx
argument_list|)
expr_stmt|;
goto|goto
name|error_ret_free_loc
goto|;
block|}
block|}
if|if
condition|(
name|stab
condition|)
block|{
name|cookie
operator|.
name|rels
operator|=
operator|(
name|NAME
argument_list|(
name|_bfd_elf
argument_list|,
name|link_read_relocs
argument_list|)
argument_list|(
name|abfd
argument_list|,
name|stab
argument_list|,
operator|(
name|PTR
operator|)
name|NULL
argument_list|,
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
name|NULL
argument_list|,
name|info
operator|->
name|keep_memory
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|cookie
operator|.
name|rels
condition|)
block|{
name|cookie
operator|.
name|rel
operator|=
name|cookie
operator|.
name|rels
expr_stmt|;
name|cookie
operator|.
name|relend
operator|=
name|cookie
operator|.
name|rels
operator|+
name|stab
operator|->
name|reloc_count
operator|*
name|bed
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
expr_stmt|;
if|if
condition|(
name|_bfd_discard_section_stabs
argument_list|(
name|abfd
argument_list|,
name|stab
argument_list|,
name|elf_section_data
argument_list|(
name|stab
argument_list|)
operator|->
name|sec_info
argument_list|,
name|elf_reloc_symbol_deleted_p
argument_list|,
operator|&
name|cookie
argument_list|)
condition|)
name|ret
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|cookie
operator|.
name|rels
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|eh
condition|)
block|{
name|cookie
operator|.
name|rels
operator|=
name|NULL
expr_stmt|;
name|cookie
operator|.
name|rel
operator|=
name|NULL
expr_stmt|;
name|cookie
operator|.
name|relend
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|eh
operator|->
name|reloc_count
condition|)
name|cookie
operator|.
name|rels
operator|=
operator|(
name|NAME
argument_list|(
name|_bfd_elf
argument_list|,
name|link_read_relocs
argument_list|)
argument_list|(
name|abfd
argument_list|,
name|eh
argument_list|,
operator|(
name|PTR
operator|)
name|NULL
argument_list|,
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
name|NULL
argument_list|,
name|info
operator|->
name|keep_memory
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|cookie
operator|.
name|rels
condition|)
block|{
name|cookie
operator|.
name|rel
operator|=
name|cookie
operator|.
name|rels
expr_stmt|;
name|cookie
operator|.
name|relend
operator|=
name|cookie
operator|.
name|rels
operator|+
name|eh
operator|->
name|reloc_count
operator|*
name|bed
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
expr_stmt|;
block|}
if|if
condition|(
name|_bfd_elf_discard_section_eh_frame
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|eh
argument_list|,
name|ehdr
argument_list|,
name|elf_reloc_symbol_deleted_p
argument_list|,
operator|&
name|cookie
argument_list|)
condition|)
name|ret
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|cookie
operator|.
name|rels
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bed
operator|->
name|elf_backend_discard_info
condition|)
block|{
if|if
condition|(
name|bed
operator|->
name|elf_backend_discard_info
argument_list|(
name|abfd
argument_list|,
operator|&
name|cookie
argument_list|,
name|info
argument_list|)
condition|)
name|ret
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|cookie
operator|.
name|locsym_shndx
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|cookie
operator|.
name|locsym_shndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|freesyms
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|freesyms
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ehdr
operator|&&
name|_bfd_elf_discard_section_eh_frame_hdr
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|ehdr
argument_list|)
condition|)
name|ret
operator|=
name|true
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|elf_section_ignore_discarded_relocs
parameter_list|(
name|sec
parameter_list|)
name|asection
modifier|*
name|sec
decl_stmt|;
block|{
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
switch|switch
condition|(
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|sec_info_type
condition|)
block|{
case|case
name|ELF_INFO_TYPE_STABS
case|:
case|case
name|ELF_INFO_TYPE_EH_FRAME
case|:
return|return
name|true
return|;
default|default:
break|break;
block|}
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|sec
operator|->
name|owner
argument_list|)
expr_stmt|;
if|if
condition|(
name|bed
operator|->
name|elf_backend_ignore_discarded_relocs
operator|!=
name|NULL
operator|&&
call|(
modifier|*
name|bed
operator|->
name|elf_backend_ignore_discarded_relocs
call|)
argument_list|(
name|sec
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

end_unit

