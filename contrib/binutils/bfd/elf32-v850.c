begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* V850-specific support for 32-bit ELF    Copyright (C) 1996, 1997, 1998 Free Software Foundation, Inc.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* XXX FIXME: This code is littered with 32bit int, 16bit short, 8bit char    dependencies.  As is the gas& simulator code or the v850.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf/v850.h"
end_include

begin_comment
comment|/* sign-extend a 24-bit number */
end_comment

begin_define
define|#
directive|define
name|SEXT24
parameter_list|(
name|x
parameter_list|)
value|((((x)& 0xffffff) ^ (~ 0x7fffff)) + 0x800000)
end_define

begin_decl_stmt
specifier|static
name|reloc_howto_type
modifier|*
name|v850_elf_reloc_type_lookup
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|bfd_reloc_code_real_type
name|code
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|v850_elf_info_to_howto_rel
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|Elf32_Internal_Rel
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|v850_elf_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|v850_elf_is_local_label_name
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|v850_elf_relocate_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|,
name|asection
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Try to minimize the amount of space occupied by relocation tables    on the ROM (not that the ROM won't be swamped by other ELF overhead).  */
end_comment

begin_define
define|#
directive|define
name|USE_REL
end_define

begin_comment
comment|/* Note: It is REQUIRED that the 'type' value of each entry in this array    match the index of the entry in the array.  */
end_comment

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|v850_elf_howto_table
index|[]
init|=
block|{
comment|/* This reloc does nothing.  */
name|HOWTO
argument_list|(
name|R_V850_NONE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_V850_NONE"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A PC relative 9 bit branch. */
name|HOWTO
argument_list|(
name|R_V850_9_PCREL
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|26
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|v850_elf_reloc
argument_list|,
comment|/* special_function */
literal|"R_V850_9_PCREL"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0x00ffffff
argument_list|,
comment|/* src_mask */
literal|0x00ffffff
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A PC relative 22 bit branch. */
name|HOWTO
argument_list|(
name|R_V850_22_PCREL
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|22
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|7
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|v850_elf_reloc
argument_list|,
comment|/* special_function */
literal|"R_V850_22_PCREL"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0x07ffff80
argument_list|,
comment|/* src_mask */
literal|0x07ffff80
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* High 16 bits of symbol value.  */
name|HOWTO
argument_list|(
name|R_V850_HI16_S
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|v850_elf_reloc
argument_list|,
comment|/* special_function */
literal|"R_V850_HI16_S"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* High 16 bits of symbol value.  */
name|HOWTO
argument_list|(
name|R_V850_HI16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|v850_elf_reloc
argument_list|,
comment|/* special_function */
literal|"R_V850_HI16"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Low 16 bits of symbol value.  */
name|HOWTO
argument_list|(
name|R_V850_LO16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|v850_elf_reloc
argument_list|,
comment|/* special_function */
literal|"R_V850_LO16"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Simple 32bit reloc.  */
name|HOWTO
argument_list|(
name|R_V850_32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|v850_elf_reloc
argument_list|,
comment|/* special_function */
literal|"R_V850_32"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Simple 16bit reloc.  */
name|HOWTO
argument_list|(
name|R_V850_16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_V850_16"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Simple 8bit reloc.	 */
name|HOWTO
argument_list|(
name|R_V850_8
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_V850_8"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xff
argument_list|,
comment|/* src_mask */
literal|0xff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16 bit offset from the short data area pointer.  */
name|HOWTO
argument_list|(
name|R_V850_SDA_16_16_OFFSET
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|v850_elf_reloc
argument_list|,
comment|/* special_function */
literal|"R_V850_SDA_16_16_OFFSET"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 15 bit offset from the short data area pointer.  */
name|HOWTO
argument_list|(
name|R_V850_SDA_15_16_OFFSET
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|1
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|v850_elf_reloc
argument_list|,
comment|/* special_function */
literal|"R_V850_SDA_15_16_OFFSET"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0xfffe
argument_list|,
comment|/* src_mask */
literal|0xfffe
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16 bit offset from the zero data area pointer.  */
name|HOWTO
argument_list|(
name|R_V850_ZDA_16_16_OFFSET
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|v850_elf_reloc
argument_list|,
comment|/* special_function */
literal|"R_V850_ZDA_16_16_OFFSET"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 15 bit offset from the zero data area pointer.  */
name|HOWTO
argument_list|(
name|R_V850_ZDA_15_16_OFFSET
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|1
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|v850_elf_reloc
argument_list|,
comment|/* special_function */
literal|"R_V850_ZDA_15_16_OFFSET"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0xfffe
argument_list|,
comment|/* src_mask */
literal|0xfffe
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 6 bit offset from the tiny data area pointer.  */
name|HOWTO
argument_list|(
name|R_V850_TDA_6_8_OFFSET
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|1
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|v850_elf_reloc
argument_list|,
comment|/* special_function */
literal|"R_V850_TDA_6_8_OFFSET"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0x7e
argument_list|,
comment|/* src_mask */
literal|0x7e
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 8 bit offset from the tiny data area pointer.  */
name|HOWTO
argument_list|(
name|R_V850_TDA_7_8_OFFSET
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|v850_elf_reloc
argument_list|,
comment|/* special_function */
literal|"R_V850_TDA_7_8_OFFSET"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0x7f
argument_list|,
comment|/* src_mask */
literal|0x7f
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 7 bit offset from the tiny data area pointer.  */
name|HOWTO
argument_list|(
name|R_V850_TDA_7_7_OFFSET
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|7
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|v850_elf_reloc
argument_list|,
comment|/* special_function */
literal|"R_V850_TDA_7_7_OFFSET"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0x7f
argument_list|,
comment|/* src_mask */
literal|0x7f
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16 bit offset from the tiny data area pointer!  */
name|HOWTO
argument_list|(
name|R_V850_TDA_16_16_OFFSET
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|v850_elf_reloc
argument_list|,
comment|/* special_function */
literal|"R_V850_TDA_16_16_OFFSET"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xfff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Map BFD reloc types to V850 ELF reloc types.  */
end_comment

begin_struct
struct|struct
name|v850_elf_reloc_map
block|{
name|unsigned
name|char
name|bfd_reloc_val
decl_stmt|;
name|unsigned
name|char
name|elf_reloc_val
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|v850_elf_reloc_map
name|v850_elf_reloc_map
index|[]
init|=
block|{
block|{
name|BFD_RELOC_NONE
block|,
name|R_V850_NONE
block|}
block|,
block|{
name|BFD_RELOC_V850_9_PCREL
block|,
name|R_V850_9_PCREL
block|}
block|,
block|{
name|BFD_RELOC_V850_22_PCREL
block|,
name|R_V850_22_PCREL
block|}
block|,
block|{
name|BFD_RELOC_HI16_S
block|,
name|R_V850_HI16_S
block|}
block|,
block|{
name|BFD_RELOC_HI16
block|,
name|R_V850_HI16
block|}
block|,
block|{
name|BFD_RELOC_LO16
block|,
name|R_V850_LO16
block|}
block|,
block|{
name|BFD_RELOC_32
block|,
name|R_V850_32
block|}
block|,
block|{
name|BFD_RELOC_16
block|,
name|R_V850_16
block|}
block|,
block|{
name|BFD_RELOC_8
block|,
name|R_V850_8
block|}
block|,
block|{
name|BFD_RELOC_V850_SDA_16_16_OFFSET
block|,
name|R_V850_SDA_16_16_OFFSET
block|}
block|,
block|{
name|BFD_RELOC_V850_SDA_15_16_OFFSET
block|,
name|R_V850_SDA_15_16_OFFSET
block|}
block|,
block|{
name|BFD_RELOC_V850_ZDA_16_16_OFFSET
block|,
name|R_V850_ZDA_16_16_OFFSET
block|}
block|,
block|{
name|BFD_RELOC_V850_ZDA_15_16_OFFSET
block|,
name|R_V850_ZDA_15_16_OFFSET
block|}
block|,
block|{
name|BFD_RELOC_V850_TDA_6_8_OFFSET
block|,
name|R_V850_TDA_6_8_OFFSET
block|}
block|,
block|{
name|BFD_RELOC_V850_TDA_7_8_OFFSET
block|,
name|R_V850_TDA_7_8_OFFSET
block|}
block|,
block|{
name|BFD_RELOC_V850_TDA_7_7_OFFSET
block|,
name|R_V850_TDA_7_7_OFFSET
block|}
block|,
block|{
name|BFD_RELOC_V850_TDA_16_16_OFFSET
block|,
name|R_V850_TDA_16_16_OFFSET
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Map a bfd relocation into the appropriate howto structure */
end_comment

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|v850_elf_reloc_type_lookup
parameter_list|(
name|abfd
parameter_list|,
name|code
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|v850_elf_reloc_map
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|v850_elf_reloc_map
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|v850_elf_reloc_map
index|[
name|i
index|]
operator|.
name|bfd_reloc_val
operator|==
name|code
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|v850_elf_howto_table
index|[
name|v850_elf_reloc_map
index|[
name|i
index|]
operator|.
name|elf_reloc_val
index|]
operator|.
name|type
operator|==
name|v850_elf_reloc_map
index|[
name|i
index|]
operator|.
name|elf_reloc_val
argument_list|)
expr_stmt|;
return|return
operator|&
name|v850_elf_howto_table
index|[
name|v850_elf_reloc_map
index|[
name|i
index|]
operator|.
name|elf_reloc_val
index|]
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set the howto pointer for an V850 ELF reloc.  */
end_comment

begin_function
specifier|static
name|void
name|v850_elf_info_to_howto_rel
parameter_list|(
name|abfd
parameter_list|,
name|cache_ptr
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|cache_ptr
decl_stmt|;
name|Elf32_Internal_Rel
modifier|*
name|dst
decl_stmt|;
block|{
name|unsigned
name|int
name|r_type
decl_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|dst
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|r_type
operator|<
operator|(
name|unsigned
name|int
operator|)
name|R_V850_max
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|howto
operator|=
operator|&
name|v850_elf_howto_table
index|[
name|r_type
index|]
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Look through the relocs for a section during the first phase, and    allocate space in the global offset table or procedure linkage    table.  */
end_comment

begin_function
specifier|static
name|boolean
name|v850_elf_check_relocs
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|sec
parameter_list|,
name|relocs
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|;
block|{
name|boolean
name|ret
init|=
name|true
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel_end
decl_stmt|;
name|asection
modifier|*
name|sreloc
decl_stmt|;
name|enum
name|v850_reloc_type
name|r_type
decl_stmt|;
name|int
name|other
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|common
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
literal|0
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocateable
condition|)
return|return
name|true
return|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"v850_elf_check_relocs called for section %s in %s\n"
argument_list|,
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|sreloc
operator|=
name|NULL
expr_stmt|;
name|rel_end
operator|=
name|relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|rel_end
condition|;
name|rel
operator|++
control|)
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
name|h
operator|=
name|NULL
expr_stmt|;
else|else
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
name|r_type
operator|=
operator|(
expr|enum
name|v850_reloc_type
operator|)
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
default|default:
case|case
name|R_V850_NONE
case|:
case|case
name|R_V850_9_PCREL
case|:
case|case
name|R_V850_22_PCREL
case|:
case|case
name|R_V850_HI16_S
case|:
case|case
name|R_V850_HI16
case|:
case|case
name|R_V850_LO16
case|:
case|case
name|R_V850_32
case|:
case|case
name|R_V850_16
case|:
case|case
name|R_V850_8
case|:
break|break;
case|case
name|R_V850_SDA_16_16_OFFSET
case|:
case|case
name|R_V850_SDA_15_16_OFFSET
case|:
name|other
operator|=
name|V850_OTHER_SDA
expr_stmt|;
name|common
operator|=
literal|".scommon"
expr_stmt|;
goto|goto
name|small_data_common
goto|;
case|case
name|R_V850_ZDA_16_16_OFFSET
case|:
case|case
name|R_V850_ZDA_15_16_OFFSET
case|:
name|other
operator|=
name|V850_OTHER_ZDA
expr_stmt|;
name|common
operator|=
literal|".zcommon"
expr_stmt|;
goto|goto
name|small_data_common
goto|;
case|case
name|R_V850_TDA_6_8_OFFSET
case|:
case|case
name|R_V850_TDA_7_8_OFFSET
case|:
case|case
name|R_V850_TDA_7_7_OFFSET
case|:
case|case
name|R_V850_TDA_16_16_OFFSET
case|:
name|other
operator|=
name|V850_OTHER_TDA
expr_stmt|;
name|common
operator|=
literal|".tcommon"
expr_stmt|;
comment|/* fall through */
define|#
directive|define
name|V850_OTHER_MASK
value|(V850_OTHER_TDA | V850_OTHER_SDA | V850_OTHER_ZDA)
name|small_data_common
label|:
if|if
condition|(
name|h
condition|)
block|{
name|h
operator|->
name|other
operator||=
name|other
expr_stmt|;
comment|/* flag which type of relocation was used */
if|if
condition|(
operator|(
name|h
operator|->
name|other
operator|&
name|V850_OTHER_MASK
operator|)
operator|!=
operator|(
name|other
operator|&
name|V850_OTHER_MASK
operator|)
operator|&&
operator|(
name|h
operator|->
name|other
operator|&
name|V850_OTHER_ERROR
operator|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
specifier|static
name|char
name|buff
index|[
literal|100
index|]
decl_stmt|;
comment|/* XXX */
switch|switch
condition|(
name|h
operator|->
name|other
operator|&
name|V850_OTHER_MASK
condition|)
block|{
default|default:
name|msg
operator|=
literal|"cannot occupy in multiple small data regions"
expr_stmt|;
break|break;
case|case
name|V850_OTHER_SDA
operator||
name|V850_OTHER_ZDA
operator||
name|V850_OTHER_TDA
case|:
name|msg
operator|=
literal|"can only be in one of the small, zero, and tiny data regions"
expr_stmt|;
break|break;
case|case
name|V850_OTHER_SDA
operator||
name|V850_OTHER_ZDA
case|:
name|msg
operator|=
literal|"cannot be in both small and zero data regions simultaneously"
expr_stmt|;
break|break;
case|case
name|V850_OTHER_SDA
operator||
name|V850_OTHER_TDA
case|:
name|msg
operator|=
literal|"cannot be in both small and tiny data regions simultaneously"
expr_stmt|;
break|break;
case|case
name|V850_OTHER_ZDA
operator||
name|V850_OTHER_TDA
case|:
name|msg
operator|=
literal|"cannot be in both zero and tiny data regions simultaneously"
expr_stmt|;
break|break;
block|}
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"Variable '%s' %s"
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|info
operator|->
name|callbacks
operator|->
name|warning
argument_list|(
name|info
argument_list|,
name|buff
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|abfd
argument_list|,
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
name|h
operator|->
name|other
operator||=
name|V850_OTHER_ERROR
expr_stmt|;
name|ret
operator|=
name|false
expr_stmt|;
block|}
block|}
if|if
condition|(
name|h
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_common
operator|&&
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|&&
operator|!
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
argument_list|)
argument_list|,
literal|"COMMON"
argument_list|)
condition|)
block|{
name|asection
modifier|*
name|section
init|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
operator|=
name|bfd_make_section_old_way
argument_list|(
name|abfd
argument_list|,
name|common
argument_list|)
decl_stmt|;
name|section
operator|->
name|flags
operator||=
name|SEC_IS_COMMON
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"v850_elf_check_relocs, found %s relocation for %s%s\n"
argument_list|,
name|v850_elf_howto_table
index|[
operator|(
name|int
operator|)
name|r_type
index|]
operator|.
name|name
argument_list|,
operator|(
name|h
operator|&&
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
operator|)
condition|?
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
else|:
literal|"<unknown>"
argument_list|,
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_common
operator|)
condition|?
literal|", symbol is common"
else|:
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
return|return
name|ret
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
block|{
name|long
name|addend
decl_stmt|;
name|bfd_byte
modifier|*
name|address
decl_stmt|;
name|unsigned
name|long
name|counter
decl_stmt|;
block|}
name|hi16s_location
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|hi16s_location
name|previous_hi16s
index|[
literal|10
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX is this enough ? */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|hi16s_counter
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|remember_hi16s_reloc
parameter_list|(
name|addend
parameter_list|,
name|address
parameter_list|)
name|long
name|addend
decl_stmt|;
name|bfd_byte
modifier|*
name|address
decl_stmt|;
block|{
name|hi16s_location
modifier|*
name|oldest
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Find a free slot.  */
for|for
control|(
name|i
operator|=
sizeof|sizeof
argument_list|(
name|previous_hi16s
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|previous_hi16s
index|[
literal|0
index|]
argument_list|)
init|;
name|i
operator|--
condition|;
control|)
block|{
name|hi16s_location
modifier|*
name|entry
init|=
name|previous_hi16s
operator|+
name|i
decl_stmt|;
if|if
condition|(
name|entry
operator|->
name|addend
operator|==
literal|0
operator|&&
name|entry
operator|->
name|address
operator|==
literal|0
condition|)
block|{
comment|/* Use this entry.  */
name|oldest
operator|=
name|entry
expr_stmt|;
break|break;
block|}
comment|/* Remember the least recently added entry.  */
if|if
condition|(
name|oldest
operator|==
name|NULL
operator|||
name|oldest
operator|->
name|counter
operator|>
name|entry
operator|->
name|counter
condition|)
name|oldest
operator|=
name|entry
expr_stmt|;
block|}
name|oldest
operator|->
name|addend
operator|=
name|addend
expr_stmt|;
name|oldest
operator|->
name|address
operator|=
name|address
expr_stmt|;
name|oldest
operator|->
name|counter
operator|=
name|hi16s_counter
operator|++
expr_stmt|;
comment|/* Cope with wrap around of our counter.  */
if|if
condition|(
name|hi16s_counter
operator|==
literal|0
condition|)
block|{
comment|/* XXX - Assume that all counter entries differ only in their low 16 bits.  */
for|for
control|(
name|i
operator|=
sizeof|sizeof
argument_list|(
name|previous_hi16s
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|previous_hi16s
index|[
literal|0
index|]
argument_list|)
init|;
name|i
operator|--
condition|;
control|)
block|{
name|hi16s_location
modifier|*
name|entry
init|=
name|previous_hi16s
operator|+
name|i
decl_stmt|;
name|entry
operator|->
name|counter
operator|&=
literal|0xffff
expr_stmt|;
block|}
name|hi16s_counter
operator|=
literal|0x10000
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|bfd_byte
modifier|*
name|find_remembered_hi16s_reloc
parameter_list|(
name|addend
parameter_list|)
name|long
name|addend
decl_stmt|;
block|{
name|hi16s_location
modifier|*
name|match
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Search the table.  Record the most recent entry that matches.  */
for|for
control|(
name|i
operator|=
sizeof|sizeof
argument_list|(
name|previous_hi16s
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|previous_hi16s
index|[
literal|0
index|]
argument_list|)
init|;
name|i
operator|--
condition|;
control|)
block|{
name|hi16s_location
modifier|*
name|entry
init|=
name|previous_hi16s
operator|+
name|i
decl_stmt|;
if|if
condition|(
name|entry
operator|->
name|addend
operator|==
name|addend
condition|)
block|{
if|if
condition|(
name|match
operator|==
name|NULL
operator|||
name|match
operator|->
name|counter
operator|<
name|entry
operator|->
name|counter
condition|)
name|match
operator|=
name|entry
expr_stmt|;
block|}
block|}
if|if
condition|(
name|match
operator|!=
name|NULL
condition|)
block|{
name|bfd_byte
modifier|*
name|addr
decl_stmt|;
comment|/* Empty the table entry.  */
name|match
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
name|addr
operator|=
name|match
operator|->
name|address
expr_stmt|;
name|match
operator|->
name|address
operator|=
name|NULL
expr_stmt|;
return|return
name|addr
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_status_type
name|v850_elf_store_addend_in_insn
parameter_list|(
name|abfd
parameter_list|,
name|r_type
parameter_list|,
name|addend
parameter_list|,
name|address
parameter_list|,
name|replace
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|int
name|r_type
decl_stmt|;
name|long
name|addend
decl_stmt|;
name|bfd_byte
modifier|*
name|address
decl_stmt|;
name|boolean
name|replace
decl_stmt|;
block|{
name|unsigned
name|long
name|insn
decl_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
default|default:
comment|/* fprintf (stderr, "reloc type %d not SUPPORTED\n", r_type ); */
return|return
name|bfd_reloc_notsupported
return|;
case|case
name|R_V850_32
case|:
if|if
condition|(
operator|!
name|replace
condition|)
name|addend
operator|+=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|address
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|addend
argument_list|,
name|address
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_V850_22_PCREL
case|:
if|if
condition|(
name|addend
operator|>
literal|0x1fffff
operator|||
name|addend
operator|<
operator|-
literal|0x200000
condition|)
return|return
name|bfd_reloc_overflow
return|;
if|if
condition|(
operator|(
name|addend
operator|%
literal|2
operator|)
operator|!=
literal|0
condition|)
return|return
name|bfd_reloc_dangerous
return|;
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|address
argument_list|)
expr_stmt|;
name|insn
operator|&=
operator|~
literal|0xfffe003f
expr_stmt|;
name|insn
operator||=
operator|(
operator|(
operator|(
name|addend
operator|&
literal|0xfffe
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|addend
operator|&
literal|0x3f0000
operator|)
operator|>>
literal|16
operator|)
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|insn
argument_list|,
name|address
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_V850_9_PCREL
case|:
if|if
condition|(
name|addend
operator|>
literal|0xff
operator|||
name|addend
operator|<
operator|-
literal|0x100
condition|)
return|return
name|bfd_reloc_overflow
return|;
if|if
condition|(
operator|(
name|addend
operator|%
literal|2
operator|)
operator|!=
literal|0
condition|)
return|return
name|bfd_reloc_dangerous
return|;
name|insn
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|address
argument_list|)
expr_stmt|;
name|insn
operator|&=
operator|~
literal|0xf870
expr_stmt|;
name|insn
operator||=
operator|(
operator|(
name|addend
operator|&
literal|0x1f0
operator|)
operator|<<
literal|7
operator|)
operator||
operator|(
operator|(
name|addend
operator|&
literal|0x0e
operator|)
operator|<<
literal|3
operator|)
expr_stmt|;
break|break;
case|case
name|R_V850_HI16
case|:
name|addend
operator|+=
operator|(
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|address
argument_list|)
operator|<<
literal|16
operator|)
expr_stmt|;
name|addend
operator|=
operator|(
name|addend
operator|>>
literal|16
operator|)
expr_stmt|;
name|insn
operator|=
name|addend
expr_stmt|;
break|break;
case|case
name|R_V850_HI16_S
case|:
comment|/* Remember where this relocation took place.  */
name|remember_hi16s_reloc
argument_list|(
name|addend
argument_list|,
name|address
argument_list|)
expr_stmt|;
name|addend
operator|+=
operator|(
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|address
argument_list|)
operator|<<
literal|16
operator|)
expr_stmt|;
name|addend
operator|=
operator|(
name|addend
operator|>>
literal|16
operator|)
operator|+
operator|(
operator|(
name|addend
operator|&
literal|0x8000
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
comment|/* This relocation cannot overflow. */
if|if
condition|(
name|addend
operator|>
literal|0x7fff
operator|||
name|addend
operator|<
operator|-
literal|0x8000
condition|)
name|addend
operator|=
literal|0
expr_stmt|;
name|insn
operator|=
name|addend
expr_stmt|;
break|break;
case|case
name|R_V850_LO16
case|:
comment|/* Calculate the sum of the value stored in the instruction and the 	 addend and check for overflow from the low 16 bits into the high 	 16 bits.  The assembler has already done some of this:  If the 	 value stored in the instruction has its 15th bit set, (counting 	 from zero) then the assembler will have added 1 to the value 	 stored in the associated HI16S reloc.  So for example, these 	 relocations:  	     movhi hi( fred ), r0, r1 	     movea lo( fred ), r1, r1  	 will store 0 in the value fields for the MOVHI and MOVEA instructions 	 and addend will be the address of fred, but for these instructions:  	     movhi hi( fred + 0x123456), r0, r1 	     movea lo( fred + 0x123456), r1, r1  	 the value stored in the MOVHI instruction will be 0x12 and the value 	 stored in the MOVEA instruction will be 0x3456.  If however the 	 instructions were:  	     movhi hi( fred + 0x10ffff), r0, r1 	     movea lo( fred + 0x10ffff), r1, r1  	 then the value stored in the MOVHI instruction would be 0x11 (not 	 0x10) and the value stored in the MOVEA instruction would be 0xffff. 	 Thus (assuming for the moment that the addend is 0), at run time the 	 MOVHI instruction loads 0x110000 into r1, then the MOVEA instruction 	 adds 0xffffffff (sign extension!) producing 0x10ffff.  Similarly if 	 the instructions were:  	     movhi hi( fred - 1), r0, r1 	     movea lo( fred - 1), r1, r1  	 then 0 is stored in the MOVHI instruction and -1 is stored in the 	 MOVEA instruction.  	 Overflow can occur if the addition of the value stored in the 	 instruction plus the addend sets the 15th bit when before it was clear. 	 This is because the 15th bit will be sign extended into the high part, 	 thus reducing its value by one, but since the 15th bit was originally 	 clear, the assembler will not have added 1 to the previous HI16S reloc 	 to compensate for this effect.  For example:  	    movhi hi( fred + 0x123456), r0, r1 	    movea lo( fred + 0x123456), r1, r1  	 The value stored in HI16S reloc is 0x12, the value stored in the LO16 	 reloc is 0x3456.  If we assume that the address of fred is 0x00007000 	 then the relocations become:  	   HI16S: 0x0012 + (0x00007000>> 16)    = 0x12 	   LO16:  0x3456 + (0x00007000& 0xffff) = 0xa456  	 but when the instructions are executed, the MOVEA instruction's value 	 is signed extended, so the sum becomes:  	      0x00120000 	    + 0xffffa456 	    ------------ 	      0x0011a456    but 'fred + 0x123456' = 0x0012a456  	 Note that if the 15th bit was set in the value stored in the LO16 	 reloc, then we do not have to do anything:  	    movhi hi( fred + 0x10ffff), r0, r1 	    movea lo( fred + 0x10ffff), r1, r1  	    HI16S:  0x0011 + (0x00007000>> 16)    = 0x11 	    LO16:   0xffff + (0x00007000& 0xffff) = 0x6fff  	      0x00110000 	    + 0x00006fff 	    ------------ 	      0x00116fff  = fred + 0x10ffff = 0x7000 + 0x10ffff  	  	 Overflow can also occur if the computation carries into the 16th bit 	 and it also results in the 15th bit having the same value as the 15th 	 bit of the original value.   What happens is that the HI16S reloc 	 will have already examined the 15th bit of the original value and 	 added 1 to the high part if the bit is set.  This compensates for the 	 sign extension of 15th bit of the result of the computation.  But now 	 there is a carry into the 16th bit, and this has not been allowed for.  	 So, for example if fred is at address 0xf000:  	   movhi hi( fred + 0xffff), r0, r1    [bit 15 of the offset is set] 	   movea lo( fred + 0xffff), r1, r1  	   HI16S: 0x0001 + (0x0000f000>> 16)    = 0x0001 	   LO16:  0xffff + (0x0000f000& 0xffff) = 0xefff   (carry into bit 16 is lost)  	     0x00010000 	   + 0xffffefff 	   ------------ 	     0x0000efff   but 'fred + 0xffff' = 0x0001efff  	 Similarly, if the 15th bit remains clear, but overflow occurs into 	 the 16th bit then (assuming the address of fred is 0xf000):  	   movhi hi( fred + 0x7000), r0, r1    [bit 15 of the offset is clear] 	   movea lo( fred + 0x7000), r1, r1  	   HI16S: 0x0000 + (0x0000f000>> 16)    = 0x0000 	   LO16:  0x7000 + (0x0000f000& 0xffff) = 0x6fff  (carry into bit 16 is lost)  	     0x00000000 	   + 0x00006fff 	   ------------ 	     0x00006fff   but 'fred + 0x7000' = 0x00016fff 	    	 Note - there is no need to change anything if a carry occurs, and the 	 15th bit changes its value from being set to being clear, as the HI16S 	 reloc will have already added in 1 to the high part for us:  	   movhi hi( fred + 0xffff), r0, r1     [bit 15 of the offset is set] 	   movea lo( fred + 0xffff), r1, r1  	   HI16S: 0x0001 + (0x00007000>> 16) 	   LO16:  0xffff + (0x00007000& 0xffff) = 0x6fff  (carry into bit 16 is lost)  	     0x00010000 	   + 0x00006fff   (bit 15 not set, so the top half is zero) 	   ------------ 	     0x00016fff   which is right (assuming that fred is at 0x7000)  	 but if the 15th bit goes from being clear to being set, then we must 	 once again handle overflow:  	   movhi hi( fred + 0x7000), r0, r1     [bit 15 of the offset is clear] 	   movea lo( fred + 0x7000), r1, r1  	   HI16S: 0x0000 + (0x0000ffff>> 16) 	   LO16:  0x7000 + (0x0000ffff& 0xffff) = 0x6fff  (carry into bit 16)  	     0x00000000 	   + 0x00006fff   (bit 15 not set, so the top half is zero) 	   ------------ 	     0x00006fff   which is wrong (assuming that fred is at 0xffff) 	 */
block|{
name|long
name|result
decl_stmt|;
name|insn
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|address
argument_list|)
expr_stmt|;
name|result
operator|=
name|insn
operator|+
name|addend
expr_stmt|;
define|#
directive|define
name|BIT15_SET
parameter_list|(
name|x
parameter_list|)
value|((x)& 0x8000)
define|#
directive|define
name|OVERFLOWS
parameter_list|(
name|a
parameter_list|,
name|i
parameter_list|)
value|((((a)& 0xffff) + (i))> 0xffff)
if|if
condition|(
operator|(
name|BIT15_SET
argument_list|(
name|result
argument_list|)
operator|&&
operator|!
name|BIT15_SET
argument_list|(
name|addend
argument_list|)
operator|)
operator|||
operator|(
name|OVERFLOWS
argument_list|(
name|addend
argument_list|,
name|insn
argument_list|)
operator|&&
operator|(
operator|(
operator|!
name|BIT15_SET
argument_list|(
name|insn
argument_list|)
operator|)
operator|||
operator|(
name|BIT15_SET
argument_list|(
name|addend
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
name|bfd_byte
modifier|*
name|hi16s_address
init|=
name|find_remembered_hi16s_reloc
argument_list|(
name|addend
argument_list|)
decl_stmt|;
comment|/* Amend the matching HI16_S relocation.  */
if|if
condition|(
name|hi16s_address
operator|!=
name|NULL
condition|)
block|{
name|insn
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|hi16s_address
argument_list|)
expr_stmt|;
name|insn
operator|+=
literal|1
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|insn
argument_list|,
name|hi16s_address
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"FAILED to find previous HI16 reloc\n"
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_overflow
return|;
block|}
block|}
comment|/* Do not complain if value has top bit set, as this has been anticipated.  */
name|insn
operator|=
name|result
operator|&
literal|0xffff
expr_stmt|;
break|break;
block|}
case|case
name|R_V850_8
case|:
if|if
condition|(
operator|!
name|replace
condition|)
name|addend
operator|+=
operator|(
name|char
operator|)
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|address
argument_list|)
expr_stmt|;
if|if
condition|(
name|addend
operator|>
literal|0x7f
operator|||
name|addend
operator|<
operator|-
literal|0x80
condition|)
return|return
name|bfd_reloc_overflow
return|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|addend
argument_list|,
name|address
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_V850_16
case|:
name|replace
operator|=
name|false
expr_stmt|;
comment|/* drop through */
case|case
name|R_V850_SDA_16_16_OFFSET
case|:
case|case
name|R_V850_ZDA_16_16_OFFSET
case|:
case|case
name|R_V850_TDA_16_16_OFFSET
case|:
if|if
condition|(
operator|!
name|replace
condition|)
name|addend
operator|+=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|address
argument_list|)
expr_stmt|;
if|if
condition|(
name|addend
operator|>
literal|0x7fff
operator|||
name|addend
operator|<
operator|-
literal|0x8000
condition|)
return|return
name|bfd_reloc_overflow
return|;
name|insn
operator|=
name|addend
expr_stmt|;
break|break;
case|case
name|R_V850_SDA_15_16_OFFSET
case|:
case|case
name|R_V850_ZDA_15_16_OFFSET
case|:
name|insn
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|address
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|replace
condition|)
name|addend
operator|+=
operator|(
name|insn
operator|&
literal|0xfffe
operator|)
expr_stmt|;
if|if
condition|(
name|addend
operator|>
literal|0x7ffe
operator|||
name|addend
operator|<
operator|-
literal|0x8000
condition|)
return|return
name|bfd_reloc_overflow
return|;
if|if
condition|(
name|addend
operator|&
literal|1
condition|)
return|return
name|bfd_reloc_dangerous
return|;
name|insn
operator|=
operator|(
name|addend
operator|&
operator|~
literal|1
operator|)
operator||
operator|(
name|insn
operator|&
literal|1
operator|)
expr_stmt|;
break|break;
case|case
name|R_V850_TDA_6_8_OFFSET
case|:
name|insn
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|address
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|replace
condition|)
name|addend
operator|+=
operator|(
operator|(
name|insn
operator|&
literal|0x7e
operator|)
operator|<<
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|addend
operator|>
literal|0xfc
operator|||
name|addend
operator|<
literal|0
condition|)
return|return
name|bfd_reloc_overflow
return|;
if|if
condition|(
name|addend
operator|&
literal|3
condition|)
return|return
name|bfd_reloc_dangerous
return|;
name|insn
operator|&=
literal|0xff81
expr_stmt|;
name|insn
operator||=
operator|(
name|addend
operator|>>
literal|1
operator|)
expr_stmt|;
break|break;
case|case
name|R_V850_TDA_7_8_OFFSET
case|:
name|insn
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|address
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|replace
condition|)
name|addend
operator|+=
operator|(
operator|(
name|insn
operator|&
literal|0x7f
operator|)
operator|<<
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|addend
operator|>
literal|0xfe
operator|||
name|addend
operator|<
literal|0
condition|)
return|return
name|bfd_reloc_overflow
return|;
if|if
condition|(
name|addend
operator|&
literal|1
condition|)
return|return
name|bfd_reloc_dangerous
return|;
name|insn
operator|&=
literal|0xff80
expr_stmt|;
name|insn
operator||=
operator|(
name|addend
operator|>>
literal|1
operator|)
expr_stmt|;
break|break;
case|case
name|R_V850_TDA_7_7_OFFSET
case|:
name|insn
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|address
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|replace
condition|)
name|addend
operator|+=
name|insn
operator|&
literal|0x7f
expr_stmt|;
if|if
condition|(
name|addend
operator|>
literal|0x7f
operator|||
name|addend
operator|<
literal|0
condition|)
return|return
name|bfd_reloc_overflow
return|;
name|insn
operator|&=
literal|0xff80
expr_stmt|;
name|insn
operator||=
name|addend
expr_stmt|;
break|break;
block|}
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|insn
argument_list|,
name|address
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Insert the addend into the instruction.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|v850_elf_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|isection
parameter_list|,
name|obfd
parameter_list|,
name|err
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|isection
decl_stmt|;
name|bfd
modifier|*
name|obfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|err
decl_stmt|;
block|{
name|long
name|relocation
decl_stmt|;
comment|/* If there is an output BFD,      and the symbol is not a section name (which is only defined at final link time),      and either we are not putting the addend into the instruction          or the addend is zero, so there is nothing to add into the instruction      then just fixup the address and return.  */
if|if
condition|(
name|obfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
operator|&&
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|!
name|reloc
operator|->
name|howto
operator|->
name|partial_inplace
operator|||
name|reloc
operator|->
name|addend
operator|==
literal|0
operator|)
condition|)
block|{
name|reloc
operator|->
name|address
operator|+=
name|isection
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
if|#
directive|if
literal|0
block|else if (obfd != NULL)     {       return bfd_reloc_continue;     }
endif|#
directive|endif
comment|/* Catch relocs involving undefined symbols.  */
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
operator|&&
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_WEAK
operator|)
operator|==
literal|0
operator|&&
name|obfd
operator|==
name|NULL
condition|)
return|return
name|bfd_reloc_undefined
return|;
comment|/* We handle final linking of some relocs ourselves.  */
comment|/* Is the address of the relocation really within the section?  */
if|if
condition|(
name|reloc
operator|->
name|address
operator|>
name|isection
operator|->
name|_cooked_size
condition|)
return|return
name|bfd_reloc_outofrange
return|;
comment|/* Work out which section the relocation is targetted at and the      initial relocation command value.  */
comment|/* Get symbol value.  (Common symbols are special.)  */
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
else|else
name|relocation
operator|=
name|symbol
operator|->
name|value
expr_stmt|;
comment|/* Convert input-section-relative symbol value to absolute + addend.  */
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
name|relocation
operator|+=
name|reloc
operator|->
name|addend
expr_stmt|;
if|if
condition|(
name|reloc
operator|->
name|howto
operator|->
name|pc_relative
operator|==
name|true
condition|)
block|{
comment|/* Here the variable relocation holds the final address of the 	 symbol we are relocating against, plus any addend.  */
name|relocation
operator|-=
name|isection
operator|->
name|output_section
operator|->
name|vma
operator|+
name|isection
operator|->
name|output_offset
expr_stmt|;
comment|/* Deal with pcrel_offset */
name|relocation
operator|-=
name|reloc
operator|->
name|address
expr_stmt|;
block|}
comment|/* I've got no clue... */
name|reloc
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
return|return
name|v850_elf_store_addend_in_insn
argument_list|(
name|abfd
argument_list|,
name|reloc
operator|->
name|howto
operator|->
name|type
argument_list|,
name|relocation
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc
operator|->
name|address
argument_list|,
name|true
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|boolean
name|v850_elf_is_local_label_name
parameter_list|(
name|abfd
parameter_list|,
name|name
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|name
index|[
literal|1
index|]
operator|==
literal|'L'
operator|||
name|name
index|[
literal|1
index|]
operator|==
literal|'.'
operator|)
operator|)
operator|||
operator|(
name|name
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|name
index|[
literal|2
index|]
operator|==
literal|'L'
operator|&&
name|name
index|[
literal|3
index|]
operator|==
literal|'_'
operator|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Perform a relocation as part of a final link.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|v850_elf_final_link_relocate
parameter_list|(
name|howto
parameter_list|,
name|input_bfd
parameter_list|,
name|output_bfd
parameter_list|,
name|input_section
parameter_list|,
name|contents
parameter_list|,
name|offset
parameter_list|,
name|value
parameter_list|,
name|addend
parameter_list|,
name|info
parameter_list|,
name|sym_sec
parameter_list|,
name|is_local
parameter_list|)
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|asection
modifier|*
name|sym_sec
decl_stmt|;
name|int
name|is_local
decl_stmt|;
block|{
name|unsigned
name|long
name|r_type
init|=
name|howto
operator|->
name|type
decl_stmt|;
name|bfd_byte
modifier|*
name|hit_data
init|=
name|contents
operator|+
name|offset
decl_stmt|;
comment|/* Adjust the value according to the relocation.  */
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_V850_9_PCREL
case|:
name|value
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|value
operator|-=
name|offset
expr_stmt|;
break|break;
case|case
name|R_V850_22_PCREL
case|:
name|value
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|offset
operator|)
expr_stmt|;
name|value
operator|=
name|SEXT24
argument_list|(
name|value
argument_list|)
expr_stmt|;
comment|/* Only the bottom 24 bits of the PC are valid */
break|break;
case|case
name|R_V850_HI16_S
case|:
case|case
name|R_V850_HI16
case|:
case|case
name|R_V850_LO16
case|:
case|case
name|R_V850_16
case|:
case|case
name|R_V850_32
case|:
case|case
name|R_V850_8
case|:
break|break;
case|case
name|R_V850_ZDA_15_16_OFFSET
case|:
case|case
name|R_V850_ZDA_16_16_OFFSET
case|:
if|if
condition|(
name|sym_sec
operator|==
name|NULL
condition|)
return|return
name|bfd_reloc_undefined
return|;
name|value
operator|-=
name|sym_sec
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
break|break;
case|case
name|R_V850_SDA_15_16_OFFSET
case|:
case|case
name|R_V850_SDA_16_16_OFFSET
case|:
block|{
name|unsigned
name|long
name|gp
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
if|if
condition|(
name|sym_sec
operator|==
name|NULL
condition|)
return|return
name|bfd_reloc_undefined
return|;
comment|/* Get the value of __gp.  */
name|h
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|info
operator|->
name|hash
argument_list|,
literal|"__gp"
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|)
name|NULL
operator|||
name|h
operator|->
name|type
operator|!=
name|bfd_link_hash_defined
condition|)
return|return
name|bfd_reloc_other
return|;
name|gp
operator|=
operator|(
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|value
operator|-=
name|sym_sec
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|value
operator|-=
operator|(
name|gp
operator|-
name|sym_sec
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|R_V850_TDA_16_16_OFFSET
case|:
case|case
name|R_V850_TDA_7_7_OFFSET
case|:
case|case
name|R_V850_TDA_7_8_OFFSET
case|:
case|case
name|R_V850_TDA_6_8_OFFSET
case|:
block|{
name|unsigned
name|long
name|ep
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
comment|/* Get the value of __ep.  */
name|h
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|info
operator|->
name|hash
argument_list|,
literal|"__ep"
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|)
name|NULL
operator|||
name|h
operator|->
name|type
operator|!=
name|bfd_link_hash_defined
condition|)
return|return
name|bfd_reloc_continue
return|;
comment|/* Actually this indicates that __ep could not be found. */
name|ep
operator|=
operator|(
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|value
operator|-=
name|ep
expr_stmt|;
block|}
break|break;
case|case
name|R_V850_NONE
case|:
return|return
name|bfd_reloc_ok
return|;
default|default:
return|return
name|bfd_reloc_notsupported
return|;
block|}
comment|/* Perform the relocation.  */
return|return
name|v850_elf_store_addend_in_insn
argument_list|(
name|input_bfd
argument_list|,
name|r_type
argument_list|,
name|value
argument_list|,
name|hit_data
argument_list|,
name|false
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Relocate an V850 ELF section.  */
end_comment

begin_function
specifier|static
name|boolean
name|v850_elf_relocate_section
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|contents
parameter_list|,
name|relocs
parameter_list|,
name|local_syms
parameter_list|,
name|local_sections
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|local_syms
decl_stmt|;
name|asection
modifier|*
modifier|*
name|local_sections
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relend
decl_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|rel
operator|=
name|relocs
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|input_section
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|int
name|r_type
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_reloc_status_type
name|r
decl_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|howto
operator|=
name|v850_elf_howto_table
operator|+
name|r_type
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|relocateable
condition|)
block|{
comment|/* This is a relocateable link.  We don't have to change              anything, unless the reloc is against a section symbol,              in which case we have to adjust according to where the              section symbol winds up in the output section.  */
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_SECTION
condition|)
block|{
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_REL
comment|/* The Elf_Internal_Rel structure does not have space for the 		     modified addend value, so we store it in the instruction 		     instead. */
if|if
condition|(
name|sec
operator|->
name|output_offset
operator|+
name|sym
operator|->
name|st_value
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|v850_elf_store_addend_in_insn
argument_list|(
name|input_bfd
argument_list|,
name|r_type
argument_list|,
name|sec
operator|->
name|output_offset
operator|+
name|sym
operator|->
name|st_value
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|,
name|false
argument_list|)
operator|!=
name|bfd_reloc_ok
condition|)
block|{
name|info
operator|->
name|callbacks
operator|->
name|warning
argument_list|(
name|info
argument_list|,
literal|"Unable to handle relocation during incremental link"
argument_list|,
name|NULL
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
block|}
block|}
else|#
directive|else
name|rel
operator|->
name|r_addend
operator|+=
name|sec
operator|->
name|output_offset
operator|+
name|sym
operator|->
name|st_value
expr_stmt|;
endif|#
directive|endif
block|}
block|}
continue|continue;
block|}
comment|/* This is a final link.  */
name|h
operator|=
name|NULL
expr_stmt|;
name|sym
operator|=
name|NULL
expr_stmt|;
name|sec
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|relocation
operator|=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|sym
operator|->
name|st_value
operator|)
expr_stmt|;
if|#
directive|if
literal|0
block|{ 	    char * name; 	    name = bfd_elf_string_from_elf_section (input_bfd, symtab_hdr->sh_link, sym->st_name); 	    name = (name == NULL) ? "<none>" : name; fprintf (stderr, "local: sec: %s, sym: %s (%d), value: %x + %x + %x addend %x\n", 	 sec->name, name, sym->st_name, 	 sec->output_section->vma, sec->output_offset, sym->st_value, rel->r_addend); 	  }
endif|#
directive|endif
block|}
else|else
block|{
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
block|{
name|sec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|relocation
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|)
expr_stmt|;
if|#
directive|if
literal|0
block|fprintf (stderr, "defined: sec: %s, name: %s, value: %x + %x + %x gives: %x\n", 	 sec->name, h->root.root.string, h->root.u.def.value, sec->output_section->vma, sec->output_offset, relocation);
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
block|{
if|#
directive|if
literal|0
block|fprintf (stderr, "undefined: sec: %s, name: %s\n", 	 sec->name, h->root.root.string);
endif|#
directive|endif
name|relocation
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
if|#
directive|if
literal|0
block|fprintf (stderr, "unknown: name: %s\n", h->root.root.string);
endif|#
directive|endif
name|relocation
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* FIXME: We should use the addend, but the COFF relocations          don't.  */
name|r
operator|=
name|v850_elf_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|output_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|relocation
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|,
name|info
argument_list|,
name|sec
argument_list|,
name|h
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|bfd_reloc_ok
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
literal|0
decl_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
else|else
block|{
name|name
operator|=
operator|(
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_link
argument_list|,
name|sym
operator|->
name|st_name
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
operator|||
operator|*
name|name
operator|==
literal|'\0'
condition|)
name|name
operator|=
name|bfd_section_name
argument_list|(
name|input_bfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|bfd_reloc_overflow
case|:
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|info
argument_list|,
name|name
argument_list|,
name|howto
operator|->
name|name
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|bfd_reloc_undefined
case|:
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|info
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|bfd_reloc_outofrange
case|:
name|msg
operator|=
literal|"internal error: out of range error"
expr_stmt|;
goto|goto
name|common_error
goto|;
case|case
name|bfd_reloc_notsupported
case|:
name|msg
operator|=
literal|"internal error: unsupported relocation error"
expr_stmt|;
goto|goto
name|common_error
goto|;
case|case
name|bfd_reloc_dangerous
case|:
name|msg
operator|=
literal|"internal error: dangerous relocation"
expr_stmt|;
goto|goto
name|common_error
goto|;
case|case
name|bfd_reloc_other
case|:
name|msg
operator|=
literal|"could not locate special linker symbol __gp"
expr_stmt|;
goto|goto
name|common_error
goto|;
case|case
name|bfd_reloc_continue
case|:
name|msg
operator|=
literal|"could not locate special linker symbol __ep"
expr_stmt|;
goto|goto
name|common_error
goto|;
case|case
operator|(
name|bfd_reloc_dangerous
operator|+
literal|1
operator|)
case|:
name|msg
operator|=
literal|"could not locate special linker symbol __ctbp"
expr_stmt|;
goto|goto
name|common_error
goto|;
default|default:
name|msg
operator|=
literal|"internal error: unknown error"
expr_stmt|;
comment|/* fall through */
name|common_error
label|:
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|warning
call|)
argument_list|(
name|info
argument_list|,
name|msg
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
break|break;
block|}
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Set the right machine number.  */
end_comment

begin_function
specifier|static
name|boolean
name|v850_elf_object_p
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
switch|switch
condition|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_V850_ARCH
condition|)
block|{
default|default:
case|case
name|E_V850_ARCH
case|:
operator|(
name|void
operator|)
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_v850
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Store the machine number in the flags field.  */
end_comment

begin_function
name|void
name|v850_elf_final_write_processing
parameter_list|(
name|abfd
parameter_list|,
name|linker
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|boolean
name|linker
decl_stmt|;
block|{
name|unsigned
name|long
name|val
decl_stmt|;
switch|switch
condition|(
name|bfd_get_mach
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
default|default:
case|case
literal|0
case|:
name|val
operator|=
name|E_V850_ARCH
expr_stmt|;
break|break;
block|}
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&=
operator|~
name|EF_V850_ARCH
expr_stmt|;
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator||=
name|val
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Function to keep V850 specific file flags. */
end_comment

begin_function
name|boolean
name|v850_elf_set_private_flags
parameter_list|(
name|abfd
parameter_list|,
name|flags
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
block|{
name|BFD_ASSERT
argument_list|(
operator|!
name|elf_flags_init
argument_list|(
name|abfd
argument_list|)
operator|||
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|==
name|flags
argument_list|)
expr_stmt|;
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|=
name|flags
expr_stmt|;
name|elf_flags_init
argument_list|(
name|abfd
argument_list|)
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Copy backend specific data from one object module to another */
end_comment

begin_function
name|boolean
name|v850_elf_copy_private_bfd_data
parameter_list|(
name|ibfd
parameter_list|,
name|obfd
parameter_list|)
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|bfd
modifier|*
name|obfd
decl_stmt|;
block|{
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|ibfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
operator|||
name|bfd_get_flavour
argument_list|(
name|obfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
return|return
name|true
return|;
name|BFD_ASSERT
argument_list|(
operator|!
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
operator|||
operator|(
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|==
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
operator|->
name|e_flags
operator|)
argument_list|)
expr_stmt|;
name|elf_gp
argument_list|(
name|obfd
argument_list|)
operator|=
name|elf_gp
argument_list|(
name|ibfd
argument_list|)
expr_stmt|;
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|=
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Merge backend specific data from an object file to the output    object file when linking.  */
end_comment

begin_function
name|boolean
name|v850_elf_merge_private_bfd_data
parameter_list|(
name|ibfd
parameter_list|,
name|obfd
parameter_list|)
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|bfd
modifier|*
name|obfd
decl_stmt|;
block|{
name|flagword
name|out_flags
decl_stmt|;
name|flagword
name|in_flags
decl_stmt|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|ibfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
operator|||
name|bfd_get_flavour
argument_list|(
name|obfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
return|return
name|true
return|;
name|in_flags
operator|=
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
name|out_flags
operator|=
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
if|if
condition|(
operator|!
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
condition|)
block|{
comment|/* If the input is the default architecture then do not 	 bother setting the flags for the output architecture, 	 instead allow future merges to do this.  If no future 	 merges ever set these flags then they will retain their 	 unitialised values, which surprise surprise, correspond 	 to the default values.  */
if|if
condition|(
name|bfd_get_arch_info
argument_list|(
name|ibfd
argument_list|)
operator|->
name|the_default
condition|)
return|return
name|true
return|;
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
operator|=
name|true
expr_stmt|;
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|=
name|in_flags
expr_stmt|;
if|if
condition|(
name|bfd_get_arch
argument_list|(
name|obfd
argument_list|)
operator|==
name|bfd_get_arch
argument_list|(
name|ibfd
argument_list|)
operator|&&
name|bfd_get_arch_info
argument_list|(
name|obfd
argument_list|)
operator|->
name|the_default
condition|)
block|{
return|return
name|bfd_set_arch_mach
argument_list|(
name|obfd
argument_list|,
name|bfd_get_arch
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|bfd_get_mach
argument_list|(
name|ibfd
argument_list|)
argument_list|)
return|;
block|}
return|return
name|true
return|;
block|}
comment|/* Check flag compatibility.  */
if|if
condition|(
name|in_flags
operator|==
name|out_flags
condition|)
return|return
name|true
return|;
if|if
condition|(
operator|(
name|in_flags
operator|&
name|EF_V850_ARCH
operator|)
operator|!=
operator|(
name|out_flags
operator|&
name|EF_V850_ARCH
operator|)
operator|&&
operator|(
name|in_flags
operator|&
name|EF_V850_ARCH
operator|)
operator|!=
name|E_V850_ARCH
condition|)
name|_bfd_error_handler
argument_list|(
literal|"%s: Architecture mismatch with previous modules"
argument_list|,
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Display the flags field */
end_comment

begin_function
specifier|static
name|boolean
name|v850_elf_print_private_bfd_data
parameter_list|(
name|abfd
parameter_list|,
name|ptr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|ptr
decl_stmt|;
block|{
name|FILE
modifier|*
name|file
init|=
operator|(
name|FILE
operator|*
operator|)
name|ptr
decl_stmt|;
name|BFD_ASSERT
argument_list|(
argument|abfd != NULL&& ptr != NULL
argument_list|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"private flags = %lx"
argument_list|,
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_V850_ARCH
condition|)
block|{
default|default:
case|case
name|E_V850_ARCH
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|": v850 architecture"
argument_list|)
expr_stmt|;
break|break;
block|}
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* V850 ELF uses four common sections.  One is the usual one, and the    others are for (small) objects in one of the special data areas:    small, tiny and zero.  All the objects are kept together, and then    referenced via the gp register, the ep register or the r0 register    respectively, which yields smaller, faster assembler code.  This    approach is copied from elf32-mips.c.  */
end_comment

begin_decl_stmt
specifier|static
name|asection
name|v850_elf_scom_section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asymbol
name|v850_elf_scom_symbol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asymbol
modifier|*
name|v850_elf_scom_symbol_ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asection
name|v850_elf_tcom_section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asymbol
name|v850_elf_tcom_symbol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asymbol
modifier|*
name|v850_elf_tcom_symbol_ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asection
name|v850_elf_zcom_section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asymbol
name|v850_elf_zcom_symbol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asymbol
modifier|*
name|v850_elf_zcom_symbol_ptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Given a BFD section, try to locate the corresponding ELF section    index.  */
end_comment

begin_function
specifier|static
name|boolean
name|v850_elf_section_from_bfd_section
parameter_list|(
name|abfd
parameter_list|,
name|hdr
parameter_list|,
name|sec
parameter_list|,
name|retval
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|Elf32_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|int
modifier|*
name|retval
decl_stmt|;
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|,
literal|".scommon"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|retval
operator|=
name|SHN_V850_SCOMMON
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|,
literal|".tcommon"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|retval
operator|=
name|SHN_V850_TCOMMON
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|,
literal|".zcommon"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|retval
operator|=
name|SHN_V850_ZCOMMON
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Handle the special V850 section numbers that a symbol may use.  */
end_comment

begin_function
specifier|static
name|void
name|v850_elf_symbol_processing
parameter_list|(
name|abfd
parameter_list|,
name|asym
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asymbol
modifier|*
name|asym
decl_stmt|;
block|{
name|elf_symbol_type
modifier|*
name|elfsym
init|=
operator|(
name|elf_symbol_type
operator|*
operator|)
name|asym
decl_stmt|;
switch|switch
condition|(
name|elfsym
operator|->
name|internal_elf_sym
operator|.
name|st_shndx
condition|)
block|{
case|case
name|SHN_V850_SCOMMON
case|:
if|if
condition|(
name|v850_elf_scom_section
operator|.
name|name
operator|==
name|NULL
condition|)
block|{
comment|/* Initialize the small common section.  */
name|v850_elf_scom_section
operator|.
name|name
operator|=
literal|".scommon"
expr_stmt|;
name|v850_elf_scom_section
operator|.
name|flags
operator|=
name|SEC_IS_COMMON
operator||
name|SEC_ALLOC
operator||
name|SEC_DATA
expr_stmt|;
name|v850_elf_scom_section
operator|.
name|output_section
operator|=
operator|&
name|v850_elf_scom_section
expr_stmt|;
name|v850_elf_scom_section
operator|.
name|symbol
operator|=
operator|&
name|v850_elf_scom_symbol
expr_stmt|;
name|v850_elf_scom_section
operator|.
name|symbol_ptr_ptr
operator|=
operator|&
name|v850_elf_scom_symbol_ptr
expr_stmt|;
name|v850_elf_scom_symbol
operator|.
name|name
operator|=
literal|".scommon"
expr_stmt|;
name|v850_elf_scom_symbol
operator|.
name|flags
operator|=
name|BSF_SECTION_SYM
expr_stmt|;
name|v850_elf_scom_symbol
operator|.
name|section
operator|=
operator|&
name|v850_elf_scom_section
expr_stmt|;
name|v850_elf_scom_symbol_ptr
operator|=
operator|&
name|v850_elf_scom_symbol
expr_stmt|;
block|}
name|asym
operator|->
name|section
operator|=
operator|&
name|v850_elf_scom_section
expr_stmt|;
name|asym
operator|->
name|value
operator|=
name|elfsym
operator|->
name|internal_elf_sym
operator|.
name|st_size
expr_stmt|;
break|break;
case|case
name|SHN_V850_TCOMMON
case|:
if|if
condition|(
name|v850_elf_tcom_section
operator|.
name|name
operator|==
name|NULL
condition|)
block|{
comment|/* Initialize the tcommon section.  */
name|v850_elf_tcom_section
operator|.
name|name
operator|=
literal|".tcommon"
expr_stmt|;
name|v850_elf_tcom_section
operator|.
name|flags
operator|=
name|SEC_IS_COMMON
expr_stmt|;
name|v850_elf_tcom_section
operator|.
name|output_section
operator|=
operator|&
name|v850_elf_tcom_section
expr_stmt|;
name|v850_elf_tcom_section
operator|.
name|symbol
operator|=
operator|&
name|v850_elf_tcom_symbol
expr_stmt|;
name|v850_elf_tcom_section
operator|.
name|symbol_ptr_ptr
operator|=
operator|&
name|v850_elf_tcom_symbol_ptr
expr_stmt|;
name|v850_elf_tcom_symbol
operator|.
name|name
operator|=
literal|".tcommon"
expr_stmt|;
name|v850_elf_tcom_symbol
operator|.
name|flags
operator|=
name|BSF_SECTION_SYM
expr_stmt|;
name|v850_elf_tcom_symbol
operator|.
name|section
operator|=
operator|&
name|v850_elf_tcom_section
expr_stmt|;
name|v850_elf_tcom_symbol_ptr
operator|=
operator|&
name|v850_elf_tcom_symbol
expr_stmt|;
block|}
name|asym
operator|->
name|section
operator|=
operator|&
name|v850_elf_tcom_section
expr_stmt|;
name|asym
operator|->
name|value
operator|=
name|elfsym
operator|->
name|internal_elf_sym
operator|.
name|st_size
expr_stmt|;
break|break;
case|case
name|SHN_V850_ZCOMMON
case|:
if|if
condition|(
name|v850_elf_zcom_section
operator|.
name|name
operator|==
name|NULL
condition|)
block|{
comment|/* Initialize the zcommon section.  */
name|v850_elf_zcom_section
operator|.
name|name
operator|=
literal|".zcommon"
expr_stmt|;
name|v850_elf_zcom_section
operator|.
name|flags
operator|=
name|SEC_IS_COMMON
expr_stmt|;
name|v850_elf_zcom_section
operator|.
name|output_section
operator|=
operator|&
name|v850_elf_zcom_section
expr_stmt|;
name|v850_elf_zcom_section
operator|.
name|symbol
operator|=
operator|&
name|v850_elf_zcom_symbol
expr_stmt|;
name|v850_elf_zcom_section
operator|.
name|symbol_ptr_ptr
operator|=
operator|&
name|v850_elf_zcom_symbol_ptr
expr_stmt|;
name|v850_elf_zcom_symbol
operator|.
name|name
operator|=
literal|".zcommon"
expr_stmt|;
name|v850_elf_zcom_symbol
operator|.
name|flags
operator|=
name|BSF_SECTION_SYM
expr_stmt|;
name|v850_elf_zcom_symbol
operator|.
name|section
operator|=
operator|&
name|v850_elf_zcom_section
expr_stmt|;
name|v850_elf_zcom_symbol_ptr
operator|=
operator|&
name|v850_elf_zcom_symbol
expr_stmt|;
block|}
name|asym
operator|->
name|section
operator|=
operator|&
name|v850_elf_zcom_section
expr_stmt|;
name|asym
operator|->
name|value
operator|=
name|elfsym
operator|->
name|internal_elf_sym
operator|.
name|st_size
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Hook called by the linker routine which adds symbols from an object    file.  We must handle the special MIPS section numbers here.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|boolean
name|v850_elf_add_symbol_hook
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|sym
parameter_list|,
name|namep
parameter_list|,
name|flagsp
parameter_list|,
name|secp
parameter_list|,
name|valp
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
specifier|const
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|namep
decl_stmt|;
name|flagword
modifier|*
name|flagsp
decl_stmt|;
name|asection
modifier|*
modifier|*
name|secp
decl_stmt|;
name|bfd_vma
modifier|*
name|valp
decl_stmt|;
block|{
switch|switch
condition|(
name|sym
operator|->
name|st_shndx
condition|)
block|{
case|case
name|SHN_V850_SCOMMON
case|:
operator|*
name|secp
operator|=
name|bfd_make_section_old_way
argument_list|(
name|abfd
argument_list|,
literal|".scommon"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|secp
operator|)
operator|->
name|flags
operator||=
name|SEC_IS_COMMON
expr_stmt|;
operator|*
name|valp
operator|=
name|sym
operator|->
name|st_size
expr_stmt|;
break|break;
case|case
name|SHN_V850_TCOMMON
case|:
operator|*
name|secp
operator|=
name|bfd_make_section_old_way
argument_list|(
name|abfd
argument_list|,
literal|".tcommon"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|secp
operator|)
operator|->
name|flags
operator||=
name|SEC_IS_COMMON
expr_stmt|;
operator|*
name|valp
operator|=
name|sym
operator|->
name|st_size
expr_stmt|;
break|break;
case|case
name|SHN_V850_ZCOMMON
case|:
operator|*
name|secp
operator|=
name|bfd_make_section_old_way
argument_list|(
name|abfd
argument_list|,
literal|".zcommon"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|secp
operator|)
operator|->
name|flags
operator||=
name|SEC_IS_COMMON
expr_stmt|;
operator|*
name|valp
operator|=
name|sym
operator|->
name|st_size
expr_stmt|;
break|break;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/*ARGSIGNORED*/
end_comment

begin_function
specifier|static
name|boolean
name|v850_elf_link_output_symbol_hook
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|name
parameter_list|,
name|sym
parameter_list|,
name|input_sec
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|asection
modifier|*
name|input_sec
decl_stmt|;
block|{
comment|/* If we see a common symbol, which implies a relocatable link, then      if a symbol was in a special common section in an input file, mark      it as a special common in the output file.  */
if|if
condition|(
name|sym
operator|->
name|st_shndx
operator|==
name|SHN_COMMON
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|input_sec
operator|->
name|name
argument_list|,
literal|".scommon"
argument_list|)
operator|==
literal|0
condition|)
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_V850_SCOMMON
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|input_sec
operator|->
name|name
argument_list|,
literal|".tcommon"
argument_list|)
operator|==
literal|0
condition|)
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_V850_TCOMMON
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|input_sec
operator|->
name|name
argument_list|,
literal|".zcommon"
argument_list|)
operator|==
literal|0
condition|)
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_V850_ZCOMMON
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|v850_elf_section_from_shdr
parameter_list|(
name|abfd
parameter_list|,
name|hdr
parameter_list|,
name|name
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
comment|/* There ought to be a place to keep ELF backend specific flags, but      at the moment there isn't one.  We just keep track of the      sections by their name, instead.  */
if|if
condition|(
operator|!
name|_bfd_elf_make_section_from_shdr
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|false
return|;
switch|switch
condition|(
name|hdr
operator|->
name|sh_type
condition|)
block|{
case|case
name|SHT_V850_SCOMMON
case|:
case|case
name|SHT_V850_TCOMMON
case|:
case|case
name|SHT_V850_ZCOMMON
case|:
if|if
condition|(
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|bfd_section
argument_list|,
operator|(
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|bfd_section
argument_list|)
operator||
name|SEC_IS_COMMON
operator|)
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Set the correct type for a V850 ELF section.  We do this by the    section name, which is a hack, but ought to work.  */
end_comment

begin_function
specifier|static
name|boolean
name|v850_elf_fake_sections
parameter_list|(
name|abfd
parameter_list|,
name|hdr
parameter_list|,
name|sec
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|Elf32_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
block|{
specifier|register
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".scommon"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_V850_SCOMMON
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".tcommon"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_V850_TCOMMON
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".zcommon"
argument_list|)
operator|==
literal|0
condition|)
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_V850_ZCOMMON
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|TARGET_LITTLE_SYM
value|bfd_elf32_v850_vec
end_define

begin_define
define|#
directive|define
name|TARGET_LITTLE_NAME
value|"elf32-v850"
end_define

begin_define
define|#
directive|define
name|ELF_ARCH
value|bfd_arch_v850
end_define

begin_define
define|#
directive|define
name|ELF_MACHINE_CODE
value|EM_CYGNUS_V850
end_define

begin_define
define|#
directive|define
name|ELF_MAXPAGESIZE
value|0x1000
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto
value|0
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto_rel
value|v850_elf_info_to_howto_rel
end_define

begin_define
define|#
directive|define
name|elf_backend_check_relocs
value|v850_elf_check_relocs
end_define

begin_define
define|#
directive|define
name|elf_backend_relocate_section
value|v850_elf_relocate_section
end_define

begin_define
define|#
directive|define
name|elf_backend_object_p
value|v850_elf_object_p
end_define

begin_define
define|#
directive|define
name|elf_backend_final_write_processing
value|v850_elf_final_write_processing
end_define

begin_define
define|#
directive|define
name|elf_backend_section_from_bfd_section
value|v850_elf_section_from_bfd_section
end_define

begin_define
define|#
directive|define
name|elf_backend_symbol_processing
value|v850_elf_symbol_processing
end_define

begin_define
define|#
directive|define
name|elf_backend_add_symbol_hook
value|v850_elf_add_symbol_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_link_output_symbol_hook
value|v850_elf_link_output_symbol_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_section_from_shdr
value|v850_elf_section_from_shdr
end_define

begin_define
define|#
directive|define
name|elf_backend_fake_sections
value|v850_elf_fake_sections
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_is_local_label_name
value|v850_elf_is_local_label_name
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_reloc_type_lookup
value|v850_elf_reloc_type_lookup
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_copy_private_bfd_data
value|v850_elf_copy_private_bfd_data
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_merge_private_bfd_data
value|v850_elf_merge_private_bfd_data
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_set_private_flags
value|v850_elf_set_private_flags
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_print_private_bfd_data
value|v850_elf_print_private_bfd_data
end_define

begin_define
define|#
directive|define
name|elf_symbol_leading_char
value|'_'
end_define

begin_include
include|#
directive|include
file|"elf32-target.h"
end_include

end_unit

