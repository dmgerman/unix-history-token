begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* linker.c -- BFD linker routines    Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001    Free Software Foundation, Inc.    Written by Steve Chamberlain and Ian Lance Taylor, Cygnus Support  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"genlink.h"
end_include

begin_comment
comment|/* SECTION 	Linker Functions  @cindex Linker 	The linker uses three special entry points in the BFD target 	vector.  It is not necessary to write special routines for 	these entry points when creating a new BFD back end, since 	generic versions are provided.  However, writing them can 	speed up linking and make it use significantly less runtime 	memory.  	The first routine creates a hash table used by the other 	routines.  The second routine adds the symbols from an object 	file to the hash table.  The third routine takes all the 	object files and links them together to create the output 	file.  These routines are designed so that the linker proper 	does not need to know anything about the symbols in the object 	files that it is linking.  The linker merely arranges the 	sections as directed by the linker script and lets BFD handle 	the details of symbols and relocs.  	The second routine and third routines are passed a pointer to 	a<<struct bfd_link_info>> structure (defined in<<bfdlink.h>>) which holds information relevant to the link, 	including the linker hash table (which was created by the 	first routine) and a set of callback functions to the linker 	proper.  	The generic linker routines are in<<linker.c>>, and use the 	header file<<genlink.h>>.  As of this writing, the only back 	ends which have implemented versions of these routines are 	a.out (in<<aoutx.h>>) and ECOFF (in<<ecoff.c>>).  The a.out 	routines are used as examples throughout this section.  @menu @* Creating a Linker Hash Table:: @* Adding Symbols to the Hash Table:: @* Performing the Final Link:: @end menu  INODE Creating a Linker Hash Table, Adding Symbols to the Hash Table, Linker Functions, Linker Functions SUBSECTION 	Creating a linker hash table  @cindex _bfd_link_hash_table_create in target vector @cindex target vector (_bfd_link_hash_table_create) 	The linker routines must create a hash table, which must be 	derived from<<struct bfd_link_hash_table>> described in<<bfdlink.c>>.  @xref{Hash Tables}, for information on how to 	create a derived hash table.  This entry point is called using 	the target vector of the linker output file.  	The<<_bfd_link_hash_table_create>> entry point must allocate 	and initialize an instance of the desired hash table.  If the 	back end does not require any additional information to be 	stored with the entries in the hash table, the entry point may 	simply create a<<struct bfd_link_hash_table>>.  Most likely, 	however, some additional information will be needed.  	For example, with each entry in the hash table the a.out 	linker keeps the index the symbol has in the final output file 	(this index number is used so that when doing a relocateable 	link the symbol index used in the output file can be quickly 	filled in when copying over a reloc).  The a.out linker code 	defines the required structures and functions for a hash table 	derived from<<struct bfd_link_hash_table>>.  The a.out linker 	hash table is created by the function<<NAME(aout,link_hash_table_create)>>; it simply allocates 	space for the hash table, initializes it, and returns a 	pointer to it.  	When writing the linker routines for a new back end, you will 	generally not know exactly which fields will be required until 	you have finished.  You should simply create a new hash table 	which defines no additional fields, and then simply add fields 	as they become necessary.  INODE Adding Symbols to the Hash Table, Performing the Final Link, Creating a Linker Hash Table, Linker Functions SUBSECTION 	Adding symbols to the hash table  @cindex _bfd_link_add_symbols in target vector @cindex target vector (_bfd_link_add_symbols) 	The linker proper will call the<<_bfd_link_add_symbols>> 	entry point for each object file or archive which is to be 	linked (typically these are the files named on the command 	line, but some may also come from the linker script).  The 	entry point is responsible for examining the file.  For an 	object file, BFD must add any relevant symbol information to 	the hash table.  For an archive, BFD must determine which 	elements of the archive should be used and adding them to the 	link.  	The a.out version of this entry point is<<NAME(aout,link_add_symbols)>>.  @menu @* Differing file formats:: @* Adding symbols from an object file:: @* Adding symbols from an archive:: @end menu  INODE Differing file formats, Adding symbols from an object file, Adding Symbols to the Hash Table, Adding Symbols to the Hash Table SUBSUBSECTION 	Differing file formats  	Normally all the files involved in a link will be of the same 	format, but it is also possible to link together different 	format object files, and the back end must support that.  The<<_bfd_link_add_symbols>> entry point is called via the target 	vector of the file to be added.  This has an important 	consequence: the function may not assume that the hash table 	is the type created by the corresponding<<_bfd_link_hash_table_create>> vector.  All the<<_bfd_link_add_symbols>> function can assume about the hash 	table is that it is derived from<<struct 	bfd_link_hash_table>>.  	Sometimes the<<_bfd_link_add_symbols>> function must store 	some information in the hash table entry to be used by the<<_bfd_final_link>> function.  In such a case the<<creator>> 	field of the hash table must be checked to make sure that the 	hash table was created by an object file of the same format.  	The<<_bfd_final_link>> routine must be prepared to handle a 	hash entry without any extra information added by the<<_bfd_link_add_symbols>> function.  A hash entry without 	extra information will also occur when the linker script 	directs the linker to create a symbol.  Note that, regardless 	of how a hash table entry is added, all the fields will be 	initialized to some sort of null value by the hash table entry 	initialization function.  	See<<ecoff_link_add_externals>> for an example of how to 	check the<<creator>> field before saving information (in this 	case, the ECOFF external symbol debugging information) in a 	hash table entry.  INODE Adding symbols from an object file, Adding symbols from an archive, Differing file formats, Adding Symbols to the Hash Table SUBSUBSECTION 	Adding symbols from an object file  	When the<<_bfd_link_add_symbols>> routine is passed an object 	file, it must add all externally visible symbols in that 	object file to the hash table.  The actual work of adding the 	symbol to the hash table is normally handled by the function<<_bfd_generic_link_add_one_symbol>>.  The<<_bfd_link_add_symbols>> routine is responsible for reading 	all the symbols from the object file and passing the correct 	information to<<_bfd_generic_link_add_one_symbol>>.  	The<<_bfd_link_add_symbols>> routine should not use<<bfd_canonicalize_symtab>> to read the symbols.  The point of 	providing this routine is to avoid the overhead of converting 	the symbols into generic<<asymbol>> structures.  @findex _bfd_generic_link_add_one_symbol<<_bfd_generic_link_add_one_symbol>> handles the details of 	combining common symbols, warning about multiple definitions, 	and so forth.  It takes arguments which describe the symbol to 	add, notably symbol flags, a section, and an offset.  The 	symbol flags include such things as<<BSF_WEAK>> or<<BSF_INDIRECT>>.  The section is a section in the object 	file, or something like<<bfd_und_section_ptr>> for an undefined 	symbol or<<bfd_com_section_ptr>> for a common symbol.  	If the<<_bfd_final_link>> routine is also going to need to 	read the symbol information, the<<_bfd_link_add_symbols>> 	routine should save it somewhere attached to the object file 	BFD.  However, the information should only be saved if the<<keep_memory>> field of the<<info>> argument is true, so 	that the<<-no-keep-memory>> linker switch is effective.  	The a.out function which adds symbols from an object file is<<aout_link_add_object_symbols>>, and most of the interesting 	work is in<<aout_link_add_symbols>>.  The latter saves 	pointers to the hash tables entries created by<<_bfd_generic_link_add_one_symbol>> indexed by symbol number, 	so that the<<_bfd_final_link>> routine does not have to call 	the hash table lookup routine to locate the entry.  INODE Adding symbols from an archive, , Adding symbols from an object file, Adding Symbols to the Hash Table SUBSUBSECTION 	Adding symbols from an archive  	When the<<_bfd_link_add_symbols>> routine is passed an 	archive, it must look through the symbols defined by the 	archive and decide which elements of the archive should be 	included in the link.  For each such element it must call the<<add_archive_element>> linker callback, and it must add the 	symbols from the object file to the linker hash table.  @findex _bfd_generic_link_add_archive_symbols 	In most cases the work of looking through the symbols in the 	archive should be done by the<<_bfd_generic_link_add_archive_symbols>> function.  This 	function builds a hash table from the archive symbol table and 	looks through the list of undefined symbols to see which 	elements should be included.<<_bfd_generic_link_add_archive_symbols>> is passed a function 	to call to make the final decision about adding an archive 	element to the link and to do the actual work of adding the 	symbols to the linker hash table.  	The function passed to<<_bfd_generic_link_add_archive_symbols>> must read the 	symbols of the archive element and decide whether the archive 	element should be included in the link.  If the element is to 	be included, the<<add_archive_element>> linker callback 	routine must be called with the element as an argument, and 	the elements symbols must be added to the linker hash table 	just as though the element had itself been passed to the<<_bfd_link_add_symbols>> function.  	When the a.out<<_bfd_link_add_symbols>> function receives an 	archive, it calls<<_bfd_generic_link_add_archive_symbols>> 	passing<<aout_link_check_archive_element>> as the function 	argument.<<aout_link_check_archive_element>> calls<<aout_link_check_ar_symbols>>.  If the latter decides to add 	the element (an element is only added if it provides a real, 	non-common, definition for a previously undefined or common 	symbol) it calls the<<add_archive_element>> callback and then<<aout_link_check_archive_element>> calls<<aout_link_add_symbols>> to actually add the symbols to the 	linker hash table.  	The ECOFF back end is unusual in that it does not normally 	call<<_bfd_generic_link_add_archive_symbols>>, because ECOFF 	archives already contain a hash table of symbols.  The ECOFF 	back end searches the archive itself to avoid the overhead of 	creating a new hash table.  INODE Performing the Final Link, , Adding Symbols to the Hash Table, Linker Functions SUBSECTION 	Performing the final link  @cindex _bfd_link_final_link in target vector @cindex target vector (_bfd_final_link) 	When all the input files have been processed, the linker calls 	the<<_bfd_final_link>> entry point of the output BFD.  This 	routine is responsible for producing the final output file, 	which has several aspects.  It must relocate the contents of 	the input sections and copy the data into the output sections. 	It must build an output symbol table including any local 	symbols from the input files and the global symbols from the 	hash table.  When producing relocateable output, it must 	modify the input relocs and write them into the output file. 	There may also be object format dependent work to be done.  	The linker will also call the<<write_object_contents>> entry 	point when the BFD is closed.  The two entry points must work 	together in order to produce the correct output file.  	The details of how this works are inevitably dependent upon 	the specific object file format.  The a.out<<_bfd_final_link>> routine is<<NAME(aout,final_link)>>.  @menu @* Information provided by the linker:: @* Relocating the section contents:: @* Writing the symbol table:: @end menu  INODE Information provided by the linker, Relocating the section contents, Performing the Final Link, Performing the Final Link SUBSUBSECTION 	Information provided by the linker  	Before the linker calls the<<_bfd_final_link>> entry point, 	it sets up some data structures for the function to use.  	The<<input_bfds>> field of the<<bfd_link_info>> structure 	will point to a list of all the input files included in the 	link.  These files are linked through the<<link_next>> field 	of the<<bfd>> structure.  	Each section in the output file will have a list of<<link_order>> structures attached to the<<link_order_head>> 	field (the<<link_order>> structure is defined in<<bfdlink.h>>).  These structures describe how to create the 	contents of the output section in terms of the contents of 	various input sections, fill constants, and, eventually, other 	types of information.  They also describe relocs that must be 	created by the BFD backend, but do not correspond to any input 	file; this is used to support -Ur, which builds constructors 	while generating a relocateable object file.  INODE Relocating the section contents, Writing the symbol table, Information provided by the linker, Performing the Final Link SUBSUBSECTION 	Relocating the section contents  	The<<_bfd_final_link>> function should look through the<<link_order>> structures attached to each section of the 	output file.  Each<<link_order>> structure should either be 	handled specially, or it should be passed to the function<<_bfd_default_link_order>> which will do the right thing 	(<<_bfd_default_link_order>> is defined in<<linker.c>>).  	For efficiency, a<<link_order>> of type<<bfd_indirect_link_order>> whose associated section belongs 	to a BFD of the same format as the output BFD must be handled 	specially.  This type of<<link_order>> describes part of an 	output section in terms of a section belonging to one of the 	input files.  The<<_bfd_final_link>> function should read the 	contents of the section and any associated relocs, apply the 	relocs to the section contents, and write out the modified 	section contents.  If performing a relocateable link, the 	relocs themselves must also be modified and written out.  @findex _bfd_relocate_contents @findex _bfd_final_link_relocate 	The functions<<_bfd_relocate_contents>> and<<_bfd_final_link_relocate>> provide some general support for 	performing the actual relocations, notably overflow checking. 	Their arguments include information about the symbol the 	relocation is against and a<<reloc_howto_type>> argument 	which describes the relocation to perform.  These functions 	are defined in<<reloc.c>>.  	The a.out function which handles reading, relocating, and 	writing section contents is<<aout_link_input_section>>.  The 	actual relocation is done in<<aout_link_input_section_std>> 	and<<aout_link_input_section_ext>>.  INODE Writing the symbol table, , Relocating the section contents, Performing the Final Link SUBSUBSECTION 	Writing the symbol table  	The<<_bfd_final_link>> function must gather all the symbols 	in the input files and write them out.  It must also write out 	all the symbols in the global hash table.  This must be 	controlled by the<<strip>> and<<discard>> fields of the<<bfd_link_info>> structure.  	The local symbols of the input files will not have been 	entered into the linker hash table.  The<<_bfd_final_link>> 	routine must consider each input file and include the symbols 	in the output file.  It may be convenient to do this when 	looking through the<<link_order>> structures, or it may be 	done by stepping through the<<input_bfds>> list.  	The<<_bfd_final_link>> routine must also traverse the global 	hash table to gather all the externally visible symbols.  It 	is possible that most of the externally visible symbols may be 	written out when considering the symbols of each input file, 	but it is still necessary to traverse the hash table since the 	linker script may have defined some symbols that are not in 	any of the input files.  	The<<strip>> field of the<<bfd_link_info>> structure 	controls which symbols are written out.  The possible values 	are listed in<<bfdlink.h>>.  If the value is<<strip_some>>, 	then the<<keep_hash>> field of the<<bfd_link_info>> 	structure is a hash table of symbols to keep; each symbol 	should be looked up in this hash table, and only symbols which 	are present should be included in the output file.  	If the<<strip>> field of the<<bfd_link_info>> structure 	permits local symbols to be written out, the<<discard>> field 	is used to further controls which local symbols are included 	in the output file.  If the value is<<discard_l>>, then all 	local symbols which begin with a certain prefix are discarded; 	this is controlled by the<<bfd_is_local_label_name>> entry point.  	The a.out backend handles symbols by calling<<aout_link_write_symbols>> on each input BFD and then 	traversing the global hash table with the function<<aout_link_write_other_symbol>>.  It builds a string table 	while writing out the symbols, which is written to the output 	file at the end of<<NAME(aout,final_link)>>. */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|generic_link_read_symbols
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|generic_link_add_symbols
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|boolean
name|collect
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|generic_link_add_object_symbols
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|boolean
name|collect
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|generic_link_check_archive_element_no_collect
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|boolean
operator|*
name|pneeded
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|generic_link_check_archive_element_collect
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|boolean
operator|*
name|pneeded
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|generic_link_check_archive_element
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|boolean
operator|*
name|pneeded
operator|,
name|boolean
name|collect
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|generic_link_add_symbol_list
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd_size_type
name|count
operator|,
name|asymbol
operator|*
operator|*
operator|,
name|boolean
name|collect
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd
modifier|*
name|hash_entry_bfd
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_symbol_from_hash
name|PARAMS
argument_list|(
operator|(
name|asymbol
operator|*
operator|,
expr|struct
name|bfd_link_hash_entry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|generic_add_output_symbol
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|size_t
operator|*
name|psymalloc
operator|,
name|asymbol
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|default_fill_link_order
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|asection
operator|*
operator|,
expr|struct
name|bfd_link_order
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|default_indirect_link_order
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|asection
operator|*
operator|,
expr|struct
name|bfd_link_order
operator|*
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The link hash table structure is defined in bfdlink.h.  It provides    a base hash table which the backend specific hash tables are built    upon.  */
end_comment

begin_comment
comment|/* Routine to create an entry in the link hash table.  */
end_comment

begin_function
name|struct
name|bfd_hash_entry
modifier|*
name|_bfd_link_hash_newfunc
parameter_list|(
name|entry
parameter_list|,
name|table
parameter_list|,
name|string
parameter_list|)
name|struct
name|bfd_hash_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|bfd_hash_table
modifier|*
name|table
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|struct
name|bfd_link_hash_entry
modifier|*
name|ret
init|=
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|)
name|entry
decl_stmt|;
comment|/* Allocate the structure if it has not already been allocated by a      subclass.  */
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
name|ret
operator|=
operator|(
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|)
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bfd_link_hash_entry
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* Call the allocation method of the superclass.  */
name|ret
operator|=
operator|(
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|)
name|bfd_hash_newfunc
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
comment|/* Initialize the local fields.  */
name|ret
operator|->
name|type
operator|=
name|bfd_link_hash_new
expr_stmt|;
name|ret
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Initialize a link hash table.  The BFD argument is the one    responsible for creating this table.  */
end_comment

begin_decl_stmt
name|boolean
name|_bfd_link_hash_table_init
argument_list|(
name|table
argument_list|,
name|abfd
argument_list|,
name|newfunc
argument_list|)
decl|struct
name|bfd_link_hash_table
modifier|*
name|table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd
modifier|*
name|abfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|bfd_hash_entry
modifier|*
argument_list|(
operator|*
name|newfunc
argument_list|)
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|,
expr|struct
name|bfd_hash_table
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|table
operator|->
name|creator
operator|=
name|abfd
operator|->
name|xvec
expr_stmt|;
name|table
operator|->
name|undefs
operator|=
name|NULL
expr_stmt|;
name|table
operator|->
name|undefs_tail
operator|=
name|NULL
expr_stmt|;
return|return
name|bfd_hash_table_init
argument_list|(
operator|&
name|table
operator|->
name|table
argument_list|,
name|newfunc
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/* Look up a symbol in a link hash table.  If follow is true, we    follow bfd_link_hash_indirect and bfd_link_hash_warning links to    the real symbol.  */
end_comment

begin_function
name|struct
name|bfd_link_hash_entry
modifier|*
name|bfd_link_hash_lookup
parameter_list|(
name|table
parameter_list|,
name|string
parameter_list|,
name|create
parameter_list|,
name|copy
parameter_list|,
name|follow
parameter_list|)
name|struct
name|bfd_link_hash_table
modifier|*
name|table
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
name|boolean
name|create
decl_stmt|;
name|boolean
name|copy
decl_stmt|;
name|boolean
name|follow
decl_stmt|;
block|{
name|struct
name|bfd_link_hash_entry
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
operator|(
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|)
name|bfd_hash_lookup
argument_list|(
operator|&
name|table
operator|->
name|table
argument_list|,
name|string
argument_list|,
name|create
argument_list|,
name|copy
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|follow
operator|&&
name|ret
operator|!=
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
block|{
while|while
condition|(
name|ret
operator|->
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|ret
operator|->
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|ret
operator|=
name|ret
operator|->
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Look up a symbol in the main linker hash table if the symbol might    be wrapped.  This should only be used for references to an    undefined symbol, not for definitions of a symbol.  */
end_comment

begin_function
name|struct
name|bfd_link_hash_entry
modifier|*
name|bfd_wrapped_link_hash_lookup
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|string
parameter_list|,
name|create
parameter_list|,
name|copy
parameter_list|,
name|follow
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
name|boolean
name|create
decl_stmt|;
name|boolean
name|copy
decl_stmt|;
name|boolean
name|follow
decl_stmt|;
block|{
if|if
condition|(
name|info
operator|->
name|wrap_hash
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|l
decl_stmt|;
name|l
operator|=
name|string
expr_stmt|;
if|if
condition|(
operator|*
name|l
operator|==
name|bfd_get_symbol_leading_char
argument_list|(
name|abfd
argument_list|)
condition|)
operator|++
name|l
expr_stmt|;
undef|#
directive|undef
name|WRAP
define|#
directive|define
name|WRAP
value|"__wrap_"
if|if
condition|(
name|bfd_hash_lookup
argument_list|(
name|info
operator|->
name|wrap_hash
argument_list|,
name|l
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|n
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
comment|/* This symbol is being wrapped.  We want to replace all              references to SYM with references to __wrap_SYM.  */
name|n
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|strlen
argument_list|(
name|l
argument_list|)
operator|+
sizeof|sizeof
name|WRAP
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* Note that symbol_leading_char may be '\0'.  */
name|n
index|[
literal|0
index|]
operator|=
name|bfd_get_symbol_leading_char
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|n
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strcat
argument_list|(
name|n
argument_list|,
name|WRAP
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|n
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|h
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|info
operator|->
name|hash
argument_list|,
name|n
argument_list|,
name|create
argument_list|,
name|true
argument_list|,
name|follow
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
name|h
return|;
block|}
undef|#
directive|undef
name|WRAP
undef|#
directive|undef
name|REAL
define|#
directive|define
name|REAL
value|"__real_"
if|if
condition|(
operator|*
name|l
operator|==
literal|'_'
operator|&&
name|strncmp
argument_list|(
name|l
argument_list|,
name|REAL
argument_list|,
sizeof|sizeof
name|REAL
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|&&
name|bfd_hash_lookup
argument_list|(
name|info
operator|->
name|wrap_hash
argument_list|,
name|l
operator|+
sizeof|sizeof
name|REAL
operator|-
literal|1
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|n
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
comment|/* This is a reference to __real_SYM, where SYM is being              wrapped.  We want to replace all references to __real_SYM              with references to SYM.  */
name|n
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|strlen
argument_list|(
name|l
operator|+
sizeof|sizeof
name|REAL
operator|-
literal|1
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* Note that symbol_leading_char may be '\0'.  */
name|n
index|[
literal|0
index|]
operator|=
name|bfd_get_symbol_leading_char
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|n
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strcat
argument_list|(
name|n
argument_list|,
name|l
operator|+
sizeof|sizeof
name|REAL
operator|-
literal|1
argument_list|)
expr_stmt|;
name|h
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|info
operator|->
name|hash
argument_list|,
name|n
argument_list|,
name|create
argument_list|,
name|true
argument_list|,
name|follow
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
name|h
return|;
block|}
undef|#
directive|undef
name|REAL
block|}
return|return
name|bfd_link_hash_lookup
argument_list|(
name|info
operator|->
name|hash
argument_list|,
name|string
argument_list|,
name|create
argument_list|,
name|copy
argument_list|,
name|follow
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Traverse a generic link hash table.  The only reason this is not a    macro is to do better type checking.  This code presumes that an    argument passed as a struct bfd_hash_entry * may be caught as a    struct bfd_link_hash_entry * with no explicit cast required on the    call.  */
end_comment

begin_function_decl
name|void
name|bfd_link_hash_traverse
parameter_list|(
name|table
parameter_list|,
name|func
parameter_list|,
name|info
parameter_list|)
name|struct
name|bfd_link_hash_table
modifier|*
name|table
decl_stmt|;
function_decl|boolean
parameter_list|(
function_decl|*func
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|PTR
name|info
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|bfd_hash_traverse
argument_list|(
operator|&
name|table
operator|->
name|table
argument_list|,
operator|(
operator|(
name|boolean
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
operator|)
name|func
operator|)
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Add a symbol to the linker hash table undefs list.  */
end_comment

begin_function
name|INLINE
name|void
name|bfd_link_add_undef
parameter_list|(
name|table
parameter_list|,
name|h
parameter_list|)
name|struct
name|bfd_link_hash_table
modifier|*
name|table
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
block|{
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|next
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|table
operator|->
name|undefs_tail
operator|!=
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
name|table
operator|->
name|undefs_tail
operator|->
name|next
operator|=
name|h
expr_stmt|;
if|if
condition|(
name|table
operator|->
name|undefs
operator|==
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
name|table
operator|->
name|undefs
operator|=
name|h
expr_stmt|;
name|table
operator|->
name|undefs_tail
operator|=
name|h
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Routine to create an entry in an generic link hash table.  */
end_comment

begin_function
name|struct
name|bfd_hash_entry
modifier|*
name|_bfd_generic_link_hash_newfunc
parameter_list|(
name|entry
parameter_list|,
name|table
parameter_list|,
name|string
parameter_list|)
name|struct
name|bfd_hash_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|bfd_hash_table
modifier|*
name|table
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|struct
name|generic_link_hash_entry
modifier|*
name|ret
init|=
operator|(
expr|struct
name|generic_link_hash_entry
operator|*
operator|)
name|entry
decl_stmt|;
comment|/* Allocate the structure if it has not already been allocated by a      subclass.  */
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|generic_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
name|ret
operator|=
operator|(
operator|(
expr|struct
name|generic_link_hash_entry
operator|*
operator|)
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|generic_link_hash_entry
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|generic_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* Call the allocation method of the superclass.  */
name|ret
operator|=
operator|(
operator|(
expr|struct
name|generic_link_hash_entry
operator|*
operator|)
name|_bfd_link_hash_newfunc
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
comment|/* Set local fields.  */
name|ret
operator|->
name|written
operator|=
name|false
expr_stmt|;
name|ret
operator|->
name|sym
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Create an generic link hash table.  */
end_comment

begin_function
name|struct
name|bfd_link_hash_table
modifier|*
name|_bfd_generic_link_hash_table_create
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|generic_link_hash_table
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
operator|(
operator|(
expr|struct
name|generic_link_hash_table
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|generic_link_hash_table
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
operator|(
expr|struct
name|bfd_link_hash_table
operator|*
operator|)
name|NULL
return|;
if|if
condition|(
operator|!
name|_bfd_link_hash_table_init
argument_list|(
operator|&
name|ret
operator|->
name|root
argument_list|,
name|abfd
argument_list|,
name|_bfd_generic_link_hash_newfunc
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|bfd_link_hash_table
operator|*
operator|)
name|NULL
return|;
block|}
return|return
operator|&
name|ret
operator|->
name|root
return|;
block|}
end_function

begin_comment
comment|/* Grab the symbols for an object file when doing a generic link.  We    store the symbols in the outsymbols field.  We need to keep them    around for the entire link to ensure that we only read them once.    If we read them multiple times, we might wind up with relocs and    the hash table pointing to different instances of the symbol    structure.  */
end_comment

begin_function
specifier|static
name|boolean
name|generic_link_read_symbols
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
if|if
condition|(
name|bfd_get_outsymbols
argument_list|(
name|abfd
argument_list|)
operator|==
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|NULL
condition|)
block|{
name|long
name|symsize
decl_stmt|;
name|long
name|symcount
decl_stmt|;
name|symsize
operator|=
name|bfd_get_symtab_upper_bound
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|symsize
operator|<
literal|0
condition|)
return|return
name|false
return|;
name|bfd_get_outsymbols
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|symsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_get_outsymbols
argument_list|(
name|abfd
argument_list|)
operator|==
name|NULL
operator|&&
name|symsize
operator|!=
literal|0
condition|)
return|return
name|false
return|;
name|symcount
operator|=
name|bfd_canonicalize_symtab
argument_list|(
name|abfd
argument_list|,
name|bfd_get_outsymbols
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|symcount
operator|<
literal|0
condition|)
return|return
name|false
return|;
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|=
name|symcount
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generic function to add symbols to from an object file to the    global hash table.  This version does not automatically collect    constructors by name.  */
end_comment

begin_function
name|boolean
name|_bfd_generic_link_add_symbols
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
return|return
name|generic_link_add_symbols
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|false
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Generic function to add symbols from an object file to the global    hash table.  This version automatically collects constructors by    name, as the collect2 program does.  It should be used for any    target which does not provide some other mechanism for setting up    constructors and destructors; these are approximately those targets    for which gcc uses collect2 and do not support stabs.  */
end_comment

begin_function
name|boolean
name|_bfd_generic_link_add_symbols_collect
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
return|return
name|generic_link_add_symbols
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|true
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Add symbols from an object file to the global hash table.  */
end_comment

begin_function
specifier|static
name|boolean
name|generic_link_add_symbols
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|collect
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|boolean
name|collect
decl_stmt|;
block|{
name|boolean
name|ret
decl_stmt|;
switch|switch
condition|(
name|bfd_get_format
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
case|case
name|bfd_object
case|:
name|ret
operator|=
name|generic_link_add_object_symbols
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|collect
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_archive
case|:
name|ret
operator|=
operator|(
name|_bfd_generic_link_add_archive_symbols
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
operator|(
name|collect
condition|?
name|generic_link_check_archive_element_collect
else|:
name|generic_link_check_archive_element_no_collect
operator|)
argument_list|)
operator|)
expr_stmt|;
break|break;
default|default:
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
name|ret
operator|=
name|false
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Add symbols from an object file to the global hash table.  */
end_comment

begin_function
specifier|static
name|boolean
name|generic_link_add_object_symbols
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|collect
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|boolean
name|collect
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|generic_link_read_symbols
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|generic_link_add_symbol_list
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|_bfd_generic_link_get_symcount
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|_bfd_generic_link_get_symbols
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|collect
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* We build a hash table of all symbols defined in an archive.  */
end_comment

begin_comment
comment|/* An archive symbol may be defined by multiple archive elements.    This linked list is used to hold the elements.  */
end_comment

begin_struct
struct|struct
name|archive_list
block|{
name|struct
name|archive_list
modifier|*
name|next
decl_stmt|;
name|int
name|indx
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* An entry in an archive hash table.  */
end_comment

begin_struct
struct|struct
name|archive_hash_entry
block|{
name|struct
name|bfd_hash_entry
name|root
decl_stmt|;
comment|/* Where the symbol is defined.  */
name|struct
name|archive_list
modifier|*
name|defs
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* An archive hash table itself.  */
end_comment

begin_struct
struct|struct
name|archive_hash_table
block|{
name|struct
name|bfd_hash_table
name|table
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|archive_hash_newfunc
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|,
expr|struct
name|bfd_hash_table
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|archive_hash_table_init
name|PARAMS
argument_list|(
operator|(
expr|struct
name|archive_hash_table
operator|*
operator|,
expr|struct
name|bfd_hash_entry
operator|*
call|(
modifier|*
call|)
argument_list|(
expr|struct
name|bfd_hash_entry
operator|*
argument_list|,
expr|struct
name|bfd_hash_table
operator|*
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Create a new entry for an archive hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|archive_hash_newfunc
parameter_list|(
name|entry
parameter_list|,
name|table
parameter_list|,
name|string
parameter_list|)
name|struct
name|bfd_hash_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|bfd_hash_table
modifier|*
name|table
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|struct
name|archive_hash_entry
modifier|*
name|ret
init|=
operator|(
expr|struct
name|archive_hash_entry
operator|*
operator|)
name|entry
decl_stmt|;
comment|/* Allocate the structure if it has not already been allocated by a      subclass.  */
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|archive_hash_entry
operator|*
operator|)
name|NULL
condition|)
name|ret
operator|=
operator|(
operator|(
expr|struct
name|archive_hash_entry
operator|*
operator|)
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|archive_hash_entry
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|archive_hash_entry
operator|*
operator|)
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* Call the allocation method of the superclass.  */
name|ret
operator|=
operator|(
operator|(
expr|struct
name|archive_hash_entry
operator|*
operator|)
name|bfd_hash_newfunc
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
comment|/* Initialize the local fields.  */
name|ret
operator|->
name|defs
operator|=
operator|(
expr|struct
name|archive_list
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Initialize an archive hash table.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|archive_hash_table_init
argument_list|(
name|table
argument_list|,
name|newfunc
argument_list|)
decl|struct
name|archive_hash_table
modifier|*
name|table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|bfd_hash_entry
modifier|*
argument_list|(
operator|*
name|newfunc
argument_list|)
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|,
expr|struct
name|bfd_hash_table
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
name|bfd_hash_table_init
argument_list|(
operator|&
name|table
operator|->
name|table
argument_list|,
name|newfunc
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/* Look up an entry in an archive hash table.  */
end_comment

begin_define
define|#
directive|define
name|archive_hash_lookup
parameter_list|(
name|t
parameter_list|,
name|string
parameter_list|,
name|create
parameter_list|,
name|copy
parameter_list|)
define|\
value|((struct archive_hash_entry *) \    bfd_hash_lookup (&(t)->table, (string), (create), (copy)))
end_define

begin_comment
comment|/* Allocate space in an archive hash table.  */
end_comment

begin_define
define|#
directive|define
name|archive_hash_allocate
parameter_list|(
name|t
parameter_list|,
name|size
parameter_list|)
value|bfd_hash_allocate (&(t)->table, (size))
end_define

begin_comment
comment|/* Free an archive hash table.  */
end_comment

begin_define
define|#
directive|define
name|archive_hash_table_free
parameter_list|(
name|t
parameter_list|)
value|bfd_hash_table_free (&(t)->table)
end_define

begin_comment
comment|/* Generic function to add symbols from an archive file to the global    hash file.  This function presumes that the archive symbol table    has already been read in (this is normally done by the    bfd_check_format entry point).  It looks through the undefined and    common symbols and searches the archive symbol table for them.  If    it finds an entry, it includes the associated object file in the    link.     The old linker looked through the archive symbol table for    undefined symbols.  We do it the other way around, looking through    undefined symbols for symbols defined in the archive.  The    advantage of the newer scheme is that we only have to look through    the list of undefined symbols once, whereas the old method had to    re-search the symbol table each time a new object file was added.     The CHECKFN argument is used to see if an object file should be    included.  CHECKFN should set *PNEEDED to true if the object file    should be included, and must also call the bfd_link_info    add_archive_element callback function and handle adding the symbols    to the global hash table.  CHECKFN should only return false if some    sort of error occurs.     For some formats, such as a.out, it is possible to look through an    object file but not actually include it in the link.  The    archive_pass field in a BFD is used to avoid checking the symbols    of an object files too many times.  When an object is included in    the link, archive_pass is set to -1.  If an object is scanned but    not included, archive_pass is set to the pass number.  The pass    number is incremented each time a new object file is included.  The    pass number is used because when a new object file is included it    may create new undefined symbols which cause a previously examined    object file to be included.  */
end_comment

begin_function_decl
name|boolean
name|_bfd_generic_link_add_archive_symbols
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|checkfn
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
function_decl|boolean
parameter_list|(
function_decl|*checkfn
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|boolean
operator|*
name|pneeded
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|carsym
modifier|*
name|arsyms
decl_stmt|;
name|carsym
modifier|*
name|arsym_end
decl_stmt|;
specifier|register
name|carsym
modifier|*
name|arsym
decl_stmt|;
name|int
name|pass
decl_stmt|;
name|struct
name|archive_hash_table
name|arsym_hash
decl_stmt|;
name|int
name|indx
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
modifier|*
name|pundef
decl_stmt|;
if|if
condition|(
operator|!
name|bfd_has_map
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
comment|/* An empty archive is a special case.  */
if|if
condition|(
name|bfd_openr_next_archived_file
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd
operator|*
operator|)
name|NULL
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|true
return|;
name|bfd_set_error
argument_list|(
name|bfd_error_no_armap
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|arsyms
operator|=
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symdefs
expr_stmt|;
name|arsym_end
operator|=
name|arsyms
operator|+
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symdef_count
expr_stmt|;
comment|/* In order to quickly determine whether an symbol is defined in      this archive, we build a hash table of the symbols.  */
if|if
condition|(
operator|!
name|archive_hash_table_init
argument_list|(
operator|&
name|arsym_hash
argument_list|,
name|archive_hash_newfunc
argument_list|)
condition|)
return|return
name|false
return|;
for|for
control|(
name|arsym
operator|=
name|arsyms
operator|,
name|indx
operator|=
literal|0
init|;
name|arsym
operator|<
name|arsym_end
condition|;
name|arsym
operator|++
operator|,
name|indx
operator|++
control|)
block|{
name|struct
name|archive_hash_entry
modifier|*
name|arh
decl_stmt|;
name|struct
name|archive_list
modifier|*
name|l
decl_stmt|,
modifier|*
modifier|*
name|pp
decl_stmt|;
name|arh
operator|=
name|archive_hash_lookup
argument_list|(
operator|&
name|arsym_hash
argument_list|,
name|arsym
operator|->
name|name
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|arh
operator|==
operator|(
expr|struct
name|archive_hash_entry
operator|*
operator|)
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|l
operator|=
operator|(
operator|(
expr|struct
name|archive_list
operator|*
operator|)
name|archive_hash_allocate
argument_list|(
operator|&
name|arsym_hash
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|archive_list
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|l
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|l
operator|->
name|indx
operator|=
name|indx
expr_stmt|;
for|for
control|(
name|pp
operator|=
operator|&
name|arh
operator|->
name|defs
init|;
operator|*
name|pp
operator|!=
operator|(
expr|struct
name|archive_list
operator|*
operator|)
name|NULL
condition|;
name|pp
operator|=
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|next
control|)
empty_stmt|;
operator|*
name|pp
operator|=
name|l
expr_stmt|;
name|l
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* The archive_pass field in the archive itself is used to      initialize PASS, sine we may search the same archive multiple      times.  */
name|pass
operator|=
name|abfd
operator|->
name|archive_pass
operator|+
literal|1
expr_stmt|;
comment|/* New undefined symbols are added to the end of the list, so we      only need to look through it once.  */
name|pundef
operator|=
operator|&
name|info
operator|->
name|hash
operator|->
name|undefs
expr_stmt|;
while|while
condition|(
operator|*
name|pundef
operator|!=
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
block|{
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|archive_hash_entry
modifier|*
name|arh
decl_stmt|;
name|struct
name|archive_list
modifier|*
name|l
decl_stmt|;
name|h
operator|=
operator|*
name|pundef
expr_stmt|;
comment|/* When a symbol is defined, it is not necessarily removed from 	 the list.  */
if|if
condition|(
name|h
operator|->
name|type
operator|!=
name|bfd_link_hash_undefined
operator|&&
name|h
operator|->
name|type
operator|!=
name|bfd_link_hash_common
condition|)
block|{
comment|/* Remove this entry from the list, for general cleanliness 	     and because we are going to look through the list again 	     if we search any more libraries.  We can't remove the 	     entry if it is the tail, because that would lose any 	     entries we add to the list later on (it would also cause 	     us to lose track of whether the symbol has been 	     referenced).  */
if|if
condition|(
operator|*
name|pundef
operator|!=
name|info
operator|->
name|hash
operator|->
name|undefs_tail
condition|)
operator|*
name|pundef
operator|=
operator|(
operator|*
name|pundef
operator|)
operator|->
name|next
expr_stmt|;
else|else
name|pundef
operator|=
operator|&
operator|(
operator|*
name|pundef
operator|)
operator|->
name|next
expr_stmt|;
continue|continue;
block|}
comment|/* Look for this symbol in the archive symbol map.  */
name|arh
operator|=
name|archive_hash_lookup
argument_list|(
operator|&
name|arsym_hash
argument_list|,
name|h
operator|->
name|root
operator|.
name|string
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|arh
operator|==
operator|(
expr|struct
name|archive_hash_entry
operator|*
operator|)
name|NULL
condition|)
block|{
name|pundef
operator|=
operator|&
operator|(
operator|*
name|pundef
operator|)
operator|->
name|next
expr_stmt|;
continue|continue;
block|}
comment|/* Look at all the objects which define this symbol.  */
for|for
control|(
name|l
operator|=
name|arh
operator|->
name|defs
init|;
name|l
operator|!=
operator|(
expr|struct
name|archive_list
operator|*
operator|)
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
name|bfd
modifier|*
name|element
decl_stmt|;
name|boolean
name|needed
decl_stmt|;
comment|/* If the symbol has gotten defined along the way, quit.  */
if|if
condition|(
name|h
operator|->
name|type
operator|!=
name|bfd_link_hash_undefined
operator|&&
name|h
operator|->
name|type
operator|!=
name|bfd_link_hash_common
condition|)
break|break;
name|element
operator|=
name|bfd_get_elt_at_index
argument_list|(
name|abfd
argument_list|,
name|l
operator|->
name|indx
argument_list|)
expr_stmt|;
if|if
condition|(
name|element
operator|==
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
goto|goto
name|error_return
goto|;
comment|/* If we've already included this element, or if we've 	     already checked it on this pass, continue.  */
if|if
condition|(
name|element
operator|->
name|archive_pass
operator|==
operator|-
literal|1
operator|||
name|element
operator|->
name|archive_pass
operator|==
name|pass
condition|)
continue|continue;
comment|/* If we can't figure this element out, just ignore it.  */
if|if
condition|(
operator|!
name|bfd_check_format
argument_list|(
name|element
argument_list|,
name|bfd_object
argument_list|)
condition|)
block|{
name|element
operator|->
name|archive_pass
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/* CHECKFN will see if this element should be included, and 	     go ahead and include it if appropriate.  */
if|if
condition|(
operator|!
call|(
modifier|*
name|checkfn
call|)
argument_list|(
name|element
argument_list|,
name|info
argument_list|,
operator|&
name|needed
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|needed
condition|)
name|element
operator|->
name|archive_pass
operator|=
name|pass
expr_stmt|;
else|else
block|{
name|element
operator|->
name|archive_pass
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Increment the pass count to show that we may need to 		 recheck object files which were already checked.  */
operator|++
name|pass
expr_stmt|;
block|}
block|}
name|pundef
operator|=
operator|&
operator|(
operator|*
name|pundef
operator|)
operator|->
name|next
expr_stmt|;
block|}
name|archive_hash_table_free
argument_list|(
operator|&
name|arsym_hash
argument_list|)
expr_stmt|;
comment|/* Save PASS in case we are called again.  */
name|abfd
operator|->
name|archive_pass
operator|=
name|pass
expr_stmt|;
return|return
name|true
return|;
name|error_return
label|:
name|archive_hash_table_free
argument_list|(
operator|&
name|arsym_hash
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* See if we should include an archive element.  This version is used    when we do not want to automatically collect constructors based on    the symbol name, presumably because we have some other mechanism    for finding them.  */
end_comment

begin_function
specifier|static
name|boolean
name|generic_link_check_archive_element_no_collect
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|pneeded
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|boolean
modifier|*
name|pneeded
decl_stmt|;
block|{
return|return
name|generic_link_check_archive_element
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|pneeded
argument_list|,
name|false
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* See if we should include an archive element.  This version is used    when we want to automatically collect constructors based on the    symbol name, as collect2 does.  */
end_comment

begin_function
specifier|static
name|boolean
name|generic_link_check_archive_element_collect
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|pneeded
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|boolean
modifier|*
name|pneeded
decl_stmt|;
block|{
return|return
name|generic_link_check_archive_element
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|pneeded
argument_list|,
name|true
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* See if we should include an archive element.  Optionally collect    constructors.  */
end_comment

begin_function
specifier|static
name|boolean
name|generic_link_check_archive_element
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|pneeded
parameter_list|,
name|collect
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|boolean
modifier|*
name|pneeded
decl_stmt|;
name|boolean
name|collect
decl_stmt|;
block|{
name|asymbol
modifier|*
modifier|*
name|pp
decl_stmt|,
modifier|*
modifier|*
name|ppend
decl_stmt|;
operator|*
name|pneeded
operator|=
name|false
expr_stmt|;
if|if
condition|(
operator|!
name|generic_link_read_symbols
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
name|pp
operator|=
name|_bfd_generic_link_get_symbols
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|ppend
operator|=
name|pp
operator|+
name|_bfd_generic_link_get_symcount
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|pp
operator|<
name|ppend
condition|;
name|pp
operator|++
control|)
block|{
name|asymbol
modifier|*
name|p
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|p
operator|=
operator|*
name|pp
expr_stmt|;
comment|/* We are only interested in globally visible symbols.  */
if|if
condition|(
operator|!
name|bfd_is_com_section
argument_list|(
name|p
operator|->
name|section
argument_list|)
operator|&&
operator|(
name|p
operator|->
name|flags
operator|&
operator|(
name|BSF_GLOBAL
operator||
name|BSF_INDIRECT
operator||
name|BSF_WEAK
operator|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* We are only interested if we know something about this 	 symbol, and it is undefined or common.  An undefined weak 	 symbol (type bfd_link_hash_undefweak) is not considered to be 	 a reference when pulling files out of an archive.  See the 	 SVR4 ABI, p. 4-27.  */
name|h
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|info
operator|->
name|hash
argument_list|,
name|bfd_asymbol_name
argument_list|(
name|p
argument_list|)
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|)
name|NULL
operator|||
operator|(
name|h
operator|->
name|type
operator|!=
name|bfd_link_hash_undefined
operator|&&
name|h
operator|->
name|type
operator|!=
name|bfd_link_hash_common
operator|)
condition|)
continue|continue;
comment|/* P is a symbol we are looking for.  */
if|if
condition|(
operator|!
name|bfd_is_com_section
argument_list|(
name|p
operator|->
name|section
argument_list|)
condition|)
block|{
name|bfd_size_type
name|symcount
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
comment|/* This object file defines this symbol, so pull it in.  */
if|if
condition|(
operator|!
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|add_archive_element
call|)
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
name|bfd_asymbol_name
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
name|symcount
operator|=
name|_bfd_generic_link_get_symcount
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|symbols
operator|=
name|_bfd_generic_link_get_symbols
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|generic_link_add_symbol_list
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|symcount
argument_list|,
name|symbols
argument_list|,
name|collect
argument_list|)
condition|)
return|return
name|false
return|;
operator|*
name|pneeded
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* P is a common symbol.  */
if|if
condition|(
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_undefined
condition|)
block|{
name|bfd
modifier|*
name|symbfd
decl_stmt|;
name|bfd_vma
name|size
decl_stmt|;
name|unsigned
name|int
name|power
decl_stmt|;
name|symbfd
operator|=
name|h
operator|->
name|u
operator|.
name|undef
operator|.
name|abfd
expr_stmt|;
if|if
condition|(
name|symbfd
operator|==
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* This symbol was created as undefined from outside 		 BFD.  We assume that we should link in the object 		 file.  This is for the -u option in the linker.  */
if|if
condition|(
operator|!
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|add_archive_element
call|)
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
name|bfd_asymbol_name
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
operator|*
name|pneeded
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* Turn the symbol into a common symbol but do not link in 	     the object file.  This is how a.out works.  Object 	     formats that require different semantics must implement 	     this function differently.  This symbol is already on the 	     undefs list.  We add the section to a common section 	     attached to symbfd to ensure that it is in a BFD which 	     will be linked in.  */
name|h
operator|->
name|type
operator|=
name|bfd_link_hash_common
expr_stmt|;
name|h
operator|->
name|u
operator|.
name|c
operator|.
name|p
operator|=
operator|(
operator|(
expr|struct
name|bfd_link_hash_common_entry
operator|*
operator|)
name|bfd_hash_allocate
argument_list|(
operator|&
name|info
operator|->
name|hash
operator|->
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bfd_link_hash_common_entry
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|u
operator|.
name|c
operator|.
name|p
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|size
operator|=
name|bfd_asymbol_value
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|h
operator|->
name|u
operator|.
name|c
operator|.
name|size
operator|=
name|size
expr_stmt|;
name|power
operator|=
name|bfd_log2
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|power
operator|>
literal|4
condition|)
name|power
operator|=
literal|4
expr_stmt|;
name|h
operator|->
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|alignment_power
operator|=
name|power
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|section
operator|==
name|bfd_com_section_ptr
condition|)
name|h
operator|->
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
operator|=
name|bfd_make_section_old_way
argument_list|(
name|symbfd
argument_list|,
literal|"COMMON"
argument_list|)
expr_stmt|;
else|else
name|h
operator|->
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
operator|=
name|bfd_make_section_old_way
argument_list|(
name|symbfd
argument_list|,
name|p
operator|->
name|section
operator|->
name|name
argument_list|)
expr_stmt|;
name|h
operator|->
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
operator|->
name|flags
operator|=
name|SEC_ALLOC
expr_stmt|;
block|}
else|else
block|{
comment|/* Adjust the size of the common symbol if necessary.  This 	     is how a.out works.  Object formats that require 	     different semantics must implement this function 	     differently.  */
if|if
condition|(
name|bfd_asymbol_value
argument_list|(
name|p
argument_list|)
operator|>
name|h
operator|->
name|u
operator|.
name|c
operator|.
name|size
condition|)
name|h
operator|->
name|u
operator|.
name|c
operator|.
name|size
operator|=
name|bfd_asymbol_value
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* This archive element is not needed.  */
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Add the symbols from an object file to the global hash table.  ABFD    is the object file.  INFO is the linker information.  SYMBOL_COUNT    is the number of symbols.  SYMBOLS is the list of symbols.  COLLECT    is true if constructors should be automatically collected by name    as is done by collect2.  */
end_comment

begin_function
specifier|static
name|boolean
name|generic_link_add_symbol_list
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|symbol_count
parameter_list|,
name|symbols
parameter_list|,
name|collect
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd_size_type
name|symbol_count
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
name|boolean
name|collect
decl_stmt|;
block|{
name|asymbol
modifier|*
modifier|*
name|pp
decl_stmt|,
modifier|*
modifier|*
name|ppend
decl_stmt|;
name|pp
operator|=
name|symbols
expr_stmt|;
name|ppend
operator|=
name|symbols
operator|+
name|symbol_count
expr_stmt|;
for|for
control|(
init|;
name|pp
operator|<
name|ppend
condition|;
name|pp
operator|++
control|)
block|{
name|asymbol
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|*
name|pp
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|flags
operator|&
operator|(
name|BSF_INDIRECT
operator||
name|BSF_WARNING
operator||
name|BSF_GLOBAL
operator||
name|BSF_CONSTRUCTOR
operator||
name|BSF_WEAK
operator|)
operator|)
operator|!=
literal|0
operator|||
name|bfd_is_und_section
argument_list|(
name|bfd_get_section
argument_list|(
name|p
argument_list|)
argument_list|)
operator|||
name|bfd_is_com_section
argument_list|(
name|bfd_get_section
argument_list|(
name|p
argument_list|)
argument_list|)
operator|||
name|bfd_is_ind_section
argument_list|(
name|bfd_get_section
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
name|struct
name|generic_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|name
operator|=
name|bfd_asymbol_name
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|p
operator|->
name|flags
operator|&
name|BSF_INDIRECT
operator|)
operator|!=
literal|0
operator|||
name|bfd_is_ind_section
argument_list|(
name|p
operator|->
name|section
argument_list|)
operator|)
operator|&&
name|pp
operator|+
literal|1
operator|<
name|ppend
condition|)
block|{
name|pp
operator|++
expr_stmt|;
name|string
operator|=
name|bfd_asymbol_name
argument_list|(
operator|*
name|pp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|p
operator|->
name|flags
operator|&
name|BSF_WARNING
operator|)
operator|!=
literal|0
operator|&&
name|pp
operator|+
literal|1
operator|<
name|ppend
condition|)
block|{
comment|/* The name of P is actually the warning string, and the 		 next symbol is the one to warn about.  */
name|string
operator|=
name|name
expr_stmt|;
name|pp
operator|++
expr_stmt|;
name|name
operator|=
name|bfd_asymbol_name
argument_list|(
operator|*
name|pp
argument_list|)
expr_stmt|;
block|}
else|else
name|string
operator|=
name|NULL
expr_stmt|;
name|h
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
name|name
argument_list|,
name|p
operator|->
name|flags
argument_list|,
name|bfd_get_section
argument_list|(
name|p
argument_list|)
argument_list|,
name|p
operator|->
name|value
argument_list|,
name|string
argument_list|,
name|false
argument_list|,
name|collect
argument_list|,
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|*
operator|)
operator|&
name|h
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
comment|/* If this is a constructor symbol, and the linker didn't do              anything with it, then we want to just pass the symbol              through to the output file.  This will happen when              linking with -r.  */
if|if
condition|(
operator|(
name|p
operator|->
name|flags
operator|&
name|BSF_CONSTRUCTOR
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|==
name|NULL
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_new
operator|)
condition|)
block|{
name|p
operator|->
name|udata
operator|.
name|p
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
comment|/* Save the BFD symbol so that we don't lose any backend 	     specific information that may be attached to it.  We only 	     want this one if it gives more information than the 	     existing one; we don't want to replace a defined symbol 	     with an undefined one.  This routine may be called with a 	     hash table other than the generic hash table, so we only 	     do this if we are certain that the hash table is a 	     generic one.  */
if|if
condition|(
name|info
operator|->
name|hash
operator|->
name|creator
operator|==
name|abfd
operator|->
name|xvec
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|sym
operator|==
operator|(
name|asymbol
operator|*
operator|)
name|NULL
operator|||
operator|(
operator|!
name|bfd_is_und_section
argument_list|(
name|bfd_get_section
argument_list|(
name|p
argument_list|)
argument_list|)
operator|&&
operator|(
operator|!
name|bfd_is_com_section
argument_list|(
name|bfd_get_section
argument_list|(
name|p
argument_list|)
argument_list|)
operator|||
name|bfd_is_und_section
argument_list|(
name|bfd_get_section
argument_list|(
name|h
operator|->
name|sym
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
name|h
operator|->
name|sym
operator|=
name|p
expr_stmt|;
comment|/* BSF_OLD_COMMON is a hack to support COFF reloc 		     reading, and it should go away when the COFF 		     linker is switched to the new version.  */
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|bfd_get_section
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
name|p
operator|->
name|flags
operator||=
name|BSF_OLD_COMMON
expr_stmt|;
block|}
block|}
comment|/* Store a back pointer from the symbol to the hash 	     table entry for the benefit of relaxation code until 	     it gets rewritten to not use asymbol structures. 	     Setting this is also used to check whether these 	     symbols were set up by the generic linker.  */
name|p
operator|->
name|udata
operator|.
name|p
operator|=
operator|(
name|PTR
operator|)
name|h
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* We use a state table to deal with adding symbols from an object    file.  The first index into the state table describes the symbol    from the object file.  The second index into the state table is the    type of the symbol in the hash table.  */
end_comment

begin_comment
comment|/* The symbol from the object file is turned into one of these row    values.  */
end_comment

begin_enum
enum|enum
name|link_row
block|{
name|UNDEF_ROW
block|,
comment|/* Undefined.  */
name|UNDEFW_ROW
block|,
comment|/* Weak undefined.  */
name|DEF_ROW
block|,
comment|/* Defined.  */
name|DEFW_ROW
block|,
comment|/* Weak defined.  */
name|COMMON_ROW
block|,
comment|/* Common.  */
name|INDR_ROW
block|,
comment|/* Indirect.  */
name|WARN_ROW
block|,
comment|/* Warning.  */
name|SET_ROW
comment|/* Member of set.  */
block|}
enum|;
end_enum

begin_comment
comment|/* apparently needed for Hitachi 3050R(HI-UX/WE2)? */
end_comment

begin_undef
undef|#
directive|undef
name|FAIL
end_undef

begin_comment
comment|/* The actions to take in the state table.  */
end_comment

begin_enum
enum|enum
name|link_action
block|{
name|FAIL
block|,
comment|/* Abort.  */
name|UND
block|,
comment|/* Mark symbol undefined.  */
name|WEAK
block|,
comment|/* Mark symbol weak undefined.  */
name|DEF
block|,
comment|/* Mark symbol defined.  */
name|DEFW
block|,
comment|/* Mark symbol weak defined.  */
name|COM
block|,
comment|/* Mark symbol common.  */
name|REF
block|,
comment|/* Mark defined symbol referenced.  */
name|CREF
block|,
comment|/* Possibly warn about common reference to defined symbol.  */
name|CDEF
block|,
comment|/* Define existing common symbol.  */
name|NOACT
block|,
comment|/* No action.  */
name|BIG
block|,
comment|/* Mark symbol common using largest size.  */
name|MDEF
block|,
comment|/* Multiple definition error.  */
name|MIND
block|,
comment|/* Multiple indirect symbols.  */
name|IND
block|,
comment|/* Make indirect symbol.  */
name|CIND
block|,
comment|/* Make indirect symbol from existing common symbol.  */
name|SET
block|,
comment|/* Add value to set.  */
name|MWARN
block|,
comment|/* Make warning symbol.  */
name|WARN
block|,
comment|/* Issue warning.  */
name|CWARN
block|,
comment|/* Warn if referenced, else MWARN.  */
name|CYCLE
block|,
comment|/* Repeat with symbol pointed to.  */
name|REFC
block|,
comment|/* Mark indirect symbol referenced and then CYCLE.  */
name|WARNC
comment|/* Issue warning and then CYCLE.  */
block|}
enum|;
end_enum

begin_comment
comment|/* The state table itself.  The first index is a link_row and the    second index is a bfd_link_hash_type.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|enum
name|link_action
name|link_action
index|[
literal|8
index|]
index|[
literal|8
index|]
init|=
block|{
comment|/* current\prev    new    undef  undefw def    defw   com    indr   warn  */
comment|/* UNDEF_ROW 	*/
block|{
name|UND
block|,
name|NOACT
block|,
name|UND
block|,
name|REF
block|,
name|REF
block|,
name|NOACT
block|,
name|REFC
block|,
name|WARNC
block|}
block|,
comment|/* UNDEFW_ROW	*/
block|{
name|WEAK
block|,
name|NOACT
block|,
name|NOACT
block|,
name|REF
block|,
name|REF
block|,
name|NOACT
block|,
name|REFC
block|,
name|WARNC
block|}
block|,
comment|/* DEF_ROW 	*/
block|{
name|DEF
block|,
name|DEF
block|,
name|DEF
block|,
name|MDEF
block|,
name|DEF
block|,
name|CDEF
block|,
name|MDEF
block|,
name|CYCLE
block|}
block|,
comment|/* DEFW_ROW 	*/
block|{
name|DEFW
block|,
name|DEFW
block|,
name|DEFW
block|,
name|NOACT
block|,
name|NOACT
block|,
name|NOACT
block|,
name|NOACT
block|,
name|CYCLE
block|}
block|,
comment|/* COMMON_ROW	*/
block|{
name|COM
block|,
name|COM
block|,
name|COM
block|,
name|CREF
block|,
name|CREF
block|,
name|BIG
block|,
name|REFC
block|,
name|WARNC
block|}
block|,
comment|/* INDR_ROW	*/
block|{
name|IND
block|,
name|IND
block|,
name|IND
block|,
name|MDEF
block|,
name|IND
block|,
name|CIND
block|,
name|MIND
block|,
name|CYCLE
block|}
block|,
comment|/* WARN_ROW   */
block|{
name|MWARN
block|,
name|WARN
block|,
name|WARN
block|,
name|CWARN
block|,
name|CWARN
block|,
name|WARN
block|,
name|CWARN
block|,
name|MWARN
block|}
block|,
comment|/* SET_ROW	*/
block|{
name|SET
block|,
name|SET
block|,
name|SET
block|,
name|SET
block|,
name|SET
block|,
name|SET
block|,
name|CYCLE
block|,
name|CYCLE
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Most of the entries in the LINK_ACTION table are straightforward,    but a few are somewhat subtle.     A reference to an indirect symbol (UNDEF_ROW/indr or    UNDEFW_ROW/indr) is counted as a reference both to the indirect    symbol and to the symbol the indirect symbol points to.     A reference to a warning symbol (UNDEF_ROW/warn or UNDEFW_ROW/warn)    causes the warning to be issued.     A common definition of an indirect symbol (COMMON_ROW/indr) is    treated as a multiple definition error.  Likewise for an indirect    definition of a common symbol (INDR_ROW/com).     An indirect definition of a warning (INDR_ROW/warn) does not cause    the warning to be issued.     If a warning is created for an indirect symbol (WARN_ROW/indr) no    warning is created for the symbol the indirect symbol points to.     Adding an entry to a set does not count as a reference to a set,    and no warning is issued (SET_ROW/warn).  */
end_comment

begin_comment
comment|/* Return the BFD in which a hash entry has been defined, if known.  */
end_comment

begin_function
specifier|static
name|bfd
modifier|*
name|hash_entry_bfd
parameter_list|(
name|h
parameter_list|)
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
block|{
while|while
condition|(
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
name|h
operator|->
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
switch|switch
condition|(
name|h
operator|->
name|type
condition|)
block|{
default|default:
return|return
name|NULL
return|;
case|case
name|bfd_link_hash_undefined
case|:
case|case
name|bfd_link_hash_undefweak
case|:
return|return
name|h
operator|->
name|u
operator|.
name|undef
operator|.
name|abfd
return|;
case|case
name|bfd_link_hash_defined
case|:
case|case
name|bfd_link_hash_defweak
case|:
return|return
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
return|;
case|case
name|bfd_link_hash_common
case|:
return|return
name|h
operator|->
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
operator|->
name|owner
return|;
block|}
comment|/*NOTREACHED*/
block|}
end_function

begin_comment
comment|/* Add a symbol to the global hash table.    ABFD is the BFD the symbol comes from.    NAME is the name of the symbol.    FLAGS is the BSF_* bits associated with the symbol.    SECTION is the section in which the symbol is defined; this may be      bfd_und_section_ptr or bfd_com_section_ptr.    VALUE is the value of the symbol, relative to the section.    STRING is used for either an indirect symbol, in which case it is      the name of the symbol to indirect to, or a warning symbol, in      which case it is the warning string.    COPY is true if NAME or STRING must be copied into locally      allocated memory if they need to be saved.    COLLECT is true if we should automatically collect gcc constructor      or destructor names as collect2 does.    HASHP, if not NULL, is a place to store the created hash table      entry; if *HASHP is not NULL, the caller has already looked up      the hash table entry, and stored it in *HASHP.  */
end_comment

begin_function
name|boolean
name|_bfd_generic_link_add_one_symbol
parameter_list|(
name|info
parameter_list|,
name|abfd
parameter_list|,
name|name
parameter_list|,
name|flags
parameter_list|,
name|section
parameter_list|,
name|value
parameter_list|,
name|string
parameter_list|,
name|copy
parameter_list|,
name|collect
parameter_list|,
name|hashp
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
name|boolean
name|copy
decl_stmt|;
name|boolean
name|collect
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
modifier|*
name|hashp
decl_stmt|;
block|{
name|enum
name|link_row
name|row
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|boolean
name|cycle
decl_stmt|;
if|if
condition|(
name|bfd_is_ind_section
argument_list|(
name|section
argument_list|)
operator|||
operator|(
name|flags
operator|&
name|BSF_INDIRECT
operator|)
operator|!=
literal|0
condition|)
name|row
operator|=
name|INDR_ROW
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|BSF_WARNING
operator|)
operator|!=
literal|0
condition|)
name|row
operator|=
name|WARN_ROW
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|BSF_CONSTRUCTOR
operator|)
operator|!=
literal|0
condition|)
name|row
operator|=
name|SET_ROW
expr_stmt|;
elseif|else
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|section
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|BSF_WEAK
operator|)
operator|!=
literal|0
condition|)
name|row
operator|=
name|UNDEFW_ROW
expr_stmt|;
else|else
name|row
operator|=
name|UNDEF_ROW
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|BSF_WEAK
operator|)
operator|!=
literal|0
condition|)
name|row
operator|=
name|DEFW_ROW
expr_stmt|;
elseif|else
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|section
argument_list|)
condition|)
name|row
operator|=
name|COMMON_ROW
expr_stmt|;
else|else
name|row
operator|=
name|DEF_ROW
expr_stmt|;
if|if
condition|(
name|hashp
operator|!=
name|NULL
operator|&&
operator|*
name|hashp
operator|!=
name|NULL
condition|)
name|h
operator|=
operator|*
name|hashp
expr_stmt|;
else|else
block|{
if|if
condition|(
name|row
operator|==
name|UNDEF_ROW
operator|||
name|row
operator|==
name|UNDEFW_ROW
condition|)
name|h
operator|=
name|bfd_wrapped_link_hash_lookup
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|name
argument_list|,
name|true
argument_list|,
name|copy
argument_list|,
name|false
argument_list|)
expr_stmt|;
else|else
name|h
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|info
operator|->
name|hash
argument_list|,
name|name
argument_list|,
name|true
argument_list|,
name|copy
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|hashp
operator|!=
name|NULL
condition|)
operator|*
name|hashp
operator|=
name|NULL
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
if|if
condition|(
name|info
operator|->
name|notice_all
operator|||
operator|(
name|info
operator|->
name|notice_hash
operator|!=
operator|(
expr|struct
name|bfd_hash_table
operator|*
operator|)
name|NULL
operator|&&
operator|(
name|bfd_hash_lookup
argument_list|(
name|info
operator|->
name|notice_hash
argument_list|,
name|name
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
operator|!=
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|NULL
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|notice
call|)
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|string
argument_list|,
name|abfd
argument_list|,
name|section
argument_list|,
name|value
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|hashp
operator|!=
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|*
operator|)
name|NULL
condition|)
operator|*
name|hashp
operator|=
name|h
expr_stmt|;
do|do
block|{
name|enum
name|link_action
name|action
decl_stmt|;
name|cycle
operator|=
name|false
expr_stmt|;
name|action
operator|=
name|link_action
index|[
operator|(
name|int
operator|)
name|row
index|]
index|[
operator|(
name|int
operator|)
name|h
operator|->
name|type
index|]
expr_stmt|;
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|FAIL
case|:
name|abort
argument_list|()
expr_stmt|;
case|case
name|NOACT
case|:
comment|/* Do nothing.  */
break|break;
case|case
name|UND
case|:
comment|/* Make a new undefined symbol.  */
name|h
operator|->
name|type
operator|=
name|bfd_link_hash_undefined
expr_stmt|;
name|h
operator|->
name|u
operator|.
name|undef
operator|.
name|abfd
operator|=
name|abfd
expr_stmt|;
name|bfd_link_add_undef
argument_list|(
name|info
operator|->
name|hash
argument_list|,
name|h
argument_list|)
expr_stmt|;
break|break;
case|case
name|WEAK
case|:
comment|/* Make a new weak undefined symbol.  */
name|h
operator|->
name|type
operator|=
name|bfd_link_hash_undefweak
expr_stmt|;
name|h
operator|->
name|u
operator|.
name|undef
operator|.
name|abfd
operator|=
name|abfd
expr_stmt|;
break|break;
case|case
name|CDEF
case|:
comment|/* We have found a definition for a symbol which was 	     previously common.  */
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_common
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|multiple_common
call|)
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|string
argument_list|,
name|h
operator|->
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
operator|->
name|owner
argument_list|,
name|bfd_link_hash_common
argument_list|,
name|h
operator|->
name|u
operator|.
name|c
operator|.
name|size
argument_list|,
name|abfd
argument_list|,
name|bfd_link_hash_defined
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
comment|/* Fall through.  */
case|case
name|DEF
case|:
case|case
name|DEFW
case|:
block|{
name|enum
name|bfd_link_hash_type
name|oldtype
decl_stmt|;
comment|/* Define a symbol.  */
name|oldtype
operator|=
name|h
operator|->
name|type
expr_stmt|;
if|if
condition|(
name|action
operator|==
name|DEFW
condition|)
name|h
operator|->
name|type
operator|=
name|bfd_link_hash_defweak
expr_stmt|;
else|else
name|h
operator|->
name|type
operator|=
name|bfd_link_hash_defined
expr_stmt|;
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|section
expr_stmt|;
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|value
expr_stmt|;
comment|/* If we have been asked to, we act like collect2 and 	       identify all functions that might be global 	       constructors and destructors and pass them up in a 	       callback.  We only do this for certain object file 	       types, since many object file types can handle this 	       automatically.  */
if|if
condition|(
name|collect
operator|&&
name|name
index|[
literal|0
index|]
operator|==
literal|'_'
condition|)
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
comment|/* A constructor or destructor name starts like this: 		   _+GLOBAL_[_.$][ID][_.$] where the first [_.$] and 		   the second are the same character (we accept any 		   character there, in case a new object file format 		   comes along with even worse naming restrictions).  */
define|#
directive|define
name|CONS_PREFIX
value|"GLOBAL_"
define|#
directive|define
name|CONS_PREFIX_LEN
value|(sizeof CONS_PREFIX - 1)
name|s
operator|=
name|name
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|==
literal|'_'
condition|)
operator|++
name|s
expr_stmt|;
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|'G'
operator|&&
name|strncmp
argument_list|(
name|s
argument_list|,
name|CONS_PREFIX
argument_list|,
name|CONS_PREFIX_LEN
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
name|c
decl_stmt|;
name|c
operator|=
name|s
index|[
name|CONS_PREFIX_LEN
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|'I'
operator|||
name|c
operator|==
literal|'D'
operator|)
operator|&&
name|s
index|[
name|CONS_PREFIX_LEN
index|]
operator|==
name|s
index|[
name|CONS_PREFIX_LEN
operator|+
literal|2
index|]
condition|)
block|{
comment|/* If this is a definition of a symbol which                            was previously weakly defined, we are in                            trouble.  We have already added a                            constructor entry for the weak defined                            symbol, and now we are trying to add one                            for the new symbol.  Fortunately, this case                            should never arise in practice.  */
if|if
condition|(
name|oldtype
operator|==
name|bfd_link_hash_defweak
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|constructor
call|)
argument_list|(
name|info
argument_list|,
name|c
operator|==
literal|'I'
condition|?
name|true
else|:
name|false
argument_list|,
name|h
operator|->
name|root
operator|.
name|string
argument_list|,
name|abfd
argument_list|,
name|section
argument_list|,
name|value
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
block|}
block|}
block|}
block|}
break|break;
case|case
name|COM
case|:
comment|/* We have found a common definition for a symbol.  */
if|if
condition|(
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_new
condition|)
name|bfd_link_add_undef
argument_list|(
name|info
operator|->
name|hash
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|bfd_link_hash_common
expr_stmt|;
name|h
operator|->
name|u
operator|.
name|c
operator|.
name|p
operator|=
operator|(
operator|(
expr|struct
name|bfd_link_hash_common_entry
operator|*
operator|)
name|bfd_hash_allocate
argument_list|(
operator|&
name|info
operator|->
name|hash
operator|->
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bfd_link_hash_common_entry
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|u
operator|.
name|c
operator|.
name|p
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|h
operator|->
name|u
operator|.
name|c
operator|.
name|size
operator|=
name|value
expr_stmt|;
comment|/* Select a default alignment based on the size.  This may              be overridden by the caller.  */
block|{
name|unsigned
name|int
name|power
decl_stmt|;
name|power
operator|=
name|bfd_log2
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|power
operator|>
literal|4
condition|)
name|power
operator|=
literal|4
expr_stmt|;
name|h
operator|->
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|alignment_power
operator|=
name|power
expr_stmt|;
block|}
comment|/* The section of a common symbol is only used if the common              symbol is actually allocated.  It basically provides a              hook for the linker script to decide which output section              the common symbols should be put in.  In most cases, the              section of a common symbol will be bfd_com_section_ptr,              the code here will choose a common symbol section named              "COMMON", and the linker script will contain *(COMMON) in              the appropriate place.  A few targets use separate common              sections for small symbols, and they require special              handling.  */
if|if
condition|(
name|section
operator|==
name|bfd_com_section_ptr
condition|)
block|{
name|h
operator|->
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
operator|=
name|bfd_make_section_old_way
argument_list|(
name|abfd
argument_list|,
literal|"COMMON"
argument_list|)
expr_stmt|;
name|h
operator|->
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
operator|->
name|flags
operator|=
name|SEC_ALLOC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|section
operator|->
name|owner
operator|!=
name|abfd
condition|)
block|{
name|h
operator|->
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
operator|=
name|bfd_make_section_old_way
argument_list|(
name|abfd
argument_list|,
name|section
operator|->
name|name
argument_list|)
expr_stmt|;
name|h
operator|->
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
operator|->
name|flags
operator|=
name|SEC_ALLOC
expr_stmt|;
block|}
else|else
name|h
operator|->
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
operator|=
name|section
expr_stmt|;
break|break;
case|case
name|REF
case|:
comment|/* A reference to a defined symbol.  */
if|if
condition|(
name|h
operator|->
name|next
operator|==
name|NULL
operator|&&
name|info
operator|->
name|hash
operator|->
name|undefs_tail
operator|!=
name|h
condition|)
name|h
operator|->
name|next
operator|=
name|h
expr_stmt|;
break|break;
case|case
name|BIG
case|:
comment|/* We have found a common definition for a symbol which 	     already had a common definition.  Use the maximum of the 	     two sizes.  */
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_common
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|multiple_common
call|)
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|string
argument_list|,
name|h
operator|->
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
operator|->
name|owner
argument_list|,
name|bfd_link_hash_common
argument_list|,
name|h
operator|->
name|u
operator|.
name|c
operator|.
name|size
argument_list|,
name|abfd
argument_list|,
name|bfd_link_hash_common
argument_list|,
name|value
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|value
operator|>
name|h
operator|->
name|u
operator|.
name|c
operator|.
name|size
condition|)
block|{
name|unsigned
name|int
name|power
decl_stmt|;
name|h
operator|->
name|u
operator|.
name|c
operator|.
name|size
operator|=
name|value
expr_stmt|;
comment|/* Select a default alignment based on the size.  This may 		 be overridden by the caller.  */
name|power
operator|=
name|bfd_log2
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|power
operator|>
literal|4
condition|)
name|power
operator|=
literal|4
expr_stmt|;
name|h
operator|->
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|alignment_power
operator|=
name|power
expr_stmt|;
block|}
break|break;
case|case
name|CREF
case|:
block|{
name|bfd
modifier|*
name|obfd
decl_stmt|;
comment|/* We have found a common definition for a symbol which 	       was already defined.  FIXME: It would nice if we could 	       report the BFD which defined an indirect symbol, but we 	       don't have anywhere to store the information.  */
if|if
condition|(
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
name|obfd
operator|=
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
expr_stmt|;
else|else
name|obfd
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|multiple_common
call|)
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|string
argument_list|,
name|obfd
argument_list|,
name|h
operator|->
name|type
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|abfd
argument_list|,
name|bfd_link_hash_common
argument_list|,
name|value
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
block|}
break|break;
case|case
name|MIND
case|:
comment|/* Multiple indirect symbols.  This is OK if they both point 	     to the same symbol.  */
if|if
condition|(
name|strcmp
argument_list|(
name|h
operator|->
name|u
operator|.
name|i
operator|.
name|link
operator|->
name|root
operator|.
name|string
argument_list|,
name|string
argument_list|)
operator|==
literal|0
condition|)
break|break;
comment|/* Fall through.  */
case|case
name|MDEF
case|:
comment|/* Handle a multiple definition.  */
block|{
name|asection
modifier|*
name|msec
init|=
name|NULL
decl_stmt|;
name|bfd_vma
name|mval
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|h
operator|->
name|type
condition|)
block|{
case|case
name|bfd_link_hash_defined
case|:
name|msec
operator|=
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|mval
operator|=
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
break|break;
case|case
name|bfd_link_hash_indirect
case|:
name|msec
operator|=
name|bfd_ind_section_ptr
expr_stmt|;
name|mval
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Ignore a redefinition of an absolute symbol to the same                value; it's harmless.  */
if|if
condition|(
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_defined
operator|&&
name|bfd_is_abs_section
argument_list|(
name|msec
argument_list|)
operator|&&
name|bfd_is_abs_section
argument_list|(
name|section
argument_list|)
operator|&&
name|value
operator|==
name|mval
condition|)
break|break;
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|multiple_definition
call|)
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|string
argument_list|,
name|msec
operator|->
name|owner
argument_list|,
name|msec
argument_list|,
name|mval
argument_list|,
name|abfd
argument_list|,
name|section
argument_list|,
name|value
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
block|}
break|break;
case|case
name|CIND
case|:
comment|/* Create an indirect symbol from an existing common symbol.  */
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_common
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|multiple_common
call|)
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|string
argument_list|,
name|h
operator|->
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
operator|->
name|owner
argument_list|,
name|bfd_link_hash_common
argument_list|,
name|h
operator|->
name|u
operator|.
name|c
operator|.
name|size
argument_list|,
name|abfd
argument_list|,
name|bfd_link_hash_indirect
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
comment|/* Fall through.  */
case|case
name|IND
case|:
comment|/* Create an indirect symbol.  */
block|{
name|struct
name|bfd_link_hash_entry
modifier|*
name|inh
decl_stmt|;
comment|/* STRING is the name of the symbol we want to indirect 	       to.  */
name|inh
operator|=
name|bfd_wrapped_link_hash_lookup
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|string
argument_list|,
name|true
argument_list|,
name|copy
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|inh
operator|==
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
name|inh
operator|->
name|type
operator|==
name|bfd_link_hash_indirect
operator|&&
name|inh
operator|->
name|u
operator|.
name|i
operator|.
name|link
operator|==
name|h
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: indirect symbol `%s' to `%s' is a loop"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|name
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|inh
operator|->
name|type
operator|==
name|bfd_link_hash_new
condition|)
block|{
name|inh
operator|->
name|type
operator|=
name|bfd_link_hash_undefined
expr_stmt|;
name|inh
operator|->
name|u
operator|.
name|undef
operator|.
name|abfd
operator|=
name|abfd
expr_stmt|;
name|bfd_link_add_undef
argument_list|(
name|info
operator|->
name|hash
argument_list|,
name|inh
argument_list|)
expr_stmt|;
block|}
comment|/* If the indirect symbol has been referenced, we need to 	       push the reference down to the symbol we are 	       referencing.  */
if|if
condition|(
name|h
operator|->
name|type
operator|!=
name|bfd_link_hash_new
condition|)
block|{
name|row
operator|=
name|UNDEF_ROW
expr_stmt|;
name|cycle
operator|=
name|true
expr_stmt|;
block|}
name|h
operator|->
name|type
operator|=
name|bfd_link_hash_indirect
expr_stmt|;
name|h
operator|->
name|u
operator|.
name|i
operator|.
name|link
operator|=
name|inh
expr_stmt|;
block|}
break|break;
case|case
name|SET
case|:
comment|/* Add an entry to a set.  */
if|if
condition|(
operator|!
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|add_to_set
call|)
argument_list|(
name|info
argument_list|,
name|h
argument_list|,
name|BFD_RELOC_CTOR
argument_list|,
name|abfd
argument_list|,
name|section
argument_list|,
name|value
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|WARNC
case|:
comment|/* Issue a warning and cycle.  */
if|if
condition|(
name|h
operator|->
name|u
operator|.
name|i
operator|.
name|warning
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|warning
call|)
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|u
operator|.
name|i
operator|.
name|warning
argument_list|,
name|h
operator|->
name|root
operator|.
name|string
argument_list|,
name|abfd
argument_list|,
operator|(
name|asection
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Only issue a warning once.  */
name|h
operator|->
name|u
operator|.
name|i
operator|.
name|warning
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Fall through.  */
case|case
name|CYCLE
case|:
comment|/* Try again with the referenced symbol.  */
name|h
operator|=
name|h
operator|->
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|cycle
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|REFC
case|:
comment|/* A reference to an indirect symbol.  */
if|if
condition|(
name|h
operator|->
name|next
operator|==
name|NULL
operator|&&
name|info
operator|->
name|hash
operator|->
name|undefs_tail
operator|!=
name|h
condition|)
name|h
operator|->
name|next
operator|=
name|h
expr_stmt|;
name|h
operator|=
name|h
operator|->
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|cycle
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|WARN
case|:
comment|/* Issue a warning.  */
if|if
condition|(
operator|!
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|warning
call|)
argument_list|(
name|info
argument_list|,
name|string
argument_list|,
name|h
operator|->
name|root
operator|.
name|string
argument_list|,
name|hash_entry_bfd
argument_list|(
name|h
argument_list|)
argument_list|,
operator|(
name|asection
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|CWARN
case|:
comment|/* Warn if this symbol has been referenced already, 	     otherwise add a warning.  A symbol has been referenced if 	     the next field is not NULL, or it is the tail of the 	     undefined symbol list.  The REF case above helps to 	     ensure this.  */
if|if
condition|(
name|h
operator|->
name|next
operator|!=
name|NULL
operator|||
name|info
operator|->
name|hash
operator|->
name|undefs_tail
operator|==
name|h
condition|)
block|{
if|if
condition|(
operator|!
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|warning
call|)
argument_list|(
name|info
argument_list|,
name|string
argument_list|,
name|h
operator|->
name|root
operator|.
name|string
argument_list|,
name|hash_entry_bfd
argument_list|(
name|h
argument_list|)
argument_list|,
operator|(
name|asection
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
block|}
comment|/* Fall through.  */
case|case
name|MWARN
case|:
comment|/* Make a warning symbol.  */
block|{
name|struct
name|bfd_link_hash_entry
modifier|*
name|sub
decl_stmt|;
comment|/* STRING is the warning to give.  */
name|sub
operator|=
operator|(
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|)
operator|(
call|(
modifier|*
name|info
operator|->
name|hash
operator|->
name|table
operator|.
name|newfunc
call|)
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|info
operator|->
name|hash
operator|->
name|table
argument_list|,
name|h
operator|->
name|root
operator|.
name|string
argument_list|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|sub
operator|==
name|NULL
condition|)
return|return
name|false
return|;
operator|*
name|sub
operator|=
operator|*
name|h
expr_stmt|;
name|sub
operator|->
name|type
operator|=
name|bfd_link_hash_warning
expr_stmt|;
name|sub
operator|->
name|u
operator|.
name|i
operator|.
name|link
operator|=
name|h
expr_stmt|;
if|if
condition|(
operator|!
name|copy
condition|)
name|sub
operator|->
name|u
operator|.
name|i
operator|.
name|warning
operator|=
name|string
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|w
decl_stmt|;
name|w
operator|=
name|bfd_hash_allocate
argument_list|(
operator|&
name|info
operator|->
name|hash
operator|->
name|table
argument_list|,
name|strlen
argument_list|(
name|string
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|strcpy
argument_list|(
name|w
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|sub
operator|->
name|u
operator|.
name|i
operator|.
name|warning
operator|=
name|w
expr_stmt|;
block|}
name|bfd_hash_replace
argument_list|(
operator|&
name|info
operator|->
name|hash
operator|->
name|table
argument_list|,
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|h
argument_list|,
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|sub
argument_list|)
expr_stmt|;
if|if
condition|(
name|hashp
operator|!=
name|NULL
condition|)
operator|*
name|hashp
operator|=
name|sub
expr_stmt|;
block|}
break|break;
block|}
block|}
do|while
condition|(
name|cycle
condition|)
do|;
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generic final link routine.  */
end_comment

begin_function
name|boolean
name|_bfd_generic_final_link
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|bfd
modifier|*
name|sub
decl_stmt|;
name|asection
modifier|*
name|o
decl_stmt|;
name|struct
name|bfd_link_order
modifier|*
name|p
decl_stmt|;
name|size_t
name|outsymalloc
decl_stmt|;
name|struct
name|generic_write_global_symbol_info
name|wginfo
decl_stmt|;
name|bfd_get_outsymbols
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|NULL
expr_stmt|;
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|=
literal|0
expr_stmt|;
name|outsymalloc
operator|=
literal|0
expr_stmt|;
comment|/* Mark all sections which will be included in the output file.  */
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
for|for
control|(
name|p
operator|=
name|o
operator|->
name|link_order_head
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_indirect_link_order
condition|)
name|p
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
operator|->
name|linker_mark
operator|=
name|true
expr_stmt|;
comment|/* Build the output symbol table.  */
for|for
control|(
name|sub
operator|=
name|info
operator|->
name|input_bfds
init|;
name|sub
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|;
name|sub
operator|=
name|sub
operator|->
name|link_next
control|)
if|if
condition|(
operator|!
name|_bfd_generic_link_output_symbols
argument_list|(
name|abfd
argument_list|,
name|sub
argument_list|,
name|info
argument_list|,
operator|&
name|outsymalloc
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Accumulate the global symbols.  */
name|wginfo
operator|.
name|info
operator|=
name|info
expr_stmt|;
name|wginfo
operator|.
name|output_bfd
operator|=
name|abfd
expr_stmt|;
name|wginfo
operator|.
name|psymalloc
operator|=
operator|&
name|outsymalloc
expr_stmt|;
name|_bfd_generic_link_hash_traverse
argument_list|(
name|_bfd_generic_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|_bfd_generic_link_write_global_symbol
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|wginfo
argument_list|)
expr_stmt|;
comment|/* Make sure we have a trailing NULL pointer on OUTSYMBOLS.  We      shouldn't really need one, since we have SYMCOUNT, but some old      code still expects one.  */
if|if
condition|(
operator|!
name|generic_add_output_symbol
argument_list|(
name|abfd
argument_list|,
operator|&
name|outsymalloc
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|info
operator|->
name|relocateable
condition|)
block|{
comment|/* Allocate space for the output relocs for each section.  */
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
name|o
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|o
operator|->
name|link_order_head
init|;
name|p
operator|!=
operator|(
expr|struct
name|bfd_link_order
operator|*
operator|)
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_section_reloc_link_order
operator|||
name|p
operator|->
name|type
operator|==
name|bfd_symbol_reloc_link_order
condition|)
operator|++
name|o
operator|->
name|reloc_count
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_indirect_link_order
condition|)
block|{
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|long
name|relsize
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|relocs
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
name|long
name|reloc_count
decl_stmt|;
name|input_section
operator|=
name|p
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
expr_stmt|;
name|input_bfd
operator|=
name|input_section
operator|->
name|owner
expr_stmt|;
name|relsize
operator|=
name|bfd_get_reloc_upper_bound
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
expr_stmt|;
if|if
condition|(
name|relsize
operator|<
literal|0
condition|)
return|return
name|false
return|;
name|relocs
operator|=
operator|(
name|arelent
operator|*
operator|*
operator|)
name|bfd_malloc
argument_list|(
operator|(
name|size_t
operator|)
name|relsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|relocs
operator|&&
name|relsize
operator|!=
literal|0
condition|)
return|return
name|false
return|;
name|symbols
operator|=
name|_bfd_generic_link_get_symbols
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|reloc_count
operator|=
name|bfd_canonicalize_reloc
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|relocs
argument_list|,
name|symbols
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc_count
operator|<
literal|0
condition|)
return|return
name|false
return|;
name|BFD_ASSERT
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|reloc_count
operator|==
name|input_section
operator|->
name|reloc_count
argument_list|)
expr_stmt|;
name|o
operator|->
name|reloc_count
operator|+=
name|reloc_count
expr_stmt|;
name|free
argument_list|(
name|relocs
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|o
operator|->
name|reloc_count
operator|>
literal|0
condition|)
block|{
name|o
operator|->
name|orelocation
operator|=
operator|(
operator|(
name|arelent
operator|*
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
operator|(
name|o
operator|->
name|reloc_count
operator|*
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
operator|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|o
operator|->
name|orelocation
condition|)
return|return
name|false
return|;
name|o
operator|->
name|flags
operator||=
name|SEC_RELOC
expr_stmt|;
comment|/* Reset the count so that it can be used as an index 		 when putting in the output relocs.  */
name|o
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
comment|/* Handle all the link order information for the sections.  */
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
for|for
control|(
name|p
operator|=
name|o
operator|->
name|link_order_head
init|;
name|p
operator|!=
operator|(
expr|struct
name|bfd_link_order
operator|*
operator|)
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
switch|switch
condition|(
name|p
operator|->
name|type
condition|)
block|{
case|case
name|bfd_section_reloc_link_order
case|:
case|case
name|bfd_symbol_reloc_link_order
case|:
if|if
condition|(
operator|!
name|_bfd_generic_reloc_link_order
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|o
argument_list|,
name|p
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|bfd_indirect_link_order
case|:
if|if
condition|(
operator|!
name|default_indirect_link_order
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|o
argument_list|,
name|p
argument_list|,
name|true
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
default|default:
if|if
condition|(
operator|!
name|_bfd_default_link_order
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|o
argument_list|,
name|p
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
block|}
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Add an output symbol to the output BFD.  */
end_comment

begin_function
specifier|static
name|boolean
name|generic_add_output_symbol
parameter_list|(
name|output_bfd
parameter_list|,
name|psymalloc
parameter_list|,
name|sym
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|size_t
modifier|*
name|psymalloc
decl_stmt|;
name|asymbol
modifier|*
name|sym
decl_stmt|;
block|{
if|if
condition|(
name|bfd_get_symcount
argument_list|(
name|output_bfd
argument_list|)
operator|>=
operator|*
name|psymalloc
condition|)
block|{
name|asymbol
modifier|*
modifier|*
name|newsyms
decl_stmt|;
if|if
condition|(
operator|*
name|psymalloc
operator|==
literal|0
condition|)
operator|*
name|psymalloc
operator|=
literal|124
expr_stmt|;
else|else
operator|*
name|psymalloc
operator|*=
literal|2
expr_stmt|;
name|newsyms
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|bfd_realloc
argument_list|(
name|bfd_get_outsymbols
argument_list|(
name|output_bfd
argument_list|)
argument_list|,
operator|*
name|psymalloc
operator|*
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newsyms
operator|==
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|NULL
condition|)
return|return
name|false
return|;
name|bfd_get_outsymbols
argument_list|(
name|output_bfd
argument_list|)
operator|=
name|newsyms
expr_stmt|;
block|}
name|bfd_get_outsymbols
argument_list|(
name|output_bfd
argument_list|)
index|[
name|bfd_get_symcount
argument_list|(
name|output_bfd
argument_list|)
index|]
operator|=
name|sym
expr_stmt|;
if|if
condition|(
name|sym
operator|!=
name|NULL
condition|)
operator|++
name|bfd_get_symcount
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Handle the symbols for an input BFD.  */
end_comment

begin_function
name|boolean
name|_bfd_generic_link_output_symbols
parameter_list|(
name|output_bfd
parameter_list|,
name|input_bfd
parameter_list|,
name|info
parameter_list|,
name|psymalloc
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|size_t
modifier|*
name|psymalloc
decl_stmt|;
block|{
name|asymbol
modifier|*
modifier|*
name|sym_ptr
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|sym_end
decl_stmt|;
if|if
condition|(
operator|!
name|generic_link_read_symbols
argument_list|(
name|input_bfd
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Create a filename symbol if we are supposed to.  */
if|if
condition|(
name|info
operator|->
name|create_object_symbols_section
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
for|for
control|(
name|sec
operator|=
name|input_bfd
operator|->
name|sections
init|;
name|sec
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
block|{
if|if
condition|(
name|sec
operator|->
name|output_section
operator|==
name|info
operator|->
name|create_object_symbols_section
condition|)
block|{
name|asymbol
modifier|*
name|newsym
decl_stmt|;
name|newsym
operator|=
name|bfd_make_empty_symbol
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newsym
condition|)
return|return
name|false
return|;
name|newsym
operator|->
name|name
operator|=
name|input_bfd
operator|->
name|filename
expr_stmt|;
name|newsym
operator|->
name|value
operator|=
literal|0
expr_stmt|;
name|newsym
operator|->
name|flags
operator|=
name|BSF_LOCAL
operator||
name|BSF_FILE
expr_stmt|;
name|newsym
operator|->
name|section
operator|=
name|sec
expr_stmt|;
if|if
condition|(
operator|!
name|generic_add_output_symbol
argument_list|(
name|output_bfd
argument_list|,
name|psymalloc
argument_list|,
name|newsym
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
block|}
block|}
block|}
comment|/* Adjust the values of the globally visible symbols, and write out      local symbols.  */
name|sym_ptr
operator|=
name|_bfd_generic_link_get_symbols
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|sym_end
operator|=
name|sym_ptr
operator|+
name|_bfd_generic_link_get_symcount
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|sym_ptr
operator|<
name|sym_end
condition|;
name|sym_ptr
operator|++
control|)
block|{
name|asymbol
modifier|*
name|sym
decl_stmt|;
name|struct
name|generic_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|boolean
name|output
decl_stmt|;
name|h
operator|=
operator|(
expr|struct
name|generic_link_hash_entry
operator|*
operator|)
name|NULL
expr_stmt|;
name|sym
operator|=
operator|*
name|sym_ptr
expr_stmt|;
if|if
condition|(
operator|(
name|sym
operator|->
name|flags
operator|&
operator|(
name|BSF_INDIRECT
operator||
name|BSF_WARNING
operator||
name|BSF_GLOBAL
operator||
name|BSF_CONSTRUCTOR
operator||
name|BSF_WEAK
operator|)
operator|)
operator|!=
literal|0
operator|||
name|bfd_is_und_section
argument_list|(
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|||
name|bfd_is_com_section
argument_list|(
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|||
name|bfd_is_ind_section
argument_list|(
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|sym
operator|->
name|udata
operator|.
name|p
operator|!=
name|NULL
condition|)
name|h
operator|=
operator|(
expr|struct
name|generic_link_hash_entry
operator|*
operator|)
name|sym
operator|->
name|udata
operator|.
name|p
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|sym
operator|->
name|flags
operator|&
name|BSF_CONSTRUCTOR
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* This case normally means that the main linker code                  deliberately ignored this constructor symbol.  We                  should just pass it through.  This will screw up if                  the constructor symbol is from a different,                  non-generic, object file format, but the case will                  only arise when linking with -r, which will probably                  fail anyhow, since there will be no way to represent                  the relocs in the output format being used.  */
name|h
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
name|h
operator|=
operator|(
operator|(
expr|struct
name|generic_link_hash_entry
operator|*
operator|)
name|bfd_wrapped_link_hash_lookup
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
operator|)
expr_stmt|;
else|else
name|h
operator|=
name|_bfd_generic_link_hash_lookup
argument_list|(
name|_bfd_generic_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
operator|(
expr|struct
name|generic_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* Force all references to this symbol to point to 		 the same area in memory.  It is possible that 		 this routine will be called with a hash table 		 other than a generic hash table, so we double 		 check that.  */
if|if
condition|(
name|info
operator|->
name|hash
operator|->
name|creator
operator|==
name|input_bfd
operator|->
name|xvec
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|sym
operator|!=
operator|(
name|asymbol
operator|*
operator|)
name|NULL
condition|)
operator|*
name|sym_ptr
operator|=
name|sym
operator|=
name|h
operator|->
name|sym
expr_stmt|;
block|}
switch|switch
condition|(
name|h
operator|->
name|root
operator|.
name|type
condition|)
block|{
default|default:
case|case
name|bfd_link_hash_new
case|:
name|abort
argument_list|()
expr_stmt|;
case|case
name|bfd_link_hash_undefined
case|:
break|break;
case|case
name|bfd_link_hash_undefweak
case|:
name|sym
operator|->
name|flags
operator||=
name|BSF_WEAK
expr_stmt|;
break|break;
case|case
name|bfd_link_hash_indirect
case|:
name|h
operator|=
operator|(
expr|struct
name|generic_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
comment|/* fall through */
case|case
name|bfd_link_hash_defined
case|:
name|sym
operator|->
name|flags
operator||=
name|BSF_GLOBAL
expr_stmt|;
name|sym
operator|->
name|flags
operator|&=
operator|~
name|BSF_CONSTRUCTOR
expr_stmt|;
name|sym
operator|->
name|value
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
name|sym
operator|->
name|section
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
break|break;
case|case
name|bfd_link_hash_defweak
case|:
name|sym
operator|->
name|flags
operator||=
name|BSF_WEAK
expr_stmt|;
name|sym
operator|->
name|flags
operator|&=
operator|~
name|BSF_CONSTRUCTOR
expr_stmt|;
name|sym
operator|->
name|value
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
name|sym
operator|->
name|section
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
break|break;
case|case
name|bfd_link_hash_common
case|:
name|sym
operator|->
name|value
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|size
expr_stmt|;
name|sym
operator|->
name|flags
operator||=
name|BSF_GLOBAL
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_is_com_section
argument_list|(
name|sym
operator|->
name|section
argument_list|)
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|bfd_is_und_section
argument_list|(
name|sym
operator|->
name|section
argument_list|)
argument_list|)
expr_stmt|;
name|sym
operator|->
name|section
operator|=
name|bfd_com_section_ptr
expr_stmt|;
block|}
comment|/* We do not set the section of the symbol to 		     h->root.u.c.p->section.  That value was saved so 		     that we would know where to allocate the symbol 		     if it was defined.  In this case the type is 		     still bfd_link_hash_common, so we did not define 		     it, so we do not want to use that section.  */
break|break;
block|}
block|}
block|}
comment|/* This switch is straight from the old code in 	 write_file_locals in ldsym.c.  */
if|if
condition|(
name|info
operator|->
name|strip
operator|==
name|strip_all
operator|||
operator|(
name|info
operator|->
name|strip
operator|==
name|strip_some
operator|&&
operator|(
name|bfd_hash_lookup
argument_list|(
name|info
operator|->
name|keep_hash
argument_list|,
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
operator|==
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|NULL
operator|)
operator|)
condition|)
name|output
operator|=
name|false
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|sym
operator|->
name|flags
operator|&
operator|(
name|BSF_GLOBAL
operator||
name|BSF_WEAK
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* If this symbol is marked as occurring now, rather 	     than at the end, output it now.  This is used for 	     COFF C_EXT FCN symbols.  FIXME: There must be a 	     better way.  */
if|if
condition|(
name|bfd_asymbol_bfd
argument_list|(
name|sym
argument_list|)
operator|==
name|input_bfd
operator|&&
operator|(
name|sym
operator|->
name|flags
operator|&
name|BSF_NOT_AT_END
operator|)
operator|!=
literal|0
condition|)
name|output
operator|=
name|true
expr_stmt|;
else|else
name|output
operator|=
name|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bfd_is_ind_section
argument_list|(
name|sym
operator|->
name|section
argument_list|)
condition|)
name|output
operator|=
name|false
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|sym
operator|->
name|flags
operator|&
name|BSF_DEBUGGING
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|strip
operator|==
name|strip_none
condition|)
name|output
operator|=
name|true
expr_stmt|;
else|else
name|output
operator|=
name|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|sym
operator|->
name|section
argument_list|)
operator|||
name|bfd_is_com_section
argument_list|(
name|sym
operator|->
name|section
argument_list|)
condition|)
name|output
operator|=
name|false
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|sym
operator|->
name|flags
operator|&
name|BSF_LOCAL
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|sym
operator|->
name|flags
operator|&
name|BSF_WARNING
operator|)
operator|!=
literal|0
condition|)
name|output
operator|=
name|false
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|info
operator|->
name|discard
condition|)
block|{
default|default:
case|case
name|discard_all
case|:
name|output
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|discard_l
case|:
if|if
condition|(
name|bfd_is_local_label
argument_list|(
name|input_bfd
argument_list|,
name|sym
argument_list|)
condition|)
name|output
operator|=
name|false
expr_stmt|;
else|else
name|output
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|discard_none
case|:
name|output
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|sym
operator|->
name|flags
operator|&
name|BSF_CONSTRUCTOR
operator|)
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|strip
operator|!=
name|strip_all
condition|)
name|output
operator|=
name|true
expr_stmt|;
else|else
name|output
operator|=
name|false
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* If this symbol is in a section which is not being included 	 in the output file, then we don't want to output the symbol.  	 Gross.  .bss and similar sections won't have the linker_mark 	 field set.  */
if|if
condition|(
operator|(
name|sym
operator|->
name|section
operator|->
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|!=
literal|0
operator|&&
name|sym
operator|->
name|section
operator|->
name|linker_mark
operator|==
name|false
condition|)
name|output
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|output
condition|)
block|{
if|if
condition|(
operator|!
name|generic_add_output_symbol
argument_list|(
name|output_bfd
argument_list|,
name|psymalloc
argument_list|,
name|sym
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|h
operator|!=
operator|(
expr|struct
name|generic_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
name|h
operator|->
name|written
operator|=
name|true
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Set the section and value of a generic BFD symbol based on a linker    hash table entry.  */
end_comment

begin_function
specifier|static
name|void
name|set_symbol_from_hash
parameter_list|(
name|sym
parameter_list|,
name|h
parameter_list|)
name|asymbol
modifier|*
name|sym
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
block|{
switch|switch
condition|(
name|h
operator|->
name|type
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
name|bfd_link_hash_new
case|:
comment|/* This can happen when a constructor symbol is seen but we are          not building constructors.  */
if|if
condition|(
name|sym
operator|->
name|section
operator|!=
name|NULL
condition|)
block|{
name|BFD_ASSERT
argument_list|(
operator|(
name|sym
operator|->
name|flags
operator|&
name|BSF_CONSTRUCTOR
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sym
operator|->
name|flags
operator||=
name|BSF_CONSTRUCTOR
expr_stmt|;
name|sym
operator|->
name|section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
name|sym
operator|->
name|value
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|bfd_link_hash_undefined
case|:
name|sym
operator|->
name|section
operator|=
name|bfd_und_section_ptr
expr_stmt|;
name|sym
operator|->
name|value
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|bfd_link_hash_undefweak
case|:
name|sym
operator|->
name|section
operator|=
name|bfd_und_section_ptr
expr_stmt|;
name|sym
operator|->
name|value
operator|=
literal|0
expr_stmt|;
name|sym
operator|->
name|flags
operator||=
name|BSF_WEAK
expr_stmt|;
break|break;
case|case
name|bfd_link_hash_defined
case|:
name|sym
operator|->
name|section
operator|=
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|sym
operator|->
name|value
operator|=
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
break|break;
case|case
name|bfd_link_hash_defweak
case|:
name|sym
operator|->
name|flags
operator||=
name|BSF_WEAK
expr_stmt|;
name|sym
operator|->
name|section
operator|=
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|sym
operator|->
name|value
operator|=
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
break|break;
case|case
name|bfd_link_hash_common
case|:
name|sym
operator|->
name|value
operator|=
name|h
operator|->
name|u
operator|.
name|c
operator|.
name|size
expr_stmt|;
if|if
condition|(
name|sym
operator|->
name|section
operator|==
name|NULL
condition|)
name|sym
operator|->
name|section
operator|=
name|bfd_com_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|bfd_is_com_section
argument_list|(
name|sym
operator|->
name|section
argument_list|)
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|bfd_is_und_section
argument_list|(
name|sym
operator|->
name|section
argument_list|)
argument_list|)
expr_stmt|;
name|sym
operator|->
name|section
operator|=
name|bfd_com_section_ptr
expr_stmt|;
block|}
comment|/* Do not set the section; see _bfd_generic_link_output_symbols.  */
break|break;
case|case
name|bfd_link_hash_indirect
case|:
case|case
name|bfd_link_hash_warning
case|:
comment|/* FIXME: What should we do here?  */
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Write out a global symbol, if it hasn't already been written out.    This is called for each symbol in the hash table.  */
end_comment

begin_function
name|boolean
name|_bfd_generic_link_write_global_symbol
parameter_list|(
name|h
parameter_list|,
name|data
parameter_list|)
name|struct
name|generic_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
name|struct
name|generic_write_global_symbol_info
modifier|*
name|wginfo
init|=
operator|(
expr|struct
name|generic_write_global_symbol_info
operator|*
operator|)
name|data
decl_stmt|;
name|asymbol
modifier|*
name|sym
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|written
condition|)
return|return
name|true
return|;
name|h
operator|->
name|written
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|wginfo
operator|->
name|info
operator|->
name|strip
operator|==
name|strip_all
operator|||
operator|(
name|wginfo
operator|->
name|info
operator|->
name|strip
operator|==
name|strip_some
operator|&&
name|bfd_hash_lookup
argument_list|(
name|wginfo
operator|->
name|info
operator|->
name|keep_hash
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
operator|==
name|NULL
operator|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|h
operator|->
name|sym
operator|!=
operator|(
name|asymbol
operator|*
operator|)
name|NULL
condition|)
name|sym
operator|=
name|h
operator|->
name|sym
expr_stmt|;
else|else
block|{
name|sym
operator|=
name|bfd_make_empty_symbol
argument_list|(
name|wginfo
operator|->
name|output_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sym
condition|)
return|return
name|false
return|;
name|sym
operator|->
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
name|sym
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
block|}
name|set_symbol_from_hash
argument_list|(
name|sym
argument_list|,
operator|&
name|h
operator|->
name|root
argument_list|)
expr_stmt|;
name|sym
operator|->
name|flags
operator||=
name|BSF_GLOBAL
expr_stmt|;
if|if
condition|(
operator|!
name|generic_add_output_symbol
argument_list|(
name|wginfo
operator|->
name|output_bfd
argument_list|,
name|wginfo
operator|->
name|psymalloc
argument_list|,
name|sym
argument_list|)
condition|)
block|{
comment|/* FIXME: No way to return failure.  */
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Create a relocation.  */
end_comment

begin_function
name|boolean
name|_bfd_generic_reloc_link_order
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|sec
parameter_list|,
name|link_order
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|bfd_link_order
modifier|*
name|link_order
decl_stmt|;
block|{
name|arelent
modifier|*
name|r
decl_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|relocateable
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|orelocation
operator|==
operator|(
name|arelent
operator|*
operator|*
operator|)
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|r
operator|=
operator|(
name|arelent
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
operator|(
name|arelent
operator|*
operator|)
name|NULL
condition|)
return|return
name|false
return|;
name|r
operator|->
name|address
operator|=
name|link_order
operator|->
name|offset
expr_stmt|;
name|r
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|abfd
argument_list|,
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|reloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|howto
operator|==
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Get the symbol to use for the relocation.  */
if|if
condition|(
name|link_order
operator|->
name|type
operator|==
name|bfd_section_reloc_link_order
condition|)
name|r
operator|->
name|sym_ptr_ptr
operator|=
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|u
operator|.
name|section
operator|->
name|symbol_ptr_ptr
expr_stmt|;
else|else
block|{
name|struct
name|generic_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
operator|(
operator|(
expr|struct
name|generic_link_hash_entry
operator|*
operator|)
name|bfd_wrapped_link_hash_lookup
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|u
operator|.
name|name
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
operator|(
expr|struct
name|generic_link_hash_entry
operator|*
operator|)
name|NULL
operator|||
operator|!
name|h
operator|->
name|written
condition|)
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|unattached_reloc
call|)
argument_list|(
name|info
argument_list|,
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|u
operator|.
name|name
argument_list|,
operator|(
name|bfd
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|asection
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|r
operator|->
name|sym_ptr_ptr
operator|=
operator|&
name|h
operator|->
name|sym
expr_stmt|;
block|}
comment|/* If this is an inplace reloc, write the addend to the object file.      Otherwise, store it in the reloc addend.  */
if|if
condition|(
operator|!
name|r
operator|->
name|howto
operator|->
name|partial_inplace
condition|)
name|r
operator|->
name|addend
operator|=
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|addend
expr_stmt|;
else|else
block|{
name|bfd_size_type
name|size
decl_stmt|;
name|bfd_reloc_status_type
name|rstat
decl_stmt|;
name|bfd_byte
modifier|*
name|buf
decl_stmt|;
name|boolean
name|ok
decl_stmt|;
name|size
operator|=
name|bfd_get_reloc_size
argument_list|(
name|r
operator|->
name|howto
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_zmalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
operator|(
name|bfd_byte
operator|*
operator|)
name|NULL
condition|)
return|return
name|false
return|;
name|rstat
operator|=
name|_bfd_relocate_contents
argument_list|(
name|r
operator|->
name|howto
argument_list|,
name|abfd
argument_list|,
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|addend
argument_list|,
name|buf
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rstat
condition|)
block|{
case|case
name|bfd_reloc_ok
case|:
break|break;
default|default:
case|case
name|bfd_reloc_outofrange
case|:
name|abort
argument_list|()
expr_stmt|;
case|case
name|bfd_reloc_overflow
case|:
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|info
argument_list|,
operator|(
name|link_order
operator|->
name|type
operator|==
name|bfd_section_reloc_link_order
condition|?
name|bfd_section_name
argument_list|(
name|abfd
argument_list|,
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|u
operator|.
name|section
argument_list|)
else|:
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|u
operator|.
name|name
operator|)
argument_list|,
name|r
operator|->
name|howto
operator|->
name|name
argument_list|,
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|addend
argument_list|,
operator|(
name|bfd
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|asection
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
operator|)
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
break|break;
block|}
name|ok
operator|=
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
operator|(
name|PTR
operator|)
name|buf
argument_list|,
call|(
name|file_ptr
call|)
argument_list|(
name|link_order
operator|->
name|offset
operator|*
name|bfd_octets_per_byte
argument_list|(
name|abfd
argument_list|)
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|false
return|;
name|r
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
block|}
name|sec
operator|->
name|orelocation
index|[
name|sec
operator|->
name|reloc_count
index|]
operator|=
name|r
expr_stmt|;
operator|++
name|sec
operator|->
name|reloc_count
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Allocate a new link_order for a section.  */
end_comment

begin_function
name|struct
name|bfd_link_order
modifier|*
name|bfd_new_link_order
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
block|{
name|struct
name|bfd_link_order
modifier|*
name|new
decl_stmt|;
name|new
operator|=
operator|(
operator|(
expr|struct
name|bfd_link_order
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bfd_link_order
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|new
condition|)
return|return
name|NULL
return|;
name|new
operator|->
name|type
operator|=
name|bfd_undefined_link_order
expr_stmt|;
name|new
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|next
operator|=
operator|(
expr|struct
name|bfd_link_order
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|section
operator|->
name|link_order_tail
operator|!=
operator|(
expr|struct
name|bfd_link_order
operator|*
operator|)
name|NULL
condition|)
name|section
operator|->
name|link_order_tail
operator|->
name|next
operator|=
name|new
expr_stmt|;
else|else
name|section
operator|->
name|link_order_head
operator|=
name|new
expr_stmt|;
name|section
operator|->
name|link_order_tail
operator|=
name|new
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/* Default link order processing routine.  Note that we can not handle    the reloc_link_order types here, since they depend upon the details    of how the particular backends generates relocs.  */
end_comment

begin_function
name|boolean
name|_bfd_default_link_order
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|sec
parameter_list|,
name|link_order
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|bfd_link_order
modifier|*
name|link_order
decl_stmt|;
block|{
switch|switch
condition|(
name|link_order
operator|->
name|type
condition|)
block|{
case|case
name|bfd_undefined_link_order
case|:
case|case
name|bfd_section_reloc_link_order
case|:
case|case
name|bfd_symbol_reloc_link_order
case|:
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|bfd_indirect_link_order
case|:
return|return
name|default_indirect_link_order
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|sec
argument_list|,
name|link_order
argument_list|,
name|false
argument_list|)
return|;
case|case
name|bfd_fill_link_order
case|:
return|return
name|default_fill_link_order
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|sec
argument_list|,
name|link_order
argument_list|)
return|;
case|case
name|bfd_data_link_order
case|:
return|return
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
operator|(
name|PTR
operator|)
name|link_order
operator|->
name|u
operator|.
name|data
operator|.
name|contents
argument_list|,
call|(
name|file_ptr
call|)
argument_list|(
name|link_order
operator|->
name|offset
operator|*
name|bfd_octets_per_byte
argument_list|(
name|abfd
argument_list|)
argument_list|)
argument_list|,
name|link_order
operator|->
name|size
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Default routine to handle a bfd_fill_link_order.  */
end_comment

begin_function
specifier|static
name|boolean
name|default_fill_link_order
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|sec
parameter_list|,
name|link_order
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|bfd_link_order
modifier|*
name|link_order
decl_stmt|;
block|{
name|size_t
name|size
decl_stmt|;
name|char
modifier|*
name|space
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|int
name|fill
decl_stmt|;
name|boolean
name|result
decl_stmt|;
name|BFD_ASSERT
argument_list|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|size
operator|=
operator|(
name|size_t
operator|)
name|link_order
operator|->
name|size
expr_stmt|;
name|space
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|space
operator|==
name|NULL
operator|&&
name|size
operator|!=
literal|0
condition|)
return|return
name|false
return|;
name|fill
operator|=
name|link_order
operator|->
name|u
operator|.
name|fill
operator|.
name|value
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|+=
literal|2
control|)
name|space
index|[
name|i
index|]
operator|=
name|fill
operator|>>
literal|8
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|+=
literal|2
control|)
name|space
index|[
name|i
index|]
operator|=
name|fill
expr_stmt|;
name|result
operator|=
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|space
argument_list|,
call|(
name|file_ptr
call|)
argument_list|(
name|link_order
operator|->
name|offset
operator|*
name|bfd_octets_per_byte
argument_list|(
name|abfd
argument_list|)
argument_list|)
argument_list|,
name|link_order
operator|->
name|size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|space
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Default routine to handle a bfd_indirect_link_order.  */
end_comment

begin_function
specifier|static
name|boolean
name|default_indirect_link_order
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|output_section
parameter_list|,
name|link_order
parameter_list|,
name|generic_linker
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|asection
modifier|*
name|output_section
decl_stmt|;
name|struct
name|bfd_link_order
modifier|*
name|link_order
decl_stmt|;
name|boolean
name|generic_linker
decl_stmt|;
block|{
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
init|=
name|NULL
decl_stmt|;
name|bfd_byte
modifier|*
name|new_contents
decl_stmt|;
name|BFD_ASSERT
argument_list|(
operator|(
name|output_section
operator|->
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|link_order
operator|->
name|size
operator|==
literal|0
condition|)
return|return
name|true
return|;
name|input_section
operator|=
name|link_order
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
expr_stmt|;
name|input_bfd
operator|=
name|input_section
operator|->
name|owner
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|input_section
operator|->
name|output_section
operator|==
name|output_section
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|input_section
operator|->
name|output_offset
operator|==
name|link_order
operator|->
name|offset
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|input_section
operator|->
name|_cooked_size
operator|==
name|link_order
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|relocateable
operator|&&
name|input_section
operator|->
name|reloc_count
operator|>
literal|0
operator|&&
name|output_section
operator|->
name|orelocation
operator|==
operator|(
name|arelent
operator|*
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* Space has not been allocated for the output relocations. 	 This can happen when we are called by a specific backend 	 because somebody is attempting to link together different 	 types of object files.  Handling this case correctly is 	 difficult, and sometimes impossible.  */
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Attempt to do relocateable link with %s input and %s output"
argument_list|)
argument_list|,
name|bfd_get_target
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|bfd_get_target
argument_list|(
name|output_bfd
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|generic_linker
condition|)
block|{
name|asymbol
modifier|*
modifier|*
name|sympp
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symppend
decl_stmt|;
comment|/* Get the canonical symbols.  The generic linker will always 	 have retrieved them by this point, but we are being called by 	 a specific linker, presumably because we are linking 	 different types of object files together.  */
if|if
condition|(
operator|!
name|generic_link_read_symbols
argument_list|(
name|input_bfd
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Since we have been called by a specific linker, rather than 	 the generic linker, the values of the symbols will not be 	 right.  They will be the values as seen in the input file, 	 not the values of the final link.  We need to fix them up 	 before we can relocate the section.  */
name|sympp
operator|=
name|_bfd_generic_link_get_symbols
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|symppend
operator|=
name|sympp
operator|+
name|_bfd_generic_link_get_symcount
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|sympp
operator|<
name|symppend
condition|;
name|sympp
operator|++
control|)
block|{
name|asymbol
modifier|*
name|sym
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|sym
operator|=
operator|*
name|sympp
expr_stmt|;
if|if
condition|(
operator|(
name|sym
operator|->
name|flags
operator|&
operator|(
name|BSF_INDIRECT
operator||
name|BSF_WARNING
operator||
name|BSF_GLOBAL
operator||
name|BSF_CONSTRUCTOR
operator||
name|BSF_WEAK
operator|)
operator|)
operator|!=
literal|0
operator|||
name|bfd_is_und_section
argument_list|(
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|||
name|bfd_is_com_section
argument_list|(
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|||
name|bfd_is_ind_section
argument_list|(
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
block|{
comment|/* sym->udata may have been set by 		 generic_link_add_symbol_list.  */
if|if
condition|(
name|sym
operator|->
name|udata
operator|.
name|p
operator|!=
name|NULL
condition|)
name|h
operator|=
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|)
name|sym
operator|->
name|udata
operator|.
name|p
expr_stmt|;
elseif|else
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
name|h
operator|=
name|bfd_wrapped_link_hash_lookup
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
else|else
name|h
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|info
operator|->
name|hash
argument_list|,
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|set_symbol_from_hash
argument_list|(
name|sym
argument_list|,
name|h
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Get and relocate the section contents.  */
name|contents
operator|=
operator|(
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|bfd_section_size
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
operator|&&
name|bfd_section_size
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
name|new_contents
operator|=
operator|(
name|bfd_get_relocated_section_contents
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|link_order
argument_list|,
name|contents
argument_list|,
name|info
operator|->
name|relocateable
argument_list|,
name|_bfd_generic_link_get_symbols
argument_list|(
name|input_bfd
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_contents
condition|)
goto|goto
name|error_return
goto|;
comment|/* Output the section contents.  */
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|output_bfd
argument_list|,
name|output_section
argument_list|,
operator|(
name|PTR
operator|)
name|new_contents
argument_list|,
call|(
name|file_ptr
call|)
argument_list|(
name|link_order
operator|->
name|offset
operator|*
name|bfd_octets_per_byte
argument_list|(
name|output_bfd
argument_list|)
argument_list|)
argument_list|,
name|link_order
operator|->
name|size
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|contents
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
return|return
name|true
return|;
name|error_return
label|:
if|if
condition|(
name|contents
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* A little routine to count the number of relocs in a link_order    list.  */
end_comment

begin_function
name|unsigned
name|int
name|_bfd_count_link_order_relocs
parameter_list|(
name|link_order
parameter_list|)
name|struct
name|bfd_link_order
modifier|*
name|link_order
decl_stmt|;
block|{
specifier|register
name|unsigned
name|int
name|c
decl_stmt|;
specifier|register
name|struct
name|bfd_link_order
modifier|*
name|l
decl_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|l
operator|=
name|link_order
init|;
name|l
operator|!=
operator|(
expr|struct
name|bfd_link_order
operator|*
operator|)
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
if|if
condition|(
name|l
operator|->
name|type
operator|==
name|bfd_section_reloc_link_order
operator|||
name|l
operator|->
name|type
operator|==
name|bfd_symbol_reloc_link_order
condition|)
operator|++
name|c
expr_stmt|;
block|}
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/* FUNCTION 	bfd_link_split_section  SYNOPSIS         boolean bfd_link_split_section(bfd *abfd, asection *sec);  DESCRIPTION 	Return nonzero if @var{sec} should be split during a 	reloceatable or final link.  .#define bfd_link_split_section(abfd, sec) \ .       BFD_SEND (abfd, _bfd_link_split_section, (abfd, sec)) .  */
end_comment

begin_function
name|boolean
name|_bfd_generic_link_split_section
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|sec
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|false
return|;
block|}
end_function

end_unit

