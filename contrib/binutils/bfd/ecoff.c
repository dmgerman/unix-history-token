begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Generic ECOFF (Extended-COFF) routines.    Copyright 1990, 1991, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001, 2002    Free Software Foundation, Inc.    Original version by Per Bothner.    Full support added by Ian Lance Taylor, ian@cygnus.com.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"aout/ar.h"
end_include

begin_include
include|#
directive|include
file|"aout/ranlib.h"
end_include

begin_include
include|#
directive|include
file|"aout/stab_gnu.h"
end_include

begin_comment
comment|/* FIXME: We need the definitions of N_SET[ADTB], but aout64.h defines    some other stuff which we don't want and which conflicts with stuff    we do want.  */
end_comment

begin_include
include|#
directive|include
file|"libaout.h"
end_include

begin_include
include|#
directive|include
file|"aout/aout64.h"
end_include

begin_undef
undef|#
directive|undef
name|N_ABS
end_undef

begin_undef
undef|#
directive|undef
name|exec_hdr
end_undef

begin_undef
undef|#
directive|undef
name|obj_sym_filepos
end_undef

begin_include
include|#
directive|include
file|"coff/internal.h"
end_include

begin_include
include|#
directive|include
file|"coff/sym.h"
end_include

begin_include
include|#
directive|include
file|"coff/symconst.h"
end_include

begin_include
include|#
directive|include
file|"coff/ecoff.h"
end_include

begin_include
include|#
directive|include
file|"libcoff.h"
end_include

begin_include
include|#
directive|include
file|"libecoff.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* Prototypes for static functions.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ecoff_get_magic
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|ecoff_sec_to_styp_flags
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|name
operator|,
name|flagword
name|flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ecoff_slurp_symbolic_header
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ecoff_set_symbol_info
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|SYMR
operator|*
name|ecoff_sym
operator|,
name|asymbol
operator|*
name|asym
operator|,
name|int
name|ext
operator|,
name|int
name|weak
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ecoff_emit_aggregate
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|FDR
operator|*
name|fdr
operator|,
name|char
operator|*
name|string
operator|,
name|RNDXR
operator|*
name|rndx
operator|,
name|long
name|isym
operator|,
specifier|const
name|char
operator|*
name|which
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ecoff_type_to_string
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|FDR
operator|*
name|fdr
operator|,
name|unsigned
name|int
name|indx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ecoff_slurp_reloc_table
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|asection
operator|*
name|section
operator|,
name|asymbol
operator|*
operator|*
name|symbols
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ecoff_sort_hdrs
name|PARAMS
argument_list|(
operator|(
specifier|const
name|PTR
operator|,
specifier|const
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ecoff_compute_section_file_positions
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_size_type
name|ecoff_compute_reloc_file_positions
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ecoff_get_extr
name|PARAMS
argument_list|(
operator|(
name|asymbol
operator|*
operator|,
name|EXTR
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ecoff_set_index
name|PARAMS
argument_list|(
operator|(
name|asymbol
operator|*
operator|,
name|bfd_size_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|ecoff_armap_hash
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|s
operator|,
name|unsigned
name|int
operator|*
name|rehash
operator|,
name|unsigned
name|int
name|size
operator|,
name|unsigned
name|int
name|hlog
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* This stuff is somewhat copied from coffcode.h.  */
end_comment

begin_decl_stmt
specifier|static
name|asection
name|bfd_debug_section
init|=
block|{
comment|/* name,   id,  index, next, flags, user_set_vma, reloc_done,    */
literal|"*DEBUG*"
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* linker_mark, linker_has_input, gc_mark, segment_mark,         */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* vma, lma, _cooked_size, _raw_size,                            */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* output_offset, output_section, alignment_power,               */
literal|0
block|,
name|NULL
block|,
literal|0
block|,
comment|/* relocation, orelocation, reloc_count, filepos, rel_filepos,   */
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* line_filepos, userdata, contents, lineno, lineno_count,       */
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
comment|/* entsize, comdat, moving_line_filepos,                         */
literal|0
block|,
name|NULL
block|,
literal|0
block|,
comment|/* target_index, used_by_bfd, constructor_chain, owner,          */
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
comment|/* symbol,                                                       */
operator|(
expr|struct
name|symbol_cache_entry
operator|*
operator|)
name|NULL
block|,
comment|/* symbol_ptr_ptr,                                               */
operator|(
expr|struct
name|symbol_cache_entry
operator|*
operator|*
operator|)
name|NULL
block|,
comment|/* link_order_head, link_order_tail                              */
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Create an ECOFF object.  */
end_comment

begin_function
name|boolean
name|_bfd_ecoff_mkobject
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
name|ecoff_data_type
argument_list|)
decl_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|ecoff_obj_data
operator|=
operator|(
expr|struct
name|ecoff_tdata
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|tdata
operator|.
name|ecoff_obj_data
operator|==
name|NULL
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* This is a hook called by coff_real_object_p to create any backend    specific information.  */
end_comment

begin_function
name|PTR
name|_bfd_ecoff_mkobject_hook
parameter_list|(
name|abfd
parameter_list|,
name|filehdr
parameter_list|,
name|aouthdr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|filehdr
decl_stmt|;
name|PTR
name|aouthdr
decl_stmt|;
block|{
name|struct
name|internal_filehdr
modifier|*
name|internal_f
init|=
operator|(
expr|struct
name|internal_filehdr
operator|*
operator|)
name|filehdr
decl_stmt|;
name|struct
name|internal_aouthdr
modifier|*
name|internal_a
init|=
operator|(
expr|struct
name|internal_aouthdr
operator|*
operator|)
name|aouthdr
decl_stmt|;
name|ecoff_data_type
modifier|*
name|ecoff
decl_stmt|;
if|if
condition|(
name|_bfd_ecoff_mkobject
argument_list|(
name|abfd
argument_list|)
operator|==
name|false
condition|)
return|return
name|NULL
return|;
name|ecoff
operator|=
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|ecoff
operator|->
name|gp_size
operator|=
literal|8
expr_stmt|;
name|ecoff
operator|->
name|sym_filepos
operator|=
name|internal_f
operator|->
name|f_symptr
expr_stmt|;
if|if
condition|(
name|internal_a
operator|!=
operator|(
expr|struct
name|internal_aouthdr
operator|*
operator|)
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
name|ecoff
operator|->
name|text_start
operator|=
name|internal_a
operator|->
name|text_start
expr_stmt|;
name|ecoff
operator|->
name|text_end
operator|=
name|internal_a
operator|->
name|text_start
operator|+
name|internal_a
operator|->
name|tsize
expr_stmt|;
name|ecoff
operator|->
name|gp
operator|=
name|internal_a
operator|->
name|gp_value
expr_stmt|;
name|ecoff
operator|->
name|gprmask
operator|=
name|internal_a
operator|->
name|gprmask
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|ecoff
operator|->
name|cprmask
index|[
name|i
index|]
operator|=
name|internal_a
operator|->
name|cprmask
index|[
name|i
index|]
expr_stmt|;
name|ecoff
operator|->
name|fprmask
operator|=
name|internal_a
operator|->
name|fprmask
expr_stmt|;
if|if
condition|(
name|internal_a
operator|->
name|magic
operator|==
name|ECOFF_AOUT_ZMAGIC
condition|)
name|abfd
operator|->
name|flags
operator||=
name|D_PAGED
expr_stmt|;
else|else
name|abfd
operator|->
name|flags
operator|&=
operator|~
name|D_PAGED
expr_stmt|;
block|}
comment|/* It turns out that no special action is required by the MIPS or      Alpha ECOFF backends.  They have different information in the      a.out header, but we just copy it all (e.g., gprmask, cprmask and      fprmask) and let the swapping routines ensure that only relevant      information is written out.  */
return|return
operator|(
name|PTR
operator|)
name|ecoff
return|;
block|}
end_function

begin_comment
comment|/* Initialize a new section.  */
end_comment

begin_function
name|boolean
name|_bfd_ecoff_new_section_hook
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
block|{
name|section
operator|->
name|alignment_power
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|section
operator|->
name|name
argument_list|,
name|_TEXT
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|section
operator|->
name|name
argument_list|,
name|_INIT
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|section
operator|->
name|name
argument_list|,
name|_FINI
argument_list|)
operator|==
literal|0
condition|)
name|section
operator|->
name|flags
operator||=
name|SEC_CODE
operator||
name|SEC_LOAD
operator||
name|SEC_ALLOC
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|section
operator|->
name|name
argument_list|,
name|_DATA
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|section
operator|->
name|name
argument_list|,
name|_SDATA
argument_list|)
operator|==
literal|0
condition|)
name|section
operator|->
name|flags
operator||=
name|SEC_DATA
operator||
name|SEC_LOAD
operator||
name|SEC_ALLOC
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|section
operator|->
name|name
argument_list|,
name|_RDATA
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|section
operator|->
name|name
argument_list|,
name|_LIT8
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|section
operator|->
name|name
argument_list|,
name|_LIT4
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|section
operator|->
name|name
argument_list|,
name|_RCONST
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|section
operator|->
name|name
argument_list|,
name|_PDATA
argument_list|)
operator|==
literal|0
condition|)
name|section
operator|->
name|flags
operator||=
name|SEC_DATA
operator||
name|SEC_LOAD
operator||
name|SEC_ALLOC
operator||
name|SEC_READONLY
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|section
operator|->
name|name
argument_list|,
name|_BSS
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|section
operator|->
name|name
argument_list|,
name|_SBSS
argument_list|)
operator|==
literal|0
condition|)
name|section
operator|->
name|flags
operator||=
name|SEC_ALLOC
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|section
operator|->
name|name
argument_list|,
name|_LIB
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* An Irix 4 shared libary.  */
name|section
operator|->
name|flags
operator||=
name|SEC_COFF_SHARED_LIBRARY
expr_stmt|;
block|}
comment|/* Probably any other section name is SEC_NEVER_LOAD, but I'm      uncertain about .init on some systems and I don't know how shared      libraries work.  */
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Determine the machine architecture and type.  This is called from    the generic COFF routines.  It is the inverse of ecoff_get_magic,    below.  This could be an ECOFF backend routine, with one version    for each target, but there aren't all that many ECOFF targets.  */
end_comment

begin_function
name|boolean
name|_bfd_ecoff_set_arch_mach_hook
parameter_list|(
name|abfd
parameter_list|,
name|filehdr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|filehdr
decl_stmt|;
block|{
name|struct
name|internal_filehdr
modifier|*
name|internal_f
init|=
operator|(
expr|struct
name|internal_filehdr
operator|*
operator|)
name|filehdr
decl_stmt|;
name|enum
name|bfd_architecture
name|arch
decl_stmt|;
name|unsigned
name|long
name|mach
decl_stmt|;
switch|switch
condition|(
name|internal_f
operator|->
name|f_magic
condition|)
block|{
case|case
name|MIPS_MAGIC_1
case|:
case|case
name|MIPS_MAGIC_LITTLE
case|:
case|case
name|MIPS_MAGIC_BIG
case|:
name|arch
operator|=
name|bfd_arch_mips
expr_stmt|;
name|mach
operator|=
literal|3000
expr_stmt|;
break|break;
case|case
name|MIPS_MAGIC_LITTLE2
case|:
case|case
name|MIPS_MAGIC_BIG2
case|:
comment|/* MIPS ISA level 2: the r6000 */
name|arch
operator|=
name|bfd_arch_mips
expr_stmt|;
name|mach
operator|=
literal|6000
expr_stmt|;
break|break;
case|case
name|MIPS_MAGIC_LITTLE3
case|:
case|case
name|MIPS_MAGIC_BIG3
case|:
comment|/* MIPS ISA level 3: the r4000 */
name|arch
operator|=
name|bfd_arch_mips
expr_stmt|;
name|mach
operator|=
literal|4000
expr_stmt|;
break|break;
case|case
name|ALPHA_MAGIC
case|:
name|arch
operator|=
name|bfd_arch_alpha
expr_stmt|;
name|mach
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|arch
operator|=
name|bfd_arch_obscure
expr_stmt|;
name|mach
operator|=
literal|0
expr_stmt|;
break|break;
block|}
return|return
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|arch
argument_list|,
name|mach
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Get the magic number to use based on the architecture and machine.    This is the inverse of _bfd_ecoff_set_arch_mach_hook, above.  */
end_comment

begin_function
specifier|static
name|int
name|ecoff_get_magic
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|int
name|big
decl_stmt|,
name|little
decl_stmt|;
switch|switch
condition|(
name|bfd_get_arch
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
case|case
name|bfd_arch_mips
case|:
switch|switch
condition|(
name|bfd_get_mach
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
default|default:
case|case
literal|0
case|:
case|case
literal|3000
case|:
name|big
operator|=
name|MIPS_MAGIC_BIG
expr_stmt|;
name|little
operator|=
name|MIPS_MAGIC_LITTLE
expr_stmt|;
break|break;
case|case
literal|6000
case|:
name|big
operator|=
name|MIPS_MAGIC_BIG2
expr_stmt|;
name|little
operator|=
name|MIPS_MAGIC_LITTLE2
expr_stmt|;
break|break;
case|case
literal|4000
case|:
name|big
operator|=
name|MIPS_MAGIC_BIG3
expr_stmt|;
name|little
operator|=
name|MIPS_MAGIC_LITTLE3
expr_stmt|;
break|break;
block|}
return|return
name|bfd_big_endian
argument_list|(
name|abfd
argument_list|)
condition|?
name|big
else|:
name|little
return|;
case|case
name|bfd_arch_alpha
case|:
return|return
name|ALPHA_MAGIC
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Get the section s_flags to use for a section.  */
end_comment

begin_function
specifier|static
name|long
name|ecoff_sec_to_styp_flags
parameter_list|(
name|name
parameter_list|,
name|flags
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
block|{
name|long
name|styp
decl_stmt|;
name|styp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|_TEXT
argument_list|)
operator|==
literal|0
condition|)
name|styp
operator|=
name|STYP_TEXT
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|_DATA
argument_list|)
operator|==
literal|0
condition|)
name|styp
operator|=
name|STYP_DATA
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|_SDATA
argument_list|)
operator|==
literal|0
condition|)
name|styp
operator|=
name|STYP_SDATA
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|_RDATA
argument_list|)
operator|==
literal|0
condition|)
name|styp
operator|=
name|STYP_RDATA
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|_LITA
argument_list|)
operator|==
literal|0
condition|)
name|styp
operator|=
name|STYP_LITA
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|_LIT8
argument_list|)
operator|==
literal|0
condition|)
name|styp
operator|=
name|STYP_LIT8
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|_LIT4
argument_list|)
operator|==
literal|0
condition|)
name|styp
operator|=
name|STYP_LIT4
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|_BSS
argument_list|)
operator|==
literal|0
condition|)
name|styp
operator|=
name|STYP_BSS
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|_SBSS
argument_list|)
operator|==
literal|0
condition|)
name|styp
operator|=
name|STYP_SBSS
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|_INIT
argument_list|)
operator|==
literal|0
condition|)
name|styp
operator|=
name|STYP_ECOFF_INIT
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|_FINI
argument_list|)
operator|==
literal|0
condition|)
name|styp
operator|=
name|STYP_ECOFF_FINI
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|_PDATA
argument_list|)
operator|==
literal|0
condition|)
name|styp
operator|=
name|STYP_PDATA
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|_XDATA
argument_list|)
operator|==
literal|0
condition|)
name|styp
operator|=
name|STYP_XDATA
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|_LIB
argument_list|)
operator|==
literal|0
condition|)
name|styp
operator|=
name|STYP_ECOFF_LIB
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|_GOT
argument_list|)
operator|==
literal|0
condition|)
name|styp
operator|=
name|STYP_GOT
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|_HASH
argument_list|)
operator|==
literal|0
condition|)
name|styp
operator|=
name|STYP_HASH
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|_DYNAMIC
argument_list|)
operator|==
literal|0
condition|)
name|styp
operator|=
name|STYP_DYNAMIC
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|_LIBLIST
argument_list|)
operator|==
literal|0
condition|)
name|styp
operator|=
name|STYP_LIBLIST
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|_RELDYN
argument_list|)
operator|==
literal|0
condition|)
name|styp
operator|=
name|STYP_RELDYN
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|_CONFLIC
argument_list|)
operator|==
literal|0
condition|)
name|styp
operator|=
name|STYP_CONFLIC
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|_DYNSTR
argument_list|)
operator|==
literal|0
condition|)
name|styp
operator|=
name|STYP_DYNSTR
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|_DYNSYM
argument_list|)
operator|==
literal|0
condition|)
name|styp
operator|=
name|STYP_DYNSYM
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|_COMMENT
argument_list|)
operator|==
literal|0
condition|)
block|{
name|styp
operator|=
name|STYP_COMMENT
expr_stmt|;
name|flags
operator|&=
operator|~
name|SEC_NEVER_LOAD
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|_RCONST
argument_list|)
operator|==
literal|0
condition|)
name|styp
operator|=
name|STYP_RCONST
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|SEC_CODE
condition|)
name|styp
operator|=
name|STYP_TEXT
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|SEC_DATA
condition|)
name|styp
operator|=
name|STYP_DATA
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|SEC_READONLY
condition|)
name|styp
operator|=
name|STYP_RDATA
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|SEC_LOAD
condition|)
name|styp
operator|=
name|STYP_REG
expr_stmt|;
else|else
name|styp
operator|=
name|STYP_BSS
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SEC_NEVER_LOAD
condition|)
name|styp
operator||=
name|STYP_NOLOAD
expr_stmt|;
return|return
name|styp
return|;
block|}
end_function

begin_comment
comment|/* Get the BFD flags to use for a section.  */
end_comment

begin_function
name|boolean
name|_bfd_ecoff_styp_to_sec_flags
parameter_list|(
name|abfd
parameter_list|,
name|hdr
parameter_list|,
name|name
parameter_list|,
name|section
parameter_list|,
name|flags_ptr
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|PTR
name|hdr
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|section
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|flagword
modifier|*
name|flags_ptr
decl_stmt|;
block|{
name|struct
name|internal_scnhdr
modifier|*
name|internal_s
init|=
operator|(
expr|struct
name|internal_scnhdr
operator|*
operator|)
name|hdr
decl_stmt|;
name|long
name|styp_flags
init|=
name|internal_s
operator|->
name|s_flags
decl_stmt|;
name|flagword
name|sec_flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|styp_flags
operator|&
name|STYP_NOLOAD
condition|)
name|sec_flags
operator||=
name|SEC_NEVER_LOAD
expr_stmt|;
comment|/* For 386 COFF, at least, an unloadable text or data section is      actually a shared library section.  */
if|if
condition|(
operator|(
name|styp_flags
operator|&
name|STYP_TEXT
operator|)
operator|||
operator|(
name|styp_flags
operator|&
name|STYP_ECOFF_INIT
operator|)
operator|||
operator|(
name|styp_flags
operator|&
name|STYP_ECOFF_FINI
operator|)
operator|||
operator|(
name|styp_flags
operator|&
name|STYP_DYNAMIC
operator|)
operator|||
operator|(
name|styp_flags
operator|&
name|STYP_LIBLIST
operator|)
operator|||
operator|(
name|styp_flags
operator|&
name|STYP_RELDYN
operator|)
operator|||
name|styp_flags
operator|==
name|STYP_CONFLIC
operator|||
operator|(
name|styp_flags
operator|&
name|STYP_DYNSTR
operator|)
operator|||
operator|(
name|styp_flags
operator|&
name|STYP_DYNSYM
operator|)
operator|||
operator|(
name|styp_flags
operator|&
name|STYP_HASH
operator|)
condition|)
block|{
if|if
condition|(
name|sec_flags
operator|&
name|SEC_NEVER_LOAD
condition|)
name|sec_flags
operator||=
name|SEC_CODE
operator||
name|SEC_COFF_SHARED_LIBRARY
expr_stmt|;
else|else
name|sec_flags
operator||=
name|SEC_CODE
operator||
name|SEC_LOAD
operator||
name|SEC_ALLOC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|styp_flags
operator|&
name|STYP_DATA
operator|)
operator|||
operator|(
name|styp_flags
operator|&
name|STYP_RDATA
operator|)
operator|||
operator|(
name|styp_flags
operator|&
name|STYP_SDATA
operator|)
operator|||
name|styp_flags
operator|==
name|STYP_PDATA
operator|||
name|styp_flags
operator|==
name|STYP_XDATA
operator|||
operator|(
name|styp_flags
operator|&
name|STYP_GOT
operator|)
operator|||
name|styp_flags
operator|==
name|STYP_RCONST
condition|)
block|{
if|if
condition|(
name|sec_flags
operator|&
name|SEC_NEVER_LOAD
condition|)
name|sec_flags
operator||=
name|SEC_DATA
operator||
name|SEC_COFF_SHARED_LIBRARY
expr_stmt|;
else|else
name|sec_flags
operator||=
name|SEC_DATA
operator||
name|SEC_LOAD
operator||
name|SEC_ALLOC
expr_stmt|;
if|if
condition|(
operator|(
name|styp_flags
operator|&
name|STYP_RDATA
operator|)
operator|||
name|styp_flags
operator|==
name|STYP_PDATA
operator|||
name|styp_flags
operator|==
name|STYP_RCONST
condition|)
name|sec_flags
operator||=
name|SEC_READONLY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|styp_flags
operator|&
name|STYP_BSS
operator|)
operator|||
operator|(
name|styp_flags
operator|&
name|STYP_SBSS
operator|)
condition|)
name|sec_flags
operator||=
name|SEC_ALLOC
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|styp_flags
operator|&
name|STYP_INFO
operator|)
operator|||
name|styp_flags
operator|==
name|STYP_COMMENT
condition|)
name|sec_flags
operator||=
name|SEC_NEVER_LOAD
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|styp_flags
operator|&
name|STYP_LITA
operator|)
operator|||
operator|(
name|styp_flags
operator|&
name|STYP_LIT8
operator|)
operator|||
operator|(
name|styp_flags
operator|&
name|STYP_LIT4
operator|)
condition|)
name|sec_flags
operator||=
name|SEC_DATA
operator||
name|SEC_LOAD
operator||
name|SEC_ALLOC
operator||
name|SEC_READONLY
expr_stmt|;
elseif|else
if|if
condition|(
name|styp_flags
operator|&
name|STYP_ECOFF_LIB
condition|)
name|sec_flags
operator||=
name|SEC_COFF_SHARED_LIBRARY
expr_stmt|;
else|else
name|sec_flags
operator||=
name|SEC_ALLOC
operator||
name|SEC_LOAD
expr_stmt|;
operator|*
name|flags_ptr
operator|=
name|sec_flags
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read in the symbolic header for an ECOFF object file.  */
end_comment

begin_function
specifier|static
name|boolean
name|ecoff_slurp_symbolic_header
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
specifier|const
name|struct
name|ecoff_backend_data
modifier|*
specifier|const
name|backend
init|=
name|ecoff_backend
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|bfd_size_type
name|external_hdr_size
decl_stmt|;
name|PTR
name|raw
init|=
name|NULL
decl_stmt|;
name|HDRR
modifier|*
name|internal_symhdr
decl_stmt|;
comment|/* See if we've already read it in.  */
if|if
condition|(
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|debug_info
operator|.
name|symbolic_header
operator|.
name|magic
operator|==
name|backend
operator|->
name|debug_swap
operator|.
name|sym_magic
condition|)
return|return
name|true
return|;
comment|/* See whether there is a symbolic header.  */
if|if
condition|(
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|sym_filepos
operator|==
literal|0
condition|)
block|{
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* At this point bfd_get_symcount (abfd) holds the number of symbols      as read from the file header, but on ECOFF this is always the      size of the symbolic information header.  It would be cleaner to      handle this when we first read the file in coffgen.c.  */
name|external_hdr_size
operator|=
name|backend
operator|->
name|debug_swap
operator|.
name|external_hdr_size
expr_stmt|;
if|if
condition|(
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|!=
name|external_hdr_size
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Read the symbolic information header.  */
name|raw
operator|=
operator|(
name|PTR
operator|)
name|bfd_malloc
argument_list|(
name|external_hdr_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|raw
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|sym_filepos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bread
argument_list|(
name|raw
argument_list|,
name|external_hdr_size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|external_hdr_size
condition|)
goto|goto
name|error_return
goto|;
name|internal_symhdr
operator|=
operator|&
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|debug_info
operator|.
name|symbolic_header
expr_stmt|;
call|(
modifier|*
name|backend
operator|->
name|debug_swap
operator|.
name|swap_hdr_in
call|)
argument_list|(
name|abfd
argument_list|,
name|raw
argument_list|,
name|internal_symhdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_symhdr
operator|->
name|magic
operator|!=
name|backend
operator|->
name|debug_swap
operator|.
name|sym_magic
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
comment|/* Now we can get the correct number of symbols.  */
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
name|internal_symhdr
operator|->
name|isymMax
operator|+
name|internal_symhdr
operator|->
name|iextMax
operator|)
expr_stmt|;
if|if
condition|(
name|raw
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|raw
argument_list|)
expr_stmt|;
return|return
name|true
return|;
name|error_return
label|:
if|if
condition|(
name|raw
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|raw
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Read in and swap the important symbolic information for an ECOFF    object file.  This is called by gdb via the read_debug_info entry    point in the backend structure.  */
end_comment

begin_function
name|boolean
name|_bfd_ecoff_slurp_symbolic_info
parameter_list|(
name|abfd
parameter_list|,
name|ignore
parameter_list|,
name|debug
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|ecoff_debug_info
modifier|*
name|debug
decl_stmt|;
block|{
specifier|const
name|struct
name|ecoff_backend_data
modifier|*
specifier|const
name|backend
init|=
name|ecoff_backend
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|HDRR
modifier|*
name|internal_symhdr
decl_stmt|;
name|bfd_size_type
name|raw_base
decl_stmt|;
name|bfd_size_type
name|raw_size
decl_stmt|;
name|PTR
name|raw
decl_stmt|;
name|bfd_size_type
name|external_fdr_size
decl_stmt|;
name|char
modifier|*
name|fraw_src
decl_stmt|;
name|char
modifier|*
name|fraw_end
decl_stmt|;
name|struct
name|fdr
modifier|*
name|fdr_ptr
decl_stmt|;
name|bfd_size_type
name|raw_end
decl_stmt|;
name|bfd_size_type
name|cb_end
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|file_ptr
name|pos
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|debug
operator|==
operator|&
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|debug_info
argument_list|)
expr_stmt|;
comment|/* Check whether we've already gotten it, and whether there's any to      get.  */
if|if
condition|(
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|raw_syments
operator|!=
operator|(
name|PTR
operator|)
name|NULL
condition|)
return|return
name|true
return|;
if|if
condition|(
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|sym_filepos
operator|==
literal|0
condition|)
block|{
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
operator|!
name|ecoff_slurp_symbolic_header
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
name|internal_symhdr
operator|=
operator|&
name|debug
operator|->
name|symbolic_header
expr_stmt|;
comment|/* Read all the symbolic information at once.  */
name|raw_base
operator|=
operator|(
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|sym_filepos
operator|+
name|backend
operator|->
name|debug_swap
operator|.
name|external_hdr_size
operator|)
expr_stmt|;
comment|/* Alpha ecoff makes the determination of raw_size difficult. It has      an undocumented debug data section between the symhdr and the first      documented section. And the ordering of the sections varies between      statically and dynamically linked executables.      If bfd supports SEEK_END someday, this code could be simplified.  */
name|raw_end
operator|=
literal|0
expr_stmt|;
define|#
directive|define
name|UPDATE_RAW_END
parameter_list|(
name|start
parameter_list|,
name|count
parameter_list|,
name|size
parameter_list|)
define|\
value|cb_end = internal_symhdr->start + internal_symhdr->count * (size); \   if (cb_end> raw_end) \     raw_end = cb_end
name|UPDATE_RAW_END
argument_list|(
name|cbLineOffset
argument_list|,
name|cbLine
argument_list|,
expr|sizeof
operator|(
name|unsigned
name|char
operator|)
argument_list|)
expr_stmt|;
name|UPDATE_RAW_END
argument_list|(
name|cbDnOffset
argument_list|,
name|idnMax
argument_list|,
name|backend
operator|->
name|debug_swap
operator|.
name|external_dnr_size
argument_list|)
expr_stmt|;
name|UPDATE_RAW_END
argument_list|(
name|cbPdOffset
argument_list|,
name|ipdMax
argument_list|,
name|backend
operator|->
name|debug_swap
operator|.
name|external_pdr_size
argument_list|)
expr_stmt|;
name|UPDATE_RAW_END
argument_list|(
name|cbSymOffset
argument_list|,
name|isymMax
argument_list|,
name|backend
operator|->
name|debug_swap
operator|.
name|external_sym_size
argument_list|)
expr_stmt|;
name|UPDATE_RAW_END
argument_list|(
name|cbOptOffset
argument_list|,
name|ioptMax
argument_list|,
name|backend
operator|->
name|debug_swap
operator|.
name|external_opt_size
argument_list|)
expr_stmt|;
name|UPDATE_RAW_END
argument_list|(
name|cbAuxOffset
argument_list|,
name|iauxMax
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|aux_ext
argument_list|)
argument_list|)
expr_stmt|;
name|UPDATE_RAW_END
argument_list|(
name|cbSsOffset
argument_list|,
name|issMax
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|UPDATE_RAW_END
argument_list|(
name|cbSsExtOffset
argument_list|,
name|issExtMax
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|UPDATE_RAW_END
argument_list|(
name|cbFdOffset
argument_list|,
name|ifdMax
argument_list|,
name|backend
operator|->
name|debug_swap
operator|.
name|external_fdr_size
argument_list|)
expr_stmt|;
name|UPDATE_RAW_END
argument_list|(
name|cbRfdOffset
argument_list|,
name|crfd
argument_list|,
name|backend
operator|->
name|debug_swap
operator|.
name|external_rfd_size
argument_list|)
expr_stmt|;
name|UPDATE_RAW_END
argument_list|(
name|cbExtOffset
argument_list|,
name|iextMax
argument_list|,
name|backend
operator|->
name|debug_swap
operator|.
name|external_ext_size
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|UPDATE_RAW_END
name|raw_size
operator|=
name|raw_end
operator|-
name|raw_base
expr_stmt|;
if|if
condition|(
name|raw_size
operator|==
literal|0
condition|)
block|{
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|sym_filepos
operator|=
literal|0
expr_stmt|;
return|return
name|true
return|;
block|}
name|raw
operator|=
operator|(
name|PTR
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|raw
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|pos
operator|=
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|sym_filepos
expr_stmt|;
name|pos
operator|+=
name|backend
operator|->
name|debug_swap
operator|.
name|external_hdr_size
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|pos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bread
argument_list|(
name|raw
argument_list|,
name|raw_size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|raw_size
condition|)
block|{
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|raw
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|raw_syments
operator|=
name|raw
expr_stmt|;
comment|/* Get pointers for the numeric offsets in the HDRR structure.  */
define|#
directive|define
name|FIX
parameter_list|(
name|off1
parameter_list|,
name|off2
parameter_list|,
name|type
parameter_list|)
define|\
value|if (internal_symhdr->off1 == 0) \     debug->off2 = (type) NULL; \   else \     debug->off2 = (type) ((char *) raw \ 			  + (internal_symhdr->off1 \ 			     - raw_base))
name|FIX
argument_list|(
argument|cbLineOffset
argument_list|,
argument|line
argument_list|,
argument|unsigned char *
argument_list|)
empty_stmt|;
name|FIX
argument_list|(
name|cbDnOffset
argument_list|,
name|external_dnr
argument_list|,
name|PTR
argument_list|)
expr_stmt|;
name|FIX
argument_list|(
name|cbPdOffset
argument_list|,
name|external_pdr
argument_list|,
name|PTR
argument_list|)
expr_stmt|;
name|FIX
argument_list|(
name|cbSymOffset
argument_list|,
name|external_sym
argument_list|,
name|PTR
argument_list|)
expr_stmt|;
name|FIX
argument_list|(
name|cbOptOffset
argument_list|,
name|external_opt
argument_list|,
name|PTR
argument_list|)
expr_stmt|;
name|FIX
argument_list|(
name|cbAuxOffset
argument_list|,
name|external_aux
argument_list|,
expr|union
name|aux_ext
operator|*
argument_list|)
expr_stmt|;
name|FIX
argument_list|(
name|cbSsOffset
argument_list|,
name|ss
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|FIX
argument_list|(
name|cbSsExtOffset
argument_list|,
name|ssext
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|FIX
argument_list|(
name|cbFdOffset
argument_list|,
name|external_fdr
argument_list|,
name|PTR
argument_list|)
expr_stmt|;
name|FIX
argument_list|(
name|cbRfdOffset
argument_list|,
name|external_rfd
argument_list|,
name|PTR
argument_list|)
expr_stmt|;
name|FIX
argument_list|(
name|cbExtOffset
argument_list|,
name|external_ext
argument_list|,
name|PTR
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|FIX
comment|/* I don't want to always swap all the data, because it will just      waste time and most programs will never look at it.  The only      time the linker needs most of the debugging information swapped      is when linking big-endian and little-endian MIPS object files      together, which is not a common occurrence.       We need to look at the fdr to deal with a lot of information in      the symbols, so we swap them here.  */
name|amt
operator|=
name|internal_symhdr
operator|->
name|ifdMax
expr_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
expr|struct
name|fdr
argument_list|)
expr_stmt|;
name|debug
operator|->
name|fdr
operator|=
operator|(
expr|struct
name|fdr
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|fdr
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|external_fdr_size
operator|=
name|backend
operator|->
name|debug_swap
operator|.
name|external_fdr_size
expr_stmt|;
name|fdr_ptr
operator|=
name|debug
operator|->
name|fdr
expr_stmt|;
name|fraw_src
operator|=
operator|(
name|char
operator|*
operator|)
name|debug
operator|->
name|external_fdr
expr_stmt|;
name|fraw_end
operator|=
name|fraw_src
operator|+
name|internal_symhdr
operator|->
name|ifdMax
operator|*
name|external_fdr_size
expr_stmt|;
for|for
control|(
init|;
name|fraw_src
operator|<
name|fraw_end
condition|;
name|fraw_src
operator|+=
name|external_fdr_size
operator|,
name|fdr_ptr
operator|++
control|)
call|(
modifier|*
name|backend
operator|->
name|debug_swap
operator|.
name|swap_fdr_in
call|)
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|fraw_src
argument_list|,
name|fdr_ptr
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ECOFF symbol table routines.  The ECOFF symbol table is described    in gcc/mips-tfile.c.  */
end_comment

begin_comment
comment|/* ECOFF uses two common sections.  One is the usual one, and the    other is for small objects.  All the small objects are kept    together, and then referenced via the gp pointer, which yields    faster assembler code.  This is what we use for the small common    section.  */
end_comment

begin_decl_stmt
specifier|static
name|asection
name|ecoff_scom_section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asymbol
name|ecoff_scom_symbol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asymbol
modifier|*
name|ecoff_scom_symbol_ptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Create an empty symbol.  */
end_comment

begin_function
name|asymbol
modifier|*
name|_bfd_ecoff_make_empty_symbol
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|ecoff_symbol_type
modifier|*
name|new
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
name|ecoff_symbol_type
argument_list|)
decl_stmt|;
name|new
operator|=
operator|(
name|ecoff_symbol_type
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|==
operator|(
name|ecoff_symbol_type
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|asymbol
operator|*
operator|)
name|NULL
return|;
name|memset
argument_list|(
operator|(
name|PTR
operator|)
name|new
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|new
argument_list|)
expr_stmt|;
name|new
operator|->
name|symbol
operator|.
name|section
operator|=
operator|(
name|asection
operator|*
operator|)
name|NULL
expr_stmt|;
name|new
operator|->
name|fdr
operator|=
operator|(
name|FDR
operator|*
operator|)
name|NULL
expr_stmt|;
name|new
operator|->
name|local
operator|=
name|false
expr_stmt|;
name|new
operator|->
name|native
operator|=
name|NULL
expr_stmt|;
name|new
operator|->
name|symbol
operator|.
name|the_bfd
operator|=
name|abfd
expr_stmt|;
return|return
operator|&
name|new
operator|->
name|symbol
return|;
block|}
end_function

begin_comment
comment|/* Set the BFD flags and section for an ECOFF symbol.  */
end_comment

begin_function
specifier|static
name|boolean
name|ecoff_set_symbol_info
parameter_list|(
name|abfd
parameter_list|,
name|ecoff_sym
parameter_list|,
name|asym
parameter_list|,
name|ext
parameter_list|,
name|weak
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|SYMR
modifier|*
name|ecoff_sym
decl_stmt|;
name|asymbol
modifier|*
name|asym
decl_stmt|;
name|int
name|ext
decl_stmt|;
name|int
name|weak
decl_stmt|;
block|{
name|asym
operator|->
name|the_bfd
operator|=
name|abfd
expr_stmt|;
name|asym
operator|->
name|value
operator|=
name|ecoff_sym
operator|->
name|value
expr_stmt|;
name|asym
operator|->
name|section
operator|=
operator|&
name|bfd_debug_section
expr_stmt|;
name|asym
operator|->
name|udata
operator|.
name|i
operator|=
literal|0
expr_stmt|;
comment|/* Most symbol types are just for debugging.  */
switch|switch
condition|(
name|ecoff_sym
operator|->
name|st
condition|)
block|{
case|case
name|stGlobal
case|:
case|case
name|stStatic
case|:
case|case
name|stLabel
case|:
case|case
name|stProc
case|:
case|case
name|stStaticProc
case|:
break|break;
case|case
name|stNil
case|:
if|if
condition|(
name|ECOFF_IS_STAB
argument_list|(
name|ecoff_sym
argument_list|)
condition|)
block|{
name|asym
operator|->
name|flags
operator|=
name|BSF_DEBUGGING
expr_stmt|;
return|return
name|true
return|;
block|}
break|break;
default|default:
name|asym
operator|->
name|flags
operator|=
name|BSF_DEBUGGING
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|weak
condition|)
name|asym
operator|->
name|flags
operator|=
name|BSF_EXPORT
operator||
name|BSF_WEAK
expr_stmt|;
elseif|else
if|if
condition|(
name|ext
condition|)
name|asym
operator|->
name|flags
operator|=
name|BSF_EXPORT
operator||
name|BSF_GLOBAL
expr_stmt|;
else|else
block|{
name|asym
operator|->
name|flags
operator|=
name|BSF_LOCAL
expr_stmt|;
comment|/* Normally, a local stProc symbol will have a corresponding          external symbol.  We mark the local symbol as a debugging          symbol, in order to prevent nm from printing both out.          Similarly, we mark stLabel and stabs symbols as debugging          symbols.  In both cases, we do want to set the value          correctly based on the symbol class.  */
if|if
condition|(
name|ecoff_sym
operator|->
name|st
operator|==
name|stProc
operator|||
name|ecoff_sym
operator|->
name|st
operator|==
name|stLabel
operator|||
name|ECOFF_IS_STAB
argument_list|(
name|ecoff_sym
argument_list|)
condition|)
name|asym
operator|->
name|flags
operator||=
name|BSF_DEBUGGING
expr_stmt|;
block|}
switch|switch
condition|(
name|ecoff_sym
operator|->
name|sc
condition|)
block|{
case|case
name|scNil
case|:
comment|/* Used for compiler generated labels.  Leave them in the 	 debugging section, and mark them as local.  If BSF_DEBUGGING 	 is set, then nm does not display them for some reason.  If no 	 flags are set then the linker whines about them.  */
name|asym
operator|->
name|flags
operator|=
name|BSF_LOCAL
expr_stmt|;
break|break;
case|case
name|scText
case|:
name|asym
operator|->
name|section
operator|=
name|bfd_make_section_old_way
argument_list|(
name|abfd
argument_list|,
literal|".text"
argument_list|)
expr_stmt|;
name|asym
operator|->
name|value
operator|-=
name|asym
operator|->
name|section
operator|->
name|vma
expr_stmt|;
break|break;
case|case
name|scData
case|:
name|asym
operator|->
name|section
operator|=
name|bfd_make_section_old_way
argument_list|(
name|abfd
argument_list|,
literal|".data"
argument_list|)
expr_stmt|;
name|asym
operator|->
name|value
operator|-=
name|asym
operator|->
name|section
operator|->
name|vma
expr_stmt|;
break|break;
case|case
name|scBss
case|:
name|asym
operator|->
name|section
operator|=
name|bfd_make_section_old_way
argument_list|(
name|abfd
argument_list|,
literal|".bss"
argument_list|)
expr_stmt|;
name|asym
operator|->
name|value
operator|-=
name|asym
operator|->
name|section
operator|->
name|vma
expr_stmt|;
break|break;
case|case
name|scRegister
case|:
name|asym
operator|->
name|flags
operator|=
name|BSF_DEBUGGING
expr_stmt|;
break|break;
case|case
name|scAbs
case|:
name|asym
operator|->
name|section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
break|break;
case|case
name|scUndefined
case|:
name|asym
operator|->
name|section
operator|=
name|bfd_und_section_ptr
expr_stmt|;
name|asym
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|asym
operator|->
name|value
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|scCdbLocal
case|:
case|case
name|scBits
case|:
case|case
name|scCdbSystem
case|:
case|case
name|scRegImage
case|:
case|case
name|scInfo
case|:
case|case
name|scUserStruct
case|:
name|asym
operator|->
name|flags
operator|=
name|BSF_DEBUGGING
expr_stmt|;
break|break;
case|case
name|scSData
case|:
name|asym
operator|->
name|section
operator|=
name|bfd_make_section_old_way
argument_list|(
name|abfd
argument_list|,
literal|".sdata"
argument_list|)
expr_stmt|;
name|asym
operator|->
name|value
operator|-=
name|asym
operator|->
name|section
operator|->
name|vma
expr_stmt|;
break|break;
case|case
name|scSBss
case|:
name|asym
operator|->
name|section
operator|=
name|bfd_make_section_old_way
argument_list|(
name|abfd
argument_list|,
literal|".sbss"
argument_list|)
expr_stmt|;
name|asym
operator|->
name|value
operator|-=
name|asym
operator|->
name|section
operator|->
name|vma
expr_stmt|;
break|break;
case|case
name|scRData
case|:
name|asym
operator|->
name|section
operator|=
name|bfd_make_section_old_way
argument_list|(
name|abfd
argument_list|,
literal|".rdata"
argument_list|)
expr_stmt|;
name|asym
operator|->
name|value
operator|-=
name|asym
operator|->
name|section
operator|->
name|vma
expr_stmt|;
break|break;
case|case
name|scVar
case|:
name|asym
operator|->
name|flags
operator|=
name|BSF_DEBUGGING
expr_stmt|;
break|break;
case|case
name|scCommon
case|:
if|if
condition|(
name|asym
operator|->
name|value
operator|>
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|gp_size
condition|)
block|{
name|asym
operator|->
name|section
operator|=
name|bfd_com_section_ptr
expr_stmt|;
name|asym
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* Fall through.  */
case|case
name|scSCommon
case|:
if|if
condition|(
name|ecoff_scom_section
operator|.
name|name
operator|==
name|NULL
condition|)
block|{
comment|/* Initialize the small common section.  */
name|ecoff_scom_section
operator|.
name|name
operator|=
name|SCOMMON
expr_stmt|;
name|ecoff_scom_section
operator|.
name|flags
operator|=
name|SEC_IS_COMMON
expr_stmt|;
name|ecoff_scom_section
operator|.
name|output_section
operator|=
operator|&
name|ecoff_scom_section
expr_stmt|;
name|ecoff_scom_section
operator|.
name|symbol
operator|=
operator|&
name|ecoff_scom_symbol
expr_stmt|;
name|ecoff_scom_section
operator|.
name|symbol_ptr_ptr
operator|=
operator|&
name|ecoff_scom_symbol_ptr
expr_stmt|;
name|ecoff_scom_symbol
operator|.
name|name
operator|=
name|SCOMMON
expr_stmt|;
name|ecoff_scom_symbol
operator|.
name|flags
operator|=
name|BSF_SECTION_SYM
expr_stmt|;
name|ecoff_scom_symbol
operator|.
name|section
operator|=
operator|&
name|ecoff_scom_section
expr_stmt|;
name|ecoff_scom_symbol_ptr
operator|=
operator|&
name|ecoff_scom_symbol
expr_stmt|;
block|}
name|asym
operator|->
name|section
operator|=
operator|&
name|ecoff_scom_section
expr_stmt|;
name|asym
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|scVarRegister
case|:
case|case
name|scVariant
case|:
name|asym
operator|->
name|flags
operator|=
name|BSF_DEBUGGING
expr_stmt|;
break|break;
case|case
name|scSUndefined
case|:
name|asym
operator|->
name|section
operator|=
name|bfd_und_section_ptr
expr_stmt|;
name|asym
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|asym
operator|->
name|value
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|scInit
case|:
name|asym
operator|->
name|section
operator|=
name|bfd_make_section_old_way
argument_list|(
name|abfd
argument_list|,
literal|".init"
argument_list|)
expr_stmt|;
name|asym
operator|->
name|value
operator|-=
name|asym
operator|->
name|section
operator|->
name|vma
expr_stmt|;
break|break;
case|case
name|scBasedVar
case|:
case|case
name|scXData
case|:
case|case
name|scPData
case|:
name|asym
operator|->
name|flags
operator|=
name|BSF_DEBUGGING
expr_stmt|;
break|break;
case|case
name|scFini
case|:
name|asym
operator|->
name|section
operator|=
name|bfd_make_section_old_way
argument_list|(
name|abfd
argument_list|,
literal|".fini"
argument_list|)
expr_stmt|;
name|asym
operator|->
name|value
operator|-=
name|asym
operator|->
name|section
operator|->
name|vma
expr_stmt|;
break|break;
case|case
name|scRConst
case|:
name|asym
operator|->
name|section
operator|=
name|bfd_make_section_old_way
argument_list|(
name|abfd
argument_list|,
literal|".rconst"
argument_list|)
expr_stmt|;
name|asym
operator|->
name|value
operator|-=
name|asym
operator|->
name|section
operator|->
name|vma
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* Look for special constructors symbols and make relocation entries      in a special construction section.  These are produced by the      -fgnu-linker argument to g++.  */
if|if
condition|(
name|ECOFF_IS_STAB
argument_list|(
name|ecoff_sym
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|ECOFF_UNMARK_STAB
argument_list|(
name|ecoff_sym
operator|->
name|index
argument_list|)
condition|)
block|{
default|default:
break|break;
case|case
name|N_SETA
case|:
case|case
name|N_SETT
case|:
case|case
name|N_SETD
case|:
case|case
name|N_SETB
case|:
block|{
comment|/* This code is no longer needed.  It used to be used to 	       make the linker handle set symbols, but they are now 	       handled in the add_symbols routine instead.  */
if|#
directive|if
literal|0
block|const char *name; 	    asection *section; 	    arelent_chain *reloc_chain; 	    unsigned int bitsize; 	    bfd_size_type amt;
comment|/* Get a section with the same name as the symbol (usually 	       __CTOR_LIST__ or __DTOR_LIST__).  FIXME: gcc uses the 	       name ___CTOR_LIST (three underscores).  We need 	       __CTOR_LIST (two underscores), since ECOFF doesn't use 	       a leading underscore.  This should be handled by gcc, 	       but instead we do it here.  Actually, this should all 	       be done differently anyhow.  */
block|name = bfd_asymbol_name (asym); 	    if (name[0] == '_'&& name[1] == '_'&& name[2] == '_') 	      { 		++name; 		asym->name = name; 	      } 	    section = bfd_get_section_by_name (abfd, name); 	    if (section == (asection *) NULL) 	      { 		char *copy;  		amt = strlen (name) + 1; 		copy = (char *) bfd_alloc (abfd, amt); 		if (!copy) 		  return false; 		strcpy (copy, name); 		section = bfd_make_section (abfd, copy); 	      }
comment|/* Build a reloc pointing to this constructor.  */
block|amt = sizeof (arelent_chain); 	    reloc_chain = (arelent_chain *) bfd_alloc (abfd, amt); 	    if (!reloc_chain) 	      return false; 	    reloc_chain->relent.sym_ptr_ptr = 	      bfd_get_section (asym)->symbol_ptr_ptr; 	    reloc_chain->relent.address = section->_raw_size; 	    reloc_chain->relent.addend = asym->value; 	    reloc_chain->relent.howto = 	      ecoff_backend (abfd)->constructor_reloc;
comment|/* Set up the constructor section to hold the reloc.  */
block|section->flags = SEC_CONSTRUCTOR; 	    ++section->reloc_count;
comment|/* Constructor sections must be rounded to a boundary 	       based on the bitsize.  These are not real sections-- 	       they are handled specially by the linker--so the ECOFF 	       16 byte alignment restriction does not apply.  */
block|bitsize = ecoff_backend (abfd)->constructor_bitsize; 	    section->alignment_power = 1; 	    while ((1<< section->alignment_power)< bitsize / 8) 	      ++section->alignment_power;  	    reloc_chain->next = section->constructor_chain; 	    section->constructor_chain = reloc_chain; 	    section->_raw_size += bitsize / 8;
endif|#
directive|endif
comment|/* 0 */
comment|/* Mark the symbol as a constructor.  */
name|asym
operator|->
name|flags
operator||=
name|BSF_CONSTRUCTOR
expr_stmt|;
block|}
break|break;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Read an ECOFF symbol table.  */
end_comment

begin_function
name|boolean
name|_bfd_ecoff_slurp_symbol_table
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
specifier|const
name|struct
name|ecoff_backend_data
modifier|*
specifier|const
name|backend
init|=
name|ecoff_backend
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
specifier|const
name|bfd_size_type
name|external_ext_size
init|=
name|backend
operator|->
name|debug_swap
operator|.
name|external_ext_size
decl_stmt|;
specifier|const
name|bfd_size_type
name|external_sym_size
init|=
name|backend
operator|->
name|debug_swap
operator|.
name|external_sym_size
decl_stmt|;
name|void
argument_list|(
argument|* const swap_ext_in
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|EXTR
operator|*
operator|)
argument_list|)
operator|=
name|backend
operator|->
name|debug_swap
operator|.
name|swap_ext_in
expr_stmt|;
name|void
argument_list|(
argument|* const swap_sym_in
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|SYMR
operator|*
operator|)
argument_list|)
operator|=
name|backend
operator|->
name|debug_swap
operator|.
name|swap_sym_in
expr_stmt|;
name|bfd_size_type
name|internal_size
decl_stmt|;
name|ecoff_symbol_type
modifier|*
name|internal
decl_stmt|;
name|ecoff_symbol_type
modifier|*
name|internal_ptr
decl_stmt|;
name|char
modifier|*
name|eraw_src
decl_stmt|;
name|char
modifier|*
name|eraw_end
decl_stmt|;
name|FDR
modifier|*
name|fdr_ptr
decl_stmt|;
name|FDR
modifier|*
name|fdr_end
decl_stmt|;
comment|/* If we've already read in the symbol table, do nothing.  */
if|if
condition|(
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|canonical_symbols
operator|!=
name|NULL
condition|)
return|return
name|true
return|;
comment|/* Get the symbolic information.  */
if|if
condition|(
operator|!
name|_bfd_ecoff_slurp_symbolic_info
argument_list|(
name|abfd
argument_list|,
operator|(
name|asection
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|debug_info
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|==
literal|0
condition|)
return|return
name|true
return|;
name|internal_size
operator|=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|internal_size
operator|*=
sizeof|sizeof
argument_list|(
name|ecoff_symbol_type
argument_list|)
expr_stmt|;
name|internal
operator|=
operator|(
name|ecoff_symbol_type
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|internal_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|internal_ptr
operator|=
name|internal
expr_stmt|;
name|eraw_src
operator|=
operator|(
name|char
operator|*
operator|)
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|debug_info
operator|.
name|external_ext
expr_stmt|;
name|eraw_end
operator|=
operator|(
name|eraw_src
operator|+
operator|(
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|debug_info
operator|.
name|symbolic_header
operator|.
name|iextMax
operator|*
name|external_ext_size
operator|)
operator|)
expr_stmt|;
for|for
control|(
init|;
name|eraw_src
operator|<
name|eraw_end
condition|;
name|eraw_src
operator|+=
name|external_ext_size
operator|,
name|internal_ptr
operator|++
control|)
block|{
name|EXTR
name|internal_esym
decl_stmt|;
call|(
modifier|*
name|swap_ext_in
call|)
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|eraw_src
argument_list|,
operator|&
name|internal_esym
argument_list|)
expr_stmt|;
name|internal_ptr
operator|->
name|symbol
operator|.
name|name
operator|=
operator|(
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|debug_info
operator|.
name|ssext
operator|+
name|internal_esym
operator|.
name|asym
operator|.
name|iss
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|ecoff_set_symbol_info
argument_list|(
name|abfd
argument_list|,
operator|&
name|internal_esym
operator|.
name|asym
argument_list|,
operator|&
name|internal_ptr
operator|->
name|symbol
argument_list|,
literal|1
argument_list|,
name|internal_esym
operator|.
name|weakext
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* The alpha uses a negative ifd field for section symbols.  */
if|if
condition|(
name|internal_esym
operator|.
name|ifd
operator|>=
literal|0
condition|)
name|internal_ptr
operator|->
name|fdr
operator|=
operator|(
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|debug_info
operator|.
name|fdr
operator|+
name|internal_esym
operator|.
name|ifd
operator|)
expr_stmt|;
else|else
name|internal_ptr
operator|->
name|fdr
operator|=
name|NULL
expr_stmt|;
name|internal_ptr
operator|->
name|local
operator|=
name|false
expr_stmt|;
name|internal_ptr
operator|->
name|native
operator|=
operator|(
name|PTR
operator|)
name|eraw_src
expr_stmt|;
block|}
comment|/* The local symbols must be accessed via the fdr's, because the      string and aux indices are relative to the fdr information.  */
name|fdr_ptr
operator|=
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|debug_info
operator|.
name|fdr
expr_stmt|;
name|fdr_end
operator|=
name|fdr_ptr
operator|+
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|debug_info
operator|.
name|symbolic_header
operator|.
name|ifdMax
expr_stmt|;
for|for
control|(
init|;
name|fdr_ptr
operator|<
name|fdr_end
condition|;
name|fdr_ptr
operator|++
control|)
block|{
name|char
modifier|*
name|lraw_src
decl_stmt|;
name|char
modifier|*
name|lraw_end
decl_stmt|;
name|lraw_src
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|debug_info
operator|.
name|external_sym
operator|+
name|fdr_ptr
operator|->
name|isymBase
operator|*
name|external_sym_size
operator|)
expr_stmt|;
name|lraw_end
operator|=
name|lraw_src
operator|+
name|fdr_ptr
operator|->
name|csym
operator|*
name|external_sym_size
expr_stmt|;
for|for
control|(
init|;
name|lraw_src
operator|<
name|lraw_end
condition|;
name|lraw_src
operator|+=
name|external_sym_size
operator|,
name|internal_ptr
operator|++
control|)
block|{
name|SYMR
name|internal_sym
decl_stmt|;
call|(
modifier|*
name|swap_sym_in
call|)
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|lraw_src
argument_list|,
operator|&
name|internal_sym
argument_list|)
expr_stmt|;
name|internal_ptr
operator|->
name|symbol
operator|.
name|name
operator|=
operator|(
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|debug_info
operator|.
name|ss
operator|+
name|fdr_ptr
operator|->
name|issBase
operator|+
name|internal_sym
operator|.
name|iss
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|ecoff_set_symbol_info
argument_list|(
name|abfd
argument_list|,
operator|&
name|internal_sym
argument_list|,
operator|&
name|internal_ptr
operator|->
name|symbol
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
name|internal_ptr
operator|->
name|fdr
operator|=
name|fdr_ptr
expr_stmt|;
name|internal_ptr
operator|->
name|local
operator|=
name|true
expr_stmt|;
name|internal_ptr
operator|->
name|native
operator|=
operator|(
name|PTR
operator|)
name|lraw_src
expr_stmt|;
block|}
block|}
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|canonical_symbols
operator|=
name|internal
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Return the amount of space needed for the canonical symbols.  */
end_comment

begin_function
name|long
name|_bfd_ecoff_get_symtab_upper_bound
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|_bfd_ecoff_slurp_symbolic_info
argument_list|(
name|abfd
argument_list|,
operator|(
name|asection
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|debug_info
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|+
literal|1
operator|)
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|ecoff_symbol_type
operator|*
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Get the canonical symbols.  */
end_comment

begin_function
name|long
name|_bfd_ecoff_get_symtab
parameter_list|(
name|abfd
parameter_list|,
name|alocation
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|alocation
decl_stmt|;
block|{
name|unsigned
name|int
name|counter
init|=
literal|0
decl_stmt|;
name|ecoff_symbol_type
modifier|*
name|symbase
decl_stmt|;
name|ecoff_symbol_type
modifier|*
modifier|*
name|location
init|=
operator|(
name|ecoff_symbol_type
operator|*
operator|*
operator|)
name|alocation
decl_stmt|;
if|if
condition|(
name|_bfd_ecoff_slurp_symbol_table
argument_list|(
name|abfd
argument_list|)
operator|==
name|false
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|symbase
operator|=
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|canonical_symbols
expr_stmt|;
while|while
condition|(
name|counter
operator|<
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
operator|*
operator|(
name|location
operator|++
operator|)
operator|=
name|symbase
operator|++
expr_stmt|;
name|counter
operator|++
expr_stmt|;
block|}
operator|*
name|location
operator|++
operator|=
operator|(
name|ecoff_symbol_type
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Turn ECOFF type information into a printable string.    ecoff_emit_aggregate and ecoff_type_to_string are from    gcc/mips-tdump.c, with swapping added and used_ptr removed.  */
end_comment

begin_comment
comment|/* Write aggregate information to a string.  */
end_comment

begin_function
specifier|static
name|void
name|ecoff_emit_aggregate
parameter_list|(
name|abfd
parameter_list|,
name|fdr
parameter_list|,
name|string
parameter_list|,
name|rndx
parameter_list|,
name|isym
parameter_list|,
name|which
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|FDR
modifier|*
name|fdr
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|RNDXR
modifier|*
name|rndx
decl_stmt|;
name|long
name|isym
decl_stmt|;
specifier|const
name|char
modifier|*
name|which
decl_stmt|;
block|{
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
specifier|const
name|debug_swap
init|=
operator|&
name|ecoff_backend
argument_list|(
name|abfd
argument_list|)
operator|->
name|debug_swap
decl_stmt|;
name|struct
name|ecoff_debug_info
modifier|*
specifier|const
name|debug_info
init|=
operator|&
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|debug_info
decl_stmt|;
name|unsigned
name|int
name|ifd
init|=
name|rndx
operator|->
name|rfd
decl_stmt|;
name|unsigned
name|int
name|indx
init|=
name|rndx
operator|->
name|index
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|ifd
operator|==
literal|0xfff
condition|)
name|ifd
operator|=
name|isym
expr_stmt|;
comment|/* An ifd of -1 is an opaque type.  An escaped index of 0 is a      struct return type of a procedure compiled without -g.  */
if|if
condition|(
name|ifd
operator|==
literal|0xffffffff
operator|||
operator|(
name|rndx
operator|->
name|rfd
operator|==
literal|0xfff
operator|&&
name|indx
operator|==
literal|0
operator|)
condition|)
name|name
operator|=
literal|"<undefined>"
expr_stmt|;
elseif|else
if|if
condition|(
name|indx
operator|==
name|indexNil
condition|)
name|name
operator|=
literal|"<no name>"
expr_stmt|;
else|else
block|{
name|SYMR
name|sym
decl_stmt|;
if|if
condition|(
name|debug_info
operator|->
name|external_rfd
operator|==
name|NULL
condition|)
name|fdr
operator|=
name|debug_info
operator|->
name|fdr
operator|+
name|ifd
expr_stmt|;
else|else
block|{
name|RFDT
name|rfd
decl_stmt|;
call|(
modifier|*
name|debug_swap
operator|->
name|swap_rfd_in
call|)
argument_list|(
name|abfd
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|debug_info
operator|->
name|external_rfd
operator|+
operator|(
operator|(
name|fdr
operator|->
name|rfdBase
operator|+
name|ifd
operator|)
operator|*
name|debug_swap
operator|->
name|external_rfd_size
operator|)
operator|)
argument_list|,
operator|&
name|rfd
argument_list|)
expr_stmt|;
name|fdr
operator|=
name|debug_info
operator|->
name|fdr
operator|+
name|rfd
expr_stmt|;
block|}
name|indx
operator|+=
name|fdr
operator|->
name|isymBase
expr_stmt|;
call|(
modifier|*
name|debug_swap
operator|->
name|swap_sym_in
call|)
argument_list|(
name|abfd
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|debug_info
operator|->
name|external_sym
operator|+
name|indx
operator|*
name|debug_swap
operator|->
name|external_sym_size
operator|)
argument_list|,
operator|&
name|sym
argument_list|)
expr_stmt|;
name|name
operator|=
name|debug_info
operator|->
name|ss
operator|+
name|fdr
operator|->
name|issBase
operator|+
name|sym
operator|.
name|iss
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"%s %s { ifd = %u, index = %lu }"
argument_list|,
name|which
argument_list|,
name|name
argument_list|,
name|ifd
argument_list|,
operator|(
operator|(
name|long
operator|)
name|indx
operator|+
name|debug_info
operator|->
name|symbolic_header
operator|.
name|iextMax
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert the type information to string format.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|ecoff_type_to_string
parameter_list|(
name|abfd
parameter_list|,
name|fdr
parameter_list|,
name|indx
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|FDR
modifier|*
name|fdr
decl_stmt|;
name|unsigned
name|int
name|indx
decl_stmt|;
block|{
name|union
name|aux_ext
modifier|*
name|aux_ptr
decl_stmt|;
name|int
name|bigendian
decl_stmt|;
name|AUXU
name|u
decl_stmt|;
struct|struct
name|qual
block|{
name|unsigned
name|int
name|type
decl_stmt|;
name|int
name|low_bound
decl_stmt|;
name|int
name|high_bound
decl_stmt|;
name|int
name|stride
decl_stmt|;
block|}
name|qualifiers
index|[
literal|7
index|]
struct|;
name|unsigned
name|int
name|basic_type
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
name|buffer1
index|[
literal|1024
index|]
decl_stmt|;
specifier|static
name|char
name|buffer2
index|[
literal|1024
index|]
decl_stmt|;
name|char
modifier|*
name|p1
init|=
name|buffer1
decl_stmt|;
name|char
modifier|*
name|p2
init|=
name|buffer2
decl_stmt|;
name|RNDXR
name|rndx
decl_stmt|;
name|aux_ptr
operator|=
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|debug_info
operator|.
name|external_aux
operator|+
name|fdr
operator|->
name|iauxBase
expr_stmt|;
name|bigendian
operator|=
name|fdr
operator|->
name|fBigendian
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
block|{
name|qualifiers
index|[
name|i
index|]
operator|.
name|low_bound
operator|=
literal|0
expr_stmt|;
name|qualifiers
index|[
name|i
index|]
operator|.
name|high_bound
operator|=
literal|0
expr_stmt|;
name|qualifiers
index|[
name|i
index|]
operator|.
name|stride
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|AUX_GET_ISYM
argument_list|(
name|bigendian
argument_list|,
operator|&
name|aux_ptr
index|[
name|indx
index|]
argument_list|)
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
return|return
literal|"-1 (no type)"
return|;
name|_bfd_ecoff_swap_tir_in
argument_list|(
name|bigendian
argument_list|,
operator|&
name|aux_ptr
index|[
name|indx
operator|++
index|]
operator|.
name|a_ti
argument_list|,
operator|&
name|u
operator|.
name|ti
argument_list|)
expr_stmt|;
name|basic_type
operator|=
name|u
operator|.
name|ti
operator|.
name|bt
expr_stmt|;
name|qualifiers
index|[
literal|0
index|]
operator|.
name|type
operator|=
name|u
operator|.
name|ti
operator|.
name|tq0
expr_stmt|;
name|qualifiers
index|[
literal|1
index|]
operator|.
name|type
operator|=
name|u
operator|.
name|ti
operator|.
name|tq1
expr_stmt|;
name|qualifiers
index|[
literal|2
index|]
operator|.
name|type
operator|=
name|u
operator|.
name|ti
operator|.
name|tq2
expr_stmt|;
name|qualifiers
index|[
literal|3
index|]
operator|.
name|type
operator|=
name|u
operator|.
name|ti
operator|.
name|tq3
expr_stmt|;
name|qualifiers
index|[
literal|4
index|]
operator|.
name|type
operator|=
name|u
operator|.
name|ti
operator|.
name|tq4
expr_stmt|;
name|qualifiers
index|[
literal|5
index|]
operator|.
name|type
operator|=
name|u
operator|.
name|ti
operator|.
name|tq5
expr_stmt|;
name|qualifiers
index|[
literal|6
index|]
operator|.
name|type
operator|=
name|tqNil
expr_stmt|;
comment|/*    * Go get the basic type.    */
switch|switch
condition|(
name|basic_type
condition|)
block|{
case|case
name|btNil
case|:
comment|/* undefined */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"nil"
argument_list|)
expr_stmt|;
break|break;
case|case
name|btAdr
case|:
comment|/* address - integer same size as pointer */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"address"
argument_list|)
expr_stmt|;
break|break;
case|case
name|btChar
case|:
comment|/* character */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"char"
argument_list|)
expr_stmt|;
break|break;
case|case
name|btUChar
case|:
comment|/* unsigned character */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"unsigned char"
argument_list|)
expr_stmt|;
break|break;
case|case
name|btShort
case|:
comment|/* short */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"short"
argument_list|)
expr_stmt|;
break|break;
case|case
name|btUShort
case|:
comment|/* unsigned short */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"unsigned short"
argument_list|)
expr_stmt|;
break|break;
case|case
name|btInt
case|:
comment|/* int */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"int"
argument_list|)
expr_stmt|;
break|break;
case|case
name|btUInt
case|:
comment|/* unsigned int */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"unsigned int"
argument_list|)
expr_stmt|;
break|break;
case|case
name|btLong
case|:
comment|/* long */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"long"
argument_list|)
expr_stmt|;
break|break;
case|case
name|btULong
case|:
comment|/* unsigned long */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"unsigned long"
argument_list|)
expr_stmt|;
break|break;
case|case
name|btFloat
case|:
comment|/* float (real) */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"float"
argument_list|)
expr_stmt|;
break|break;
case|case
name|btDouble
case|:
comment|/* Double (real) */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"double"
argument_list|)
expr_stmt|;
break|break;
comment|/* Structures add 1-2 aux words: 	 1st word is [ST_RFDESCAPE, offset] pointer to struct def; 	 2nd word is file index if 1st word rfd is ST_RFDESCAPE.  */
case|case
name|btStruct
case|:
comment|/* Structure (Record) */
name|_bfd_ecoff_swap_rndx_in
argument_list|(
name|bigendian
argument_list|,
operator|&
name|aux_ptr
index|[
name|indx
index|]
operator|.
name|a_rndx
argument_list|,
operator|&
name|rndx
argument_list|)
expr_stmt|;
name|ecoff_emit_aggregate
argument_list|(
name|abfd
argument_list|,
name|fdr
argument_list|,
name|p1
argument_list|,
operator|&
name|rndx
argument_list|,
operator|(
name|long
operator|)
name|AUX_GET_ISYM
argument_list|(
name|bigendian
argument_list|,
operator|&
name|aux_ptr
index|[
name|indx
operator|+
literal|1
index|]
argument_list|)
argument_list|,
literal|"struct"
argument_list|)
expr_stmt|;
name|indx
operator|++
expr_stmt|;
comment|/* skip aux words */
break|break;
comment|/* Unions add 1-2 aux words: 	 1st word is [ST_RFDESCAPE, offset] pointer to union def; 	 2nd word is file index if 1st word rfd is ST_RFDESCAPE.  */
case|case
name|btUnion
case|:
comment|/* Union */
name|_bfd_ecoff_swap_rndx_in
argument_list|(
name|bigendian
argument_list|,
operator|&
name|aux_ptr
index|[
name|indx
index|]
operator|.
name|a_rndx
argument_list|,
operator|&
name|rndx
argument_list|)
expr_stmt|;
name|ecoff_emit_aggregate
argument_list|(
name|abfd
argument_list|,
name|fdr
argument_list|,
name|p1
argument_list|,
operator|&
name|rndx
argument_list|,
operator|(
name|long
operator|)
name|AUX_GET_ISYM
argument_list|(
name|bigendian
argument_list|,
operator|&
name|aux_ptr
index|[
name|indx
operator|+
literal|1
index|]
argument_list|)
argument_list|,
literal|"union"
argument_list|)
expr_stmt|;
name|indx
operator|++
expr_stmt|;
comment|/* skip aux words */
break|break;
comment|/* Enumerations add 1-2 aux words: 	 1st word is [ST_RFDESCAPE, offset] pointer to enum def; 	 2nd word is file index if 1st word rfd is ST_RFDESCAPE.  */
case|case
name|btEnum
case|:
comment|/* Enumeration */
name|_bfd_ecoff_swap_rndx_in
argument_list|(
name|bigendian
argument_list|,
operator|&
name|aux_ptr
index|[
name|indx
index|]
operator|.
name|a_rndx
argument_list|,
operator|&
name|rndx
argument_list|)
expr_stmt|;
name|ecoff_emit_aggregate
argument_list|(
name|abfd
argument_list|,
name|fdr
argument_list|,
name|p1
argument_list|,
operator|&
name|rndx
argument_list|,
operator|(
name|long
operator|)
name|AUX_GET_ISYM
argument_list|(
name|bigendian
argument_list|,
operator|&
name|aux_ptr
index|[
name|indx
operator|+
literal|1
index|]
argument_list|)
argument_list|,
literal|"enum"
argument_list|)
expr_stmt|;
name|indx
operator|++
expr_stmt|;
comment|/* skip aux words */
break|break;
case|case
name|btTypedef
case|:
comment|/* defined via a typedef, isymRef points */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"typedef"
argument_list|)
expr_stmt|;
break|break;
case|case
name|btRange
case|:
comment|/* subrange of int */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"subrange"
argument_list|)
expr_stmt|;
break|break;
case|case
name|btSet
case|:
comment|/* pascal sets */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"set"
argument_list|)
expr_stmt|;
break|break;
case|case
name|btComplex
case|:
comment|/* fortran complex */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"complex"
argument_list|)
expr_stmt|;
break|break;
case|case
name|btDComplex
case|:
comment|/* fortran double complex */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"double complex"
argument_list|)
expr_stmt|;
break|break;
case|case
name|btIndirect
case|:
comment|/* forward or unnamed typedef */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"forward/unamed typedef"
argument_list|)
expr_stmt|;
break|break;
case|case
name|btFixedDec
case|:
comment|/* Fixed Decimal */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"fixed decimal"
argument_list|)
expr_stmt|;
break|break;
case|case
name|btFloatDec
case|:
comment|/* Float Decimal */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"float decimal"
argument_list|)
expr_stmt|;
break|break;
case|case
name|btString
case|:
comment|/* Varying Length Character String */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"string"
argument_list|)
expr_stmt|;
break|break;
case|case
name|btBit
case|:
comment|/* Aligned Bit String */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"bit"
argument_list|)
expr_stmt|;
break|break;
case|case
name|btPicture
case|:
comment|/* Picture */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"picture"
argument_list|)
expr_stmt|;
break|break;
case|case
name|btVoid
case|:
comment|/* Void */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"void"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|sprintf
argument_list|(
name|p1
argument_list|,
name|_
argument_list|(
literal|"Unknown basic type %d"
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|basic_type
argument_list|)
expr_stmt|;
break|break;
block|}
name|p1
operator|+=
name|strlen
argument_list|(
name|buffer1
argument_list|)
expr_stmt|;
comment|/*    * If this is a bitfield, get the bitsize.    */
if|if
condition|(
name|u
operator|.
name|ti
operator|.
name|fBitfield
condition|)
block|{
name|int
name|bitsize
decl_stmt|;
name|bitsize
operator|=
name|AUX_GET_WIDTH
argument_list|(
name|bigendian
argument_list|,
operator|&
name|aux_ptr
index|[
name|indx
operator|++
index|]
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|p1
argument_list|,
literal|" : %d"
argument_list|,
name|bitsize
argument_list|)
expr_stmt|;
name|p1
operator|+=
name|strlen
argument_list|(
name|buffer1
argument_list|)
expr_stmt|;
block|}
comment|/*    * Deal with any qualifiers.    */
if|if
condition|(
name|qualifiers
index|[
literal|0
index|]
operator|.
name|type
operator|!=
name|tqNil
condition|)
block|{
comment|/*        * Snarf up any array bounds in the correct order.  Arrays        * store 5 successive words in the aux. table:        *	word 0	RNDXR to type of the bounds (ie, int)        *	word 1	Current file descriptor index        *	word 2	low bound        *	word 3	high bound (or -1 if [])        *	word 4	stride size in bits        */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|qualifiers
index|[
name|i
index|]
operator|.
name|type
operator|==
name|tqArray
condition|)
block|{
name|qualifiers
index|[
name|i
index|]
operator|.
name|low_bound
operator|=
name|AUX_GET_DNLOW
argument_list|(
name|bigendian
argument_list|,
operator|&
name|aux_ptr
index|[
name|indx
operator|+
literal|2
index|]
argument_list|)
expr_stmt|;
name|qualifiers
index|[
name|i
index|]
operator|.
name|high_bound
operator|=
name|AUX_GET_DNHIGH
argument_list|(
name|bigendian
argument_list|,
operator|&
name|aux_ptr
index|[
name|indx
operator|+
literal|3
index|]
argument_list|)
expr_stmt|;
name|qualifiers
index|[
name|i
index|]
operator|.
name|stride
operator|=
name|AUX_GET_WIDTH
argument_list|(
name|bigendian
argument_list|,
operator|&
name|aux_ptr
index|[
name|indx
operator|+
literal|4
index|]
argument_list|)
expr_stmt|;
name|indx
operator|+=
literal|5
expr_stmt|;
block|}
block|}
comment|/*        * Now print out the qualifiers.        */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|qualifiers
index|[
name|i
index|]
operator|.
name|type
condition|)
block|{
case|case
name|tqNil
case|:
case|case
name|tqMax
case|:
break|break;
case|case
name|tqPtr
case|:
name|strcpy
argument_list|(
name|p2
argument_list|,
literal|"ptr to "
argument_list|)
expr_stmt|;
name|p2
operator|+=
sizeof|sizeof
argument_list|(
literal|"ptr to "
argument_list|)
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|tqVol
case|:
name|strcpy
argument_list|(
name|p2
argument_list|,
literal|"volatile "
argument_list|)
expr_stmt|;
name|p2
operator|+=
sizeof|sizeof
argument_list|(
literal|"volatile "
argument_list|)
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|tqFar
case|:
name|strcpy
argument_list|(
name|p2
argument_list|,
literal|"far "
argument_list|)
expr_stmt|;
name|p2
operator|+=
sizeof|sizeof
argument_list|(
literal|"far "
argument_list|)
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|tqProc
case|:
name|strcpy
argument_list|(
name|p2
argument_list|,
literal|"func. ret. "
argument_list|)
expr_stmt|;
name|p2
operator|+=
sizeof|sizeof
argument_list|(
literal|"func. ret. "
argument_list|)
expr_stmt|;
break|break;
case|case
name|tqArray
case|:
block|{
name|int
name|first_array
init|=
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
comment|/* Print array bounds reversed (ie, in the order the C 		   programmer writes them).  C is such a fun language....  */
while|while
condition|(
name|i
operator|<
literal|5
operator|&&
name|qualifiers
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|type
operator|==
name|tqArray
condition|)
name|i
operator|++
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|>=
name|first_array
condition|;
name|j
operator|--
control|)
block|{
name|strcpy
argument_list|(
name|p2
argument_list|,
literal|"array ["
argument_list|)
expr_stmt|;
name|p2
operator|+=
sizeof|sizeof
argument_list|(
literal|"array ["
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|qualifiers
index|[
name|j
index|]
operator|.
name|low_bound
operator|!=
literal|0
condition|)
name|sprintf
argument_list|(
name|p2
argument_list|,
literal|"%ld:%ld {%ld bits}"
argument_list|,
operator|(
name|long
operator|)
name|qualifiers
index|[
name|j
index|]
operator|.
name|low_bound
argument_list|,
operator|(
name|long
operator|)
name|qualifiers
index|[
name|j
index|]
operator|.
name|high_bound
argument_list|,
operator|(
name|long
operator|)
name|qualifiers
index|[
name|j
index|]
operator|.
name|stride
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|qualifiers
index|[
name|j
index|]
operator|.
name|high_bound
operator|!=
operator|-
literal|1
condition|)
name|sprintf
argument_list|(
name|p2
argument_list|,
literal|"%ld {%ld bits}"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|qualifiers
index|[
name|j
index|]
operator|.
name|high_bound
operator|+
literal|1
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
name|qualifiers
index|[
name|j
index|]
operator|.
name|stride
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|p2
argument_list|,
literal|" {%ld bits}"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|qualifiers
index|[
name|j
index|]
operator|.
name|stride
argument_list|)
argument_list|)
expr_stmt|;
name|p2
operator|+=
name|strlen
argument_list|(
name|p2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p2
argument_list|,
literal|"] of "
argument_list|)
expr_stmt|;
name|p2
operator|+=
sizeof|sizeof
argument_list|(
literal|"] of "
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
block|}
name|strcpy
argument_list|(
name|p2
argument_list|,
name|buffer1
argument_list|)
expr_stmt|;
return|return
name|buffer2
return|;
block|}
end_function

begin_comment
comment|/* Return information about ECOFF symbol SYMBOL in RET.  */
end_comment

begin_function
name|void
name|_bfd_ecoff_get_symbol_info
parameter_list|(
name|abfd
parameter_list|,
name|symbol
parameter_list|,
name|ret
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|symbol_info
modifier|*
name|ret
decl_stmt|;
block|{
name|bfd_symbol_info
argument_list|(
name|symbol
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return whether this is a local label.  */
end_comment

begin_function
name|boolean
name|_bfd_ecoff_bfd_is_local_label_name
parameter_list|(
name|abfd
parameter_list|,
name|name
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
return|return
name|name
index|[
literal|0
index|]
operator|==
literal|'$'
return|;
block|}
end_function

begin_comment
comment|/* Print information about an ECOFF symbol.  */
end_comment

begin_function
name|void
name|_bfd_ecoff_print_symbol
parameter_list|(
name|abfd
parameter_list|,
name|filep
parameter_list|,
name|symbol
parameter_list|,
name|how
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|filep
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|bfd_print_symbol_type
name|how
decl_stmt|;
block|{
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
specifier|const
name|debug_swap
init|=
operator|&
name|ecoff_backend
argument_list|(
name|abfd
argument_list|)
operator|->
name|debug_swap
decl_stmt|;
name|FILE
modifier|*
name|file
init|=
operator|(
name|FILE
operator|*
operator|)
name|filep
decl_stmt|;
switch|switch
condition|(
name|how
condition|)
block|{
case|case
name|bfd_print_symbol_name
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|symbol
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_print_symbol_more
case|:
if|if
condition|(
name|ecoffsymbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|local
condition|)
block|{
name|SYMR
name|ecoff_sym
decl_stmt|;
call|(
modifier|*
name|debug_swap
operator|->
name|swap_sym_in
call|)
argument_list|(
name|abfd
argument_list|,
name|ecoffsymbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|native
argument_list|,
operator|&
name|ecoff_sym
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"ecoff local "
argument_list|)
expr_stmt|;
name|fprintf_vma
argument_list|(
name|file
argument_list|,
operator|(
name|bfd_vma
operator|)
name|ecoff_sym
operator|.
name|value
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %x %x"
argument_list|,
operator|(
name|unsigned
operator|)
name|ecoff_sym
operator|.
name|st
argument_list|,
operator|(
name|unsigned
operator|)
name|ecoff_sym
operator|.
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|EXTR
name|ecoff_ext
decl_stmt|;
call|(
modifier|*
name|debug_swap
operator|->
name|swap_ext_in
call|)
argument_list|(
name|abfd
argument_list|,
name|ecoffsymbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|native
argument_list|,
operator|&
name|ecoff_ext
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"ecoff extern "
argument_list|)
expr_stmt|;
name|fprintf_vma
argument_list|(
name|file
argument_list|,
operator|(
name|bfd_vma
operator|)
name|ecoff_ext
operator|.
name|asym
operator|.
name|value
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %x %x"
argument_list|,
operator|(
name|unsigned
operator|)
name|ecoff_ext
operator|.
name|asym
operator|.
name|st
argument_list|,
operator|(
name|unsigned
operator|)
name|ecoff_ext
operator|.
name|asym
operator|.
name|sc
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|bfd_print_symbol_all
case|:
comment|/* Print out the symbols in a reasonable way */
block|{
name|char
name|type
decl_stmt|;
name|int
name|pos
decl_stmt|;
name|EXTR
name|ecoff_ext
decl_stmt|;
name|char
name|jmptbl
decl_stmt|;
name|char
name|cobol_main
decl_stmt|;
name|char
name|weakext
decl_stmt|;
if|if
condition|(
name|ecoffsymbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|local
condition|)
block|{
call|(
modifier|*
name|debug_swap
operator|->
name|swap_sym_in
call|)
argument_list|(
name|abfd
argument_list|,
name|ecoffsymbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|native
argument_list|,
operator|&
name|ecoff_ext
operator|.
name|asym
argument_list|)
expr_stmt|;
name|type
operator|=
literal|'l'
expr_stmt|;
name|pos
operator|=
operator|(
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|ecoffsymbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|native
operator|-
operator|(
name|char
operator|*
operator|)
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|debug_info
operator|.
name|external_sym
operator|)
operator|/
name|debug_swap
operator|->
name|external_sym_size
operator|)
operator|+
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|debug_info
operator|.
name|symbolic_header
operator|.
name|iextMax
operator|)
expr_stmt|;
name|jmptbl
operator|=
literal|' '
expr_stmt|;
name|cobol_main
operator|=
literal|' '
expr_stmt|;
name|weakext
operator|=
literal|' '
expr_stmt|;
block|}
else|else
block|{
call|(
modifier|*
name|debug_swap
operator|->
name|swap_ext_in
call|)
argument_list|(
name|abfd
argument_list|,
name|ecoffsymbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|native
argument_list|,
operator|&
name|ecoff_ext
argument_list|)
expr_stmt|;
name|type
operator|=
literal|'e'
expr_stmt|;
name|pos
operator|=
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|ecoffsymbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|native
operator|-
operator|(
name|char
operator|*
operator|)
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|debug_info
operator|.
name|external_ext
operator|)
operator|/
name|debug_swap
operator|->
name|external_ext_size
operator|)
expr_stmt|;
name|jmptbl
operator|=
name|ecoff_ext
operator|.
name|jmptbl
condition|?
literal|'j'
else|:
literal|' '
expr_stmt|;
name|cobol_main
operator|=
name|ecoff_ext
operator|.
name|cobol_main
condition|?
literal|'c'
else|:
literal|' '
expr_stmt|;
name|weakext
operator|=
name|ecoff_ext
operator|.
name|weakext
condition|?
literal|'w'
else|:
literal|' '
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"[%3d] %c "
argument_list|,
name|pos
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|fprintf_vma
argument_list|(
name|file
argument_list|,
operator|(
name|bfd_vma
operator|)
name|ecoff_ext
operator|.
name|asym
operator|.
name|value
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" st %x sc %x indx %x %c%c%c %s"
argument_list|,
operator|(
name|unsigned
operator|)
name|ecoff_ext
operator|.
name|asym
operator|.
name|st
argument_list|,
operator|(
name|unsigned
operator|)
name|ecoff_ext
operator|.
name|asym
operator|.
name|sc
argument_list|,
operator|(
name|unsigned
operator|)
name|ecoff_ext
operator|.
name|asym
operator|.
name|index
argument_list|,
name|jmptbl
argument_list|,
name|cobol_main
argument_list|,
name|weakext
argument_list|,
name|symbol
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecoffsymbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|fdr
operator|!=
name|NULL
operator|&&
name|ecoff_ext
operator|.
name|asym
operator|.
name|index
operator|!=
name|indexNil
condition|)
block|{
name|FDR
modifier|*
name|fdr
decl_stmt|;
name|unsigned
name|int
name|indx
decl_stmt|;
name|int
name|bigendian
decl_stmt|;
name|bfd_size_type
name|sym_base
decl_stmt|;
name|union
name|aux_ext
modifier|*
name|aux_base
decl_stmt|;
name|fdr
operator|=
name|ecoffsymbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|fdr
expr_stmt|;
name|indx
operator|=
name|ecoff_ext
operator|.
name|asym
operator|.
name|index
expr_stmt|;
comment|/* sym_base is used to map the fdr relative indices which 	       appear in the file to the position number which we are 	       using.  */
name|sym_base
operator|=
name|fdr
operator|->
name|isymBase
expr_stmt|;
if|if
condition|(
name|ecoffsymbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|local
condition|)
name|sym_base
operator|+=
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|debug_info
operator|.
name|symbolic_header
operator|.
name|iextMax
expr_stmt|;
comment|/* aux_base is the start of the aux entries for this file; 	       asym.index is an offset from this.  */
name|aux_base
operator|=
operator|(
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|debug_info
operator|.
name|external_aux
operator|+
name|fdr
operator|->
name|iauxBase
operator|)
expr_stmt|;
comment|/* The aux entries are stored in host byte order; the 	       order is indicated by a bit in the fdr.  */
name|bigendian
operator|=
name|fdr
operator|->
name|fBigendian
expr_stmt|;
comment|/* This switch is basically from gcc/mips-tdump.c  */
switch|switch
condition|(
name|ecoff_ext
operator|.
name|asym
operator|.
name|st
condition|)
block|{
case|case
name|stNil
case|:
case|case
name|stLabel
case|:
break|break;
case|case
name|stFile
case|:
case|case
name|stBlock
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"\n      End+1 symbol: %ld"
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
name|indx
operator|+
name|sym_base
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|stEnd
case|:
if|if
condition|(
name|ecoff_ext
operator|.
name|asym
operator|.
name|sc
operator|==
name|scText
operator|||
name|ecoff_ext
operator|.
name|asym
operator|.
name|sc
operator|==
name|scInfo
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"\n      First symbol: %ld"
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
name|indx
operator|+
name|sym_base
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"\n      First symbol: %ld"
argument_list|)
argument_list|,
operator|(
call|(
name|long
call|)
argument_list|(
name|AUX_GET_ISYM
argument_list|(
name|bigendian
argument_list|,
operator|&
name|aux_base
index|[
name|ecoff_ext
operator|.
name|asym
operator|.
name|index
index|]
argument_list|)
operator|+
name|sym_base
argument_list|)
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|stProc
case|:
case|case
name|stStaticProc
case|:
if|if
condition|(
name|ECOFF_IS_STAB
argument_list|(
operator|&
name|ecoff_ext
operator|.
name|asym
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|ecoffsymbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|local
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"\n      End+1 symbol: %-7ld   Type:  %s"
argument_list|)
argument_list|,
operator|(
call|(
name|long
call|)
argument_list|(
name|AUX_GET_ISYM
argument_list|(
name|bigendian
argument_list|,
operator|&
name|aux_base
index|[
name|ecoff_ext
operator|.
name|asym
operator|.
name|index
index|]
argument_list|)
operator|+
name|sym_base
argument_list|)
operator|)
argument_list|,
name|ecoff_type_to_string
argument_list|(
name|abfd
argument_list|,
name|fdr
argument_list|,
name|indx
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"\n      Local symbol: %ld"
argument_list|)
argument_list|,
operator|(
operator|(
name|long
operator|)
name|indx
operator|+
operator|(
name|long
operator|)
name|sym_base
operator|+
operator|(
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|debug_info
operator|.
name|symbolic_header
operator|.
name|iextMax
operator|)
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|stStruct
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"\n      struct; End+1 symbol: %ld"
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
name|indx
operator|+
name|sym_base
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|stUnion
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"\n      union; End+1 symbol: %ld"
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
name|indx
operator|+
name|sym_base
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|stEnum
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"\n      enum; End+1 symbol: %ld"
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
name|indx
operator|+
name|sym_base
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|!
name|ECOFF_IS_STAB
argument_list|(
operator|&
name|ecoff_ext
operator|.
name|asym
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"\n      Type: %s"
argument_list|)
argument_list|,
name|ecoff_type_to_string
argument_list|(
name|abfd
argument_list|,
name|fdr
argument_list|,
name|indx
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read in the relocs for a section.  */
end_comment

begin_function
specifier|static
name|boolean
name|ecoff_slurp_reloc_table
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|symbols
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
block|{
specifier|const
name|struct
name|ecoff_backend_data
modifier|*
specifier|const
name|backend
init|=
name|ecoff_backend
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|arelent
modifier|*
name|internal_relocs
decl_stmt|;
name|bfd_size_type
name|external_reloc_size
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|char
modifier|*
name|external_relocs
decl_stmt|;
name|arelent
modifier|*
name|rptr
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|section
operator|->
name|relocation
operator|!=
operator|(
name|arelent
operator|*
operator|)
name|NULL
operator|||
name|section
operator|->
name|reloc_count
operator|==
literal|0
operator|||
operator|(
name|section
operator|->
name|flags
operator|&
name|SEC_CONSTRUCTOR
operator|)
operator|!=
literal|0
condition|)
return|return
name|true
return|;
if|if
condition|(
name|_bfd_ecoff_slurp_symbol_table
argument_list|(
name|abfd
argument_list|)
operator|==
name|false
condition|)
return|return
name|false
return|;
name|amt
operator|=
name|section
operator|->
name|reloc_count
expr_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
expr_stmt|;
name|internal_relocs
operator|=
operator|(
name|arelent
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
name|external_reloc_size
operator|=
name|backend
operator|->
name|external_reloc_size
expr_stmt|;
name|amt
operator|=
name|external_reloc_size
operator|*
name|section
operator|->
name|reloc_count
expr_stmt|;
name|external_relocs
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
operator|(
name|arelent
operator|*
operator|)
name|NULL
operator|||
name|external_relocs
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|section
operator|->
name|rel_filepos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bfd_bread
argument_list|(
name|external_relocs
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
return|return
name|false
return|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|rptr
operator|=
name|internal_relocs
init|;
name|i
operator|<
name|section
operator|->
name|reloc_count
condition|;
name|i
operator|++
operator|,
name|rptr
operator|++
control|)
block|{
name|struct
name|internal_reloc
name|intern
decl_stmt|;
call|(
modifier|*
name|backend
operator|->
name|swap_reloc_in
call|)
argument_list|(
name|abfd
argument_list|,
name|external_relocs
operator|+
name|i
operator|*
name|external_reloc_size
argument_list|,
operator|&
name|intern
argument_list|)
expr_stmt|;
if|if
condition|(
name|intern
operator|.
name|r_extern
condition|)
block|{
comment|/* r_symndx is an index into the external symbols.  */
name|BFD_ASSERT
argument_list|(
name|intern
operator|.
name|r_symndx
operator|>=
literal|0
operator|&&
operator|(
name|intern
operator|.
name|r_symndx
operator|<
operator|(
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|debug_info
operator|.
name|symbolic_header
operator|.
name|iextMax
operator|)
operator|)
argument_list|)
expr_stmt|;
name|rptr
operator|->
name|sym_ptr_ptr
operator|=
name|symbols
operator|+
name|intern
operator|.
name|r_symndx
expr_stmt|;
name|rptr
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|intern
operator|.
name|r_symndx
operator|==
name|RELOC_SECTION_NONE
operator|||
name|intern
operator|.
name|r_symndx
operator|==
name|RELOC_SECTION_ABS
condition|)
block|{
name|rptr
operator|->
name|sym_ptr_ptr
operator|=
name|bfd_abs_section_ptr
operator|->
name|symbol_ptr_ptr
expr_stmt|;
name|rptr
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|sec_name
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
comment|/* r_symndx is a section key.  */
switch|switch
condition|(
name|intern
operator|.
name|r_symndx
condition|)
block|{
case|case
name|RELOC_SECTION_TEXT
case|:
name|sec_name
operator|=
literal|".text"
expr_stmt|;
break|break;
case|case
name|RELOC_SECTION_RDATA
case|:
name|sec_name
operator|=
literal|".rdata"
expr_stmt|;
break|break;
case|case
name|RELOC_SECTION_DATA
case|:
name|sec_name
operator|=
literal|".data"
expr_stmt|;
break|break;
case|case
name|RELOC_SECTION_SDATA
case|:
name|sec_name
operator|=
literal|".sdata"
expr_stmt|;
break|break;
case|case
name|RELOC_SECTION_SBSS
case|:
name|sec_name
operator|=
literal|".sbss"
expr_stmt|;
break|break;
case|case
name|RELOC_SECTION_BSS
case|:
name|sec_name
operator|=
literal|".bss"
expr_stmt|;
break|break;
case|case
name|RELOC_SECTION_INIT
case|:
name|sec_name
operator|=
literal|".init"
expr_stmt|;
break|break;
case|case
name|RELOC_SECTION_LIT8
case|:
name|sec_name
operator|=
literal|".lit8"
expr_stmt|;
break|break;
case|case
name|RELOC_SECTION_LIT4
case|:
name|sec_name
operator|=
literal|".lit4"
expr_stmt|;
break|break;
case|case
name|RELOC_SECTION_XDATA
case|:
name|sec_name
operator|=
literal|".xdata"
expr_stmt|;
break|break;
case|case
name|RELOC_SECTION_PDATA
case|:
name|sec_name
operator|=
literal|".pdata"
expr_stmt|;
break|break;
case|case
name|RELOC_SECTION_FINI
case|:
name|sec_name
operator|=
literal|".fini"
expr_stmt|;
break|break;
case|case
name|RELOC_SECTION_LITA
case|:
name|sec_name
operator|=
literal|".lita"
expr_stmt|;
break|break;
case|case
name|RELOC_SECTION_RCONST
case|:
name|sec_name
operator|=
literal|".rconst"
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|sec_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|rptr
operator|->
name|sym_ptr_ptr
operator|=
name|sec
operator|->
name|symbol_ptr_ptr
expr_stmt|;
name|rptr
operator|->
name|addend
operator|=
operator|-
name|bfd_get_section_vma
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
block|}
name|rptr
operator|->
name|address
operator|=
name|intern
operator|.
name|r_vaddr
operator|-
name|bfd_get_section_vma
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
expr_stmt|;
comment|/* Let the backend select the howto field and do any other 	 required processing.  */
call|(
modifier|*
name|backend
operator|->
name|adjust_reloc_in
call|)
argument_list|(
name|abfd
argument_list|,
operator|&
name|intern
argument_list|,
name|rptr
argument_list|)
expr_stmt|;
block|}
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|external_relocs
argument_list|)
expr_stmt|;
name|section
operator|->
name|relocation
operator|=
name|internal_relocs
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Get a canonical list of relocs.  */
end_comment

begin_function
name|long
name|_bfd_ecoff_canonicalize_reloc
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|relptr
parameter_list|,
name|symbols
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|relptr
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
block|{
name|unsigned
name|int
name|count
decl_stmt|;
if|if
condition|(
name|section
operator|->
name|flags
operator|&
name|SEC_CONSTRUCTOR
condition|)
block|{
name|arelent_chain
modifier|*
name|chain
decl_stmt|;
comment|/* This section has relocs made up by us, not the file, so take 	 them out of their chain and place them into the data area 	 provided.  */
for|for
control|(
name|count
operator|=
literal|0
operator|,
name|chain
operator|=
name|section
operator|->
name|constructor_chain
init|;
name|count
operator|<
name|section
operator|->
name|reloc_count
condition|;
name|count
operator|++
operator|,
name|chain
operator|=
name|chain
operator|->
name|next
control|)
operator|*
name|relptr
operator|++
operator|=
operator|&
name|chain
operator|->
name|relent
expr_stmt|;
block|}
else|else
block|{
name|arelent
modifier|*
name|tblptr
decl_stmt|;
if|if
condition|(
name|ecoff_slurp_reloc_table
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|symbols
argument_list|)
operator|==
name|false
condition|)
return|return
operator|-
literal|1
return|;
name|tblptr
operator|=
name|section
operator|->
name|relocation
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|section
operator|->
name|reloc_count
condition|;
name|count
operator|++
control|)
operator|*
name|relptr
operator|++
operator|=
name|tblptr
operator|++
expr_stmt|;
block|}
operator|*
name|relptr
operator|=
operator|(
name|arelent
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
name|section
operator|->
name|reloc_count
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Provided a BFD, a section and an offset into the section, calculate    and return the name of the source file and the line nearest to the    wanted location.  */
end_comment

begin_function
name|boolean
name|_bfd_ecoff_find_nearest_line
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|ignore_symbols
parameter_list|,
name|offset
parameter_list|,
name|filename_ptr
parameter_list|,
name|functionname_ptr
parameter_list|,
name|retline_ptr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|ignore_symbols
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|filename_ptr
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|functionname_ptr
decl_stmt|;
name|unsigned
name|int
modifier|*
name|retline_ptr
decl_stmt|;
block|{
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
specifier|const
name|debug_swap
init|=
operator|&
name|ecoff_backend
argument_list|(
name|abfd
argument_list|)
operator|->
name|debug_swap
decl_stmt|;
name|struct
name|ecoff_debug_info
modifier|*
specifier|const
name|debug_info
init|=
operator|&
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|debug_info
decl_stmt|;
name|struct
name|ecoff_find_line
modifier|*
name|line_info
decl_stmt|;
comment|/* Make sure we have the FDR's.  */
if|if
condition|(
operator|!
name|_bfd_ecoff_slurp_symbolic_info
argument_list|(
name|abfd
argument_list|,
operator|(
name|asection
operator|*
operator|)
name|NULL
argument_list|,
name|debug_info
argument_list|)
operator|||
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|==
literal|0
condition|)
return|return
name|false
return|;
if|if
condition|(
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|find_line_info
operator|==
name|NULL
condition|)
block|{
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|ecoff_find_line
argument_list|)
decl_stmt|;
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|find_line_info
operator|=
operator|(
expr|struct
name|ecoff_find_line
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|find_line_info
operator|==
name|NULL
condition|)
return|return
name|false
return|;
block|}
name|line_info
operator|=
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|find_line_info
expr_stmt|;
return|return
name|_bfd_ecoff_locate_line
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|offset
argument_list|,
name|debug_info
argument_list|,
name|debug_swap
argument_list|,
name|line_info
argument_list|,
name|filename_ptr
argument_list|,
name|functionname_ptr
argument_list|,
name|retline_ptr
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Copy private BFD data.  This is called by objcopy and strip.  We    use it to copy the ECOFF debugging information from one BFD to the    other.  It would be theoretically possible to represent the ECOFF    debugging information in the symbol table.  However, it would be a    lot of work, and there would be little gain (gas, gdb, and ld    already access the ECOFF debugging information via the    ecoff_debug_info structure, and that structure would have to be    retained in order to support ECOFF debugging in MIPS ELF).     The debugging information for the ECOFF external symbols comes from    the symbol table, so this function only handles the other debugging    information.  */
end_comment

begin_function
name|boolean
name|_bfd_ecoff_bfd_copy_private_bfd_data
parameter_list|(
name|ibfd
parameter_list|,
name|obfd
parameter_list|)
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|bfd
modifier|*
name|obfd
decl_stmt|;
block|{
name|struct
name|ecoff_debug_info
modifier|*
name|iinfo
init|=
operator|&
name|ecoff_data
argument_list|(
name|ibfd
argument_list|)
operator|->
name|debug_info
decl_stmt|;
name|struct
name|ecoff_debug_info
modifier|*
name|oinfo
init|=
operator|&
name|ecoff_data
argument_list|(
name|obfd
argument_list|)
operator|->
name|debug_info
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|sym_ptr_ptr
decl_stmt|;
name|size_t
name|c
decl_stmt|;
name|boolean
name|local
decl_stmt|;
comment|/* We only want to copy information over if both BFD's use ECOFF      format.  */
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|ibfd
argument_list|)
operator|!=
name|bfd_target_ecoff_flavour
operator|||
name|bfd_get_flavour
argument_list|(
name|obfd
argument_list|)
operator|!=
name|bfd_target_ecoff_flavour
condition|)
return|return
name|true
return|;
comment|/* Copy the GP value and the register masks.  */
name|ecoff_data
argument_list|(
name|obfd
argument_list|)
operator|->
name|gp
operator|=
name|ecoff_data
argument_list|(
name|ibfd
argument_list|)
operator|->
name|gp
expr_stmt|;
name|ecoff_data
argument_list|(
name|obfd
argument_list|)
operator|->
name|gprmask
operator|=
name|ecoff_data
argument_list|(
name|ibfd
argument_list|)
operator|->
name|gprmask
expr_stmt|;
name|ecoff_data
argument_list|(
name|obfd
argument_list|)
operator|->
name|fprmask
operator|=
name|ecoff_data
argument_list|(
name|ibfd
argument_list|)
operator|->
name|fprmask
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
name|ecoff_data
argument_list|(
name|obfd
argument_list|)
operator|->
name|cprmask
index|[
name|i
index|]
operator|=
name|ecoff_data
argument_list|(
name|ibfd
argument_list|)
operator|->
name|cprmask
index|[
name|i
index|]
expr_stmt|;
comment|/* Copy the version stamp.  */
name|oinfo
operator|->
name|symbolic_header
operator|.
name|vstamp
operator|=
name|iinfo
operator|->
name|symbolic_header
operator|.
name|vstamp
expr_stmt|;
comment|/* If there are no symbols, don't copy any debugging information.  */
name|c
operator|=
name|bfd_get_symcount
argument_list|(
name|obfd
argument_list|)
expr_stmt|;
name|sym_ptr_ptr
operator|=
name|bfd_get_outsymbols
argument_list|(
name|obfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
operator|||
name|sym_ptr_ptr
operator|==
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|NULL
condition|)
return|return
name|true
return|;
comment|/* See if there are any local symbols.  */
name|local
operator|=
name|false
expr_stmt|;
for|for
control|(
init|;
name|c
operator|>
literal|0
condition|;
name|c
operator|--
operator|,
name|sym_ptr_ptr
operator|++
control|)
block|{
if|if
condition|(
name|ecoffsymbol
argument_list|(
operator|*
name|sym_ptr_ptr
argument_list|)
operator|->
name|local
condition|)
block|{
name|local
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|local
condition|)
block|{
comment|/* There are some local symbols.  We just bring over all the 	 debugging information.  FIXME: This is not quite the right 	 thing to do.  If the user has asked us to discard all 	 debugging information, then we are probably going to wind up 	 keeping it because there will probably be some local symbol 	 which objcopy did not discard.  We should actually break 	 apart the debugging information and only keep that which 	 applies to the symbols we want to keep.  */
name|oinfo
operator|->
name|symbolic_header
operator|.
name|ilineMax
operator|=
name|iinfo
operator|->
name|symbolic_header
operator|.
name|ilineMax
expr_stmt|;
name|oinfo
operator|->
name|symbolic_header
operator|.
name|cbLine
operator|=
name|iinfo
operator|->
name|symbolic_header
operator|.
name|cbLine
expr_stmt|;
name|oinfo
operator|->
name|line
operator|=
name|iinfo
operator|->
name|line
expr_stmt|;
name|oinfo
operator|->
name|symbolic_header
operator|.
name|idnMax
operator|=
name|iinfo
operator|->
name|symbolic_header
operator|.
name|idnMax
expr_stmt|;
name|oinfo
operator|->
name|external_dnr
operator|=
name|iinfo
operator|->
name|external_dnr
expr_stmt|;
name|oinfo
operator|->
name|symbolic_header
operator|.
name|ipdMax
operator|=
name|iinfo
operator|->
name|symbolic_header
operator|.
name|ipdMax
expr_stmt|;
name|oinfo
operator|->
name|external_pdr
operator|=
name|iinfo
operator|->
name|external_pdr
expr_stmt|;
name|oinfo
operator|->
name|symbolic_header
operator|.
name|isymMax
operator|=
name|iinfo
operator|->
name|symbolic_header
operator|.
name|isymMax
expr_stmt|;
name|oinfo
operator|->
name|external_sym
operator|=
name|iinfo
operator|->
name|external_sym
expr_stmt|;
name|oinfo
operator|->
name|symbolic_header
operator|.
name|ioptMax
operator|=
name|iinfo
operator|->
name|symbolic_header
operator|.
name|ioptMax
expr_stmt|;
name|oinfo
operator|->
name|external_opt
operator|=
name|iinfo
operator|->
name|external_opt
expr_stmt|;
name|oinfo
operator|->
name|symbolic_header
operator|.
name|iauxMax
operator|=
name|iinfo
operator|->
name|symbolic_header
operator|.
name|iauxMax
expr_stmt|;
name|oinfo
operator|->
name|external_aux
operator|=
name|iinfo
operator|->
name|external_aux
expr_stmt|;
name|oinfo
operator|->
name|symbolic_header
operator|.
name|issMax
operator|=
name|iinfo
operator|->
name|symbolic_header
operator|.
name|issMax
expr_stmt|;
name|oinfo
operator|->
name|ss
operator|=
name|iinfo
operator|->
name|ss
expr_stmt|;
name|oinfo
operator|->
name|symbolic_header
operator|.
name|ifdMax
operator|=
name|iinfo
operator|->
name|symbolic_header
operator|.
name|ifdMax
expr_stmt|;
name|oinfo
operator|->
name|external_fdr
operator|=
name|iinfo
operator|->
name|external_fdr
expr_stmt|;
name|oinfo
operator|->
name|symbolic_header
operator|.
name|crfd
operator|=
name|iinfo
operator|->
name|symbolic_header
operator|.
name|crfd
expr_stmt|;
name|oinfo
operator|->
name|external_rfd
operator|=
name|iinfo
operator|->
name|external_rfd
expr_stmt|;
block|}
else|else
block|{
comment|/* We are discarding all the local symbol information.  Look 	 through the external symbols and remove all references to FDR 	 or aux information.  */
name|c
operator|=
name|bfd_get_symcount
argument_list|(
name|obfd
argument_list|)
expr_stmt|;
name|sym_ptr_ptr
operator|=
name|bfd_get_outsymbols
argument_list|(
name|obfd
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|c
operator|>
literal|0
condition|;
name|c
operator|--
operator|,
name|sym_ptr_ptr
operator|++
control|)
block|{
name|EXTR
name|esym
decl_stmt|;
operator|(
operator|*
operator|(
name|ecoff_backend
argument_list|(
name|obfd
argument_list|)
operator|->
name|debug_swap
operator|.
name|swap_ext_in
operator|)
operator|)
operator|(
name|obfd
operator|,
name|ecoffsymbol
argument_list|(
operator|*
name|sym_ptr_ptr
argument_list|)
operator|->
name|native
operator|,
operator|&
name|esym
operator|)
expr_stmt|;
name|esym
operator|.
name|ifd
operator|=
name|ifdNil
expr_stmt|;
name|esym
operator|.
name|asym
operator|.
name|index
operator|=
name|indexNil
expr_stmt|;
operator|(
operator|*
operator|(
name|ecoff_backend
argument_list|(
name|obfd
argument_list|)
operator|->
name|debug_swap
operator|.
name|swap_ext_out
operator|)
operator|)
operator|(
name|obfd
operator|,
operator|&
name|esym
operator|,
name|ecoffsymbol
argument_list|(
operator|*
name|sym_ptr_ptr
argument_list|)
operator|->
name|native
operator|)
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set the architecture.  The supported architecture is stored in the    backend pointer.  We always set the architecture anyhow, since many    callers ignore the return value.  */
end_comment

begin_function
name|boolean
name|_bfd_ecoff_set_arch_mach
parameter_list|(
name|abfd
parameter_list|,
name|arch
parameter_list|,
name|machine
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|enum
name|bfd_architecture
name|arch
decl_stmt|;
name|unsigned
name|long
name|machine
decl_stmt|;
block|{
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|arch
argument_list|,
name|machine
argument_list|)
expr_stmt|;
return|return
name|arch
operator|==
name|ecoff_backend
argument_list|(
name|abfd
argument_list|)
operator|->
name|arch
return|;
block|}
end_function

begin_comment
comment|/* Get the size of the section headers.  */
end_comment

begin_function
name|int
name|_bfd_ecoff_sizeof_headers
parameter_list|(
name|abfd
parameter_list|,
name|reloc
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|boolean
name|reloc
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|asection
modifier|*
name|current
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|current
operator|=
name|abfd
operator|->
name|sections
init|;
name|current
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|;
name|current
operator|=
name|current
operator|->
name|next
control|)
operator|++
name|c
expr_stmt|;
name|ret
operator|=
operator|(
name|bfd_coff_filhsz
argument_list|(
name|abfd
argument_list|)
operator|+
name|bfd_coff_aoutsz
argument_list|(
name|abfd
argument_list|)
operator|+
name|c
operator|*
name|bfd_coff_scnhsz
argument_list|(
name|abfd
argument_list|)
operator|)
expr_stmt|;
return|return
name|BFD_ALIGN
argument_list|(
name|ret
argument_list|,
literal|16
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Get the contents of a section.  */
end_comment

begin_function
name|boolean
name|_bfd_ecoff_get_section_contents
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|location
parameter_list|,
name|offset
parameter_list|,
name|count
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|PTR
name|location
decl_stmt|;
name|file_ptr
name|offset
decl_stmt|;
name|bfd_size_type
name|count
decl_stmt|;
block|{
return|return
name|_bfd_generic_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|location
argument_list|,
name|offset
argument_list|,
name|count
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Sort sections by VMA, but put SEC_ALLOC sections first.  This is    called via qsort.  */
end_comment

begin_function
specifier|static
name|int
name|ecoff_sort_hdrs
parameter_list|(
name|arg1
parameter_list|,
name|arg2
parameter_list|)
specifier|const
name|PTR
name|arg1
decl_stmt|;
specifier|const
name|PTR
name|arg2
decl_stmt|;
block|{
specifier|const
name|asection
modifier|*
name|hdr1
init|=
operator|*
operator|(
specifier|const
name|asection
operator|*
operator|*
operator|)
name|arg1
decl_stmt|;
specifier|const
name|asection
modifier|*
name|hdr2
init|=
operator|*
operator|(
specifier|const
name|asection
operator|*
operator|*
operator|)
name|arg2
decl_stmt|;
if|if
condition|(
operator|(
name|hdr1
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|hdr2
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|hdr2
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
block|}
if|if
condition|(
name|hdr1
operator|->
name|vma
operator|<
name|hdr2
operator|->
name|vma
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|hdr1
operator|->
name|vma
operator|>
name|hdr2
operator|->
name|vma
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Calculate the file position for each section, and set    reloc_filepos.  */
end_comment

begin_function
specifier|static
name|boolean
name|ecoff_compute_section_file_positions
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|file_ptr
name|sofar
decl_stmt|,
name|file_sofar
decl_stmt|;
name|asection
modifier|*
modifier|*
name|sorted_hdrs
decl_stmt|;
name|asection
modifier|*
name|current
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|file_ptr
name|old_sofar
decl_stmt|;
name|boolean
name|rdata_in_text
decl_stmt|;
name|boolean
name|first_data
decl_stmt|,
name|first_nonalloc
decl_stmt|;
specifier|const
name|bfd_vma
name|round
init|=
name|ecoff_backend
argument_list|(
name|abfd
argument_list|)
operator|->
name|round
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|sofar
operator|=
name|_bfd_ecoff_sizeof_headers
argument_list|(
name|abfd
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|file_sofar
operator|=
name|sofar
expr_stmt|;
comment|/* Sort the sections by VMA.  */
name|amt
operator|=
name|abfd
operator|->
name|section_count
expr_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
expr_stmt|;
name|sorted_hdrs
operator|=
operator|(
name|asection
operator|*
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|sorted_hdrs
operator|==
name|NULL
condition|)
return|return
name|false
return|;
for|for
control|(
name|current
operator|=
name|abfd
operator|->
name|sections
operator|,
name|i
operator|=
literal|0
init|;
name|current
operator|!=
name|NULL
condition|;
name|current
operator|=
name|current
operator|->
name|next
operator|,
name|i
operator|++
control|)
name|sorted_hdrs
index|[
name|i
index|]
operator|=
name|current
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|i
operator|==
name|abfd
operator|->
name|section_count
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|sorted_hdrs
argument_list|,
name|abfd
operator|->
name|section_count
argument_list|,
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
argument_list|,
name|ecoff_sort_hdrs
argument_list|)
expr_stmt|;
comment|/* Some versions of the OSF linker put the .rdata section in the      text segment, and some do not.  */
name|rdata_in_text
operator|=
name|ecoff_backend
argument_list|(
name|abfd
argument_list|)
operator|->
name|rdata_in_text
expr_stmt|;
if|if
condition|(
name|rdata_in_text
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|abfd
operator|->
name|section_count
condition|;
name|i
operator|++
control|)
block|{
name|current
operator|=
name|sorted_hdrs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|current
operator|->
name|name
argument_list|,
name|_RDATA
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|(
name|current
operator|->
name|flags
operator|&
name|SEC_CODE
operator|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|current
operator|->
name|name
argument_list|,
name|_PDATA
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|current
operator|->
name|name
argument_list|,
name|_RCONST
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|rdata_in_text
operator|=
name|false
expr_stmt|;
break|break;
block|}
block|}
block|}
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|rdata_in_text
operator|=
name|rdata_in_text
expr_stmt|;
name|first_data
operator|=
name|true
expr_stmt|;
name|first_nonalloc
operator|=
name|true
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|abfd
operator|->
name|section_count
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|alignment_power
decl_stmt|;
name|current
operator|=
name|sorted_hdrs
index|[
name|i
index|]
expr_stmt|;
comment|/* For the Alpha ECOFF .pdata section the lnnoptr field is 	 supposed to indicate the number of .pdata entries that are 	 really in the section.  Each entry is 8 bytes.  We store this 	 away in line_filepos before increasing the section size.  */
if|if
condition|(
name|strcmp
argument_list|(
name|current
operator|->
name|name
argument_list|,
name|_PDATA
argument_list|)
operator|==
literal|0
condition|)
name|current
operator|->
name|line_filepos
operator|=
name|current
operator|->
name|_raw_size
operator|/
literal|8
expr_stmt|;
name|alignment_power
operator|=
name|current
operator|->
name|alignment_power
expr_stmt|;
comment|/* On Ultrix, the data sections in an executable file must be 	 aligned to a page boundary within the file.  This does not 	 affect the section size, though.  FIXME: Does this work for 	 other platforms?  It requires some modification for the 	 Alpha, because .rdata on the Alpha goes with the text, not 	 the data.  */
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|EXEC_P
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|abfd
operator|->
name|flags
operator|&
name|D_PAGED
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|first_data
operator|&&
operator|(
name|current
operator|->
name|flags
operator|&
name|SEC_CODE
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|!
name|rdata_in_text
operator|||
name|strcmp
argument_list|(
name|current
operator|->
name|name
argument_list|,
name|_RDATA
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
name|strcmp
argument_list|(
name|current
operator|->
name|name
argument_list|,
name|_PDATA
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|current
operator|->
name|name
argument_list|,
name|_RCONST
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|sofar
operator|=
operator|(
name|sofar
operator|+
name|round
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|round
operator|-
literal|1
operator|)
expr_stmt|;
name|file_sofar
operator|=
operator|(
name|file_sofar
operator|+
name|round
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|round
operator|-
literal|1
operator|)
expr_stmt|;
name|first_data
operator|=
name|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|current
operator|->
name|name
argument_list|,
name|_LIB
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* On Irix 4, the location of contents of the .lib section 	     from a shared library section is also rounded up to a 	     page boundary.  */
name|sofar
operator|=
operator|(
name|sofar
operator|+
name|round
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|round
operator|-
literal|1
operator|)
expr_stmt|;
name|file_sofar
operator|=
operator|(
name|file_sofar
operator|+
name|round
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|round
operator|-
literal|1
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|first_nonalloc
operator|&&
operator|(
name|current
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|==
literal|0
operator|&&
operator|(
name|abfd
operator|->
name|flags
operator|&
name|D_PAGED
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Skip up to the next page for an unallocated section, such              as the .comment section on the Alpha.  This leaves room              for the .bss section.  */
name|first_nonalloc
operator|=
name|false
expr_stmt|;
name|sofar
operator|=
operator|(
name|sofar
operator|+
name|round
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|round
operator|-
literal|1
operator|)
expr_stmt|;
name|file_sofar
operator|=
operator|(
name|file_sofar
operator|+
name|round
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|round
operator|-
literal|1
operator|)
expr_stmt|;
block|}
comment|/* Align the sections in the file to the same boundary on 	 which they are aligned in virtual memory.  */
name|sofar
operator|=
name|BFD_ALIGN
argument_list|(
name|sofar
argument_list|,
literal|1
operator|<<
name|alignment_power
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|current
operator|->
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|!=
literal|0
condition|)
name|file_sofar
operator|=
name|BFD_ALIGN
argument_list|(
name|file_sofar
argument_list|,
literal|1
operator|<<
name|alignment_power
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|D_PAGED
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|current
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
name|sofar
operator|+=
operator|(
name|current
operator|->
name|vma
operator|-
name|sofar
operator|)
operator|%
name|round
expr_stmt|;
if|if
condition|(
operator|(
name|current
operator|->
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|!=
literal|0
condition|)
name|file_sofar
operator|+=
operator|(
name|current
operator|->
name|vma
operator|-
name|file_sofar
operator|)
operator|%
name|round
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|current
operator|->
name|flags
operator|&
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_LOAD
operator|)
operator|)
operator|!=
literal|0
condition|)
name|current
operator|->
name|filepos
operator|=
name|file_sofar
expr_stmt|;
name|sofar
operator|+=
name|current
operator|->
name|_raw_size
expr_stmt|;
if|if
condition|(
operator|(
name|current
operator|->
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|!=
literal|0
condition|)
name|file_sofar
operator|+=
name|current
operator|->
name|_raw_size
expr_stmt|;
comment|/* make sure that this section is of the right size too */
name|old_sofar
operator|=
name|sofar
expr_stmt|;
name|sofar
operator|=
name|BFD_ALIGN
argument_list|(
name|sofar
argument_list|,
literal|1
operator|<<
name|alignment_power
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|current
operator|->
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|!=
literal|0
condition|)
name|file_sofar
operator|=
name|BFD_ALIGN
argument_list|(
name|file_sofar
argument_list|,
literal|1
operator|<<
name|alignment_power
argument_list|)
expr_stmt|;
name|current
operator|->
name|_raw_size
operator|+=
name|sofar
operator|-
name|old_sofar
expr_stmt|;
block|}
name|free
argument_list|(
name|sorted_hdrs
argument_list|)
expr_stmt|;
name|sorted_hdrs
operator|=
name|NULL
expr_stmt|;
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|reloc_filepos
operator|=
name|file_sofar
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Determine the location of the relocs for all the sections in the    output file, as well as the location of the symbolic debugging    information.  */
end_comment

begin_function
specifier|static
name|bfd_size_type
name|ecoff_compute_reloc_file_positions
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
specifier|const
name|bfd_size_type
name|external_reloc_size
init|=
name|ecoff_backend
argument_list|(
name|abfd
argument_list|)
operator|->
name|external_reloc_size
decl_stmt|;
name|file_ptr
name|reloc_base
decl_stmt|;
name|bfd_size_type
name|reloc_size
decl_stmt|;
name|asection
modifier|*
name|current
decl_stmt|;
name|file_ptr
name|sym_base
decl_stmt|;
if|if
condition|(
operator|!
name|abfd
operator|->
name|output_has_begun
condition|)
block|{
if|if
condition|(
operator|!
name|ecoff_compute_section_file_positions
argument_list|(
name|abfd
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|abfd
operator|->
name|output_has_begun
operator|=
name|true
expr_stmt|;
block|}
name|reloc_base
operator|=
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|reloc_filepos
expr_stmt|;
name|reloc_size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|current
operator|=
name|abfd
operator|->
name|sections
init|;
name|current
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|;
name|current
operator|=
name|current
operator|->
name|next
control|)
block|{
if|if
condition|(
name|current
operator|->
name|reloc_count
operator|==
literal|0
condition|)
name|current
operator|->
name|rel_filepos
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|bfd_size_type
name|relsize
decl_stmt|;
name|current
operator|->
name|rel_filepos
operator|=
name|reloc_base
expr_stmt|;
name|relsize
operator|=
name|current
operator|->
name|reloc_count
operator|*
name|external_reloc_size
expr_stmt|;
name|reloc_size
operator|+=
name|relsize
expr_stmt|;
name|reloc_base
operator|+=
name|relsize
expr_stmt|;
block|}
block|}
name|sym_base
operator|=
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|reloc_filepos
operator|+
name|reloc_size
expr_stmt|;
comment|/* At least on Ultrix, the symbol table of an executable file must      be aligned to a page boundary.  FIXME: Is this true on other      platforms?  */
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|EXEC_P
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|abfd
operator|->
name|flags
operator|&
name|D_PAGED
operator|)
operator|!=
literal|0
condition|)
name|sym_base
operator|=
operator|(
operator|(
name|sym_base
operator|+
name|ecoff_backend
argument_list|(
name|abfd
argument_list|)
operator|->
name|round
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|ecoff_backend
argument_list|(
name|abfd
argument_list|)
operator|->
name|round
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|sym_filepos
operator|=
name|sym_base
expr_stmt|;
return|return
name|reloc_size
return|;
block|}
end_function

begin_comment
comment|/* Set the contents of a section.  */
end_comment

begin_function
name|boolean
name|_bfd_ecoff_set_section_contents
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|location
parameter_list|,
name|offset
parameter_list|,
name|count
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|PTR
name|location
decl_stmt|;
name|file_ptr
name|offset
decl_stmt|;
name|bfd_size_type
name|count
decl_stmt|;
block|{
name|file_ptr
name|pos
decl_stmt|;
comment|/* This must be done first, because bfd_set_section_contents is      going to set output_has_begun to true.  */
if|if
condition|(
name|abfd
operator|->
name|output_has_begun
operator|==
name|false
condition|)
block|{
if|if
condition|(
operator|!
name|ecoff_compute_section_file_positions
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
block|}
comment|/* Handle the .lib section specially so that Irix 4 shared libraries      work out.  See coff_set_section_contents in coffcode.h.  */
if|if
condition|(
name|strcmp
argument_list|(
name|section
operator|->
name|name
argument_list|,
name|_LIB
argument_list|)
operator|==
literal|0
condition|)
block|{
name|bfd_byte
modifier|*
name|rec
decl_stmt|,
modifier|*
name|recend
decl_stmt|;
name|rec
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|location
expr_stmt|;
name|recend
operator|=
name|rec
operator|+
name|count
expr_stmt|;
while|while
condition|(
name|rec
operator|<
name|recend
condition|)
block|{
operator|++
name|section
operator|->
name|lma
expr_stmt|;
name|rec
operator|+=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|rec
argument_list|)
operator|*
literal|4
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
name|rec
operator|==
name|recend
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
name|true
return|;
name|pos
operator|=
name|section
operator|->
name|filepos
operator|+
name|offset
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|pos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bwrite
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|abfd
argument_list|)
operator|!=
name|count
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Get the GP value for an ECOFF file.  This is a hook used by    nlmconv.  */
end_comment

begin_function
name|bfd_vma
name|bfd_ecoff_get_gp_value
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|abfd
argument_list|)
operator|!=
name|bfd_target_ecoff_flavour
operator|||
name|bfd_get_format
argument_list|(
name|abfd
argument_list|)
operator|!=
name|bfd_object
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|gp
return|;
block|}
end_function

begin_comment
comment|/* Set the GP value for an ECOFF file.  This is a hook used by the    assembler.  */
end_comment

begin_function
name|boolean
name|bfd_ecoff_set_gp_value
parameter_list|(
name|abfd
parameter_list|,
name|gp_value
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|bfd_vma
name|gp_value
decl_stmt|;
block|{
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|abfd
argument_list|)
operator|!=
name|bfd_target_ecoff_flavour
operator|||
name|bfd_get_format
argument_list|(
name|abfd
argument_list|)
operator|!=
name|bfd_object
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|gp
operator|=
name|gp_value
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Set the register masks for an ECOFF file.  This is a hook used by    the assembler.  */
end_comment

begin_function
name|boolean
name|bfd_ecoff_set_regmasks
parameter_list|(
name|abfd
parameter_list|,
name|gprmask
parameter_list|,
name|fprmask
parameter_list|,
name|cprmask
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|unsigned
name|long
name|gprmask
decl_stmt|;
name|unsigned
name|long
name|fprmask
decl_stmt|;
name|unsigned
name|long
modifier|*
name|cprmask
decl_stmt|;
block|{
name|ecoff_data_type
modifier|*
name|tdata
decl_stmt|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|abfd
argument_list|)
operator|!=
name|bfd_target_ecoff_flavour
operator|||
name|bfd_get_format
argument_list|(
name|abfd
argument_list|)
operator|!=
name|bfd_object
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|tdata
operator|=
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|tdata
operator|->
name|gprmask
operator|=
name|gprmask
expr_stmt|;
name|tdata
operator|->
name|fprmask
operator|=
name|fprmask
expr_stmt|;
if|if
condition|(
name|cprmask
operator|!=
operator|(
name|unsigned
name|long
operator|*
operator|)
name|NULL
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
name|tdata
operator|->
name|cprmask
index|[
name|i
index|]
operator|=
name|cprmask
index|[
name|i
index|]
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Get ECOFF EXTR information for an external symbol.  This function    is passed to bfd_ecoff_debug_externals.  */
end_comment

begin_function
specifier|static
name|boolean
name|ecoff_get_extr
parameter_list|(
name|sym
parameter_list|,
name|esym
parameter_list|)
name|asymbol
modifier|*
name|sym
decl_stmt|;
name|EXTR
modifier|*
name|esym
decl_stmt|;
block|{
name|ecoff_symbol_type
modifier|*
name|ecoff_sym_ptr
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
if|if
condition|(
name|bfd_asymbol_flavour
argument_list|(
name|sym
argument_list|)
operator|!=
name|bfd_target_ecoff_flavour
operator|||
name|ecoffsymbol
argument_list|(
name|sym
argument_list|)
operator|->
name|native
operator|==
name|NULL
condition|)
block|{
comment|/* Don't include debugging, local, or section symbols.  */
if|if
condition|(
operator|(
name|sym
operator|->
name|flags
operator|&
name|BSF_DEBUGGING
operator|)
operator|!=
literal|0
operator|||
operator|(
name|sym
operator|->
name|flags
operator|&
name|BSF_LOCAL
operator|)
operator|!=
literal|0
operator|||
operator|(
name|sym
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
name|esym
operator|->
name|jmptbl
operator|=
literal|0
expr_stmt|;
name|esym
operator|->
name|cobol_main
operator|=
literal|0
expr_stmt|;
name|esym
operator|->
name|weakext
operator|=
operator|(
name|sym
operator|->
name|flags
operator|&
name|BSF_WEAK
operator|)
operator|!=
literal|0
expr_stmt|;
name|esym
operator|->
name|reserved
operator|=
literal|0
expr_stmt|;
name|esym
operator|->
name|ifd
operator|=
name|ifdNil
expr_stmt|;
comment|/* FIXME: we can do better than this for st and sc.  */
name|esym
operator|->
name|asym
operator|.
name|st
operator|=
name|stGlobal
expr_stmt|;
name|esym
operator|->
name|asym
operator|.
name|sc
operator|=
name|scAbs
expr_stmt|;
name|esym
operator|->
name|asym
operator|.
name|reserved
operator|=
literal|0
expr_stmt|;
name|esym
operator|->
name|asym
operator|.
name|index
operator|=
name|indexNil
expr_stmt|;
return|return
name|true
return|;
block|}
name|ecoff_sym_ptr
operator|=
name|ecoffsymbol
argument_list|(
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecoff_sym_ptr
operator|->
name|local
condition|)
return|return
name|false
return|;
name|input_bfd
operator|=
name|bfd_asymbol_bfd
argument_list|(
name|sym
argument_list|)
expr_stmt|;
operator|(
operator|*
operator|(
name|ecoff_backend
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|debug_swap
operator|.
name|swap_ext_in
operator|)
operator|)
operator|(
name|input_bfd
operator|,
name|ecoff_sym_ptr
operator|->
name|native
operator|,
name|esym
operator|)
expr_stmt|;
comment|/* If the symbol was defined by the linker, then esym will be      undefined but sym will not be.  Get a better class for such a      symbol.  */
if|if
condition|(
operator|(
name|esym
operator|->
name|asym
operator|.
name|sc
operator|==
name|scUndefined
operator|||
name|esym
operator|->
name|asym
operator|.
name|sc
operator|==
name|scSUndefined
operator|)
operator|&&
operator|!
name|bfd_is_und_section
argument_list|(
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
name|esym
operator|->
name|asym
operator|.
name|sc
operator|=
name|scAbs
expr_stmt|;
comment|/* Adjust the FDR index for the symbol by that used for the input      BFD.  */
if|if
condition|(
name|esym
operator|->
name|ifd
operator|!=
operator|-
literal|1
condition|)
block|{
name|struct
name|ecoff_debug_info
modifier|*
name|input_debug
decl_stmt|;
name|input_debug
operator|=
operator|&
name|ecoff_data
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|debug_info
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|esym
operator|->
name|ifd
operator|<
name|input_debug
operator|->
name|symbolic_header
operator|.
name|ifdMax
argument_list|)
expr_stmt|;
if|if
condition|(
name|input_debug
operator|->
name|ifdmap
operator|!=
operator|(
name|RFDT
operator|*
operator|)
name|NULL
condition|)
name|esym
operator|->
name|ifd
operator|=
name|input_debug
operator|->
name|ifdmap
index|[
name|esym
operator|->
name|ifd
index|]
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Set the external symbol index.  This routine is passed to    bfd_ecoff_debug_externals.  */
end_comment

begin_function
specifier|static
name|void
name|ecoff_set_index
parameter_list|(
name|sym
parameter_list|,
name|indx
parameter_list|)
name|asymbol
modifier|*
name|sym
decl_stmt|;
name|bfd_size_type
name|indx
decl_stmt|;
block|{
name|ecoff_set_sym_index
argument_list|(
name|sym
argument_list|,
name|indx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write out an ECOFF file.  */
end_comment

begin_function
name|boolean
name|_bfd_ecoff_write_object_contents
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
specifier|const
name|struct
name|ecoff_backend_data
modifier|*
specifier|const
name|backend
init|=
name|ecoff_backend
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
specifier|const
name|bfd_vma
name|round
init|=
name|backend
operator|->
name|round
decl_stmt|;
specifier|const
name|bfd_size_type
name|filhsz
init|=
name|bfd_coff_filhsz
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
specifier|const
name|bfd_size_type
name|aoutsz
init|=
name|bfd_coff_aoutsz
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
specifier|const
name|bfd_size_type
name|scnhsz
init|=
name|bfd_coff_scnhsz
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
specifier|const
name|bfd_size_type
name|external_hdr_size
init|=
name|backend
operator|->
name|debug_swap
operator|.
name|external_hdr_size
decl_stmt|;
specifier|const
name|bfd_size_type
name|external_reloc_size
init|=
name|backend
operator|->
name|external_reloc_size
decl_stmt|;
name|void
argument_list|(
argument|* const adjust_reloc_out
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|arelent
operator|*
operator|,
expr|struct
name|internal_reloc
operator|*
operator|)
argument_list|)
operator|=
name|backend
operator|->
name|adjust_reloc_out
expr_stmt|;
name|void
argument_list|(
argument|* const swap_reloc_out
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
expr|struct
name|internal_reloc
operator|*
operator|,
name|PTR
operator|)
argument_list|)
operator|=
name|backend
operator|->
name|swap_reloc_out
expr_stmt|;
name|struct
name|ecoff_debug_info
modifier|*
specifier|const
name|debug
init|=
operator|&
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|debug_info
decl_stmt|;
name|HDRR
modifier|*
specifier|const
name|symhdr
init|=
operator|&
name|debug
operator|->
name|symbolic_header
decl_stmt|;
name|asection
modifier|*
name|current
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
name|bfd_size_type
name|reloc_size
decl_stmt|;
name|bfd_size_type
name|text_size
decl_stmt|;
name|bfd_vma
name|text_start
decl_stmt|;
name|boolean
name|set_text_start
decl_stmt|;
name|bfd_size_type
name|data_size
decl_stmt|;
name|bfd_vma
name|data_start
decl_stmt|;
name|boolean
name|set_data_start
decl_stmt|;
name|bfd_size_type
name|bss_size
decl_stmt|;
name|PTR
name|buff
init|=
name|NULL
decl_stmt|;
name|PTR
name|reloc_buff
init|=
name|NULL
decl_stmt|;
name|struct
name|internal_filehdr
name|internal_f
decl_stmt|;
name|struct
name|internal_aouthdr
name|internal_a
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Determine where the sections and relocs will go in the output      file.  */
name|reloc_size
operator|=
name|ecoff_compute_reloc_file_positions
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|count
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|current
operator|=
name|abfd
operator|->
name|sections
init|;
name|current
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|;
name|current
operator|=
name|current
operator|->
name|next
control|)
block|{
name|current
operator|->
name|target_index
operator|=
name|count
expr_stmt|;
operator|++
name|count
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|D_PAGED
operator|)
operator|!=
literal|0
condition|)
name|text_size
operator|=
name|_bfd_ecoff_sizeof_headers
argument_list|(
name|abfd
argument_list|,
name|false
argument_list|)
expr_stmt|;
else|else
name|text_size
operator|=
literal|0
expr_stmt|;
name|text_start
operator|=
literal|0
expr_stmt|;
name|set_text_start
operator|=
name|false
expr_stmt|;
name|data_size
operator|=
literal|0
expr_stmt|;
name|data_start
operator|=
literal|0
expr_stmt|;
name|set_data_start
operator|=
name|false
expr_stmt|;
name|bss_size
operator|=
literal|0
expr_stmt|;
comment|/* Write section headers to the file.  */
comment|/* Allocate buff big enough to hold a section header,      file header, or a.out header.  */
block|{
name|bfd_size_type
name|siz
decl_stmt|;
name|siz
operator|=
name|scnhsz
expr_stmt|;
if|if
condition|(
name|siz
operator|<
name|filhsz
condition|)
name|siz
operator|=
name|filhsz
expr_stmt|;
if|if
condition|(
name|siz
operator|<
name|aoutsz
condition|)
name|siz
operator|=
name|aoutsz
expr_stmt|;
name|buff
operator|=
operator|(
name|PTR
operator|)
name|bfd_malloc
argument_list|(
name|siz
argument_list|)
expr_stmt|;
if|if
condition|(
name|buff
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
block|}
name|internal_f
operator|.
name|f_nscns
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
call|(
name|file_ptr
call|)
argument_list|(
name|filhsz
operator|+
name|aoutsz
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
for|for
control|(
name|current
operator|=
name|abfd
operator|->
name|sections
init|;
name|current
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|;
name|current
operator|=
name|current
operator|->
name|next
control|)
block|{
name|struct
name|internal_scnhdr
name|section
decl_stmt|;
name|bfd_vma
name|vma
decl_stmt|;
operator|++
name|internal_f
operator|.
name|f_nscns
expr_stmt|;
name|strncpy
argument_list|(
name|section
operator|.
name|s_name
argument_list|,
name|current
operator|->
name|name
argument_list|,
sizeof|sizeof
name|section
operator|.
name|s_name
argument_list|)
expr_stmt|;
comment|/* This seems to be correct for Irix 4 shared libraries.  */
name|vma
operator|=
name|bfd_get_section_vma
argument_list|(
name|abfd
argument_list|,
name|current
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|current
operator|->
name|name
argument_list|,
name|_LIB
argument_list|)
operator|==
literal|0
condition|)
name|section
operator|.
name|s_vaddr
operator|=
literal|0
expr_stmt|;
else|else
name|section
operator|.
name|s_vaddr
operator|=
name|vma
expr_stmt|;
name|section
operator|.
name|s_paddr
operator|=
name|current
operator|->
name|lma
expr_stmt|;
name|section
operator|.
name|s_size
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|current
argument_list|)
expr_stmt|;
comment|/* If this section is unloadable then the scnptr will be 0.  */
if|if
condition|(
operator|(
name|current
operator|->
name|flags
operator|&
operator|(
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator|)
operator|)
operator|==
literal|0
condition|)
name|section
operator|.
name|s_scnptr
operator|=
literal|0
expr_stmt|;
else|else
name|section
operator|.
name|s_scnptr
operator|=
name|current
operator|->
name|filepos
expr_stmt|;
name|section
operator|.
name|s_relptr
operator|=
name|current
operator|->
name|rel_filepos
expr_stmt|;
comment|/* FIXME: the lnnoptr of the .sbss or .sdata section of an 	 object file produced by the assembler is supposed to point to 	 information about how much room is required by objects of 	 various different sizes.  I think this only matters if we 	 want the linker to compute the best size to use, or 	 something.  I don't know what happens if the information is 	 not present.  */
if|if
condition|(
name|strcmp
argument_list|(
name|current
operator|->
name|name
argument_list|,
name|_PDATA
argument_list|)
operator|!=
literal|0
condition|)
name|section
operator|.
name|s_lnnoptr
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* The Alpha ECOFF .pdata section uses the lnnoptr field to 	     hold the number of entries in the section (each entry is 	     8 bytes).  We stored this in the line_filepos field in 	     ecoff_compute_section_file_positions.  */
name|section
operator|.
name|s_lnnoptr
operator|=
name|current
operator|->
name|line_filepos
expr_stmt|;
block|}
name|section
operator|.
name|s_nreloc
operator|=
name|current
operator|->
name|reloc_count
expr_stmt|;
name|section
operator|.
name|s_nlnno
operator|=
literal|0
expr_stmt|;
name|section
operator|.
name|s_flags
operator|=
name|ecoff_sec_to_styp_flags
argument_list|(
name|current
operator|->
name|name
argument_list|,
name|current
operator|->
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_coff_swap_scnhdr_out
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|section
argument_list|,
name|buff
argument_list|)
operator|==
literal|0
operator|||
name|bfd_bwrite
argument_list|(
name|buff
argument_list|,
name|scnhsz
argument_list|,
name|abfd
argument_list|)
operator|!=
name|scnhsz
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|(
name|section
operator|.
name|s_flags
operator|&
name|STYP_TEXT
operator|)
operator|!=
literal|0
operator|||
operator|(
operator|(
name|section
operator|.
name|s_flags
operator|&
name|STYP_RDATA
operator|)
operator|!=
literal|0
operator|&&
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|rdata_in_text
operator|)
operator|||
name|section
operator|.
name|s_flags
operator|==
name|STYP_PDATA
operator|||
operator|(
name|section
operator|.
name|s_flags
operator|&
name|STYP_DYNAMIC
operator|)
operator|!=
literal|0
operator|||
operator|(
name|section
operator|.
name|s_flags
operator|&
name|STYP_LIBLIST
operator|)
operator|!=
literal|0
operator|||
operator|(
name|section
operator|.
name|s_flags
operator|&
name|STYP_RELDYN
operator|)
operator|!=
literal|0
operator|||
name|section
operator|.
name|s_flags
operator|==
name|STYP_CONFLIC
operator|||
operator|(
name|section
operator|.
name|s_flags
operator|&
name|STYP_DYNSTR
operator|)
operator|!=
literal|0
operator|||
operator|(
name|section
operator|.
name|s_flags
operator|&
name|STYP_DYNSYM
operator|)
operator|!=
literal|0
operator|||
operator|(
name|section
operator|.
name|s_flags
operator|&
name|STYP_HASH
operator|)
operator|!=
literal|0
operator|||
operator|(
name|section
operator|.
name|s_flags
operator|&
name|STYP_ECOFF_INIT
operator|)
operator|!=
literal|0
operator|||
operator|(
name|section
operator|.
name|s_flags
operator|&
name|STYP_ECOFF_FINI
operator|)
operator|!=
literal|0
operator|||
name|section
operator|.
name|s_flags
operator|==
name|STYP_RCONST
condition|)
block|{
name|text_size
operator|+=
name|bfd_get_section_size_before_reloc
argument_list|(
name|current
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set_text_start
operator|||
name|text_start
operator|>
name|vma
condition|)
block|{
name|text_start
operator|=
name|vma
expr_stmt|;
name|set_text_start
operator|=
name|true
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|section
operator|.
name|s_flags
operator|&
name|STYP_RDATA
operator|)
operator|!=
literal|0
operator|||
operator|(
name|section
operator|.
name|s_flags
operator|&
name|STYP_DATA
operator|)
operator|!=
literal|0
operator|||
operator|(
name|section
operator|.
name|s_flags
operator|&
name|STYP_LITA
operator|)
operator|!=
literal|0
operator|||
operator|(
name|section
operator|.
name|s_flags
operator|&
name|STYP_LIT8
operator|)
operator|!=
literal|0
operator|||
operator|(
name|section
operator|.
name|s_flags
operator|&
name|STYP_LIT4
operator|)
operator|!=
literal|0
operator|||
operator|(
name|section
operator|.
name|s_flags
operator|&
name|STYP_SDATA
operator|)
operator|!=
literal|0
operator|||
name|section
operator|.
name|s_flags
operator|==
name|STYP_XDATA
operator|||
operator|(
name|section
operator|.
name|s_flags
operator|&
name|STYP_GOT
operator|)
operator|!=
literal|0
condition|)
block|{
name|data_size
operator|+=
name|bfd_get_section_size_before_reloc
argument_list|(
name|current
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set_data_start
operator|||
name|data_start
operator|>
name|vma
condition|)
block|{
name|data_start
operator|=
name|vma
expr_stmt|;
name|set_data_start
operator|=
name|true
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|section
operator|.
name|s_flags
operator|&
name|STYP_BSS
operator|)
operator|!=
literal|0
operator|||
operator|(
name|section
operator|.
name|s_flags
operator|&
name|STYP_SBSS
operator|)
operator|!=
literal|0
condition|)
name|bss_size
operator|+=
name|bfd_get_section_size_before_reloc
argument_list|(
name|current
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|section
operator|.
name|s_flags
operator|==
literal|0
operator|||
operator|(
name|section
operator|.
name|s_flags
operator|&
name|STYP_ECOFF_LIB
operator|)
operator|!=
literal|0
operator|||
name|section
operator|.
name|s_flags
operator|==
name|STYP_COMMENT
condition|)
comment|/* Do nothing */
empty_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Set up the file header.  */
name|internal_f
operator|.
name|f_magic
operator|=
name|ecoff_get_magic
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* We will NOT put a fucking timestamp in the header here. Every      time you put it back, I will come in and take it out again.  I'm      sorry.  This field does not belong here.  We fill it with a 0 so      it compares the same but is not a reasonable time. --      gnu@cygnus.com.  */
name|internal_f
operator|.
name|f_timdat
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* The ECOFF f_nsyms field is not actually the number of 	 symbols, it's the size of symbolic information header.  */
name|internal_f
operator|.
name|f_nsyms
operator|=
name|external_hdr_size
expr_stmt|;
name|internal_f
operator|.
name|f_symptr
operator|=
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|sym_filepos
expr_stmt|;
block|}
else|else
block|{
name|internal_f
operator|.
name|f_nsyms
operator|=
literal|0
expr_stmt|;
name|internal_f
operator|.
name|f_symptr
operator|=
literal|0
expr_stmt|;
block|}
name|internal_f
operator|.
name|f_opthdr
operator|=
name|aoutsz
expr_stmt|;
name|internal_f
operator|.
name|f_flags
operator|=
name|F_LNNO
expr_stmt|;
if|if
condition|(
name|reloc_size
operator|==
literal|0
condition|)
name|internal_f
operator|.
name|f_flags
operator||=
name|F_RELFLG
expr_stmt|;
if|if
condition|(
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|==
literal|0
condition|)
name|internal_f
operator|.
name|f_flags
operator||=
name|F_LSYMS
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|flags
operator|&
name|EXEC_P
condition|)
name|internal_f
operator|.
name|f_flags
operator||=
name|F_EXEC
expr_stmt|;
if|if
condition|(
name|bfd_little_endian
argument_list|(
name|abfd
argument_list|)
condition|)
name|internal_f
operator|.
name|f_flags
operator||=
name|F_AR32WR
expr_stmt|;
else|else
name|internal_f
operator|.
name|f_flags
operator||=
name|F_AR32W
expr_stmt|;
comment|/* Set up the ``optional'' header.  */
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|D_PAGED
operator|)
operator|!=
literal|0
condition|)
name|internal_a
operator|.
name|magic
operator|=
name|ECOFF_AOUT_ZMAGIC
expr_stmt|;
else|else
name|internal_a
operator|.
name|magic
operator|=
name|ECOFF_AOUT_OMAGIC
expr_stmt|;
comment|/* FIXME: Is this really correct?  */
name|internal_a
operator|.
name|vstamp
operator|=
name|symhdr
operator|->
name|vstamp
expr_stmt|;
comment|/* At least on Ultrix, these have to be rounded to page boundaries.      FIXME: Is this true on other platforms?  */
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|D_PAGED
operator|)
operator|!=
literal|0
condition|)
block|{
name|internal_a
operator|.
name|tsize
operator|=
operator|(
name|text_size
operator|+
name|round
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|round
operator|-
literal|1
operator|)
expr_stmt|;
name|internal_a
operator|.
name|text_start
operator|=
name|text_start
operator|&
operator|~
operator|(
name|round
operator|-
literal|1
operator|)
expr_stmt|;
name|internal_a
operator|.
name|dsize
operator|=
operator|(
name|data_size
operator|+
name|round
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|round
operator|-
literal|1
operator|)
expr_stmt|;
name|internal_a
operator|.
name|data_start
operator|=
name|data_start
operator|&
operator|~
operator|(
name|round
operator|-
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
name|internal_a
operator|.
name|tsize
operator|=
name|text_size
expr_stmt|;
name|internal_a
operator|.
name|text_start
operator|=
name|text_start
expr_stmt|;
name|internal_a
operator|.
name|dsize
operator|=
name|data_size
expr_stmt|;
name|internal_a
operator|.
name|data_start
operator|=
name|data_start
expr_stmt|;
block|}
comment|/* On Ultrix, the initial portions of the .sbss and .bss segments      are at the end of the data section.  The bsize field in the      optional header records how many bss bytes are required beyond      those in the data section.  The value is not rounded to a page      boundary.  */
if|if
condition|(
name|bss_size
operator|<
name|internal_a
operator|.
name|dsize
operator|-
name|data_size
condition|)
name|bss_size
operator|=
literal|0
expr_stmt|;
else|else
name|bss_size
operator|-=
name|internal_a
operator|.
name|dsize
operator|-
name|data_size
expr_stmt|;
name|internal_a
operator|.
name|bsize
operator|=
name|bss_size
expr_stmt|;
name|internal_a
operator|.
name|bss_start
operator|=
name|internal_a
operator|.
name|data_start
operator|+
name|internal_a
operator|.
name|dsize
expr_stmt|;
name|internal_a
operator|.
name|entry
operator|=
name|bfd_get_start_address
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|internal_a
operator|.
name|gp_value
operator|=
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|gp
expr_stmt|;
name|internal_a
operator|.
name|gprmask
operator|=
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|gprmask
expr_stmt|;
name|internal_a
operator|.
name|fprmask
operator|=
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|fprmask
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|internal_a
operator|.
name|cprmask
index|[
name|i
index|]
operator|=
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|cprmask
index|[
name|i
index|]
expr_stmt|;
comment|/* Let the backend adjust the headers if necessary.  */
if|if
condition|(
name|backend
operator|->
name|adjust_headers
condition|)
block|{
if|if
condition|(
operator|!
call|(
modifier|*
name|backend
operator|->
name|adjust_headers
call|)
argument_list|(
name|abfd
argument_list|,
operator|&
name|internal_f
argument_list|,
operator|&
name|internal_a
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
comment|/* Write out the file header and the optional header.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
name|bfd_coff_swap_filehdr_out
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|internal_f
argument_list|,
name|buff
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
name|buff
argument_list|,
name|filhsz
argument_list|,
name|abfd
argument_list|)
operator|!=
name|filhsz
condition|)
goto|goto
name|error_return
goto|;
name|bfd_coff_swap_aouthdr_out
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|internal_a
argument_list|,
name|buff
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
name|buff
argument_list|,
name|aoutsz
argument_list|,
name|abfd
argument_list|)
operator|!=
name|aoutsz
condition|)
goto|goto
name|error_return
goto|;
comment|/* Build the external symbol information.  This must be done before      writing out the relocs so that we know the symbol indices.  We      don't do this if this BFD was created by the backend linker,      since it will have already handled the symbols and relocs.  */
if|if
condition|(
operator|!
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|linker
condition|)
block|{
name|symhdr
operator|->
name|iextMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|issExtMax
operator|=
literal|0
expr_stmt|;
name|debug
operator|->
name|external_ext
operator|=
name|debug
operator|->
name|external_ext_end
operator|=
name|NULL
expr_stmt|;
name|debug
operator|->
name|ssext
operator|=
name|debug
operator|->
name|ssext_end
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|bfd_ecoff_debug_externals
argument_list|(
name|abfd
argument_list|,
name|debug
argument_list|,
operator|&
name|backend
operator|->
name|debug_swap
argument_list|,
operator|(
operator|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|EXEC_P
operator|)
operator|==
literal|0
operator|)
condition|?
name|true
else|:
name|false
operator|)
argument_list|,
name|ecoff_get_extr
argument_list|,
name|ecoff_set_index
argument_list|)
operator|==
name|false
condition|)
goto|goto
name|error_return
goto|;
comment|/* Write out the relocs.  */
for|for
control|(
name|current
operator|=
name|abfd
operator|->
name|sections
init|;
name|current
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|;
name|current
operator|=
name|current
operator|->
name|next
control|)
block|{
name|arelent
modifier|*
modifier|*
name|reloc_ptr_ptr
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|reloc_end
decl_stmt|;
name|char
modifier|*
name|out_ptr
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
if|if
condition|(
name|current
operator|->
name|reloc_count
operator|==
literal|0
condition|)
continue|continue;
name|amt
operator|=
name|current
operator|->
name|reloc_count
operator|*
name|external_reloc_size
expr_stmt|;
name|reloc_buff
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc_buff
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|reloc_ptr_ptr
operator|=
name|current
operator|->
name|orelocation
expr_stmt|;
name|reloc_end
operator|=
name|reloc_ptr_ptr
operator|+
name|current
operator|->
name|reloc_count
expr_stmt|;
name|out_ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|reloc_buff
expr_stmt|;
for|for
control|(
init|;
name|reloc_ptr_ptr
operator|<
name|reloc_end
condition|;
name|reloc_ptr_ptr
operator|++
operator|,
name|out_ptr
operator|+=
name|external_reloc_size
control|)
block|{
name|arelent
modifier|*
name|reloc
decl_stmt|;
name|asymbol
modifier|*
name|sym
decl_stmt|;
name|struct
name|internal_reloc
name|in
decl_stmt|;
name|memset
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|in
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|in
argument_list|)
expr_stmt|;
name|reloc
operator|=
operator|*
name|reloc_ptr_ptr
expr_stmt|;
name|sym
operator|=
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
expr_stmt|;
name|in
operator|.
name|r_vaddr
operator|=
operator|(
name|reloc
operator|->
name|address
operator|+
name|bfd_get_section_vma
argument_list|(
name|abfd
argument_list|,
name|current
argument_list|)
operator|)
expr_stmt|;
name|in
operator|.
name|r_type
operator|=
name|reloc
operator|->
name|howto
operator|->
name|type
expr_stmt|;
if|if
condition|(
operator|(
name|sym
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|==
literal|0
condition|)
block|{
name|in
operator|.
name|r_symndx
operator|=
name|ecoff_get_sym_index
argument_list|(
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
argument_list|)
expr_stmt|;
name|in
operator|.
name|r_extern
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".text"
argument_list|)
operator|==
literal|0
condition|)
name|in
operator|.
name|r_symndx
operator|=
name|RELOC_SECTION_TEXT
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".rdata"
argument_list|)
operator|==
literal|0
condition|)
name|in
operator|.
name|r_symndx
operator|=
name|RELOC_SECTION_RDATA
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".data"
argument_list|)
operator|==
literal|0
condition|)
name|in
operator|.
name|r_symndx
operator|=
name|RELOC_SECTION_DATA
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sdata"
argument_list|)
operator|==
literal|0
condition|)
name|in
operator|.
name|r_symndx
operator|=
name|RELOC_SECTION_SDATA
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sbss"
argument_list|)
operator|==
literal|0
condition|)
name|in
operator|.
name|r_symndx
operator|=
name|RELOC_SECTION_SBSS
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".bss"
argument_list|)
operator|==
literal|0
condition|)
name|in
operator|.
name|r_symndx
operator|=
name|RELOC_SECTION_BSS
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".init"
argument_list|)
operator|==
literal|0
condition|)
name|in
operator|.
name|r_symndx
operator|=
name|RELOC_SECTION_INIT
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".lit8"
argument_list|)
operator|==
literal|0
condition|)
name|in
operator|.
name|r_symndx
operator|=
name|RELOC_SECTION_LIT8
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".lit4"
argument_list|)
operator|==
literal|0
condition|)
name|in
operator|.
name|r_symndx
operator|=
name|RELOC_SECTION_LIT4
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".xdata"
argument_list|)
operator|==
literal|0
condition|)
name|in
operator|.
name|r_symndx
operator|=
name|RELOC_SECTION_XDATA
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".pdata"
argument_list|)
operator|==
literal|0
condition|)
name|in
operator|.
name|r_symndx
operator|=
name|RELOC_SECTION_PDATA
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".fini"
argument_list|)
operator|==
literal|0
condition|)
name|in
operator|.
name|r_symndx
operator|=
name|RELOC_SECTION_FINI
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".lita"
argument_list|)
operator|==
literal|0
condition|)
name|in
operator|.
name|r_symndx
operator|=
name|RELOC_SECTION_LITA
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"*ABS*"
argument_list|)
operator|==
literal|0
condition|)
name|in
operator|.
name|r_symndx
operator|=
name|RELOC_SECTION_ABS
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".rconst"
argument_list|)
operator|==
literal|0
condition|)
name|in
operator|.
name|r_symndx
operator|=
name|RELOC_SECTION_RCONST
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|in
operator|.
name|r_extern
operator|=
literal|0
expr_stmt|;
block|}
call|(
modifier|*
name|adjust_reloc_out
call|)
argument_list|(
name|abfd
argument_list|,
name|reloc
argument_list|,
operator|&
name|in
argument_list|)
expr_stmt|;
call|(
modifier|*
name|swap_reloc_out
call|)
argument_list|(
name|abfd
argument_list|,
operator|&
name|in
argument_list|,
operator|(
name|PTR
operator|)
name|out_ptr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|current
operator|->
name|rel_filepos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
name|amt
operator|=
name|current
operator|->
name|reloc_count
operator|*
name|external_reloc_size
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
name|reloc_buff
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
goto|goto
name|error_return
goto|;
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|reloc_buff
argument_list|)
expr_stmt|;
name|reloc_buff
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Write out the symbolic debugging information.  */
if|if
condition|(
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* Write out the debugging information.  */
if|if
condition|(
name|bfd_ecoff_write_debug
argument_list|(
name|abfd
argument_list|,
name|debug
argument_list|,
operator|&
name|backend
operator|->
name|debug_swap
argument_list|,
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|sym_filepos
argument_list|)
operator|==
name|false
condition|)
goto|goto
name|error_return
goto|;
block|}
block|}
comment|/* The .bss section of a demand paged executable must receive an      entire page.  If there are symbols, the symbols will start on the      next page.  If there are no symbols, we must fill out the page by      hand.  */
if|if
condition|(
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|abfd
operator|->
name|flags
operator|&
name|EXEC_P
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|abfd
operator|->
name|flags
operator|&
name|D_PAGED
operator|)
operator|!=
literal|0
condition|)
block|{
name|char
name|c
decl_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|sym_filepos
operator|-
literal|1
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|bfd_bread
argument_list|(
operator|&
name|c
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|1
argument_list|,
name|abfd
argument_list|)
operator|==
literal|0
condition|)
name|c
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|sym_filepos
operator|-
literal|1
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
operator|&
name|c
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|1
condition|)
goto|goto
name|error_return
goto|;
block|}
if|if
condition|(
name|reloc_buff
operator|!=
name|NULL
condition|)
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|reloc_buff
argument_list|)
expr_stmt|;
if|if
condition|(
name|buff
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|buff
argument_list|)
expr_stmt|;
return|return
name|true
return|;
name|error_return
label|:
if|if
condition|(
name|reloc_buff
operator|!=
name|NULL
condition|)
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|reloc_buff
argument_list|)
expr_stmt|;
if|if
condition|(
name|buff
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|buff
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Archive handling.  ECOFF uses what appears to be a unique type of    archive header (armap).  The byte ordering of the armap and the    contents are encoded in the name of the armap itself.  At least for    now, we only support archives with the same byte ordering in the    armap and the contents.     The first four bytes in the armap are the number of symbol    definitions.  This is always a power of two.     This is followed by the symbol definitions.  Each symbol definition    occupies 8 bytes.  The first four bytes are the offset from the    start of the armap strings to the null-terminated string naming    this symbol.  The second four bytes are the file offset to the    archive member which defines this symbol.  If the second four bytes    are 0, then this is not actually a symbol definition, and it should    be ignored.     The symbols are hashed into the armap with a closed hashing scheme.    See the functions below for the details of the algorithm.     After the symbol definitions comes four bytes holding the size of    the string table, followed by the string table itself.  */
end_comment

begin_comment
comment|/* The name of an archive headers looks like this:    __________E[BL]E[BL]_ (with a trailing space).    The trailing space is changed to an X if the archive is changed to    indicate that the armap is out of date.     The Alpha seems to use ________64E[BL]E[BL]_.  */
end_comment

begin_define
define|#
directive|define
name|ARMAP_BIG_ENDIAN
value|'B'
end_define

begin_define
define|#
directive|define
name|ARMAP_LITTLE_ENDIAN
value|'L'
end_define

begin_define
define|#
directive|define
name|ARMAP_MARKER
value|'E'
end_define

begin_define
define|#
directive|define
name|ARMAP_START_LENGTH
value|10
end_define

begin_define
define|#
directive|define
name|ARMAP_HEADER_MARKER_INDEX
value|10
end_define

begin_define
define|#
directive|define
name|ARMAP_HEADER_ENDIAN_INDEX
value|11
end_define

begin_define
define|#
directive|define
name|ARMAP_OBJECT_MARKER_INDEX
value|12
end_define

begin_define
define|#
directive|define
name|ARMAP_OBJECT_ENDIAN_INDEX
value|13
end_define

begin_define
define|#
directive|define
name|ARMAP_END_INDEX
value|14
end_define

begin_define
define|#
directive|define
name|ARMAP_END
value|"_ "
end_define

begin_comment
comment|/* This is a magic number used in the hashing algorithm.  */
end_comment

begin_define
define|#
directive|define
name|ARMAP_HASH_MAGIC
value|0x9dd68ab5
end_define

begin_comment
comment|/* This returns the hash value to use for a string.  It also sets    *REHASH to the rehash adjustment if the first slot is taken.  SIZE    is the number of entries in the hash table, and HLOG is the log    base 2 of SIZE.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|ecoff_armap_hash
parameter_list|(
name|s
parameter_list|,
name|rehash
parameter_list|,
name|size
parameter_list|,
name|hlog
parameter_list|)
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|unsigned
name|int
modifier|*
name|rehash
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
name|unsigned
name|int
name|hlog
decl_stmt|;
block|{
name|unsigned
name|int
name|hash
decl_stmt|;
if|if
condition|(
name|hlog
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|hash
operator|=
operator|*
name|s
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
name|hash
operator|=
operator|(
operator|(
name|hash
operator|>>
literal|27
operator|)
operator||
operator|(
name|hash
operator|<<
literal|5
operator|)
operator|)
operator|+
operator|*
name|s
operator|++
expr_stmt|;
name|hash
operator|*=
name|ARMAP_HASH_MAGIC
expr_stmt|;
operator|*
name|rehash
operator|=
operator|(
name|hash
operator|&
operator|(
name|size
operator|-
literal|1
operator|)
operator|)
operator||
literal|1
expr_stmt|;
return|return
name|hash
operator|>>
operator|(
literal|32
operator|-
name|hlog
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Read in the armap.  */
end_comment

begin_function
name|boolean
name|_bfd_ecoff_slurp_armap
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|char
name|nextname
index|[
literal|17
index|]
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|areltdata
modifier|*
name|mapdata
decl_stmt|;
name|bfd_size_type
name|parsed_size
decl_stmt|;
name|char
modifier|*
name|raw_armap
decl_stmt|;
name|struct
name|artdata
modifier|*
name|ardata
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
name|char
modifier|*
name|raw_ptr
decl_stmt|;
name|struct
name|symdef
modifier|*
name|symdef_ptr
decl_stmt|;
name|char
modifier|*
name|stringbase
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
comment|/* Get the name of the first element.  */
name|i
operator|=
name|bfd_bread
argument_list|(
operator|(
name|PTR
operator|)
name|nextname
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|16
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
name|true
return|;
if|if
condition|(
name|i
operator|!=
literal|16
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
operator|-
literal|16
argument_list|,
name|SEEK_CUR
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
comment|/* Irix 4.0.5F apparently can use either an ECOFF armap or a      standard COFF armap.  We could move the ECOFF armap stuff into      bfd_slurp_armap, but that seems inappropriate since no other      target uses this format.  Instead, we check directly for a COFF      armap.  */
if|if
condition|(
name|strncmp
argument_list|(
name|nextname
argument_list|,
literal|"/               "
argument_list|,
literal|16
argument_list|)
operator|==
literal|0
condition|)
return|return
name|bfd_slurp_armap
argument_list|(
name|abfd
argument_list|)
return|;
comment|/* See if the first element is an armap.  */
if|if
condition|(
name|strncmp
argument_list|(
name|nextname
argument_list|,
name|ecoff_backend
argument_list|(
name|abfd
argument_list|)
operator|->
name|armap_start
argument_list|,
name|ARMAP_START_LENGTH
argument_list|)
operator|!=
literal|0
operator|||
name|nextname
index|[
name|ARMAP_HEADER_MARKER_INDEX
index|]
operator|!=
name|ARMAP_MARKER
operator|||
operator|(
name|nextname
index|[
name|ARMAP_HEADER_ENDIAN_INDEX
index|]
operator|!=
name|ARMAP_BIG_ENDIAN
operator|&&
name|nextname
index|[
name|ARMAP_HEADER_ENDIAN_INDEX
index|]
operator|!=
name|ARMAP_LITTLE_ENDIAN
operator|)
operator|||
name|nextname
index|[
name|ARMAP_OBJECT_MARKER_INDEX
index|]
operator|!=
name|ARMAP_MARKER
operator|||
operator|(
name|nextname
index|[
name|ARMAP_OBJECT_ENDIAN_INDEX
index|]
operator|!=
name|ARMAP_BIG_ENDIAN
operator|&&
name|nextname
index|[
name|ARMAP_OBJECT_ENDIAN_INDEX
index|]
operator|!=
name|ARMAP_LITTLE_ENDIAN
operator|)
operator|||
name|strncmp
argument_list|(
name|nextname
operator|+
name|ARMAP_END_INDEX
argument_list|,
name|ARMAP_END
argument_list|,
sizeof|sizeof
name|ARMAP_END
operator|-
literal|1
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|bfd_has_map
argument_list|(
name|abfd
argument_list|)
operator|=
name|false
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* Make sure we have the right byte ordering.  */
if|if
condition|(
operator|(
operator|(
name|nextname
index|[
name|ARMAP_HEADER_ENDIAN_INDEX
index|]
operator|==
name|ARMAP_BIG_ENDIAN
operator|)
operator|^
operator|(
name|bfd_header_big_endian
argument_list|(
name|abfd
argument_list|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|nextname
index|[
name|ARMAP_OBJECT_ENDIAN_INDEX
index|]
operator|==
name|ARMAP_BIG_ENDIAN
operator|)
operator|^
operator|(
name|bfd_big_endian
argument_list|(
name|abfd
argument_list|)
operator|)
operator|)
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Read in the armap.  */
name|ardata
operator|=
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|mapdata
operator|=
operator|(
expr|struct
name|areltdata
operator|*
operator|)
name|_bfd_read_ar_hdr
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapdata
operator|==
operator|(
expr|struct
name|areltdata
operator|*
operator|)
name|NULL
condition|)
return|return
name|false
return|;
name|parsed_size
operator|=
name|mapdata
operator|->
name|parsed_size
expr_stmt|;
name|bfd_release
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|mapdata
argument_list|)
expr_stmt|;
name|raw_armap
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|parsed_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|raw_armap
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bfd_bread
argument_list|(
operator|(
name|PTR
operator|)
name|raw_armap
argument_list|,
name|parsed_size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|parsed_size
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_system_call
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_malformed_archive
argument_list|)
expr_stmt|;
name|bfd_release
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|raw_armap
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|ardata
operator|->
name|tdata
operator|=
operator|(
name|PTR
operator|)
name|raw_armap
expr_stmt|;
name|count
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|raw_armap
argument_list|)
expr_stmt|;
name|ardata
operator|->
name|symdef_count
operator|=
literal|0
expr_stmt|;
name|ardata
operator|->
name|cache
operator|=
operator|(
expr|struct
name|ar_cache
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* This code used to overlay the symdefs over the raw archive data,      but that doesn't work on a 64 bit host.  */
name|stringbase
operator|=
name|raw_armap
operator|+
name|count
operator|*
literal|8
operator|+
literal|8
expr_stmt|;
ifdef|#
directive|ifdef
name|CHECK_ARMAP_HASH
block|{
name|unsigned
name|int
name|hlog
decl_stmt|;
comment|/* Double check that I have the hashing algorithm right by making        sure that every symbol can be looked up successfully.  */
name|hlog
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|<<=
literal|1
control|)
name|hlog
operator|++
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|i
operator|==
name|count
argument_list|)
expr_stmt|;
name|raw_ptr
operator|=
name|raw_armap
operator|+
literal|4
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|raw_ptr
operator|+=
literal|8
control|)
block|{
name|unsigned
name|int
name|name_offset
decl_stmt|,
name|file_offset
decl_stmt|;
name|unsigned
name|int
name|hash
decl_stmt|,
name|rehash
decl_stmt|,
name|srch
decl_stmt|;
name|name_offset
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|raw_ptr
argument_list|)
expr_stmt|;
name|file_offset
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|raw_ptr
operator|+
literal|4
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_offset
operator|==
literal|0
condition|)
continue|continue;
name|hash
operator|=
name|ecoff_armap_hash
argument_list|(
name|stringbase
operator|+
name|name_offset
argument_list|,
operator|&
name|rehash
argument_list|,
name|count
argument_list|,
name|hlog
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash
operator|==
name|i
condition|)
continue|continue;
comment|/* See if we can rehash to this location.  */
for|for
control|(
name|srch
operator|=
operator|(
name|hash
operator|+
name|rehash
operator|)
operator|&
operator|(
name|count
operator|-
literal|1
operator|)
init|;
name|srch
operator|!=
name|hash
operator|&&
name|srch
operator|!=
name|i
condition|;
name|srch
operator|=
operator|(
name|srch
operator|+
name|rehash
operator|)
operator|&
operator|(
name|count
operator|-
literal|1
operator|)
control|)
name|BFD_ASSERT
argument_list|(
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|raw_armap
operator|+
literal|8
operator|+
name|srch
operator|*
literal|8
operator|)
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|srch
operator|==
name|i
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* CHECK_ARMAP_HASH */
name|raw_ptr
operator|=
name|raw_armap
operator|+
literal|4
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|raw_ptr
operator|+=
literal|8
control|)
if|if
condition|(
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|raw_ptr
operator|+
literal|4
operator|)
argument_list|)
operator|!=
literal|0
condition|)
operator|++
name|ardata
operator|->
name|symdef_count
expr_stmt|;
name|amt
operator|=
name|ardata
operator|->
name|symdef_count
expr_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
expr|struct
name|symdef
argument_list|)
expr_stmt|;
name|symdef_ptr
operator|=
operator|(
expr|struct
name|symdef
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|symdef_ptr
condition|)
return|return
name|false
return|;
name|ardata
operator|->
name|symdefs
operator|=
operator|(
name|carsym
operator|*
operator|)
name|symdef_ptr
expr_stmt|;
name|raw_ptr
operator|=
name|raw_armap
operator|+
literal|4
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|raw_ptr
operator|+=
literal|8
control|)
block|{
name|unsigned
name|int
name|name_offset
decl_stmt|,
name|file_offset
decl_stmt|;
name|file_offset
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|raw_ptr
operator|+
literal|4
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_offset
operator|==
literal|0
condition|)
continue|continue;
name|name_offset
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|raw_ptr
argument_list|)
expr_stmt|;
name|symdef_ptr
operator|->
name|s
operator|.
name|name
operator|=
name|stringbase
operator|+
name|name_offset
expr_stmt|;
name|symdef_ptr
operator|->
name|file_offset
operator|=
name|file_offset
expr_stmt|;
operator|++
name|symdef_ptr
expr_stmt|;
block|}
name|ardata
operator|->
name|first_file_filepos
operator|=
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* Pad to an even boundary.  */
name|ardata
operator|->
name|first_file_filepos
operator|+=
name|ardata
operator|->
name|first_file_filepos
operator|%
literal|2
expr_stmt|;
name|bfd_has_map
argument_list|(
name|abfd
argument_list|)
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Write out an armap.  */
end_comment

begin_function
name|boolean
name|_bfd_ecoff_write_armap
parameter_list|(
name|abfd
parameter_list|,
name|elength
parameter_list|,
name|map
parameter_list|,
name|orl_count
parameter_list|,
name|stridx
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|unsigned
name|int
name|elength
decl_stmt|;
name|struct
name|orl
modifier|*
name|map
decl_stmt|;
name|unsigned
name|int
name|orl_count
decl_stmt|;
name|int
name|stridx
decl_stmt|;
block|{
name|unsigned
name|int
name|hashsize
decl_stmt|,
name|hashlog
decl_stmt|;
name|bfd_size_type
name|symdefsize
decl_stmt|;
name|int
name|padit
decl_stmt|;
name|unsigned
name|int
name|stringsize
decl_stmt|;
name|unsigned
name|int
name|mapsize
decl_stmt|;
name|file_ptr
name|firstreal
decl_stmt|;
name|struct
name|ar_hdr
name|hdr
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|bfd_byte
name|temp
index|[
literal|4
index|]
decl_stmt|;
name|bfd_byte
modifier|*
name|hashtable
decl_stmt|;
name|bfd
modifier|*
name|current
decl_stmt|;
name|bfd
modifier|*
name|last_elt
decl_stmt|;
comment|/* Ultrix appears to use as a hash table size the least power of two      greater than twice the number of entries.  */
for|for
control|(
name|hashlog
operator|=
literal|0
init|;
operator|(
operator|(
name|unsigned
name|int
operator|)
literal|1
operator|<<
name|hashlog
operator|)
operator|<=
literal|2
operator|*
name|orl_count
condition|;
name|hashlog
operator|++
control|)
empty_stmt|;
name|hashsize
operator|=
literal|1
operator|<<
name|hashlog
expr_stmt|;
name|symdefsize
operator|=
name|hashsize
operator|*
literal|8
expr_stmt|;
name|padit
operator|=
name|stridx
operator|%
literal|2
expr_stmt|;
name|stringsize
operator|=
name|stridx
operator|+
name|padit
expr_stmt|;
comment|/* Include 8 bytes to store symdefsize and stringsize in output.  */
name|mapsize
operator|=
name|symdefsize
operator|+
name|stringsize
operator|+
literal|8
expr_stmt|;
name|firstreal
operator|=
name|SARMAG
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
operator|+
name|mapsize
operator|+
name|elength
expr_stmt|;
name|memset
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|hdr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|hdr
argument_list|)
expr_stmt|;
comment|/* Work out the ECOFF armap name.  */
name|strcpy
argument_list|(
name|hdr
operator|.
name|ar_name
argument_list|,
name|ecoff_backend
argument_list|(
name|abfd
argument_list|)
operator|->
name|armap_start
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|ar_name
index|[
name|ARMAP_HEADER_MARKER_INDEX
index|]
operator|=
name|ARMAP_MARKER
expr_stmt|;
name|hdr
operator|.
name|ar_name
index|[
name|ARMAP_HEADER_ENDIAN_INDEX
index|]
operator|=
operator|(
name|bfd_header_big_endian
argument_list|(
name|abfd
argument_list|)
condition|?
name|ARMAP_BIG_ENDIAN
else|:
name|ARMAP_LITTLE_ENDIAN
operator|)
expr_stmt|;
name|hdr
operator|.
name|ar_name
index|[
name|ARMAP_OBJECT_MARKER_INDEX
index|]
operator|=
name|ARMAP_MARKER
expr_stmt|;
name|hdr
operator|.
name|ar_name
index|[
name|ARMAP_OBJECT_ENDIAN_INDEX
index|]
operator|=
name|bfd_big_endian
argument_list|(
name|abfd
argument_list|)
condition|?
name|ARMAP_BIG_ENDIAN
else|:
name|ARMAP_LITTLE_ENDIAN
expr_stmt|;
name|memcpy
argument_list|(
name|hdr
operator|.
name|ar_name
operator|+
name|ARMAP_END_INDEX
argument_list|,
name|ARMAP_END
argument_list|,
sizeof|sizeof
name|ARMAP_END
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Write the timestamp of the archive header to be just a little bit      later than the timestamp of the file, otherwise the linker will      complain that the index is out of date.  Actually, the Ultrix      linker just checks the archive name; the GNU linker may check the      date.  */
name|stat
argument_list|(
name|abfd
operator|->
name|filename
argument_list|,
operator|&
name|statbuf
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|hdr
operator|.
name|ar_date
argument_list|,
literal|"%ld"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|statbuf
operator|.
name|st_mtime
operator|+
literal|60
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The DECstation uses zeroes for the uid, gid and mode of the      armap.  */
name|hdr
operator|.
name|ar_uid
index|[
literal|0
index|]
operator|=
literal|'0'
expr_stmt|;
name|hdr
operator|.
name|ar_gid
index|[
literal|0
index|]
operator|=
literal|'0'
expr_stmt|;
if|#
directive|if
literal|0
block|hdr.ar_mode[0] = '0';
else|#
directive|else
comment|/* Building gcc ends up extracting the armap as a file - twice.  */
name|hdr
operator|.
name|ar_mode
index|[
literal|0
index|]
operator|=
literal|'6'
expr_stmt|;
name|hdr
operator|.
name|ar_mode
index|[
literal|1
index|]
operator|=
literal|'4'
expr_stmt|;
name|hdr
operator|.
name|ar_mode
index|[
literal|2
index|]
operator|=
literal|'4'
expr_stmt|;
endif|#
directive|endif
name|sprintf
argument_list|(
name|hdr
operator|.
name|ar_size
argument_list|,
literal|"%-10d"
argument_list|,
operator|(
name|int
operator|)
name|mapsize
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|ar_fmag
index|[
literal|0
index|]
operator|=
literal|'`'
expr_stmt|;
name|hdr
operator|.
name|ar_fmag
index|[
literal|1
index|]
operator|=
literal|'\012'
expr_stmt|;
comment|/* Turn all null bytes in the header into spaces.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|hdr
operator|)
operator|)
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|hdr
operator|)
operator|)
index|[
name|i
index|]
operator|)
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|hdr
argument_list|,
operator|(
name|bfd_size_type
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
condition|)
return|return
name|false
return|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|hashsize
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
operator|(
name|PTR
operator|)
name|temp
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|4
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
condition|)
return|return
name|false
return|;
name|hashtable
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|symdefsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hashtable
condition|)
return|return
name|false
return|;
name|current
operator|=
name|abfd
operator|->
name|archive_head
expr_stmt|;
name|last_elt
operator|=
name|current
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|orl_count
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|hash
decl_stmt|,
name|rehash
decl_stmt|;
comment|/* Advance firstreal to the file position of this archive 	 element.  */
if|if
condition|(
name|map
index|[
name|i
index|]
operator|.
name|u
operator|.
name|abfd
operator|!=
name|last_elt
condition|)
block|{
do|do
block|{
name|firstreal
operator|+=
name|arelt_size
argument_list|(
name|current
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
expr_stmt|;
name|firstreal
operator|+=
name|firstreal
operator|%
literal|2
expr_stmt|;
name|current
operator|=
name|current
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|current
operator|!=
name|map
index|[
name|i
index|]
operator|.
name|u
operator|.
name|abfd
condition|)
do|;
block|}
name|last_elt
operator|=
name|current
expr_stmt|;
name|hash
operator|=
name|ecoff_armap_hash
argument_list|(
operator|*
name|map
index|[
name|i
index|]
operator|.
name|name
argument_list|,
operator|&
name|rehash
argument_list|,
name|hashsize
argument_list|,
name|hashlog
argument_list|)
expr_stmt|;
if|if
condition|(
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|hashtable
operator|+
operator|(
name|hash
operator|*
literal|8
operator|)
operator|+
literal|4
operator|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|int
name|srch
decl_stmt|;
comment|/* The desired slot is already taken.  */
for|for
control|(
name|srch
operator|=
operator|(
name|hash
operator|+
name|rehash
operator|)
operator|&
operator|(
name|hashsize
operator|-
literal|1
operator|)
init|;
name|srch
operator|!=
name|hash
condition|;
name|srch
operator|=
operator|(
name|srch
operator|+
name|rehash
operator|)
operator|&
operator|(
name|hashsize
operator|-
literal|1
operator|)
control|)
if|if
condition|(
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|hashtable
operator|+
operator|(
name|srch
operator|*
literal|8
operator|)
operator|+
literal|4
operator|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|BFD_ASSERT
argument_list|(
name|srch
operator|!=
name|hash
argument_list|)
expr_stmt|;
name|hash
operator|=
name|srch
expr_stmt|;
block|}
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|map
index|[
name|i
index|]
operator|.
name|namidx
argument_list|,
operator|(
name|hashtable
operator|+
name|hash
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|firstreal
argument_list|,
operator|(
name|hashtable
operator|+
name|hash
operator|*
literal|8
operator|+
literal|4
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bfd_bwrite
argument_list|(
operator|(
name|PTR
operator|)
name|hashtable
argument_list|,
name|symdefsize
argument_list|,
name|abfd
argument_list|)
operator|!=
name|symdefsize
condition|)
return|return
name|false
return|;
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|hashtable
argument_list|)
expr_stmt|;
comment|/* Now write the strings.  */
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|stringsize
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
operator|(
name|PTR
operator|)
name|temp
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|4
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
condition|)
return|return
name|false
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|orl_count
condition|;
name|i
operator|++
control|)
block|{
name|bfd_size_type
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
operator|*
name|map
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
call|(
name|PTR
call|)
argument_list|(
operator|*
name|map
index|[
name|i
index|]
operator|.
name|name
argument_list|)
argument_list|,
name|len
argument_list|,
name|abfd
argument_list|)
operator|!=
name|len
condition|)
return|return
name|false
return|;
block|}
comment|/* The spec sez this should be a newline.  But in order to be      bug-compatible for DECstation ar we use a null.  */
if|if
condition|(
name|padit
condition|)
block|{
if|if
condition|(
name|bfd_bwrite
argument_list|(
literal|""
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|1
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* See whether this BFD is an archive.  If it is, read in the armap    and the extended name table.  */
end_comment

begin_function
specifier|const
name|bfd_target
modifier|*
name|_bfd_ecoff_archive_p
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|artdata
modifier|*
name|tdata_hold
decl_stmt|;
name|char
name|armag
index|[
name|SARMAG
operator|+
literal|1
index|]
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|tdata_hold
operator|=
name|abfd
operator|->
name|tdata
operator|.
name|aout_ar_data
expr_stmt|;
if|if
condition|(
name|bfd_bread
argument_list|(
operator|(
name|PTR
operator|)
name|armag
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|SARMAG
argument_list|,
name|abfd
argument_list|)
operator|!=
name|SARMAG
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_system_call
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
operator|(
specifier|const
name|bfd_target
operator|*
operator|)
name|NULL
return|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|armag
argument_list|,
name|ARMAG
argument_list|,
name|SARMAG
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* We are setting bfd_ardata(abfd) here, but since bfd_ardata      involves a cast, we can't do it as the left operand of      assignment.  */
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|artdata
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|aout_ar_data
operator|=
operator|(
expr|struct
name|artdata
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|==
operator|(
expr|struct
name|artdata
operator|*
operator|)
name|NULL
condition|)
block|{
name|abfd
operator|->
name|tdata
operator|.
name|aout_ar_data
operator|=
name|tdata_hold
expr_stmt|;
return|return
operator|(
specifier|const
name|bfd_target
operator|*
operator|)
name|NULL
return|;
block|}
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|first_file_filepos
operator|=
name|SARMAG
expr_stmt|;
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|cache
operator|=
name|NULL
expr_stmt|;
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|archive_head
operator|=
name|NULL
expr_stmt|;
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symdefs
operator|=
name|NULL
expr_stmt|;
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|extended_names
operator|=
name|NULL
expr_stmt|;
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|tdata
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|_bfd_ecoff_slurp_armap
argument_list|(
name|abfd
argument_list|)
operator|==
name|false
operator|||
name|_bfd_ecoff_slurp_extended_name_table
argument_list|(
name|abfd
argument_list|)
operator|==
name|false
condition|)
block|{
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|aout_ar_data
operator|=
name|tdata_hold
expr_stmt|;
return|return
operator|(
specifier|const
name|bfd_target
operator|*
operator|)
name|NULL
return|;
block|}
if|if
condition|(
name|bfd_has_map
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|bfd
modifier|*
name|first
decl_stmt|;
comment|/* This archive has a map, so we may presume that the contents 	 are object files.  Make sure that if the first file in the 	 archive can be recognized as an object file, it is for this 	 target.  If not, assume that this is the wrong format.  If 	 the first file is not an object file, somebody is doing 	 something weird, and we permit it so that ar -t will work.  */
name|first
operator|=
name|bfd_openr_next_archived_file
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
operator|!=
name|NULL
condition|)
block|{
name|boolean
name|fail
decl_stmt|;
name|first
operator|->
name|target_defaulted
operator|=
name|false
expr_stmt|;
name|fail
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|bfd_check_format
argument_list|(
name|first
argument_list|,
name|bfd_object
argument_list|)
operator|&&
name|first
operator|->
name|xvec
operator|!=
name|abfd
operator|->
name|xvec
condition|)
block|{
operator|(
name|void
operator|)
name|bfd_close
argument_list|(
name|first
argument_list|)
expr_stmt|;
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|aout_ar_data
operator|=
name|tdata_hold
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* We ought to close first here, but we can't, because we              have no way to remove it from the archive cache.  FIXME.  */
block|}
block|}
return|return
name|abfd
operator|->
name|xvec
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ECOFF linker code.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|ecoff_link_hash_newfunc
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
name|entry
operator|,
expr|struct
name|bfd_hash_table
operator|*
name|table
operator|,
specifier|const
name|char
operator|*
name|string
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ecoff_link_add_archive_symbols
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ecoff_link_check_archive_element
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|boolean
operator|*
name|pneeded
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ecoff_link_add_object_symbols
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ecoff_link_add_externals
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|PTR
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Routine to create an entry in an ECOFF link hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|ecoff_link_hash_newfunc
parameter_list|(
name|entry
parameter_list|,
name|table
parameter_list|,
name|string
parameter_list|)
name|struct
name|bfd_hash_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|bfd_hash_table
modifier|*
name|table
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|struct
name|ecoff_link_hash_entry
modifier|*
name|ret
init|=
operator|(
expr|struct
name|ecoff_link_hash_entry
operator|*
operator|)
name|entry
decl_stmt|;
comment|/* Allocate the structure if it has not already been allocated by a      subclass.  */
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|ecoff_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
name|ret
operator|=
operator|(
operator|(
expr|struct
name|ecoff_link_hash_entry
operator|*
operator|)
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ecoff_link_hash_entry
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|ecoff_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* Call the allocation method of the superclass.  */
name|ret
operator|=
operator|(
operator|(
expr|struct
name|ecoff_link_hash_entry
operator|*
operator|)
name|_bfd_link_hash_newfunc
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
comment|/* Set local fields.  */
name|ret
operator|->
name|indx
operator|=
operator|-
literal|1
expr_stmt|;
name|ret
operator|->
name|abfd
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|written
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|small
operator|=
literal|0
expr_stmt|;
block|}
name|memset
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|ret
operator|->
name|esym
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ret
operator|->
name|esym
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Create an ECOFF link hash table.  */
end_comment

begin_function
name|struct
name|bfd_link_hash_table
modifier|*
name|_bfd_ecoff_bfd_link_hash_table_create
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|ecoff_link_hash_table
modifier|*
name|ret
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|ecoff_link_hash_table
argument_list|)
decl_stmt|;
name|ret
operator|=
operator|(
expr|struct
name|ecoff_link_hash_table
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|_bfd_link_hash_table_init
argument_list|(
operator|&
name|ret
operator|->
name|root
argument_list|,
name|abfd
argument_list|,
name|ecoff_link_hash_newfunc
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|bfd_link_hash_table
operator|*
operator|)
name|NULL
return|;
block|}
return|return
operator|&
name|ret
operator|->
name|root
return|;
block|}
end_function

begin_comment
comment|/* Look up an entry in an ECOFF link hash table.  */
end_comment

begin_define
define|#
directive|define
name|ecoff_link_hash_lookup
parameter_list|(
name|table
parameter_list|,
name|string
parameter_list|,
name|create
parameter_list|,
name|copy
parameter_list|,
name|follow
parameter_list|)
define|\
value|((struct ecoff_link_hash_entry *) \    bfd_link_hash_lookup (&(table)->root, (string), (create), (copy), (follow)))
end_define

begin_comment
comment|/* Traverse an ECOFF link hash table.  */
end_comment

begin_define
define|#
directive|define
name|ecoff_link_hash_traverse
parameter_list|(
name|table
parameter_list|,
name|func
parameter_list|,
name|info
parameter_list|)
define|\
value|(bfd_link_hash_traverse						\    (&(table)->root,							\     (boolean (*) PARAMS ((struct bfd_link_hash_entry *, PTR))) (func),	\     (info)))
end_define

begin_comment
comment|/* Get the ECOFF link hash table from the info structure.  This is    just a cast.  */
end_comment

begin_define
define|#
directive|define
name|ecoff_hash_table
parameter_list|(
name|p
parameter_list|)
value|((struct ecoff_link_hash_table *) ((p)->hash))
end_define

begin_comment
comment|/* Given an ECOFF BFD, add symbols to the global hash table as    appropriate.  */
end_comment

begin_function
name|boolean
name|_bfd_ecoff_bfd_link_add_symbols
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
switch|switch
condition|(
name|bfd_get_format
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
case|case
name|bfd_object
case|:
return|return
name|ecoff_link_add_object_symbols
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
return|;
case|case
name|bfd_archive
case|:
return|return
name|ecoff_link_add_archive_symbols
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
return|;
default|default:
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
end_function

begin_comment
comment|/* Add the symbols from an archive file to the global hash table.    This looks through the undefined symbols, looks each one up in the    archive hash table, and adds any associated object file.  We do not    use _bfd_generic_link_add_archive_symbols because ECOFF archives    already have a hash table, so there is no reason to construct    another one.  */
end_comment

begin_function
specifier|static
name|boolean
name|ecoff_link_add_archive_symbols
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
specifier|const
name|struct
name|ecoff_backend_data
modifier|*
specifier|const
name|backend
init|=
name|ecoff_backend
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
specifier|const
name|bfd_byte
modifier|*
name|raw_armap
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
modifier|*
name|pundef
decl_stmt|;
name|unsigned
name|int
name|armap_count
decl_stmt|;
name|unsigned
name|int
name|armap_log
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
specifier|const
name|bfd_byte
modifier|*
name|hashtable
decl_stmt|;
specifier|const
name|char
modifier|*
name|stringbase
decl_stmt|;
if|if
condition|(
operator|!
name|bfd_has_map
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
comment|/* An empty archive is a special case.  */
if|if
condition|(
name|bfd_openr_next_archived_file
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd
operator|*
operator|)
name|NULL
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|true
return|;
name|bfd_set_error
argument_list|(
name|bfd_error_no_armap
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* If we don't have any raw data for this archive, as can happen on      Irix 4.0.5F, we call the generic routine.      FIXME: We should be more clever about this, since someday tdata      may get to something for a generic archive.  */
name|raw_armap
operator|=
operator|(
specifier|const
name|bfd_byte
operator|*
operator|)
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|tdata
expr_stmt|;
if|if
condition|(
name|raw_armap
operator|==
operator|(
name|bfd_byte
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|_bfd_generic_link_add_archive_symbols
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|ecoff_link_check_archive_element
argument_list|)
operator|)
return|;
name|armap_count
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|raw_armap
argument_list|)
expr_stmt|;
name|armap_log
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|armap_count
condition|;
name|i
operator|<<=
literal|1
control|)
name|armap_log
operator|++
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|i
operator|==
name|armap_count
argument_list|)
expr_stmt|;
name|hashtable
operator|=
name|raw_armap
operator|+
literal|4
expr_stmt|;
name|stringbase
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|raw_armap
operator|+
name|armap_count
operator|*
literal|8
operator|+
literal|8
expr_stmt|;
comment|/* Look through the list of undefined symbols.  */
name|pundef
operator|=
operator|&
name|info
operator|->
name|hash
operator|->
name|undefs
expr_stmt|;
while|while
condition|(
operator|*
name|pundef
operator|!=
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
block|{
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|unsigned
name|int
name|hash
decl_stmt|,
name|rehash
decl_stmt|;
name|unsigned
name|int
name|file_offset
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bfd
modifier|*
name|element
decl_stmt|;
name|h
operator|=
operator|*
name|pundef
expr_stmt|;
comment|/* When a symbol is defined, it is not necessarily removed from 	 the list.  */
if|if
condition|(
name|h
operator|->
name|type
operator|!=
name|bfd_link_hash_undefined
operator|&&
name|h
operator|->
name|type
operator|!=
name|bfd_link_hash_common
condition|)
block|{
comment|/* Remove this entry from the list, for general cleanliness 	     and because we are going to look through the list again 	     if we search any more libraries.  We can't remove the 	     entry if it is the tail, because that would lose any 	     entries we add to the list later on.  */
if|if
condition|(
operator|*
name|pundef
operator|!=
name|info
operator|->
name|hash
operator|->
name|undefs_tail
condition|)
operator|*
name|pundef
operator|=
operator|(
operator|*
name|pundef
operator|)
operator|->
name|next
expr_stmt|;
else|else
name|pundef
operator|=
operator|&
operator|(
operator|*
name|pundef
operator|)
operator|->
name|next
expr_stmt|;
continue|continue;
block|}
comment|/* Native ECOFF linkers do not pull in archive elements merely 	 to satisfy common definitions, so neither do we.  We leave 	 them on the list, though, in case we are linking against some 	 other object format.  */
if|if
condition|(
name|h
operator|->
name|type
operator|!=
name|bfd_link_hash_undefined
condition|)
block|{
name|pundef
operator|=
operator|&
operator|(
operator|*
name|pundef
operator|)
operator|->
name|next
expr_stmt|;
continue|continue;
block|}
comment|/* Look for this symbol in the archive hash table.  */
name|hash
operator|=
name|ecoff_armap_hash
argument_list|(
name|h
operator|->
name|root
operator|.
name|string
argument_list|,
operator|&
name|rehash
argument_list|,
name|armap_count
argument_list|,
name|armap_log
argument_list|)
expr_stmt|;
name|file_offset
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|hashtable
operator|+
operator|(
name|hash
operator|*
literal|8
operator|)
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_offset
operator|==
literal|0
condition|)
block|{
comment|/* Nothing in this slot.  */
name|pundef
operator|=
operator|&
operator|(
operator|*
name|pundef
operator|)
operator|->
name|next
expr_stmt|;
continue|continue;
block|}
name|name
operator|=
name|stringbase
operator|+
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|hashtable
operator|+
operator|(
name|hash
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|!=
name|h
operator|->
name|root
operator|.
name|string
index|[
literal|0
index|]
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
name|h
operator|->
name|root
operator|.
name|string
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|int
name|srch
decl_stmt|;
name|boolean
name|found
decl_stmt|;
comment|/* That was the wrong symbol.  Try rehashing.  */
name|found
operator|=
name|false
expr_stmt|;
for|for
control|(
name|srch
operator|=
operator|(
name|hash
operator|+
name|rehash
operator|)
operator|&
operator|(
name|armap_count
operator|-
literal|1
operator|)
init|;
name|srch
operator|!=
name|hash
condition|;
name|srch
operator|=
operator|(
name|srch
operator|+
name|rehash
operator|)
operator|&
operator|(
name|armap_count
operator|-
literal|1
operator|)
control|)
block|{
name|file_offset
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|hashtable
operator|+
operator|(
name|srch
operator|*
literal|8
operator|)
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_offset
operator|==
literal|0
condition|)
break|break;
name|name
operator|=
name|stringbase
operator|+
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|hashtable
operator|+
operator|(
name|srch
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
name|h
operator|->
name|root
operator|.
name|string
index|[
literal|0
index|]
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|h
operator|->
name|root
operator|.
name|string
argument_list|)
operator|==
literal|0
condition|)
block|{
name|found
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|pundef
operator|=
operator|&
operator|(
operator|*
name|pundef
operator|)
operator|->
name|next
expr_stmt|;
continue|continue;
block|}
name|hash
operator|=
name|srch
expr_stmt|;
block|}
name|element
operator|=
call|(
modifier|*
name|backend
operator|->
name|get_elt_at_filepos
call|)
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
name|file_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|element
operator|==
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|bfd_check_format
argument_list|(
name|element
argument_list|,
name|bfd_object
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Unlike the generic linker, we know that this element provides 	 a definition for an undefined symbol and we know that we want 	 to include it.  We don't need to check anything.  */
if|if
condition|(
operator|!
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|add_archive_element
call|)
argument_list|(
name|info
argument_list|,
name|element
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|ecoff_link_add_object_symbols
argument_list|(
name|element
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|false
return|;
name|pundef
operator|=
operator|&
operator|(
operator|*
name|pundef
operator|)
operator|->
name|next
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* This is called if we used _bfd_generic_link_add_archive_symbols    because we were not dealing with an ECOFF archive.  */
end_comment

begin_function
specifier|static
name|boolean
name|ecoff_link_check_archive_element
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|pneeded
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|boolean
modifier|*
name|pneeded
decl_stmt|;
block|{
specifier|const
name|struct
name|ecoff_backend_data
modifier|*
specifier|const
name|backend
init|=
name|ecoff_backend
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|void
argument_list|(
argument|* const swap_ext_in
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|EXTR
operator|*
operator|)
argument_list|)
operator|=
name|backend
operator|->
name|debug_swap
operator|.
name|swap_ext_in
expr_stmt|;
name|HDRR
modifier|*
name|symhdr
decl_stmt|;
name|bfd_size_type
name|external_ext_size
decl_stmt|;
name|PTR
name|external_ext
init|=
name|NULL
decl_stmt|;
name|bfd_size_type
name|esize
decl_stmt|;
name|char
modifier|*
name|ssext
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|ext_ptr
decl_stmt|;
name|char
modifier|*
name|ext_end
decl_stmt|;
operator|*
name|pneeded
operator|=
name|false
expr_stmt|;
if|if
condition|(
operator|!
name|ecoff_slurp_symbolic_header
argument_list|(
name|abfd
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* If there are no symbols, we don't want it.  */
if|if
condition|(
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|successful_return
goto|;
name|symhdr
operator|=
operator|&
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|debug_info
operator|.
name|symbolic_header
expr_stmt|;
comment|/* Read in the external symbols and external strings.  */
name|external_ext_size
operator|=
name|backend
operator|->
name|debug_swap
operator|.
name|external_ext_size
expr_stmt|;
name|esize
operator|=
name|symhdr
operator|->
name|iextMax
operator|*
name|external_ext_size
expr_stmt|;
name|external_ext
operator|=
operator|(
name|PTR
operator|)
name|bfd_malloc
argument_list|(
name|esize
argument_list|)
expr_stmt|;
if|if
condition|(
name|external_ext
operator|==
name|NULL
operator|&&
name|esize
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
name|symhdr
operator|->
name|cbExtOffset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bread
argument_list|(
name|external_ext
argument_list|,
name|esize
argument_list|,
name|abfd
argument_list|)
operator|!=
name|esize
condition|)
goto|goto
name|error_return
goto|;
name|ssext
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_malloc
argument_list|(
operator|(
name|bfd_size_type
operator|)
name|symhdr
operator|->
name|issExtMax
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssext
operator|==
name|NULL
operator|&&
name|symhdr
operator|->
name|issExtMax
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
name|symhdr
operator|->
name|cbSsExtOffset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|bfd_bread
argument_list|(
name|ssext
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|symhdr
operator|->
name|issExtMax
argument_list|,
name|abfd
argument_list|)
operator|!=
operator|(
name|bfd_size_type
operator|)
name|symhdr
operator|->
name|issExtMax
operator|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* Look through the external symbols to see if they define some      symbol that is currently undefined.  */
name|ext_ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|external_ext
expr_stmt|;
name|ext_end
operator|=
name|ext_ptr
operator|+
name|esize
expr_stmt|;
for|for
control|(
init|;
name|ext_ptr
operator|<
name|ext_end
condition|;
name|ext_ptr
operator|+=
name|external_ext_size
control|)
block|{
name|EXTR
name|esym
decl_stmt|;
name|boolean
name|def
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
call|(
modifier|*
name|swap_ext_in
call|)
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|ext_ptr
argument_list|,
operator|&
name|esym
argument_list|)
expr_stmt|;
comment|/* See if this symbol defines something.  */
if|if
condition|(
name|esym
operator|.
name|asym
operator|.
name|st
operator|!=
name|stGlobal
operator|&&
name|esym
operator|.
name|asym
operator|.
name|st
operator|!=
name|stLabel
operator|&&
name|esym
operator|.
name|asym
operator|.
name|st
operator|!=
name|stProc
condition|)
continue|continue;
switch|switch
condition|(
name|esym
operator|.
name|asym
operator|.
name|sc
condition|)
block|{
case|case
name|scText
case|:
case|case
name|scData
case|:
case|case
name|scBss
case|:
case|case
name|scAbs
case|:
case|case
name|scSData
case|:
case|case
name|scSBss
case|:
case|case
name|scRData
case|:
case|case
name|scCommon
case|:
case|case
name|scSCommon
case|:
case|case
name|scInit
case|:
case|case
name|scFini
case|:
case|case
name|scRConst
case|:
name|def
operator|=
name|true
expr_stmt|;
break|break;
default|default:
name|def
operator|=
name|false
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|def
condition|)
continue|continue;
name|name
operator|=
name|ssext
operator|+
name|esym
operator|.
name|asym
operator|.
name|iss
expr_stmt|;
name|h
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|info
operator|->
name|hash
argument_list|,
name|name
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* Unlike the generic linker, we do not pull in elements because 	 of common symbols.  */
if|if
condition|(
name|h
operator|==
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|)
name|NULL
operator|||
name|h
operator|->
name|type
operator|!=
name|bfd_link_hash_undefined
condition|)
continue|continue;
comment|/* Include this element.  */
if|if
condition|(
operator|!
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|add_archive_element
call|)
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
name|name
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|ecoff_link_add_externals
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|external_ext
argument_list|,
name|ssext
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
operator|*
name|pneeded
operator|=
name|true
expr_stmt|;
goto|goto
name|successful_return
goto|;
block|}
name|successful_return
label|:
if|if
condition|(
name|external_ext
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|external_ext
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssext
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ssext
argument_list|)
expr_stmt|;
return|return
name|true
return|;
name|error_return
label|:
if|if
condition|(
name|external_ext
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|external_ext
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssext
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ssext
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Add symbols from an ECOFF object file to the global linker hash    table.  */
end_comment

begin_function
specifier|static
name|boolean
name|ecoff_link_add_object_symbols
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|HDRR
modifier|*
name|symhdr
decl_stmt|;
name|bfd_size_type
name|external_ext_size
decl_stmt|;
name|PTR
name|external_ext
init|=
name|NULL
decl_stmt|;
name|bfd_size_type
name|esize
decl_stmt|;
name|char
modifier|*
name|ssext
init|=
name|NULL
decl_stmt|;
name|boolean
name|result
decl_stmt|;
if|if
condition|(
operator|!
name|ecoff_slurp_symbolic_header
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* If there are no symbols, we don't want it.  */
if|if
condition|(
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|==
literal|0
condition|)
return|return
name|true
return|;
name|symhdr
operator|=
operator|&
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|debug_info
operator|.
name|symbolic_header
expr_stmt|;
comment|/* Read in the external symbols and external strings.  */
name|external_ext_size
operator|=
name|ecoff_backend
argument_list|(
name|abfd
argument_list|)
operator|->
name|debug_swap
operator|.
name|external_ext_size
expr_stmt|;
name|esize
operator|=
name|symhdr
operator|->
name|iextMax
operator|*
name|external_ext_size
expr_stmt|;
name|external_ext
operator|=
operator|(
name|PTR
operator|)
name|bfd_malloc
argument_list|(
name|esize
argument_list|)
expr_stmt|;
if|if
condition|(
name|external_ext
operator|==
name|NULL
operator|&&
name|esize
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
name|symhdr
operator|->
name|cbExtOffset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bread
argument_list|(
name|external_ext
argument_list|,
name|esize
argument_list|,
name|abfd
argument_list|)
operator|!=
name|esize
condition|)
goto|goto
name|error_return
goto|;
name|ssext
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_malloc
argument_list|(
operator|(
name|bfd_size_type
operator|)
name|symhdr
operator|->
name|issExtMax
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssext
operator|==
name|NULL
operator|&&
name|symhdr
operator|->
name|issExtMax
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
name|symhdr
operator|->
name|cbSsExtOffset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|bfd_bread
argument_list|(
name|ssext
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|symhdr
operator|->
name|issExtMax
argument_list|,
name|abfd
argument_list|)
operator|!=
operator|(
name|bfd_size_type
operator|)
name|symhdr
operator|->
name|issExtMax
operator|)
condition|)
goto|goto
name|error_return
goto|;
name|result
operator|=
name|ecoff_link_add_externals
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|external_ext
argument_list|,
name|ssext
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssext
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ssext
argument_list|)
expr_stmt|;
if|if
condition|(
name|external_ext
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|external_ext
argument_list|)
expr_stmt|;
return|return
name|result
return|;
name|error_return
label|:
if|if
condition|(
name|ssext
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ssext
argument_list|)
expr_stmt|;
if|if
condition|(
name|external_ext
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|external_ext
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Add the external symbols of an object file to the global linker    hash table.  The external symbols and strings we are passed are    just allocated on the stack, and will be discarded.  We must    explicitly save any information we may need later on in the link.    We do not want to read the external symbol information again.  */
end_comment

begin_function
specifier|static
name|boolean
name|ecoff_link_add_externals
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|external_ext
parameter_list|,
name|ssext
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|PTR
name|external_ext
decl_stmt|;
name|char
modifier|*
name|ssext
decl_stmt|;
block|{
specifier|const
name|struct
name|ecoff_backend_data
modifier|*
specifier|const
name|backend
init|=
name|ecoff_backend
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|void
argument_list|(
argument|* const swap_ext_in
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|EXTR
operator|*
operator|)
argument_list|)
operator|=
name|backend
operator|->
name|debug_swap
operator|.
name|swap_ext_in
expr_stmt|;
name|bfd_size_type
name|external_ext_size
init|=
name|backend
operator|->
name|debug_swap
operator|.
name|external_ext_size
decl_stmt|;
name|unsigned
name|long
name|ext_count
decl_stmt|;
name|struct
name|ecoff_link_hash_entry
modifier|*
modifier|*
name|sym_hash
decl_stmt|;
name|char
modifier|*
name|ext_ptr
decl_stmt|;
name|char
modifier|*
name|ext_end
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|ext_count
operator|=
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|debug_info
operator|.
name|symbolic_header
operator|.
name|iextMax
expr_stmt|;
name|amt
operator|=
name|ext_count
expr_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
expr|struct
name|bfd_link_hash_entry
operator|*
argument_list|)
expr_stmt|;
name|sym_hash
operator|=
operator|(
expr|struct
name|ecoff_link_hash_entry
operator|*
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sym_hash
condition|)
return|return
name|false
return|;
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|sym_hashes
operator|=
name|sym_hash
expr_stmt|;
name|ext_ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|external_ext
expr_stmt|;
name|ext_end
operator|=
name|ext_ptr
operator|+
name|ext_count
operator|*
name|external_ext_size
expr_stmt|;
for|for
control|(
init|;
name|ext_ptr
operator|<
name|ext_end
condition|;
name|ext_ptr
operator|+=
name|external_ext_size
operator|,
name|sym_hash
operator|++
control|)
block|{
name|EXTR
name|esym
decl_stmt|;
name|boolean
name|skip
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|ecoff_link_hash_entry
modifier|*
name|h
decl_stmt|;
operator|*
name|sym_hash
operator|=
name|NULL
expr_stmt|;
call|(
modifier|*
name|swap_ext_in
call|)
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|ext_ptr
argument_list|,
operator|&
name|esym
argument_list|)
expr_stmt|;
comment|/* Skip debugging symbols.  */
name|skip
operator|=
name|false
expr_stmt|;
switch|switch
condition|(
name|esym
operator|.
name|asym
operator|.
name|st
condition|)
block|{
case|case
name|stGlobal
case|:
case|case
name|stStatic
case|:
case|case
name|stLabel
case|:
case|case
name|stProc
case|:
case|case
name|stStaticProc
case|:
break|break;
default|default:
name|skip
operator|=
name|true
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|skip
condition|)
continue|continue;
comment|/* Get the information for this symbol.  */
name|value
operator|=
name|esym
operator|.
name|asym
operator|.
name|value
expr_stmt|;
switch|switch
condition|(
name|esym
operator|.
name|asym
operator|.
name|sc
condition|)
block|{
default|default:
case|case
name|scNil
case|:
case|case
name|scRegister
case|:
case|case
name|scCdbLocal
case|:
case|case
name|scBits
case|:
case|case
name|scCdbSystem
case|:
case|case
name|scRegImage
case|:
case|case
name|scInfo
case|:
case|case
name|scUserStruct
case|:
case|case
name|scVar
case|:
case|case
name|scVarRegister
case|:
case|case
name|scVariant
case|:
case|case
name|scBasedVar
case|:
case|case
name|scXData
case|:
case|case
name|scPData
case|:
name|section
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|scText
case|:
name|section
operator|=
name|bfd_make_section_old_way
argument_list|(
name|abfd
argument_list|,
literal|".text"
argument_list|)
expr_stmt|;
name|value
operator|-=
name|section
operator|->
name|vma
expr_stmt|;
break|break;
case|case
name|scData
case|:
name|section
operator|=
name|bfd_make_section_old_way
argument_list|(
name|abfd
argument_list|,
literal|".data"
argument_list|)
expr_stmt|;
name|value
operator|-=
name|section
operator|->
name|vma
expr_stmt|;
break|break;
case|case
name|scBss
case|:
name|section
operator|=
name|bfd_make_section_old_way
argument_list|(
name|abfd
argument_list|,
literal|".bss"
argument_list|)
expr_stmt|;
name|value
operator|-=
name|section
operator|->
name|vma
expr_stmt|;
break|break;
case|case
name|scAbs
case|:
name|section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
break|break;
case|case
name|scUndefined
case|:
name|section
operator|=
name|bfd_und_section_ptr
expr_stmt|;
break|break;
case|case
name|scSData
case|:
name|section
operator|=
name|bfd_make_section_old_way
argument_list|(
name|abfd
argument_list|,
literal|".sdata"
argument_list|)
expr_stmt|;
name|value
operator|-=
name|section
operator|->
name|vma
expr_stmt|;
break|break;
case|case
name|scSBss
case|:
name|section
operator|=
name|bfd_make_section_old_way
argument_list|(
name|abfd
argument_list|,
literal|".sbss"
argument_list|)
expr_stmt|;
name|value
operator|-=
name|section
operator|->
name|vma
expr_stmt|;
break|break;
case|case
name|scRData
case|:
name|section
operator|=
name|bfd_make_section_old_way
argument_list|(
name|abfd
argument_list|,
literal|".rdata"
argument_list|)
expr_stmt|;
name|value
operator|-=
name|section
operator|->
name|vma
expr_stmt|;
break|break;
case|case
name|scCommon
case|:
if|if
condition|(
name|value
operator|>
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|gp_size
condition|)
block|{
name|section
operator|=
name|bfd_com_section_ptr
expr_stmt|;
break|break;
block|}
comment|/* Fall through.  */
case|case
name|scSCommon
case|:
if|if
condition|(
name|ecoff_scom_section
operator|.
name|name
operator|==
name|NULL
condition|)
block|{
comment|/* Initialize the small common section.  */
name|ecoff_scom_section
operator|.
name|name
operator|=
name|SCOMMON
expr_stmt|;
name|ecoff_scom_section
operator|.
name|flags
operator|=
name|SEC_IS_COMMON
expr_stmt|;
name|ecoff_scom_section
operator|.
name|output_section
operator|=
operator|&
name|ecoff_scom_section
expr_stmt|;
name|ecoff_scom_section
operator|.
name|symbol
operator|=
operator|&
name|ecoff_scom_symbol
expr_stmt|;
name|ecoff_scom_section
operator|.
name|symbol_ptr_ptr
operator|=
operator|&
name|ecoff_scom_symbol_ptr
expr_stmt|;
name|ecoff_scom_symbol
operator|.
name|name
operator|=
name|SCOMMON
expr_stmt|;
name|ecoff_scom_symbol
operator|.
name|flags
operator|=
name|BSF_SECTION_SYM
expr_stmt|;
name|ecoff_scom_symbol
operator|.
name|section
operator|=
operator|&
name|ecoff_scom_section
expr_stmt|;
name|ecoff_scom_symbol_ptr
operator|=
operator|&
name|ecoff_scom_symbol
expr_stmt|;
block|}
name|section
operator|=
operator|&
name|ecoff_scom_section
expr_stmt|;
break|break;
case|case
name|scSUndefined
case|:
name|section
operator|=
name|bfd_und_section_ptr
expr_stmt|;
break|break;
case|case
name|scInit
case|:
name|section
operator|=
name|bfd_make_section_old_way
argument_list|(
name|abfd
argument_list|,
literal|".init"
argument_list|)
expr_stmt|;
name|value
operator|-=
name|section
operator|->
name|vma
expr_stmt|;
break|break;
case|case
name|scFini
case|:
name|section
operator|=
name|bfd_make_section_old_way
argument_list|(
name|abfd
argument_list|,
literal|".fini"
argument_list|)
expr_stmt|;
name|value
operator|-=
name|section
operator|->
name|vma
expr_stmt|;
break|break;
case|case
name|scRConst
case|:
name|section
operator|=
name|bfd_make_section_old_way
argument_list|(
name|abfd
argument_list|,
literal|".rconst"
argument_list|)
expr_stmt|;
name|value
operator|-=
name|section
operator|->
name|vma
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|section
operator|==
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
continue|continue;
name|name
operator|=
name|ssext
operator|+
name|esym
operator|.
name|asym
operator|.
name|iss
expr_stmt|;
name|h
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
name|name
argument_list|,
call|(
name|flagword
call|)
argument_list|(
name|esym
operator|.
name|weakext
condition|?
name|BSF_WEAK
else|:
name|BSF_GLOBAL
argument_list|)
argument_list|,
name|section
argument_list|,
name|value
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|true
argument_list|,
name|true
argument_list|,
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|*
operator|)
operator|&
name|h
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
operator|*
name|sym_hash
operator|=
name|h
expr_stmt|;
comment|/* If we are building an ECOFF hash table, save the external 	 symbol information.  */
if|if
condition|(
name|info
operator|->
name|hash
operator|->
name|creator
operator|->
name|flavour
operator|==
name|bfd_get_flavour
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|abfd
operator|==
operator|(
name|bfd
operator|*
operator|)
name|NULL
operator|||
operator|(
operator|!
name|bfd_is_und_section
argument_list|(
name|section
argument_list|)
operator|&&
operator|(
operator|!
name|bfd_is_com_section
argument_list|(
name|section
argument_list|)
operator|||
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defined
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
operator|)
operator|)
operator|)
condition|)
block|{
name|h
operator|->
name|abfd
operator|=
name|abfd
expr_stmt|;
name|h
operator|->
name|esym
operator|=
name|esym
expr_stmt|;
block|}
comment|/* Remember whether this symbol was small undefined.  */
if|if
condition|(
name|esym
operator|.
name|asym
operator|.
name|sc
operator|==
name|scSUndefined
condition|)
name|h
operator|->
name|small
operator|=
literal|1
expr_stmt|;
comment|/* If this symbol was ever small undefined, it needs to wind 	     up in a GP relative section.  We can't control the 	     section of a defined symbol, but we can control the 	     section of a common symbol.  This case is actually needed 	     on Ultrix 4.2 to handle the symbol cred in -lckrb.  */
if|if
condition|(
name|h
operator|->
name|small
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_common
operator|&&
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
operator|->
name|name
argument_list|,
name|SCOMMON
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
operator|=
name|bfd_make_section_old_way
argument_list|(
name|abfd
argument_list|,
name|SCOMMON
argument_list|)
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
operator|->
name|flags
operator|=
name|SEC_ALLOC
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|==
name|scCommon
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scSCommon
expr_stmt|;
block|}
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ECOFF final link routines.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|ecoff_final_link_debug_accumulate
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|output_bfd
operator|,
name|bfd
operator|*
name|input_bfd
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|PTR
name|handle
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ecoff_link_write_external
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ecoff_link_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ecoff_indirect_link_order
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|asection
operator|*
operator|,
expr|struct
name|bfd_link_order
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ecoff_reloc_link_order
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|asection
operator|*
operator|,
expr|struct
name|bfd_link_order
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Structure used to pass information to ecoff_link_write_external.  */
end_comment

begin_struct
struct|struct
name|extsym_info
block|{
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* ECOFF final link routine.  This looks through all the input BFDs    and gathers together all the debugging information, and then    processes all the link order information.  This may cause it to    close and reopen some input BFDs; I'll see how bad this is.  */
end_comment

begin_function
name|boolean
name|_bfd_ecoff_bfd_final_link
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
specifier|const
name|struct
name|ecoff_backend_data
modifier|*
specifier|const
name|backend
init|=
name|ecoff_backend
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|struct
name|ecoff_debug_info
modifier|*
specifier|const
name|debug
init|=
operator|&
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|debug_info
decl_stmt|;
name|HDRR
modifier|*
name|symhdr
decl_stmt|;
name|PTR
name|handle
decl_stmt|;
specifier|register
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|o
decl_stmt|;
name|struct
name|bfd_link_order
modifier|*
name|p
decl_stmt|;
name|struct
name|extsym_info
name|einfo
decl_stmt|;
comment|/* We accumulate the debugging information counts in the symbolic      header.  */
name|symhdr
operator|=
operator|&
name|debug
operator|->
name|symbolic_header
expr_stmt|;
name|symhdr
operator|->
name|vstamp
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|ilineMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|cbLine
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|idnMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|ipdMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|isymMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|ioptMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|iauxMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|issMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|issExtMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|ifdMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|crfd
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|iextMax
operator|=
literal|0
expr_stmt|;
comment|/* We accumulate the debugging information itself in the debug_info      structure.  */
name|debug
operator|->
name|line
operator|=
name|NULL
expr_stmt|;
name|debug
operator|->
name|external_dnr
operator|=
name|NULL
expr_stmt|;
name|debug
operator|->
name|external_pdr
operator|=
name|NULL
expr_stmt|;
name|debug
operator|->
name|external_sym
operator|=
name|NULL
expr_stmt|;
name|debug
operator|->
name|external_opt
operator|=
name|NULL
expr_stmt|;
name|debug
operator|->
name|external_aux
operator|=
name|NULL
expr_stmt|;
name|debug
operator|->
name|ss
operator|=
name|NULL
expr_stmt|;
name|debug
operator|->
name|ssext
operator|=
name|debug
operator|->
name|ssext_end
operator|=
name|NULL
expr_stmt|;
name|debug
operator|->
name|external_fdr
operator|=
name|NULL
expr_stmt|;
name|debug
operator|->
name|external_rfd
operator|=
name|NULL
expr_stmt|;
name|debug
operator|->
name|external_ext
operator|=
name|debug
operator|->
name|external_ext_end
operator|=
name|NULL
expr_stmt|;
name|handle
operator|=
name|bfd_ecoff_debug_init
argument_list|(
name|abfd
argument_list|,
name|debug
argument_list|,
operator|&
name|backend
operator|->
name|debug_swap
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|handle
operator|==
operator|(
name|PTR
operator|)
name|NULL
condition|)
return|return
name|false
return|;
comment|/* Accumulate the debugging symbols from each input BFD.  */
for|for
control|(
name|input_bfd
operator|=
name|info
operator|->
name|input_bfds
init|;
name|input_bfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|;
name|input_bfd
operator|=
name|input_bfd
operator|->
name|link_next
control|)
block|{
name|boolean
name|ret
decl_stmt|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|input_bfd
argument_list|)
operator|==
name|bfd_target_ecoff_flavour
condition|)
block|{
comment|/* Abitrarily set the symbolic header vstamp to the vstamp 	     of the first object file in the link.  */
if|if
condition|(
name|symhdr
operator|->
name|vstamp
operator|==
literal|0
condition|)
name|symhdr
operator|->
name|vstamp
operator|=
name|ecoff_data
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|debug_info
operator|.
name|symbolic_header
operator|.
name|vstamp
expr_stmt|;
name|ret
operator|=
name|ecoff_final_link_debug_accumulate
argument_list|(
name|abfd
argument_list|,
name|input_bfd
argument_list|,
name|info
argument_list|,
name|handle
argument_list|)
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|bfd_ecoff_debug_accumulate_other
argument_list|(
name|handle
argument_list|,
name|abfd
argument_list|,
name|debug
argument_list|,
operator|&
name|backend
operator|->
name|debug_swap
argument_list|,
name|input_bfd
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
return|return
name|false
return|;
comment|/* Combine the register masks.  */
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|gprmask
operator||=
name|ecoff_data
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|gprmask
expr_stmt|;
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|fprmask
operator||=
name|ecoff_data
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|fprmask
expr_stmt|;
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|cprmask
index|[
literal|0
index|]
operator||=
name|ecoff_data
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|cprmask
index|[
literal|0
index|]
expr_stmt|;
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|cprmask
index|[
literal|1
index|]
operator||=
name|ecoff_data
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|cprmask
index|[
literal|1
index|]
expr_stmt|;
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|cprmask
index|[
literal|2
index|]
operator||=
name|ecoff_data
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|cprmask
index|[
literal|2
index|]
expr_stmt|;
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|cprmask
index|[
literal|3
index|]
operator||=
name|ecoff_data
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|cprmask
index|[
literal|3
index|]
expr_stmt|;
block|}
comment|/* Write out the external symbols.  */
name|einfo
operator|.
name|abfd
operator|=
name|abfd
expr_stmt|;
name|einfo
operator|.
name|info
operator|=
name|info
expr_stmt|;
name|ecoff_link_hash_traverse
argument_list|(
name|ecoff_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|ecoff_link_write_external
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|einfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|relocateable
condition|)
block|{
comment|/* We need to make a pass over the link_orders to count up the 	 number of relocations we will need to output, so that we know 	 how much space they will take up.  */
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
name|o
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|o
operator|->
name|link_order_head
init|;
name|p
operator|!=
operator|(
expr|struct
name|bfd_link_order
operator|*
operator|)
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_indirect_link_order
condition|)
name|o
operator|->
name|reloc_count
operator|+=
name|p
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
operator|->
name|reloc_count
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_section_reloc_link_order
operator|||
name|p
operator|->
name|type
operator|==
name|bfd_symbol_reloc_link_order
condition|)
operator|++
name|o
operator|->
name|reloc_count
expr_stmt|;
block|}
block|}
comment|/* Compute the reloc and symbol file positions.  */
name|ecoff_compute_reloc_file_positions
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* Write out the debugging information.  */
if|if
condition|(
operator|!
name|bfd_ecoff_write_accumulated_debug
argument_list|(
name|handle
argument_list|,
name|abfd
argument_list|,
name|debug
argument_list|,
operator|&
name|backend
operator|->
name|debug_swap
argument_list|,
name|info
argument_list|,
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|sym_filepos
argument_list|)
condition|)
return|return
name|false
return|;
name|bfd_ecoff_debug_free
argument_list|(
name|handle
argument_list|,
name|abfd
argument_list|,
name|debug
argument_list|,
operator|&
name|backend
operator|->
name|debug_swap
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|relocateable
condition|)
block|{
comment|/* Now reset the reloc_count field of the sections in the output 	 BFD to 0, so that we can use them to keep track of how many 	 relocs we have output thus far.  */
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
name|o
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Get a value for the GP register.  */
if|if
condition|(
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|gp
operator|==
literal|0
condition|)
block|{
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|info
operator|->
name|hash
argument_list|,
literal|"_gp"
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|)
name|NULL
operator|&&
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_defined
condition|)
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|gp
operator|=
operator|(
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|info
operator|->
name|relocateable
condition|)
block|{
name|bfd_vma
name|lo
decl_stmt|;
comment|/* Make up a value.  */
name|lo
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
if|if
condition|(
name|o
operator|->
name|vma
operator|<
name|lo
operator|&&
operator|(
name|strcmp
argument_list|(
name|o
operator|->
name|name
argument_list|,
name|_SBSS
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|o
operator|->
name|name
argument_list|,
name|_SDATA
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|o
operator|->
name|name
argument_list|,
name|_LIT4
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|o
operator|->
name|name
argument_list|,
name|_LIT8
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|o
operator|->
name|name
argument_list|,
name|_LITA
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|lo
operator|=
name|o
operator|->
name|vma
expr_stmt|;
block|}
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|gp
operator|=
name|lo
operator|+
literal|0x8000
expr_stmt|;
block|}
else|else
block|{
comment|/* If the relocate_section function needs to do a reloc 	     involving the GP value, it should make a reloc_dangerous 	     callback to warn that GP is not defined.  */
block|}
block|}
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
for|for
control|(
name|p
operator|=
name|o
operator|->
name|link_order_head
init|;
name|p
operator|!=
operator|(
expr|struct
name|bfd_link_order
operator|*
operator|)
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_indirect_link_order
operator|&&
operator|(
name|bfd_get_flavour
argument_list|(
name|p
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
operator|->
name|owner
argument_list|)
operator|==
name|bfd_target_ecoff_flavour
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|ecoff_indirect_link_order
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|o
argument_list|,
name|p
argument_list|)
condition|)
return|return
name|false
return|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_section_reloc_link_order
operator|||
name|p
operator|->
name|type
operator|==
name|bfd_symbol_reloc_link_order
condition|)
block|{
if|if
condition|(
operator|!
name|ecoff_reloc_link_order
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|o
argument_list|,
name|p
argument_list|)
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|_bfd_default_link_order
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|o
argument_list|,
name|p
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
block|}
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|=
name|symhdr
operator|->
name|iextMax
operator|+
name|symhdr
operator|->
name|isymMax
expr_stmt|;
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|linker
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Accumulate the debugging information for an input BFD into the    output BFD.  This must read in the symbolic information of the    input BFD.  */
end_comment

begin_function
specifier|static
name|boolean
name|ecoff_final_link_debug_accumulate
parameter_list|(
name|output_bfd
parameter_list|,
name|input_bfd
parameter_list|,
name|info
parameter_list|,
name|handle
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|PTR
name|handle
decl_stmt|;
block|{
name|struct
name|ecoff_debug_info
modifier|*
specifier|const
name|debug
init|=
operator|&
name|ecoff_data
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|debug_info
decl_stmt|;
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
specifier|const
name|swap
init|=
operator|&
name|ecoff_backend
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|debug_swap
decl_stmt|;
name|HDRR
modifier|*
name|symhdr
init|=
operator|&
name|debug
operator|->
name|symbolic_header
decl_stmt|;
name|boolean
name|ret
decl_stmt|;
define|#
directive|define
name|READ
parameter_list|(
name|ptr
parameter_list|,
name|offset
parameter_list|,
name|count
parameter_list|,
name|size
parameter_list|,
name|type
parameter_list|)
define|\
value|if (symhdr->count == 0)						 \     debug->ptr = NULL;							 \   else									 \     {									 \       bfd_size_type amt = (bfd_size_type) size * symhdr->count;		 \       debug->ptr = (type) bfd_malloc (amt);				 \       if (debug->ptr == NULL)						 \ 	{								 \           ret = false;							 \           goto return_something;					 \ 	}								 \       if (bfd_seek (input_bfd, (file_ptr) symhdr->offset, SEEK_SET) != 0 \ 	  || bfd_bread (debug->ptr, amt, input_bfd) != amt)		 \ 	{								 \           ret = false;							 \           goto return_something;					 \ 	}								 \     }
comment|/* If raw_syments is not NULL, then the data was already by read by      _bfd_ecoff_slurp_symbolic_info.  */
if|if
condition|(
name|ecoff_data
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|raw_syments
operator|==
name|NULL
condition|)
block|{
name|READ
argument_list|(
argument|line
argument_list|,
argument|cbLineOffset
argument_list|,
argument|cbLine
argument_list|,
argument|sizeof (unsigned char)
argument_list|,
argument|unsigned char *
argument_list|)
empty_stmt|;
name|READ
argument_list|(
name|external_dnr
argument_list|,
name|cbDnOffset
argument_list|,
name|idnMax
argument_list|,
name|swap
operator|->
name|external_dnr_size
argument_list|,
name|PTR
argument_list|)
expr_stmt|;
name|READ
argument_list|(
name|external_pdr
argument_list|,
name|cbPdOffset
argument_list|,
name|ipdMax
argument_list|,
name|swap
operator|->
name|external_pdr_size
argument_list|,
name|PTR
argument_list|)
expr_stmt|;
name|READ
argument_list|(
name|external_sym
argument_list|,
name|cbSymOffset
argument_list|,
name|isymMax
argument_list|,
name|swap
operator|->
name|external_sym_size
argument_list|,
name|PTR
argument_list|)
expr_stmt|;
name|READ
argument_list|(
name|external_opt
argument_list|,
name|cbOptOffset
argument_list|,
name|ioptMax
argument_list|,
name|swap
operator|->
name|external_opt_size
argument_list|,
name|PTR
argument_list|)
expr_stmt|;
name|READ
argument_list|(
name|external_aux
argument_list|,
name|cbAuxOffset
argument_list|,
name|iauxMax
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|aux_ext
argument_list|)
argument_list|,
expr|union
name|aux_ext
operator|*
argument_list|)
expr_stmt|;
name|READ
argument_list|(
name|ss
argument_list|,
name|cbSsOffset
argument_list|,
name|issMax
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|READ
argument_list|(
name|external_fdr
argument_list|,
name|cbFdOffset
argument_list|,
name|ifdMax
argument_list|,
name|swap
operator|->
name|external_fdr_size
argument_list|,
name|PTR
argument_list|)
expr_stmt|;
name|READ
argument_list|(
name|external_rfd
argument_list|,
name|cbRfdOffset
argument_list|,
name|crfd
argument_list|,
name|swap
operator|->
name|external_rfd_size
argument_list|,
name|PTR
argument_list|)
expr_stmt|;
block|}
undef|#
directive|undef
name|READ
comment|/* We do not read the external strings or the external symbols.  */
name|ret
operator|=
operator|(
name|bfd_ecoff_debug_accumulate
argument_list|(
name|handle
argument_list|,
name|output_bfd
argument_list|,
operator|&
name|ecoff_data
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|debug_info
argument_list|,
operator|&
name|ecoff_backend
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|debug_swap
argument_list|,
name|input_bfd
argument_list|,
name|debug
argument_list|,
name|swap
argument_list|,
name|info
argument_list|)
operator|)
expr_stmt|;
name|return_something
label|:
if|if
condition|(
name|ecoff_data
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|raw_syments
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|debug
operator|->
name|line
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|external_dnr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|external_dnr
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|external_pdr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|external_pdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|external_sym
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|external_sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|external_opt
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|external_opt
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|external_aux
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|external_aux
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|ss
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|ss
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|external_fdr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|external_fdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|external_rfd
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|external_rfd
argument_list|)
expr_stmt|;
comment|/* Make sure we don't accidentally follow one of these pointers 	 into freed memory.  */
name|debug
operator|->
name|line
operator|=
name|NULL
expr_stmt|;
name|debug
operator|->
name|external_dnr
operator|=
name|NULL
expr_stmt|;
name|debug
operator|->
name|external_pdr
operator|=
name|NULL
expr_stmt|;
name|debug
operator|->
name|external_sym
operator|=
name|NULL
expr_stmt|;
name|debug
operator|->
name|external_opt
operator|=
name|NULL
expr_stmt|;
name|debug
operator|->
name|external_aux
operator|=
name|NULL
expr_stmt|;
name|debug
operator|->
name|ss
operator|=
name|NULL
expr_stmt|;
name|debug
operator|->
name|external_fdr
operator|=
name|NULL
expr_stmt|;
name|debug
operator|->
name|external_rfd
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Put out information for an external symbol.  These come only from    the hash table.  */
end_comment

begin_function
specifier|static
name|boolean
name|ecoff_link_write_external
parameter_list|(
name|h
parameter_list|,
name|data
parameter_list|)
name|struct
name|ecoff_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
name|struct
name|extsym_info
modifier|*
name|einfo
init|=
operator|(
expr|struct
name|extsym_info
operator|*
operator|)
name|data
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
init|=
name|einfo
operator|->
name|abfd
decl_stmt|;
name|boolean
name|strip
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
block|{
name|h
operator|=
operator|(
expr|struct
name|ecoff_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_new
condition|)
return|return
name|true
return|;
block|}
comment|/* We need to check if this symbol is being stripped.  */
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
name|strip
operator|=
name|false
expr_stmt|;
elseif|else
if|if
condition|(
name|einfo
operator|->
name|info
operator|->
name|strip
operator|==
name|strip_all
operator|||
operator|(
name|einfo
operator|->
name|info
operator|->
name|strip
operator|==
name|strip_some
operator|&&
name|bfd_hash_lookup
argument_list|(
name|einfo
operator|->
name|info
operator|->
name|keep_hash
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
operator|==
name|NULL
operator|)
condition|)
name|strip
operator|=
name|true
expr_stmt|;
else|else
name|strip
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|strip
operator|||
name|h
operator|->
name|written
condition|)
return|return
name|true
return|;
if|if
condition|(
name|h
operator|->
name|abfd
operator|==
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
block|{
name|h
operator|->
name|esym
operator|.
name|jmptbl
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|cobol_main
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|weakext
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|reserved
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|ifd
operator|=
name|ifdNil
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|st
operator|=
name|stGlobal
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defined
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scAbs
expr_stmt|;
else|else
block|{
name|asection
modifier|*
name|output_section
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|output_section
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
expr_stmt|;
name|name
operator|=
name|bfd_section_name
argument_list|(
name|output_section
operator|->
name|owner
argument_list|,
name|output_section
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|_TEXT
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scText
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|_DATA
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scData
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|_SDATA
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scSData
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|_RDATA
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scRData
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|_BSS
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scBss
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|_SBSS
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scSBss
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|_INIT
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scInit
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|_FINI
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scFini
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|_PDATA
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scPData
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|_XDATA
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scXData
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|_RCONST
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scRConst
expr_stmt|;
else|else
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scAbs
expr_stmt|;
block|}
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|reserved
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|index
operator|=
name|indexNil
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|->
name|esym
operator|.
name|ifd
operator|!=
operator|-
literal|1
condition|)
block|{
name|struct
name|ecoff_debug_info
modifier|*
name|debug
decl_stmt|;
comment|/* Adjust the FDR index for the symbol by that used for the 	 input BFD.  */
name|debug
operator|=
operator|&
name|ecoff_data
argument_list|(
name|h
operator|->
name|abfd
argument_list|)
operator|->
name|debug_info
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|esym
operator|.
name|ifd
operator|>=
literal|0
operator|&&
name|h
operator|->
name|esym
operator|.
name|ifd
operator|<
name|debug
operator|->
name|symbolic_header
operator|.
name|ifdMax
argument_list|)
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|ifd
operator|=
name|debug
operator|->
name|ifdmap
index|[
name|h
operator|->
name|esym
operator|.
name|ifd
index|]
expr_stmt|;
block|}
switch|switch
condition|(
name|h
operator|->
name|root
operator|.
name|type
condition|)
block|{
default|default:
case|case
name|bfd_link_hash_warning
case|:
case|case
name|bfd_link_hash_new
case|:
name|abort
argument_list|()
expr_stmt|;
case|case
name|bfd_link_hash_undefined
case|:
case|case
name|bfd_link_hash_undefweak
case|:
if|if
condition|(
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|!=
name|scUndefined
operator|&&
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|!=
name|scSUndefined
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scUndefined
expr_stmt|;
break|break;
case|case
name|bfd_link_hash_defined
case|:
case|case
name|bfd_link_hash_defweak
case|:
if|if
condition|(
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|==
name|scUndefined
operator|||
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|==
name|scSUndefined
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scAbs
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|==
name|scCommon
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scBss
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|==
name|scSCommon
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scSBss
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
break|break;
case|case
name|bfd_link_hash_common
case|:
if|if
condition|(
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|!=
name|scCommon
operator|&&
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|!=
name|scSCommon
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scCommon
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|size
expr_stmt|;
break|break;
case|case
name|bfd_link_hash_indirect
case|:
comment|/* We ignore these symbols, since the indirected symbol is 	 already in the hash table.  */
return|return
name|true
return|;
block|}
comment|/* bfd_ecoff_debug_one_external uses iextMax to keep track of the      symbol number.  */
name|h
operator|->
name|indx
operator|=
name|ecoff_data
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|debug_info
operator|.
name|symbolic_header
operator|.
name|iextMax
expr_stmt|;
name|h
operator|->
name|written
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|bfd_ecoff_debug_one_external
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|ecoff_data
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|debug_info
argument_list|,
operator|&
name|ecoff_backend
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|debug_swap
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
operator|&
name|h
operator|->
name|esym
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Relocate and write an ECOFF section into an ECOFF output file.  */
end_comment

begin_function
specifier|static
name|boolean
name|ecoff_indirect_link_order
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|output_section
parameter_list|,
name|link_order
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|asection
modifier|*
name|output_section
decl_stmt|;
name|struct
name|bfd_link_order
modifier|*
name|link_order
decl_stmt|;
block|{
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|struct
name|ecoff_section_tdata
modifier|*
name|section_tdata
decl_stmt|;
name|bfd_size_type
name|raw_size
decl_stmt|;
name|bfd_size_type
name|cooked_size
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
init|=
name|NULL
decl_stmt|;
name|bfd_size_type
name|external_reloc_size
decl_stmt|;
name|bfd_size_type
name|external_relocs_size
decl_stmt|;
name|PTR
name|external_relocs
init|=
name|NULL
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|BFD_ASSERT
argument_list|(
operator|(
name|output_section
operator|->
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|link_order
operator|->
name|size
operator|==
literal|0
condition|)
return|return
name|true
return|;
name|input_section
operator|=
name|link_order
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
expr_stmt|;
name|input_bfd
operator|=
name|input_section
operator|->
name|owner
expr_stmt|;
name|section_tdata
operator|=
name|ecoff_section_data
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
expr_stmt|;
name|raw_size
operator|=
name|input_section
operator|->
name|_raw_size
expr_stmt|;
name|cooked_size
operator|=
name|input_section
operator|->
name|_cooked_size
expr_stmt|;
if|if
condition|(
name|cooked_size
operator|==
literal|0
condition|)
name|cooked_size
operator|=
name|raw_size
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|input_section
operator|->
name|output_section
operator|==
name|output_section
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|input_section
operator|->
name|output_offset
operator|==
name|link_order
operator|->
name|offset
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|cooked_size
operator|==
name|link_order
operator|->
name|size
argument_list|)
expr_stmt|;
comment|/* Get the section contents.  We allocate memory for the larger of      the size before relocating and the size after relocating.  */
name|amt
operator|=
name|raw_size
operator|>=
name|cooked_size
condition|?
name|raw_size
else|:
name|cooked_size
expr_stmt|;
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
operator|&&
name|amt
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
comment|/* If we are relaxing, the contents may have already been read into      memory, in which case we copy them into our new buffer.  We don't      simply reuse the old buffer in case cooked_size> raw_size.  */
if|if
condition|(
name|section_tdata
operator|!=
operator|(
expr|struct
name|ecoff_section_tdata
operator|*
operator|)
name|NULL
operator|&&
name|section_tdata
operator|->
name|contents
operator|!=
operator|(
name|bfd_byte
operator|*
operator|)
name|NULL
condition|)
name|memcpy
argument_list|(
name|contents
argument_list|,
name|section_tdata
operator|->
name|contents
argument_list|,
operator|(
name|size_t
operator|)
name|raw_size
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
name|PTR
operator|)
name|contents
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|raw_size
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
comment|/* Get the relocs.  If we are relaxing MIPS code, they will already      have been read in.  Otherwise, we read them in now.  */
name|external_reloc_size
operator|=
name|ecoff_backend
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|external_reloc_size
expr_stmt|;
name|external_relocs_size
operator|=
name|external_reloc_size
operator|*
name|input_section
operator|->
name|reloc_count
expr_stmt|;
if|if
condition|(
name|section_tdata
operator|!=
operator|(
expr|struct
name|ecoff_section_tdata
operator|*
operator|)
name|NULL
operator|&&
name|section_tdata
operator|->
name|external_relocs
operator|!=
name|NULL
condition|)
name|external_relocs
operator|=
name|section_tdata
operator|->
name|external_relocs
expr_stmt|;
else|else
block|{
name|external_relocs
operator|=
operator|(
name|PTR
operator|)
name|bfd_malloc
argument_list|(
name|external_relocs_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|external_relocs
operator|==
name|NULL
operator|&&
name|external_relocs_size
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|input_bfd
argument_list|,
name|input_section
operator|->
name|rel_filepos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|bfd_bread
argument_list|(
name|external_relocs
argument_list|,
name|external_relocs_size
argument_list|,
name|input_bfd
argument_list|)
operator|!=
name|external_relocs_size
operator|)
condition|)
goto|goto
name|error_return
goto|;
block|}
comment|/* Relocate the section contents.  */
if|if
condition|(
operator|!
operator|(
operator|(
operator|*
name|ecoff_backend
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|relocate_section
operator|)
operator|(
name|output_bfd
operator|,
name|info
operator|,
name|input_bfd
operator|,
name|input_section
operator|,
name|contents
operator|,
name|external_relocs
operator|)
operator|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* Write out the relocated section.  */
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|output_bfd
argument_list|,
name|output_section
argument_list|,
operator|(
name|PTR
operator|)
name|contents
argument_list|,
operator|(
name|file_ptr
operator|)
name|input_section
operator|->
name|output_offset
argument_list|,
name|cooked_size
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* If we are producing relocateable output, the relocs were      modified, and we write them out now.  We use the reloc_count      field of output_section to keep track of the number of relocs we      have output so far.  */
if|if
condition|(
name|info
operator|->
name|relocateable
condition|)
block|{
name|file_ptr
name|pos
init|=
operator|(
name|output_section
operator|->
name|rel_filepos
operator|+
name|output_section
operator|->
name|reloc_count
operator|*
name|external_reloc_size
operator|)
decl_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|output_bfd
argument_list|,
name|pos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|bfd_bwrite
argument_list|(
name|external_relocs
argument_list|,
name|external_relocs_size
argument_list|,
name|output_bfd
argument_list|)
operator|!=
name|external_relocs_size
operator|)
condition|)
goto|goto
name|error_return
goto|;
name|output_section
operator|->
name|reloc_count
operator|+=
name|input_section
operator|->
name|reloc_count
expr_stmt|;
block|}
if|if
condition|(
name|contents
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
if|if
condition|(
name|external_relocs
operator|!=
name|NULL
operator|&&
name|section_tdata
operator|==
name|NULL
condition|)
name|free
argument_list|(
name|external_relocs
argument_list|)
expr_stmt|;
return|return
name|true
return|;
name|error_return
label|:
if|if
condition|(
name|contents
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
if|if
condition|(
name|external_relocs
operator|!=
name|NULL
operator|&&
name|section_tdata
operator|==
name|NULL
condition|)
name|free
argument_list|(
name|external_relocs
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Generate a reloc when linking an ECOFF file.  This is a reloc    requested by the linker, and does come from any input file.  This    is used to build constructor and destructor tables when linking    with -Ur.  */
end_comment

begin_function
specifier|static
name|boolean
name|ecoff_reloc_link_order
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|output_section
parameter_list|,
name|link_order
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|asection
modifier|*
name|output_section
decl_stmt|;
name|struct
name|bfd_link_order
modifier|*
name|link_order
decl_stmt|;
block|{
name|enum
name|bfd_link_order_type
name|type
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|;
name|arelent
name|rel
decl_stmt|;
name|struct
name|internal_reloc
name|in
decl_stmt|;
name|bfd_size_type
name|external_reloc_size
decl_stmt|;
name|bfd_byte
modifier|*
name|rbuf
decl_stmt|;
name|boolean
name|ok
decl_stmt|;
name|file_ptr
name|pos
decl_stmt|;
name|type
operator|=
name|link_order
operator|->
name|type
expr_stmt|;
name|section
operator|=
name|NULL
expr_stmt|;
name|addend
operator|=
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|addend
expr_stmt|;
comment|/* We set up an arelent to pass to the backend adjust_reloc_out      routine.  */
name|rel
operator|.
name|address
operator|=
name|link_order
operator|->
name|offset
expr_stmt|;
name|rel
operator|.
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|output_bfd
argument_list|,
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|reloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rel
operator|.
name|howto
operator|==
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|type
operator|==
name|bfd_section_reloc_link_order
condition|)
block|{
name|section
operator|=
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|u
operator|.
name|section
expr_stmt|;
name|rel
operator|.
name|sym_ptr_ptr
operator|=
name|section
operator|->
name|symbol_ptr_ptr
expr_stmt|;
block|}
else|else
block|{
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
comment|/* Treat a reloc against a defined symbol as though it were          actually against the section.  */
name|h
operator|=
name|bfd_wrapped_link_hash_lookup
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|u
operator|.
name|name
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
condition|)
block|{
name|type
operator|=
name|bfd_section_reloc_link_order
expr_stmt|;
name|section
operator|=
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
expr_stmt|;
comment|/* It seems that we ought to add the symbol value to the              addend here, but in practice it has already been added              because it was passed to constructor_callback.  */
name|addend
operator|+=
name|section
operator|->
name|vma
operator|+
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
expr_stmt|;
block|}
else|else
block|{
comment|/* We can't set up a reloc against a symbol correctly, 	     because we have no asymbol structure.  Currently no 	     adjust_reloc_out routine cares.  */
name|rel
operator|.
name|sym_ptr_ptr
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
block|}
comment|/* All ECOFF relocs are in-place.  Put the addend into the object      file.  */
name|BFD_ASSERT
argument_list|(
name|rel
operator|.
name|howto
operator|->
name|partial_inplace
argument_list|)
expr_stmt|;
if|if
condition|(
name|addend
operator|!=
literal|0
condition|)
block|{
name|bfd_size_type
name|size
decl_stmt|;
name|bfd_reloc_status_type
name|rstat
decl_stmt|;
name|bfd_byte
modifier|*
name|buf
decl_stmt|;
name|size
operator|=
name|bfd_get_reloc_size
argument_list|(
name|rel
operator|.
name|howto
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_zmalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
operator|(
name|bfd_byte
operator|*
operator|)
name|NULL
condition|)
return|return
name|false
return|;
name|rstat
operator|=
name|_bfd_relocate_contents
argument_list|(
name|rel
operator|.
name|howto
argument_list|,
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|addend
argument_list|,
name|buf
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rstat
condition|)
block|{
case|case
name|bfd_reloc_ok
case|:
break|break;
default|default:
case|case
name|bfd_reloc_outofrange
case|:
name|abort
argument_list|()
expr_stmt|;
case|case
name|bfd_reloc_overflow
case|:
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|info
argument_list|,
operator|(
name|link_order
operator|->
name|type
operator|==
name|bfd_section_reloc_link_order
condition|?
name|bfd_section_name
argument_list|(
name|output_bfd
argument_list|,
name|section
argument_list|)
else|:
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|u
operator|.
name|name
operator|)
argument_list|,
name|rel
operator|.
name|howto
operator|->
name|name
argument_list|,
name|addend
argument_list|,
operator|(
name|bfd
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|asection
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
operator|)
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
break|break;
block|}
name|ok
operator|=
name|bfd_set_section_contents
argument_list|(
name|output_bfd
argument_list|,
name|output_section
argument_list|,
operator|(
name|PTR
operator|)
name|buf
argument_list|,
operator|(
name|file_ptr
operator|)
name|link_order
operator|->
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|false
return|;
block|}
name|rel
operator|.
name|addend
operator|=
literal|0
expr_stmt|;
comment|/* Move the information into an internal_reloc structure.  */
name|in
operator|.
name|r_vaddr
operator|=
operator|(
name|rel
operator|.
name|address
operator|+
name|bfd_get_section_vma
argument_list|(
name|output_bfd
argument_list|,
name|output_section
argument_list|)
operator|)
expr_stmt|;
name|in
operator|.
name|r_type
operator|=
name|rel
operator|.
name|howto
operator|->
name|type
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|bfd_symbol_reloc_link_order
condition|)
block|{
name|struct
name|ecoff_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
operator|(
operator|(
expr|struct
name|ecoff_link_hash_entry
operator|*
operator|)
name|bfd_wrapped_link_hash_lookup
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|u
operator|.
name|name
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
operator|(
expr|struct
name|ecoff_link_hash_entry
operator|*
operator|)
name|NULL
operator|&&
name|h
operator|->
name|indx
operator|!=
operator|-
literal|1
condition|)
name|in
operator|.
name|r_symndx
operator|=
name|h
operator|->
name|indx
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|unattached_reloc
call|)
argument_list|(
name|info
argument_list|,
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|u
operator|.
name|name
argument_list|,
operator|(
name|bfd
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|asection
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
name|in
operator|.
name|r_symndx
operator|=
literal|0
expr_stmt|;
block|}
name|in
operator|.
name|r_extern
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|output_bfd
argument_list|,
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".text"
argument_list|)
operator|==
literal|0
condition|)
name|in
operator|.
name|r_symndx
operator|=
name|RELOC_SECTION_TEXT
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".rdata"
argument_list|)
operator|==
literal|0
condition|)
name|in
operator|.
name|r_symndx
operator|=
name|RELOC_SECTION_RDATA
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".data"
argument_list|)
operator|==
literal|0
condition|)
name|in
operator|.
name|r_symndx
operator|=
name|RELOC_SECTION_DATA
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sdata"
argument_list|)
operator|==
literal|0
condition|)
name|in
operator|.
name|r_symndx
operator|=
name|RELOC_SECTION_SDATA
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sbss"
argument_list|)
operator|==
literal|0
condition|)
name|in
operator|.
name|r_symndx
operator|=
name|RELOC_SECTION_SBSS
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".bss"
argument_list|)
operator|==
literal|0
condition|)
name|in
operator|.
name|r_symndx
operator|=
name|RELOC_SECTION_BSS
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".init"
argument_list|)
operator|==
literal|0
condition|)
name|in
operator|.
name|r_symndx
operator|=
name|RELOC_SECTION_INIT
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".lit8"
argument_list|)
operator|==
literal|0
condition|)
name|in
operator|.
name|r_symndx
operator|=
name|RELOC_SECTION_LIT8
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".lit4"
argument_list|)
operator|==
literal|0
condition|)
name|in
operator|.
name|r_symndx
operator|=
name|RELOC_SECTION_LIT4
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".xdata"
argument_list|)
operator|==
literal|0
condition|)
name|in
operator|.
name|r_symndx
operator|=
name|RELOC_SECTION_XDATA
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".pdata"
argument_list|)
operator|==
literal|0
condition|)
name|in
operator|.
name|r_symndx
operator|=
name|RELOC_SECTION_PDATA
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".fini"
argument_list|)
operator|==
literal|0
condition|)
name|in
operator|.
name|r_symndx
operator|=
name|RELOC_SECTION_FINI
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".lita"
argument_list|)
operator|==
literal|0
condition|)
name|in
operator|.
name|r_symndx
operator|=
name|RELOC_SECTION_LITA
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"*ABS*"
argument_list|)
operator|==
literal|0
condition|)
name|in
operator|.
name|r_symndx
operator|=
name|RELOC_SECTION_ABS
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".rconst"
argument_list|)
operator|==
literal|0
condition|)
name|in
operator|.
name|r_symndx
operator|=
name|RELOC_SECTION_RCONST
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|in
operator|.
name|r_extern
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Let the BFD backend adjust the reloc.  */
operator|(
operator|*
name|ecoff_backend
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|adjust_reloc_out
operator|)
operator|(
name|output_bfd
operator|,
operator|&
name|rel
operator|,
operator|&
name|in
operator|)
expr_stmt|;
comment|/* Get some memory and swap out the reloc.  */
name|external_reloc_size
operator|=
name|ecoff_backend
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|external_reloc_size
expr_stmt|;
name|rbuf
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|external_reloc_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbuf
operator|==
operator|(
name|bfd_byte
operator|*
operator|)
name|NULL
condition|)
return|return
name|false
return|;
operator|(
operator|*
name|ecoff_backend
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|swap_reloc_out
operator|)
operator|(
name|output_bfd
operator|,
operator|&
name|in
operator|,
operator|(
name|PTR
operator|)
name|rbuf
operator|)
expr_stmt|;
name|pos
operator|=
operator|(
name|output_section
operator|->
name|rel_filepos
operator|+
name|output_section
operator|->
name|reloc_count
operator|*
name|external_reloc_size
operator|)
expr_stmt|;
name|ok
operator|=
operator|(
name|bfd_seek
argument_list|(
name|output_bfd
argument_list|,
name|pos
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|bfd_bwrite
argument_list|(
operator|(
name|PTR
operator|)
name|rbuf
argument_list|,
name|external_reloc_size
argument_list|,
name|output_bfd
argument_list|)
operator|==
name|external_reloc_size
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|ok
condition|)
operator|++
name|output_section
operator|->
name|reloc_count
expr_stmt|;
name|free
argument_list|(
name|rbuf
argument_list|)
expr_stmt|;
return|return
name|ok
return|;
block|}
end_function

end_unit

