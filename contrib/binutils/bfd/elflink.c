begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ELF linking support for BFD.    Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,    2005, 2006, 2007 Free Software Foundation, Inc.     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_define
define|#
directive|define
name|ARCH_SIZE
value|0
end_define

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"objalloc.h"
end_include

begin_comment
comment|/* Define a symbol in a dynamic linkage section.  */
end_comment

begin_function
name|struct
name|elf_link_hash_entry
modifier|*
name|_bfd_elf_define_linkage_sym
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|bh
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
name|h
operator|=
name|elf_link_hash_lookup
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
comment|/* Zap symbol defined in an as-needed lib that wasn't linked. 	 This is a symptom of a larger problem:  Absolute symbols 	 defined in shared libraries can't be overridden, because we 	 lose the link to the bfd which is via the symbol section.  */
name|h
operator|->
name|root
operator|.
name|type
operator|=
name|bfd_link_hash_new
expr_stmt|;
block|}
name|bh
operator|=
operator|&
name|h
operator|->
name|root
expr_stmt|;
if|if
condition|(
operator|!
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
name|name
argument_list|,
name|BSF_GLOBAL
argument_list|,
name|sec
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|collect
argument_list|,
operator|&
name|bh
argument_list|)
condition|)
return|return
name|NULL
return|;
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|bh
expr_stmt|;
name|h
operator|->
name|def_regular
operator|=
literal|1
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|STT_OBJECT
expr_stmt|;
name|h
operator|->
name|other
operator|=
operator|(
name|h
operator|->
name|other
operator|&
operator|~
name|ELF_ST_VISIBILITY
argument_list|(
operator|-
literal|1
argument_list|)
operator|)
operator||
name|STV_HIDDEN
expr_stmt|;
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
call|(
modifier|*
name|bed
operator|->
name|elf_backend_hide_symbol
call|)
argument_list|(
name|info
argument_list|,
name|h
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|h
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|_bfd_elf_create_got_section
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|flagword
name|flags
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|int
name|ptralign
decl_stmt|;
comment|/* This function may be called more than once.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LINKER_CREATED
operator|)
operator|!=
literal|0
condition|)
return|return
name|TRUE
return|;
switch|switch
condition|(
name|bed
operator|->
name|s
operator|->
name|arch_size
condition|)
block|{
case|case
literal|32
case|:
name|ptralign
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|64
case|:
name|ptralign
operator|=
literal|3
expr_stmt|;
break|break;
default|default:
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|flags
operator|=
name|bed
operator|->
name|dynamic_sec_flags
expr_stmt|;
name|s
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|abfd
argument_list|,
literal|".got"
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|ptralign
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|bed
operator|->
name|want_got_plt
condition|)
block|{
name|s
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|abfd
argument_list|,
literal|".got.plt"
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|ptralign
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|bed
operator|->
name|want_got_sym
condition|)
block|{
comment|/* Define the symbol _GLOBAL_OFFSET_TABLE_ at the start of the .got 	 (or .got.plt) section.  We don't do this in the linker script 	 because we don't want to define the symbol if we are not creating 	 a global offset table.  */
name|h
operator|=
name|_bfd_elf_define_linkage_sym
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|s
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|)
expr_stmt|;
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|hgot
operator|=
name|h
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* The first bit of the global offset table is the header.  */
name|s
operator|->
name|size
operator|+=
name|bed
operator|->
name|got_header_size
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create a strtab to hold the dynamic symbol names.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|_bfd_elf_link_create_dynstrtab
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|elf_link_hash_table
modifier|*
name|hash_table
decl_stmt|;
name|hash_table
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_table
operator|->
name|dynobj
operator|==
name|NULL
condition|)
name|hash_table
operator|->
name|dynobj
operator|=
name|abfd
expr_stmt|;
if|if
condition|(
name|hash_table
operator|->
name|dynstr
operator|==
name|NULL
condition|)
block|{
name|hash_table
operator|->
name|dynstr
operator|=
name|_bfd_elf_strtab_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|hash_table
operator|->
name|dynstr
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Create some sections which will be filled in with dynamic linking    information.  ABFD is an input file which requires dynamic sections    to be created.  The dynamic sections take up virtual memory space    when the final executable is run, so we need to create them before    addresses are assigned to the output sections.  We work out the    actual contents and size of these sections later.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_elf_link_create_dynamic_sections
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|flagword
name|flags
decl_stmt|;
specifier|register
name|asection
modifier|*
name|s
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
if|if
condition|(
operator|!
name|is_elf_hash_table
argument_list|(
name|info
operator|->
name|hash
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
operator|!
name|_bfd_elf_link_create_dynstrtab
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|abfd
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|flags
operator|=
name|bed
operator|->
name|dynamic_sec_flags
expr_stmt|;
comment|/* A dynamically linked executable has a .interp section, but a      shared library does not.  */
if|if
condition|(
name|info
operator|->
name|executable
condition|)
block|{
name|s
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|abfd
argument_list|,
literal|".interp"
argument_list|,
name|flags
operator||
name|SEC_READONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Create sections to hold version informations.  These are removed      if they are not needed.  */
name|s
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|abfd
argument_list|,
literal|".gnu.version_d"
argument_list|,
name|flags
operator||
name|SEC_READONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|bed
operator|->
name|s
operator|->
name|log_file_align
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|s
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|abfd
argument_list|,
literal|".gnu.version"
argument_list|,
name|flags
operator||
name|SEC_READONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|s
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|abfd
argument_list|,
literal|".gnu.version_r"
argument_list|,
name|flags
operator||
name|SEC_READONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|bed
operator|->
name|s
operator|->
name|log_file_align
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|s
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|abfd
argument_list|,
literal|".dynsym"
argument_list|,
name|flags
operator||
name|SEC_READONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|bed
operator|->
name|s
operator|->
name|log_file_align
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|s
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|abfd
argument_list|,
literal|".dynstr"
argument_list|,
name|flags
operator||
name|SEC_READONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|s
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|abfd
argument_list|,
literal|".dynamic"
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|bed
operator|->
name|s
operator|->
name|log_file_align
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* The special symbol _DYNAMIC is always set to the start of the      .dynamic section.  We could set _DYNAMIC in a linker script, but we      only want to define it if we are, in fact, creating a .dynamic      section.  We don't want to define it if there is no .dynamic      section, since on some ELF platforms the start up code examines it      to decide how to initialize the process.  */
if|if
condition|(
operator|!
name|_bfd_elf_define_linkage_sym
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|s
argument_list|,
literal|"_DYNAMIC"
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|info
operator|->
name|emit_hash
condition|)
block|{
name|s
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|abfd
argument_list|,
literal|".hash"
argument_list|,
name|flags
operator||
name|SEC_READONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|bed
operator|->
name|s
operator|->
name|log_file_align
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
operator|=
name|bed
operator|->
name|s
operator|->
name|sizeof_hash_entry
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|emit_gnu_hash
condition|)
block|{
name|s
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|abfd
argument_list|,
literal|".gnu.hash"
argument_list|,
name|flags
operator||
name|SEC_READONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|bed
operator|->
name|s
operator|->
name|log_file_align
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* For 64-bit ELF, .gnu.hash is a non-uniform entity size section: 	 4 32-bit words followed by variable count of 64-bit words, then 	 variable count of 32-bit words.  */
if|if
condition|(
name|bed
operator|->
name|s
operator|->
name|arch_size
operator|==
literal|64
condition|)
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
operator|=
literal|0
expr_stmt|;
else|else
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
operator|=
literal|4
expr_stmt|;
block|}
comment|/* Let the backend create the rest of the sections.  This lets the      backend set the right flags.  The backend will normally create      the .got and .plt sections.  */
if|if
condition|(
operator|!
call|(
modifier|*
name|bed
operator|->
name|elf_backend_create_dynamic_sections
call|)
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Create dynamic sections when linking against a dynamic object.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_elf_create_dynamic_sections
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|flagword
name|flags
decl_stmt|,
name|pltflags
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
comment|/* We need to create .plt, .rel[a].plt, .got, .got.plt, .dynbss, and      .rel[a].bss sections.  */
name|flags
operator|=
name|bed
operator|->
name|dynamic_sec_flags
expr_stmt|;
name|pltflags
operator|=
name|flags
expr_stmt|;
if|if
condition|(
name|bed
operator|->
name|plt_not_loaded
condition|)
comment|/* We do not clear SEC_ALLOC here because we still want the OS to        allocate space for the section; it's just that there's nothing        to read in from the object file.  */
name|pltflags
operator|&=
operator|~
operator|(
name|SEC_CODE
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator|)
expr_stmt|;
else|else
name|pltflags
operator||=
name|SEC_ALLOC
operator||
name|SEC_CODE
operator||
name|SEC_LOAD
expr_stmt|;
if|if
condition|(
name|bed
operator|->
name|plt_readonly
condition|)
name|pltflags
operator||=
name|SEC_READONLY
expr_stmt|;
name|s
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|abfd
argument_list|,
literal|".plt"
argument_list|,
name|pltflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|bed
operator|->
name|plt_alignment
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Define the symbol _PROCEDURE_LINKAGE_TABLE_ at the start of the      .plt section.  */
if|if
condition|(
name|bed
operator|->
name|want_plt_sym
condition|)
block|{
name|h
operator|=
name|_bfd_elf_define_linkage_sym
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|s
argument_list|,
literal|"_PROCEDURE_LINKAGE_TABLE_"
argument_list|)
expr_stmt|;
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|hplt
operator|=
name|h
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
name|s
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|abfd
argument_list|,
operator|(
name|bed
operator|->
name|default_use_rela_p
condition|?
literal|".rela.plt"
else|:
literal|".rel.plt"
operator|)
argument_list|,
name|flags
operator||
name|SEC_READONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|bed
operator|->
name|s
operator|->
name|log_file_align
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|_bfd_elf_create_got_section
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|bed
operator|->
name|want_dynbss
condition|)
block|{
comment|/* The .dynbss section is a place to put symbols which are defined 	 by dynamic objects, are referenced by regular objects, and are 	 not functions.  We must allocate space for them in the process 	 image and use a R_*_COPY reloc to tell the dynamic linker to 	 initialize them at run time.  The linker script puts the .dynbss 	 section into the .bss section of the final image.  */
name|s
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|abfd
argument_list|,
literal|".dynbss"
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LINKER_CREATED
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* The .rel[a].bss section holds copy relocs.  This section is not 	 normally needed.  We need to create it here, though, so that the 	 linker will map it to an output section.  We can't just create it 	 only if we need it, because we will not know whether we need it 	 until we have seen all the input files, and the first time the 	 main linker code calls BFD after examining all the input files 	 (size_dynamic_sections) the input sections have already been 	 mapped to the output sections.  If the section turns out not to 	 be needed, we can discard it later.  We will never need this 	 section when generating a shared object, since they do not use 	 copy relocs.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
name|s
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|abfd
argument_list|,
operator|(
name|bed
operator|->
name|default_use_rela_p
condition|?
literal|".rela.bss"
else|:
literal|".rel.bss"
operator|)
argument_list|,
name|flags
operator||
name|SEC_READONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|bed
operator|->
name|s
operator|->
name|log_file_align
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Record a new dynamic symbol.  We record the dynamic symbols as we    read the input files, since we need to have a list of all of them    before we can determine the final sizes of the output sections.    Note that we may actually call this function even though we are not    going to output any dynamic symbols; in some cases we know that a    symbol should be in the dynamic symbol table, but only if there is    one.  */
end_comment

begin_function
name|bfd_boolean
name|bfd_elf_link_record_dynamic_symbol
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|)
block|{
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
block|{
name|struct
name|elf_strtab_hash
modifier|*
name|dynstr
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bfd_size_type
name|indx
decl_stmt|;
comment|/* XXX: The ABI draft says the linker must turn hidden and 	 internal symbols into STB_LOCAL symbols when producing the 	 DSO. However, if ld.so honors st_other in the dynamic table, 	 this would not be necessary.  */
switch|switch
condition|(
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
condition|)
block|{
case|case
name|STV_INTERNAL
case|:
case|case
name|STV_HIDDEN
case|:
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefined
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefweak
condition|)
block|{
name|h
operator|->
name|forced_local
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|is_relocatable_executable
condition|)
return|return
name|TRUE
return|;
block|}
default|default:
break|break;
block|}
name|h
operator|->
name|dynindx
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynsymcount
expr_stmt|;
operator|++
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynsymcount
expr_stmt|;
name|dynstr
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
expr_stmt|;
if|if
condition|(
name|dynstr
operator|==
name|NULL
condition|)
block|{
comment|/* Create a strtab to hold the dynamic symbol names.  */
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
operator|=
name|dynstr
operator|=
name|_bfd_elf_strtab_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|dynstr
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* We don't put any version information in the dynamic string 	 table.  */
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
name|ELF_VER_CHR
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
comment|/* We know that the p points into writable memory.  In fact, 	   there are only a few symbols that have read-only names, being 	   those like _GLOBAL_OFFSET_TABLE_ that are created specially 	   by the backends.  Most symbols will have names pointing into 	   an ELF string table read from a file, or to objalloc memory.  */
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|indx
operator|=
name|_bfd_elf_strtab_add
argument_list|(
name|dynstr
argument_list|,
name|name
argument_list|,
name|p
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
name|ELF_VER_CHR
expr_stmt|;
if|if
condition|(
name|indx
operator|==
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
condition|)
return|return
name|FALSE
return|;
name|h
operator|->
name|dynstr_index
operator|=
name|indx
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Mark a symbol dynamic.  */
end_comment

begin_function
name|void
name|bfd_elf_link_mark_dynamic_symbol
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|)
block|{
name|struct
name|bfd_elf_dynamic_list
modifier|*
name|d
init|=
name|info
operator|->
name|dynamic_list
decl_stmt|;
comment|/* It may be called more than once on the same H.  */
if|if
condition|(
name|h
operator|->
name|dynamic
operator|||
name|info
operator|->
name|relocatable
condition|)
return|return;
if|if
condition|(
operator|(
name|info
operator|->
name|dynamic_data
operator|&&
operator|(
name|h
operator|->
name|type
operator|==
name|STT_OBJECT
operator|||
operator|(
name|sym
operator|!=
name|NULL
operator|&&
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_OBJECT
operator|)
operator|)
operator|)
operator|||
operator|(
name|d
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_new
operator|&&
call|(
modifier|*
name|d
operator|->
name|match
call|)
argument_list|(
operator|&
name|d
operator|->
name|head
argument_list|,
name|NULL
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
operator|)
condition|)
name|h
operator|->
name|dynamic
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record an assignment to a symbol made by a linker script.  We need    this in case some dynamic object refers to this symbol.  */
end_comment

begin_function
name|bfd_boolean
name|bfd_elf_record_link_assignment
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|bfd_boolean
name|provide
parameter_list|,
name|bfd_boolean
name|hidden
parameter_list|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
if|if
condition|(
operator|!
name|is_elf_hash_table
argument_list|(
name|info
operator|->
name|hash
argument_list|)
condition|)
return|return
name|TRUE
return|;
name|htab
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|h
operator|=
name|elf_link_hash_lookup
argument_list|(
name|htab
argument_list|,
name|name
argument_list|,
operator|!
name|provide
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
return|return
name|provide
return|;
comment|/* Since we're defining the symbol, don't let it seem to have not      been defined.  record_dynamic_symbol and size_dynamic_sections      may depend on this.  */
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
condition|)
block|{
name|h
operator|->
name|root
operator|.
name|type
operator|=
name|bfd_link_hash_new
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|undef
operator|.
name|next
operator|!=
name|NULL
operator|||
name|htab
operator|->
name|root
operator|.
name|undefs_tail
operator|==
operator|&
name|h
operator|->
name|root
condition|)
name|bfd_link_repair_undef_list
argument_list|(
operator|&
name|htab
operator|->
name|root
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_new
condition|)
block|{
name|bfd_elf_link_mark_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|h
operator|->
name|non_elf
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
condition|)
block|{
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|output_bfd
argument_list|)
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|hv
init|=
name|h
decl_stmt|;
do|do
name|hv
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|hv
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
do|while
condition|(
name|hv
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|hv
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
do|;
name|h
operator|->
name|root
operator|.
name|type
operator|=
name|bfd_link_hash_undefined
expr_stmt|;
name|hv
operator|->
name|root
operator|.
name|type
operator|=
name|bfd_link_hash_indirect
expr_stmt|;
name|hv
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
operator|=
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
call|(
modifier|*
name|bed
operator|->
name|elf_backend_copy_indirect_symbol
call|)
argument_list|(
name|info
argument_list|,
name|h
argument_list|,
name|hv
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* If this symbol is being provided by the linker script, and it is      currently defined by a dynamic object, but not by a regular      object, then mark it as undefined so that the generic linker will      force the correct value.  */
if|if
condition|(
name|provide
operator|&&
name|h
operator|->
name|def_dynamic
operator|&&
operator|!
name|h
operator|->
name|def_regular
condition|)
name|h
operator|->
name|root
operator|.
name|type
operator|=
name|bfd_link_hash_undefined
expr_stmt|;
comment|/* If this symbol is not being provided by the linker script, and it is      currently defined by a dynamic object, but not by a regular object,      then clear out any version information because the symbol will not be      associated with the dynamic object any more.  */
if|if
condition|(
operator|!
name|provide
operator|&&
name|h
operator|->
name|def_dynamic
operator|&&
operator|!
name|h
operator|->
name|def_regular
condition|)
name|h
operator|->
name|verinfo
operator|.
name|verdef
operator|=
name|NULL
expr_stmt|;
name|h
operator|->
name|def_regular
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|provide
operator|&&
name|hidden
condition|)
block|{
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|output_bfd
argument_list|)
decl_stmt|;
name|h
operator|->
name|other
operator|=
operator|(
name|h
operator|->
name|other
operator|&
operator|~
name|ELF_ST_VISIBILITY
argument_list|(
operator|-
literal|1
argument_list|)
operator|)
operator||
name|STV_HIDDEN
expr_stmt|;
call|(
modifier|*
name|bed
operator|->
name|elf_backend_hide_symbol
call|)
argument_list|(
name|info
argument_list|,
name|h
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
comment|/* STV_HIDDEN and STV_INTERNAL symbols must be STB_LOCAL in shared objects      and executables.  */
if|if
condition|(
operator|!
name|info
operator|->
name|relocatable
operator|&&
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_HIDDEN
operator|||
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_INTERNAL
operator|)
condition|)
name|h
operator|->
name|forced_local
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|h
operator|->
name|def_dynamic
operator|||
name|h
operator|->
name|ref_dynamic
operator|||
name|info
operator|->
name|shared
operator|||
operator|(
name|info
operator|->
name|executable
operator|&&
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|is_relocatable_executable
operator|)
operator|)
operator|&&
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* If this is a weak defined symbol, and we know a corresponding 	 real symbol from the same dynamic object, make sure the real 	 symbol is also made into a dynamic symbol.  */
if|if
condition|(
name|h
operator|->
name|u
operator|.
name|weakdef
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|u
operator|.
name|weakdef
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Record a new local dynamic symbol.  Returns 0 on failure, 1 on    success, and 2 on a failure caused by attempting to record a symbol    in a discarded section, eg. a discarded link-once section symbol.  */
end_comment

begin_function
name|int
name|bfd_elf_link_record_local_dynamic_symbol
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|long
name|input_indx
parameter_list|)
block|{
name|bfd_size_type
name|amt
decl_stmt|;
name|struct
name|elf_link_local_dynamic_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|elf_link_hash_table
modifier|*
name|eht
decl_stmt|;
name|struct
name|elf_strtab_hash
modifier|*
name|dynstr
decl_stmt|;
name|unsigned
name|long
name|dynstr_index
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|Elf_External_Sym_Shndx
name|eshndx
decl_stmt|;
name|char
name|esym
index|[
sizeof|sizeof
argument_list|(
name|Elf64_External_Sym
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|is_elf_hash_table
argument_list|(
name|info
operator|->
name|hash
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* See if the entry exists already.  */
for|for
control|(
name|entry
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynlocal
init|;
name|entry
condition|;
name|entry
operator|=
name|entry
operator|->
name|next
control|)
if|if
condition|(
name|entry
operator|->
name|input_bfd
operator|==
name|input_bfd
operator|&&
name|entry
operator|->
name|input_indx
operator|==
name|input_indx
condition|)
return|return
literal|1
return|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
expr_stmt|;
name|entry
operator|=
name|bfd_alloc
argument_list|(
name|input_bfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* Go find the symbol, so that we can find it's name.  */
if|if
condition|(
operator|!
name|bfd_elf_get_elf_syms
argument_list|(
name|input_bfd
argument_list|,
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
argument_list|,
literal|1
argument_list|,
name|input_indx
argument_list|,
operator|&
name|entry
operator|->
name|isym
argument_list|,
name|esym
argument_list|,
operator|&
name|eshndx
argument_list|)
condition|)
block|{
name|bfd_release
argument_list|(
name|input_bfd
argument_list|,
name|entry
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|entry
operator|->
name|isym
operator|.
name|st_shndx
operator|!=
name|SHN_UNDEF
operator|&&
operator|(
name|entry
operator|->
name|isym
operator|.
name|st_shndx
operator|<
name|SHN_LORESERVE
operator|||
name|entry
operator|->
name|isym
operator|.
name|st_shndx
operator|>
name|SHN_HIRESERVE
operator|)
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|input_bfd
argument_list|,
name|entry
operator|->
name|isym
operator|.
name|st_shndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
name|bfd_is_abs_section
argument_list|(
name|s
operator|->
name|output_section
argument_list|)
condition|)
block|{
comment|/* We can still bfd_release here as nothing has done another 	     bfd_alloc.  We can't do this later in this function.  */
name|bfd_release
argument_list|(
name|input_bfd
argument_list|,
name|entry
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
block|}
name|name
operator|=
operator|(
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
operator|.
name|sh_link
argument_list|,
name|entry
operator|->
name|isym
operator|.
name|st_name
argument_list|)
operator|)
expr_stmt|;
name|dynstr
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
expr_stmt|;
if|if
condition|(
name|dynstr
operator|==
name|NULL
condition|)
block|{
comment|/* Create a strtab to hold the dynamic symbol names.  */
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
operator|=
name|dynstr
operator|=
name|_bfd_elf_strtab_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|dynstr
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
block|}
name|dynstr_index
operator|=
name|_bfd_elf_strtab_add
argument_list|(
name|dynstr
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynstr_index
operator|==
operator|(
name|unsigned
name|long
operator|)
operator|-
literal|1
condition|)
return|return
literal|0
return|;
name|entry
operator|->
name|isym
operator|.
name|st_name
operator|=
name|dynstr_index
expr_stmt|;
name|eht
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|entry
operator|->
name|next
operator|=
name|eht
operator|->
name|dynlocal
expr_stmt|;
name|eht
operator|->
name|dynlocal
operator|=
name|entry
expr_stmt|;
name|entry
operator|->
name|input_bfd
operator|=
name|input_bfd
expr_stmt|;
name|entry
operator|->
name|input_indx
operator|=
name|input_indx
expr_stmt|;
name|eht
operator|->
name|dynsymcount
operator|++
expr_stmt|;
comment|/* Whatever binding the symbol had before, it's now local.  */
name|entry
operator|->
name|isym
operator|.
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_LOCAL
argument_list|,
name|ELF_ST_TYPE
argument_list|(
name|entry
operator|->
name|isym
operator|.
name|st_info
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The dynindx will be set at the end of size_dynamic_sections.  */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return the dynindex of a local dynamic symbol.  */
end_comment

begin_function
name|long
name|_bfd_elf_link_lookup_local_dynindx
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|long
name|input_indx
parameter_list|)
block|{
name|struct
name|elf_link_local_dynamic_entry
modifier|*
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynlocal
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next
control|)
if|if
condition|(
name|e
operator|->
name|input_bfd
operator|==
name|input_bfd
operator|&&
name|e
operator|->
name|input_indx
operator|==
name|input_indx
condition|)
return|return
name|e
operator|->
name|dynindx
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* This function is used to renumber the dynamic symbols, if some of    them are removed because they are marked as local.  This is called    via elf_link_hash_traverse.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_link_renumber_hash_table_dynsyms
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|size_t
modifier|*
name|count
init|=
name|data
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|forced_local
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
condition|)
name|h
operator|->
name|dynindx
operator|=
operator|++
operator|(
operator|*
name|count
operator|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Like elf_link_renumber_hash_table_dynsyms, but just number symbols with    STB_LOCAL binding.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_link_renumber_local_hash_table_dynsyms
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|size_t
modifier|*
name|count
init|=
name|data
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
operator|!
name|h
operator|->
name|forced_local
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
condition|)
name|h
operator|->
name|dynindx
operator|=
operator|++
operator|(
operator|*
name|count
operator|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return true if the dynamic symbol for a given section should be    omitted when creating a shared library.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_elf_link_omit_section_dynsym
parameter_list|(
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|asection
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
switch|switch
condition|(
name|elf_section_data
argument_list|(
name|p
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_type
condition|)
block|{
case|case
name|SHT_PROGBITS
case|:
case|case
name|SHT_NOBITS
case|:
comment|/* If sh_type is yet undecided, assume it could be 	 SHT_PROGBITS/SHT_NOBITS.  */
case|case
name|SHT_NULL
case|:
name|htab
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|htab
operator|->
name|tls_sec
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|htab
operator|->
name|text_index_section
operator|!=
name|NULL
condition|)
return|return
name|p
operator|!=
name|htab
operator|->
name|text_index_section
operator|&&
name|p
operator|!=
name|htab
operator|->
name|data_index_section
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|p
operator|->
name|name
argument_list|,
literal|".got"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|p
operator|->
name|name
argument_list|,
literal|".got.plt"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|p
operator|->
name|name
argument_list|,
literal|".plt"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|asection
modifier|*
name|ip
decl_stmt|;
if|if
condition|(
name|htab
operator|->
name|dynobj
operator|!=
name|NULL
operator|&&
operator|(
name|ip
operator|=
name|bfd_get_section_by_name
argument_list|(
name|htab
operator|->
name|dynobj
argument_list|,
name|p
operator|->
name|name
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|ip
operator|->
name|flags
operator|&
name|SEC_LINKER_CREATED
operator|)
operator|&&
name|ip
operator|->
name|output_section
operator|==
name|p
condition|)
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
comment|/* There shouldn't be section relative relocations 	 against any other section.  */
default|default:
return|return
name|TRUE
return|;
block|}
block|}
end_function

begin_comment
comment|/* Assign dynsym indices.  In a shared library we generate a section    symbol for each output section, which come first.  Next come symbols    which have been forced to local binding.  Then all of the back-end    allocated local dynamic syms, followed by the rest of the global    symbols.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|_bfd_elf_link_renumber_dynsyms
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|unsigned
name|long
modifier|*
name|section_sym_count
parameter_list|)
block|{
name|unsigned
name|long
name|dynsymcount
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
operator|||
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|is_relocatable_executable
condition|)
block|{
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|output_bfd
argument_list|)
decl_stmt|;
name|asection
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|output_bfd
operator|->
name|sections
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
operator|(
name|p
operator|->
name|flags
operator|&
name|SEC_EXCLUDE
operator|)
operator|==
literal|0
operator|&&
operator|(
name|p
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
operator|&&
operator|!
call|(
modifier|*
name|bed
operator|->
name|elf_backend_omit_section_dynsym
call|)
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|p
argument_list|)
condition|)
name|elf_section_data
argument_list|(
name|p
argument_list|)
operator|->
name|dynindx
operator|=
operator|++
name|dynsymcount
expr_stmt|;
else|else
name|elf_section_data
argument_list|(
name|p
argument_list|)
operator|->
name|dynindx
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|section_sym_count
operator|=
name|dynsymcount
expr_stmt|;
name|elf_link_hash_traverse
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|elf_link_renumber_local_hash_table_dynsyms
argument_list|,
operator|&
name|dynsymcount
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynlocal
condition|)
block|{
name|struct
name|elf_link_local_dynamic_entry
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynlocal
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
name|p
operator|->
name|dynindx
operator|=
operator|++
name|dynsymcount
expr_stmt|;
block|}
name|elf_link_hash_traverse
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|elf_link_renumber_hash_table_dynsyms
argument_list|,
operator|&
name|dynsymcount
argument_list|)
expr_stmt|;
comment|/* There is an unused NULL entry at the head of the table which      we must account for in our count.  Unless there weren't any      symbols, which means we'll have no table at all.  */
if|if
condition|(
name|dynsymcount
operator|!=
literal|0
condition|)
operator|++
name|dynsymcount
expr_stmt|;
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynsymcount
operator|=
name|dynsymcount
expr_stmt|;
return|return
name|dynsymcount
return|;
block|}
end_function

begin_comment
comment|/* This function is called when we want to define a new symbol.  It    handles the various cases which arise when we find a definition in    a dynamic object, or when there is already a definition in a    dynamic object.  The new symbol is described by NAME, SYM, PSEC,    and PVALUE.  We set SYM_HASH to the hash table entry.  We set    OVERRIDE if the old symbol is overriding a new definition.  We set    TYPE_CHANGE_OK if it is OK for the type to change.  We set    SIZE_CHANGE_OK if it is OK for the size to change.  By OK to    change, we mean that we shouldn't warn if the type or size does    change.  We set POLD_ALIGNMENT if an old common symbol in a dynamic    object is overridden by a regular object.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_elf_merge_symbol
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|,
name|asection
modifier|*
modifier|*
name|psec
parameter_list|,
name|bfd_vma
modifier|*
name|pvalue
parameter_list|,
name|unsigned
name|int
modifier|*
name|pold_alignment
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hash
parameter_list|,
name|bfd_boolean
modifier|*
name|skip
parameter_list|,
name|bfd_boolean
modifier|*
name|override
parameter_list|,
name|bfd_boolean
modifier|*
name|type_change_ok
parameter_list|,
name|bfd_boolean
modifier|*
name|size_change_ok
parameter_list|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|,
modifier|*
name|oldsec
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|flip
decl_stmt|;
name|int
name|bind
decl_stmt|;
name|bfd
modifier|*
name|oldbfd
decl_stmt|;
name|bfd_boolean
name|newdyn
decl_stmt|,
name|olddyn
decl_stmt|,
name|olddef
decl_stmt|,
name|newdef
decl_stmt|,
name|newdyncommon
decl_stmt|,
name|olddyncommon
decl_stmt|;
name|bfd_boolean
name|newweak
decl_stmt|,
name|oldweak
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
operator|*
name|skip
operator|=
name|FALSE
expr_stmt|;
operator|*
name|override
operator|=
name|FALSE
expr_stmt|;
name|sec
operator|=
operator|*
name|psec
expr_stmt|;
name|bind
operator|=
name|ELF_ST_BIND
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
expr_stmt|;
comment|/* Silently discard TLS symbols from --just-syms.  There's no way to      combine a static TLS block with a new TLS block for this executable.  */
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_TLS
operator|&&
name|sec
operator|->
name|sec_info_type
operator|==
name|ELF_INFO_TYPE_JUST_SYMS
condition|)
block|{
operator|*
name|skip
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
operator|!
name|bfd_is_und_section
argument_list|(
name|sec
argument_list|)
condition|)
name|h
operator|=
name|elf_link_hash_lookup
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|name
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
else|else
name|h
operator|=
operator|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|bfd_wrapped_link_hash_lookup
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|name
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
operator|*
name|sym_hash
operator|=
name|h
expr_stmt|;
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* This code is for coping with dynamic objects, and is only useful      if we are doing an ELF link.  */
if|if
condition|(
operator|!
call|(
modifier|*
name|bed
operator|->
name|relocs_compatible
call|)
argument_list|(
name|abfd
operator|->
name|xvec
argument_list|,
name|info
operator|->
name|hash
operator|->
name|creator
argument_list|)
condition|)
return|return
name|TRUE
return|;
comment|/* For merging, we only care about real symbols.  */
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
comment|/* We have to check it for every instance since the first few may be      refereences and not all compilers emit symbol type for undefined      symbols.  */
name|bfd_elf_link_mark_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|,
name|sym
argument_list|)
expr_stmt|;
comment|/* If we just created the symbol, mark it as being an ELF symbol.      Other than that, there is nothing to do--there is no merge issue      with a newly defined symbol--so we just return.  */
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_new
condition|)
block|{
name|h
operator|->
name|non_elf
operator|=
literal|0
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* OLDBFD and OLDSEC are a BFD and an ASECTION associated with the      existing symbol.  */
switch|switch
condition|(
name|h
operator|->
name|root
operator|.
name|type
condition|)
block|{
default|default:
name|oldbfd
operator|=
name|NULL
expr_stmt|;
name|oldsec
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|bfd_link_hash_undefined
case|:
case|case
name|bfd_link_hash_undefweak
case|:
name|oldbfd
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|undef
operator|.
name|abfd
expr_stmt|;
name|oldsec
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|bfd_link_hash_defined
case|:
case|case
name|bfd_link_hash_defweak
case|:
name|oldbfd
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
expr_stmt|;
name|oldsec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
break|break;
case|case
name|bfd_link_hash_common
case|:
name|oldbfd
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
operator|->
name|owner
expr_stmt|;
name|oldsec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
expr_stmt|;
break|break;
block|}
comment|/* In cases involving weak versioned symbols, we may wind up trying      to merge a symbol with itself.  Catch that here, to avoid the      confusion that results if we try to override a symbol with      itself.  The additional tests catch cases like      _GLOBAL_OFFSET_TABLE_, which are regular symbols defined in a      dynamic object, which we do want to handle here.  */
if|if
condition|(
name|abfd
operator|==
name|oldbfd
operator|&&
operator|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|==
literal|0
operator|||
operator|!
name|h
operator|->
name|def_regular
operator|)
condition|)
return|return
name|TRUE
return|;
comment|/* NEWDYN and OLDDYN indicate whether the new or old symbol,      respectively, is from a dynamic object.  */
name|newdyn
operator|=
operator|(
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
expr_stmt|;
name|olddyn
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|oldbfd
operator|!=
name|NULL
condition|)
name|olddyn
operator|=
operator|(
name|oldbfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|oldsec
operator|!=
name|NULL
condition|)
block|{
comment|/* This handles the special SHN_MIPS_{TEXT,DATA} section 	 indices used by MIPS ELF.  */
name|olddyn
operator|=
operator|(
name|oldsec
operator|->
name|symbol
operator|->
name|flags
operator|&
name|BSF_DYNAMIC
operator|)
operator|!=
literal|0
expr_stmt|;
block|}
comment|/* NEWDEF and OLDDEF indicate whether the new or old symbol,      respectively, appear to be a definition rather than reference.  */
name|newdef
operator|=
operator|!
name|bfd_is_und_section
argument_list|(
name|sec
argument_list|)
operator|&&
operator|!
name|bfd_is_com_section
argument_list|(
name|sec
argument_list|)
expr_stmt|;
name|olddef
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefined
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefweak
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_common
operator|)
expr_stmt|;
comment|/* When we try to create a default indirect symbol from the dynamic      definition with the default version, we skip it if its type and      the type of existing regular definition mismatch.  We only do it      if the existing regular definition won't be dynamic.  */
if|if
condition|(
name|pold_alignment
operator|==
name|NULL
operator|&&
operator|!
name|info
operator|->
name|shared
operator|&&
operator|!
name|info
operator|->
name|export_dynamic
operator|&&
operator|!
name|h
operator|->
name|ref_dynamic
operator|&&
name|newdyn
operator|&&
name|newdef
operator|&&
operator|!
name|olddyn
operator|&&
operator|(
name|olddef
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_common
operator|)
operator|&&
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|!=
name|h
operator|->
name|type
operator|&&
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|!=
name|STT_NOTYPE
operator|&&
name|h
operator|->
name|type
operator|!=
name|STT_NOTYPE
operator|&&
operator|!
operator|(
name|bed
operator|->
name|is_function_type
argument_list|(
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
argument_list|)
operator|&&
name|bed
operator|->
name|is_function_type
argument_list|(
name|h
operator|->
name|type
argument_list|)
operator|)
condition|)
block|{
operator|*
name|skip
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* Check TLS symbol.  We don't check undefined symbol introduced by      "ld -u".  */
if|if
condition|(
operator|(
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_TLS
operator|||
name|h
operator|->
name|type
operator|==
name|STT_TLS
operator|)
operator|&&
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|!=
name|h
operator|->
name|type
operator|&&
name|oldbfd
operator|!=
name|NULL
condition|)
block|{
name|bfd
modifier|*
name|ntbfd
decl_stmt|,
modifier|*
name|tbfd
decl_stmt|;
name|bfd_boolean
name|ntdef
decl_stmt|,
name|tdef
decl_stmt|;
name|asection
modifier|*
name|ntsec
decl_stmt|,
modifier|*
name|tsec
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|type
operator|==
name|STT_TLS
condition|)
block|{
name|ntbfd
operator|=
name|abfd
expr_stmt|;
name|ntsec
operator|=
name|sec
expr_stmt|;
name|ntdef
operator|=
name|newdef
expr_stmt|;
name|tbfd
operator|=
name|oldbfd
expr_stmt|;
name|tsec
operator|=
name|oldsec
expr_stmt|;
name|tdef
operator|=
name|olddef
expr_stmt|;
block|}
else|else
block|{
name|ntbfd
operator|=
name|oldbfd
expr_stmt|;
name|ntsec
operator|=
name|oldsec
expr_stmt|;
name|ntdef
operator|=
name|olddef
expr_stmt|;
name|tbfd
operator|=
name|abfd
expr_stmt|;
name|tsec
operator|=
name|sec
expr_stmt|;
name|tdef
operator|=
name|newdef
expr_stmt|;
block|}
if|if
condition|(
name|tdef
operator|&&
name|ntdef
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: TLS definition in %B section %A mismatches non-TLS definition in %B section %A"
argument_list|)
argument_list|,
name|tbfd
argument_list|,
name|tsec
argument_list|,
name|ntbfd
argument_list|,
name|ntsec
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|tdef
operator|&&
operator|!
name|ntdef
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: TLS reference in %B mismatches non-TLS reference in %B"
argument_list|)
argument_list|,
name|tbfd
argument_list|,
name|ntbfd
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tdef
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: TLS definition in %B section %A mismatches non-TLS reference in %B"
argument_list|)
argument_list|,
name|tbfd
argument_list|,
name|tsec
argument_list|,
name|ntbfd
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: TLS reference in %B mismatches non-TLS definition in %B section %A"
argument_list|)
argument_list|,
name|tbfd
argument_list|,
name|ntbfd
argument_list|,
name|ntsec
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* We need to remember if a symbol has a definition in a dynamic      object or is weak in all dynamic objects. Internal and hidden      visibility will make it unavailable to dynamic objects.  */
if|if
condition|(
name|newdyn
operator|&&
operator|!
name|h
operator|->
name|dynamic_def
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_is_und_section
argument_list|(
name|sec
argument_list|)
condition|)
name|h
operator|->
name|dynamic_def
operator|=
literal|1
expr_stmt|;
else|else
block|{
comment|/* Check if this symbol is weak in all dynamic objects. If it 	     is the first time we see it in a dynamic object, we mark 	     if it is weak. Otherwise, we clear it.  */
if|if
condition|(
operator|!
name|h
operator|->
name|ref_dynamic
condition|)
block|{
if|if
condition|(
name|bind
operator|==
name|STB_WEAK
condition|)
name|h
operator|->
name|dynamic_weak
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bind
operator|!=
name|STB_WEAK
condition|)
name|h
operator|->
name|dynamic_weak
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* If the old symbol has non-default visibility, we ignore the new      definition from a dynamic object.  */
if|if
condition|(
name|newdyn
operator|&&
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|!=
name|STV_DEFAULT
operator|&&
operator|!
name|bfd_is_und_section
argument_list|(
name|sec
argument_list|)
condition|)
block|{
operator|*
name|skip
operator|=
name|TRUE
expr_stmt|;
comment|/* Make sure this symbol is dynamic.  */
name|h
operator|->
name|ref_dynamic
operator|=
literal|1
expr_stmt|;
comment|/* A protected symbol has external availability. Make sure it is 	 recorded as dynamic.  	 FIXME: Should we check type and size for protected symbol?  */
if|if
condition|(
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_PROTECTED
condition|)
return|return
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
return|;
else|else
return|return
name|TRUE
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|newdyn
operator|&&
name|ELF_ST_VISIBILITY
argument_list|(
name|sym
operator|->
name|st_other
argument_list|)
operator|!=
name|STV_DEFAULT
operator|&&
name|h
operator|->
name|def_dynamic
condition|)
block|{
comment|/* If the new symbol with non-default visibility comes from a 	 relocatable file and the old definition comes from a dynamic 	 object, we remove the old definition.  */
if|if
condition|(
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
condition|)
block|{
comment|/* Handle the case where the old dynamic definition is 	     default versioned.  We need to copy the symbol info from 	     the symbol with default version to the normal one if it 	     was referenced before.  */
if|if
condition|(
name|h
operator|->
name|ref_regular
condition|)
block|{
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|vh
init|=
operator|*
name|sym_hash
decl_stmt|;
name|vh
operator|->
name|root
operator|.
name|type
operator|=
name|h
operator|->
name|root
operator|.
name|type
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|type
operator|=
name|bfd_link_hash_indirect
expr_stmt|;
call|(
modifier|*
name|bed
operator|->
name|elf_backend_copy_indirect_symbol
call|)
argument_list|(
name|info
argument_list|,
name|vh
argument_list|,
name|h
argument_list|)
expr_stmt|;
comment|/* Protected symbols will override the dynamic definition 		 with default version.  */
if|if
condition|(
name|ELF_ST_VISIBILITY
argument_list|(
name|sym
operator|->
name|st_other
argument_list|)
operator|==
name|STV_PROTECTED
condition|)
block|{
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
operator|=
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|)
name|vh
expr_stmt|;
name|vh
operator|->
name|dynamic_def
operator|=
literal|1
expr_stmt|;
name|vh
operator|->
name|ref_dynamic
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|h
operator|->
name|root
operator|.
name|type
operator|=
name|vh
operator|->
name|root
operator|.
name|type
expr_stmt|;
name|vh
operator|->
name|ref_dynamic
operator|=
literal|0
expr_stmt|;
comment|/* We have to hide it here since it was made dynamic 		     global with extra bits when the symbol info was 		     copied from the old dynamic definition.  */
call|(
modifier|*
name|bed
operator|->
name|elf_backend_hide_symbol
call|)
argument_list|(
name|info
argument_list|,
name|vh
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
name|h
operator|=
name|vh
expr_stmt|;
block|}
else|else
name|h
operator|=
operator|*
name|sym_hash
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|undef
operator|.
name|next
operator|||
name|info
operator|->
name|hash
operator|->
name|undefs_tail
operator|==
operator|&
name|h
operator|->
name|root
operator|)
operator|&&
name|bfd_is_und_section
argument_list|(
name|sec
argument_list|)
condition|)
block|{
comment|/* If the new symbol is undefined and the old symbol was 	     also undefined before, we need to make sure 	     _bfd_generic_link_add_one_symbol doesn't mess 	     up the linker hash table undefs list.  Since the old 	     definition came from a dynamic object, it is still on the 	     undefs list.  */
name|h
operator|->
name|root
operator|.
name|type
operator|=
name|bfd_link_hash_undefined
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|undef
operator|.
name|abfd
operator|=
name|abfd
expr_stmt|;
block|}
else|else
block|{
name|h
operator|->
name|root
operator|.
name|type
operator|=
name|bfd_link_hash_new
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|undef
operator|.
name|abfd
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|->
name|def_dynamic
condition|)
block|{
name|h
operator|->
name|def_dynamic
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|ref_dynamic
operator|=
literal|1
expr_stmt|;
name|h
operator|->
name|dynamic_def
operator|=
literal|1
expr_stmt|;
block|}
comment|/* FIXME: Should we check type and size for protected symbol?  */
name|h
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|type
operator|=
literal|0
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* Differentiate strong and weak symbols.  */
name|newweak
operator|=
name|bind
operator|==
name|STB_WEAK
expr_stmt|;
name|oldweak
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|)
expr_stmt|;
comment|/* If a new weak symbol definition comes from a regular file and the      old symbol comes from a dynamic library, we treat the new one as      strong.  Similarly, an old weak symbol definition from a regular      file is treated as strong when the new symbol comes from a dynamic      library.  Further, an old weak symbol from a dynamic library is      treated as strong if the new symbol is from a dynamic library.      This reflects the way glibc's ld.so works.       Do this before setting *type_change_ok or *size_change_ok so that      we warn properly when dynamic library symbols are overridden.  */
if|if
condition|(
name|newdef
operator|&&
operator|!
name|newdyn
operator|&&
name|olddyn
condition|)
name|newweak
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|olddef
operator|&&
name|newdyn
condition|)
name|oldweak
operator|=
name|FALSE
expr_stmt|;
comment|/* Allow changes between different types of funciton symbol.  */
if|if
condition|(
name|bed
operator|->
name|is_function_type
argument_list|(
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
argument_list|)
operator|&&
name|bed
operator|->
name|is_function_type
argument_list|(
name|h
operator|->
name|type
argument_list|)
condition|)
operator|*
name|type_change_ok
operator|=
name|TRUE
expr_stmt|;
comment|/* It's OK to change the type if either the existing symbol or the      new symbol is weak.  A type change is also OK if the old symbol      is undefined and the new symbol is defined.  */
if|if
condition|(
name|oldweak
operator|||
name|newweak
operator|||
operator|(
name|newdef
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
operator|)
condition|)
operator|*
name|type_change_ok
operator|=
name|TRUE
expr_stmt|;
comment|/* It's OK to change the size if either the existing symbol or the      new symbol is weak, or if the old symbol is undefined.  */
if|if
condition|(
operator|*
name|type_change_ok
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
condition|)
operator|*
name|size_change_ok
operator|=
name|TRUE
expr_stmt|;
comment|/* NEWDYNCOMMON and OLDDYNCOMMON indicate whether the new or old      symbol, respectively, appears to be a common symbol in a dynamic      object.  If a symbol appears in an uninitialized section, and is      not weak, and is not a function, then it may be a common symbol      which was resolved when the dynamic object was created.  We want      to treat such symbols specially, because they raise special      considerations when setting the symbol size: if the symbol      appears as a common symbol in a regular object, and the size in      the regular object is larger, we must make sure that we use the      larger size.  This problematic case can always be avoided in C,      but it must be handled correctly when using Fortran shared      libraries.       Note that if NEWDYNCOMMON is set, NEWDEF will be set, and      likewise for OLDDYNCOMMON and OLDDEF.       Note that this test is just a heuristic, and that it is quite      possible to have an uninitialized symbol in a shared object which      is really a definition, rather than a common symbol.  This could      lead to some minor confusion when the symbol really is a common      symbol in some regular object.  However, I think it will be      harmless.  */
if|if
condition|(
name|newdyn
operator|&&
name|newdef
operator|&&
operator|!
name|newweak
operator|&&
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|==
literal|0
operator|&&
name|sym
operator|->
name|st_size
operator|>
literal|0
operator|&&
operator|!
name|bed
operator|->
name|is_function_type
argument_list|(
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
argument_list|)
condition|)
name|newdyncommon
operator|=
name|TRUE
expr_stmt|;
else|else
name|newdyncommon
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|olddyn
operator|&&
name|olddef
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|&&
name|h
operator|->
name|def_dynamic
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|==
literal|0
operator|&&
name|h
operator|->
name|size
operator|>
literal|0
operator|&&
operator|!
name|bed
operator|->
name|is_function_type
argument_list|(
name|h
operator|->
name|type
argument_list|)
condition|)
name|olddyncommon
operator|=
name|TRUE
expr_stmt|;
else|else
name|olddyncommon
operator|=
name|FALSE
expr_stmt|;
comment|/* We now know everything about the old and new symbols.  We ask the      backend to check if we can merge them.  */
if|if
condition|(
name|bed
operator|->
name|merge_symbol
operator|&&
operator|!
name|bed
operator|->
name|merge_symbol
argument_list|(
name|info
argument_list|,
name|sym_hash
argument_list|,
name|h
argument_list|,
name|sym
argument_list|,
name|psec
argument_list|,
name|pvalue
argument_list|,
name|pold_alignment
argument_list|,
name|skip
argument_list|,
name|override
argument_list|,
name|type_change_ok
argument_list|,
name|size_change_ok
argument_list|,
operator|&
name|newdyn
argument_list|,
operator|&
name|newdef
argument_list|,
operator|&
name|newdyncommon
argument_list|,
operator|&
name|newweak
argument_list|,
name|abfd
argument_list|,
operator|&
name|sec
argument_list|,
operator|&
name|olddyn
argument_list|,
operator|&
name|olddef
argument_list|,
operator|&
name|olddyncommon
argument_list|,
operator|&
name|oldweak
argument_list|,
name|oldbfd
argument_list|,
operator|&
name|oldsec
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* If both the old and the new symbols look like common symbols in a      dynamic object, set the size of the symbol to the larger of the      two.  */
if|if
condition|(
name|olddyncommon
operator|&&
name|newdyncommon
operator|&&
name|sym
operator|->
name|st_size
operator|!=
name|h
operator|->
name|size
condition|)
block|{
comment|/* Since we think we have two common symbols, issue a multiple 	 common warning if desired.  Note that we only warn if the 	 size is different.  If the size is the same, we simply let 	 the old symbol override the new one as normally happens with 	 symbols defined in dynamic objects.  */
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|multiple_common
call|)
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|oldbfd
argument_list|,
name|bfd_link_hash_common
argument_list|,
name|h
operator|->
name|size
argument_list|,
name|abfd
argument_list|,
name|bfd_link_hash_common
argument_list|,
name|sym
operator|->
name|st_size
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|sym
operator|->
name|st_size
operator|>
name|h
operator|->
name|size
condition|)
name|h
operator|->
name|size
operator|=
name|sym
operator|->
name|st_size
expr_stmt|;
operator|*
name|size_change_ok
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* If we are looking at a dynamic object, and we have found a      definition, we need to see if the symbol was already defined by      some other object.  If so, we want to use the existing      definition, and we do not want to report a multiple symbol      definition error; we do this by clobbering *PSEC to be      bfd_und_section_ptr.       We treat a common symbol as a definition if the symbol in the      shared library is a function, since common symbols always      represent variables; this can cause confusion in principle, but      any such confusion would seem to indicate an erroneous program or      shared library.  We also permit a common symbol in a regular      object to override a weak symbol in a shared object.  */
if|if
condition|(
name|newdyn
operator|&&
name|newdef
operator|&&
operator|(
name|olddef
operator|||
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_common
operator|&&
operator|(
name|newweak
operator|||
name|bed
operator|->
name|is_function_type
argument_list|(
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
operator|*
name|override
operator|=
name|TRUE
expr_stmt|;
name|newdef
operator|=
name|FALSE
expr_stmt|;
name|newdyncommon
operator|=
name|FALSE
expr_stmt|;
operator|*
name|psec
operator|=
name|sec
operator|=
name|bfd_und_section_ptr
expr_stmt|;
operator|*
name|size_change_ok
operator|=
name|TRUE
expr_stmt|;
comment|/* If we get here when the old symbol is a common symbol, then 	 we are explicitly letting it override a weak symbol or 	 function in a dynamic object, and we don't want to warn about 	 a type change.  If the old symbol is a defined symbol, a type 	 change warning may still be appropriate.  */
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_common
condition|)
operator|*
name|type_change_ok
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Handle the special case of an old common symbol merging with a      new symbol which looks like a common symbol in a shared object.      We change *PSEC and *PVALUE to make the new symbol look like a      common symbol, and let _bfd_generic_link_add_one_symbol do the      right thing.  */
if|if
condition|(
name|newdyncommon
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_common
condition|)
block|{
operator|*
name|override
operator|=
name|TRUE
expr_stmt|;
name|newdef
operator|=
name|FALSE
expr_stmt|;
name|newdyncommon
operator|=
name|FALSE
expr_stmt|;
operator|*
name|pvalue
operator|=
name|sym
operator|->
name|st_size
expr_stmt|;
operator|*
name|psec
operator|=
name|sec
operator|=
name|bed
operator|->
name|common_section
argument_list|(
name|oldsec
argument_list|)
expr_stmt|;
operator|*
name|size_change_ok
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Skip weak definitions of symbols that are already defined.  */
if|if
condition|(
name|newdef
operator|&&
name|olddef
operator|&&
name|newweak
condition|)
operator|*
name|skip
operator|=
name|TRUE
expr_stmt|;
comment|/* If the old symbol is from a dynamic object, and the new symbol is      a definition which is not from a dynamic object, then the new      symbol overrides the old symbol.  Symbols from regular files      always take precedence over symbols from dynamic objects, even if      they are defined after the dynamic object in the link.       As above, we again permit a common symbol in a regular object to      override a definition in a shared object if the shared object      symbol is a function or is weak.  */
name|flip
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|newdyn
operator|&&
operator|(
name|newdef
operator|||
operator|(
name|bfd_is_com_section
argument_list|(
name|sec
argument_list|)
operator|&&
operator|(
name|oldweak
operator|||
name|bed
operator|->
name|is_function_type
argument_list|(
name|h
operator|->
name|type
argument_list|)
operator|)
operator|)
operator|)
operator|&&
name|olddyn
operator|&&
name|olddef
operator|&&
name|h
operator|->
name|def_dynamic
condition|)
block|{
comment|/* Change the hash table entry to undefined, and let 	 _bfd_generic_link_add_one_symbol do the right thing with the 	 new definition.  */
name|h
operator|->
name|root
operator|.
name|type
operator|=
name|bfd_link_hash_undefined
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|undef
operator|.
name|abfd
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
expr_stmt|;
operator|*
name|size_change_ok
operator|=
name|TRUE
expr_stmt|;
name|olddef
operator|=
name|FALSE
expr_stmt|;
name|olddyncommon
operator|=
name|FALSE
expr_stmt|;
comment|/* We again permit a type change when a common symbol may be 	 overriding a function.  */
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|sec
argument_list|)
condition|)
operator|*
name|type_change_ok
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
condition|)
name|flip
operator|=
operator|*
name|sym_hash
expr_stmt|;
else|else
comment|/* This union may have been set to be non-NULL when this symbol 	   was seen in a dynamic object.  We must force the union to be 	   NULL, so that it is correct for a regular symbol.  */
name|h
operator|->
name|verinfo
operator|.
name|vertree
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Handle the special case of a new common symbol merging with an      old symbol that looks like it might be a common symbol defined in      a shared object.  Note that we have already handled the case in      which a new common symbol should simply override the definition      in the shared library.  */
if|if
condition|(
operator|!
name|newdyn
operator|&&
name|bfd_is_com_section
argument_list|(
name|sec
argument_list|)
operator|&&
name|olddyncommon
condition|)
block|{
comment|/* It would be best if we could set the hash table entry to a 	 common symbol, but we don't know what to use for the section 	 or the alignment.  */
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|multiple_common
call|)
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|oldbfd
argument_list|,
name|bfd_link_hash_common
argument_list|,
name|h
operator|->
name|size
argument_list|,
name|abfd
argument_list|,
name|bfd_link_hash_common
argument_list|,
name|sym
operator|->
name|st_size
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
comment|/* If the presumed common symbol in the dynamic object is 	 larger, pretend that the new symbol has its size.  */
if|if
condition|(
name|h
operator|->
name|size
operator|>
operator|*
name|pvalue
condition|)
operator|*
name|pvalue
operator|=
name|h
operator|->
name|size
expr_stmt|;
comment|/* We need to remember the alignment required by the symbol 	 in the dynamic object.  */
name|BFD_ASSERT
argument_list|(
name|pold_alignment
argument_list|)
expr_stmt|;
operator|*
name|pold_alignment
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|alignment_power
expr_stmt|;
name|olddef
operator|=
name|FALSE
expr_stmt|;
name|olddyncommon
operator|=
name|FALSE
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|type
operator|=
name|bfd_link_hash_undefined
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|undef
operator|.
name|abfd
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
expr_stmt|;
operator|*
name|size_change_ok
operator|=
name|TRUE
expr_stmt|;
operator|*
name|type_change_ok
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
condition|)
name|flip
operator|=
operator|*
name|sym_hash
expr_stmt|;
else|else
name|h
operator|->
name|verinfo
operator|.
name|vertree
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|flip
operator|!=
name|NULL
condition|)
block|{
comment|/* Handle the case where we had a versioned symbol in a dynamic 	 library and now find a definition in a normal object.  In this 	 case, we make the versioned symbol point to the normal one.  */
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|flip
operator|->
name|root
operator|.
name|type
operator|=
name|h
operator|->
name|root
operator|.
name|type
expr_stmt|;
name|flip
operator|->
name|root
operator|.
name|u
operator|.
name|undef
operator|.
name|abfd
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|undef
operator|.
name|abfd
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|type
operator|=
name|bfd_link_hash_indirect
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
operator|=
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|)
name|flip
expr_stmt|;
call|(
modifier|*
name|bed
operator|->
name|elf_backend_copy_indirect_symbol
call|)
argument_list|(
name|info
argument_list|,
name|flip
argument_list|,
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|def_dynamic
condition|)
block|{
name|h
operator|->
name|def_dynamic
operator|=
literal|0
expr_stmt|;
name|flip
operator|->
name|ref_dynamic
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* This function is called to create an indirect symbol from the    default for the symbol with the default version if needed. The    symbol is described by H, NAME, SYM, PSEC, VALUE, and OVERRIDE.  We    set DYNSYM if the new indirect symbol is dynamic.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_elf_add_default_symbol
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|,
name|asection
modifier|*
modifier|*
name|psec
parameter_list|,
name|bfd_vma
modifier|*
name|value
parameter_list|,
name|bfd_boolean
modifier|*
name|dynsym
parameter_list|,
name|bfd_boolean
name|override
parameter_list|)
block|{
name|bfd_boolean
name|type_change_ok
decl_stmt|;
name|bfd_boolean
name|size_change_ok
decl_stmt|;
name|bfd_boolean
name|skip
decl_stmt|;
name|char
modifier|*
name|shortname
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|hi
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|bh
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
name|bfd_boolean
name|collect
decl_stmt|;
name|bfd_boolean
name|dynamic
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|shortlen
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
comment|/* If this symbol has a version, and it is the default version, we      create an indirect symbol from the default name to the fully      decorated name.  This will cause external references which do not      specify a version to be bound to this version of the symbol.  */
name|p
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
name|ELF_VER_CHR
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|p
index|[
literal|1
index|]
operator|!=
name|ELF_VER_CHR
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|override
condition|)
block|{
comment|/* We are overridden by an old definition. We need to check if we 	 need to create the indirect symbol from the default name.  */
name|hi
operator|=
name|elf_link_hash_lookup
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|name
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|hi
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|hi
operator|==
name|h
condition|)
return|return
name|TRUE
return|;
while|while
condition|(
name|hi
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|hi
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
block|{
name|hi
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|hi
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|hi
operator|==
name|h
condition|)
return|return
name|TRUE
return|;
block|}
block|}
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|collect
operator|=
name|bed
operator|->
name|collect
expr_stmt|;
name|dynamic
operator|=
operator|(
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
expr_stmt|;
name|shortlen
operator|=
name|p
operator|-
name|name
expr_stmt|;
name|shortname
operator|=
name|bfd_hash_allocate
argument_list|(
operator|&
name|info
operator|->
name|hash
operator|->
name|table
argument_list|,
name|shortlen
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|shortname
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|memcpy
argument_list|(
name|shortname
argument_list|,
name|name
argument_list|,
name|shortlen
argument_list|)
expr_stmt|;
name|shortname
index|[
name|shortlen
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* We are going to create a new symbol.  Merge it with any existing      symbol with this name.  For the purposes of the merge, act as      though we were defining the symbol we just defined, although we      actually going to define an indirect symbol.  */
name|type_change_ok
operator|=
name|FALSE
expr_stmt|;
name|size_change_ok
operator|=
name|FALSE
expr_stmt|;
name|sec
operator|=
operator|*
name|psec
expr_stmt|;
if|if
condition|(
operator|!
name|_bfd_elf_merge_symbol
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|shortname
argument_list|,
name|sym
argument_list|,
operator|&
name|sec
argument_list|,
name|value
argument_list|,
name|NULL
argument_list|,
operator|&
name|hi
argument_list|,
operator|&
name|skip
argument_list|,
operator|&
name|override
argument_list|,
operator|&
name|type_change_ok
argument_list|,
operator|&
name|size_change_ok
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|skip
condition|)
goto|goto
name|nondefault
goto|;
if|if
condition|(
operator|!
name|override
condition|)
block|{
name|bh
operator|=
operator|&
name|hi
operator|->
name|root
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
name|shortname
argument_list|,
name|BSF_INDIRECT
argument_list|,
name|bfd_ind_section_ptr
argument_list|,
literal|0
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|,
name|collect
argument_list|,
operator|&
name|bh
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
name|hi
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|bh
expr_stmt|;
block|}
else|else
block|{
comment|/* In this case the symbol named SHORTNAME is overriding the 	 indirect symbol we want to add.  We were planning on making 	 SHORTNAME an indirect symbol referring to NAME.  SHORTNAME 	 is the name without a version.  NAME is the fully versioned 	 name, and it is the default version.  	 Overriding means that we already saw a definition for the 	 symbol SHORTNAME in a regular object, and it is overriding 	 the symbol defined in the dynamic object.  	 When this happens, we actually want to change NAME, the 	 symbol we just added, to refer to SHORTNAME.  This will cause 	 references to NAME in the shared object to become references 	 to SHORTNAME in the regular object.  This is what we expect 	 when we override a function in a shared object: that the 	 references in the shared object will be mapped to the 	 definition in the regular object.  */
while|while
condition|(
name|hi
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|hi
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|hi
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|hi
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|type
operator|=
name|bfd_link_hash_indirect
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
operator|=
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|)
name|hi
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|def_dynamic
condition|)
block|{
name|h
operator|->
name|def_dynamic
operator|=
literal|0
expr_stmt|;
name|hi
operator|->
name|ref_dynamic
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|hi
operator|->
name|ref_regular
operator|||
name|hi
operator|->
name|def_regular
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|hi
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
comment|/* Now set HI to H, so that the following code will set the 	 other fields correctly.  */
name|hi
operator|=
name|h
expr_stmt|;
block|}
comment|/* Check if HI is a warning symbol.  */
if|if
condition|(
name|hi
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|hi
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|hi
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
comment|/* If there is a duplicate definition somewhere, then HI may not      point to an indirect symbol.  We will have reported an error to      the user in that case.  */
if|if
condition|(
name|hi
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|ht
decl_stmt|;
name|ht
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|hi
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
call|(
modifier|*
name|bed
operator|->
name|elf_backend_copy_indirect_symbol
call|)
argument_list|(
name|info
argument_list|,
name|ht
argument_list|,
name|hi
argument_list|)
expr_stmt|;
comment|/* See if the new flags lead us to realize that the symbol must 	 be dynamic.  */
if|if
condition|(
operator|!
operator|*
name|dynsym
condition|)
block|{
if|if
condition|(
operator|!
name|dynamic
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|shared
operator|||
name|hi
operator|->
name|ref_dynamic
condition|)
operator|*
name|dynsym
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|hi
operator|->
name|ref_regular
condition|)
operator|*
name|dynsym
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
comment|/* We also need to define an indirection from the nondefault version      of the symbol.  */
name|nondefault
label|:
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|shortname
operator|=
name|bfd_hash_allocate
argument_list|(
operator|&
name|info
operator|->
name|hash
operator|->
name|table
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|shortname
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|memcpy
argument_list|(
name|shortname
argument_list|,
name|name
argument_list|,
name|shortlen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|shortname
operator|+
name|shortlen
argument_list|,
name|p
operator|+
literal|1
argument_list|,
name|len
operator|-
name|shortlen
argument_list|)
expr_stmt|;
comment|/* Once again, merge with any existing symbol.  */
name|type_change_ok
operator|=
name|FALSE
expr_stmt|;
name|size_change_ok
operator|=
name|FALSE
expr_stmt|;
name|sec
operator|=
operator|*
name|psec
expr_stmt|;
if|if
condition|(
operator|!
name|_bfd_elf_merge_symbol
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|shortname
argument_list|,
name|sym
argument_list|,
operator|&
name|sec
argument_list|,
name|value
argument_list|,
name|NULL
argument_list|,
operator|&
name|hi
argument_list|,
operator|&
name|skip
argument_list|,
operator|&
name|override
argument_list|,
operator|&
name|type_change_ok
argument_list|,
operator|&
name|size_change_ok
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|skip
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|override
condition|)
block|{
comment|/* Here SHORTNAME is a versioned name, so we don't expect to see 	 the type of override we do in the case above unless it is 	 overridden by a versioned definition.  */
if|if
condition|(
name|hi
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defined
operator|&&
name|hi
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: unexpected redefinition of indirect versioned symbol `%s'"
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|shortname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bh
operator|=
operator|&
name|hi
operator|->
name|root
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
name|shortname
argument_list|,
name|BSF_INDIRECT
argument_list|,
name|bfd_ind_section_ptr
argument_list|,
literal|0
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|,
name|collect
argument_list|,
operator|&
name|bh
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
name|hi
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|bh
expr_stmt|;
comment|/* If there is a duplicate definition somewhere, then HI may not 	 point to an indirect symbol.  We will have reported an error 	 to the user in that case.  */
if|if
condition|(
name|hi
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
condition|)
block|{
call|(
modifier|*
name|bed
operator|->
name|elf_backend_copy_indirect_symbol
call|)
argument_list|(
name|info
argument_list|,
name|h
argument_list|,
name|hi
argument_list|)
expr_stmt|;
comment|/* See if the new flags lead us to realize that the symbol 	     must be dynamic.  */
if|if
condition|(
operator|!
operator|*
name|dynsym
condition|)
block|{
if|if
condition|(
operator|!
name|dynamic
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|shared
operator|||
name|hi
operator|->
name|ref_dynamic
condition|)
operator|*
name|dynsym
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|hi
operator|->
name|ref_regular
condition|)
operator|*
name|dynsym
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This routine is used to export all defined symbols into the dynamic    symbol table.  It is called via elf_link_hash_traverse.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_elf_export_symbol
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|elf_info_failed
modifier|*
name|eif
init|=
name|data
decl_stmt|;
comment|/* Ignore this if we won't export it.  */
if|if
condition|(
operator|!
name|eif
operator|->
name|info
operator|->
name|export_dynamic
operator|&&
operator|!
name|h
operator|->
name|dynamic
condition|)
return|return
name|TRUE
return|;
comment|/* Ignore indirect symbols.  These are added by the versioning code.  */
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|&&
operator|(
name|h
operator|->
name|def_regular
operator|||
name|h
operator|->
name|ref_regular
operator|)
condition|)
block|{
name|struct
name|bfd_elf_version_tree
modifier|*
name|t
decl_stmt|;
name|struct
name|bfd_elf_version_expr
modifier|*
name|d
decl_stmt|;
for|for
control|(
name|t
operator|=
name|eif
operator|->
name|verdefs
init|;
name|t
operator|!=
name|NULL
condition|;
name|t
operator|=
name|t
operator|->
name|next
control|)
block|{
if|if
condition|(
name|t
operator|->
name|globals
operator|.
name|list
operator|!=
name|NULL
condition|)
block|{
name|d
operator|=
call|(
modifier|*
name|t
operator|->
name|match
call|)
argument_list|(
operator|&
name|t
operator|->
name|globals
argument_list|,
name|NULL
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|!=
name|NULL
condition|)
goto|goto
name|doit
goto|;
block|}
if|if
condition|(
name|t
operator|->
name|locals
operator|.
name|list
operator|!=
name|NULL
condition|)
block|{
name|d
operator|=
call|(
modifier|*
name|t
operator|->
name|match
call|)
argument_list|(
operator|&
name|t
operator|->
name|locals
argument_list|,
name|NULL
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|!=
name|NULL
condition|)
return|return
name|TRUE
return|;
block|}
block|}
if|if
condition|(
operator|!
name|eif
operator|->
name|verdefs
condition|)
block|{
name|doit
label|:
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|eif
operator|->
name|info
argument_list|,
name|h
argument_list|)
condition|)
block|{
name|eif
operator|->
name|failed
operator|=
name|TRUE
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Look through the symbols which are defined in other shared    libraries and referenced here.  Update the list of version    dependencies.  This will be put into the .gnu.version_r section.    This function is called via elf_link_hash_traverse.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_elf_link_find_version_dependencies
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|elf_find_verdep_info
modifier|*
name|rinfo
init|=
name|data
decl_stmt|;
name|Elf_Internal_Verneed
modifier|*
name|t
decl_stmt|;
name|Elf_Internal_Vernaux
modifier|*
name|a
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
comment|/* We only care about symbols defined in shared objects with version      information.  */
if|if
condition|(
operator|!
name|h
operator|->
name|def_dynamic
operator|||
name|h
operator|->
name|def_regular
operator|||
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|||
name|h
operator|->
name|verinfo
operator|.
name|verdef
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
comment|/* See if we already know about this version.  */
for|for
control|(
name|t
operator|=
name|elf_tdata
argument_list|(
name|rinfo
operator|->
name|output_bfd
argument_list|)
operator|->
name|verref
init|;
name|t
operator|!=
name|NULL
condition|;
name|t
operator|=
name|t
operator|->
name|vn_nextref
control|)
block|{
if|if
condition|(
name|t
operator|->
name|vn_bfd
operator|!=
name|h
operator|->
name|verinfo
operator|.
name|verdef
operator|->
name|vd_bfd
condition|)
continue|continue;
for|for
control|(
name|a
operator|=
name|t
operator|->
name|vn_auxptr
init|;
name|a
operator|!=
name|NULL
condition|;
name|a
operator|=
name|a
operator|->
name|vna_nextptr
control|)
if|if
condition|(
name|a
operator|->
name|vna_nodename
operator|==
name|h
operator|->
name|verinfo
operator|.
name|verdef
operator|->
name|vd_nodename
condition|)
return|return
name|TRUE
return|;
break|break;
block|}
comment|/* This is a new version.  Add it to tree we are building.  */
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
block|{
name|amt
operator|=
sizeof|sizeof
expr|*
name|t
expr_stmt|;
name|t
operator|=
name|bfd_zalloc
argument_list|(
name|rinfo
operator|->
name|output_bfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
block|{
name|rinfo
operator|->
name|failed
operator|=
name|TRUE
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|t
operator|->
name|vn_bfd
operator|=
name|h
operator|->
name|verinfo
operator|.
name|verdef
operator|->
name|vd_bfd
expr_stmt|;
name|t
operator|->
name|vn_nextref
operator|=
name|elf_tdata
argument_list|(
name|rinfo
operator|->
name|output_bfd
argument_list|)
operator|->
name|verref
expr_stmt|;
name|elf_tdata
argument_list|(
name|rinfo
operator|->
name|output_bfd
argument_list|)
operator|->
name|verref
operator|=
name|t
expr_stmt|;
block|}
name|amt
operator|=
sizeof|sizeof
expr|*
name|a
expr_stmt|;
name|a
operator|=
name|bfd_zalloc
argument_list|(
name|rinfo
operator|->
name|output_bfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
comment|/* Note that we are copying a string pointer here, and testing it      above.  If bfd_elf_string_from_elf_section is ever changed to      discard the string data when low in memory, this will have to be      fixed.  */
name|a
operator|->
name|vna_nodename
operator|=
name|h
operator|->
name|verinfo
operator|.
name|verdef
operator|->
name|vd_nodename
expr_stmt|;
name|a
operator|->
name|vna_flags
operator|=
name|h
operator|->
name|verinfo
operator|.
name|verdef
operator|->
name|vd_flags
expr_stmt|;
name|a
operator|->
name|vna_nextptr
operator|=
name|t
operator|->
name|vn_auxptr
expr_stmt|;
name|h
operator|->
name|verinfo
operator|.
name|verdef
operator|->
name|vd_exp_refno
operator|=
name|rinfo
operator|->
name|vers
expr_stmt|;
operator|++
name|rinfo
operator|->
name|vers
expr_stmt|;
name|a
operator|->
name|vna_other
operator|=
name|h
operator|->
name|verinfo
operator|.
name|verdef
operator|->
name|vd_exp_refno
operator|+
literal|1
expr_stmt|;
name|t
operator|->
name|vn_auxptr
operator|=
name|a
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Figure out appropriate versions for all the symbols.  We may not    have the version number script until we have read all of the input    files, so until that point we don't know which symbols should be    local.  This function is called via elf_link_hash_traverse.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_elf_link_assign_sym_version
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|elf_assign_sym_version_info
modifier|*
name|sinfo
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
name|struct
name|elf_info_failed
name|eif
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|sinfo
operator|=
name|data
expr_stmt|;
name|info
operator|=
name|sinfo
operator|->
name|info
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
comment|/* Fix the symbol flags.  */
name|eif
operator|.
name|failed
operator|=
name|FALSE
expr_stmt|;
name|eif
operator|.
name|info
operator|=
name|info
expr_stmt|;
if|if
condition|(
operator|!
name|_bfd_elf_fix_symbol_flags
argument_list|(
name|h
argument_list|,
operator|&
name|eif
argument_list|)
condition|)
block|{
if|if
condition|(
name|eif
operator|.
name|failed
condition|)
name|sinfo
operator|->
name|failed
operator|=
name|TRUE
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* We only need version numbers for symbols defined in regular      objects.  */
if|if
condition|(
operator|!
name|h
operator|->
name|def_regular
condition|)
return|return
name|TRUE
return|;
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|sinfo
operator|->
name|output_bfd
argument_list|)
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|ELF_VER_CHR
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|verinfo
operator|.
name|vertree
operator|==
name|NULL
condition|)
block|{
name|struct
name|bfd_elf_version_tree
modifier|*
name|t
decl_stmt|;
name|bfd_boolean
name|hidden
decl_stmt|;
name|hidden
operator|=
name|TRUE
expr_stmt|;
comment|/* There are two consecutive ELF_VER_CHR characters if this is 	 not a hidden symbol.  */
operator|++
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
name|ELF_VER_CHR
condition|)
block|{
name|hidden
operator|=
name|FALSE
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
comment|/* If there is no version string, we can just return out.  */
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|hidden
condition|)
name|h
operator|->
name|hidden
operator|=
literal|1
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* Look for the version.  If we find it, it is no longer weak.  */
for|for
control|(
name|t
operator|=
name|sinfo
operator|->
name|verdefs
init|;
name|t
operator|!=
name|NULL
condition|;
name|t
operator|=
name|t
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|t
operator|->
name|name
argument_list|,
name|p
argument_list|)
operator|==
literal|0
condition|)
block|{
name|size_t
name|len
decl_stmt|;
name|char
modifier|*
name|alc
decl_stmt|;
name|struct
name|bfd_elf_version_expr
modifier|*
name|d
decl_stmt|;
name|len
operator|=
name|p
operator|-
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
name|alc
operator|=
name|bfd_malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|alc
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|memcpy
argument_list|(
name|alc
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|alc
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|alc
index|[
name|len
operator|-
literal|2
index|]
operator|==
name|ELF_VER_CHR
condition|)
name|alc
index|[
name|len
operator|-
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|h
operator|->
name|verinfo
operator|.
name|vertree
operator|=
name|t
expr_stmt|;
name|t
operator|->
name|used
operator|=
name|TRUE
expr_stmt|;
name|d
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|globals
operator|.
name|list
operator|!=
name|NULL
condition|)
name|d
operator|=
call|(
modifier|*
name|t
operator|->
name|match
call|)
argument_list|(
operator|&
name|t
operator|->
name|globals
argument_list|,
name|NULL
argument_list|,
name|alc
argument_list|)
expr_stmt|;
comment|/* See if there is anything to force this symbol to 		 local scope.  */
if|if
condition|(
name|d
operator|==
name|NULL
operator|&&
name|t
operator|->
name|locals
operator|.
name|list
operator|!=
name|NULL
condition|)
block|{
name|d
operator|=
call|(
modifier|*
name|t
operator|->
name|match
call|)
argument_list|(
operator|&
name|t
operator|->
name|locals
argument_list|,
name|NULL
argument_list|,
name|alc
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|&&
operator|!
name|info
operator|->
name|export_dynamic
condition|)
call|(
modifier|*
name|bed
operator|->
name|elf_backend_hide_symbol
call|)
argument_list|(
name|info
argument_list|,
name|h
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|alc
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* If we are building an application, we need to create a 	 version node for this version.  */
if|if
condition|(
name|t
operator|==
name|NULL
operator|&&
name|info
operator|->
name|executable
condition|)
block|{
name|struct
name|bfd_elf_version_tree
modifier|*
modifier|*
name|pp
decl_stmt|;
name|int
name|version_index
decl_stmt|;
comment|/* If we aren't going to export this symbol, we don't need 	     to worry about it.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
return|return
name|TRUE
return|;
name|amt
operator|=
sizeof|sizeof
expr|*
name|t
expr_stmt|;
name|t
operator|=
name|bfd_zalloc
argument_list|(
name|sinfo
operator|->
name|output_bfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
block|{
name|sinfo
operator|->
name|failed
operator|=
name|TRUE
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|t
operator|->
name|name
operator|=
name|p
expr_stmt|;
name|t
operator|->
name|name_indx
operator|=
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
expr_stmt|;
name|t
operator|->
name|used
operator|=
name|TRUE
expr_stmt|;
name|version_index
operator|=
literal|1
expr_stmt|;
comment|/* Don't count anonymous version tag.  */
if|if
condition|(
name|sinfo
operator|->
name|verdefs
operator|!=
name|NULL
operator|&&
name|sinfo
operator|->
name|verdefs
operator|->
name|vernum
operator|==
literal|0
condition|)
name|version_index
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|pp
operator|=
operator|&
name|sinfo
operator|->
name|verdefs
init|;
operator|*
name|pp
operator|!=
name|NULL
condition|;
name|pp
operator|=
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|next
control|)
operator|++
name|version_index
expr_stmt|;
name|t
operator|->
name|vernum
operator|=
name|version_index
expr_stmt|;
operator|*
name|pp
operator|=
name|t
expr_stmt|;
name|h
operator|->
name|verinfo
operator|.
name|vertree
operator|=
name|t
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
block|{
comment|/* We could not find the version for a symbol when 	     generating a shared archive.  Return an error.  */
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: version node not found for symbol %s"
argument_list|)
argument_list|,
name|sinfo
operator|->
name|output_bfd
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
name|sinfo
operator|->
name|failed
operator|=
name|TRUE
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|hidden
condition|)
name|h
operator|->
name|hidden
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If we don't have a version for this symbol, see if we can find      something.  */
if|if
condition|(
name|h
operator|->
name|verinfo
operator|.
name|vertree
operator|==
name|NULL
operator|&&
name|sinfo
operator|->
name|verdefs
operator|!=
name|NULL
condition|)
block|{
name|struct
name|bfd_elf_version_tree
modifier|*
name|t
decl_stmt|;
name|struct
name|bfd_elf_version_tree
modifier|*
name|local_ver
decl_stmt|;
name|struct
name|bfd_elf_version_expr
modifier|*
name|d
decl_stmt|;
comment|/* See if can find what version this symbol is in.  If the 	 symbol is supposed to be local, then don't actually register 	 it.  */
name|local_ver
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|t
operator|=
name|sinfo
operator|->
name|verdefs
init|;
name|t
operator|!=
name|NULL
condition|;
name|t
operator|=
name|t
operator|->
name|next
control|)
block|{
if|if
condition|(
name|t
operator|->
name|globals
operator|.
name|list
operator|!=
name|NULL
condition|)
block|{
name|bfd_boolean
name|matched
decl_stmt|;
name|matched
operator|=
name|FALSE
expr_stmt|;
name|d
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|d
operator|=
call|(
modifier|*
name|t
operator|->
name|match
call|)
argument_list|(
operator|&
name|t
operator|->
name|globals
argument_list|,
name|d
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
if|if
condition|(
name|d
operator|->
name|symver
condition|)
name|matched
operator|=
name|TRUE
expr_stmt|;
else|else
block|{
comment|/* There is a version without definition.  Make 		       the symbol the default definition for this 		       version.  */
name|h
operator|->
name|verinfo
operator|.
name|vertree
operator|=
name|t
expr_stmt|;
name|local_ver
operator|=
name|NULL
expr_stmt|;
name|d
operator|->
name|script
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|d
operator|!=
name|NULL
condition|)
break|break;
elseif|else
if|if
condition|(
name|matched
condition|)
comment|/* There is no undefined version for this symbol. Hide the 		   default one.  */
call|(
modifier|*
name|bed
operator|->
name|elf_backend_hide_symbol
call|)
argument_list|(
name|info
argument_list|,
name|h
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|->
name|locals
operator|.
name|list
operator|!=
name|NULL
condition|)
block|{
name|d
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|d
operator|=
call|(
modifier|*
name|t
operator|->
name|match
call|)
argument_list|(
operator|&
name|t
operator|->
name|locals
argument_list|,
name|d
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|local_ver
operator|=
name|t
expr_stmt|;
comment|/* If the match is "*", keep looking for a more 		     explicit, perhaps even global, match. 		     XXX: Shouldn't this be !d->wildcard instead?  */
if|if
condition|(
name|d
operator|->
name|pattern
index|[
literal|0
index|]
operator|!=
literal|'*'
operator|||
name|d
operator|->
name|pattern
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
break|break;
block|}
if|if
condition|(
name|d
operator|!=
name|NULL
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|local_ver
operator|!=
name|NULL
condition|)
block|{
name|h
operator|->
name|verinfo
operator|.
name|vertree
operator|=
name|local_ver
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|&&
operator|!
name|info
operator|->
name|export_dynamic
condition|)
block|{
call|(
modifier|*
name|bed
operator|->
name|elf_backend_hide_symbol
call|)
argument_list|(
name|info
argument_list|,
name|h
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read and swap the relocs from the section indicated by SHDR.  This    may be either a REL or a RELA section.  The relocations are    translated into RELA relocations and stored in INTERNAL_RELOCS,    which should have already been allocated to contain enough space.    The EXTERNAL_RELOCS are a buffer where the external form of the    relocations should be stored.     Returns FALSE if something goes wrong.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_link_read_relocs_from_section
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|Elf_Internal_Shdr
modifier|*
name|shdr
parameter_list|,
name|void
modifier|*
name|external_relocs
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
parameter_list|)
block|{
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
name|void
function_decl|(
modifier|*
name|swap_in
function_decl|)
parameter_list|(
name|bfd
modifier|*
parameter_list|,
specifier|const
name|bfd_byte
modifier|*
parameter_list|,
name|Elf_Internal_Rela
modifier|*
parameter_list|)
function_decl|;
specifier|const
name|bfd_byte
modifier|*
name|erela
decl_stmt|;
specifier|const
name|bfd_byte
modifier|*
name|erelaend
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irela
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|size_t
name|nsyms
decl_stmt|;
comment|/* Position ourselves at the start of the section.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|shdr
operator|->
name|sh_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
comment|/* Read the relocations.  */
if|if
condition|(
name|bfd_bread
argument_list|(
name|external_relocs
argument_list|,
name|shdr
operator|->
name|sh_size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|shdr
operator|->
name|sh_size
condition|)
return|return
name|FALSE
return|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|nsyms
operator|=
name|symtab_hdr
operator|->
name|sh_size
operator|/
name|symtab_hdr
operator|->
name|sh_entsize
expr_stmt|;
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* Convert the external relocations to the internal format.  */
if|if
condition|(
name|shdr
operator|->
name|sh_entsize
operator|==
name|bed
operator|->
name|s
operator|->
name|sizeof_rel
condition|)
name|swap_in
operator|=
name|bed
operator|->
name|s
operator|->
name|swap_reloc_in
expr_stmt|;
elseif|else
if|if
condition|(
name|shdr
operator|->
name|sh_entsize
operator|==
name|bed
operator|->
name|s
operator|->
name|sizeof_rela
condition|)
name|swap_in
operator|=
name|bed
operator|->
name|s
operator|->
name|swap_reloca_in
expr_stmt|;
else|else
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|erela
operator|=
name|external_relocs
expr_stmt|;
name|erelaend
operator|=
name|erela
operator|+
name|shdr
operator|->
name|sh_size
expr_stmt|;
name|irela
operator|=
name|internal_relocs
expr_stmt|;
while|while
condition|(
name|erela
operator|<
name|erelaend
condition|)
block|{
name|bfd_vma
name|r_symndx
decl_stmt|;
call|(
modifier|*
name|swap_in
call|)
argument_list|(
name|abfd
argument_list|,
name|erela
argument_list|,
name|irela
argument_list|)
expr_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|irela
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|bed
operator|->
name|s
operator|->
name|arch_size
operator|==
literal|64
condition|)
name|r_symndx
operator|>>=
literal|24
expr_stmt|;
if|if
condition|(
operator|(
name|size_t
operator|)
name|r_symndx
operator|>=
name|nsyms
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: bad reloc symbol index (0x%lx>= 0x%lx)"
literal|" for offset 0x%lx in section `%A'"
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|sec
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|r_symndx
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|nsyms
argument_list|,
name|irela
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|irela
operator|+=
name|bed
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
expr_stmt|;
name|erela
operator|+=
name|shdr
operator|->
name|sh_entsize
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Read and swap the relocs for a section O.  They may have been    cached.  If the EXTERNAL_RELOCS and INTERNAL_RELOCS arguments are    not NULL, they are used as buffers to read into.  They are known to    be large enough.  If the INTERNAL_RELOCS relocs argument is NULL,    the return value is allocated using either malloc or bfd_alloc,    according to the KEEP_MEMORY argument.  If O has two relocation    sections (both REL and RELA relocations), then the REL_HDR    relocations will appear first in INTERNAL_RELOCS, followed by the    REL_HDR2 relocations.  */
end_comment

begin_function
name|Elf_Internal_Rela
modifier|*
name|_bfd_elf_link_read_relocs
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|o
parameter_list|,
name|void
modifier|*
name|external_relocs
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
parameter_list|,
name|bfd_boolean
name|keep_memory
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|rel_hdr
decl_stmt|;
name|void
modifier|*
name|alloc1
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|alloc2
init|=
name|NULL
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
if|if
condition|(
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|relocs
operator|!=
name|NULL
condition|)
return|return
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|relocs
return|;
if|if
condition|(
name|o
operator|->
name|reloc_count
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
name|rel_hdr
operator|=
operator|&
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_hdr
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
block|{
name|bfd_size_type
name|size
decl_stmt|;
name|size
operator|=
name|o
operator|->
name|reloc_count
expr_stmt|;
name|size
operator|*=
name|bed
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Internal_Rela
argument_list|)
expr_stmt|;
if|if
condition|(
name|keep_memory
condition|)
name|internal_relocs
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
name|internal_relocs
operator|=
name|alloc2
operator|=
name|bfd_malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
block|}
if|if
condition|(
name|external_relocs
operator|==
name|NULL
condition|)
block|{
name|bfd_size_type
name|size
init|=
name|rel_hdr
operator|->
name|sh_size
decl_stmt|;
if|if
condition|(
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_hdr2
condition|)
name|size
operator|+=
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_hdr2
operator|->
name|sh_size
expr_stmt|;
name|alloc1
operator|=
name|bfd_malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|alloc1
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|external_relocs
operator|=
name|alloc1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|elf_link_read_relocs_from_section
argument_list|(
name|abfd
argument_list|,
name|o
argument_list|,
name|rel_hdr
argument_list|,
name|external_relocs
argument_list|,
name|internal_relocs
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_hdr2
operator|&&
operator|(
operator|!
name|elf_link_read_relocs_from_section
argument_list|(
name|abfd
argument_list|,
name|o
argument_list|,
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_hdr2
argument_list|,
operator|(
operator|(
name|bfd_byte
operator|*
operator|)
name|external_relocs
operator|)
operator|+
name|rel_hdr
operator|->
name|sh_size
argument_list|,
name|internal_relocs
operator|+
operator|(
name|NUM_SHDR_ENTRIES
argument_list|(
name|rel_hdr
argument_list|)
operator|*
name|bed
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
operator|)
argument_list|)
operator|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* Cache the results for next time, if we can.  */
if|if
condition|(
name|keep_memory
condition|)
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|relocs
operator|=
name|internal_relocs
expr_stmt|;
if|if
condition|(
name|alloc1
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|alloc1
argument_list|)
expr_stmt|;
comment|/* Don't free alloc2, since if it was allocated we are passing it      back (under the name of internal_relocs).  */
return|return
name|internal_relocs
return|;
name|error_return
label|:
if|if
condition|(
name|alloc1
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|alloc1
argument_list|)
expr_stmt|;
if|if
condition|(
name|alloc2
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|alloc2
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Compute the size of, and allocate space for, REL_HDR which is the    section header for a section containing relocations for O.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_elf_link_size_reloc_section
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Shdr
modifier|*
name|rel_hdr
parameter_list|,
name|asection
modifier|*
name|o
parameter_list|)
block|{
name|bfd_size_type
name|reloc_count
decl_stmt|;
name|bfd_size_type
name|num_rel_hashes
decl_stmt|;
comment|/* Figure out how many relocations there will be.  */
if|if
condition|(
name|rel_hdr
operator|==
operator|&
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_hdr
condition|)
name|reloc_count
operator|=
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_count
expr_stmt|;
else|else
name|reloc_count
operator|=
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_count2
expr_stmt|;
name|num_rel_hashes
operator|=
name|o
operator|->
name|reloc_count
expr_stmt|;
if|if
condition|(
name|num_rel_hashes
operator|<
name|reloc_count
condition|)
name|num_rel_hashes
operator|=
name|reloc_count
expr_stmt|;
comment|/* That allows us to calculate the size of the section.  */
name|rel_hdr
operator|->
name|sh_size
operator|=
name|rel_hdr
operator|->
name|sh_entsize
operator|*
name|reloc_count
expr_stmt|;
comment|/* The contents field must last into write_object_contents, so we      allocate it with bfd_alloc rather than malloc.  Also since we      cannot be sure that the contents will actually be filled in,      we zero the allocated space.  */
name|rel_hdr
operator|->
name|contents
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|rel_hdr
operator|->
name|sh_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|rel_hdr
operator|->
name|contents
operator|==
name|NULL
operator|&&
name|rel_hdr
operator|->
name|sh_size
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
comment|/* We only allocate one set of hash entries, so we only do it the      first time we are called.  */
if|if
condition|(
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_hashes
operator|==
name|NULL
operator|&&
name|num_rel_hashes
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|bfd_zmalloc
argument_list|(
name|num_rel_hashes
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|elf_link_hash_entry
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_hashes
operator|=
name|p
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Copy the relocations indicated by the INTERNAL_RELOCS (which    originated from the section given by INPUT_REL_HDR) to the    OUTPUT_BFD.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_elf_link_output_relocs
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|Elf_Internal_Shdr
modifier|*
name|input_rel_hdr
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|rel_hash
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|Elf_Internal_Rela
modifier|*
name|irela
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irelaend
decl_stmt|;
name|bfd_byte
modifier|*
name|erel
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|output_rel_hdr
decl_stmt|;
name|asection
modifier|*
name|output_section
decl_stmt|;
name|unsigned
name|int
modifier|*
name|rel_countp
init|=
name|NULL
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
name|void
function_decl|(
modifier|*
name|swap_out
function_decl|)
parameter_list|(
name|bfd
modifier|*
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
parameter_list|,
name|bfd_byte
modifier|*
parameter_list|)
function_decl|;
name|output_section
operator|=
name|input_section
operator|->
name|output_section
expr_stmt|;
name|output_rel_hdr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|elf_section_data
argument_list|(
name|output_section
argument_list|)
operator|->
name|rel_hdr
operator|.
name|sh_entsize
operator|==
name|input_rel_hdr
operator|->
name|sh_entsize
condition|)
block|{
name|output_rel_hdr
operator|=
operator|&
name|elf_section_data
argument_list|(
name|output_section
argument_list|)
operator|->
name|rel_hdr
expr_stmt|;
name|rel_countp
operator|=
operator|&
name|elf_section_data
argument_list|(
name|output_section
argument_list|)
operator|->
name|rel_count
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|elf_section_data
argument_list|(
name|output_section
argument_list|)
operator|->
name|rel_hdr2
operator|&&
operator|(
name|elf_section_data
argument_list|(
name|output_section
argument_list|)
operator|->
name|rel_hdr2
operator|->
name|sh_entsize
operator|==
name|input_rel_hdr
operator|->
name|sh_entsize
operator|)
condition|)
block|{
name|output_rel_hdr
operator|=
name|elf_section_data
argument_list|(
name|output_section
argument_list|)
operator|->
name|rel_hdr2
expr_stmt|;
name|rel_countp
operator|=
operator|&
name|elf_section_data
argument_list|(
name|output_section
argument_list|)
operator|->
name|rel_count2
expr_stmt|;
block|}
else|else
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: relocation size mismatch in %B section %A"
argument_list|)
argument_list|,
name|output_bfd
argument_list|,
name|input_section
operator|->
name|owner
argument_list|,
name|input_section
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_object_format
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|input_rel_hdr
operator|->
name|sh_entsize
operator|==
name|bed
operator|->
name|s
operator|->
name|sizeof_rel
condition|)
name|swap_out
operator|=
name|bed
operator|->
name|s
operator|->
name|swap_reloc_out
expr_stmt|;
elseif|else
if|if
condition|(
name|input_rel_hdr
operator|->
name|sh_entsize
operator|==
name|bed
operator|->
name|s
operator|->
name|sizeof_rela
condition|)
name|swap_out
operator|=
name|bed
operator|->
name|s
operator|->
name|swap_reloca_out
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|erel
operator|=
name|output_rel_hdr
operator|->
name|contents
expr_stmt|;
name|erel
operator|+=
operator|*
name|rel_countp
operator|*
name|input_rel_hdr
operator|->
name|sh_entsize
expr_stmt|;
name|irela
operator|=
name|internal_relocs
expr_stmt|;
name|irelaend
operator|=
name|irela
operator|+
operator|(
name|NUM_SHDR_ENTRIES
argument_list|(
name|input_rel_hdr
argument_list|)
operator|*
name|bed
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
operator|)
expr_stmt|;
while|while
condition|(
name|irela
operator|<
name|irelaend
condition|)
block|{
call|(
modifier|*
name|swap_out
call|)
argument_list|(
name|output_bfd
argument_list|,
name|irela
argument_list|,
name|erel
argument_list|)
expr_stmt|;
name|irela
operator|+=
name|bed
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
expr_stmt|;
name|erel
operator|+=
name|input_rel_hdr
operator|->
name|sh_entsize
expr_stmt|;
block|}
comment|/* Bump the counter, so that we know where to add the next set of      relocations.  */
operator|*
name|rel_countp
operator|+=
name|NUM_SHDR_ENTRIES
argument_list|(
name|input_rel_hdr
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make weak undefined symbols in PIE dynamic.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_elf_link_hash_fixup_symbol
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|)
block|{
if|if
condition|(
name|info
operator|->
name|pie
operator|&&
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
return|return
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Fix up the flags for a symbol.  This handles various cases which    can only be fixed after all the input files are seen.  This is    currently called by both adjust_dynamic_symbol and    assign_sym_version, which is unnecessary but perhaps more robust in    the face of future changes.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_elf_fix_symbol_flags
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|struct
name|elf_info_failed
modifier|*
name|eif
parameter_list|)
block|{
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|NULL
decl_stmt|;
comment|/* If this symbol was mentioned in a non-ELF file, try to set      DEF_REGULAR and REF_REGULAR correctly.  This is the only way to      permit a non-ELF file to correctly refer to a symbol defined in      an ELF dynamic object.  */
if|if
condition|(
name|h
operator|->
name|non_elf
condition|)
block|{
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defined
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
condition|)
block|{
name|h
operator|->
name|ref_regular
operator|=
literal|1
expr_stmt|;
name|h
operator|->
name|ref_regular_nonweak
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
operator|!=
name|NULL
operator|&&
operator|(
name|bfd_get_flavour
argument_list|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
argument_list|)
operator|==
name|bfd_target_elf_flavour
operator|)
condition|)
block|{
name|h
operator|->
name|ref_regular
operator|=
literal|1
expr_stmt|;
name|h
operator|->
name|ref_regular_nonweak
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|h
operator|->
name|def_regular
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|&&
operator|(
name|h
operator|->
name|def_dynamic
operator|||
name|h
operator|->
name|ref_dynamic
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|eif
operator|->
name|info
argument_list|,
name|h
argument_list|)
condition|)
block|{
name|eif
operator|->
name|failed
operator|=
name|TRUE
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
block|}
else|else
block|{
comment|/* Unfortunately, NON_ELF is only correct if the symbol 	 was first seen in a non-ELF file.  Fortunately, if the symbol 	 was first seen in an ELF file, we're probably OK unless the 	 symbol was defined in a non-ELF file.  Catch that case here. 	 FIXME: We're still in trouble if the symbol was first seen in 	 a dynamic object, and then later in a non-ELF regular object.  */
if|if
condition|(
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
operator|!
name|h
operator|->
name|def_regular
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
operator|!=
name|NULL
condition|?
operator|(
name|bfd_get_flavour
argument_list|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
argument_list|)
operator|!=
name|bfd_target_elf_flavour
operator|)
else|:
operator|(
name|bfd_is_abs_section
argument_list|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
argument_list|)
operator|&&
operator|!
name|h
operator|->
name|def_dynamic
operator|)
operator|)
condition|)
name|h
operator|->
name|def_regular
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Backend specific symbol fixup.  */
if|if
condition|(
name|elf_hash_table
argument_list|(
name|eif
operator|->
name|info
argument_list|)
operator|->
name|dynobj
condition|)
block|{
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|elf_hash_table
argument_list|(
name|eif
operator|->
name|info
argument_list|)
operator|->
name|dynobj
argument_list|)
expr_stmt|;
if|if
condition|(
name|bed
operator|->
name|elf_backend_fixup_symbol
operator|&&
operator|!
call|(
modifier|*
name|bed
operator|->
name|elf_backend_fixup_symbol
call|)
argument_list|(
name|eif
operator|->
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* If this is a final link, and the symbol was defined as a common      symbol in a regular object file, and there was no definition in      any dynamic object, then the linker will have allocated space for      the symbol in a common section but the DEF_REGULAR      flag will not have been set.  */
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|&&
operator|!
name|h
operator|->
name|def_regular
operator|&&
name|h
operator|->
name|ref_regular
operator|&&
operator|!
name|h
operator|->
name|def_dynamic
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|==
literal|0
condition|)
name|h
operator|->
name|def_regular
operator|=
literal|1
expr_stmt|;
comment|/* If -Bsymbolic was used (which means to bind references to global      symbols to the definition within the shared object), and this      symbol was defined in a regular object, then it actually doesn't      need a PLT entry.  Likewise, if the symbol has non-default      visibility.  If the symbol has hidden or internal visibility, we      will force it local.  */
if|if
condition|(
name|h
operator|->
name|needs_plt
operator|&&
name|eif
operator|->
name|info
operator|->
name|shared
operator|&&
name|is_elf_hash_table
argument_list|(
name|eif
operator|->
name|info
operator|->
name|hash
argument_list|)
operator|&&
operator|(
name|SYMBOLIC_BIND
argument_list|(
name|eif
operator|->
name|info
argument_list|,
name|h
argument_list|)
operator|||
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|!=
name|STV_DEFAULT
operator|)
operator|&&
name|h
operator|->
name|def_regular
condition|)
block|{
name|bfd_boolean
name|force_local
decl_stmt|;
name|force_local
operator|=
operator|(
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_INTERNAL
operator|||
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_HIDDEN
operator|)
expr_stmt|;
call|(
modifier|*
name|bed
operator|->
name|elf_backend_hide_symbol
call|)
argument_list|(
name|eif
operator|->
name|info
argument_list|,
name|h
argument_list|,
name|force_local
argument_list|)
expr_stmt|;
block|}
comment|/* If a weak undefined symbol has non-default visibility, we also      hide it from the dynamic linker.  */
if|if
condition|(
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|!=
name|STV_DEFAULT
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
block|{
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|elf_hash_table
argument_list|(
name|eif
operator|->
name|info
argument_list|)
operator|->
name|dynobj
argument_list|)
expr_stmt|;
call|(
modifier|*
name|bed
operator|->
name|elf_backend_hide_symbol
call|)
argument_list|(
name|eif
operator|->
name|info
argument_list|,
name|h
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
comment|/* If this is a weak defined symbol in a dynamic object, and we know      the real definition in the dynamic object, copy interesting flags      over to the real definition.  */
if|if
condition|(
name|h
operator|->
name|u
operator|.
name|weakdef
operator|!=
name|NULL
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|weakdef
decl_stmt|;
name|weakdef
operator|=
name|h
operator|->
name|u
operator|.
name|weakdef
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|weakdef
operator|->
name|def_dynamic
argument_list|)
expr_stmt|;
comment|/* If the real definition is defined by a regular object file, 	 don't do anything special.  See the longer description in 	 _bfd_elf_adjust_dynamic_symbol, below.  */
if|if
condition|(
name|weakdef
operator|->
name|def_regular
condition|)
name|h
operator|->
name|u
operator|.
name|weakdef
operator|=
name|NULL
expr_stmt|;
else|else
call|(
modifier|*
name|bed
operator|->
name|elf_backend_copy_indirect_symbol
call|)
argument_list|(
name|eif
operator|->
name|info
argument_list|,
name|weakdef
argument_list|,
name|h
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Make the backend pick a good value for a dynamic symbol.  This is    called via elf_link_hash_traverse, and also calls itself    recursively.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_elf_adjust_dynamic_symbol
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|elf_info_failed
modifier|*
name|eif
init|=
name|data
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
if|if
condition|(
operator|!
name|is_elf_hash_table
argument_list|(
name|eif
operator|->
name|info
operator|->
name|hash
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
block|{
name|h
operator|->
name|got
operator|=
name|elf_hash_table
argument_list|(
name|eif
operator|->
name|info
argument_list|)
operator|->
name|init_got_offset
expr_stmt|;
name|h
operator|->
name|plt
operator|=
name|elf_hash_table
argument_list|(
name|eif
operator|->
name|info
argument_list|)
operator|->
name|init_plt_offset
expr_stmt|;
comment|/* When warning symbols are created, they **replace** the "real" 	 entry in the hash table, thus we never get to see the real 	 symbol in a hash traversal.  So look at it now.  */
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
block|}
comment|/* Ignore indirect symbols.  These are added by the versioning code.  */
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
condition|)
return|return
name|TRUE
return|;
comment|/* Fix the symbol flags.  */
if|if
condition|(
operator|!
name|_bfd_elf_fix_symbol_flags
argument_list|(
name|h
argument_list|,
name|eif
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* If this symbol does not require a PLT entry, and it is not      defined by a dynamic object, or is not referenced by a regular      object, ignore it.  We do have to handle a weak defined symbol,      even if no regular object refers to it, if we decided to add it      to the dynamic symbol table.  FIXME: Do we normally need to worry      about symbols which are defined by one dynamic object and      referenced by another one?  */
if|if
condition|(
operator|!
name|h
operator|->
name|needs_plt
operator|&&
operator|(
name|h
operator|->
name|def_regular
operator|||
operator|!
name|h
operator|->
name|def_dynamic
operator|||
operator|(
operator|!
name|h
operator|->
name|ref_regular
operator|&&
operator|(
name|h
operator|->
name|u
operator|.
name|weakdef
operator|==
name|NULL
operator|||
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
block|{
name|h
operator|->
name|plt
operator|=
name|elf_hash_table
argument_list|(
name|eif
operator|->
name|info
argument_list|)
operator|->
name|init_plt_offset
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* If we've already adjusted this symbol, don't do it again.  This      can happen via a recursive call.  */
if|if
condition|(
name|h
operator|->
name|dynamic_adjusted
condition|)
return|return
name|TRUE
return|;
comment|/* Don't look at this symbol again.  Note that we must set this      after checking the above conditions, because we may look at a      symbol once, decide not to do anything, and then get called      recursively later after REF_REGULAR is set below.  */
name|h
operator|->
name|dynamic_adjusted
operator|=
literal|1
expr_stmt|;
comment|/* If this is a weak definition, and we know a real definition, and      the real symbol is not itself defined by a regular object file,      then get a good value for the real definition.  We handle the      real symbol first, for the convenience of the backend routine.       Note that there is a confusing case here.  If the real definition      is defined by a regular object file, we don't get the real symbol      from the dynamic object, but we do get the weak symbol.  If the      processor backend uses a COPY reloc, then if some routine in the      dynamic object changes the real symbol, we will not see that      change in the corresponding weak symbol.  This is the way other      ELF linkers work as well, and seems to be a result of the shared      library model.       I will clarify this issue.  Most SVR4 shared libraries define the      variable _timezone and define timezone as a weak synonym.  The      tzset call changes _timezone.  If you write        extern int timezone;        int _timezone = 5;        int main () { tzset (); printf ("%d %d\n", timezone, _timezone); }      you might expect that, since timezone is a synonym for _timezone,      the same number will print both times.  However, if the processor      backend uses a COPY reloc, then actually timezone will be copied      into your process image, and, since you define _timezone      yourself, _timezone will not.  Thus timezone and _timezone will      wind up at different memory locations.  The tzset call will set      _timezone, leaving timezone unchanged.  */
if|if
condition|(
name|h
operator|->
name|u
operator|.
name|weakdef
operator|!=
name|NULL
condition|)
block|{
comment|/* If we get to this point, we know there is an implicit 	 reference by a regular object file via the weak symbol H. 	 FIXME: Is this really true?  What if the traversal finds 	 H->U.WEAKDEF before it finds H?  */
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|ref_regular
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|_bfd_elf_adjust_dynamic_symbol
argument_list|(
name|h
operator|->
name|u
operator|.
name|weakdef
argument_list|,
name|eif
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* If a symbol has no type and no size and does not require a PLT      entry, then we are probably about to do the wrong thing here: we      are probably going to create a COPY reloc for an empty object.      This case can arise when a shared object is built with assembly      code, and the assembly code fails to set the symbol type.  */
if|if
condition|(
name|h
operator|->
name|size
operator|==
literal|0
operator|&&
name|h
operator|->
name|type
operator|==
name|STT_NOTYPE
operator|&&
operator|!
name|h
operator|->
name|needs_plt
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"warning: type and size of dynamic symbol `%s' are not defined"
argument_list|)
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|eif
operator|->
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|dynobj
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|bed
operator|->
name|elf_backend_adjust_dynamic_symbol
call|)
argument_list|(
name|eif
operator|->
name|info
argument_list|,
name|h
argument_list|)
condition|)
block|{
name|eif
operator|->
name|failed
operator|=
name|TRUE
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Adjust the dynamic symbol, H, for copy in the dynamic bss section,    DYNBSS.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_elf_adjust_dynamic_copy
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|asection
modifier|*
name|dynbss
parameter_list|)
block|{
name|unsigned
name|int
name|power_of_two
decl_stmt|;
name|bfd_vma
name|mask
decl_stmt|;
name|asection
modifier|*
name|sec
init|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
decl_stmt|;
comment|/* The section aligment of definition is the maximum alignment      requirement of symbols defined in the section.  Since we don't      know the symbol alignment requirement, we start with the      maximum alignment and check low bits of the symbol address      for the minimum alignment.  */
name|power_of_two
operator|=
name|bfd_get_section_alignment
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|mask
operator|=
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
name|power_of_two
operator|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|&
name|mask
operator|)
operator|!=
literal|0
condition|)
block|{
name|mask
operator|>>=
literal|1
expr_stmt|;
operator|--
name|power_of_two
expr_stmt|;
block|}
if|if
condition|(
name|power_of_two
operator|>
name|bfd_get_section_alignment
argument_list|(
name|dynbss
operator|->
name|owner
argument_list|,
name|dynbss
argument_list|)
condition|)
block|{
comment|/* Adjust the section alignment if needed.  */
if|if
condition|(
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynbss
operator|->
name|owner
argument_list|,
name|dynbss
argument_list|,
name|power_of_two
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* We make sure that the symbol will be aligned properly.  */
name|dynbss
operator|->
name|size
operator|=
name|BFD_ALIGN
argument_list|(
name|dynbss
operator|->
name|size
argument_list|,
name|mask
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Define the symbol as being at this point in DYNBSS.  */
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|dynbss
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|dynbss
operator|->
name|size
expr_stmt|;
comment|/* Increment the size of DYNBSS to make room for the symbol.  */
name|dynbss
operator|->
name|size
operator|+=
name|h
operator|->
name|size
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Adjust all external symbols pointing into SEC_MERGE sections    to reflect the object merging within the sections.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_elf_link_sec_merge_syms
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
operator|(
operator|(
name|sec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|)
operator|->
name|flags
operator|&
name|SEC_MERGE
operator|)
operator|&&
name|sec
operator|->
name|sec_info_type
operator|==
name|ELF_INFO_TYPE_MERGE
condition|)
block|{
name|bfd
modifier|*
name|output_bfd
init|=
name|data
decl_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|_bfd_merged_section_offset
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
argument_list|,
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|sec_info
argument_list|,
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Returns false if the symbol referred to by H should be considered    to resolve local to the current module, and true if it should be    considered to bind dynamically.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_elf_dynamic_symbol_p
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd_boolean
name|ignore_protected
parameter_list|)
block|{
name|bfd_boolean
name|binding_stays_local_p
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
name|struct
name|elf_link_hash_table
modifier|*
name|hash_table
decl_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
comment|/* If it was forced local, then clearly it's not dynamic.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|h
operator|->
name|forced_local
condition|)
return|return
name|FALSE
return|;
comment|/* Identify the cases where name binding rules say that a      visible symbol resolves locally.  */
name|binding_stays_local_p
operator|=
name|info
operator|->
name|executable
operator|||
name|SYMBOLIC_BIND
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
condition|)
block|{
case|case
name|STV_INTERNAL
case|:
case|case
name|STV_HIDDEN
case|:
return|return
name|FALSE
return|;
case|case
name|STV_PROTECTED
case|:
name|hash_table
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_elf_hash_table
argument_list|(
name|hash_table
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|hash_table
operator|->
name|dynobj
argument_list|)
expr_stmt|;
comment|/* Proper resolution for function pointer equality may require 	 that these symbols perhaps be resolved dynamically, even though 	 we should be resolving them to the current module.  */
if|if
condition|(
operator|!
name|ignore_protected
operator|||
operator|!
name|bed
operator|->
name|is_function_type
argument_list|(
name|h
operator|->
name|type
argument_list|)
condition|)
name|binding_stays_local_p
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* If it isn't defined locally, then clearly it's dynamic.  */
if|if
condition|(
operator|!
name|h
operator|->
name|def_regular
condition|)
return|return
name|TRUE
return|;
comment|/* Otherwise, the symbol is dynamic if binding rules don't tell      us that it remains local.  */
return|return
operator|!
name|binding_stays_local_p
return|;
block|}
end_function

begin_comment
comment|/* Return true if the symbol referred to by H should be considered    to resolve local to the current module, and false otherwise.  Differs    from (the inverse of) _bfd_elf_dynamic_symbol_p in the treatment of    undefined symbols and weak symbols.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_elf_symbol_refs_local_p
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd_boolean
name|local_protected
parameter_list|)
block|{
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
name|struct
name|elf_link_hash_table
modifier|*
name|hash_table
decl_stmt|;
comment|/* If it's a local sym, of course we resolve locally.  */
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
comment|/* Common symbols that become definitions don't get the DEF_REGULAR      flag set, so test it first, and don't bail out.  */
if|if
condition|(
name|ELF_COMMON_DEF_P
argument_list|(
name|h
argument_list|)
condition|)
comment|/* Do nothing.  */
empty_stmt|;
comment|/* If we don't have a definition in a regular file, then we can't      resolve locally.  The sym is either undefined or dynamic.  */
elseif|else
if|if
condition|(
operator|!
name|h
operator|->
name|def_regular
condition|)
return|return
name|FALSE
return|;
comment|/* Forced local symbols resolve locally.  */
if|if
condition|(
name|h
operator|->
name|forced_local
condition|)
return|return
name|TRUE
return|;
comment|/* As do non-dynamic symbols.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
return|return
name|TRUE
return|;
comment|/* At this point, we know the symbol is defined and dynamic.  In an      executable it must resolve locally, likewise when building symbolic      shared libraries.  */
if|if
condition|(
name|info
operator|->
name|executable
operator|||
name|SYMBOLIC_BIND
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|TRUE
return|;
comment|/* Now deal with defined dynamic symbols in shared libraries.  Ones      with default visibility might not resolve locally.  */
if|if
condition|(
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_DEFAULT
condition|)
return|return
name|FALSE
return|;
comment|/* However, STV_HIDDEN or STV_INTERNAL ones must be local.  */
if|if
condition|(
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|!=
name|STV_PROTECTED
condition|)
return|return
name|TRUE
return|;
name|hash_table
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_elf_hash_table
argument_list|(
name|hash_table
argument_list|)
condition|)
return|return
name|TRUE
return|;
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|hash_table
operator|->
name|dynobj
argument_list|)
expr_stmt|;
comment|/* STV_PROTECTED non-function symbols are local.  */
if|if
condition|(
operator|!
name|bed
operator|->
name|is_function_type
argument_list|(
name|h
operator|->
name|type
argument_list|)
condition|)
return|return
name|TRUE
return|;
comment|/* Function pointer equality tests may require that STV_PROTECTED      symbols be treated as dynamic symbols, even when we know that the      dynamic linker will resolve them locally.  */
return|return
name|local_protected
return|;
block|}
end_function

begin_comment
comment|/* Caches some TLS segment info, and ensures that the TLS segment vma is    aligned.  Returns the first TLS output section.  */
end_comment

begin_function
name|struct
name|bfd_section
modifier|*
name|_bfd_elf_tls_setup
parameter_list|(
name|bfd
modifier|*
name|obfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|bfd_section
modifier|*
name|sec
decl_stmt|,
modifier|*
name|tls
decl_stmt|;
name|unsigned
name|int
name|align
init|=
literal|0
decl_stmt|;
for|for
control|(
name|sec
operator|=
name|obfd
operator|->
name|sections
init|;
name|sec
operator|!=
name|NULL
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_THREAD_LOCAL
operator|)
operator|!=
literal|0
condition|)
break|break;
name|tls
operator|=
name|sec
expr_stmt|;
for|for
control|(
init|;
name|sec
operator|!=
name|NULL
operator|&&
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_THREAD_LOCAL
operator|)
operator|!=
literal|0
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
if|if
condition|(
name|sec
operator|->
name|alignment_power
operator|>
name|align
condition|)
name|align
operator|=
name|sec
operator|->
name|alignment_power
expr_stmt|;
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|tls_sec
operator|=
name|tls
expr_stmt|;
comment|/* Ensure the alignment of the first section is the largest alignment,      so that the tls segment starts aligned.  */
if|if
condition|(
name|tls
operator|!=
name|NULL
condition|)
name|tls
operator|->
name|alignment_power
operator|=
name|align
expr_stmt|;
return|return
name|tls
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE iff this is a non-common, definition of a non-function symbol.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|is_global_data_symbol_definition
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|)
block|{
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
comment|/* Local symbols do not count, but target specific ones might.  */
if|if
condition|(
name|ELF_ST_BIND
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|!=
name|STB_GLOBAL
operator|&&
name|ELF_ST_BIND
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|<
name|STB_LOOS
condition|)
return|return
name|FALSE
return|;
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* Function symbols do not count.  */
if|if
condition|(
name|bed
operator|->
name|is_function_type
argument_list|(
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* If the section is undefined, then so is the symbol.  */
if|if
condition|(
name|sym
operator|->
name|st_shndx
operator|==
name|SHN_UNDEF
condition|)
return|return
name|FALSE
return|;
comment|/* If the symbol is defined in the common section, then      it is a common definition and so does not count.  */
if|if
condition|(
name|bed
operator|->
name|common_definition
argument_list|(
name|sym
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* If the symbol is in a target specific section then we      must rely upon the backend to tell us what it is.  */
if|if
condition|(
name|sym
operator|->
name|st_shndx
operator|>=
name|SHN_LORESERVE
operator|&&
name|sym
operator|->
name|st_shndx
operator|<
name|SHN_ABS
condition|)
comment|/* FIXME - this function is not coded yet:         return _bfd_is_global_symbol_definition (abfd, sym);         Instead for now assume that the definition is not global,        Even if this is wrong, at least the linker will behave        in the same way that it used to do.  */
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Search the symbol table of the archive element of the archive ABFD    whose archive map contains a mention of SYMDEF, and determine if    the symbol is defined in this element.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_link_is_defined_archive_symbol
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|carsym
modifier|*
name|symdef
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
name|bfd_size_type
name|symcount
decl_stmt|;
name|bfd_size_type
name|extsymcount
decl_stmt|;
name|bfd_size_type
name|extsymoff
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymbuf
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isym
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymend
decl_stmt|;
name|bfd_boolean
name|result
decl_stmt|;
name|abfd
operator|=
name|_bfd_get_elt_at_filepos
argument_list|(
name|abfd
argument_list|,
name|symdef
operator|->
name|file_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|abfd
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|bfd_check_format
argument_list|(
name|abfd
argument_list|,
name|bfd_object
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* If we have already included the element containing this symbol in the      link then we do not need to include it again.  Just claim that any symbol      it contains is not a definition, so that our caller will not decide to      (re)include this element.  */
if|if
condition|(
name|abfd
operator|->
name|archive_pass
condition|)
return|return
name|FALSE
return|;
comment|/* Select the appropriate symbol table.  */
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|==
literal|0
operator|||
name|elf_dynsymtab
argument_list|(
name|abfd
argument_list|)
operator|==
literal|0
condition|)
name|hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
else|else
name|hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|dynsymtab_hdr
expr_stmt|;
name|symcount
operator|=
name|hdr
operator|->
name|sh_size
operator|/
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|s
operator|->
name|sizeof_sym
expr_stmt|;
comment|/* The sh_info field of the symtab header tells us where the      external symbols start.  We don't care about the local symbols.  */
if|if
condition|(
name|elf_bad_symtab
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|extsymcount
operator|=
name|symcount
expr_stmt|;
name|extsymoff
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|extsymcount
operator|=
name|symcount
operator|-
name|hdr
operator|->
name|sh_info
expr_stmt|;
name|extsymoff
operator|=
name|hdr
operator|->
name|sh_info
expr_stmt|;
block|}
if|if
condition|(
name|extsymcount
operator|==
literal|0
condition|)
return|return
name|FALSE
return|;
comment|/* Read in the symbol table.  */
name|isymbuf
operator|=
name|bfd_elf_get_elf_syms
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|,
name|extsymcount
argument_list|,
name|extsymoff
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* Scan the symbol table looking for SYMDEF.  */
name|result
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|isym
operator|=
name|isymbuf
operator|,
name|isymend
operator|=
name|isymbuf
operator|+
name|extsymcount
init|;
name|isym
operator|<
name|isymend
condition|;
name|isym
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|sh_link
argument_list|,
name|isym
operator|->
name|st_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|symdef
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|result
operator|=
name|is_global_data_symbol_definition
argument_list|(
name|abfd
argument_list|,
name|isym
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|free
argument_list|(
name|isymbuf
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add an entry to the .dynamic table.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_elf_add_dynamic_entry
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd_vma
name|tag
parameter_list|,
name|bfd_vma
name|val
parameter_list|)
block|{
name|struct
name|elf_link_hash_table
modifier|*
name|hash_table
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_size_type
name|newsize
decl_stmt|;
name|bfd_byte
modifier|*
name|newcontents
decl_stmt|;
name|Elf_Internal_Dyn
name|dyn
decl_stmt|;
name|hash_table
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_elf_hash_table
argument_list|(
name|hash_table
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|hash_table
operator|->
name|dynobj
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|hash_table
operator|->
name|dynobj
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|newsize
operator|=
name|s
operator|->
name|size
operator|+
name|bed
operator|->
name|s
operator|->
name|sizeof_dyn
expr_stmt|;
name|newcontents
operator|=
name|bfd_realloc
argument_list|(
name|s
operator|->
name|contents
argument_list|,
name|newsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|newcontents
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|dyn
operator|.
name|d_tag
operator|=
name|tag
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|val
expr_stmt|;
name|bed
operator|->
name|s
operator|->
name|swap_dyn_out
argument_list|(
name|hash_table
operator|->
name|dynobj
argument_list|,
operator|&
name|dyn
argument_list|,
name|newcontents
operator|+
name|s
operator|->
name|size
argument_list|)
expr_stmt|;
name|s
operator|->
name|size
operator|=
name|newsize
expr_stmt|;
name|s
operator|->
name|contents
operator|=
name|newcontents
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Add a DT_NEEDED entry for this dynamic object if DO_IT is true,    otherwise just check whether one already exists.  Returns -1 on error,    1 if a DT_NEEDED tag already exists, and 0 on success.  */
end_comment

begin_function
specifier|static
name|int
name|elf_add_dt_needed_tag
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
specifier|const
name|char
modifier|*
name|soname
parameter_list|,
name|bfd_boolean
name|do_it
parameter_list|)
block|{
name|struct
name|elf_link_hash_table
modifier|*
name|hash_table
decl_stmt|;
name|bfd_size_type
name|oldsize
decl_stmt|;
name|bfd_size_type
name|strindex
decl_stmt|;
if|if
condition|(
operator|!
name|_bfd_elf_link_create_dynstrtab
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|hash_table
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|oldsize
operator|=
name|_bfd_elf_strtab_size
argument_list|(
name|hash_table
operator|->
name|dynstr
argument_list|)
expr_stmt|;
name|strindex
operator|=
name|_bfd_elf_strtab_add
argument_list|(
name|hash_table
operator|->
name|dynstr
argument_list|,
name|soname
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|strindex
operator|==
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|oldsize
operator|==
name|_bfd_elf_strtab_size
argument_list|(
name|hash_table
operator|->
name|dynstr
argument_list|)
condition|)
block|{
name|asection
modifier|*
name|sdyn
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
name|bfd_byte
modifier|*
name|extdyn
decl_stmt|;
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|hash_table
operator|->
name|dynobj
argument_list|)
expr_stmt|;
name|sdyn
operator|=
name|bfd_get_section_by_name
argument_list|(
name|hash_table
operator|->
name|dynobj
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdyn
operator|!=
name|NULL
condition|)
for|for
control|(
name|extdyn
operator|=
name|sdyn
operator|->
name|contents
init|;
name|extdyn
operator|<
name|sdyn
operator|->
name|contents
operator|+
name|sdyn
operator|->
name|size
condition|;
name|extdyn
operator|+=
name|bed
operator|->
name|s
operator|->
name|sizeof_dyn
control|)
block|{
name|Elf_Internal_Dyn
name|dyn
decl_stmt|;
name|bed
operator|->
name|s
operator|->
name|swap_dyn_in
argument_list|(
name|hash_table
operator|->
name|dynobj
argument_list|,
name|extdyn
argument_list|,
operator|&
name|dyn
argument_list|)
expr_stmt|;
if|if
condition|(
name|dyn
operator|.
name|d_tag
operator|==
name|DT_NEEDED
operator|&&
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|==
name|strindex
condition|)
block|{
name|_bfd_elf_strtab_delref
argument_list|(
name|hash_table
operator|->
name|dynstr
argument_list|,
name|strindex
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
block|}
if|if
condition|(
name|do_it
condition|)
block|{
if|if
condition|(
operator|!
name|_bfd_elf_link_create_dynamic_sections
argument_list|(
name|hash_table
operator|->
name|dynobj
argument_list|,
name|info
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|_bfd_elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_NEEDED
argument_list|,
name|strindex
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
else|else
comment|/* We were just checking for existence of the tag.  */
name|_bfd_elf_strtab_delref
argument_list|(
name|hash_table
operator|->
name|dynstr
argument_list|,
name|strindex
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Sort symbol by value and section.  */
end_comment

begin_function
specifier|static
name|int
name|elf_sort_symbol
parameter_list|(
specifier|const
name|void
modifier|*
name|arg1
parameter_list|,
specifier|const
name|void
modifier|*
name|arg2
parameter_list|)
block|{
specifier|const
name|struct
name|elf_link_hash_entry
modifier|*
name|h1
decl_stmt|;
specifier|const
name|struct
name|elf_link_hash_entry
modifier|*
name|h2
decl_stmt|;
name|bfd_signed_vma
name|vdiff
decl_stmt|;
name|h1
operator|=
operator|*
operator|(
specifier|const
expr|struct
name|elf_link_hash_entry
operator|*
operator|*
operator|)
name|arg1
expr_stmt|;
name|h2
operator|=
operator|*
operator|(
specifier|const
expr|struct
name|elf_link_hash_entry
operator|*
operator|*
operator|)
name|arg2
expr_stmt|;
name|vdiff
operator|=
name|h1
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|-
name|h2
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
if|if
condition|(
name|vdiff
operator|!=
literal|0
condition|)
return|return
name|vdiff
operator|>
literal|0
condition|?
literal|1
else|:
operator|-
literal|1
return|;
else|else
block|{
name|long
name|sdiff
init|=
name|h1
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|id
operator|-
name|h2
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|id
decl_stmt|;
if|if
condition|(
name|sdiff
operator|!=
literal|0
condition|)
return|return
name|sdiff
operator|>
literal|0
condition|?
literal|1
else|:
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* This function is used to adjust offsets into .dynstr for    dynamic symbols.  This is called via elf_link_hash_traverse.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_adjust_dynstr_offsets
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|elf_strtab_hash
modifier|*
name|dynstr
init|=
name|data
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
condition|)
name|h
operator|->
name|dynstr_index
operator|=
name|_bfd_elf_strtab_offset
argument_list|(
name|dynstr
argument_list|,
name|h
operator|->
name|dynstr_index
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Assign string offsets in .dynstr, update all structures referencing    them.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_finalize_dynstr
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|elf_link_hash_table
modifier|*
name|hash_table
init|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
decl_stmt|;
name|struct
name|elf_link_local_dynamic_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|elf_strtab_hash
modifier|*
name|dynstr
init|=
name|hash_table
operator|->
name|dynstr
decl_stmt|;
name|bfd
modifier|*
name|dynobj
init|=
name|hash_table
operator|->
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|sdyn
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
name|bfd_byte
modifier|*
name|extdyn
decl_stmt|;
name|_bfd_elf_strtab_finalize
argument_list|(
name|dynstr
argument_list|)
expr_stmt|;
name|size
operator|=
name|_bfd_elf_strtab_size
argument_list|(
name|dynstr
argument_list|)
expr_stmt|;
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|dynobj
argument_list|)
expr_stmt|;
name|sdyn
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sdyn
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Update all .dynamic entries referencing .dynstr strings.  */
for|for
control|(
name|extdyn
operator|=
name|sdyn
operator|->
name|contents
init|;
name|extdyn
operator|<
name|sdyn
operator|->
name|contents
operator|+
name|sdyn
operator|->
name|size
condition|;
name|extdyn
operator|+=
name|bed
operator|->
name|s
operator|->
name|sizeof_dyn
control|)
block|{
name|Elf_Internal_Dyn
name|dyn
decl_stmt|;
name|bed
operator|->
name|s
operator|->
name|swap_dyn_in
argument_list|(
name|dynobj
argument_list|,
name|extdyn
argument_list|,
operator|&
name|dyn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dyn
operator|.
name|d_tag
condition|)
block|{
case|case
name|DT_STRSZ
case|:
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|size
expr_stmt|;
break|break;
case|case
name|DT_NEEDED
case|:
case|case
name|DT_SONAME
case|:
case|case
name|DT_RPATH
case|:
case|case
name|DT_RUNPATH
case|:
case|case
name|DT_FILTER
case|:
case|case
name|DT_AUXILIARY
case|:
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|_bfd_elf_strtab_offset
argument_list|(
name|dynstr
argument_list|,
name|dyn
operator|.
name|d_un
operator|.
name|d_val
argument_list|)
expr_stmt|;
break|break;
default|default:
continue|continue;
block|}
name|bed
operator|->
name|s
operator|->
name|swap_dyn_out
argument_list|(
name|dynobj
argument_list|,
operator|&
name|dyn
argument_list|,
name|extdyn
argument_list|)
expr_stmt|;
block|}
comment|/* Now update local dynamic symbols.  */
for|for
control|(
name|entry
operator|=
name|hash_table
operator|->
name|dynlocal
init|;
name|entry
condition|;
name|entry
operator|=
name|entry
operator|->
name|next
control|)
name|entry
operator|->
name|isym
operator|.
name|st_name
operator|=
name|_bfd_elf_strtab_offset
argument_list|(
name|dynstr
argument_list|,
name|entry
operator|->
name|isym
operator|.
name|st_name
argument_list|)
expr_stmt|;
comment|/* And the rest of dynamic symbols.  */
name|elf_link_hash_traverse
argument_list|(
name|hash_table
argument_list|,
name|elf_adjust_dynstr_offsets
argument_list|,
name|dynstr
argument_list|)
expr_stmt|;
comment|/* Adjust version definitions.  */
if|if
condition|(
name|elf_tdata
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|cverdefs
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_byte
modifier|*
name|p
decl_stmt|;
name|bfd_size_type
name|i
decl_stmt|;
name|Elf_Internal_Verdef
name|def
decl_stmt|;
name|Elf_Internal_Verdaux
name|defaux
decl_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".gnu.version_d"
argument_list|)
expr_stmt|;
name|p
operator|=
name|s
operator|->
name|contents
expr_stmt|;
do|do
block|{
name|_bfd_elf_swap_verdef_in
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|Elf_External_Verdef
operator|*
operator|)
name|p
argument_list|,
operator|&
name|def
argument_list|)
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|Elf_External_Verdef
argument_list|)
expr_stmt|;
if|if
condition|(
name|def
operator|.
name|vd_aux
operator|!=
sizeof|sizeof
argument_list|(
name|Elf_External_Verdef
argument_list|)
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|def
operator|.
name|vd_cnt
condition|;
operator|++
name|i
control|)
block|{
name|_bfd_elf_swap_verdaux_in
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|Elf_External_Verdaux
operator|*
operator|)
name|p
argument_list|,
operator|&
name|defaux
argument_list|)
expr_stmt|;
name|defaux
operator|.
name|vda_name
operator|=
name|_bfd_elf_strtab_offset
argument_list|(
name|dynstr
argument_list|,
name|defaux
operator|.
name|vda_name
argument_list|)
expr_stmt|;
name|_bfd_elf_swap_verdaux_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|defaux
argument_list|,
operator|(
name|Elf_External_Verdaux
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|Elf_External_Verdaux
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|def
operator|.
name|vd_next
condition|)
do|;
block|}
comment|/* Adjust version references.  */
if|if
condition|(
name|elf_tdata
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|verref
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_byte
modifier|*
name|p
decl_stmt|;
name|bfd_size_type
name|i
decl_stmt|;
name|Elf_Internal_Verneed
name|need
decl_stmt|;
name|Elf_Internal_Vernaux
name|needaux
decl_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".gnu.version_r"
argument_list|)
expr_stmt|;
name|p
operator|=
name|s
operator|->
name|contents
expr_stmt|;
do|do
block|{
name|_bfd_elf_swap_verneed_in
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|Elf_External_Verneed
operator|*
operator|)
name|p
argument_list|,
operator|&
name|need
argument_list|)
expr_stmt|;
name|need
operator|.
name|vn_file
operator|=
name|_bfd_elf_strtab_offset
argument_list|(
name|dynstr
argument_list|,
name|need
operator|.
name|vn_file
argument_list|)
expr_stmt|;
name|_bfd_elf_swap_verneed_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|need
argument_list|,
operator|(
name|Elf_External_Verneed
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|Elf_External_Verneed
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|need
operator|.
name|vn_cnt
condition|;
operator|++
name|i
control|)
block|{
name|_bfd_elf_swap_vernaux_in
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|Elf_External_Vernaux
operator|*
operator|)
name|p
argument_list|,
operator|&
name|needaux
argument_list|)
expr_stmt|;
name|needaux
operator|.
name|vna_name
operator|=
name|_bfd_elf_strtab_offset
argument_list|(
name|dynstr
argument_list|,
name|needaux
operator|.
name|vna_name
argument_list|)
expr_stmt|;
name|_bfd_elf_swap_vernaux_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|needaux
argument_list|,
operator|(
name|Elf_External_Vernaux
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|Elf_External_Vernaux
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|need
operator|.
name|vn_next
condition|)
do|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return TRUE iff relocations for INPUT are compatible with OUTPUT.    The default is to only match when the INPUT and OUTPUT are exactly    the same target.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_elf_default_relocs_compatible
parameter_list|(
specifier|const
name|bfd_target
modifier|*
name|input
parameter_list|,
specifier|const
name|bfd_target
modifier|*
name|output
parameter_list|)
block|{
return|return
name|input
operator|==
name|output
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE iff relocations for INPUT are compatible with OUTPUT.    This version is used when different targets for the same architecture    are virtually identical.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_elf_relocs_compatible
parameter_list|(
specifier|const
name|bfd_target
modifier|*
name|input
parameter_list|,
specifier|const
name|bfd_target
modifier|*
name|output
parameter_list|)
block|{
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|obed
decl_stmt|,
modifier|*
name|ibed
decl_stmt|;
if|if
condition|(
name|input
operator|==
name|output
condition|)
return|return
name|TRUE
return|;
name|ibed
operator|=
name|xvec_get_elf_backend_data
argument_list|(
name|input
argument_list|)
expr_stmt|;
name|obed
operator|=
name|xvec_get_elf_backend_data
argument_list|(
name|output
argument_list|)
expr_stmt|;
if|if
condition|(
name|ibed
operator|->
name|arch
operator|!=
name|obed
operator|->
name|arch
condition|)
return|return
name|FALSE
return|;
comment|/* If both backends are using this function, deem them compatible.  */
return|return
name|ibed
operator|->
name|relocs_compatible
operator|==
name|obed
operator|->
name|relocs_compatible
return|;
block|}
end_function

begin_comment
comment|/* Add symbols from an ELF object file to the linker hash table.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_link_add_object_symbols
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
name|bfd_size_type
name|symcount
decl_stmt|;
name|bfd_size_type
name|extsymcount
decl_stmt|;
name|bfd_size_type
name|extsymoff
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hash
decl_stmt|;
name|bfd_boolean
name|dynamic
decl_stmt|;
name|Elf_External_Versym
modifier|*
name|extversym
init|=
name|NULL
decl_stmt|;
name|Elf_External_Versym
modifier|*
name|ever
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|weaks
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|nondeflt_vers
init|=
name|NULL
decl_stmt|;
name|bfd_size_type
name|nondeflt_vers_cnt
init|=
literal|0
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymbuf
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isym
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymend
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
name|bfd_boolean
name|add_needed
decl_stmt|;
name|struct
name|elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|void
modifier|*
name|alloc_mark
init|=
name|NULL
decl_stmt|;
name|struct
name|bfd_hash_entry
modifier|*
modifier|*
name|old_table
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|old_size
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|old_count
init|=
literal|0
decl_stmt|;
name|void
modifier|*
name|old_tab
init|=
name|NULL
decl_stmt|;
name|void
modifier|*
name|old_hash
decl_stmt|;
name|void
modifier|*
name|old_ent
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|old_undefs
init|=
name|NULL
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|old_undefs_tail
init|=
name|NULL
decl_stmt|;
name|long
name|old_dynsymcount
init|=
literal|0
decl_stmt|;
name|size_t
name|tabsize
init|=
literal|0
decl_stmt|;
name|size_t
name|hashsize
init|=
literal|0
decl_stmt|;
name|htab
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|==
literal|0
condition|)
name|dynamic
operator|=
name|FALSE
expr_stmt|;
else|else
block|{
name|dynamic
operator|=
name|TRUE
expr_stmt|;
comment|/* You can't use -r against a dynamic object.  Also, there's no 	 hope of using a dynamic object which does not exactly match 	 the format of the output file.  */
if|if
condition|(
name|info
operator|->
name|relocatable
operator|||
operator|!
name|is_elf_hash_table
argument_list|(
name|htab
argument_list|)
operator|||
name|htab
operator|->
name|root
operator|.
name|creator
operator|!=
name|abfd
operator|->
name|xvec
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
else|else
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
block|}
comment|/* As a GNU extension, any input sections which are named      .gnu.warning.SYMBOL are treated as warning symbols for the given      symbol.  This differs from .gnu.warning sections, which generate      warnings when they are included in an output file.  */
if|if
condition|(
name|info
operator|->
name|executable
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONST_STRNEQ
argument_list|(
name|name
argument_list|,
literal|".gnu.warning."
argument_list|)
condition|)
block|{
name|char
modifier|*
name|msg
decl_stmt|;
name|bfd_size_type
name|sz
decl_stmt|;
name|name
operator|+=
sizeof|sizeof
expr|".gnu.warning."
operator|-
literal|1
expr_stmt|;
comment|/* If this is a shared object, then look up the symbol 		 in the hash table.  If it is there, and it is already 		 been defined, then we will not be using the entry 		 from this shared object, so we don't need to warn. 		 FIXME: If we see the definition in a regular object 		 later on, we will warn, but we shouldn't.  The only 		 fix is to keep track of what warnings we are supposed 		 to emit, and then handle them all at the end of the 		 link.  */
if|if
condition|(
name|dynamic
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
name|elf_link_hash_lookup
argument_list|(
name|htab
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* FIXME: What about bfd_link_hash_common?  */
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
condition|)
block|{
comment|/* We don't want to issue this warning.  Clobber 			 the section size so that the warning does not 			 get copied into the output file.  */
name|s
operator|->
name|size
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
block|}
name|sz
operator|=
name|s
operator|->
name|size
expr_stmt|;
name|msg
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|sz
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|msg
argument_list|,
literal|0
argument_list|,
name|sz
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
name|msg
index|[
name|sz
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
name|name
argument_list|,
name|BSF_WARNING
argument_list|,
name|s
argument_list|,
literal|0
argument_list|,
name|msg
argument_list|,
name|FALSE
argument_list|,
name|bed
operator|->
name|collect
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|info
operator|->
name|relocatable
condition|)
block|{
comment|/* Clobber the section size so that the warning does 		     not get copied into the output file.  */
name|s
operator|->
name|size
operator|=
literal|0
expr_stmt|;
comment|/* Also set SEC_EXCLUDE, so that symbols defined in 		     the warning section don't get copied to the output.  */
name|s
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
block|}
block|}
block|}
block|}
name|add_needed
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|dynamic
condition|)
block|{
comment|/* If we are creating a shared library, create all the dynamic 	 sections immediately.  We need to attach them to something, 	 so we attach them to this BFD, provided it is the right 	 format.  FIXME: If there are no input BFD's of the same 	 format as the output, we can't make a shared library.  */
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
name|is_elf_hash_table
argument_list|(
name|htab
argument_list|)
operator|&&
name|htab
operator|->
name|root
operator|.
name|creator
operator|==
name|abfd
operator|->
name|xvec
operator|&&
operator|!
name|htab
operator|->
name|dynamic_sections_created
condition|)
block|{
if|if
condition|(
operator|!
name|_bfd_elf_link_create_dynamic_sections
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|is_elf_hash_table
argument_list|(
name|htab
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
else|else
block|{
name|asection
modifier|*
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|soname
init|=
name|NULL
decl_stmt|;
name|struct
name|bfd_link_needed_list
modifier|*
name|rpath
init|=
name|NULL
decl_stmt|,
modifier|*
name|runpath
init|=
name|NULL
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* ld --just-symbols and dynamic objects don't mix very well. 	 ld shouldn't allow it.  */
if|if
condition|(
operator|(
name|s
operator|=
name|abfd
operator|->
name|sections
operator|)
operator|!=
name|NULL
operator|&&
name|s
operator|->
name|sec_info_type
operator|==
name|ELF_INFO_TYPE_JUST_SYMS
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If this dynamic lib was specified on the command line with 	 --as-needed in effect, then we don't want to add a DT_NEEDED 	 tag unless the lib is actually used.  Similary for libs brought 	 in by another lib's DT_NEEDED.  When --no-add-needed is used 	 on a dynamic lib, we don't want to add a DT_NEEDED entry for 	 any dynamic library in DT_NEEDED tags in the dynamic lib at 	 all.  */
name|add_needed
operator|=
operator|(
name|elf_dyn_lib_class
argument_list|(
name|abfd
argument_list|)
operator|&
operator|(
name|DYN_AS_NEEDED
operator||
name|DYN_DT_NEEDED
operator||
name|DYN_NO_NEEDED
operator|)
operator|)
operator|==
literal|0
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
name|bfd_byte
modifier|*
name|dynbuf
decl_stmt|;
name|bfd_byte
modifier|*
name|extdyn
decl_stmt|;
name|int
name|elfsec
decl_stmt|;
name|unsigned
name|long
name|shlink
decl_stmt|;
if|if
condition|(
operator|!
name|bfd_malloc_and_get_section
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
operator|&
name|dynbuf
argument_list|)
condition|)
goto|goto
name|error_free_dyn
goto|;
name|elfsec
operator|=
name|_bfd_elf_section_from_bfd_section
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|elfsec
operator|==
operator|-
literal|1
condition|)
goto|goto
name|error_free_dyn
goto|;
name|shlink
operator|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
index|[
name|elfsec
index|]
operator|->
name|sh_link
expr_stmt|;
for|for
control|(
name|extdyn
operator|=
name|dynbuf
init|;
name|extdyn
operator|<
name|dynbuf
operator|+
name|s
operator|->
name|size
condition|;
name|extdyn
operator|+=
name|bed
operator|->
name|s
operator|->
name|sizeof_dyn
control|)
block|{
name|Elf_Internal_Dyn
name|dyn
decl_stmt|;
name|bed
operator|->
name|s
operator|->
name|swap_dyn_in
argument_list|(
name|abfd
argument_list|,
name|extdyn
argument_list|,
operator|&
name|dyn
argument_list|)
expr_stmt|;
if|if
condition|(
name|dyn
operator|.
name|d_tag
operator|==
name|DT_SONAME
condition|)
block|{
name|unsigned
name|int
name|tagv
init|=
name|dyn
operator|.
name|d_un
operator|.
name|d_val
decl_stmt|;
name|soname
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|abfd
argument_list|,
name|shlink
argument_list|,
name|tagv
argument_list|)
expr_stmt|;
if|if
condition|(
name|soname
operator|==
name|NULL
condition|)
goto|goto
name|error_free_dyn
goto|;
block|}
if|if
condition|(
name|dyn
operator|.
name|d_tag
operator|==
name|DT_NEEDED
condition|)
block|{
name|struct
name|bfd_link_needed_list
modifier|*
name|n
decl_stmt|,
modifier|*
modifier|*
name|pn
decl_stmt|;
name|char
modifier|*
name|fnm
decl_stmt|,
modifier|*
name|anm
decl_stmt|;
name|unsigned
name|int
name|tagv
init|=
name|dyn
operator|.
name|d_un
operator|.
name|d_val
decl_stmt|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|bfd_link_needed_list
argument_list|)
expr_stmt|;
name|n
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
name|fnm
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|abfd
argument_list|,
name|shlink
argument_list|,
name|tagv
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
operator|||
name|fnm
operator|==
name|NULL
condition|)
goto|goto
name|error_free_dyn
goto|;
name|amt
operator|=
name|strlen
argument_list|(
name|fnm
argument_list|)
operator|+
literal|1
expr_stmt|;
name|anm
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|anm
operator|==
name|NULL
condition|)
goto|goto
name|error_free_dyn
goto|;
name|memcpy
argument_list|(
name|anm
argument_list|,
name|fnm
argument_list|,
name|amt
argument_list|)
expr_stmt|;
name|n
operator|->
name|name
operator|=
name|anm
expr_stmt|;
name|n
operator|->
name|by
operator|=
name|abfd
expr_stmt|;
name|n
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|pn
operator|=
operator|&
name|htab
operator|->
name|needed
init|;
operator|*
name|pn
operator|!=
name|NULL
condition|;
name|pn
operator|=
operator|&
operator|(
operator|*
name|pn
operator|)
operator|->
name|next
control|)
empty_stmt|;
operator|*
name|pn
operator|=
name|n
expr_stmt|;
block|}
if|if
condition|(
name|dyn
operator|.
name|d_tag
operator|==
name|DT_RUNPATH
condition|)
block|{
name|struct
name|bfd_link_needed_list
modifier|*
name|n
decl_stmt|,
modifier|*
modifier|*
name|pn
decl_stmt|;
name|char
modifier|*
name|fnm
decl_stmt|,
modifier|*
name|anm
decl_stmt|;
name|unsigned
name|int
name|tagv
init|=
name|dyn
operator|.
name|d_un
operator|.
name|d_val
decl_stmt|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|bfd_link_needed_list
argument_list|)
expr_stmt|;
name|n
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
name|fnm
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|abfd
argument_list|,
name|shlink
argument_list|,
name|tagv
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
operator|||
name|fnm
operator|==
name|NULL
condition|)
goto|goto
name|error_free_dyn
goto|;
name|amt
operator|=
name|strlen
argument_list|(
name|fnm
argument_list|)
operator|+
literal|1
expr_stmt|;
name|anm
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|anm
operator|==
name|NULL
condition|)
goto|goto
name|error_free_dyn
goto|;
name|memcpy
argument_list|(
name|anm
argument_list|,
name|fnm
argument_list|,
name|amt
argument_list|)
expr_stmt|;
name|n
operator|->
name|name
operator|=
name|anm
expr_stmt|;
name|n
operator|->
name|by
operator|=
name|abfd
expr_stmt|;
name|n
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|pn
operator|=
operator|&
name|runpath
init|;
operator|*
name|pn
operator|!=
name|NULL
condition|;
name|pn
operator|=
operator|&
operator|(
operator|*
name|pn
operator|)
operator|->
name|next
control|)
empty_stmt|;
operator|*
name|pn
operator|=
name|n
expr_stmt|;
block|}
comment|/* Ignore DT_RPATH if we have seen DT_RUNPATH.  */
if|if
condition|(
operator|!
name|runpath
operator|&&
name|dyn
operator|.
name|d_tag
operator|==
name|DT_RPATH
condition|)
block|{
name|struct
name|bfd_link_needed_list
modifier|*
name|n
decl_stmt|,
modifier|*
modifier|*
name|pn
decl_stmt|;
name|char
modifier|*
name|fnm
decl_stmt|,
modifier|*
name|anm
decl_stmt|;
name|unsigned
name|int
name|tagv
init|=
name|dyn
operator|.
name|d_un
operator|.
name|d_val
decl_stmt|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|bfd_link_needed_list
argument_list|)
expr_stmt|;
name|n
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
name|fnm
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|abfd
argument_list|,
name|shlink
argument_list|,
name|tagv
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
operator|||
name|fnm
operator|==
name|NULL
condition|)
goto|goto
name|error_free_dyn
goto|;
name|amt
operator|=
name|strlen
argument_list|(
name|fnm
argument_list|)
operator|+
literal|1
expr_stmt|;
name|anm
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|anm
operator|==
name|NULL
condition|)
block|{
name|error_free_dyn
label|:
name|free
argument_list|(
name|dynbuf
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|memcpy
argument_list|(
name|anm
argument_list|,
name|fnm
argument_list|,
name|amt
argument_list|)
expr_stmt|;
name|n
operator|->
name|name
operator|=
name|anm
expr_stmt|;
name|n
operator|->
name|by
operator|=
name|abfd
expr_stmt|;
name|n
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|pn
operator|=
operator|&
name|rpath
init|;
operator|*
name|pn
operator|!=
name|NULL
condition|;
name|pn
operator|=
operator|&
operator|(
operator|*
name|pn
operator|)
operator|->
name|next
control|)
empty_stmt|;
operator|*
name|pn
operator|=
name|n
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|dynbuf
argument_list|)
expr_stmt|;
block|}
comment|/* DT_RUNPATH overrides DT_RPATH.  Do _NOT_ bfd_release, as that 	 frees all more recently bfd_alloc'd blocks as well.  */
if|if
condition|(
name|runpath
condition|)
name|rpath
operator|=
name|runpath
expr_stmt|;
if|if
condition|(
name|rpath
condition|)
block|{
name|struct
name|bfd_link_needed_list
modifier|*
modifier|*
name|pn
decl_stmt|;
for|for
control|(
name|pn
operator|=
operator|&
name|htab
operator|->
name|runpath
init|;
operator|*
name|pn
operator|!=
name|NULL
condition|;
name|pn
operator|=
operator|&
operator|(
operator|*
name|pn
operator|)
operator|->
name|next
control|)
empty_stmt|;
operator|*
name|pn
operator|=
name|rpath
expr_stmt|;
block|}
comment|/* We do not want to include any of the sections in a dynamic 	 object in the output file.  We hack by simply clobbering the 	 list of sections in the BFD.  This could be handled more 	 cleanly by, say, a new section flag; the existing 	 SEC_NEVER_LOAD flag is not the one we want, because that one 	 still implies that the section takes up space in the output 	 file.  */
name|bfd_section_list_clear
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* Find the name to use in a DT_NEEDED entry that refers to this 	 object.  If the object has a DT_SONAME entry, we use it. 	 Otherwise, if the generic linker stuck something in 	 elf_dt_name, we use that.  Otherwise, we just use the file 	 name.  */
if|if
condition|(
name|soname
operator|==
name|NULL
operator|||
operator|*
name|soname
operator|==
literal|'\0'
condition|)
block|{
name|soname
operator|=
name|elf_dt_name
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|soname
operator|==
name|NULL
operator|||
operator|*
name|soname
operator|==
literal|'\0'
condition|)
name|soname
operator|=
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
comment|/* Save the SONAME because sometimes the linker emulation code 	 will need to know it.  */
name|elf_dt_name
argument_list|(
name|abfd
argument_list|)
operator|=
name|soname
expr_stmt|;
name|ret
operator|=
name|elf_add_dt_needed_tag
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|soname
argument_list|,
name|add_needed
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
goto|goto
name|error_return
goto|;
comment|/* If we have already included this dynamic object in the 	 link, just ignore it.  There is no reason to include a 	 particular dynamic object more than once.  */
if|if
condition|(
name|ret
operator|>
literal|0
condition|)
return|return
name|TRUE
return|;
block|}
comment|/* If this is a dynamic object, we always link against the .dynsym      symbol table, not the .symtab symbol table.  The dynamic linker      will only see the .dynsym symbol table, so there is no reason to      look at .symtab for a dynamic object.  */
if|if
condition|(
operator|!
name|dynamic
operator|||
name|elf_dynsymtab
argument_list|(
name|abfd
argument_list|)
operator|==
literal|0
condition|)
name|hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
else|else
name|hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|dynsymtab_hdr
expr_stmt|;
name|symcount
operator|=
name|hdr
operator|->
name|sh_size
operator|/
name|bed
operator|->
name|s
operator|->
name|sizeof_sym
expr_stmt|;
comment|/* The sh_info field of the symtab header tells us where the      external symbols start.  We don't care about the local symbols at      this point.  */
if|if
condition|(
name|elf_bad_symtab
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|extsymcount
operator|=
name|symcount
expr_stmt|;
name|extsymoff
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|extsymcount
operator|=
name|symcount
operator|-
name|hdr
operator|->
name|sh_info
expr_stmt|;
name|extsymoff
operator|=
name|hdr
operator|->
name|sh_info
expr_stmt|;
block|}
name|sym_hash
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|extsymcount
operator|!=
literal|0
condition|)
block|{
name|isymbuf
operator|=
name|bfd_elf_get_elf_syms
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|,
name|extsymcount
argument_list|,
name|extsymoff
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
comment|/* We store a pointer to the hash table entry for each external 	 symbol.  */
name|amt
operator|=
name|extsymcount
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|elf_link_hash_entry
operator|*
argument_list|)
expr_stmt|;
name|sym_hash
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_hash
operator|==
name|NULL
condition|)
goto|goto
name|error_free_sym
goto|;
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
operator|=
name|sym_hash
expr_stmt|;
block|}
if|if
condition|(
name|dynamic
condition|)
block|{
comment|/* Read in any version definitions.  */
if|if
condition|(
operator|!
name|_bfd_elf_slurp_version_tables
argument_list|(
name|abfd
argument_list|,
name|info
operator|->
name|default_imported_symver
argument_list|)
condition|)
goto|goto
name|error_free_sym
goto|;
comment|/* Read in the symbol versions, but don't bother to convert them 	 to internal format.  */
if|if
condition|(
name|elf_dynversym
argument_list|(
name|abfd
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|versymhdr
decl_stmt|;
name|versymhdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|dynversym_hdr
expr_stmt|;
name|extversym
operator|=
name|bfd_malloc
argument_list|(
name|versymhdr
operator|->
name|sh_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|extversym
operator|==
name|NULL
condition|)
goto|goto
name|error_free_sym
goto|;
name|amt
operator|=
name|versymhdr
operator|->
name|sh_size
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|versymhdr
operator|->
name|sh_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bread
argument_list|(
name|extversym
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
goto|goto
name|error_free_vers
goto|;
block|}
block|}
comment|/* If we are loading an as-needed shared lib, save the symbol table      state before we start adding symbols.  If the lib turns out      to be unneeded, restore the state.  */
if|if
condition|(
operator|(
name|elf_dyn_lib_class
argument_list|(
name|abfd
argument_list|)
operator|&
name|DYN_AS_NEEDED
operator|)
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|size_t
name|entsize
decl_stmt|;
for|for
control|(
name|entsize
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|htab
operator|->
name|root
operator|.
name|table
operator|.
name|size
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|bfd_hash_entry
modifier|*
name|p
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
for|for
control|(
name|p
operator|=
name|htab
operator|->
name|root
operator|.
name|table
operator|.
name|table
index|[
name|i
index|]
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|p
expr_stmt|;
name|entsize
operator|+=
name|htab
operator|->
name|root
operator|.
name|table
operator|.
name|entsize
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|entsize
operator|+=
name|htab
operator|->
name|root
operator|.
name|table
operator|.
name|entsize
expr_stmt|;
block|}
block|}
name|tabsize
operator|=
name|htab
operator|->
name|root
operator|.
name|table
operator|.
name|size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|bfd_hash_entry
operator|*
argument_list|)
expr_stmt|;
name|hashsize
operator|=
name|extsymcount
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|elf_link_hash_entry
operator|*
argument_list|)
expr_stmt|;
name|old_tab
operator|=
name|bfd_malloc
argument_list|(
name|tabsize
operator|+
name|entsize
operator|+
name|hashsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_tab
operator|==
name|NULL
condition|)
goto|goto
name|error_free_vers
goto|;
comment|/* Remember the current objalloc pointer, so that all mem for 	 symbols added can later be reclaimed.  */
name|alloc_mark
operator|=
name|bfd_hash_allocate
argument_list|(
operator|&
name|htab
operator|->
name|root
operator|.
name|table
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|alloc_mark
operator|==
name|NULL
condition|)
goto|goto
name|error_free_vers
goto|;
comment|/* Make a special call to the linker "notice" function to 	 tell it that we are about to handle an as-needed lib.  */
if|if
condition|(
operator|!
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|notice
call|)
argument_list|(
name|info
argument_list|,
name|NULL
argument_list|,
name|abfd
argument_list|,
name|NULL
argument_list|,
name|notice_as_needed
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Clone the symbol table and sym hashes.  Remember some 	 pointers into the symbol table, and dynamic symbol count.  */
name|old_hash
operator|=
operator|(
name|char
operator|*
operator|)
name|old_tab
operator|+
name|tabsize
expr_stmt|;
name|old_ent
operator|=
operator|(
name|char
operator|*
operator|)
name|old_hash
operator|+
name|hashsize
expr_stmt|;
name|memcpy
argument_list|(
name|old_tab
argument_list|,
name|htab
operator|->
name|root
operator|.
name|table
operator|.
name|table
argument_list|,
name|tabsize
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|old_hash
argument_list|,
name|sym_hash
argument_list|,
name|hashsize
argument_list|)
expr_stmt|;
name|old_undefs
operator|=
name|htab
operator|->
name|root
operator|.
name|undefs
expr_stmt|;
name|old_undefs_tail
operator|=
name|htab
operator|->
name|root
operator|.
name|undefs_tail
expr_stmt|;
name|old_table
operator|=
name|htab
operator|->
name|root
operator|.
name|table
operator|.
name|table
expr_stmt|;
name|old_size
operator|=
name|htab
operator|->
name|root
operator|.
name|table
operator|.
name|size
expr_stmt|;
name|old_count
operator|=
name|htab
operator|->
name|root
operator|.
name|table
operator|.
name|count
expr_stmt|;
name|old_dynsymcount
operator|=
name|htab
operator|->
name|dynsymcount
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|htab
operator|->
name|root
operator|.
name|table
operator|.
name|size
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|bfd_hash_entry
modifier|*
name|p
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
for|for
control|(
name|p
operator|=
name|htab
operator|->
name|root
operator|.
name|table
operator|.
name|table
index|[
name|i
index|]
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|memcpy
argument_list|(
name|old_ent
argument_list|,
name|p
argument_list|,
name|htab
operator|->
name|root
operator|.
name|table
operator|.
name|entsize
argument_list|)
expr_stmt|;
name|old_ent
operator|=
operator|(
name|char
operator|*
operator|)
name|old_ent
operator|+
name|htab
operator|->
name|root
operator|.
name|table
operator|.
name|entsize
expr_stmt|;
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|p
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
block|{
name|memcpy
argument_list|(
name|old_ent
argument_list|,
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
argument_list|,
name|htab
operator|->
name|root
operator|.
name|table
operator|.
name|entsize
argument_list|)
expr_stmt|;
name|old_ent
operator|=
operator|(
name|char
operator|*
operator|)
name|old_ent
operator|+
name|htab
operator|->
name|root
operator|.
name|table
operator|.
name|entsize
expr_stmt|;
block|}
block|}
block|}
block|}
name|weaks
operator|=
name|NULL
expr_stmt|;
name|ever
operator|=
name|extversym
operator|!=
name|NULL
condition|?
name|extversym
operator|+
name|extsymoff
else|:
name|NULL
expr_stmt|;
for|for
control|(
name|isym
operator|=
name|isymbuf
operator|,
name|isymend
operator|=
name|isymbuf
operator|+
name|extsymcount
init|;
name|isym
operator|<
name|isymend
condition|;
name|isym
operator|++
operator|,
name|sym_hash
operator|++
operator|,
name|ever
operator|=
operator|(
name|ever
operator|!=
name|NULL
condition|?
name|ever
operator|+
literal|1
else|:
name|NULL
operator|)
control|)
block|{
name|int
name|bind
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|,
modifier|*
name|new_sec
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|bfd_boolean
name|definition
decl_stmt|;
name|bfd_boolean
name|size_change_ok
decl_stmt|;
name|bfd_boolean
name|type_change_ok
decl_stmt|;
name|bfd_boolean
name|new_weakdef
decl_stmt|;
name|bfd_boolean
name|override
decl_stmt|;
name|bfd_boolean
name|common
decl_stmt|;
name|unsigned
name|int
name|old_alignment
decl_stmt|;
name|bfd
modifier|*
name|old_bfd
decl_stmt|;
name|override
operator|=
name|FALSE
expr_stmt|;
name|flags
operator|=
name|BSF_NO_FLAGS
expr_stmt|;
name|sec
operator|=
name|NULL
expr_stmt|;
name|value
operator|=
name|isym
operator|->
name|st_value
expr_stmt|;
operator|*
name|sym_hash
operator|=
name|NULL
expr_stmt|;
name|common
operator|=
name|bed
operator|->
name|common_definition
argument_list|(
name|isym
argument_list|)
expr_stmt|;
name|bind
operator|=
name|ELF_ST_BIND
argument_list|(
name|isym
operator|->
name|st_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|bind
operator|==
name|STB_LOCAL
condition|)
block|{
comment|/* This should be impossible, since ELF requires that all 	     global symbols follow all local symbols, and that sh_info 	     point to the first global symbol.  Unfortunately, Irix 5 	     screws this up.  */
continue|continue;
block|}
elseif|else
if|if
condition|(
name|bind
operator|==
name|STB_GLOBAL
condition|)
block|{
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|!=
name|SHN_UNDEF
operator|&&
operator|!
name|common
condition|)
name|flags
operator|=
name|BSF_GLOBAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bind
operator|==
name|STB_WEAK
condition|)
name|flags
operator|=
name|BSF_WEAK
expr_stmt|;
else|else
block|{
comment|/* Leave it up to the processor backend.  */
block|}
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_UNDEF
condition|)
name|sec
operator|=
name|bfd_und_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|<
name|SHN_LORESERVE
operator|||
name|isym
operator|->
name|st_shndx
operator|>
name|SHN_HIRESERVE
condition|)
block|{
name|sec
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|abfd
argument_list|,
name|isym
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
name|sec
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|sec
operator|->
name|kept_section
condition|)
block|{
comment|/* Symbols from discarded section are undefined.  We keep 		 its visibility.  */
name|sec
operator|=
name|bfd_und_section_ptr
expr_stmt|;
name|isym
operator|->
name|st_shndx
operator|=
name|SHN_UNDEF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
operator|(
name|EXEC_P
operator||
name|DYNAMIC
operator|)
operator|)
operator|!=
literal|0
condition|)
name|value
operator|-=
name|sec
operator|->
name|vma
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_ABS
condition|)
name|sec
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_COMMON
condition|)
block|{
name|sec
operator|=
name|bfd_com_section_ptr
expr_stmt|;
comment|/* What ELF calls the size we call the value.  What ELF 	     calls the value we call the alignment.  */
name|value
operator|=
name|isym
operator|->
name|st_size
expr_stmt|;
block|}
else|else
block|{
comment|/* Leave it up to the processor backend.  */
block|}
name|name
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|sh_link
argument_list|,
name|isym
operator|->
name|st_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
goto|goto
name|error_free_vers
goto|;
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_COMMON
operator|&&
name|ELF_ST_TYPE
argument_list|(
name|isym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_TLS
operator|&&
operator|!
name|info
operator|->
name|relocatable
condition|)
block|{
name|asection
modifier|*
name|tcomm
init|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".tcommon"
argument_list|)
decl_stmt|;
if|if
condition|(
name|tcomm
operator|==
name|NULL
condition|)
block|{
name|tcomm
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|abfd
argument_list|,
literal|".tcommon"
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_IS_COMMON
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_THREAD_LOCAL
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcomm
operator|==
name|NULL
condition|)
goto|goto
name|error_free_vers
goto|;
block|}
name|sec
operator|=
name|tcomm
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bed
operator|->
name|elf_add_symbol_hook
condition|)
block|{
if|if
condition|(
operator|!
call|(
modifier|*
name|bed
operator|->
name|elf_add_symbol_hook
call|)
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|isym
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|flags
argument_list|,
operator|&
name|sec
argument_list|,
operator|&
name|value
argument_list|)
condition|)
goto|goto
name|error_free_vers
goto|;
comment|/* The hook function sets the name to NULL if this symbol 	     should be skipped for some reason.  */
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
continue|continue;
block|}
comment|/* Sanity check that all possibilities were handled.  */
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
goto|goto
name|error_free_vers
goto|;
block|}
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|sec
argument_list|)
operator|||
name|bfd_is_com_section
argument_list|(
name|sec
argument_list|)
condition|)
name|definition
operator|=
name|FALSE
expr_stmt|;
else|else
name|definition
operator|=
name|TRUE
expr_stmt|;
name|size_change_ok
operator|=
name|FALSE
expr_stmt|;
name|type_change_ok
operator|=
name|bed
operator|->
name|type_change_ok
expr_stmt|;
name|old_alignment
operator|=
literal|0
expr_stmt|;
name|old_bfd
operator|=
name|NULL
expr_stmt|;
name|new_sec
operator|=
name|sec
expr_stmt|;
if|if
condition|(
name|is_elf_hash_table
argument_list|(
name|htab
argument_list|)
condition|)
block|{
name|Elf_Internal_Versym
name|iver
decl_stmt|;
name|unsigned
name|int
name|vernum
init|=
literal|0
decl_stmt|;
name|bfd_boolean
name|skip
decl_stmt|;
if|if
condition|(
name|ever
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|default_imported_symver
condition|)
comment|/* Use the default symbol version created earlier.  */
name|iver
operator|.
name|vs_vers
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|cverdefs
expr_stmt|;
else|else
name|iver
operator|.
name|vs_vers
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|_bfd_elf_swap_versym_in
argument_list|(
name|abfd
argument_list|,
name|ever
argument_list|,
operator|&
name|iver
argument_list|)
expr_stmt|;
name|vernum
operator|=
name|iver
operator|.
name|vs_vers
operator|&
name|VERSYM_VERSION
expr_stmt|;
comment|/* If this is a hidden symbol, or if it is not version 	     1, we append the version name to the symbol name. 	     However, we do not modify a non-hidden absolute symbol 	     if it is not a function, because it might be the version 	     symbol itself.  FIXME: What if it isn't?  */
if|if
condition|(
operator|(
name|iver
operator|.
name|vs_vers
operator|&
name|VERSYM_HIDDEN
operator|)
operator|!=
literal|0
operator|||
operator|(
name|vernum
operator|>
literal|1
operator|&&
operator|(
operator|!
name|bfd_is_abs_section
argument_list|(
name|sec
argument_list|)
operator|||
name|bed
operator|->
name|is_function_type
argument_list|(
name|ELF_ST_TYPE
argument_list|(
name|isym
operator|->
name|st_info
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|verstr
decl_stmt|;
name|size_t
name|namelen
decl_stmt|,
name|verlen
decl_stmt|,
name|newlen
decl_stmt|;
name|char
modifier|*
name|newname
decl_stmt|,
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|!=
name|SHN_UNDEF
condition|)
block|{
if|if
condition|(
name|vernum
operator|>
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|cverdefs
condition|)
name|verstr
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|vernum
operator|>
literal|1
condition|)
name|verstr
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|verdef
index|[
name|vernum
operator|-
literal|1
index|]
operator|.
name|vd_nodename
expr_stmt|;
else|else
name|verstr
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|verstr
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: %s: invalid version %u (max %d)"
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|name
argument_list|,
name|vernum
argument_list|,
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|cverdefs
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
goto|goto
name|error_free_vers
goto|;
block|}
block|}
else|else
block|{
comment|/* We cannot simply test for the number of 		     entries in the VERNEED section since the 		     numbers for the needed versions do not start 		     at 0.  */
name|Elf_Internal_Verneed
modifier|*
name|t
decl_stmt|;
name|verstr
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|t
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|verref
init|;
name|t
operator|!=
name|NULL
condition|;
name|t
operator|=
name|t
operator|->
name|vn_nextref
control|)
block|{
name|Elf_Internal_Vernaux
modifier|*
name|a
decl_stmt|;
for|for
control|(
name|a
operator|=
name|t
operator|->
name|vn_auxptr
init|;
name|a
operator|!=
name|NULL
condition|;
name|a
operator|=
name|a
operator|->
name|vna_nextptr
control|)
block|{
if|if
condition|(
name|a
operator|->
name|vna_other
operator|==
name|vernum
condition|)
block|{
name|verstr
operator|=
name|a
operator|->
name|vna_nodename
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|a
operator|!=
name|NULL
condition|)
break|break;
block|}
if|if
condition|(
name|verstr
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: %s: invalid needed version %d"
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|name
argument_list|,
name|vernum
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
goto|goto
name|error_free_vers
goto|;
block|}
block|}
name|namelen
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|verlen
operator|=
name|strlen
argument_list|(
name|verstr
argument_list|)
expr_stmt|;
name|newlen
operator|=
name|namelen
operator|+
name|verlen
operator|+
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|iver
operator|.
name|vs_vers
operator|&
name|VERSYM_HIDDEN
operator|)
operator|==
literal|0
operator|&&
name|isym
operator|->
name|st_shndx
operator|!=
name|SHN_UNDEF
condition|)
operator|++
name|newlen
expr_stmt|;
name|newname
operator|=
name|bfd_hash_allocate
argument_list|(
operator|&
name|htab
operator|->
name|root
operator|.
name|table
argument_list|,
name|newlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|newname
operator|==
name|NULL
condition|)
goto|goto
name|error_free_vers
goto|;
name|memcpy
argument_list|(
name|newname
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|p
operator|=
name|newname
operator|+
name|namelen
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|ELF_VER_CHR
expr_stmt|;
comment|/* If this is a defined non-hidden version symbol, 		 we add another @ to the name.  This indicates the 		 default version of the symbol.  */
if|if
condition|(
operator|(
name|iver
operator|.
name|vs_vers
operator|&
name|VERSYM_HIDDEN
operator|)
operator|==
literal|0
operator|&&
name|isym
operator|->
name|st_shndx
operator|!=
name|SHN_UNDEF
condition|)
operator|*
name|p
operator|++
operator|=
name|ELF_VER_CHR
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|verstr
argument_list|,
name|verlen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|name
operator|=
name|newname
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|_bfd_elf_merge_symbol
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|name
argument_list|,
name|isym
argument_list|,
operator|&
name|sec
argument_list|,
operator|&
name|value
argument_list|,
operator|&
name|old_alignment
argument_list|,
name|sym_hash
argument_list|,
operator|&
name|skip
argument_list|,
operator|&
name|override
argument_list|,
operator|&
name|type_change_ok
argument_list|,
operator|&
name|size_change_ok
argument_list|)
condition|)
goto|goto
name|error_free_vers
goto|;
if|if
condition|(
name|skip
condition|)
continue|continue;
if|if
condition|(
name|override
condition|)
name|definition
operator|=
name|FALSE
expr_stmt|;
name|h
operator|=
operator|*
name|sym_hash
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
comment|/* Remember the old alignment if this is a common symbol, so 	     that we don't reduce the alignment later on.  We can't 	     check later, because _bfd_generic_link_add_one_symbol 	     will set a default for the alignment which we want to 	     override. We also remember the old bfd where the existing 	     definition comes from.  */
switch|switch
condition|(
name|h
operator|->
name|root
operator|.
name|type
condition|)
block|{
default|default:
break|break;
case|case
name|bfd_link_hash_defined
case|:
case|case
name|bfd_link_hash_defweak
case|:
name|old_bfd
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
expr_stmt|;
break|break;
case|case
name|bfd_link_hash_common
case|:
name|old_bfd
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
operator|->
name|owner
expr_stmt|;
name|old_alignment
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|alignment_power
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|verdef
operator|!=
name|NULL
operator|&&
operator|!
name|override
operator|&&
name|vernum
operator|>
literal|1
operator|&&
name|definition
condition|)
name|h
operator|->
name|verinfo
operator|.
name|verdef
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|verdef
index|[
name|vernum
operator|-
literal|1
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
name|name
argument_list|,
name|flags
argument_list|,
name|sec
argument_list|,
name|value
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|bed
operator|->
name|collect
argument_list|,
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|*
operator|)
name|sym_hash
argument_list|)
operator|)
condition|)
goto|goto
name|error_free_vers
goto|;
name|h
operator|=
operator|*
name|sym_hash
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
operator|*
name|sym_hash
operator|=
name|h
expr_stmt|;
name|new_weakdef
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|dynamic
operator|&&
name|definition
operator|&&
operator|(
name|flags
operator|&
name|BSF_WEAK
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|bed
operator|->
name|is_function_type
argument_list|(
name|ELF_ST_TYPE
argument_list|(
name|isym
operator|->
name|st_info
argument_list|)
argument_list|)
operator|&&
name|is_elf_hash_table
argument_list|(
name|htab
argument_list|)
operator|&&
name|h
operator|->
name|u
operator|.
name|weakdef
operator|==
name|NULL
condition|)
block|{
comment|/* Keep a list of all weak defined non function symbols from 	     a dynamic object, using the weakdef field.  Later in this 	     function we will set the weakdef field to the correct 	     value.  We only put non-function symbols from dynamic 	     objects on this list, because that happens to be the only 	     time we need to know the normal symbol corresponding to a 	     weak symbol, and the information is time consuming to 	     figure out.  If the weakdef field is not already NULL, 	     then this symbol was already defined by some previous 	     dynamic object, and we will be using that previous 	     definition anyhow.  */
name|h
operator|->
name|u
operator|.
name|weakdef
operator|=
name|weaks
expr_stmt|;
name|weaks
operator|=
name|h
expr_stmt|;
name|new_weakdef
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Set the alignment of a common symbol.  */
if|if
condition|(
operator|(
name|common
operator|||
name|bfd_is_com_section
argument_list|(
name|sec
argument_list|)
operator|)
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_common
condition|)
block|{
name|unsigned
name|int
name|align
decl_stmt|;
if|if
condition|(
name|common
condition|)
name|align
operator|=
name|bfd_log2
argument_list|(
name|isym
operator|->
name|st_value
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* The new symbol is a common symbol in a shared object. 		 We need to get the alignment from the section.  */
name|align
operator|=
name|new_sec
operator|->
name|alignment_power
expr_stmt|;
block|}
if|if
condition|(
name|align
operator|>
name|old_alignment
comment|/* Permit an alignment power of zero if an alignment of one 		 is specified and no other alignments have been specified.  */
operator|||
operator|(
name|isym
operator|->
name|st_value
operator|==
literal|1
operator|&&
name|old_alignment
operator|==
literal|0
operator|)
condition|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|alignment_power
operator|=
name|align
expr_stmt|;
else|else
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|alignment_power
operator|=
name|old_alignment
expr_stmt|;
block|}
if|if
condition|(
name|is_elf_hash_table
argument_list|(
name|htab
argument_list|)
condition|)
block|{
name|bfd_boolean
name|dynsym
decl_stmt|;
comment|/* Check the alignment when a common symbol is involved. This 	     can change when a common symbol is overridden by a normal 	     definition or a common symbol is ignored due to the old 	     normal definition. We need to make sure the maximum 	     alignment is maintained.  */
if|if
condition|(
operator|(
name|old_alignment
operator|||
name|common
operator|)
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_common
condition|)
block|{
name|unsigned
name|int
name|common_align
decl_stmt|;
name|unsigned
name|int
name|normal_align
decl_stmt|;
name|unsigned
name|int
name|symbol_align
decl_stmt|;
name|bfd
modifier|*
name|normal_bfd
decl_stmt|;
name|bfd
modifier|*
name|common_bfd
decl_stmt|;
name|symbol_align
operator|=
name|ffs
argument_list|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|==
literal|0
condition|)
block|{
name|normal_align
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|alignment_power
expr_stmt|;
if|if
condition|(
name|normal_align
operator|>
name|symbol_align
condition|)
name|normal_align
operator|=
name|symbol_align
expr_stmt|;
block|}
else|else
name|normal_align
operator|=
name|symbol_align
expr_stmt|;
if|if
condition|(
name|old_alignment
condition|)
block|{
name|common_align
operator|=
name|old_alignment
expr_stmt|;
name|common_bfd
operator|=
name|old_bfd
expr_stmt|;
name|normal_bfd
operator|=
name|abfd
expr_stmt|;
block|}
else|else
block|{
name|common_align
operator|=
name|bfd_log2
argument_list|(
name|isym
operator|->
name|st_value
argument_list|)
expr_stmt|;
name|common_bfd
operator|=
name|abfd
expr_stmt|;
name|normal_bfd
operator|=
name|old_bfd
expr_stmt|;
block|}
if|if
condition|(
name|normal_align
operator|<
name|common_align
condition|)
block|{
comment|/* PR binutils/2735 */
if|if
condition|(
name|normal_bfd
operator|==
name|NULL
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Warning: alignment %u of common symbol `%s' in %B"
literal|" is greater than the alignment (%u) of its section %A"
argument_list|)
argument_list|,
name|common_bfd
argument_list|,
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
argument_list|,
literal|1
operator|<<
name|common_align
argument_list|,
name|name
argument_list|,
literal|1
operator|<<
name|normal_align
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Warning: alignment %u of symbol `%s' in %B"
literal|" is smaller than %u in %B"
argument_list|)
argument_list|,
name|normal_bfd
argument_list|,
name|common_bfd
argument_list|,
literal|1
operator|<<
name|normal_align
argument_list|,
name|name
argument_list|,
literal|1
operator|<<
name|common_align
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Remember the symbol size if it isn't undefined.  */
if|if
condition|(
operator|(
name|isym
operator|->
name|st_size
operator|!=
literal|0
operator|&&
name|isym
operator|->
name|st_shndx
operator|!=
name|SHN_UNDEF
operator|)
operator|&&
operator|(
name|definition
operator|||
name|h
operator|->
name|size
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|size
operator|!=
literal|0
operator|&&
name|h
operator|->
name|size
operator|!=
name|isym
operator|->
name|st_size
operator|&&
operator|!
name|size_change_ok
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Warning: size of symbol `%s' changed"
literal|" from %lu in %B to %lu in %B"
argument_list|)
argument_list|,
name|old_bfd
argument_list|,
name|abfd
argument_list|,
name|name
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|h
operator|->
name|size
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|isym
operator|->
name|st_size
argument_list|)
expr_stmt|;
name|h
operator|->
name|size
operator|=
name|isym
operator|->
name|st_size
expr_stmt|;
block|}
comment|/* If this is a common symbol, then we always want H->SIZE 	     to be the size of the common symbol.  The code just above 	     won't fix the size if a common symbol becomes larger.  We 	     don't warn about a size change here, because that is 	     covered by --warn-common.  Allow changed between different 	     function types.  */
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_common
condition|)
name|h
operator|->
name|size
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|size
expr_stmt|;
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|isym
operator|->
name|st_info
argument_list|)
operator|!=
name|STT_NOTYPE
operator|&&
operator|(
name|definition
operator|||
name|h
operator|->
name|type
operator|==
name|STT_NOTYPE
operator|)
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|type
operator|!=
name|STT_NOTYPE
operator|&&
name|h
operator|->
name|type
operator|!=
name|ELF_ST_TYPE
argument_list|(
name|isym
operator|->
name|st_info
argument_list|)
operator|&&
operator|!
name|type_change_ok
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Warning: type of symbol `%s' changed"
literal|" from %d to %d in %B"
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|name
argument_list|,
name|h
operator|->
name|type
argument_list|,
name|ELF_ST_TYPE
argument_list|(
name|isym
operator|->
name|st_info
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|ELF_ST_TYPE
argument_list|(
name|isym
operator|->
name|st_info
argument_list|)
expr_stmt|;
block|}
comment|/* If st_other has a processor-specific meaning, specific 	     code might be needed here. We never merge the visibility 	     attribute with the one from a dynamic object.  */
if|if
condition|(
name|bed
operator|->
name|elf_backend_merge_symbol_attribute
condition|)
call|(
modifier|*
name|bed
operator|->
name|elf_backend_merge_symbol_attribute
call|)
argument_list|(
name|h
argument_list|,
name|isym
argument_list|,
name|definition
argument_list|,
name|dynamic
argument_list|)
expr_stmt|;
comment|/* If this symbol has default visibility and the user has requested 	     we not re-export it, then mark it as hidden.  */
if|if
condition|(
name|definition
operator|&&
operator|!
name|dynamic
operator|&&
operator|(
name|abfd
operator|->
name|no_export
operator|||
operator|(
name|abfd
operator|->
name|my_archive
operator|&&
name|abfd
operator|->
name|my_archive
operator|->
name|no_export
operator|)
operator|)
operator|&&
name|ELF_ST_VISIBILITY
argument_list|(
name|isym
operator|->
name|st_other
argument_list|)
operator|!=
name|STV_INTERNAL
condition|)
name|isym
operator|->
name|st_other
operator|=
operator|(
name|STV_HIDDEN
operator||
operator|(
name|isym
operator|->
name|st_other
operator|&
operator|~
name|ELF_ST_VISIBILITY
argument_list|(
operator|-
literal|1
argument_list|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|ELF_ST_VISIBILITY
argument_list|(
name|isym
operator|->
name|st_other
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
name|dynamic
condition|)
block|{
name|unsigned
name|char
name|hvis
decl_stmt|,
name|symvis
decl_stmt|,
name|other
decl_stmt|,
name|nvis
decl_stmt|;
comment|/* Only merge the visibility. Leave the remainder of the 		 st_other field to elf_backend_merge_symbol_attribute.  */
name|other
operator|=
name|h
operator|->
name|other
operator|&
operator|~
name|ELF_ST_VISIBILITY
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Combine visibilities, using the most constraining one.  */
name|hvis
operator|=
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
expr_stmt|;
name|symvis
operator|=
name|ELF_ST_VISIBILITY
argument_list|(
name|isym
operator|->
name|st_other
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hvis
condition|)
name|nvis
operator|=
name|symvis
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|symvis
condition|)
name|nvis
operator|=
name|hvis
expr_stmt|;
else|else
name|nvis
operator|=
name|hvis
operator|<
name|symvis
condition|?
name|hvis
else|:
name|symvis
expr_stmt|;
name|h
operator|->
name|other
operator|=
name|other
operator||
name|nvis
expr_stmt|;
block|}
comment|/* Set a flag in the hash table entry indicating the type of 	     reference or definition we just found.  Keep a count of 	     the number of dynamic symbols we find.  A dynamic symbol 	     is one which is referenced or defined by both a regular 	     object and a shared object.  */
name|dynsym
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|dynamic
condition|)
block|{
if|if
condition|(
operator|!
name|definition
condition|)
block|{
name|h
operator|->
name|ref_regular
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|bind
operator|!=
name|STB_WEAK
condition|)
name|h
operator|->
name|ref_regular_nonweak
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|h
operator|->
name|def_regular
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|executable
operator|||
name|h
operator|->
name|def_dynamic
operator|||
name|h
operator|->
name|ref_dynamic
condition|)
name|dynsym
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|definition
condition|)
name|h
operator|->
name|ref_dynamic
operator|=
literal|1
expr_stmt|;
else|else
name|h
operator|->
name|def_dynamic
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|def_regular
operator|||
name|h
operator|->
name|ref_regular
operator|||
operator|(
name|h
operator|->
name|u
operator|.
name|weakdef
operator|!=
name|NULL
operator|&&
operator|!
name|new_weakdef
operator|&&
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|)
condition|)
name|dynsym
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|definition
operator|&&
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_DEBUGGING
operator|)
condition|)
block|{
comment|/* We don't want to make debug symbol dynamic.  */
call|(
modifier|*
name|bed
operator|->
name|elf_backend_hide_symbol
call|)
argument_list|(
name|info
argument_list|,
name|h
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|dynsym
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* Check to see if we need to add an indirect symbol for 	     the default name.  */
if|if
condition|(
name|definition
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_common
condition|)
if|if
condition|(
operator|!
name|_bfd_elf_add_default_symbol
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|h
argument_list|,
name|name
argument_list|,
name|isym
argument_list|,
operator|&
name|sec
argument_list|,
operator|&
name|value
argument_list|,
operator|&
name|dynsym
argument_list|,
name|override
argument_list|)
condition|)
goto|goto
name|error_free_vers
goto|;
if|if
condition|(
name|definition
operator|&&
operator|!
name|dynamic
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|strchr
argument_list|(
name|name
argument_list|,
name|ELF_VER_CHR
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
name|p
index|[
literal|1
index|]
operator|!=
name|ELF_VER_CHR
condition|)
block|{
comment|/* Queue non-default versions so that .symver x, x@FOO 		     aliases can be checked.  */
if|if
condition|(
operator|!
name|nondeflt_vers
condition|)
block|{
name|amt
operator|=
operator|(
operator|(
name|isymend
operator|-
name|isym
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|elf_link_hash_entry
operator|*
argument_list|)
operator|)
expr_stmt|;
name|nondeflt_vers
operator|=
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
block|}
name|nondeflt_vers
index|[
name|nondeflt_vers_cnt
operator|++
index|]
operator|=
name|h
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dynsym
operator|&&
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
goto|goto
name|error_free_vers
goto|;
if|if
condition|(
name|h
operator|->
name|u
operator|.
name|weakdef
operator|!=
name|NULL
operator|&&
operator|!
name|new_weakdef
operator|&&
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|u
operator|.
name|weakdef
argument_list|)
condition|)
goto|goto
name|error_free_vers
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|dynsym
operator|&&
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
condition|)
comment|/* If the symbol already has a dynamic index, but 	       visibility says it should not be visible, turn it into 	       a local symbol.  */
switch|switch
condition|(
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
condition|)
block|{
case|case
name|STV_INTERNAL
case|:
case|case
name|STV_HIDDEN
case|:
call|(
modifier|*
name|bed
operator|->
name|elf_backend_hide_symbol
call|)
argument_list|(
name|info
argument_list|,
name|h
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|dynsym
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|add_needed
operator|&&
name|definition
operator|&&
name|dynsym
operator|&&
name|h
operator|->
name|ref_regular
condition|)
block|{
name|int
name|ret
decl_stmt|;
specifier|const
name|char
modifier|*
name|soname
init|=
name|elf_dt_name
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
comment|/* A symbol from a library loaded via DT_NEEDED of some 		 other library is referenced by a regular object. 		 Add a DT_NEEDED entry for it.  Issue an error if 		 --no-add-needed is used.  */
if|if
condition|(
operator|(
name|elf_dyn_lib_class
argument_list|(
name|abfd
argument_list|)
operator|&
name|DYN_NO_NEEDED
operator|)
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: invalid DSO for symbol `%s' definition"
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
goto|goto
name|error_free_vers
goto|;
block|}
name|elf_dyn_lib_class
argument_list|(
name|abfd
argument_list|)
operator|&=
operator|~
name|DYN_AS_NEEDED
expr_stmt|;
name|add_needed
operator|=
name|TRUE
expr_stmt|;
name|ret
operator|=
name|elf_add_dt_needed_tag
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|soname
argument_list|,
name|add_needed
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
goto|goto
name|error_free_vers
goto|;
name|BFD_ASSERT
argument_list|(
name|ret
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|extversym
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|extversym
argument_list|)
expr_stmt|;
name|extversym
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|isymbuf
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|isymbuf
argument_list|)
expr_stmt|;
name|isymbuf
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|elf_dyn_lib_class
argument_list|(
name|abfd
argument_list|)
operator|&
name|DYN_AS_NEEDED
operator|)
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* Restore the symbol table.  */
if|if
condition|(
name|bed
operator|->
name|as_needed_cleanup
condition|)
call|(
modifier|*
name|bed
operator|->
name|as_needed_cleanup
call|)
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|old_hash
operator|=
operator|(
name|char
operator|*
operator|)
name|old_tab
operator|+
name|tabsize
expr_stmt|;
name|old_ent
operator|=
operator|(
name|char
operator|*
operator|)
name|old_hash
operator|+
name|hashsize
expr_stmt|;
name|sym_hash
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|htab
operator|->
name|root
operator|.
name|table
operator|.
name|table
operator|=
name|old_table
expr_stmt|;
name|htab
operator|->
name|root
operator|.
name|table
operator|.
name|size
operator|=
name|old_size
expr_stmt|;
name|htab
operator|->
name|root
operator|.
name|table
operator|.
name|count
operator|=
name|old_count
expr_stmt|;
name|memcpy
argument_list|(
name|htab
operator|->
name|root
operator|.
name|table
operator|.
name|table
argument_list|,
name|old_tab
argument_list|,
name|tabsize
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|sym_hash
argument_list|,
name|old_hash
argument_list|,
name|hashsize
argument_list|)
expr_stmt|;
name|htab
operator|->
name|root
operator|.
name|undefs
operator|=
name|old_undefs
expr_stmt|;
name|htab
operator|->
name|root
operator|.
name|undefs_tail
operator|=
name|old_undefs_tail
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|htab
operator|->
name|root
operator|.
name|table
operator|.
name|size
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|bfd_hash_entry
modifier|*
name|p
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
for|for
control|(
name|p
operator|=
name|htab
operator|->
name|root
operator|.
name|table
operator|.
name|table
index|[
name|i
index|]
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|p
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|dynindx
operator|>=
name|old_dynsymcount
condition|)
name|_bfd_elf_strtab_delref
argument_list|(
name|htab
operator|->
name|dynstr
argument_list|,
name|h
operator|->
name|dynstr_index
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|old_ent
argument_list|,
name|htab
operator|->
name|root
operator|.
name|table
operator|.
name|entsize
argument_list|)
expr_stmt|;
name|old_ent
operator|=
operator|(
name|char
operator|*
operator|)
name|old_ent
operator|+
name|htab
operator|->
name|root
operator|.
name|table
operator|.
name|entsize
expr_stmt|;
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|p
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
block|{
name|memcpy
argument_list|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
argument_list|,
name|old_ent
argument_list|,
name|htab
operator|->
name|root
operator|.
name|table
operator|.
name|entsize
argument_list|)
expr_stmt|;
name|old_ent
operator|=
operator|(
name|char
operator|*
operator|)
name|old_ent
operator|+
name|htab
operator|->
name|root
operator|.
name|table
operator|.
name|entsize
expr_stmt|;
block|}
block|}
block|}
comment|/* Make a special call to the linker "notice" function to 	 tell it that symbols added for crefs may need to be removed.  */
if|if
condition|(
operator|!
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|notice
call|)
argument_list|(
name|info
argument_list|,
name|NULL
argument_list|,
name|abfd
argument_list|,
name|NULL
argument_list|,
name|notice_not_needed
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|free
argument_list|(
name|old_tab
argument_list|)
expr_stmt|;
name|objalloc_free_block
argument_list|(
operator|(
expr|struct
name|objalloc
operator|*
operator|)
name|htab
operator|->
name|root
operator|.
name|table
operator|.
name|memory
argument_list|,
name|alloc_mark
argument_list|)
expr_stmt|;
if|if
condition|(
name|nondeflt_vers
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|nondeflt_vers
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
name|old_tab
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|notice
call|)
argument_list|(
name|info
argument_list|,
name|NULL
argument_list|,
name|abfd
argument_list|,
name|NULL
argument_list|,
name|notice_needed
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|free
argument_list|(
name|old_tab
argument_list|)
expr_stmt|;
name|old_tab
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Now that all the symbols from this input file are created, handle      .symver foo, foo@BAR such that any relocs against foo become foo@BAR.  */
if|if
condition|(
name|nondeflt_vers
operator|!=
name|NULL
condition|)
block|{
name|bfd_size_type
name|cnt
decl_stmt|,
name|symidx
decl_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|nondeflt_vers_cnt
condition|;
operator|++
name|cnt
control|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
init|=
name|nondeflt_vers
index|[
name|cnt
index|]
decl_stmt|,
modifier|*
name|hi
decl_stmt|;
name|char
modifier|*
name|shortname
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|ELF_VER_CHR
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defined
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
operator|)
condition|)
continue|continue;
name|amt
operator|=
name|p
operator|-
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
name|shortname
operator|=
name|bfd_malloc
argument_list|(
name|amt
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|shortname
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|amt
argument_list|)
expr_stmt|;
name|shortname
index|[
name|amt
index|]
operator|=
literal|'\0'
expr_stmt|;
name|hi
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|bfd_link_hash_lookup
argument_list|(
operator|&
name|htab
operator|->
name|root
argument_list|,
name|shortname
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|hi
operator|!=
name|NULL
operator|&&
name|hi
operator|->
name|root
operator|.
name|type
operator|==
name|h
operator|->
name|root
operator|.
name|type
operator|&&
name|hi
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|==
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|&&
name|hi
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|==
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
condition|)
block|{
call|(
modifier|*
name|bed
operator|->
name|elf_backend_hide_symbol
call|)
argument_list|(
name|info
argument_list|,
name|hi
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|hi
operator|->
name|root
operator|.
name|type
operator|=
name|bfd_link_hash_indirect
expr_stmt|;
name|hi
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
operator|=
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
call|(
modifier|*
name|bed
operator|->
name|elf_backend_copy_indirect_symbol
call|)
argument_list|(
name|info
argument_list|,
name|h
argument_list|,
name|hi
argument_list|)
expr_stmt|;
name|sym_hash
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_hash
condition|)
for|for
control|(
name|symidx
operator|=
literal|0
init|;
name|symidx
operator|<
name|extsymcount
condition|;
operator|++
name|symidx
control|)
if|if
condition|(
name|sym_hash
index|[
name|symidx
index|]
operator|==
name|hi
condition|)
block|{
name|sym_hash
index|[
name|symidx
index|]
operator|=
name|h
expr_stmt|;
break|break;
block|}
block|}
name|free
argument_list|(
name|shortname
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|nondeflt_vers
argument_list|)
expr_stmt|;
name|nondeflt_vers
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Now set the weakdefs field correctly for all the weak defined      symbols we found.  The only way to do this is to search all the      symbols.  Since we only need the information for non functions in      dynamic objects, that's the only time we actually put anything on      the list WEAKS.  We need this information so that if a regular      object refers to a symbol defined weakly in a dynamic object, the      real symbol in the dynamic object is also put in the dynamic      symbols; we also must arrange for both symbols to point to the      same memory location.  We could handle the general case of symbol      aliasing, but a general symbol alias can only be generated in      assembler code, handling it correctly would be very time      consuming, and other ELF linkers don't handle general aliasing      either.  */
if|if
condition|(
name|weaks
operator|!=
name|NULL
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|hpp
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|hppend
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sorted_sym_hash
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|size_t
name|sym_count
decl_stmt|;
comment|/* Since we have to search the whole symbol list for each weak 	 defined symbol, search time for N weak defined symbols will be 	 O(N^2). Binary search will cut it down to O(NlogN).  */
name|amt
operator|=
name|extsymcount
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|elf_link_hash_entry
operator|*
argument_list|)
expr_stmt|;
name|sorted_sym_hash
operator|=
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|sorted_sym_hash
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|sym_hash
operator|=
name|sorted_sym_hash
expr_stmt|;
name|hpp
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|hppend
operator|=
name|hpp
operator|+
name|extsymcount
expr_stmt|;
name|sym_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|hpp
operator|<
name|hppend
condition|;
name|hpp
operator|++
control|)
block|{
name|h
operator|=
operator|*
name|hpp
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|&&
operator|!
name|bed
operator|->
name|is_function_type
argument_list|(
name|h
operator|->
name|type
argument_list|)
condition|)
block|{
operator|*
name|sym_hash
operator|=
name|h
expr_stmt|;
name|sym_hash
operator|++
expr_stmt|;
name|sym_count
operator|++
expr_stmt|;
block|}
block|}
name|qsort
argument_list|(
name|sorted_sym_hash
argument_list|,
name|sym_count
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|elf_link_hash_entry
operator|*
argument_list|)
argument_list|,
name|elf_sort_symbol
argument_list|)
expr_stmt|;
while|while
condition|(
name|weaks
operator|!=
name|NULL
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|hlook
decl_stmt|;
name|asection
modifier|*
name|slook
decl_stmt|;
name|bfd_vma
name|vlook
decl_stmt|;
name|long
name|ilook
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|j
decl_stmt|,
name|idx
decl_stmt|;
name|hlook
operator|=
name|weaks
expr_stmt|;
name|weaks
operator|=
name|hlook
operator|->
name|u
operator|.
name|weakdef
expr_stmt|;
name|hlook
operator|->
name|u
operator|.
name|weakdef
operator|=
name|NULL
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|hlook
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|hlook
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|||
name|hlook
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_common
operator|||
name|hlook
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
argument_list|)
expr_stmt|;
name|slook
operator|=
name|hlook
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|vlook
operator|=
name|hlook
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
name|ilook
operator|=
operator|-
literal|1
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|j
operator|=
name|sym_count
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|j
condition|)
block|{
name|bfd_signed_vma
name|vdiff
decl_stmt|;
name|idx
operator|=
operator|(
name|i
operator|+
name|j
operator|)
operator|/
literal|2
expr_stmt|;
name|h
operator|=
name|sorted_sym_hash
index|[
name|idx
index|]
expr_stmt|;
name|vdiff
operator|=
name|vlook
operator|-
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
if|if
condition|(
name|vdiff
operator|<
literal|0
condition|)
name|j
operator|=
name|idx
expr_stmt|;
elseif|else
if|if
condition|(
name|vdiff
operator|>
literal|0
condition|)
name|i
operator|=
name|idx
operator|+
literal|1
expr_stmt|;
else|else
block|{
name|long
name|sdiff
init|=
name|slook
operator|->
name|id
operator|-
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|id
decl_stmt|;
if|if
condition|(
name|sdiff
operator|<
literal|0
condition|)
name|j
operator|=
name|idx
expr_stmt|;
elseif|else
if|if
condition|(
name|sdiff
operator|>
literal|0
condition|)
name|i
operator|=
name|idx
operator|+
literal|1
expr_stmt|;
else|else
block|{
name|ilook
operator|=
name|idx
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* We didn't find a value/section match.  */
if|if
condition|(
name|ilook
operator|==
operator|-
literal|1
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
name|ilook
init|;
name|i
operator|<
name|sym_count
condition|;
name|i
operator|++
control|)
block|{
name|h
operator|=
name|sorted_sym_hash
index|[
name|i
index|]
expr_stmt|;
comment|/* Stop if value or section doesn't match.  */
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|!=
name|vlook
operator|||
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|!=
name|slook
condition|)
break|break;
elseif|else
if|if
condition|(
name|h
operator|!=
name|hlook
condition|)
block|{
name|hlook
operator|->
name|u
operator|.
name|weakdef
operator|=
name|h
expr_stmt|;
comment|/* If the weak definition is in the list of dynamic 		     symbols, make sure the real definition is put 		     there as well.  */
if|if
condition|(
name|hlook
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|&&
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
comment|/* If the real definition is in the list of dynamic 		     symbols, make sure the weak definition is put 		     there as well.  If we don't do this, then the 		     dynamic loader might not merge the entries for the 		     real definition and the weak definition.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|&&
name|hlook
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|hlook
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
break|break;
block|}
block|}
block|}
name|free
argument_list|(
name|sorted_sym_hash
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bed
operator|->
name|check_directives
condition|)
call|(
modifier|*
name|bed
operator|->
name|check_directives
call|)
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
expr_stmt|;
comment|/* If this object is the same format as the output object, and it is      not a shared library, then let the backend look through the      relocs.       This is required to build global offset table entries and to      arrange for dynamic relocs.  It is not required for the      particular common case of linking non PIC code, even when linking      against shared libraries, but unfortunately there is no way of      knowing whether an object file has been compiled PIC or not.      Looking through the relocs is not particularly time consuming.      The problem is that we must either (1) keep the relocs in memory,      which causes the linker to require additional runtime memory or      (2) read the relocs twice from the input file, which wastes time.      This would be a good case for using mmap.       I have no idea how to handle linking PIC code into a file of a      different format.  It probably can't be done.  */
if|if
condition|(
operator|!
name|dynamic
operator|&&
name|is_elf_hash_table
argument_list|(
name|htab
argument_list|)
operator|&&
name|bed
operator|->
name|check_relocs
operator|!=
name|NULL
operator|&&
call|(
modifier|*
name|bed
operator|->
name|relocs_compatible
call|)
argument_list|(
name|abfd
operator|->
name|xvec
argument_list|,
name|htab
operator|->
name|root
operator|.
name|creator
argument_list|)
condition|)
block|{
name|asection
modifier|*
name|o
decl_stmt|;
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|;
name|bfd_boolean
name|ok
decl_stmt|;
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
operator|||
name|o
operator|->
name|reloc_count
operator|==
literal|0
operator|||
operator|(
operator|(
name|info
operator|->
name|strip
operator|==
name|strip_all
operator|||
name|info
operator|->
name|strip
operator|==
name|strip_debugger
operator|)
operator|&&
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_DEBUGGING
operator|)
operator|!=
literal|0
operator|)
operator|||
name|bfd_is_abs_section
argument_list|(
name|o
operator|->
name|output_section
argument_list|)
condition|)
continue|continue;
name|internal_relocs
operator|=
name|_bfd_elf_link_read_relocs
argument_list|(
name|abfd
argument_list|,
name|o
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|ok
operator|=
call|(
modifier|*
name|bed
operator|->
name|check_relocs
call|)
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|o
argument_list|,
name|internal_relocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|relocs
operator|!=
name|internal_relocs
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
goto|goto
name|error_return
goto|;
block|}
block|}
comment|/* If this is a non-traditional link, try to optimize the handling      of the .stab/.stabstr sections.  */
if|if
condition|(
operator|!
name|dynamic
operator|&&
operator|!
name|info
operator|->
name|traditional_format
operator|&&
name|is_elf_hash_table
argument_list|(
name|htab
argument_list|)
operator|&&
operator|(
name|info
operator|->
name|strip
operator|!=
name|strip_all
operator|&&
name|info
operator|->
name|strip
operator|!=
name|strip_debugger
operator|)
condition|)
block|{
name|asection
modifier|*
name|stabstr
decl_stmt|;
name|stabstr
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".stabstr"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stabstr
operator|!=
name|NULL
condition|)
block|{
name|bfd_size_type
name|string_offset
init|=
literal|0
decl_stmt|;
name|asection
modifier|*
name|stab
decl_stmt|;
for|for
control|(
name|stab
operator|=
name|abfd
operator|->
name|sections
init|;
name|stab
condition|;
name|stab
operator|=
name|stab
operator|->
name|next
control|)
if|if
condition|(
name|CONST_STRNEQ
argument_list|(
name|stab
operator|->
name|name
argument_list|,
literal|".stab"
argument_list|)
operator|&&
operator|(
operator|!
name|stab
operator|->
name|name
index|[
literal|5
index|]
operator|||
operator|(
name|stab
operator|->
name|name
index|[
literal|5
index|]
operator|==
literal|'.'
operator|&&
name|ISDIGIT
argument_list|(
name|stab
operator|->
name|name
index|[
literal|6
index|]
argument_list|)
operator|)
operator|)
operator|&&
operator|(
name|stab
operator|->
name|flags
operator|&
name|SEC_MERGE
operator|)
operator|==
literal|0
operator|&&
operator|!
name|bfd_is_abs_section
argument_list|(
name|stab
operator|->
name|output_section
argument_list|)
condition|)
block|{
name|struct
name|bfd_elf_section_data
modifier|*
name|secdata
decl_stmt|;
name|secdata
operator|=
name|elf_section_data
argument_list|(
name|stab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|_bfd_link_section_stabs
argument_list|(
name|abfd
argument_list|,
operator|&
name|htab
operator|->
name|stab_info
argument_list|,
name|stab
argument_list|,
name|stabstr
argument_list|,
operator|&
name|secdata
operator|->
name|sec_info
argument_list|,
operator|&
name|string_offset
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|secdata
operator|->
name|sec_info
condition|)
name|stab
operator|->
name|sec_info_type
operator|=
name|ELF_INFO_TYPE_STABS
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|is_elf_hash_table
argument_list|(
name|htab
argument_list|)
operator|&&
name|add_needed
condition|)
block|{
comment|/* Add this bfd to the loaded list.  */
name|struct
name|elf_link_loaded_list
modifier|*
name|n
decl_stmt|;
name|n
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|elf_link_loaded_list
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|n
operator|->
name|abfd
operator|=
name|abfd
expr_stmt|;
name|n
operator|->
name|next
operator|=
name|htab
operator|->
name|loaded
expr_stmt|;
name|htab
operator|->
name|loaded
operator|=
name|n
expr_stmt|;
block|}
return|return
name|TRUE
return|;
name|error_free_vers
label|:
if|if
condition|(
name|old_tab
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|old_tab
argument_list|)
expr_stmt|;
if|if
condition|(
name|nondeflt_vers
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|nondeflt_vers
argument_list|)
expr_stmt|;
if|if
condition|(
name|extversym
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|extversym
argument_list|)
expr_stmt|;
name|error_free_sym
label|:
if|if
condition|(
name|isymbuf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|isymbuf
argument_list|)
expr_stmt|;
name|error_return
label|:
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Return the linker hash table entry of a symbol that might be    satisfied by an archive symbol.  Return -1 on error.  */
end_comment

begin_function
name|struct
name|elf_link_hash_entry
modifier|*
name|_bfd_elf_archive_symbol_lookup
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|copy
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|first
decl_stmt|;
name|h
operator|=
name|elf_link_hash_lookup
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
return|return
name|h
return|;
comment|/* If this is a default version (the name contains @@), look up the      symbol again with only one `@' as well as without the version.      The effect is that references to the symbol with and without the      version will be matched by the default symbol in the archive.  */
name|p
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
name|ELF_VER_CHR
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|p
index|[
literal|1
index|]
operator|!=
name|ELF_VER_CHR
condition|)
return|return
name|h
return|;
comment|/* First check with only one `@'.  */
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|copy
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|copy
operator|==
name|NULL
condition|)
return|return
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
literal|0
operator|-
literal|1
return|;
name|first
operator|=
name|p
operator|-
name|name
operator|+
literal|1
expr_stmt|;
name|memcpy
argument_list|(
name|copy
argument_list|,
name|name
argument_list|,
name|first
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|copy
operator|+
name|first
argument_list|,
name|name
operator|+
name|first
operator|+
literal|1
argument_list|,
name|len
operator|-
name|first
argument_list|)
expr_stmt|;
name|h
operator|=
name|elf_link_hash_lookup
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|copy
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
block|{
comment|/* We also need to check references to the symbol without the 	 version.  */
name|copy
index|[
name|first
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|h
operator|=
name|elf_link_hash_lookup
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|copy
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|copy
argument_list|)
expr_stmt|;
return|return
name|h
return|;
block|}
end_function

begin_comment
comment|/* Add symbols from an ELF archive file to the linker hash table.  We    don't use _bfd_generic_link_add_archive_symbols because of a    problem which arises on UnixWare.  The UnixWare libc.so is an    archive which includes an entry libc.so.1 which defines a bunch of    symbols.  The libc.so archive also includes a number of other    object files, which also define symbols, some of which are the same    as those defined in libc.so.1.  Correct linking requires that we    consider each object file in turn, and include it if it defines any    symbols we need.  _bfd_generic_link_add_archive_symbols does not do    this; it looks through the list of undefined symbols, and includes    any object file which defines them.  When this algorithm is used on    UnixWare, it winds up pulling in libc.so.1 early and defining a    bunch of symbols.  This means that some of the other objects in the    archive are not included in the link, which is incorrect since they    precede libc.so.1 in the archive.     Fortunately, ELF archive handling is simpler than that done by    _bfd_generic_link_add_archive_symbols, which has to allow for a.out    oddities.  In ELF, if we find a symbol in the archive map, and the    symbol is currently undefined, we know that we must pull in that    object file.     Unfortunately, we do have to make multiple passes over the symbol    table until nothing further is resolved.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_link_add_archive_symbols
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|symindex
name|c
decl_stmt|;
name|bfd_boolean
modifier|*
name|defined
init|=
name|NULL
decl_stmt|;
name|bfd_boolean
modifier|*
name|included
init|=
name|NULL
decl_stmt|;
name|carsym
modifier|*
name|symdefs
decl_stmt|;
name|bfd_boolean
name|loop
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
argument_list|(
operator|*
name|archive_symbol_lookup
argument_list|)
argument_list|(
name|bfd
operator|*
argument_list|,
expr|struct
name|bfd_link_info
operator|*
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|bfd_has_map
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
comment|/* An empty archive is a special case.  */
if|if
condition|(
name|bfd_openr_next_archived_file
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
name|bfd_set_error
argument_list|(
name|bfd_error_no_armap
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Keep track of all symbols we know to be already defined, and all      files we know to be already included.  This is to speed up the      second and subsequent passes.  */
name|c
operator|=
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symdef_count
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
name|amt
operator|=
name|c
expr_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
name|bfd_boolean
argument_list|)
expr_stmt|;
name|defined
operator|=
name|bfd_zmalloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
name|included
operator|=
name|bfd_zmalloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|defined
operator|==
name|NULL
operator|||
name|included
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|symdefs
operator|=
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symdefs
expr_stmt|;
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|archive_symbol_lookup
operator|=
name|bed
operator|->
name|elf_backend_archive_symbol_lookup
expr_stmt|;
do|do
block|{
name|file_ptr
name|last
decl_stmt|;
name|symindex
name|i
decl_stmt|;
name|carsym
modifier|*
name|symdef
decl_stmt|;
name|carsym
modifier|*
name|symdefend
decl_stmt|;
name|loop
operator|=
name|FALSE
expr_stmt|;
name|last
operator|=
operator|-
literal|1
expr_stmt|;
name|symdef
operator|=
name|symdefs
expr_stmt|;
name|symdefend
operator|=
name|symdef
operator|+
name|c
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|symdef
operator|<
name|symdefend
condition|;
name|symdef
operator|++
operator|,
name|i
operator|++
control|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|bfd
modifier|*
name|element
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|undefs_tail
decl_stmt|;
name|symindex
name|mark
decl_stmt|;
if|if
condition|(
name|defined
index|[
name|i
index|]
operator|||
name|included
index|[
name|i
index|]
condition|)
continue|continue;
if|if
condition|(
name|symdef
operator|->
name|file_offset
operator|==
name|last
condition|)
block|{
name|included
index|[
name|i
index|]
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
name|h
operator|=
name|archive_symbol_lookup
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|symdef
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
literal|0
operator|-
literal|1
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_common
condition|)
block|{
comment|/* We currently have a common symbol.  The archive map contains 		 a reference to this symbol, so we may want to include it.  We 		 only want to include it however, if this archive element 		 contains a definition of the symbol, not just another common 		 declaration of it.  		 Unfortunately some archivers (including GNU ar) will put 		 declarations of common symbols into their archive maps, as 		 well as real definitions, so we cannot just go by the archive 		 map alone.  Instead we must read in the element's symbol 		 table and check that to see what kind of symbol definition 		 this is.  */
if|if
condition|(
operator|!
name|elf_link_is_defined_archive_symbol
argument_list|(
name|abfd
argument_list|,
name|symdef
argument_list|)
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefined
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefweak
condition|)
name|defined
index|[
name|i
index|]
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
comment|/* We need to include this archive member.  */
name|element
operator|=
name|_bfd_get_elt_at_filepos
argument_list|(
name|abfd
argument_list|,
name|symdef
operator|->
name|file_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|element
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|bfd_check_format
argument_list|(
name|element
argument_list|,
name|bfd_object
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* Doublecheck that we have not included this object 	     already--it should be impossible, but there may be 	     something wrong with the archive.  */
if|if
condition|(
name|element
operator|->
name|archive_pass
operator|!=
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|element
operator|->
name|archive_pass
operator|=
literal|1
expr_stmt|;
name|undefs_tail
operator|=
name|info
operator|->
name|hash
operator|->
name|undefs_tail
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|add_archive_element
call|)
argument_list|(
name|info
argument_list|,
name|element
argument_list|,
name|symdef
operator|->
name|name
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|bfd_link_add_symbols
argument_list|(
name|element
argument_list|,
name|info
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* If there are any new undefined symbols, we need to make 	     another pass through the archive in order to see whether 	     they can be defined.  FIXME: This isn't perfect, because 	     common symbols wind up on undefs_tail and because an 	     undefined symbol which is defined later on in this pass 	     does not require another pass.  This isn't a bug, but it 	     does make the code less efficient than it could be.  */
if|if
condition|(
name|undefs_tail
operator|!=
name|info
operator|->
name|hash
operator|->
name|undefs_tail
condition|)
name|loop
operator|=
name|TRUE
expr_stmt|;
comment|/* Look backward to mark all symbols from this object file 	     which we have already seen in this pass.  */
name|mark
operator|=
name|i
expr_stmt|;
do|do
block|{
name|included
index|[
name|mark
index|]
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|mark
operator|==
literal|0
condition|)
break|break;
operator|--
name|mark
expr_stmt|;
block|}
do|while
condition|(
name|symdefs
index|[
name|mark
index|]
operator|.
name|file_offset
operator|==
name|symdef
operator|->
name|file_offset
condition|)
do|;
comment|/* We mark subsequent symbols from this object file as we go 	     on through the loop.  */
name|last
operator|=
name|symdef
operator|->
name|file_offset
expr_stmt|;
block|}
block|}
do|while
condition|(
name|loop
condition|)
do|;
name|free
argument_list|(
name|defined
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|included
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
name|error_return
label|:
if|if
condition|(
name|defined
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|defined
argument_list|)
expr_stmt|;
if|if
condition|(
name|included
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|included
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Given an ELF BFD, add symbols to the global hash table as    appropriate.  */
end_comment

begin_function
name|bfd_boolean
name|bfd_elf_link_add_symbols
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
switch|switch
condition|(
name|bfd_get_format
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
case|case
name|bfd_object
case|:
return|return
name|elf_link_add_object_symbols
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
return|;
case|case
name|bfd_archive
case|:
return|return
name|elf_link_add_archive_symbols
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
return|;
default|default:
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This function will be called though elf_link_hash_traverse to store    all hash value of the exported symbols in an array.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_collect_hash_codes
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|unsigned
name|long
modifier|*
modifier|*
name|valuep
init|=
name|data
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|long
name|ha
decl_stmt|;
name|char
modifier|*
name|alc
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
comment|/* Ignore indirect symbols.  These are added by the versioning code.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
return|return
name|TRUE
return|;
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
name|ELF_VER_CHR
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|alc
operator|=
name|bfd_malloc
argument_list|(
name|p
operator|-
name|name
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|alc
argument_list|,
name|name
argument_list|,
name|p
operator|-
name|name
argument_list|)
expr_stmt|;
name|alc
index|[
name|p
operator|-
name|name
index|]
operator|=
literal|'\0'
expr_stmt|;
name|name
operator|=
name|alc
expr_stmt|;
block|}
comment|/* Compute the hash value.  */
name|ha
operator|=
name|bfd_elf_hash
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* Store the found hash value in the array given as the argument.  */
operator|*
operator|(
operator|*
name|valuep
operator|)
operator|++
operator|=
name|ha
expr_stmt|;
comment|/* And store it in the struct so that we can put it in the hash table      later.  */
name|h
operator|->
name|u
operator|.
name|elf_hash_value
operator|=
name|ha
expr_stmt|;
if|if
condition|(
name|alc
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|alc
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_struct
struct|struct
name|collect_gnu_hash_codes
block|{
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
name|unsigned
name|long
name|int
name|nsyms
decl_stmt|;
name|unsigned
name|long
name|int
name|maskbits
decl_stmt|;
name|unsigned
name|long
name|int
modifier|*
name|hashcodes
decl_stmt|;
name|unsigned
name|long
name|int
modifier|*
name|hashval
decl_stmt|;
name|unsigned
name|long
name|int
modifier|*
name|indx
decl_stmt|;
name|unsigned
name|long
name|int
modifier|*
name|counts
decl_stmt|;
name|bfd_vma
modifier|*
name|bitmask
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|long
name|int
name|min_dynindx
decl_stmt|;
name|unsigned
name|long
name|int
name|bucketcount
decl_stmt|;
name|unsigned
name|long
name|int
name|symindx
decl_stmt|;
name|long
name|int
name|local_indx
decl_stmt|;
name|long
name|int
name|shift1
decl_stmt|,
name|shift2
decl_stmt|;
name|unsigned
name|long
name|int
name|mask
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This function will be called though elf_link_hash_traverse to store    all hash value of the exported symbols in an array.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_collect_gnu_hash_codes
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|collect_gnu_hash_codes
modifier|*
name|s
init|=
name|data
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|long
name|ha
decl_stmt|;
name|char
modifier|*
name|alc
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
comment|/* Ignore indirect symbols.  These are added by the versioning code.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
return|return
name|TRUE
return|;
comment|/* Ignore also local symbols and undefined symbols.  */
if|if
condition|(
operator|!
call|(
modifier|*
name|s
operator|->
name|bed
operator|->
name|elf_hash_symbol
call|)
argument_list|(
name|h
argument_list|)
condition|)
return|return
name|TRUE
return|;
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
name|ELF_VER_CHR
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|alc
operator|=
name|bfd_malloc
argument_list|(
name|p
operator|-
name|name
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|alc
argument_list|,
name|name
argument_list|,
name|p
operator|-
name|name
argument_list|)
expr_stmt|;
name|alc
index|[
name|p
operator|-
name|name
index|]
operator|=
literal|'\0'
expr_stmt|;
name|name
operator|=
name|alc
expr_stmt|;
block|}
comment|/* Compute the hash value.  */
name|ha
operator|=
name|bfd_elf_gnu_hash
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* Store the found hash value in the array for compute_bucket_count,      and also for .dynsym reordering purposes.  */
name|s
operator|->
name|hashcodes
index|[
name|s
operator|->
name|nsyms
index|]
operator|=
name|ha
expr_stmt|;
name|s
operator|->
name|hashval
index|[
name|h
operator|->
name|dynindx
index|]
operator|=
name|ha
expr_stmt|;
operator|++
name|s
operator|->
name|nsyms
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|min_dynindx
operator|<
literal|0
operator|||
name|s
operator|->
name|min_dynindx
operator|>
name|h
operator|->
name|dynindx
condition|)
name|s
operator|->
name|min_dynindx
operator|=
name|h
operator|->
name|dynindx
expr_stmt|;
if|if
condition|(
name|alc
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|alc
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* This function will be called though elf_link_hash_traverse to do    final dynaminc symbol renumbering.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_renumber_gnu_hash_syms
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|collect_gnu_hash_codes
modifier|*
name|s
init|=
name|data
decl_stmt|;
name|unsigned
name|long
name|int
name|bucket
decl_stmt|;
name|unsigned
name|long
name|int
name|val
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
comment|/* Ignore indirect symbols.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
return|return
name|TRUE
return|;
comment|/* Ignore also local symbols and undefined symbols.  */
if|if
condition|(
operator|!
call|(
modifier|*
name|s
operator|->
name|bed
operator|->
name|elf_hash_symbol
call|)
argument_list|(
name|h
argument_list|)
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|dynindx
operator|>=
name|s
operator|->
name|min_dynindx
condition|)
name|h
operator|->
name|dynindx
operator|=
name|s
operator|->
name|local_indx
operator|++
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|bucket
operator|=
name|s
operator|->
name|hashval
index|[
name|h
operator|->
name|dynindx
index|]
operator|%
name|s
operator|->
name|bucketcount
expr_stmt|;
name|val
operator|=
operator|(
name|s
operator|->
name|hashval
index|[
name|h
operator|->
name|dynindx
index|]
operator|>>
name|s
operator|->
name|shift1
operator|)
operator|&
operator|(
operator|(
name|s
operator|->
name|maskbits
operator|>>
name|s
operator|->
name|shift1
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|s
operator|->
name|bitmask
index|[
name|val
index|]
operator||=
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|)
operator|<<
operator|(
name|s
operator|->
name|hashval
index|[
name|h
operator|->
name|dynindx
index|]
operator|&
name|s
operator|->
name|mask
operator|)
expr_stmt|;
name|s
operator|->
name|bitmask
index|[
name|val
index|]
operator||=
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|)
operator|<<
operator|(
operator|(
name|s
operator|->
name|hashval
index|[
name|h
operator|->
name|dynindx
index|]
operator|>>
name|s
operator|->
name|shift2
operator|)
operator|&
name|s
operator|->
name|mask
operator|)
expr_stmt|;
name|val
operator|=
name|s
operator|->
name|hashval
index|[
name|h
operator|->
name|dynindx
index|]
operator|&
operator|~
operator|(
name|unsigned
name|long
name|int
operator|)
literal|1
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|counts
index|[
name|bucket
index|]
operator|==
literal|1
condition|)
comment|/* Last element terminates the chain.  */
name|val
operator||=
literal|1
expr_stmt|;
name|bfd_put_32
argument_list|(
name|s
operator|->
name|output_bfd
argument_list|,
name|val
argument_list|,
name|s
operator|->
name|contents
operator|+
operator|(
name|s
operator|->
name|indx
index|[
name|bucket
index|]
operator|-
name|s
operator|->
name|symindx
operator|)
operator|*
literal|4
argument_list|)
expr_stmt|;
operator|--
name|s
operator|->
name|counts
index|[
name|bucket
index|]
expr_stmt|;
name|h
operator|->
name|dynindx
operator|=
name|s
operator|->
name|indx
index|[
name|bucket
index|]
operator|++
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if symbol should be hashed in the `.gnu.hash' section.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_elf_hash_symbol
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|)
block|{
return|return
operator|!
operator|(
name|h
operator|->
name|forced_local
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|||
operator|(
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|==
name|NULL
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Array used to determine the number of hash table buckets to use    based on the number of symbols there are.  If there are fewer than    3 symbols we use 1 bucket, fewer than 17 symbols we use 3 buckets,    fewer than 37 we use 17 buckets, and so forth.  We never use more    than 32771 buckets.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|size_t
name|elf_buckets
index|[]
init|=
block|{
literal|1
block|,
literal|3
block|,
literal|17
block|,
literal|37
block|,
literal|67
block|,
literal|97
block|,
literal|131
block|,
literal|197
block|,
literal|263
block|,
literal|521
block|,
literal|1031
block|,
literal|2053
block|,
literal|4099
block|,
literal|8209
block|,
literal|16411
block|,
literal|32771
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Compute bucket count for hashing table.  We do not use a static set    of possible tables sizes anymore.  Instead we determine for all    possible reasonable sizes of the table the outcome (i.e., the    number of collisions etc) and choose the best solution.  The    weighting functions are not too simple to allow the table to grow    without bounds.  Instead one of the weighting factors is the size.    Therefore the result is always a good payoff between few collisions    (= short chain lengths) and table size.  */
end_comment

begin_function
specifier|static
name|size_t
name|compute_bucket_count
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|unsigned
name|long
name|int
modifier|*
name|hashcodes
parameter_list|,
name|unsigned
name|long
name|int
name|nsyms
parameter_list|,
name|int
name|gnu_hash
parameter_list|)
block|{
name|size_t
name|dynsymcount
init|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynsymcount
decl_stmt|;
name|size_t
name|best_size
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|int
name|i
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
comment|/* We have a problem here.  The following code to optimize the table      size requires an integer type with more the 32 bits.  If      BFD_HOST_U_64_BIT is set we know about such a type.  */
ifdef|#
directive|ifdef
name|BFD_HOST_U_64_BIT
if|if
condition|(
name|info
operator|->
name|optimize
condition|)
block|{
name|size_t
name|minsize
decl_stmt|;
name|size_t
name|maxsize
decl_stmt|;
name|BFD_HOST_U_64_BIT
name|best_chlen
init|=
operator|~
operator|(
operator|(
name|BFD_HOST_U_64_BIT
operator|)
literal|0
operator|)
decl_stmt|;
name|bfd
modifier|*
name|dynobj
init|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|dynobj
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|int
modifier|*
name|counts
decl_stmt|;
comment|/* Possible optimization parameters: if we have NSYMS symbols we say 	 that the hashing table must at least have NSYMS/4 and at most 	 2*NSYMS buckets.  */
name|minsize
operator|=
name|nsyms
operator|/
literal|4
expr_stmt|;
if|if
condition|(
name|minsize
operator|==
literal|0
condition|)
name|minsize
operator|=
literal|1
expr_stmt|;
name|best_size
operator|=
name|maxsize
operator|=
name|nsyms
operator|*
literal|2
expr_stmt|;
if|if
condition|(
name|gnu_hash
condition|)
block|{
if|if
condition|(
name|minsize
operator|<
literal|2
condition|)
name|minsize
operator|=
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|best_size
operator|&
literal|31
operator|)
operator|==
literal|0
condition|)
operator|++
name|best_size
expr_stmt|;
block|}
comment|/* Create array where we count the collisions in.  We must use bfd_malloc 	 since the size could be large.  */
name|amt
operator|=
name|maxsize
expr_stmt|;
name|amt
operator|*=
expr|sizeof
operator|(
name|unsigned
name|long
name|int
operator|)
expr_stmt|;
name|counts
operator|=
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|counts
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* Compute the "optimal" size for the hash table.  The criteria is a 	 minimal chain length.  The minor criteria is (of course) the size 	 of the table.  */
for|for
control|(
name|i
operator|=
name|minsize
init|;
name|i
operator|<
name|maxsize
condition|;
operator|++
name|i
control|)
block|{
comment|/* Walk through the array of hashcodes and count the collisions.  */
name|BFD_HOST_U_64_BIT
name|max
decl_stmt|;
name|unsigned
name|long
name|int
name|j
decl_stmt|;
name|unsigned
name|long
name|int
name|fact
decl_stmt|;
if|if
condition|(
name|gnu_hash
operator|&&
operator|(
name|i
operator|&
literal|31
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|memset
argument_list|(
name|counts
argument_list|,
literal|'\0'
argument_list|,
name|i
operator|*
expr|sizeof
operator|(
name|unsigned
name|long
name|int
operator|)
argument_list|)
expr_stmt|;
comment|/* Determine how often each hash bucket is used.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nsyms
condition|;
operator|++
name|j
control|)
operator|++
name|counts
index|[
name|hashcodes
index|[
name|j
index|]
operator|%
name|i
index|]
expr_stmt|;
comment|/* For the weight function we need some information about the 	     pagesize on the target.  This is information need not be 100% 	     accurate.  Since this information is not available (so far) we 	     define it here to a reasonable default value.  If it is crucial 	     to have a better value some day simply define this value.  */
ifndef|#
directive|ifndef
name|BFD_TARGET_PAGESIZE
define|#
directive|define
name|BFD_TARGET_PAGESIZE
value|(4096)
endif|#
directive|endif
comment|/* We in any case need 2 + DYNSYMCOUNT entries for the size values 	     and the chains.  */
name|max
operator|=
operator|(
literal|2
operator|+
name|dynsymcount
operator|)
operator|*
name|bed
operator|->
name|s
operator|->
name|sizeof_hash_entry
expr_stmt|;
if|#
directive|if
literal|1
comment|/* Variant 1: optimize for short chains.  We add the squares 	     of all the chain lengths (which favors many small chain 	     over a few long chains).  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
operator|++
name|j
control|)
name|max
operator|+=
name|counts
index|[
name|j
index|]
operator|*
name|counts
index|[
name|j
index|]
expr_stmt|;
comment|/* This adds penalties for the overall size of the table.  */
name|fact
operator|=
name|i
operator|/
operator|(
name|BFD_TARGET_PAGESIZE
operator|/
name|bed
operator|->
name|s
operator|->
name|sizeof_hash_entry
operator|)
operator|+
literal|1
expr_stmt|;
name|max
operator|*=
name|fact
operator|*
name|fact
expr_stmt|;
else|#
directive|else
comment|/* Variant 2: Optimize a lot more for small table.  Here we 	     also add squares of the size but we also add penalties for 	     empty slots (the +1 term).  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
operator|++
name|j
control|)
name|max
operator|+=
operator|(
literal|1
operator|+
name|counts
index|[
name|j
index|]
operator|)
operator|*
operator|(
literal|1
operator|+
name|counts
index|[
name|j
index|]
operator|)
expr_stmt|;
comment|/* The overall size of the table is considered, but not as 	     strong as in variant 1, where it is squared.  */
name|fact
operator|=
name|i
operator|/
operator|(
name|BFD_TARGET_PAGESIZE
operator|/
name|bed
operator|->
name|s
operator|->
name|sizeof_hash_entry
operator|)
operator|+
literal|1
expr_stmt|;
name|max
operator|*=
name|fact
expr_stmt|;
endif|#
directive|endif
comment|/* Compare with current best results.  */
if|if
condition|(
name|max
operator|<
name|best_chlen
condition|)
block|{
name|best_chlen
operator|=
name|max
expr_stmt|;
name|best_size
operator|=
name|i
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|counts
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* defined (BFD_HOST_U_64_BIT) */
block|{
comment|/* This is the fallback solution if no 64bit type is available or if we 	 are not supposed to spend much time on optimizations.  We select the 	 bucket count using a fixed set of numbers.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|elf_buckets
index|[
name|i
index|]
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|best_size
operator|=
name|elf_buckets
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|nsyms
operator|<
name|elf_buckets
index|[
name|i
operator|+
literal|1
index|]
condition|)
break|break;
block|}
if|if
condition|(
name|gnu_hash
operator|&&
name|best_size
operator|<
literal|2
condition|)
name|best_size
operator|=
literal|2
expr_stmt|;
block|}
return|return
name|best_size
return|;
block|}
end_function

begin_comment
comment|/* Set up the sizes and contents of the ELF dynamic sections.  This is    called by the ELF linker emulation before_allocation routine.  We    must set the sizes of the sections before the linker sets the    addresses of the various sections.  */
end_comment

begin_function
name|bfd_boolean
name|bfd_elf_size_dynamic_sections
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
specifier|const
name|char
modifier|*
name|soname
parameter_list|,
specifier|const
name|char
modifier|*
name|rpath
parameter_list|,
specifier|const
name|char
modifier|*
name|filter_shlib
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|auxiliary_filters
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|asection
modifier|*
modifier|*
name|sinterpptr
parameter_list|,
name|struct
name|bfd_elf_version_tree
modifier|*
name|verdefs
parameter_list|)
block|{
name|bfd_size_type
name|soname_indx
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
name|struct
name|elf_assign_sym_version_info
name|asvinfo
decl_stmt|;
operator|*
name|sinterpptr
operator|=
name|NULL
expr_stmt|;
name|soname_indx
operator|=
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|is_elf_hash_table
argument_list|(
name|info
operator|->
name|hash
argument_list|)
condition|)
return|return
name|TRUE
return|;
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
name|elf_tdata
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|relro
operator|=
name|info
operator|->
name|relro
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|execstack
condition|)
name|elf_tdata
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|stack_flags
operator|=
name|PF_R
operator||
name|PF_W
operator||
name|PF_X
expr_stmt|;
elseif|else
if|if
condition|(
name|info
operator|->
name|noexecstack
condition|)
name|elf_tdata
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|stack_flags
operator|=
name|PF_R
operator||
name|PF_W
expr_stmt|;
else|else
block|{
name|bfd
modifier|*
name|inputobj
decl_stmt|;
name|asection
modifier|*
name|notesec
init|=
name|NULL
decl_stmt|;
name|int
name|exec
init|=
literal|0
decl_stmt|;
for|for
control|(
name|inputobj
operator|=
name|info
operator|->
name|input_bfds
init|;
name|inputobj
condition|;
name|inputobj
operator|=
name|inputobj
operator|->
name|link_next
control|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|inputobj
operator|->
name|flags
operator|&
operator|(
name|DYNAMIC
operator||
name|BFD_LINKER_CREATED
operator|)
condition|)
continue|continue;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|inputobj
argument_list|,
literal|".note.GNU-stack"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|flags
operator|&
name|SEC_CODE
condition|)
name|exec
operator|=
name|PF_X
expr_stmt|;
name|notesec
operator|=
name|s
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bed
operator|->
name|default_execstack
condition|)
name|exec
operator|=
name|PF_X
expr_stmt|;
block|}
if|if
condition|(
name|notesec
condition|)
block|{
name|elf_tdata
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|stack_flags
operator|=
name|PF_R
operator||
name|PF_W
operator||
name|exec
expr_stmt|;
if|if
condition|(
name|exec
operator|&&
name|info
operator|->
name|relocatable
operator|&&
name|notesec
operator|->
name|output_section
operator|!=
name|bfd_abs_section_ptr
condition|)
name|notesec
operator|->
name|output_section
operator|->
name|flags
operator||=
name|SEC_CODE
expr_stmt|;
block|}
block|}
comment|/* Any syms created from now on start with -1 in      got.refcount/offset and plt.refcount/offset.  */
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|init_got_refcount
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|init_got_offset
expr_stmt|;
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|init_plt_refcount
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|init_plt_offset
expr_stmt|;
comment|/* The backend may have to create some sections regardless of whether      we're dynamic or not.  */
if|if
condition|(
name|bed
operator|->
name|elf_backend_always_size_sections
operator|&&
operator|!
call|(
modifier|*
name|bed
operator|->
name|elf_backend_always_size_sections
call|)
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|_bfd_elf_maybe_strip_eh_frame_hdr
argument_list|(
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
comment|/* If there were no dynamic objects in the link, there is nothing to      do here.  */
if|if
condition|(
name|dynobj
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
name|struct
name|elf_info_failed
name|eif
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|asection
modifier|*
name|dynstr
decl_stmt|;
name|struct
name|bfd_elf_version_tree
modifier|*
name|t
decl_stmt|;
name|struct
name|bfd_elf_version_expr
modifier|*
name|d
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_boolean
name|all_defined
decl_stmt|;
operator|*
name|sinterpptr
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".interp"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
operator|*
name|sinterpptr
operator|!=
name|NULL
operator|||
operator|!
name|info
operator|->
name|executable
argument_list|)
expr_stmt|;
if|if
condition|(
name|soname
operator|!=
name|NULL
condition|)
block|{
name|soname_indx
operator|=
name|_bfd_elf_strtab_add
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
argument_list|,
name|soname
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|soname_indx
operator|==
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
operator|||
operator|!
name|_bfd_elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_SONAME
argument_list|,
name|soname_indx
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|info
operator|->
name|symbolic
condition|)
block|{
if|if
condition|(
operator|!
name|_bfd_elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_SYMBOLIC
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|info
operator|->
name|flags
operator||=
name|DF_SYMBOLIC
expr_stmt|;
block|}
if|if
condition|(
name|rpath
operator|!=
name|NULL
condition|)
block|{
name|bfd_size_type
name|indx
decl_stmt|;
name|indx
operator|=
name|_bfd_elf_strtab_add
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
argument_list|,
name|rpath
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|indx
operator|==
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
operator|||
operator|!
name|_bfd_elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_RPATH
argument_list|,
name|indx
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|info
operator|->
name|new_dtags
condition|)
block|{
name|_bfd_elf_strtab_addref
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
argument_list|,
name|indx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|_bfd_elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_RUNPATH
argument_list|,
name|indx
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
if|if
condition|(
name|filter_shlib
operator|!=
name|NULL
condition|)
block|{
name|bfd_size_type
name|indx
decl_stmt|;
name|indx
operator|=
name|_bfd_elf_strtab_add
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
argument_list|,
name|filter_shlib
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|indx
operator|==
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
operator|||
operator|!
name|_bfd_elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_FILTER
argument_list|,
name|indx
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|auxiliary_filters
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|auxiliary_filters
init|;
operator|*
name|p
operator|!=
name|NULL
condition|;
name|p
operator|++
control|)
block|{
name|bfd_size_type
name|indx
decl_stmt|;
name|indx
operator|=
name|_bfd_elf_strtab_add
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
argument_list|,
operator|*
name|p
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|indx
operator|==
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
operator|||
operator|!
name|_bfd_elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_AUXILIARY
argument_list|,
name|indx
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
name|eif
operator|.
name|info
operator|=
name|info
expr_stmt|;
name|eif
operator|.
name|verdefs
operator|=
name|verdefs
expr_stmt|;
name|eif
operator|.
name|failed
operator|=
name|FALSE
expr_stmt|;
comment|/* If we are supposed to export all symbols into the dynamic symbol 	 table (this is not the normal case), then do so.  */
if|if
condition|(
name|info
operator|->
name|export_dynamic
operator|||
operator|(
name|info
operator|->
name|executable
operator|&&
name|info
operator|->
name|dynamic
operator|)
condition|)
block|{
name|elf_link_hash_traverse
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|_bfd_elf_export_symbol
argument_list|,
operator|&
name|eif
argument_list|)
expr_stmt|;
if|if
condition|(
name|eif
operator|.
name|failed
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Make all global versions with definition.  */
for|for
control|(
name|t
operator|=
name|verdefs
init|;
name|t
operator|!=
name|NULL
condition|;
name|t
operator|=
name|t
operator|->
name|next
control|)
for|for
control|(
name|d
operator|=
name|t
operator|->
name|globals
operator|.
name|list
init|;
name|d
operator|!=
name|NULL
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|d
operator|->
name|symver
operator|&&
name|d
operator|->
name|symbol
condition|)
block|{
specifier|const
name|char
modifier|*
name|verstr
decl_stmt|,
modifier|*
name|name
decl_stmt|;
name|size_t
name|namelen
decl_stmt|,
name|verlen
decl_stmt|,
name|newlen
decl_stmt|;
name|char
modifier|*
name|newname
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|newh
decl_stmt|;
name|name
operator|=
name|d
operator|->
name|symbol
expr_stmt|;
name|namelen
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|verstr
operator|=
name|t
operator|->
name|name
expr_stmt|;
name|verlen
operator|=
name|strlen
argument_list|(
name|verstr
argument_list|)
expr_stmt|;
name|newlen
operator|=
name|namelen
operator|+
name|verlen
operator|+
literal|3
expr_stmt|;
name|newname
operator|=
name|bfd_malloc
argument_list|(
name|newlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|newname
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|memcpy
argument_list|(
name|newname
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
comment|/* Check the hidden versioned definition.  */
name|p
operator|=
name|newname
operator|+
name|namelen
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|ELF_VER_CHR
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|verstr
argument_list|,
name|verlen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|newh
operator|=
name|elf_link_hash_lookup
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|newname
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|newh
operator|==
name|NULL
operator|||
operator|(
name|newh
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defined
operator|&&
name|newh
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
operator|)
condition|)
block|{
comment|/* Check the default versioned definition.  */
operator|*
name|p
operator|++
operator|=
name|ELF_VER_CHR
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|verstr
argument_list|,
name|verlen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|newh
operator|=
name|elf_link_hash_lookup
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|newname
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|newname
argument_list|)
expr_stmt|;
comment|/* Mark this version if there is a definition and it is 		 not defined in a shared object.  */
if|if
condition|(
name|newh
operator|!=
name|NULL
operator|&&
operator|!
name|newh
operator|->
name|def_dynamic
operator|&&
operator|(
name|newh
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|newh
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
condition|)
name|d
operator|->
name|symver
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Attach all the symbols to their version information.  */
name|asvinfo
operator|.
name|output_bfd
operator|=
name|output_bfd
expr_stmt|;
name|asvinfo
operator|.
name|info
operator|=
name|info
expr_stmt|;
name|asvinfo
operator|.
name|verdefs
operator|=
name|verdefs
expr_stmt|;
name|asvinfo
operator|.
name|failed
operator|=
name|FALSE
expr_stmt|;
name|elf_link_hash_traverse
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|_bfd_elf_link_assign_sym_version
argument_list|,
operator|&
name|asvinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|asvinfo
operator|.
name|failed
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|info
operator|->
name|allow_undefined_version
condition|)
block|{
comment|/* Check if all global versions have a definition.  */
name|all_defined
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|t
operator|=
name|verdefs
init|;
name|t
operator|!=
name|NULL
condition|;
name|t
operator|=
name|t
operator|->
name|next
control|)
for|for
control|(
name|d
operator|=
name|t
operator|->
name|globals
operator|.
name|list
init|;
name|d
operator|!=
name|NULL
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|d
operator|->
name|symver
operator|&&
operator|!
name|d
operator|->
name|script
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: undefined version: %s"
argument_list|)
argument_list|,
name|d
operator|->
name|pattern
argument_list|,
name|t
operator|->
name|name
argument_list|)
expr_stmt|;
name|all_defined
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|all_defined
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
comment|/* Find all symbols which were defined in a dynamic object and make 	 the backend pick a reasonable value for them.  */
name|elf_link_hash_traverse
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|_bfd_elf_adjust_dynamic_symbol
argument_list|,
operator|&
name|eif
argument_list|)
expr_stmt|;
if|if
condition|(
name|eif
operator|.
name|failed
condition|)
return|return
name|FALSE
return|;
comment|/* Add some entries to the .dynamic section.  We fill in some of the 	 values later, in bfd_elf_final_link, but we must add the entries 	 now so that we know the final size of the .dynamic section.  */
comment|/* If there are initialization and/or finalization functions to 	 call then add the corresponding DT_INIT/DT_FINI entries.  */
name|h
operator|=
operator|(
name|info
operator|->
name|init_function
condition|?
name|elf_link_hash_lookup
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|info
operator|->
name|init_function
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
else|:
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|ref_regular
operator|||
name|h
operator|->
name|def_regular
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|_bfd_elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_INIT
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
name|h
operator|=
operator|(
name|info
operator|->
name|fini_function
condition|?
name|elf_link_hash_lookup
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|info
operator|->
name|fini_function
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
else|:
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|ref_regular
operator|||
name|h
operator|->
name|def_regular
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|_bfd_elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_FINI
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
literal|".preinit_array"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
name|s
operator|->
name|linker_has_input
condition|)
block|{
comment|/* DT_PREINIT_ARRAY is not allowed in shared library.  */
if|if
condition|(
operator|!
name|info
operator|->
name|executable
condition|)
block|{
name|bfd
modifier|*
name|sub
decl_stmt|;
name|asection
modifier|*
name|o
decl_stmt|;
for|for
control|(
name|sub
operator|=
name|info
operator|->
name|input_bfds
init|;
name|sub
operator|!=
name|NULL
condition|;
name|sub
operator|=
name|sub
operator|->
name|link_next
control|)
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|sub
argument_list|)
operator|==
name|bfd_target_elf_flavour
condition|)
for|for
control|(
name|o
operator|=
name|sub
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
if|if
condition|(
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_type
operator|==
name|SHT_PREINIT_ARRAY
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: .preinit_array section is not allowed in DSO"
argument_list|)
argument_list|,
name|sub
argument_list|)
expr_stmt|;
break|break;
block|}
name|bfd_set_error
argument_list|(
name|bfd_error_nonrepresentable_section
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|_bfd_elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_PREINIT_ARRAY
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|_bfd_elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_PREINIT_ARRAYSZ
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
literal|".init_array"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
name|s
operator|->
name|linker_has_input
condition|)
block|{
if|if
condition|(
operator|!
name|_bfd_elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_INIT_ARRAY
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|_bfd_elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_INIT_ARRAYSZ
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
literal|".fini_array"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
name|s
operator|->
name|linker_has_input
condition|)
block|{
if|if
condition|(
operator|!
name|_bfd_elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_FINI_ARRAY
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|_bfd_elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_FINI_ARRAYSZ
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
name|dynstr
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynstr"
argument_list|)
expr_stmt|;
comment|/* If .dynstr is excluded from the link, we don't want any of 	 these tags.  Strictly, we should be checking each section 	 individually;  This quick check covers for the case where 	 someone does a /DISCARD/ : { *(*) }.  */
if|if
condition|(
name|dynstr
operator|!=
name|NULL
operator|&&
name|dynstr
operator|->
name|output_section
operator|!=
name|bfd_abs_section_ptr
condition|)
block|{
name|bfd_size_type
name|strsize
decl_stmt|;
name|strsize
operator|=
name|_bfd_elf_strtab_size
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|info
operator|->
name|emit_hash
operator|&&
operator|!
name|_bfd_elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_HASH
argument_list|,
literal|0
argument_list|)
operator|)
operator|||
operator|(
name|info
operator|->
name|emit_gnu_hash
operator|&&
operator|!
name|_bfd_elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_GNU_HASH
argument_list|,
literal|0
argument_list|)
operator|)
operator|||
operator|!
name|_bfd_elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_STRTAB
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|_bfd_elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_SYMTAB
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|_bfd_elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_STRSZ
argument_list|,
name|strsize
argument_list|)
operator|||
operator|!
name|_bfd_elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_SYMENT
argument_list|,
name|bed
operator|->
name|s
operator|->
name|sizeof_sym
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
comment|/* The backend must work out the sizes of all the other dynamic      sections.  */
if|if
condition|(
name|bed
operator|->
name|elf_backend_size_dynamic_sections
operator|&&
operator|!
call|(
modifier|*
name|bed
operator|->
name|elf_backend_size_dynamic_sections
call|)
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
name|unsigned
name|long
name|section_sym_count
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
comment|/* Set up the version definition section.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".gnu.version_d"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* We may have created additional version definitions if we are 	 just linking a regular application.  */
name|verdefs
operator|=
name|asvinfo
operator|.
name|verdefs
expr_stmt|;
comment|/* Skip anonymous version tag.  */
if|if
condition|(
name|verdefs
operator|!=
name|NULL
operator|&&
name|verdefs
operator|->
name|vernum
operator|==
literal|0
condition|)
name|verdefs
operator|=
name|verdefs
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|verdefs
operator|==
name|NULL
operator|&&
operator|!
name|info
operator|->
name|create_default_symver
condition|)
name|s
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
else|else
block|{
name|unsigned
name|int
name|cdefs
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
name|struct
name|bfd_elf_version_tree
modifier|*
name|t
decl_stmt|;
name|bfd_byte
modifier|*
name|p
decl_stmt|;
name|Elf_Internal_Verdef
name|def
decl_stmt|;
name|Elf_Internal_Verdaux
name|defaux
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|bh
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|cdefs
operator|=
literal|0
expr_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
comment|/* Make space for the base version.  */
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf_External_Verdef
argument_list|)
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf_External_Verdaux
argument_list|)
expr_stmt|;
operator|++
name|cdefs
expr_stmt|;
comment|/* Make space for the default version.  */
if|if
condition|(
name|info
operator|->
name|create_default_symver
condition|)
block|{
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf_External_Verdef
argument_list|)
expr_stmt|;
operator|++
name|cdefs
expr_stmt|;
block|}
for|for
control|(
name|t
operator|=
name|verdefs
init|;
name|t
operator|!=
name|NULL
condition|;
name|t
operator|=
name|t
operator|->
name|next
control|)
block|{
name|struct
name|bfd_elf_version_deps
modifier|*
name|n
decl_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf_External_Verdef
argument_list|)
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf_External_Verdaux
argument_list|)
expr_stmt|;
operator|++
name|cdefs
expr_stmt|;
for|for
control|(
name|n
operator|=
name|t
operator|->
name|deps
init|;
name|n
operator|!=
name|NULL
condition|;
name|n
operator|=
name|n
operator|->
name|next
control|)
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf_External_Verdaux
argument_list|)
expr_stmt|;
block|}
name|s
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|s
operator|->
name|contents
operator|=
name|bfd_alloc
argument_list|(
name|output_bfd
argument_list|,
name|s
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|contents
operator|==
name|NULL
operator|&&
name|s
operator|->
name|size
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
comment|/* Fill in the version definition section.  */
name|p
operator|=
name|s
operator|->
name|contents
expr_stmt|;
name|def
operator|.
name|vd_version
operator|=
name|VER_DEF_CURRENT
expr_stmt|;
name|def
operator|.
name|vd_flags
operator|=
name|VER_FLG_BASE
expr_stmt|;
name|def
operator|.
name|vd_ndx
operator|=
literal|1
expr_stmt|;
name|def
operator|.
name|vd_cnt
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|create_default_symver
condition|)
block|{
name|def
operator|.
name|vd_aux
operator|=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|Elf_External_Verdef
argument_list|)
expr_stmt|;
name|def
operator|.
name|vd_next
operator|=
sizeof|sizeof
argument_list|(
name|Elf_External_Verdef
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|def
operator|.
name|vd_aux
operator|=
sizeof|sizeof
argument_list|(
name|Elf_External_Verdef
argument_list|)
expr_stmt|;
name|def
operator|.
name|vd_next
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|Elf_External_Verdef
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|Elf_External_Verdaux
argument_list|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|soname_indx
operator|!=
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
condition|)
block|{
name|_bfd_elf_strtab_addref
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
argument_list|,
name|soname_indx
argument_list|)
expr_stmt|;
name|def
operator|.
name|vd_hash
operator|=
name|bfd_elf_hash
argument_list|(
name|soname
argument_list|)
expr_stmt|;
name|defaux
operator|.
name|vda_name
operator|=
name|soname_indx
expr_stmt|;
name|name
operator|=
name|soname
expr_stmt|;
block|}
else|else
block|{
name|bfd_size_type
name|indx
decl_stmt|;
name|name
operator|=
name|lbasename
argument_list|(
name|output_bfd
operator|->
name|filename
argument_list|)
expr_stmt|;
name|def
operator|.
name|vd_hash
operator|=
name|bfd_elf_hash
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|indx
operator|=
name|_bfd_elf_strtab_add
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|indx
operator|==
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
condition|)
return|return
name|FALSE
return|;
name|defaux
operator|.
name|vda_name
operator|=
name|indx
expr_stmt|;
block|}
name|defaux
operator|.
name|vda_next
operator|=
literal|0
expr_stmt|;
name|_bfd_elf_swap_verdef_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|def
argument_list|,
operator|(
name|Elf_External_Verdef
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|Elf_External_Verdef
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|create_default_symver
condition|)
block|{
comment|/* Add a symbol representing this version.  */
name|bh
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|dynobj
argument_list|,
name|name
argument_list|,
name|BSF_GLOBAL
argument_list|,
name|bfd_abs_section_ptr
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|get_elf_backend_data
argument_list|(
name|dynobj
argument_list|)
operator|->
name|collect
argument_list|,
operator|&
name|bh
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|bh
expr_stmt|;
name|h
operator|->
name|non_elf
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|def_regular
operator|=
literal|1
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|STT_OBJECT
expr_stmt|;
name|h
operator|->
name|verinfo
operator|.
name|vertree
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Create a duplicate of the base version with the same 		 aux block, but different flags.  */
name|def
operator|.
name|vd_flags
operator|=
literal|0
expr_stmt|;
name|def
operator|.
name|vd_ndx
operator|=
literal|2
expr_stmt|;
name|def
operator|.
name|vd_aux
operator|=
sizeof|sizeof
argument_list|(
name|Elf_External_Verdef
argument_list|)
expr_stmt|;
if|if
condition|(
name|verdefs
condition|)
name|def
operator|.
name|vd_next
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|Elf_External_Verdef
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|Elf_External_Verdaux
argument_list|)
operator|)
expr_stmt|;
else|else
name|def
operator|.
name|vd_next
operator|=
literal|0
expr_stmt|;
name|_bfd_elf_swap_verdef_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|def
argument_list|,
operator|(
name|Elf_External_Verdef
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|Elf_External_Verdef
argument_list|)
expr_stmt|;
block|}
name|_bfd_elf_swap_verdaux_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|defaux
argument_list|,
operator|(
name|Elf_External_Verdaux
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|Elf_External_Verdaux
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|verdefs
init|;
name|t
operator|!=
name|NULL
condition|;
name|t
operator|=
name|t
operator|->
name|next
control|)
block|{
name|unsigned
name|int
name|cdeps
decl_stmt|;
name|struct
name|bfd_elf_version_deps
modifier|*
name|n
decl_stmt|;
name|cdeps
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
name|t
operator|->
name|deps
init|;
name|n
operator|!=
name|NULL
condition|;
name|n
operator|=
name|n
operator|->
name|next
control|)
operator|++
name|cdeps
expr_stmt|;
comment|/* Add a symbol representing this version.  */
name|bh
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|dynobj
argument_list|,
name|t
operator|->
name|name
argument_list|,
name|BSF_GLOBAL
argument_list|,
name|bfd_abs_section_ptr
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|get_elf_backend_data
argument_list|(
name|dynobj
argument_list|)
operator|->
name|collect
argument_list|,
operator|&
name|bh
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|bh
expr_stmt|;
name|h
operator|->
name|non_elf
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|def_regular
operator|=
literal|1
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|STT_OBJECT
expr_stmt|;
name|h
operator|->
name|verinfo
operator|.
name|vertree
operator|=
name|t
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|def
operator|.
name|vd_version
operator|=
name|VER_DEF_CURRENT
expr_stmt|;
name|def
operator|.
name|vd_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|globals
operator|.
name|list
operator|==
name|NULL
operator|&&
name|t
operator|->
name|locals
operator|.
name|list
operator|==
name|NULL
operator|&&
operator|!
name|t
operator|->
name|used
condition|)
name|def
operator|.
name|vd_flags
operator||=
name|VER_FLG_WEAK
expr_stmt|;
name|def
operator|.
name|vd_ndx
operator|=
name|t
operator|->
name|vernum
operator|+
operator|(
name|info
operator|->
name|create_default_symver
condition|?
literal|2
else|:
literal|1
operator|)
expr_stmt|;
name|def
operator|.
name|vd_cnt
operator|=
name|cdeps
operator|+
literal|1
expr_stmt|;
name|def
operator|.
name|vd_hash
operator|=
name|bfd_elf_hash
argument_list|(
name|t
operator|->
name|name
argument_list|)
expr_stmt|;
name|def
operator|.
name|vd_aux
operator|=
sizeof|sizeof
argument_list|(
name|Elf_External_Verdef
argument_list|)
expr_stmt|;
name|def
operator|.
name|vd_next
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|next
operator|!=
name|NULL
condition|)
name|def
operator|.
name|vd_next
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|Elf_External_Verdef
argument_list|)
operator|+
operator|(
name|cdeps
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|Elf_External_Verdaux
argument_list|)
operator|)
expr_stmt|;
name|_bfd_elf_swap_verdef_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|def
argument_list|,
operator|(
name|Elf_External_Verdef
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|Elf_External_Verdef
argument_list|)
expr_stmt|;
name|defaux
operator|.
name|vda_name
operator|=
name|h
operator|->
name|dynstr_index
expr_stmt|;
name|_bfd_elf_strtab_addref
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
argument_list|,
name|h
operator|->
name|dynstr_index
argument_list|)
expr_stmt|;
name|defaux
operator|.
name|vda_next
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|deps
operator|!=
name|NULL
condition|)
name|defaux
operator|.
name|vda_next
operator|=
sizeof|sizeof
argument_list|(
name|Elf_External_Verdaux
argument_list|)
expr_stmt|;
name|t
operator|->
name|name_indx
operator|=
name|defaux
operator|.
name|vda_name
expr_stmt|;
name|_bfd_elf_swap_verdaux_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|defaux
argument_list|,
operator|(
name|Elf_External_Verdaux
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|Elf_External_Verdaux
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
name|t
operator|->
name|deps
init|;
name|n
operator|!=
name|NULL
condition|;
name|n
operator|=
name|n
operator|->
name|next
control|)
block|{
if|if
condition|(
name|n
operator|->
name|version_needed
operator|==
name|NULL
condition|)
block|{
comment|/* This can happen if there was an error in the 			 version script.  */
name|defaux
operator|.
name|vda_name
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|defaux
operator|.
name|vda_name
operator|=
name|n
operator|->
name|version_needed
operator|->
name|name_indx
expr_stmt|;
name|_bfd_elf_strtab_addref
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
argument_list|,
name|defaux
operator|.
name|vda_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|->
name|next
operator|==
name|NULL
condition|)
name|defaux
operator|.
name|vda_next
operator|=
literal|0
expr_stmt|;
else|else
name|defaux
operator|.
name|vda_next
operator|=
sizeof|sizeof
argument_list|(
name|Elf_External_Verdaux
argument_list|)
expr_stmt|;
name|_bfd_elf_swap_verdaux_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|defaux
argument_list|,
operator|(
name|Elf_External_Verdaux
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|Elf_External_Verdaux
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|_bfd_elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_VERDEF
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|_bfd_elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_VERDEFNUM
argument_list|,
name|cdefs
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|elf_tdata
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|cverdefs
operator|=
name|cdefs
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|info
operator|->
name|new_dtags
operator|&&
name|info
operator|->
name|flags
operator|)
operator|||
operator|(
name|info
operator|->
name|flags
operator|&
name|DF_STATIC_TLS
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|_bfd_elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_FLAGS
argument_list|,
name|info
operator|->
name|flags
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
elseif|else
if|if
condition|(
name|info
operator|->
name|flags
operator|&
name|DF_BIND_NOW
condition|)
block|{
if|if
condition|(
operator|!
name|_bfd_elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_BIND_NOW
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|info
operator|->
name|flags_1
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|executable
condition|)
name|info
operator|->
name|flags_1
operator|&=
operator|~
operator|(
name|DF_1_INITFIRST
operator||
name|DF_1_NODELETE
operator||
name|DF_1_NOOPEN
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|_bfd_elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_FLAGS_1
argument_list|,
name|info
operator|->
name|flags_1
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Work out the size of the version reference section.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".gnu.version_r"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|{
name|struct
name|elf_find_verdep_info
name|sinfo
decl_stmt|;
name|sinfo
operator|.
name|output_bfd
operator|=
name|output_bfd
expr_stmt|;
name|sinfo
operator|.
name|info
operator|=
name|info
expr_stmt|;
name|sinfo
operator|.
name|vers
operator|=
name|elf_tdata
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|cverdefs
expr_stmt|;
if|if
condition|(
name|sinfo
operator|.
name|vers
operator|==
literal|0
condition|)
name|sinfo
operator|.
name|vers
operator|=
literal|1
expr_stmt|;
name|sinfo
operator|.
name|failed
operator|=
name|FALSE
expr_stmt|;
name|elf_link_hash_traverse
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|_bfd_elf_link_find_version_dependencies
argument_list|,
operator|&
name|sinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_tdata
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|verref
operator|==
name|NULL
condition|)
name|s
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
else|else
block|{
name|Elf_Internal_Verneed
modifier|*
name|t
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
name|unsigned
name|int
name|crefs
decl_stmt|;
name|bfd_byte
modifier|*
name|p
decl_stmt|;
comment|/* Build the version definition section.  */
name|size
operator|=
literal|0
expr_stmt|;
name|crefs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|t
operator|=
name|elf_tdata
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|verref
init|;
name|t
operator|!=
name|NULL
condition|;
name|t
operator|=
name|t
operator|->
name|vn_nextref
control|)
block|{
name|Elf_Internal_Vernaux
modifier|*
name|a
decl_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf_External_Verneed
argument_list|)
expr_stmt|;
operator|++
name|crefs
expr_stmt|;
for|for
control|(
name|a
operator|=
name|t
operator|->
name|vn_auxptr
init|;
name|a
operator|!=
name|NULL
condition|;
name|a
operator|=
name|a
operator|->
name|vna_nextptr
control|)
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf_External_Vernaux
argument_list|)
expr_stmt|;
block|}
name|s
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|s
operator|->
name|contents
operator|=
name|bfd_alloc
argument_list|(
name|output_bfd
argument_list|,
name|s
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|p
operator|=
name|s
operator|->
name|contents
expr_stmt|;
for|for
control|(
name|t
operator|=
name|elf_tdata
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|verref
init|;
name|t
operator|!=
name|NULL
condition|;
name|t
operator|=
name|t
operator|->
name|vn_nextref
control|)
block|{
name|unsigned
name|int
name|caux
decl_stmt|;
name|Elf_Internal_Vernaux
modifier|*
name|a
decl_stmt|;
name|bfd_size_type
name|indx
decl_stmt|;
name|caux
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|a
operator|=
name|t
operator|->
name|vn_auxptr
init|;
name|a
operator|!=
name|NULL
condition|;
name|a
operator|=
name|a
operator|->
name|vna_nextptr
control|)
operator|++
name|caux
expr_stmt|;
name|t
operator|->
name|vn_version
operator|=
name|VER_NEED_CURRENT
expr_stmt|;
name|t
operator|->
name|vn_cnt
operator|=
name|caux
expr_stmt|;
name|indx
operator|=
name|_bfd_elf_strtab_add
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
argument_list|,
name|elf_dt_name
argument_list|(
name|t
operator|->
name|vn_bfd
argument_list|)
operator|!=
name|NULL
condition|?
name|elf_dt_name
argument_list|(
name|t
operator|->
name|vn_bfd
argument_list|)
else|:
name|lbasename
argument_list|(
name|t
operator|->
name|vn_bfd
operator|->
name|filename
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|indx
operator|==
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
condition|)
return|return
name|FALSE
return|;
name|t
operator|->
name|vn_file
operator|=
name|indx
expr_stmt|;
name|t
operator|->
name|vn_aux
operator|=
sizeof|sizeof
argument_list|(
name|Elf_External_Verneed
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|vn_nextref
operator|==
name|NULL
condition|)
name|t
operator|->
name|vn_next
operator|=
literal|0
expr_stmt|;
else|else
name|t
operator|->
name|vn_next
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|Elf_External_Verneed
argument_list|)
operator|+
name|caux
operator|*
sizeof|sizeof
argument_list|(
name|Elf_External_Vernaux
argument_list|)
operator|)
expr_stmt|;
name|_bfd_elf_swap_verneed_out
argument_list|(
name|output_bfd
argument_list|,
name|t
argument_list|,
operator|(
name|Elf_External_Verneed
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|Elf_External_Verneed
argument_list|)
expr_stmt|;
for|for
control|(
name|a
operator|=
name|t
operator|->
name|vn_auxptr
init|;
name|a
operator|!=
name|NULL
condition|;
name|a
operator|=
name|a
operator|->
name|vna_nextptr
control|)
block|{
name|a
operator|->
name|vna_hash
operator|=
name|bfd_elf_hash
argument_list|(
name|a
operator|->
name|vna_nodename
argument_list|)
expr_stmt|;
name|indx
operator|=
name|_bfd_elf_strtab_add
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
argument_list|,
name|a
operator|->
name|vna_nodename
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|indx
operator|==
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
condition|)
return|return
name|FALSE
return|;
name|a
operator|->
name|vna_name
operator|=
name|indx
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|vna_nextptr
operator|==
name|NULL
condition|)
name|a
operator|->
name|vna_next
operator|=
literal|0
expr_stmt|;
else|else
name|a
operator|->
name|vna_next
operator|=
sizeof|sizeof
argument_list|(
name|Elf_External_Vernaux
argument_list|)
expr_stmt|;
name|_bfd_elf_swap_vernaux_out
argument_list|(
name|output_bfd
argument_list|,
name|a
argument_list|,
operator|(
name|Elf_External_Vernaux
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|Elf_External_Vernaux
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|_bfd_elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_VERNEED
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|_bfd_elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_VERNEEDNUM
argument_list|,
name|crefs
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|elf_tdata
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|cverrefs
operator|=
name|crefs
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|elf_tdata
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|cverrefs
operator|==
literal|0
operator|&&
name|elf_tdata
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|cverdefs
operator|==
literal|0
operator|)
operator|||
name|_bfd_elf_link_renumber_dynsyms
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
operator|&
name|section_sym_count
argument_list|)
operator|==
literal|0
condition|)
block|{
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".gnu.version"
argument_list|)
expr_stmt|;
name|s
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Find the first non-excluded output section.  We'll use its    section symbol for some emitted relocs.  */
end_comment

begin_function
name|void
name|_bfd_elf_init_1_index_section
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|output_bfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
operator|(
name|SEC_EXCLUDE
operator||
name|SEC_ALLOC
operator|)
operator|)
operator|==
name|SEC_ALLOC
operator|&&
operator|!
name|_bfd_elf_link_omit_section_dynsym
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|s
argument_list|)
condition|)
block|{
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|text_index_section
operator|=
name|s
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Find two non-excluded output sections, one for code, one for data.    We'll use their section symbols for some emitted relocs.  */
end_comment

begin_function
name|void
name|_bfd_elf_init_2_index_sections
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|output_bfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
if|if
condition|(
operator|(
operator|(
name|s
operator|->
name|flags
operator|&
operator|(
name|SEC_EXCLUDE
operator||
name|SEC_ALLOC
operator||
name|SEC_READONLY
operator|)
operator|)
operator|==
operator|(
name|SEC_ALLOC
operator||
name|SEC_READONLY
operator|)
operator|)
operator|&&
operator|!
name|_bfd_elf_link_omit_section_dynsym
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|s
argument_list|)
condition|)
block|{
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|text_index_section
operator|=
name|s
expr_stmt|;
break|break;
block|}
for|for
control|(
name|s
operator|=
name|output_bfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
if|if
condition|(
operator|(
operator|(
name|s
operator|->
name|flags
operator|&
operator|(
name|SEC_EXCLUDE
operator||
name|SEC_ALLOC
operator||
name|SEC_READONLY
operator|)
operator|)
operator|==
name|SEC_ALLOC
operator|)
operator|&&
operator|!
name|_bfd_elf_link_omit_section_dynsym
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|s
argument_list|)
condition|)
block|{
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|data_index_section
operator|=
name|s
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|text_index_section
operator|==
name|NULL
condition|)
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|text_index_section
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|data_index_section
expr_stmt|;
block|}
end_function

begin_function
name|bfd_boolean
name|bfd_elf_size_dynsym_hash_dynstr
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
if|if
condition|(
operator|!
name|is_elf_hash_table
argument_list|(
name|info
operator|->
name|hash
argument_list|)
condition|)
return|return
name|TRUE
return|;
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
call|(
modifier|*
name|bed
operator|->
name|elf_backend_init_index_section
call|)
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_size_type
name|dynsymcount
decl_stmt|;
name|unsigned
name|long
name|section_sym_count
decl_stmt|;
name|unsigned
name|int
name|dtagcount
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
comment|/* Assign dynsym indicies.  In a shared library we generate a 	 section symbol for each output section, which come first. 	 Next come all of the back-end allocated local dynamic syms, 	 followed by the rest of the global symbols.  */
name|dynsymcount
operator|=
name|_bfd_elf_link_renumber_dynsyms
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
operator|&
name|section_sym_count
argument_list|)
expr_stmt|;
comment|/* Work out the size of the symbol version section.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".gnu.version"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynsymcount
operator|!=
literal|0
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_EXCLUDE
operator|)
operator|==
literal|0
condition|)
block|{
name|s
operator|->
name|size
operator|=
name|dynsymcount
operator|*
sizeof|sizeof
argument_list|(
name|Elf_External_Versym
argument_list|)
expr_stmt|;
name|s
operator|->
name|contents
operator|=
name|bfd_zalloc
argument_list|(
name|output_bfd
argument_list|,
name|s
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|_bfd_elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_VERSYM
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Set the size of the .dynsym and .hash sections.  We counted 	 the number of dynamic symbols in elf_link_add_object_symbols. 	 We will build the contents of .dynsym and .hash when we build 	 the final symbol table, because until then we do not know the 	 correct value to give the symbols.  We built the .dynstr 	 section as we went along in elf_link_add_object_symbols.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynsym"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|size
operator|=
name|dynsymcount
operator|*
name|bed
operator|->
name|s
operator|->
name|sizeof_sym
expr_stmt|;
if|if
condition|(
name|dynsymcount
operator|!=
literal|0
condition|)
block|{
name|s
operator|->
name|contents
operator|=
name|bfd_alloc
argument_list|(
name|output_bfd
argument_list|,
name|s
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* The first entry in .dynsym is a dummy symbol. 	     Clear all the section syms, in case we don't output them all.  */
operator|++
name|section_sym_count
expr_stmt|;
name|memset
argument_list|(
name|s
operator|->
name|contents
argument_list|,
literal|0
argument_list|,
name|section_sym_count
operator|*
name|bed
operator|->
name|s
operator|->
name|sizeof_sym
argument_list|)
expr_stmt|;
block|}
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|bucketcount
operator|=
literal|0
expr_stmt|;
comment|/* Compute the size of the hashing table.  As a side effect this 	 computes the hash values for all the names we export.  */
if|if
condition|(
name|info
operator|->
name|emit_hash
condition|)
block|{
name|unsigned
name|long
name|int
modifier|*
name|hashcodes
decl_stmt|;
name|unsigned
name|long
name|int
modifier|*
name|hashcodesp
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|unsigned
name|long
name|int
name|nsyms
decl_stmt|;
name|size_t
name|bucketcount
decl_stmt|;
name|size_t
name|hash_entry_size
decl_stmt|;
comment|/* Compute the hash values for all exported symbols.  At the same 	     time store the values in an array so that we could use them for 	     optimizations.  */
name|amt
operator|=
name|dynsymcount
operator|*
expr|sizeof
operator|(
name|unsigned
name|long
name|int
operator|)
expr_stmt|;
name|hashcodes
operator|=
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|hashcodes
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|hashcodesp
operator|=
name|hashcodes
expr_stmt|;
comment|/* Put all hash values in HASHCODES.  */
name|elf_link_hash_traverse
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|elf_collect_hash_codes
argument_list|,
operator|&
name|hashcodesp
argument_list|)
expr_stmt|;
name|nsyms
operator|=
name|hashcodesp
operator|-
name|hashcodes
expr_stmt|;
name|bucketcount
operator|=
name|compute_bucket_count
argument_list|(
name|info
argument_list|,
name|hashcodes
argument_list|,
name|nsyms
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|hashcodes
argument_list|)
expr_stmt|;
if|if
condition|(
name|bucketcount
operator|==
literal|0
condition|)
return|return
name|FALSE
return|;
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|bucketcount
operator|=
name|bucketcount
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".hash"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|hash_entry_size
operator|=
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
expr_stmt|;
name|s
operator|->
name|size
operator|=
operator|(
operator|(
literal|2
operator|+
name|bucketcount
operator|+
name|dynsymcount
operator|)
operator|*
name|hash_entry_size
operator|)
expr_stmt|;
name|s
operator|->
name|contents
operator|=
name|bfd_zalloc
argument_list|(
name|output_bfd
argument_list|,
name|s
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|bfd_put
argument_list|(
literal|8
operator|*
name|hash_entry_size
argument_list|,
name|output_bfd
argument_list|,
name|bucketcount
argument_list|,
name|s
operator|->
name|contents
argument_list|)
expr_stmt|;
name|bfd_put
argument_list|(
literal|8
operator|*
name|hash_entry_size
argument_list|,
name|output_bfd
argument_list|,
name|dynsymcount
argument_list|,
name|s
operator|->
name|contents
operator|+
name|hash_entry_size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|emit_gnu_hash
condition|)
block|{
name|size_t
name|i
decl_stmt|,
name|cnt
decl_stmt|;
name|unsigned
name|char
modifier|*
name|contents
decl_stmt|;
name|struct
name|collect_gnu_hash_codes
name|cinfo
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|size_t
name|bucketcount
decl_stmt|;
name|memset
argument_list|(
operator|&
name|cinfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cinfo
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Compute the hash values for all exported symbols.  At the same 	     time store the values in an array so that we could use them for 	     optimizations.  */
name|amt
operator|=
name|dynsymcount
operator|*
literal|2
operator|*
expr|sizeof
operator|(
name|unsigned
name|long
name|int
operator|)
expr_stmt|;
name|cinfo
operator|.
name|hashcodes
operator|=
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|cinfo
operator|.
name|hashcodes
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|cinfo
operator|.
name|hashval
operator|=
name|cinfo
operator|.
name|hashcodes
operator|+
name|dynsymcount
expr_stmt|;
name|cinfo
operator|.
name|min_dynindx
operator|=
operator|-
literal|1
expr_stmt|;
name|cinfo
operator|.
name|output_bfd
operator|=
name|output_bfd
expr_stmt|;
name|cinfo
operator|.
name|bed
operator|=
name|bed
expr_stmt|;
comment|/* Put all hash values in HASHCODES.  */
name|elf_link_hash_traverse
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|elf_collect_gnu_hash_codes
argument_list|,
operator|&
name|cinfo
argument_list|)
expr_stmt|;
name|bucketcount
operator|=
name|compute_bucket_count
argument_list|(
name|info
argument_list|,
name|cinfo
operator|.
name|hashcodes
argument_list|,
name|cinfo
operator|.
name|nsyms
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bucketcount
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|cinfo
operator|.
name|hashcodes
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".gnu.hash"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|cinfo
operator|.
name|nsyms
operator|==
literal|0
condition|)
block|{
comment|/* Empty .gnu.hash section is special.  */
name|BFD_ASSERT
argument_list|(
name|cinfo
operator|.
name|min_dynindx
operator|==
operator|-
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cinfo
operator|.
name|hashcodes
argument_list|)
expr_stmt|;
name|s
operator|->
name|size
operator|=
literal|5
operator|*
literal|4
operator|+
name|bed
operator|->
name|s
operator|->
name|arch_size
operator|/
literal|8
expr_stmt|;
name|contents
operator|=
name|bfd_zalloc
argument_list|(
name|output_bfd
argument_list|,
name|s
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|s
operator|->
name|contents
operator|=
name|contents
expr_stmt|;
comment|/* 1 empty bucket.  */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
literal|1
argument_list|,
name|contents
argument_list|)
expr_stmt|;
comment|/* SYMIDX above the special symbol 0.  */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
literal|1
argument_list|,
name|contents
operator|+
literal|4
argument_list|)
expr_stmt|;
comment|/* Just one word for bitmask.  */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
literal|1
argument_list|,
name|contents
operator|+
literal|8
argument_list|)
expr_stmt|;
comment|/* Only hash fn bloom filter.  */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
literal|0
argument_list|,
name|contents
operator|+
literal|12
argument_list|)
expr_stmt|;
comment|/* No hashes are valid - empty bitmask.  */
name|bfd_put
argument_list|(
name|bed
operator|->
name|s
operator|->
name|arch_size
argument_list|,
name|output_bfd
argument_list|,
literal|0
argument_list|,
name|contents
operator|+
literal|16
argument_list|)
expr_stmt|;
comment|/* No hashes in the only bucket.  */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
literal|0
argument_list|,
name|contents
operator|+
literal|16
operator|+
name|bed
operator|->
name|s
operator|->
name|arch_size
operator|/
literal|8
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|long
name|int
name|maskwords
decl_stmt|,
name|maskbitslog2
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|cinfo
operator|.
name|min_dynindx
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|maskbitslog2
operator|=
name|bfd_log2
argument_list|(
name|cinfo
operator|.
name|nsyms
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|maskbitslog2
operator|<
literal|3
condition|)
name|maskbitslog2
operator|=
literal|5
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
literal|1
operator|<<
operator|(
name|maskbitslog2
operator|-
literal|2
operator|)
operator|)
operator|&
name|cinfo
operator|.
name|nsyms
condition|)
name|maskbitslog2
operator|=
name|maskbitslog2
operator|+
literal|3
expr_stmt|;
else|else
name|maskbitslog2
operator|=
name|maskbitslog2
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|bed
operator|->
name|s
operator|->
name|arch_size
operator|==
literal|64
condition|)
block|{
if|if
condition|(
name|maskbitslog2
operator|==
literal|5
condition|)
name|maskbitslog2
operator|=
literal|6
expr_stmt|;
name|cinfo
operator|.
name|shift1
operator|=
literal|6
expr_stmt|;
block|}
else|else
name|cinfo
operator|.
name|shift1
operator|=
literal|5
expr_stmt|;
name|cinfo
operator|.
name|mask
operator|=
operator|(
literal|1
operator|<<
name|cinfo
operator|.
name|shift1
operator|)
operator|-
literal|1
expr_stmt|;
name|cinfo
operator|.
name|shift2
operator|=
name|maskbitslog2
expr_stmt|;
name|cinfo
operator|.
name|maskbits
operator|=
literal|1
operator|<<
name|maskbitslog2
expr_stmt|;
name|maskwords
operator|=
literal|1
operator|<<
operator|(
name|maskbitslog2
operator|-
name|cinfo
operator|.
name|shift1
operator|)
expr_stmt|;
name|amt
operator|=
name|bucketcount
operator|*
expr|sizeof
operator|(
name|unsigned
name|long
name|int
operator|)
operator|*
literal|2
expr_stmt|;
name|amt
operator|+=
name|maskwords
operator|*
sizeof|sizeof
argument_list|(
name|bfd_vma
argument_list|)
expr_stmt|;
name|cinfo
operator|.
name|bitmask
operator|=
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|cinfo
operator|.
name|bitmask
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|cinfo
operator|.
name|hashcodes
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|cinfo
operator|.
name|counts
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|cinfo
operator|.
name|bitmask
operator|+
name|maskwords
operator|)
expr_stmt|;
name|cinfo
operator|.
name|indx
operator|=
name|cinfo
operator|.
name|counts
operator|+
name|bucketcount
expr_stmt|;
name|cinfo
operator|.
name|symindx
operator|=
name|dynsymcount
operator|-
name|cinfo
operator|.
name|nsyms
expr_stmt|;
name|memset
argument_list|(
name|cinfo
operator|.
name|bitmask
argument_list|,
literal|0
argument_list|,
name|maskwords
operator|*
sizeof|sizeof
argument_list|(
name|bfd_vma
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Determine how often each hash bucket is used.  */
name|memset
argument_list|(
name|cinfo
operator|.
name|counts
argument_list|,
literal|0
argument_list|,
name|bucketcount
operator|*
sizeof|sizeof
argument_list|(
name|cinfo
operator|.
name|counts
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cinfo
operator|.
name|nsyms
condition|;
operator|++
name|i
control|)
operator|++
name|cinfo
operator|.
name|counts
index|[
name|cinfo
operator|.
name|hashcodes
index|[
name|i
index|]
operator|%
name|bucketcount
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|cnt
operator|=
name|cinfo
operator|.
name|symindx
init|;
name|i
operator|<
name|bucketcount
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|cinfo
operator|.
name|counts
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|cinfo
operator|.
name|indx
index|[
name|i
index|]
operator|=
name|cnt
expr_stmt|;
name|cnt
operator|+=
name|cinfo
operator|.
name|counts
index|[
name|i
index|]
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
name|cnt
operator|==
name|dynsymcount
argument_list|)
expr_stmt|;
name|cinfo
operator|.
name|bucketcount
operator|=
name|bucketcount
expr_stmt|;
name|cinfo
operator|.
name|local_indx
operator|=
name|cinfo
operator|.
name|min_dynindx
expr_stmt|;
name|s
operator|->
name|size
operator|=
operator|(
literal|4
operator|+
name|bucketcount
operator|+
name|cinfo
operator|.
name|nsyms
operator|)
operator|*
literal|4
expr_stmt|;
name|s
operator|->
name|size
operator|+=
name|cinfo
operator|.
name|maskbits
operator|/
literal|8
expr_stmt|;
name|contents
operator|=
name|bfd_zalloc
argument_list|(
name|output_bfd
argument_list|,
name|s
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|cinfo
operator|.
name|bitmask
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cinfo
operator|.
name|hashcodes
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|s
operator|->
name|contents
operator|=
name|contents
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|bucketcount
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|cinfo
operator|.
name|symindx
argument_list|,
name|contents
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|maskwords
argument_list|,
name|contents
operator|+
literal|8
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|cinfo
operator|.
name|shift2
argument_list|,
name|contents
operator|+
literal|12
argument_list|)
expr_stmt|;
name|contents
operator|+=
literal|16
operator|+
name|cinfo
operator|.
name|maskbits
operator|/
literal|8
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bucketcount
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|cinfo
operator|.
name|counts
index|[
name|i
index|]
operator|==
literal|0
condition|)
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
literal|0
argument_list|,
name|contents
argument_list|)
expr_stmt|;
else|else
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|cinfo
operator|.
name|indx
index|[
name|i
index|]
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|contents
operator|+=
literal|4
expr_stmt|;
block|}
name|cinfo
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
comment|/* Renumber dynamic symbols, populate .gnu.hash section.  */
name|elf_link_hash_traverse
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|elf_renumber_gnu_hash_syms
argument_list|,
operator|&
name|cinfo
argument_list|)
expr_stmt|;
name|contents
operator|=
name|s
operator|->
name|contents
operator|+
literal|16
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|maskwords
condition|;
operator|++
name|i
control|)
block|{
name|bfd_put
argument_list|(
name|bed
operator|->
name|s
operator|->
name|arch_size
argument_list|,
name|output_bfd
argument_list|,
name|cinfo
operator|.
name|bitmask
index|[
name|i
index|]
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|contents
operator|+=
name|bed
operator|->
name|s
operator|->
name|arch_size
operator|/
literal|8
expr_stmt|;
block|}
name|free
argument_list|(
name|cinfo
operator|.
name|bitmask
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cinfo
operator|.
name|hashcodes
argument_list|)
expr_stmt|;
block|}
block|}
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynstr"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|elf_finalize_dynstr
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|s
operator|->
name|size
operator|=
name|_bfd_elf_strtab_size
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
argument_list|)
expr_stmt|;
for|for
control|(
name|dtagcount
operator|=
literal|0
init|;
name|dtagcount
operator|<=
name|info
operator|->
name|spare_dynamic_tags
condition|;
operator|++
name|dtagcount
control|)
if|if
condition|(
operator|!
name|_bfd_elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Final phase of ELF linker.  */
end_comment

begin_comment
comment|/* A structure we use to avoid passing large numbers of arguments.  */
end_comment

begin_struct
struct|struct
name|elf_final_link_info
block|{
comment|/* General link information.  */
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
comment|/* Output BFD.  */
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
comment|/* Symbol string table.  */
name|struct
name|bfd_strtab_hash
modifier|*
name|symstrtab
decl_stmt|;
comment|/* .dynsym section.  */
name|asection
modifier|*
name|dynsym_sec
decl_stmt|;
comment|/* .hash section.  */
name|asection
modifier|*
name|hash_sec
decl_stmt|;
comment|/* symbol version section (.gnu.version).  */
name|asection
modifier|*
name|symver_sec
decl_stmt|;
comment|/* Buffer large enough to hold contents of any section.  */
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
comment|/* Buffer large enough to hold external relocs of any section.  */
name|void
modifier|*
name|external_relocs
decl_stmt|;
comment|/* Buffer large enough to hold internal relocs of any section.  */
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|;
comment|/* Buffer large enough to hold external local symbols of any input      BFD.  */
name|bfd_byte
modifier|*
name|external_syms
decl_stmt|;
comment|/* And a buffer for symbol section indices.  */
name|Elf_External_Sym_Shndx
modifier|*
name|locsym_shndx
decl_stmt|;
comment|/* Buffer large enough to hold internal local symbols of any input      BFD.  */
name|Elf_Internal_Sym
modifier|*
name|internal_syms
decl_stmt|;
comment|/* Array large enough to hold a symbol index for each local symbol      of any input BFD.  */
name|long
modifier|*
name|indices
decl_stmt|;
comment|/* Array large enough to hold a section pointer for each local      symbol of any input BFD.  */
name|asection
modifier|*
modifier|*
name|sections
decl_stmt|;
comment|/* Buffer to hold swapped out symbols.  */
name|bfd_byte
modifier|*
name|symbuf
decl_stmt|;
comment|/* And one for symbol section indices.  */
name|Elf_External_Sym_Shndx
modifier|*
name|symshndxbuf
decl_stmt|;
comment|/* Number of swapped out symbols in buffer.  */
name|size_t
name|symbuf_count
decl_stmt|;
comment|/* Number of symbols which fit in symbuf.  */
name|size_t
name|symbuf_size
decl_stmt|;
comment|/* And same for symshndxbuf.  */
name|size_t
name|shndxbuf_size
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This struct is used to pass information to elf_link_output_extsym.  */
end_comment

begin_struct
struct|struct
name|elf_outext_info
block|{
name|bfd_boolean
name|failed
decl_stmt|;
name|bfd_boolean
name|localsyms
decl_stmt|;
name|struct
name|elf_final_link_info
modifier|*
name|finfo
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Support for evaluating a complex relocation.     Complex relocations are generalized, self-describing relocations.  The    implementation of them consists of two parts: complex symbols, and the    relocations themselves.      The relocations are use a reserved elf-wide relocation type code (R_RELC    external / BFD_RELOC_RELC internal) and an encoding of relocation field    information (start bit, end bit, word width, etc) into the addend.  This    information is extracted from CGEN-generated operand tables within gas.     Complex symbols are mangled symbols (BSF_RELC external / STT_RELC    internal) representing prefix-notation expressions, including but not    limited to those sorts of expressions normally encoded as addends in the    addend field.  The symbol mangling format is:<node> :=<literal>           |<unary-operator> ':'<node>           |<binary-operator> ':'<node> ':'<node> 	  ;<literal> := 's'<digits=N> ':'<N character symbol name>              |  'S'<digits=N> ':'<N character section name> 	     |  '#'<hexdigits> 	     ;<binary-operator> := as in C<unary-operator> := as in C, plus "0-" for unambiguous negation.  */
end_comment

begin_function
specifier|static
name|void
name|set_symbol_value
parameter_list|(
name|bfd
modifier|*
name|bfd_with_globals
parameter_list|,
name|struct
name|elf_final_link_info
modifier|*
name|finfo
parameter_list|,
name|int
name|symidx
parameter_list|,
name|bfd_vma
name|val
parameter_list|)
block|{
name|bfd_boolean
name|is_local
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|bfd_with_globals
argument_list|)
expr_stmt|;
name|sym
operator|=
name|finfo
operator|->
name|internal_syms
operator|+
name|symidx
expr_stmt|;
name|is_local
operator|=
name|ELF_ST_BIND
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STB_LOCAL
expr_stmt|;
if|if
condition|(
name|is_local
condition|)
block|{
comment|/* It is a local symbol: move it to the 	 "absolute" section and give it a value.  */
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_ABS
expr_stmt|;
name|sym
operator|->
name|st_value
operator|=
name|val
expr_stmt|;
block|}
else|else
block|{
comment|/* It is a global symbol: set its link type 	 to "defined" and give it a value.  */
name|h
operator|=
name|sym_hashes
index|[
name|symidx
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|type
operator|=
name|bfd_link_hash_defined
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|val
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|resolve_symbol
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|struct
name|elf_final_link_info
modifier|*
name|finfo
parameter_list|,
name|bfd_vma
modifier|*
name|result
parameter_list|,
name|size_t
name|locsymcount
parameter_list|)
block|{
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|global_entry
decl_stmt|;
specifier|const
name|char
modifier|*
name|candidate
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|asection
modifier|*
name|sec
init|=
name|NULL
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|locsymcount
condition|;
operator|++
name|i
control|)
block|{
name|sym
operator|=
name|finfo
operator|->
name|internal_syms
operator|+
name|i
expr_stmt|;
name|sec
operator|=
name|finfo
operator|->
name|sections
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|ELF_ST_BIND
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|!=
name|STB_LOCAL
condition|)
continue|continue;
name|candidate
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_link
argument_list|,
name|sym
operator|->
name|st_name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"Comparing string: '%s' vs. '%s' = 0x%x\n"
argument_list|,
name|name
argument_list|,
name|candidate
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|sym
operator|->
name|st_value
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|candidate
operator|&&
name|strcmp
argument_list|(
name|candidate
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|result
operator|=
name|sym
operator|->
name|st_value
expr_stmt|;
if|if
condition|(
name|sym
operator|->
name|st_shndx
operator|>
name|SHN_UNDEF
operator|&&
name|sym
operator|->
name|st_shndx
operator|<
name|SHN_LORESERVE
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"adjusting for sec '%s' @ 0x%x + 0x%x\n"
argument_list|,
name|sec
operator|->
name|output_section
operator|->
name|name
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|sec
operator|->
name|output_section
operator|->
name|vma
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|sec
operator|->
name|output_offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|result
operator|+=
name|sec
operator|->
name|output_offset
operator|+
name|sec
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"Found symbol with effective value %8.8x\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
operator|*
name|result
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|TRUE
return|;
block|}
block|}
comment|/* Hmm, haven't found it yet. perhaps it is a global.  */
name|global_entry
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|finfo
operator|->
name|info
operator|->
name|hash
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|global_entry
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|global_entry
operator|->
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|global_entry
operator|->
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
block|{
operator|*
name|result
operator|=
name|global_entry
operator|->
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|global_entry
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|global_entry
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"Found GLOBAL symbol '%s' with value %8.8x\n"
argument_list|,
name|global_entry
operator|->
name|root
operator|.
name|string
argument_list|,
operator|(
name|unsigned
name|int
operator|)
operator|*
name|result
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|TRUE
return|;
block|}
if|if
condition|(
name|global_entry
operator|->
name|type
operator|==
name|bfd_link_hash_common
condition|)
block|{
operator|*
name|result
operator|=
name|global_entry
operator|->
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|bfd_com_section_ptr
operator|->
name|output_section
operator|->
name|vma
operator|+
name|bfd_com_section_ptr
operator|->
name|output_offset
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"Found COMMON symbol '%s' with value %8.8x\n"
argument_list|,
name|global_entry
operator|->
name|root
operator|.
name|string
argument_list|,
operator|(
name|unsigned
name|int
operator|)
operator|*
name|result
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|resolve_section
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|asection
modifier|*
name|sections
parameter_list|,
name|bfd_vma
modifier|*
name|result
parameter_list|)
block|{
name|asection
modifier|*
name|curr
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
for|for
control|(
name|curr
operator|=
name|sections
init|;
name|curr
condition|;
name|curr
operator|=
name|curr
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|curr
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|result
operator|=
name|curr
operator|->
name|vma
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* Hmm. still haven't found it. try pseudo-section names.  */
for|for
control|(
name|curr
operator|=
name|sections
init|;
name|curr
condition|;
name|curr
operator|=
name|curr
operator|->
name|next
control|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|curr
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|strlen
argument_list|(
name|name
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|strncmp
argument_list|(
name|curr
operator|->
name|name
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
literal|".end"
argument_list|,
name|name
operator|+
name|len
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|result
operator|=
name|curr
operator|->
name|vma
operator|+
name|curr
operator|->
name|size
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* Insert more pseudo-section names here, if you like.  */
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|undefined_reference
parameter_list|(
specifier|const
name|char
modifier|*
name|reftype
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"undefined %s reference in complex symbol: %s"
argument_list|)
argument_list|,
name|reftype
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|eval_symbol
parameter_list|(
name|bfd_vma
modifier|*
name|result
parameter_list|,
name|char
modifier|*
name|sym
parameter_list|,
name|char
modifier|*
modifier|*
name|advanced
parameter_list|,
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|struct
name|elf_final_link_info
modifier|*
name|finfo
parameter_list|,
name|bfd_vma
name|addr
parameter_list|,
name|bfd_vma
name|section_offset
parameter_list|,
name|size_t
name|locsymcount
parameter_list|,
name|int
name|signed_p
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|int
name|symlen
decl_stmt|;
name|bfd_vma
name|a
decl_stmt|;
name|bfd_vma
name|b
decl_stmt|;
specifier|const
name|int
name|bufsz
init|=
literal|4096
decl_stmt|;
name|char
name|symbuf
index|[
name|bufsz
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|symend
decl_stmt|;
name|bfd_boolean
name|symbol_is_section
init|=
name|FALSE
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|symend
operator|=
name|sym
operator|+
name|len
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|1
operator|||
name|len
operator|>
name|bufsz
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
switch|switch
condition|(
operator|*
name|sym
condition|)
block|{
case|case
literal|'.'
case|:
operator|*
name|result
operator|=
name|addr
operator|+
name|section_offset
expr_stmt|;
operator|*
name|advanced
operator|=
name|sym
operator|+
literal|1
expr_stmt|;
return|return
name|TRUE
return|;
case|case
literal|'#'
case|:
operator|++
name|sym
expr_stmt|;
operator|*
name|result
operator|=
name|strtoul
argument_list|(
name|sym
argument_list|,
name|advanced
argument_list|,
literal|16
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
case|case
literal|'S'
case|:
name|symbol_is_section
operator|=
name|TRUE
expr_stmt|;
case|case
literal|'s'
case|:
operator|++
name|sym
expr_stmt|;
name|symlen
operator|=
name|strtol
argument_list|(
name|sym
argument_list|,
operator|&
name|sym
argument_list|,
literal|10
argument_list|)
expr_stmt|;
operator|++
name|sym
expr_stmt|;
comment|/* Skip the trailing ':'.  */
if|if
condition|(
operator|(
name|symend
operator|<
name|sym
operator|)
operator|||
operator|(
operator|(
name|symlen
operator|+
literal|1
operator|)
operator|>
name|bufsz
operator|)
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|memcpy
argument_list|(
name|symbuf
argument_list|,
name|sym
argument_list|,
name|symlen
argument_list|)
expr_stmt|;
name|symbuf
index|[
name|symlen
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|advanced
operator|=
name|sym
operator|+
name|symlen
expr_stmt|;
comment|/* Is it always possible, with complex symbols, that gas "mis-guessed"  	 the symbol as a section, or vice-versa. so we're pretty liberal in our 	 interpretation here; section means "try section first", not "must be a 	 section", and likewise with symbol.  */
if|if
condition|(
name|symbol_is_section
condition|)
block|{
if|if
condition|(
operator|(
name|resolve_section
argument_list|(
name|symbuf
argument_list|,
name|finfo
operator|->
name|output_bfd
operator|->
name|sections
argument_list|,
name|result
argument_list|)
operator|!=
name|TRUE
operator|)
operator|&&
operator|(
name|resolve_symbol
argument_list|(
name|symbuf
argument_list|,
name|input_bfd
argument_list|,
name|finfo
argument_list|,
name|result
argument_list|,
name|locsymcount
argument_list|)
operator|!=
name|TRUE
operator|)
condition|)
block|{
name|undefined_reference
argument_list|(
literal|"section"
argument_list|,
name|symbuf
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|resolve_symbol
argument_list|(
name|symbuf
argument_list|,
name|input_bfd
argument_list|,
name|finfo
argument_list|,
name|result
argument_list|,
name|locsymcount
argument_list|)
operator|!=
name|TRUE
operator|)
operator|&&
operator|(
name|resolve_section
argument_list|(
name|symbuf
argument_list|,
name|finfo
operator|->
name|output_bfd
operator|->
name|sections
argument_list|,
name|result
argument_list|)
operator|!=
name|TRUE
operator|)
condition|)
block|{
name|undefined_reference
argument_list|(
literal|"symbol"
argument_list|,
name|symbuf
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
comment|/* All that remains are operators.  */
define|#
directive|define
name|UNARY_OP
parameter_list|(
name|op
parameter_list|)
define|\
value|if (strncmp (sym, #op, strlen (#op)) == 0)			\     {								\       sym += strlen (#op);					\       if (* sym == ':')						\         ++ sym;							\       if (eval_symbol (& a, sym,& sym, input_bfd, finfo, addr, \                        section_offset, locsymcount, signed_p)   \ 	                                             != TRUE)	\         return FALSE;						\       if (signed_p)                                             \         * result = op ((signed)a);         			\       else                                                      \         * result = op a;                                        \       * advanced = sym; 					\       return TRUE;						\     }
define|#
directive|define
name|BINARY_OP
parameter_list|(
name|op
parameter_list|)
define|\
value|if (strncmp (sym, #op, strlen (#op)) == 0)			\     {								\       sym += strlen (#op);					\       if (* sym == ':')						\         ++ sym;							\       if (eval_symbol (& a, sym,& sym, input_bfd, finfo, addr, \                        section_offset, locsymcount, signed_p)   \                                                      != TRUE)	\         return FALSE;						\       ++ sym;							\       if (eval_symbol (& b, sym,& sym, input_bfd, finfo, addr, \                        section_offset, locsymcount, signed_p)   \                                                      != TRUE)	\         return FALSE;						\       if (signed_p)                                             \         * result = ((signed) a) op ((signed) b);	        \       else                                                      \         * result = a op b;                                      \       * advanced = sym;						\       return TRUE;						\     }
default|default:
name|UNARY_OP
argument_list|(
literal|0
operator|-
argument_list|)
expr_stmt|;
name|BINARY_OP
argument_list|(
operator|<<
argument_list|)
expr_stmt|;
name|BINARY_OP
argument_list|(
operator|>>
argument_list|)
expr_stmt|;
name|BINARY_OP
argument_list|(
operator|==
argument_list|)
expr_stmt|;
name|BINARY_OP
argument_list|(
operator|!=
argument_list|)
expr_stmt|;
name|BINARY_OP
argument_list|(
operator|<=
argument_list|)
expr_stmt|;
name|BINARY_OP
argument_list|(
operator|>=
argument_list|)
expr_stmt|;
name|BINARY_OP
argument_list|(
operator|&&
argument_list|)
expr_stmt|;
name|BINARY_OP
argument_list|(
operator|||
argument_list|)
expr_stmt|;
name|UNARY_OP
argument_list|(
operator|~
argument_list|)
expr_stmt|;
name|UNARY_OP
argument_list|(
operator|!
argument_list|)
expr_stmt|;
name|BINARY_OP
argument_list|(
operator|*
argument_list|)
expr_stmt|;
name|BINARY_OP
argument_list|(
operator|/
argument_list|)
expr_stmt|;
name|BINARY_OP
argument_list|(
operator|%
argument_list|)
expr_stmt|;
name|BINARY_OP
argument_list|(
operator|^
argument_list|)
expr_stmt|;
name|BINARY_OP
argument_list|(
operator||
argument_list|)
expr_stmt|;
name|BINARY_OP
argument_list|(
operator|&
argument_list|)
expr_stmt|;
name|BINARY_OP
argument_list|(
operator|+
argument_list|)
expr_stmt|;
name|BINARY_OP
argument_list|(
operator|-
argument_list|)
expr_stmt|;
name|BINARY_OP
argument_list|(
operator|<
argument_list|)
expr_stmt|;
name|BINARY_OP
argument_list|(
operator|>
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|UNARY_OP
undef|#
directive|undef
name|BINARY_OP
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"unknown operator '%c' in complex symbol"
argument_list|)
argument_list|,
operator|*
name|sym
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
end_function

begin_comment
comment|/* Entry point to evaluator, called from elf_link_input_bfd.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|evaluate_complex_relocation_symbols
parameter_list|(
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|struct
name|elf_final_link_info
modifier|*
name|finfo
parameter_list|,
name|size_t
name|locsymcount
parameter_list|)
block|{
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|asection
modifier|*
name|reloc_sec
decl_stmt|;
name|bfd_boolean
name|result
init|=
name|TRUE
decl_stmt|;
comment|/* For each section, we're going to check and see if it has any      complex relocations, and we're going to evaluate any of them      we can.  */
if|if
condition|(
name|finfo
operator|->
name|info
operator|->
name|relocatable
condition|)
return|return
name|TRUE
return|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
for|for
control|(
name|reloc_sec
operator|=
name|input_bfd
operator|->
name|sections
init|;
name|reloc_sec
condition|;
name|reloc_sec
operator|=
name|reloc_sec
operator|->
name|next
control|)
block|{
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|;
name|unsigned
name|long
name|i
decl_stmt|;
comment|/* This section was omitted from the link.  */
if|if
condition|(
operator|!
name|reloc_sec
operator|->
name|linker_mark
condition|)
continue|continue;
comment|/* Only process sections containing relocs.  */
if|if
condition|(
operator|(
name|reloc_sec
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|reloc_sec
operator|->
name|reloc_count
operator|==
literal|0
condition|)
continue|continue;
comment|/* Read in the relocs for this section.  */
name|internal_relocs
operator|=
name|_bfd_elf_link_read_relocs
argument_list|(
name|input_bfd
argument_list|,
name|reloc_sec
argument_list|,
name|NULL
argument_list|,
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
name|reloc_sec
operator|->
name|reloc_count
init|;
name|i
operator|--
condition|;
control|)
block|{
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|char
modifier|*
name|sym_name
decl_stmt|;
name|bfd_vma
name|index
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|bfd_vma
name|result
decl_stmt|;
name|bfd_vma
name|section_offset
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
name|int
name|signed_p
init|=
literal|0
decl_stmt|;
name|rel
operator|=
name|internal_relocs
operator|+
name|i
expr_stmt|;
name|section_offset
operator|=
name|reloc_sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|reloc_sec
operator|->
name|output_offset
expr_stmt|;
name|addr
operator|=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|index
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|bed
operator|->
name|s
operator|->
name|arch_size
operator|==
literal|64
condition|)
name|index
operator|>>=
literal|24
expr_stmt|;
if|if
condition|(
name|index
operator|==
name|STN_UNDEF
condition|)
continue|continue;
if|if
condition|(
name|index
operator|<
name|locsymcount
condition|)
block|{
comment|/* The symbol is local.  */
name|sym
operator|=
name|finfo
operator|->
name|internal_syms
operator|+
name|index
expr_stmt|;
comment|/* We're only processing STT_RELC or STT_SRELC type symbols.  */
if|if
condition|(
operator|(
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|!=
name|STT_RELC
operator|)
operator|&&
operator|(
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|!=
name|STT_SRELC
operator|)
condition|)
continue|continue;
name|sym_name
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_link
argument_list|,
name|sym
operator|->
name|st_name
argument_list|)
expr_stmt|;
name|signed_p
operator|=
operator|(
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_SRELC
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The symbol is global.  */
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
if|if
condition|(
name|elf_bad_symtab
argument_list|(
name|input_bfd
argument_list|)
condition|)
continue|continue;
name|h
operator|=
name|sym_hashes
index|[
name|index
operator|-
name|locsymcount
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|type
operator|!=
name|STT_RELC
operator|&&
name|h
operator|->
name|type
operator|!=
name|STT_SRELC
condition|)
continue|continue;
name|signed_p
operator|=
operator|(
name|h
operator|->
name|type
operator|==
name|STT_SRELC
operator|)
expr_stmt|;
name|sym_name
operator|=
operator|(
name|char
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"Encountered a complex symbol!"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" (input_bfd %s, section %s, reloc %ld\n"
argument_list|,
name|input_bfd
operator|->
name|filename
argument_list|,
name|reloc_sec
operator|->
name|name
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" symbol: idx  %8.8lx, name %s\n"
argument_list|,
name|index
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" reloc : info %8.8lx, addr %8.8lx\n"
argument_list|,
name|rel
operator|->
name|r_info
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" Evaluating '%s' ...\n "
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|eval_symbol
argument_list|(
operator|&
name|result
argument_list|,
name|sym_name
argument_list|,
operator|&
name|sym_name
argument_list|,
name|input_bfd
argument_list|,
name|finfo
argument_list|,
name|addr
argument_list|,
name|section_offset
argument_list|,
name|locsymcount
argument_list|,
name|signed_p
argument_list|)
condition|)
comment|/* Symbol evaluated OK.  Update to absolute value.  */
name|set_symbol_value
argument_list|(
name|input_bfd
argument_list|,
name|finfo
argument_list|,
name|index
argument_list|,
name|result
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|internal_relocs
operator|!=
name|elf_section_data
argument_list|(
name|reloc_sec
argument_list|)
operator|->
name|relocs
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
block|}
comment|/* If nothing went wrong, then we adjusted       everything we wanted to adjust.  */
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|put_value
parameter_list|(
name|bfd_vma
name|size
parameter_list|,
name|unsigned
name|long
name|chunksz
parameter_list|,
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|bfd_vma
name|x
parameter_list|,
name|bfd_byte
modifier|*
name|location
parameter_list|)
block|{
name|location
operator|+=
operator|(
name|size
operator|-
name|chunksz
operator|)
expr_stmt|;
for|for
control|(
init|;
name|size
condition|;
name|size
operator|-=
name|chunksz
operator|,
name|location
operator|-=
name|chunksz
operator|,
name|x
operator|>>=
operator|(
name|chunksz
operator|*
literal|8
operator|)
control|)
block|{
switch|switch
condition|(
name|chunksz
condition|)
block|{
default|default:
case|case
literal|0
case|:
name|abort
argument_list|()
expr_stmt|;
case|case
literal|1
case|:
name|bfd_put_8
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|location
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|location
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|location
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
ifdef|#
directive|ifdef
name|BFD64
name|bfd_put_64
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|location
argument_list|)
expr_stmt|;
else|#
directive|else
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|bfd_vma
name|get_value
parameter_list|(
name|bfd_vma
name|size
parameter_list|,
name|unsigned
name|long
name|chunksz
parameter_list|,
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|bfd_byte
modifier|*
name|location
parameter_list|)
block|{
name|bfd_vma
name|x
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|size
condition|;
name|size
operator|-=
name|chunksz
operator|,
name|location
operator|+=
name|chunksz
control|)
block|{
switch|switch
condition|(
name|chunksz
condition|)
block|{
default|default:
case|case
literal|0
case|:
name|abort
argument_list|()
expr_stmt|;
case|case
literal|1
case|:
name|x
operator|=
operator|(
name|x
operator|<<
operator|(
literal|8
operator|*
name|chunksz
operator|)
operator|)
operator||
name|bfd_get_8
argument_list|(
name|input_bfd
argument_list|,
name|location
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|x
operator|=
operator|(
name|x
operator|<<
operator|(
literal|8
operator|*
name|chunksz
operator|)
operator|)
operator||
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|location
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|x
operator|=
operator|(
name|x
operator|<<
operator|(
literal|8
operator|*
name|chunksz
operator|)
operator|)
operator||
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|location
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
ifdef|#
directive|ifdef
name|BFD64
name|x
operator|=
operator|(
name|x
operator|<<
operator|(
literal|8
operator|*
name|chunksz
operator|)
operator|)
operator||
name|bfd_get_64
argument_list|(
name|input_bfd
argument_list|,
name|location
argument_list|)
expr_stmt|;
else|#
directive|else
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
return|return
name|x
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|decode_complex_addend
parameter_list|(
name|unsigned
name|long
modifier|*
name|start
parameter_list|,
comment|/* in bits */
name|unsigned
name|long
modifier|*
name|oplen
parameter_list|,
comment|/* in bits */
name|unsigned
name|long
modifier|*
name|len
parameter_list|,
comment|/* in bits */
name|unsigned
name|long
modifier|*
name|wordsz
parameter_list|,
comment|/* in bytes */
name|unsigned
name|long
modifier|*
name|chunksz
parameter_list|,
comment|/* in bytes */
name|unsigned
name|long
modifier|*
name|lsb0_p
parameter_list|,
name|unsigned
name|long
modifier|*
name|signed_p
parameter_list|,
name|unsigned
name|long
modifier|*
name|trunc_p
parameter_list|,
name|unsigned
name|long
name|encoded
parameter_list|)
block|{
operator|*
name|start
operator|=
name|encoded
operator|&
literal|0x3F
expr_stmt|;
operator|*
name|len
operator|=
operator|(
name|encoded
operator|>>
literal|6
operator|)
operator|&
literal|0x3F
expr_stmt|;
operator|*
name|oplen
operator|=
operator|(
name|encoded
operator|>>
literal|12
operator|)
operator|&
literal|0x3F
expr_stmt|;
operator|*
name|wordsz
operator|=
operator|(
name|encoded
operator|>>
literal|18
operator|)
operator|&
literal|0xF
expr_stmt|;
operator|*
name|chunksz
operator|=
operator|(
name|encoded
operator|>>
literal|22
operator|)
operator|&
literal|0xF
expr_stmt|;
operator|*
name|lsb0_p
operator|=
operator|(
name|encoded
operator|>>
literal|27
operator|)
operator|&
literal|1
expr_stmt|;
operator|*
name|signed_p
operator|=
operator|(
name|encoded
operator|>>
literal|28
operator|)
operator|&
literal|1
expr_stmt|;
operator|*
name|trunc_p
operator|=
operator|(
name|encoded
operator|>>
literal|29
operator|)
operator|&
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bfd_elf_perform_complex_relocation
parameter_list|(
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|rel
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|local_syms
parameter_list|,
name|asection
modifier|*
modifier|*
name|local_sections
parameter_list|)
block|{
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_vma
name|relocation
init|=
literal|0
decl_stmt|,
name|shift
decl_stmt|,
name|x
decl_stmt|;
name|bfd_vma
name|r_symndx
decl_stmt|;
name|bfd_vma
name|mask
decl_stmt|;
name|unsigned
name|long
name|start
decl_stmt|,
name|oplen
decl_stmt|,
name|len
decl_stmt|,
name|wordsz
decl_stmt|,
name|chunksz
decl_stmt|,
name|lsb0_p
decl_stmt|,
name|signed_p
decl_stmt|,
name|trunc_p
decl_stmt|;
comment|/*  Perform this reloc, since it is complex.       (this is not to say that it necessarily refers to a complex       symbol; merely that it is a self-describing CGEN based reloc.       i.e. the addend has the complete reloc information (bit start, end,       word size, etc) encoded within it.).  */
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|bed
operator|->
name|s
operator|->
name|arch_size
operator|==
literal|64
condition|)
name|r_symndx
operator|>>=
literal|24
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"Performing complex relocation %ld...\n"
argument_list|,
name|r_symndx
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
comment|/* The symbol is local.  */
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|relocation
operator|=
name|sym
operator|->
name|st_value
expr_stmt|;
if|if
condition|(
name|sym
operator|->
name|st_shndx
operator|>
name|SHN_UNDEF
operator|&&
name|sym
operator|->
name|st_shndx
operator|<
name|SHN_LORESERVE
condition|)
name|relocation
operator|+=
operator|(
name|sec
operator|->
name|output_offset
operator|+
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The symbol is global.  */
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
block|{
name|sec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|relocation
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_is_abs_section
argument_list|(
name|sec
argument_list|)
condition|)
name|relocation
operator|+=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
operator|&&
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|info
operator|->
name|unresolved_syms_in_objects
operator|==
name|RM_GENERATE_ERROR
operator|||
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
argument_list|)
operator|)
condition|)
return|return;
block|}
name|decode_complex_addend
argument_list|(
operator|&
name|start
argument_list|,
operator|&
name|oplen
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|wordsz
argument_list|,
operator|&
name|chunksz
argument_list|,
operator|&
name|lsb0_p
argument_list|,
operator|&
name|signed_p
argument_list|,
operator|&
name|trunc_p
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
expr_stmt|;
name|mask
operator|=
operator|(
operator|(
operator|(
literal|1L
operator|<<
operator|(
name|len
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
operator|<<
literal|1
operator|)
operator||
literal|1
expr_stmt|;
if|if
condition|(
name|lsb0_p
condition|)
name|shift
operator|=
operator|(
name|start
operator|+
literal|1
operator|)
operator|-
name|len
expr_stmt|;
else|else
name|shift
operator|=
operator|(
literal|8
operator|*
name|wordsz
operator|)
operator|-
operator|(
name|start
operator|+
name|len
operator|)
expr_stmt|;
name|x
operator|=
name|get_value
argument_list|(
name|wordsz
argument_list|,
name|chunksz
argument_list|,
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"Doing complex reloc: "
literal|"lsb0? %ld, signed? %ld, trunc? %ld, wordsz %ld, "
literal|"chunksz %ld, start %ld, len %ld, oplen %ld\n"
literal|"    dest: %8.8lx, mask: %8.8lx, reloc: %8.8lx\n"
argument_list|,
name|lsb0_p
argument_list|,
name|signed_p
argument_list|,
name|trunc_p
argument_list|,
name|wordsz
argument_list|,
name|chunksz
argument_list|,
name|start
argument_list|,
name|len
argument_list|,
name|oplen
argument_list|,
name|x
argument_list|,
name|mask
argument_list|,
name|relocation
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|trunc_p
condition|)
block|{
comment|/* Now do an overflow check.  */
if|if
condition|(
name|bfd_check_overflow
argument_list|(
operator|(
name|signed_p
condition|?
name|complain_overflow_signed
else|:
name|complain_overflow_unsigned
operator|)
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
operator|(
literal|8
operator|*
name|wordsz
operator|)
argument_list|,
name|relocation
argument_list|)
operator|==
name|bfd_reloc_overflow
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"%s (%s + 0x%lx): relocation overflow: 0x%lx %sdoes not fit "
literal|"within 0x%lx"
argument_list|,
name|input_bfd
operator|->
name|filename
argument_list|,
name|input_section
operator|->
name|name
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|relocation
argument_list|,
operator|(
name|signed_p
condition|?
literal|"(signed) "
else|:
literal|""
operator|)
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
comment|/* Do the deed.  */
name|x
operator|=
operator|(
name|x
operator|&
operator|~
operator|(
name|mask
operator|<<
name|shift
operator|)
operator|)
operator||
operator|(
operator|(
name|relocation
operator|&
name|mask
operator|)
operator|<<
name|shift
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"           relocation: %8.8lx\n"
literal|"         shifted mask: %8.8lx\n"
literal|" shifted/masked reloc: %8.8lx\n"
literal|"               result: %8.8lx\n"
argument_list|,
name|relocation
argument_list|,
operator|(
name|mask
operator|<<
name|shift
operator|)
argument_list|,
operator|(
operator|(
name|relocation
operator|&
name|mask
operator|)
operator|<<
name|shift
operator|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|put_value
argument_list|(
name|wordsz
argument_list|,
name|chunksz
argument_list|,
name|input_bfd
argument_list|,
name|x
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* When performing a relocatable link, the input relocations are    preserved.  But, if they reference global symbols, the indices    referenced must be updated.  Update all the relocations in    REL_HDR (there are COUNT of them), using the data in REL_HASH.  */
end_comment

begin_function
specifier|static
name|void
name|elf_link_adjust_relocs
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Shdr
modifier|*
name|rel_hdr
parameter_list|,
name|unsigned
name|int
name|count
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|rel_hash
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|bfd_byte
modifier|*
name|erela
decl_stmt|;
name|void
function_decl|(
modifier|*
name|swap_in
function_decl|)
parameter_list|(
name|bfd
modifier|*
parameter_list|,
specifier|const
name|bfd_byte
modifier|*
parameter_list|,
name|Elf_Internal_Rela
modifier|*
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|swap_out
function_decl|)
parameter_list|(
name|bfd
modifier|*
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
parameter_list|,
name|bfd_byte
modifier|*
parameter_list|)
function_decl|;
name|bfd_vma
name|r_type_mask
decl_stmt|;
name|int
name|r_sym_shift
decl_stmt|;
if|if
condition|(
name|rel_hdr
operator|->
name|sh_entsize
operator|==
name|bed
operator|->
name|s
operator|->
name|sizeof_rel
condition|)
block|{
name|swap_in
operator|=
name|bed
operator|->
name|s
operator|->
name|swap_reloc_in
expr_stmt|;
name|swap_out
operator|=
name|bed
operator|->
name|s
operator|->
name|swap_reloc_out
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rel_hdr
operator|->
name|sh_entsize
operator|==
name|bed
operator|->
name|s
operator|->
name|sizeof_rela
condition|)
block|{
name|swap_in
operator|=
name|bed
operator|->
name|s
operator|->
name|swap_reloca_in
expr_stmt|;
name|swap_out
operator|=
name|bed
operator|->
name|s
operator|->
name|swap_reloca_out
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|bed
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
operator|>
name|MAX_INT_RELS_PER_EXT_REL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|bed
operator|->
name|s
operator|->
name|arch_size
operator|==
literal|32
condition|)
block|{
name|r_type_mask
operator|=
literal|0xff
expr_stmt|;
name|r_sym_shift
operator|=
literal|8
expr_stmt|;
block|}
else|else
block|{
name|r_type_mask
operator|=
literal|0xffffffff
expr_stmt|;
name|r_sym_shift
operator|=
literal|32
expr_stmt|;
block|}
name|erela
operator|=
name|rel_hdr
operator|->
name|contents
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|rel_hash
operator|++
operator|,
name|erela
operator|+=
name|rel_hdr
operator|->
name|sh_entsize
control|)
block|{
name|Elf_Internal_Rela
name|irela
index|[
name|MAX_INT_RELS_PER_EXT_REL
index|]
decl_stmt|;
name|unsigned
name|int
name|j
decl_stmt|;
if|if
condition|(
operator|*
name|rel_hash
operator|==
name|NULL
condition|)
continue|continue;
name|BFD_ASSERT
argument_list|(
operator|(
operator|*
name|rel_hash
operator|)
operator|->
name|indx
operator|>=
literal|0
argument_list|)
expr_stmt|;
call|(
modifier|*
name|swap_in
call|)
argument_list|(
name|abfd
argument_list|,
name|erela
argument_list|,
name|irela
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|bed
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
condition|;
name|j
operator|++
control|)
name|irela
index|[
name|j
index|]
operator|.
name|r_info
operator|=
operator|(
call|(
name|bfd_vma
call|)
argument_list|(
operator|*
name|rel_hash
argument_list|)
operator|->
name|indx
operator|<<
name|r_sym_shift
operator||
operator|(
name|irela
index|[
name|j
index|]
operator|.
name|r_info
operator|&
name|r_type_mask
operator|)
operator|)
expr_stmt|;
call|(
modifier|*
name|swap_out
call|)
argument_list|(
name|abfd
argument_list|,
name|irela
argument_list|,
name|erela
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_struct
struct|struct
name|elf_link_sort_rela
block|{
union|union
block|{
name|bfd_vma
name|offset
decl_stmt|;
name|bfd_vma
name|sym_mask
decl_stmt|;
block|}
name|u
union|;
name|enum
name|elf_reloc_type_class
name|type
decl_stmt|;
comment|/* We use this as an array of size int_rels_per_ext_rel.  */
name|Elf_Internal_Rela
name|rela
index|[
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|elf_link_sort_cmp1
parameter_list|(
specifier|const
name|void
modifier|*
name|A
parameter_list|,
specifier|const
name|void
modifier|*
name|B
parameter_list|)
block|{
specifier|const
name|struct
name|elf_link_sort_rela
modifier|*
name|a
init|=
name|A
decl_stmt|;
specifier|const
name|struct
name|elf_link_sort_rela
modifier|*
name|b
init|=
name|B
decl_stmt|;
name|int
name|relativea
decl_stmt|,
name|relativeb
decl_stmt|;
name|relativea
operator|=
name|a
operator|->
name|type
operator|==
name|reloc_class_relative
expr_stmt|;
name|relativeb
operator|=
name|b
operator|->
name|type
operator|==
name|reloc_class_relative
expr_stmt|;
if|if
condition|(
name|relativea
operator|<
name|relativeb
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|relativea
operator|>
name|relativeb
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|(
name|a
operator|->
name|rela
operator|->
name|r_info
operator|&
name|a
operator|->
name|u
operator|.
name|sym_mask
operator|)
operator|<
operator|(
name|b
operator|->
name|rela
operator|->
name|r_info
operator|&
name|b
operator|->
name|u
operator|.
name|sym_mask
operator|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|(
name|a
operator|->
name|rela
operator|->
name|r_info
operator|&
name|a
operator|->
name|u
operator|.
name|sym_mask
operator|)
operator|>
operator|(
name|b
operator|->
name|rela
operator|->
name|r_info
operator|&
name|b
operator|->
name|u
operator|.
name|sym_mask
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|a
operator|->
name|rela
operator|->
name|r_offset
operator|<
name|b
operator|->
name|rela
operator|->
name|r_offset
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|a
operator|->
name|rela
operator|->
name|r_offset
operator|>
name|b
operator|->
name|rela
operator|->
name|r_offset
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|elf_link_sort_cmp2
parameter_list|(
specifier|const
name|void
modifier|*
name|A
parameter_list|,
specifier|const
name|void
modifier|*
name|B
parameter_list|)
block|{
specifier|const
name|struct
name|elf_link_sort_rela
modifier|*
name|a
init|=
name|A
decl_stmt|;
specifier|const
name|struct
name|elf_link_sort_rela
modifier|*
name|b
init|=
name|B
decl_stmt|;
name|int
name|copya
decl_stmt|,
name|copyb
decl_stmt|;
if|if
condition|(
name|a
operator|->
name|u
operator|.
name|offset
operator|<
name|b
operator|->
name|u
operator|.
name|offset
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|a
operator|->
name|u
operator|.
name|offset
operator|>
name|b
operator|->
name|u
operator|.
name|offset
condition|)
return|return
literal|1
return|;
name|copya
operator|=
operator|(
name|a
operator|->
name|type
operator|==
name|reloc_class_copy
operator|)
operator|*
literal|2
operator|+
operator|(
name|a
operator|->
name|type
operator|==
name|reloc_class_plt
operator|)
expr_stmt|;
name|copyb
operator|=
operator|(
name|b
operator|->
name|type
operator|==
name|reloc_class_copy
operator|)
operator|*
literal|2
operator|+
operator|(
name|b
operator|->
name|type
operator|==
name|reloc_class_plt
operator|)
expr_stmt|;
if|if
condition|(
name|copya
operator|<
name|copyb
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|copya
operator|>
name|copyb
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|a
operator|->
name|rela
operator|->
name|r_offset
operator|<
name|b
operator|->
name|rela
operator|->
name|r_offset
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|a
operator|->
name|rela
operator|->
name|r_offset
operator|>
name|b
operator|->
name|rela
operator|->
name|r_offset
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|elf_link_sort_relocs
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|asection
modifier|*
modifier|*
name|psec
parameter_list|)
block|{
name|asection
modifier|*
name|dynamic_relocs
decl_stmt|;
name|asection
modifier|*
name|rela_dyn
decl_stmt|;
name|asection
modifier|*
name|rel_dyn
decl_stmt|;
name|bfd_size_type
name|count
decl_stmt|,
name|size
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|ret
decl_stmt|,
name|sort_elt
decl_stmt|,
name|ext_size
decl_stmt|;
name|bfd_byte
modifier|*
name|sort
decl_stmt|,
modifier|*
name|s_non_relative
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|struct
name|elf_link_sort_rela
modifier|*
name|sq
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|int
name|i2e
init|=
name|bed
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
decl_stmt|;
name|void
function_decl|(
modifier|*
name|swap_in
function_decl|)
parameter_list|(
name|bfd
modifier|*
parameter_list|,
specifier|const
name|bfd_byte
modifier|*
parameter_list|,
name|Elf_Internal_Rela
modifier|*
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|swap_out
function_decl|)
parameter_list|(
name|bfd
modifier|*
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
parameter_list|,
name|bfd_byte
modifier|*
parameter_list|)
function_decl|;
name|struct
name|bfd_link_order
modifier|*
name|lo
decl_stmt|;
name|bfd_vma
name|r_sym_mask
decl_stmt|;
name|bfd_boolean
name|use_rela
decl_stmt|;
comment|/* Find a dynamic reloc section.  */
name|rela_dyn
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".rela.dyn"
argument_list|)
expr_stmt|;
name|rel_dyn
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".rel.dyn"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rela_dyn
operator|!=
name|NULL
operator|&&
name|rela_dyn
operator|->
name|size
operator|>
literal|0
operator|&&
name|rel_dyn
operator|!=
name|NULL
operator|&&
name|rel_dyn
operator|->
name|size
operator|>
literal|0
condition|)
block|{
name|bfd_boolean
name|use_rela_initialised
init|=
name|FALSE
decl_stmt|;
comment|/* This is just here to stop gcc from complaining. 	 It's initialization checking code is not perfect.  */
name|use_rela
operator|=
name|TRUE
expr_stmt|;
comment|/* Both sections are present.  Examine the sizes 	 of the indirect sections to help us choose.  */
for|for
control|(
name|lo
operator|=
name|rela_dyn
operator|->
name|map_head
operator|.
name|link_order
init|;
name|lo
operator|!=
name|NULL
condition|;
name|lo
operator|=
name|lo
operator|->
name|next
control|)
if|if
condition|(
name|lo
operator|->
name|type
operator|==
name|bfd_indirect_link_order
condition|)
block|{
name|asection
modifier|*
name|o
init|=
name|lo
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
decl_stmt|;
if|if
condition|(
operator|(
name|o
operator|->
name|size
operator|%
name|bed
operator|->
name|s
operator|->
name|sizeof_rela
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|o
operator|->
name|size
operator|%
name|bed
operator|->
name|s
operator|->
name|sizeof_rel
operator|)
operator|==
literal|0
condition|)
comment|/* Section size is divisible by both rel and rela sizes. 		     It is of no help to us.  */
empty_stmt|;
else|else
block|{
comment|/* Section size is only divisible by rela.  */
if|if
condition|(
name|use_rela_initialised
operator|&&
operator|(
name|use_rela
operator|==
name|FALSE
operator|)
condition|)
block|{
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"%B: Unable to sort relocs - they are in more than one size"
argument_list|)
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|use_rela
operator|=
name|TRUE
expr_stmt|;
name|use_rela_initialised
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|o
operator|->
name|size
operator|%
name|bed
operator|->
name|s
operator|->
name|sizeof_rel
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Section size is only divisible by rel.  */
if|if
condition|(
name|use_rela_initialised
operator|&&
operator|(
name|use_rela
operator|==
name|TRUE
operator|)
condition|)
block|{
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"%B: Unable to sort relocs - they are in more than one size"
argument_list|)
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|use_rela
operator|=
name|FALSE
expr_stmt|;
name|use_rela_initialised
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* The section size is not divisible by either - something is wrong.  */
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"%B: Unable to sort relocs - they are of an unknown size"
argument_list|)
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
for|for
control|(
name|lo
operator|=
name|rel_dyn
operator|->
name|map_head
operator|.
name|link_order
init|;
name|lo
operator|!=
name|NULL
condition|;
name|lo
operator|=
name|lo
operator|->
name|next
control|)
if|if
condition|(
name|lo
operator|->
name|type
operator|==
name|bfd_indirect_link_order
condition|)
block|{
name|asection
modifier|*
name|o
init|=
name|lo
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
decl_stmt|;
if|if
condition|(
operator|(
name|o
operator|->
name|size
operator|%
name|bed
operator|->
name|s
operator|->
name|sizeof_rela
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|o
operator|->
name|size
operator|%
name|bed
operator|->
name|s
operator|->
name|sizeof_rel
operator|)
operator|==
literal|0
condition|)
comment|/* Section size is divisible by both rel and rela sizes. 		     It is of no help to us.  */
empty_stmt|;
else|else
block|{
comment|/* Section size is only divisible by rela.  */
if|if
condition|(
name|use_rela_initialised
operator|&&
operator|(
name|use_rela
operator|==
name|FALSE
operator|)
condition|)
block|{
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"%B: Unable to sort relocs - they are in more than one size"
argument_list|)
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|use_rela
operator|=
name|TRUE
expr_stmt|;
name|use_rela_initialised
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|o
operator|->
name|size
operator|%
name|bed
operator|->
name|s
operator|->
name|sizeof_rel
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Section size is only divisible by rel.  */
if|if
condition|(
name|use_rela_initialised
operator|&&
operator|(
name|use_rela
operator|==
name|TRUE
operator|)
condition|)
block|{
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"%B: Unable to sort relocs - they are in more than one size"
argument_list|)
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|use_rela
operator|=
name|FALSE
expr_stmt|;
name|use_rela_initialised
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* The section size is not divisible by either - something is wrong.  */
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"%B: Unable to sort relocs - they are of an unknown size"
argument_list|)
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
operator|!
name|use_rela_initialised
condition|)
comment|/* Make a guess.  */
name|use_rela
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rela_dyn
operator|!=
name|NULL
operator|&&
name|rela_dyn
operator|->
name|size
operator|>
literal|0
condition|)
name|use_rela
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|rel_dyn
operator|!=
name|NULL
operator|&&
name|rel_dyn
operator|->
name|size
operator|>
literal|0
condition|)
name|use_rela
operator|=
name|FALSE
expr_stmt|;
else|else
return|return
literal|0
return|;
if|if
condition|(
name|use_rela
condition|)
block|{
name|dynamic_relocs
operator|=
name|rela_dyn
expr_stmt|;
name|ext_size
operator|=
name|bed
operator|->
name|s
operator|->
name|sizeof_rela
expr_stmt|;
name|swap_in
operator|=
name|bed
operator|->
name|s
operator|->
name|swap_reloca_in
expr_stmt|;
name|swap_out
operator|=
name|bed
operator|->
name|s
operator|->
name|swap_reloca_out
expr_stmt|;
block|}
else|else
block|{
name|dynamic_relocs
operator|=
name|rel_dyn
expr_stmt|;
name|ext_size
operator|=
name|bed
operator|->
name|s
operator|->
name|sizeof_rel
expr_stmt|;
name|swap_in
operator|=
name|bed
operator|->
name|s
operator|->
name|swap_reloc_in
expr_stmt|;
name|swap_out
operator|=
name|bed
operator|->
name|s
operator|->
name|swap_reloc_out
expr_stmt|;
block|}
name|size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|lo
operator|=
name|dynamic_relocs
operator|->
name|map_head
operator|.
name|link_order
init|;
name|lo
operator|!=
name|NULL
condition|;
name|lo
operator|=
name|lo
operator|->
name|next
control|)
if|if
condition|(
name|lo
operator|->
name|type
operator|==
name|bfd_indirect_link_order
condition|)
name|size
operator|+=
name|lo
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|size
operator|!=
name|dynamic_relocs
operator|->
name|size
condition|)
return|return
literal|0
return|;
name|sort_elt
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|elf_link_sort_rela
argument_list|)
operator|+
operator|(
name|i2e
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Internal_Rela
argument_list|)
operator|)
expr_stmt|;
name|count
operator|=
name|dynamic_relocs
operator|->
name|size
operator|/
name|ext_size
expr_stmt|;
name|sort
operator|=
name|bfd_zmalloc
argument_list|(
name|sort_elt
operator|*
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|sort
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|warning
call|)
argument_list|(
name|info
argument_list|,
name|_
argument_list|(
literal|"Not enough memory to sort relocations"
argument_list|)
argument_list|,
literal|0
argument_list|,
name|abfd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|bed
operator|->
name|s
operator|->
name|arch_size
operator|==
literal|32
condition|)
name|r_sym_mask
operator|=
operator|~
operator|(
name|bfd_vma
operator|)
literal|0xff
expr_stmt|;
else|else
name|r_sym_mask
operator|=
operator|~
operator|(
name|bfd_vma
operator|)
literal|0xffffffff
expr_stmt|;
for|for
control|(
name|lo
operator|=
name|dynamic_relocs
operator|->
name|map_head
operator|.
name|link_order
init|;
name|lo
operator|!=
name|NULL
condition|;
name|lo
operator|=
name|lo
operator|->
name|next
control|)
if|if
condition|(
name|lo
operator|->
name|type
operator|==
name|bfd_indirect_link_order
condition|)
block|{
name|bfd_byte
modifier|*
name|erel
decl_stmt|,
modifier|*
name|erelend
decl_stmt|;
name|asection
modifier|*
name|o
init|=
name|lo
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
decl_stmt|;
if|if
condition|(
name|o
operator|->
name|contents
operator|==
name|NULL
operator|&&
name|o
operator|->
name|size
operator|!=
literal|0
condition|)
block|{
comment|/* This is a reloc section that is being handled as a normal 	       section.  See bfd_section_from_shdr.  We can't combine 	       relocs in this case.  */
name|free
argument_list|(
name|sort
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|erel
operator|=
name|o
operator|->
name|contents
expr_stmt|;
name|erelend
operator|=
name|o
operator|->
name|contents
operator|+
name|o
operator|->
name|size
expr_stmt|;
name|p
operator|=
name|sort
operator|+
name|o
operator|->
name|output_offset
operator|/
name|ext_size
operator|*
name|sort_elt
expr_stmt|;
while|while
condition|(
name|erel
operator|<
name|erelend
condition|)
block|{
name|struct
name|elf_link_sort_rela
modifier|*
name|s
init|=
operator|(
expr|struct
name|elf_link_sort_rela
operator|*
operator|)
name|p
decl_stmt|;
call|(
modifier|*
name|swap_in
call|)
argument_list|(
name|abfd
argument_list|,
name|erel
argument_list|,
name|s
operator|->
name|rela
argument_list|)
expr_stmt|;
name|s
operator|->
name|type
operator|=
call|(
modifier|*
name|bed
operator|->
name|elf_backend_reloc_type_class
call|)
argument_list|(
name|s
operator|->
name|rela
argument_list|)
expr_stmt|;
name|s
operator|->
name|u
operator|.
name|sym_mask
operator|=
name|r_sym_mask
expr_stmt|;
name|p
operator|+=
name|sort_elt
expr_stmt|;
name|erel
operator|+=
name|ext_size
expr_stmt|;
block|}
block|}
name|qsort
argument_list|(
name|sort
argument_list|,
name|count
argument_list|,
name|sort_elt
argument_list|,
name|elf_link_sort_cmp1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
name|sort
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|p
operator|+=
name|sort_elt
control|)
block|{
name|struct
name|elf_link_sort_rela
modifier|*
name|s
init|=
operator|(
expr|struct
name|elf_link_sort_rela
operator|*
operator|)
name|p
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|type
operator|!=
name|reloc_class_relative
condition|)
break|break;
block|}
name|ret
operator|=
name|i
expr_stmt|;
name|s_non_relative
operator|=
name|p
expr_stmt|;
name|sq
operator|=
operator|(
expr|struct
name|elf_link_sort_rela
operator|*
operator|)
name|s_non_relative
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|p
operator|+=
name|sort_elt
control|)
block|{
name|struct
name|elf_link_sort_rela
modifier|*
name|sp
init|=
operator|(
expr|struct
name|elf_link_sort_rela
operator|*
operator|)
name|p
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|sp
operator|->
name|rela
operator|->
name|r_info
operator|^
name|sq
operator|->
name|rela
operator|->
name|r_info
operator|)
operator|&
name|r_sym_mask
operator|)
operator|!=
literal|0
condition|)
name|sq
operator|=
name|sp
expr_stmt|;
name|sp
operator|->
name|u
operator|.
name|offset
operator|=
name|sq
operator|->
name|rela
operator|->
name|r_offset
expr_stmt|;
block|}
name|qsort
argument_list|(
name|s_non_relative
argument_list|,
name|count
operator|-
name|ret
argument_list|,
name|sort_elt
argument_list|,
name|elf_link_sort_cmp2
argument_list|)
expr_stmt|;
for|for
control|(
name|lo
operator|=
name|dynamic_relocs
operator|->
name|map_head
operator|.
name|link_order
init|;
name|lo
operator|!=
name|NULL
condition|;
name|lo
operator|=
name|lo
operator|->
name|next
control|)
if|if
condition|(
name|lo
operator|->
name|type
operator|==
name|bfd_indirect_link_order
condition|)
block|{
name|bfd_byte
modifier|*
name|erel
decl_stmt|,
modifier|*
name|erelend
decl_stmt|;
name|asection
modifier|*
name|o
init|=
name|lo
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
decl_stmt|;
name|erel
operator|=
name|o
operator|->
name|contents
expr_stmt|;
name|erelend
operator|=
name|o
operator|->
name|contents
operator|+
name|o
operator|->
name|size
expr_stmt|;
name|p
operator|=
name|sort
operator|+
name|o
operator|->
name|output_offset
operator|/
name|ext_size
operator|*
name|sort_elt
expr_stmt|;
while|while
condition|(
name|erel
operator|<
name|erelend
condition|)
block|{
name|struct
name|elf_link_sort_rela
modifier|*
name|s
init|=
operator|(
expr|struct
name|elf_link_sort_rela
operator|*
operator|)
name|p
decl_stmt|;
call|(
modifier|*
name|swap_out
call|)
argument_list|(
name|abfd
argument_list|,
name|s
operator|->
name|rela
argument_list|,
name|erel
argument_list|)
expr_stmt|;
name|p
operator|+=
name|sort_elt
expr_stmt|;
name|erel
operator|+=
name|ext_size
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|sort
argument_list|)
expr_stmt|;
operator|*
name|psec
operator|=
name|dynamic_relocs
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Flush the output symbols to the file.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_link_flush_output_syms
parameter_list|(
name|struct
name|elf_final_link_info
modifier|*
name|finfo
parameter_list|,
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
parameter_list|)
block|{
if|if
condition|(
name|finfo
operator|->
name|symbuf_count
operator|>
literal|0
condition|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
name|file_ptr
name|pos
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|pos
operator|=
name|hdr
operator|->
name|sh_offset
operator|+
name|hdr
operator|->
name|sh_size
expr_stmt|;
name|amt
operator|=
name|finfo
operator|->
name|symbuf_count
operator|*
name|bed
operator|->
name|s
operator|->
name|sizeof_sym
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|,
name|pos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bwrite
argument_list|(
name|finfo
operator|->
name|symbuf
argument_list|,
name|amt
argument_list|,
name|finfo
operator|->
name|output_bfd
argument_list|)
operator|!=
name|amt
condition|)
return|return
name|FALSE
return|;
name|hdr
operator|->
name|sh_size
operator|+=
name|amt
expr_stmt|;
name|finfo
operator|->
name|symbuf_count
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Add a symbol to the output symbol table.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_link_output_sym
parameter_list|(
name|struct
name|elf_final_link_info
modifier|*
name|finfo
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|elfsym
parameter_list|,
name|asection
modifier|*
name|input_sec
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|)
block|{
name|bfd_byte
modifier|*
name|dest
decl_stmt|;
name|Elf_External_Sym_Shndx
modifier|*
name|destshndx
decl_stmt|;
name|bfd_boolean
function_decl|(
modifier|*
name|output_symbol_hook
function_decl|)
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|Elf_Internal_Sym
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
parameter_list|)
function_decl|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|)
expr_stmt|;
name|output_symbol_hook
operator|=
name|bed
operator|->
name|elf_backend_link_output_symbol_hook
expr_stmt|;
if|if
condition|(
name|output_symbol_hook
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
call|(
modifier|*
name|output_symbol_hook
call|)
argument_list|(
name|finfo
operator|->
name|info
argument_list|,
name|name
argument_list|,
name|elfsym
argument_list|,
name|input_sec
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|name
operator|==
name|NULL
operator|||
operator|*
name|name
operator|==
literal|'\0'
condition|)
name|elfsym
operator|->
name|st_name
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|input_sec
operator|->
name|flags
operator|&
name|SEC_EXCLUDE
condition|)
name|elfsym
operator|->
name|st_name
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|elfsym
operator|->
name|st_name
operator|=
operator|(
name|unsigned
name|long
operator|)
name|_bfd_stringtab_add
argument_list|(
name|finfo
operator|->
name|symstrtab
argument_list|,
name|name
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|elfsym
operator|->
name|st_name
operator|==
operator|(
name|unsigned
name|long
operator|)
operator|-
literal|1
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|finfo
operator|->
name|symbuf_count
operator|>=
name|finfo
operator|->
name|symbuf_size
condition|)
block|{
if|if
condition|(
operator|!
name|elf_link_flush_output_syms
argument_list|(
name|finfo
argument_list|,
name|bed
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
name|dest
operator|=
name|finfo
operator|->
name|symbuf
operator|+
name|finfo
operator|->
name|symbuf_count
operator|*
name|bed
operator|->
name|s
operator|->
name|sizeof_sym
expr_stmt|;
name|destshndx
operator|=
name|finfo
operator|->
name|symshndxbuf
expr_stmt|;
if|if
condition|(
name|destshndx
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|bfd_get_symcount
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|)
operator|>=
name|finfo
operator|->
name|shndxbuf_size
condition|)
block|{
name|bfd_size_type
name|amt
decl_stmt|;
name|amt
operator|=
name|finfo
operator|->
name|shndxbuf_size
operator|*
sizeof|sizeof
argument_list|(
name|Elf_External_Sym_Shndx
argument_list|)
expr_stmt|;
name|finfo
operator|->
name|symshndxbuf
operator|=
name|destshndx
operator|=
name|bfd_realloc
argument_list|(
name|destshndx
argument_list|,
name|amt
operator|*
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|destshndx
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|destshndx
operator|+
name|amt
argument_list|,
literal|0
argument_list|,
name|amt
argument_list|)
expr_stmt|;
name|finfo
operator|->
name|shndxbuf_size
operator|*=
literal|2
expr_stmt|;
block|}
name|destshndx
operator|+=
name|bfd_get_symcount
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|)
expr_stmt|;
block|}
name|bed
operator|->
name|s
operator|->
name|swap_symbol_out
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|,
name|elfsym
argument_list|,
name|dest
argument_list|,
name|destshndx
argument_list|)
expr_stmt|;
name|finfo
operator|->
name|symbuf_count
operator|+=
literal|1
expr_stmt|;
name|bfd_get_symcount
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|)
operator|+=
literal|1
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if the dynamic symbol SYM in ABFD is supported.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|check_dynsym
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|)
block|{
if|if
condition|(
name|sym
operator|->
name|st_shndx
operator|>
name|SHN_HIRESERVE
condition|)
block|{
comment|/* The gABI doesn't support dynamic symbols in output sections          beyond 64k.  */
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: Too many sections: %d (>= %d)"
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|bfd_count_sections
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|SHN_LORESERVE
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_nonrepresentable_section
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* For DSOs loaded in via a DT_NEEDED entry, emulate ld.so in    allowing an unsatisfied unversioned symbol in the DSO to match a    versioned symbol that would normally require an explicit version.    We also handle the case that a DSO references a hidden symbol    which may be satisfied by a versioned symbol in another DSO.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_link_check_versioned_symbol
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|)
block|{
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|elf_link_loaded_list
modifier|*
name|loaded
decl_stmt|;
if|if
condition|(
operator|!
name|is_elf_hash_table
argument_list|(
name|info
operator|->
name|hash
argument_list|)
condition|)
return|return
name|FALSE
return|;
switch|switch
condition|(
name|h
operator|->
name|root
operator|.
name|type
condition|)
block|{
default|default:
name|abfd
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|bfd_link_hash_undefined
case|:
case|case
name|bfd_link_hash_undefweak
case|:
name|abfd
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|undef
operator|.
name|abfd
expr_stmt|;
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|==
literal|0
operator|||
operator|(
name|elf_dyn_lib_class
argument_list|(
name|abfd
argument_list|)
operator|&
name|DYN_DT_NEEDED
operator|)
operator|==
literal|0
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|bfd_link_hash_defined
case|:
case|case
name|bfd_link_hash_defweak
case|:
name|abfd
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
expr_stmt|;
break|break;
case|case
name|bfd_link_hash_common
case|:
name|abfd
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
operator|->
name|owner
expr_stmt|;
break|break;
block|}
name|BFD_ASSERT
argument_list|(
name|abfd
operator|!=
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|loaded
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|loaded
init|;
name|loaded
operator|!=
name|NULL
condition|;
name|loaded
operator|=
name|loaded
operator|->
name|next
control|)
block|{
name|bfd
modifier|*
name|input
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
name|bfd_size_type
name|symcount
decl_stmt|;
name|bfd_size_type
name|extsymcount
decl_stmt|;
name|bfd_size_type
name|extsymoff
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|versymhdr
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isym
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymend
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymbuf
decl_stmt|;
name|Elf_External_Versym
modifier|*
name|ever
decl_stmt|;
name|Elf_External_Versym
modifier|*
name|extversym
decl_stmt|;
name|input
operator|=
name|loaded
operator|->
name|abfd
expr_stmt|;
comment|/* We check each DSO for a possible hidden versioned definition.  */
if|if
condition|(
name|input
operator|==
name|abfd
operator|||
operator|(
name|input
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|==
literal|0
operator|||
name|elf_dynversym
argument_list|(
name|input
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input
argument_list|)
operator|->
name|dynsymtab_hdr
expr_stmt|;
name|symcount
operator|=
name|hdr
operator|->
name|sh_size
operator|/
name|bed
operator|->
name|s
operator|->
name|sizeof_sym
expr_stmt|;
if|if
condition|(
name|elf_bad_symtab
argument_list|(
name|input
argument_list|)
condition|)
block|{
name|extsymcount
operator|=
name|symcount
expr_stmt|;
name|extsymoff
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|extsymcount
operator|=
name|symcount
operator|-
name|hdr
operator|->
name|sh_info
expr_stmt|;
name|extsymoff
operator|=
name|hdr
operator|->
name|sh_info
expr_stmt|;
block|}
if|if
condition|(
name|extsymcount
operator|==
literal|0
condition|)
continue|continue;
name|isymbuf
operator|=
name|bfd_elf_get_elf_syms
argument_list|(
name|input
argument_list|,
name|hdr
argument_list|,
name|extsymcount
argument_list|,
name|extsymoff
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* Read in any version definitions.  */
name|versymhdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input
argument_list|)
operator|->
name|dynversym_hdr
expr_stmt|;
name|extversym
operator|=
name|bfd_malloc
argument_list|(
name|versymhdr
operator|->
name|sh_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|extversym
operator|==
name|NULL
condition|)
goto|goto
name|error_ret
goto|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|input
argument_list|,
name|versymhdr
operator|->
name|sh_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|bfd_bread
argument_list|(
name|extversym
argument_list|,
name|versymhdr
operator|->
name|sh_size
argument_list|,
name|input
argument_list|)
operator|!=
name|versymhdr
operator|->
name|sh_size
operator|)
condition|)
block|{
name|free
argument_list|(
name|extversym
argument_list|)
expr_stmt|;
name|error_ret
label|:
name|free
argument_list|(
name|isymbuf
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|ever
operator|=
name|extversym
operator|+
name|extsymoff
expr_stmt|;
name|isymend
operator|=
name|isymbuf
operator|+
name|extsymcount
expr_stmt|;
for|for
control|(
name|isym
operator|=
name|isymbuf
init|;
name|isym
operator|<
name|isymend
condition|;
name|isym
operator|++
operator|,
name|ever
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|Elf_Internal_Versym
name|iver
decl_stmt|;
name|unsigned
name|short
name|version_index
decl_stmt|;
if|if
condition|(
name|ELF_ST_BIND
argument_list|(
name|isym
operator|->
name|st_info
argument_list|)
operator|==
name|STB_LOCAL
operator|||
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_UNDEF
condition|)
continue|continue;
name|name
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|input
argument_list|,
name|hdr
operator|->
name|sh_link
argument_list|,
name|isym
operator|->
name|st_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|_bfd_elf_swap_versym_in
argument_list|(
name|input
argument_list|,
name|ever
argument_list|,
operator|&
name|iver
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|iver
operator|.
name|vs_vers
operator|&
name|VERSYM_HIDDEN
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* If we have a non-hidden versioned sym, then it should 		 have provided a definition for the undefined sym.  */
name|abort
argument_list|()
expr_stmt|;
block|}
name|version_index
operator|=
name|iver
operator|.
name|vs_vers
operator|&
name|VERSYM_VERSION
expr_stmt|;
if|if
condition|(
name|version_index
operator|==
literal|1
operator|||
name|version_index
operator|==
literal|2
condition|)
block|{
comment|/* This is the base or first version.  We can use it.  */
name|free
argument_list|(
name|extversym
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|isymbuf
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
name|free
argument_list|(
name|extversym
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|isymbuf
argument_list|)
expr_stmt|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Add an external symbol to the symbol table.  This is called from    the hash table traversal routine.  When generating a shared object,    we go through the symbol table twice.  The first time we output    anything that might have been forced to local scope in a version    script.  The second time we output the symbols that are still    global symbols.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_link_output_extsym
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|elf_outext_info
modifier|*
name|eoinfo
init|=
name|data
decl_stmt|;
name|struct
name|elf_final_link_info
modifier|*
name|finfo
init|=
name|eoinfo
operator|->
name|finfo
decl_stmt|;
name|bfd_boolean
name|strip
decl_stmt|;
name|Elf_Internal_Sym
name|sym
decl_stmt|;
name|asection
modifier|*
name|input_sec
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
block|{
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_new
condition|)
return|return
name|TRUE
return|;
block|}
comment|/* Decide whether to output this symbol in this pass.  */
if|if
condition|(
name|eoinfo
operator|->
name|localsyms
condition|)
block|{
if|if
condition|(
operator|!
name|h
operator|->
name|forced_local
condition|)
return|return
name|TRUE
return|;
block|}
else|else
block|{
if|if
condition|(
name|h
operator|->
name|forced_local
condition|)
return|return
name|TRUE
return|;
block|}
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
condition|)
block|{
comment|/* If we have an undefined symbol reference here then it must have 	 come from a shared library that is being linked in.  (Undefined 	 references in regular files have already been handled).  */
name|bfd_boolean
name|ignore_undef
init|=
name|FALSE
decl_stmt|;
comment|/* Some symbols may be special in that the fact that they're 	 undefined can be safely ignored - let backend determine that.  */
if|if
condition|(
name|bed
operator|->
name|elf_backend_ignore_undef_symbol
condition|)
name|ignore_undef
operator|=
name|bed
operator|->
name|elf_backend_ignore_undef_symbol
argument_list|(
name|h
argument_list|)
expr_stmt|;
comment|/* If we are reporting errors for this situation then do so now.  */
if|if
condition|(
name|ignore_undef
operator|==
name|FALSE
operator|&&
name|h
operator|->
name|ref_dynamic
operator|&&
operator|!
name|h
operator|->
name|ref_regular
operator|&&
operator|!
name|elf_link_check_versioned_symbol
argument_list|(
name|finfo
operator|->
name|info
argument_list|,
name|bed
argument_list|,
name|h
argument_list|)
operator|&&
name|finfo
operator|->
name|info
operator|->
name|unresolved_syms_in_shared_libs
operator|!=
name|RM_IGNORE
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|finfo
operator|->
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
argument_list|(
name|finfo
operator|->
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|undef
operator|.
name|abfd
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|finfo
operator|->
name|info
operator|->
name|unresolved_syms_in_shared_libs
operator|==
name|RM_GENERATE_ERROR
argument_list|)
operator|)
condition|)
block|{
name|eoinfo
operator|->
name|failed
operator|=
name|TRUE
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
block|}
comment|/* We should also warn if a forced local symbol is referenced from      shared libraries.  */
if|if
condition|(
operator|!
name|finfo
operator|->
name|info
operator|->
name|relocatable
operator|&&
operator|(
operator|!
name|finfo
operator|->
name|info
operator|->
name|shared
operator|)
operator|&&
name|h
operator|->
name|forced_local
operator|&&
name|h
operator|->
name|ref_dynamic
operator|&&
operator|!
name|h
operator|->
name|dynamic_def
operator|&&
operator|!
name|h
operator|->
name|dynamic_weak
operator|&&
operator|!
name|elf_link_check_versioned_symbol
argument_list|(
name|finfo
operator|->
name|info
argument_list|,
name|bed
argument_list|,
name|h
argument_list|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: %s symbol `%s' in %B is referenced by DSO"
argument_list|)
argument_list|,
name|finfo
operator|->
name|output_bfd
argument_list|,
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|==
name|bfd_abs_section_ptr
condition|?
name|finfo
operator|->
name|output_bfd
else|:
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
argument_list|,
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_INTERNAL
condition|?
literal|"internal"
else|:
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_HIDDEN
condition|?
literal|"hidden"
else|:
literal|"local"
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
name|eoinfo
operator|->
name|failed
operator|=
name|TRUE
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* We don't want to output symbols that have never been mentioned by      a regular file, or that we have been told to strip.  However, if      h->indx is set to -2, the symbol is used by a reloc and we must      output it.  */
if|if
condition|(
name|h
operator|->
name|indx
operator|==
operator|-
literal|2
condition|)
name|strip
operator|=
name|FALSE
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|h
operator|->
name|def_dynamic
operator|||
name|h
operator|->
name|ref_dynamic
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_new
operator|)
operator|&&
operator|!
name|h
operator|->
name|def_regular
operator|&&
operator|!
name|h
operator|->
name|ref_regular
condition|)
name|strip
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|finfo
operator|->
name|info
operator|->
name|strip
operator|==
name|strip_all
condition|)
name|strip
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|finfo
operator|->
name|info
operator|->
name|strip
operator|==
name|strip_some
operator|&&
name|bfd_hash_lookup
argument_list|(
name|finfo
operator|->
name|info
operator|->
name|keep_hash
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
operator|==
name|NULL
condition|)
name|strip
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|finfo
operator|->
name|info
operator|->
name|strip_discarded
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
name|elf_discarded_section
argument_list|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
argument_list|)
condition|)
name|strip
operator|=
name|TRUE
expr_stmt|;
else|else
name|strip
operator|=
name|FALSE
expr_stmt|;
comment|/* If we're stripping it, and it's not a dynamic symbol, there's      nothing else to do unless it is a forced local symbol.  */
if|if
condition|(
name|strip
operator|&&
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|&&
operator|!
name|h
operator|->
name|forced_local
condition|)
return|return
name|TRUE
return|;
name|sym
operator|.
name|st_value
operator|=
literal|0
expr_stmt|;
name|sym
operator|.
name|st_size
operator|=
name|h
operator|->
name|size
expr_stmt|;
name|sym
operator|.
name|st_other
operator|=
name|h
operator|->
name|other
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|forced_local
condition|)
name|sym
operator|.
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_LOCAL
argument_list|,
name|h
operator|->
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
name|sym
operator|.
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_WEAK
argument_list|,
name|h
operator|->
name|type
argument_list|)
expr_stmt|;
else|else
name|sym
operator|.
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_GLOBAL
argument_list|,
name|h
operator|->
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|h
operator|->
name|root
operator|.
name|type
condition|)
block|{
default|default:
case|case
name|bfd_link_hash_new
case|:
case|case
name|bfd_link_hash_warning
case|:
name|abort
argument_list|()
expr_stmt|;
return|return
name|FALSE
return|;
case|case
name|bfd_link_hash_undefined
case|:
case|case
name|bfd_link_hash_undefweak
case|:
name|input_sec
operator|=
name|bfd_und_section_ptr
expr_stmt|;
name|sym
operator|.
name|st_shndx
operator|=
name|SHN_UNDEF
expr_stmt|;
break|break;
case|case
name|bfd_link_hash_defined
case|:
case|case
name|bfd_link_hash_defweak
case|:
block|{
name|input_sec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
if|if
condition|(
name|input_sec
operator|->
name|output_section
operator|!=
name|NULL
condition|)
block|{
name|sym
operator|.
name|st_shndx
operator|=
name|_bfd_elf_section_from_bfd_section
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|,
name|input_sec
operator|->
name|output_section
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|.
name|st_shndx
operator|==
name|SHN_BAD
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: could not find output section %A for input section %A"
argument_list|)
argument_list|,
name|finfo
operator|->
name|output_bfd
argument_list|,
name|input_sec
operator|->
name|output_section
argument_list|,
name|input_sec
argument_list|)
expr_stmt|;
name|eoinfo
operator|->
name|failed
operator|=
name|TRUE
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* ELF symbols in relocatable files are section relative, 	       but in nonrelocatable files they are virtual 	       addresses.  */
name|sym
operator|.
name|st_value
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|input_sec
operator|->
name|output_offset
expr_stmt|;
if|if
condition|(
operator|!
name|finfo
operator|->
name|info
operator|->
name|relocatable
condition|)
block|{
name|sym
operator|.
name|st_value
operator|+=
name|input_sec
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|type
operator|==
name|STT_TLS
condition|)
block|{
comment|/* STT_TLS symbols are relative to PT_TLS segment 		       base.  */
name|BFD_ASSERT
argument_list|(
name|elf_hash_table
argument_list|(
name|finfo
operator|->
name|info
argument_list|)
operator|->
name|tls_sec
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|sym
operator|.
name|st_value
operator|-=
name|elf_hash_table
argument_list|(
name|finfo
operator|->
name|info
argument_list|)
operator|->
name|tls_sec
operator|->
name|vma
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|BFD_ASSERT
argument_list|(
name|input_sec
operator|->
name|owner
operator|==
name|NULL
operator|||
operator|(
name|input_sec
operator|->
name|owner
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|sym
operator|.
name|st_shndx
operator|=
name|SHN_UNDEF
expr_stmt|;
name|input_sec
operator|=
name|bfd_und_section_ptr
expr_stmt|;
block|}
block|}
break|break;
case|case
name|bfd_link_hash_common
case|:
name|input_sec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
expr_stmt|;
name|sym
operator|.
name|st_shndx
operator|=
name|bed
operator|->
name|common_section_index
argument_list|(
name|input_sec
argument_list|)
expr_stmt|;
name|sym
operator|.
name|st_value
operator|=
literal|1
operator|<<
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|alignment_power
expr_stmt|;
break|break;
case|case
name|bfd_link_hash_indirect
case|:
comment|/* These symbols are created by symbol versioning.  They point 	 to the decorated version of the name.  For example, if the 	 symbol foo@@GNU_1.2 is the default, which should be used when 	 foo is used with no version, then we add an indirect symbol 	 foo which points to foo@@GNU_1.2.  We ignore these symbols, 	 since the indirected symbol is already in the hash table.  */
return|return
name|TRUE
return|;
block|}
comment|/* Give the processor backend a chance to tweak the symbol value,      and also to finish up anything that needs to be done for this      symbol.  FIXME: Not calling elf_backend_finish_dynamic_symbol for      forced local syms when non-shared is due to a historical quirk.  */
if|if
condition|(
operator|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|||
name|h
operator|->
name|forced_local
operator|)
operator|&&
operator|(
operator|(
name|finfo
operator|->
name|info
operator|->
name|shared
operator|&&
operator|(
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_DEFAULT
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefweak
operator|)
operator|)
operator|||
operator|!
name|h
operator|->
name|forced_local
operator|)
operator|&&
name|elf_hash_table
argument_list|(
name|finfo
operator|->
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|bed
operator|->
name|elf_backend_finish_dynamic_symbol
call|)
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|,
name|finfo
operator|->
name|info
argument_list|,
name|h
argument_list|,
operator|&
name|sym
argument_list|)
operator|)
condition|)
block|{
name|eoinfo
operator|->
name|failed
operator|=
name|TRUE
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
comment|/* If we are marking the symbol as undefined, and there are no      non-weak references to this symbol from a regular object, then      mark the symbol as weak undefined; if there are non-weak      references, mark the symbol as strong.  We can't do this earlier,      because it might not be marked as undefined until the      finish_dynamic_symbol routine gets through with it.  */
if|if
condition|(
name|sym
operator|.
name|st_shndx
operator|==
name|SHN_UNDEF
operator|&&
name|h
operator|->
name|ref_regular
operator|&&
operator|(
name|ELF_ST_BIND
argument_list|(
name|sym
operator|.
name|st_info
argument_list|)
operator|==
name|STB_GLOBAL
operator|||
name|ELF_ST_BIND
argument_list|(
name|sym
operator|.
name|st_info
argument_list|)
operator|==
name|STB_WEAK
operator|)
condition|)
block|{
name|int
name|bindtype
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|ref_regular_nonweak
condition|)
name|bindtype
operator|=
name|STB_GLOBAL
expr_stmt|;
else|else
name|bindtype
operator|=
name|STB_WEAK
expr_stmt|;
name|sym
operator|.
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|bindtype
argument_list|,
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|.
name|st_info
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If a non-weak symbol with non-default visibility is not defined      locally, it is a fatal error.  */
if|if
condition|(
operator|!
name|finfo
operator|->
name|info
operator|->
name|relocatable
operator|&&
name|ELF_ST_VISIBILITY
argument_list|(
name|sym
operator|.
name|st_other
argument_list|)
operator|!=
name|STV_DEFAULT
operator|&&
name|ELF_ST_BIND
argument_list|(
name|sym
operator|.
name|st_info
argument_list|)
operator|!=
name|STB_WEAK
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
operator|&&
operator|!
name|h
operator|->
name|def_regular
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: %s symbol `%s' isn't defined"
argument_list|)
argument_list|,
name|finfo
operator|->
name|output_bfd
argument_list|,
name|ELF_ST_VISIBILITY
argument_list|(
name|sym
operator|.
name|st_other
argument_list|)
operator|==
name|STV_PROTECTED
condition|?
literal|"protected"
else|:
name|ELF_ST_VISIBILITY
argument_list|(
name|sym
operator|.
name|st_other
argument_list|)
operator|==
name|STV_INTERNAL
condition|?
literal|"internal"
else|:
literal|"hidden"
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
name|eoinfo
operator|->
name|failed
operator|=
name|TRUE
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* If this symbol should be put in the .dynsym section, then put it      there now.  We already know the symbol index.  We also fill in      the entry in the .hash section.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|&&
name|elf_hash_table
argument_list|(
name|finfo
operator|->
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
name|bfd_byte
modifier|*
name|esym
decl_stmt|;
name|sym
operator|.
name|st_name
operator|=
name|h
operator|->
name|dynstr_index
expr_stmt|;
name|esym
operator|=
name|finfo
operator|->
name|dynsym_sec
operator|->
name|contents
operator|+
name|h
operator|->
name|dynindx
operator|*
name|bed
operator|->
name|s
operator|->
name|sizeof_sym
expr_stmt|;
if|if
condition|(
operator|!
name|check_dynsym
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|,
operator|&
name|sym
argument_list|)
condition|)
block|{
name|eoinfo
operator|->
name|failed
operator|=
name|TRUE
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|bed
operator|->
name|s
operator|->
name|swap_symbol_out
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|,
operator|&
name|sym
argument_list|,
name|esym
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|->
name|hash_sec
operator|!=
name|NULL
condition|)
block|{
name|size_t
name|hash_entry_size
decl_stmt|;
name|bfd_byte
modifier|*
name|bucketpos
decl_stmt|;
name|bfd_vma
name|chain
decl_stmt|;
name|size_t
name|bucketcount
decl_stmt|;
name|size_t
name|bucket
decl_stmt|;
name|bucketcount
operator|=
name|elf_hash_table
argument_list|(
name|finfo
operator|->
name|info
argument_list|)
operator|->
name|bucketcount
expr_stmt|;
name|bucket
operator|=
name|h
operator|->
name|u
operator|.
name|elf_hash_value
operator|%
name|bucketcount
expr_stmt|;
name|hash_entry_size
operator|=
name|elf_section_data
argument_list|(
name|finfo
operator|->
name|hash_sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
expr_stmt|;
name|bucketpos
operator|=
operator|(
operator|(
name|bfd_byte
operator|*
operator|)
name|finfo
operator|->
name|hash_sec
operator|->
name|contents
operator|+
operator|(
name|bucket
operator|+
literal|2
operator|)
operator|*
name|hash_entry_size
operator|)
expr_stmt|;
name|chain
operator|=
name|bfd_get
argument_list|(
literal|8
operator|*
name|hash_entry_size
argument_list|,
name|finfo
operator|->
name|output_bfd
argument_list|,
name|bucketpos
argument_list|)
expr_stmt|;
name|bfd_put
argument_list|(
literal|8
operator|*
name|hash_entry_size
argument_list|,
name|finfo
operator|->
name|output_bfd
argument_list|,
name|h
operator|->
name|dynindx
argument_list|,
name|bucketpos
argument_list|)
expr_stmt|;
name|bfd_put
argument_list|(
literal|8
operator|*
name|hash_entry_size
argument_list|,
name|finfo
operator|->
name|output_bfd
argument_list|,
name|chain
argument_list|,
operator|(
operator|(
name|bfd_byte
operator|*
operator|)
name|finfo
operator|->
name|hash_sec
operator|->
name|contents
operator|+
operator|(
name|bucketcount
operator|+
literal|2
operator|+
name|h
operator|->
name|dynindx
operator|)
operator|*
name|hash_entry_size
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|finfo
operator|->
name|symver_sec
operator|!=
name|NULL
operator|&&
name|finfo
operator|->
name|symver_sec
operator|->
name|contents
operator|!=
name|NULL
condition|)
block|{
name|Elf_Internal_Versym
name|iversym
decl_stmt|;
name|Elf_External_Versym
modifier|*
name|eversym
decl_stmt|;
if|if
condition|(
operator|!
name|h
operator|->
name|def_regular
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|verinfo
operator|.
name|verdef
operator|==
name|NULL
condition|)
name|iversym
operator|.
name|vs_vers
operator|=
literal|0
expr_stmt|;
else|else
name|iversym
operator|.
name|vs_vers
operator|=
name|h
operator|->
name|verinfo
operator|.
name|verdef
operator|->
name|vd_exp_refno
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|h
operator|->
name|verinfo
operator|.
name|vertree
operator|==
name|NULL
condition|)
name|iversym
operator|.
name|vs_vers
operator|=
literal|1
expr_stmt|;
else|else
name|iversym
operator|.
name|vs_vers
operator|=
name|h
operator|->
name|verinfo
operator|.
name|vertree
operator|->
name|vernum
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|finfo
operator|->
name|info
operator|->
name|create_default_symver
condition|)
name|iversym
operator|.
name|vs_vers
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|->
name|hidden
condition|)
name|iversym
operator|.
name|vs_vers
operator||=
name|VERSYM_HIDDEN
expr_stmt|;
name|eversym
operator|=
operator|(
name|Elf_External_Versym
operator|*
operator|)
name|finfo
operator|->
name|symver_sec
operator|->
name|contents
expr_stmt|;
name|eversym
operator|+=
name|h
operator|->
name|dynindx
expr_stmt|;
name|_bfd_elf_swap_versym_out
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|,
operator|&
name|iversym
argument_list|,
name|eversym
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If we're stripping it, then it was just a dynamic symbol, and      there's nothing else to do.  */
if|if
condition|(
name|strip
operator|||
operator|(
name|input_sec
operator|->
name|flags
operator|&
name|SEC_EXCLUDE
operator|)
operator|!=
literal|0
condition|)
return|return
name|TRUE
return|;
name|h
operator|->
name|indx
operator|=
name|bfd_get_symcount
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|elf_link_output_sym
argument_list|(
name|finfo
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
operator|&
name|sym
argument_list|,
name|input_sec
argument_list|,
name|h
argument_list|)
condition|)
block|{
name|eoinfo
operator|->
name|failed
operator|=
name|TRUE
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if special handling is done for relocs in SEC against    symbols defined in discarded sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_section_ignore_discarded_relocs
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|)
block|{
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
switch|switch
condition|(
name|sec
operator|->
name|sec_info_type
condition|)
block|{
case|case
name|ELF_INFO_TYPE_STABS
case|:
case|case
name|ELF_INFO_TYPE_EH_FRAME
case|:
return|return
name|TRUE
return|;
default|default:
break|break;
block|}
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|sec
operator|->
name|owner
argument_list|)
expr_stmt|;
if|if
condition|(
name|bed
operator|->
name|elf_backend_ignore_discarded_relocs
operator|!=
name|NULL
operator|&&
call|(
modifier|*
name|bed
operator|->
name|elf_backend_ignore_discarded_relocs
call|)
argument_list|(
name|sec
argument_list|)
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Return a mask saying how ld should treat relocations in SEC against    symbols defined in discarded sections.  If this function returns    COMPLAIN set, ld will issue a warning message.  If this function    returns PRETEND set, and the discarded section was link-once and the    same size as the kept link-once section, ld will pretend that the    symbol was actually defined in the kept section.  Otherwise ld will    zero the reloc (at least that is the intent, but some cooperation by    the target dependent code is needed, particularly for REL targets).  */
end_comment

begin_function
name|unsigned
name|int
name|_bfd_elf_default_action_discarded
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|)
block|{
if|if
condition|(
name|sec
operator|->
name|flags
operator|&
name|SEC_DEBUGGING
condition|)
return|return
name|PRETEND
return|;
if|if
condition|(
name|strcmp
argument_list|(
literal|".eh_frame"
argument_list|,
name|sec
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|strcmp
argument_list|(
literal|".gcc_except_table"
argument_list|,
name|sec
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|COMPLAIN
operator||
name|PRETEND
return|;
block|}
end_function

begin_comment
comment|/* Find a match between a section and a member of a section group.  */
end_comment

begin_function
specifier|static
name|asection
modifier|*
name|match_group_member
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|,
name|asection
modifier|*
name|group
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|asection
modifier|*
name|first
init|=
name|elf_next_in_group
argument_list|(
name|group
argument_list|)
decl_stmt|;
name|asection
modifier|*
name|s
init|=
name|first
decl_stmt|;
while|while
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|bfd_elf_match_symbols_in_sections
argument_list|(
name|s
argument_list|,
name|sec
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|s
return|;
name|s
operator|=
name|elf_next_in_group
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|first
condition|)
break|break;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Check if the kept section of a discarded section SEC can be used    to replace it.  Return the replacement if it is OK.  Otherwise return    NULL.  */
end_comment

begin_function
name|asection
modifier|*
name|_bfd_elf_check_kept_section
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|asection
modifier|*
name|kept
decl_stmt|;
name|kept
operator|=
name|sec
operator|->
name|kept_section
expr_stmt|;
if|if
condition|(
name|kept
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|kept
operator|->
name|flags
operator|&
name|SEC_GROUP
operator|)
operator|!=
literal|0
condition|)
name|kept
operator|=
name|match_group_member
argument_list|(
name|sec
argument_list|,
name|kept
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|kept
operator|!=
name|NULL
operator|&&
name|sec
operator|->
name|size
operator|!=
name|kept
operator|->
name|size
condition|)
name|kept
operator|=
name|NULL
expr_stmt|;
name|sec
operator|->
name|kept_section
operator|=
name|kept
expr_stmt|;
block|}
return|return
name|kept
return|;
block|}
end_function

begin_comment
comment|/* Link an input file into the linker output file.  This function    handles all the sections and relocations of the input file at once.    This is so that we only have to read the local symbols once, and    don't have to keep them in memory.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_link_input_bfd
parameter_list|(
name|struct
name|elf_final_link_info
modifier|*
name|finfo
parameter_list|,
name|bfd
modifier|*
name|input_bfd
parameter_list|)
block|{
name|int
function_decl|(
modifier|*
name|relocate_section
function_decl|)
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd_byte
modifier|*
parameter_list|,
name|Elf_Internal_Rela
modifier|*
parameter_list|,
name|Elf_Internal_Sym
modifier|*
parameter_list|,
name|asection
modifier|*
modifier|*
parameter_list|)
function_decl|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|size_t
name|locsymcount
decl_stmt|;
name|size_t
name|extsymoff
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymbuf
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isym
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymend
decl_stmt|;
name|long
modifier|*
name|pindex
decl_stmt|;
name|asection
modifier|*
modifier|*
name|ppsection
decl_stmt|;
name|asection
modifier|*
name|o
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|output_bfd
operator|=
name|finfo
operator|->
name|output_bfd
expr_stmt|;
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
name|relocate_section
operator|=
name|bed
operator|->
name|elf_backend_relocate_section
expr_stmt|;
comment|/* If this is a dynamic object, we don't want to do anything here:      we don't want the local symbols, and we don't want the section      contents.  */
if|if
condition|(
operator|(
name|input_bfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
condition|)
return|return
name|TRUE
return|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
if|if
condition|(
name|elf_bad_symtab
argument_list|(
name|input_bfd
argument_list|)
condition|)
block|{
name|locsymcount
operator|=
name|symtab_hdr
operator|->
name|sh_size
operator|/
name|bed
operator|->
name|s
operator|->
name|sizeof_sym
expr_stmt|;
name|extsymoff
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|locsymcount
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|extsymoff
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
block|}
comment|/* Read the local symbols.  */
name|isymbuf
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
operator|&&
name|locsymcount
operator|!=
literal|0
condition|)
block|{
name|isymbuf
operator|=
name|bfd_elf_get_elf_syms
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
argument_list|,
name|locsymcount
argument_list|,
literal|0
argument_list|,
name|finfo
operator|->
name|internal_syms
argument_list|,
name|finfo
operator|->
name|external_syms
argument_list|,
name|finfo
operator|->
name|locsym_shndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* evaluate_complex_relocation_symbols looks for symbols in      finfo->internal_syms.  */
elseif|else
if|if
condition|(
name|isymbuf
operator|!=
name|NULL
operator|&&
name|locsymcount
operator|!=
literal|0
condition|)
block|{
name|bfd_elf_get_elf_syms
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
argument_list|,
name|locsymcount
argument_list|,
literal|0
argument_list|,
name|finfo
operator|->
name|internal_syms
argument_list|,
name|finfo
operator|->
name|external_syms
argument_list|,
name|finfo
operator|->
name|locsym_shndx
argument_list|)
expr_stmt|;
block|}
comment|/* Find local symbol sections and adjust values of symbols in      SEC_MERGE sections.  Write out those local symbols we know are      going into the output file.  */
name|isymend
operator|=
name|isymbuf
operator|+
name|locsymcount
expr_stmt|;
for|for
control|(
name|isym
operator|=
name|isymbuf
operator|,
name|pindex
operator|=
name|finfo
operator|->
name|indices
operator|,
name|ppsection
operator|=
name|finfo
operator|->
name|sections
init|;
name|isym
operator|<
name|isymend
condition|;
name|isym
operator|++
operator|,
name|pindex
operator|++
operator|,
name|ppsection
operator|++
control|)
block|{
name|asection
modifier|*
name|isec
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|Elf_Internal_Sym
name|osym
decl_stmt|;
operator|*
name|pindex
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|elf_bad_symtab
argument_list|(
name|input_bfd
argument_list|)
condition|)
block|{
if|if
condition|(
name|ELF_ST_BIND
argument_list|(
name|isym
operator|->
name|st_info
argument_list|)
operator|!=
name|STB_LOCAL
condition|)
block|{
operator|*
name|ppsection
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_UNDEF
condition|)
name|isec
operator|=
name|bfd_und_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|<
name|SHN_LORESERVE
operator|||
name|isym
operator|->
name|st_shndx
operator|>
name|SHN_HIRESERVE
condition|)
block|{
name|isec
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|input_bfd
argument_list|,
name|isym
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|isec
operator|&&
name|isec
operator|->
name|sec_info_type
operator|==
name|ELF_INFO_TYPE_MERGE
operator|&&
name|ELF_ST_TYPE
argument_list|(
name|isym
operator|->
name|st_info
argument_list|)
operator|!=
name|STT_SECTION
condition|)
name|isym
operator|->
name|st_value
operator|=
name|_bfd_merged_section_offset
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|isec
argument_list|,
name|elf_section_data
argument_list|(
name|isec
argument_list|)
operator|->
name|sec_info
argument_list|,
name|isym
operator|->
name|st_value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_ABS
condition|)
name|isec
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_COMMON
condition|)
name|isec
operator|=
name|bfd_com_section_ptr
expr_stmt|;
else|else
block|{
comment|/* Don't attempt to output symbols with st_shnx in the 	     reserved range other than SHN_ABS and SHN_COMMON.  */
operator|*
name|ppsection
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
operator|*
name|ppsection
operator|=
name|isec
expr_stmt|;
comment|/* Don't output the first, undefined, symbol.  */
if|if
condition|(
name|ppsection
operator|==
name|finfo
operator|->
name|sections
condition|)
continue|continue;
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|isym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_SECTION
condition|)
block|{
comment|/* We never output section symbols.  Instead, we use the 	     section symbol of the corresponding section in the output 	     file.  */
continue|continue;
block|}
comment|/* If we are stripping all symbols, we don't want to output this 	 one.  */
if|if
condition|(
name|finfo
operator|->
name|info
operator|->
name|strip
operator|==
name|strip_all
condition|)
continue|continue;
comment|/* If we are discarding all local symbols, we don't want to 	 output this one.  If we are generating a relocatable output 	 file, then some of the local symbols may be required by 	 relocs; we output them below as we discover that they are 	 needed.  */
if|if
condition|(
name|finfo
operator|->
name|info
operator|->
name|discard
operator|==
name|discard_all
condition|)
continue|continue;
comment|/* If this symbol is defined in a section which we are 	 discarding, we don't need to keep it.  */
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|!=
name|SHN_UNDEF
operator|&&
operator|(
name|isym
operator|->
name|st_shndx
operator|<
name|SHN_LORESERVE
operator|||
name|isym
operator|->
name|st_shndx
operator|>
name|SHN_HIRESERVE
operator|)
operator|&&
operator|(
name|isec
operator|==
name|NULL
operator|||
name|bfd_section_removed_from_list
argument_list|(
name|output_bfd
argument_list|,
name|isec
operator|->
name|output_section
argument_list|)
operator|)
condition|)
continue|continue;
comment|/* Get the name of the symbol.  */
name|name
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_link
argument_list|,
name|isym
operator|->
name|st_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* See if we are discarding symbols with this name.  */
if|if
condition|(
operator|(
name|finfo
operator|->
name|info
operator|->
name|strip
operator|==
name|strip_some
operator|&&
operator|(
name|bfd_hash_lookup
argument_list|(
name|finfo
operator|->
name|info
operator|->
name|keep_hash
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
operator|==
name|NULL
operator|)
operator|)
operator|||
operator|(
operator|(
operator|(
name|finfo
operator|->
name|info
operator|->
name|discard
operator|==
name|discard_sec_merge
operator|&&
operator|(
name|isec
operator|->
name|flags
operator|&
name|SEC_MERGE
operator|)
operator|&&
operator|!
name|finfo
operator|->
name|info
operator|->
name|relocatable
operator|)
operator|||
name|finfo
operator|->
name|info
operator|->
name|discard
operator|==
name|discard_l
operator|)
operator|&&
name|bfd_is_local_label_name
argument_list|(
name|input_bfd
argument_list|,
name|name
argument_list|)
operator|)
condition|)
continue|continue;
comment|/* If we get here, we are going to output this symbol.  */
name|osym
operator|=
operator|*
name|isym
expr_stmt|;
comment|/* Adjust the section index for the output file.  */
name|osym
operator|.
name|st_shndx
operator|=
name|_bfd_elf_section_from_bfd_section
argument_list|(
name|output_bfd
argument_list|,
name|isec
operator|->
name|output_section
argument_list|)
expr_stmt|;
if|if
condition|(
name|osym
operator|.
name|st_shndx
operator|==
name|SHN_BAD
condition|)
return|return
name|FALSE
return|;
operator|*
name|pindex
operator|=
name|bfd_get_symcount
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
comment|/* ELF symbols in relocatable files are section relative, but 	 in executable files they are virtual addresses.  Note that 	 this code assumes that all ELF sections have an associated 	 BFD section with a reasonable value for output_offset; below 	 we assume that they also have a reasonable value for 	 output_section.  Any special sections must be set up to meet 	 these requirements.  */
name|osym
operator|.
name|st_value
operator|+=
name|isec
operator|->
name|output_offset
expr_stmt|;
if|if
condition|(
operator|!
name|finfo
operator|->
name|info
operator|->
name|relocatable
condition|)
block|{
name|osym
operator|.
name|st_value
operator|+=
name|isec
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|osym
operator|.
name|st_info
argument_list|)
operator|==
name|STT_TLS
condition|)
block|{
comment|/* STT_TLS symbols are relative to PT_TLS segment base.  */
name|BFD_ASSERT
argument_list|(
name|elf_hash_table
argument_list|(
name|finfo
operator|->
name|info
argument_list|)
operator|->
name|tls_sec
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|osym
operator|.
name|st_value
operator|-=
name|elf_hash_table
argument_list|(
name|finfo
operator|->
name|info
argument_list|)
operator|->
name|tls_sec
operator|->
name|vma
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|elf_link_output_sym
argument_list|(
name|finfo
argument_list|,
name|name
argument_list|,
operator|&
name|osym
argument_list|,
name|isec
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|evaluate_complex_relocation_symbols
argument_list|(
name|input_bfd
argument_list|,
name|finfo
argument_list|,
name|locsymcount
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Relocate the contents of each section.  */
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
for|for
control|(
name|o
operator|=
name|input_bfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
if|if
condition|(
operator|!
name|o
operator|->
name|linker_mark
condition|)
block|{
comment|/* This section was omitted from the link.  */
continue|continue;
block|}
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|==
literal|0
operator|||
operator|(
name|o
operator|->
name|size
operator|==
literal|0
operator|&&
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_LINKER_CREATED
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Section was created by _bfd_elf_link_create_dynamic_sections 	     or somesuch.  */
continue|continue;
block|}
comment|/* Get the contents of the section.  They have been cached by a 	 relaxation routine.  Note that o is a section in an input 	 file, so the contents field will not have been set by any of 	 the routines which work on output files.  */
if|if
condition|(
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|NULL
condition|)
name|contents
operator|=
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
expr_stmt|;
else|else
block|{
name|bfd_size_type
name|amt
init|=
name|o
operator|->
name|rawsize
condition|?
name|o
operator|->
name|rawsize
else|:
name|o
operator|->
name|size
decl_stmt|;
name|contents
operator|=
name|finfo
operator|->
name|contents
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|input_bfd
argument_list|,
name|o
argument_list|,
name|contents
argument_list|,
literal|0
argument_list|,
name|amt
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|!=
literal|0
condition|)
block|{
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|;
name|bfd_vma
name|r_type_mask
decl_stmt|;
name|int
name|r_sym_shift
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* Get the swapped relocs.  */
name|internal_relocs
operator|=
name|_bfd_elf_link_read_relocs
argument_list|(
name|input_bfd
argument_list|,
name|o
argument_list|,
name|finfo
operator|->
name|external_relocs
argument_list|,
name|finfo
operator|->
name|internal_relocs
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
operator|&&
name|o
operator|->
name|reloc_count
operator|>
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|bed
operator|->
name|s
operator|->
name|arch_size
operator|==
literal|32
condition|)
block|{
name|r_type_mask
operator|=
literal|0xff
expr_stmt|;
name|r_sym_shift
operator|=
literal|8
expr_stmt|;
block|}
else|else
block|{
name|r_type_mask
operator|=
literal|0xffffffff
expr_stmt|;
name|r_sym_shift
operator|=
literal|32
expr_stmt|;
block|}
comment|/* Run through the relocs looking for any against symbols 	     from discarded sections and section symbols from 	     removed link-once sections.  Complain about relocs 	     against discarded sections.  Zero relocs against removed 	     link-once sections.  */
if|if
condition|(
operator|!
name|elf_section_ignore_discarded_relocs
argument_list|(
name|o
argument_list|)
condition|)
block|{
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|,
modifier|*
name|relend
decl_stmt|;
name|unsigned
name|int
name|action
init|=
call|(
modifier|*
name|bed
operator|->
name|action_discarded
call|)
argument_list|(
name|o
argument_list|)
decl_stmt|;
name|rel
operator|=
name|internal_relocs
expr_stmt|;
name|relend
operator|=
name|rel
operator|+
name|o
operator|->
name|reloc_count
operator|*
name|bed
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
expr_stmt|;
for|for
control|(
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|unsigned
name|long
name|r_symndx
init|=
name|rel
operator|->
name|r_info
operator|>>
name|r_sym_shift
decl_stmt|;
name|asection
modifier|*
modifier|*
name|ps
decl_stmt|,
modifier|*
name|sec
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|sym_name
decl_stmt|;
if|if
condition|(
name|r_symndx
operator|==
name|STN_UNDEF
condition|)
continue|continue;
if|if
condition|(
name|r_symndx
operator|>=
name|locsymcount
operator|||
operator|(
name|elf_bad_symtab
argument_list|(
name|input_bfd
argument_list|)
operator|&&
name|finfo
operator|->
name|sections
index|[
name|r_symndx
index|]
operator|==
name|NULL
operator|)
condition|)
block|{
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|extsymoff
index|]
expr_stmt|;
comment|/* Badly formatted input files can contain relocs that 			 reference non-existant symbols.  Check here so that 			 we do not seg fault.  */
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
block|{
name|char
name|buffer
index|[
literal|32
index|]
decl_stmt|;
name|sprintf_vma
argument_list|(
name|buffer
argument_list|,
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"error: %B contains a reloc (0x%s) for section %A "
literal|"that references a non-existent global symbol"
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|o
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defined
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
condition|)
continue|continue;
name|ps
operator|=
operator|&
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|sym_name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
block|}
else|else
block|{
name|Elf_Internal_Sym
modifier|*
name|sym
init|=
name|isymbuf
operator|+
name|r_symndx
decl_stmt|;
name|ps
operator|=
operator|&
name|finfo
operator|->
name|sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|sym_name
operator|=
name|bfd_elf_sym_name
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
argument_list|,
name|sym
argument_list|,
operator|*
name|ps
argument_list|)
expr_stmt|;
block|}
comment|/* Complain if the definition comes from a 		     discarded section.  */
if|if
condition|(
operator|(
name|sec
operator|=
operator|*
name|ps
operator|)
operator|!=
name|NULL
operator|&&
name|elf_discarded_section
argument_list|(
name|sec
argument_list|)
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|r_symndx
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|action
operator|&
name|COMPLAIN
condition|)
call|(
modifier|*
name|finfo
operator|->
name|info
operator|->
name|callbacks
operator|->
name|einfo
call|)
argument_list|(
name|_
argument_list|(
literal|"%X`%s' referenced in section `%A' of %B: "
literal|"defined in discarded section `%A' of %B\n"
argument_list|)
argument_list|,
name|sym_name
argument_list|,
name|o
argument_list|,
name|input_bfd
argument_list|,
name|sec
argument_list|,
name|sec
operator|->
name|owner
argument_list|)
expr_stmt|;
comment|/* Try to do the best we can to support buggy old 			 versions of gcc.  Pretend that the symbol is 			 really defined in the kept linkonce section. 			 FIXME: This is quite broken.  Modifying the 			 symbol here means we will be changing all later 			 uses of the symbol, not just in this section.  */
if|if
condition|(
name|action
operator|&
name|PRETEND
condition|)
block|{
name|asection
modifier|*
name|kept
decl_stmt|;
name|kept
operator|=
name|_bfd_elf_check_kept_section
argument_list|(
name|sec
argument_list|,
name|finfo
operator|->
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|kept
operator|!=
name|NULL
condition|)
block|{
operator|*
name|ps
operator|=
name|kept
expr_stmt|;
continue|continue;
block|}
block|}
block|}
block|}
block|}
comment|/* Relocate the section by invoking a back end routine.  	     The back end routine is responsible for adjusting the 	     section contents as necessary, and (if using Rela relocs 	     and generating a relocatable output file) adjusting the 	     reloc addend as necessary.  	     The back end routine does not have to worry about setting 	     the reloc address or the reloc symbol index.  	     The back end routine is given a pointer to the swapped in 	     internal symbols, and can access the hash table entries 	     for the external symbols via elf_sym_hashes (input_bfd).  	     When generating relocatable output, the back end routine 	     must handle STB_LOCAL/STT_SECTION symbols specially.  The 	     output symbol is going to be a section symbol 	     corresponding to the output section, which will require 	     the addend to be adjusted.  */
name|ret
operator|=
call|(
modifier|*
name|relocate_section
call|)
argument_list|(
name|output_bfd
argument_list|,
name|finfo
operator|->
name|info
argument_list|,
name|input_bfd
argument_list|,
name|o
argument_list|,
name|contents
argument_list|,
name|internal_relocs
argument_list|,
name|isymbuf
argument_list|,
name|finfo
operator|->
name|sections
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|ret
operator|==
literal|2
operator|||
name|finfo
operator|->
name|info
operator|->
name|relocatable
operator|||
name|finfo
operator|->
name|info
operator|->
name|emitrelocations
condition|)
block|{
name|Elf_Internal_Rela
modifier|*
name|irela
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irelaend
decl_stmt|;
name|bfd_vma
name|last_offset
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|rel_hash
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|rel_hash_list
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|input_rel_hdr
decl_stmt|,
modifier|*
name|input_rel_hdr2
decl_stmt|;
name|unsigned
name|int
name|next_erel
decl_stmt|;
name|bfd_boolean
name|rela_normal
decl_stmt|;
name|input_rel_hdr
operator|=
operator|&
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_hdr
expr_stmt|;
name|rela_normal
operator|=
operator|(
name|bed
operator|->
name|rela_normal
operator|&&
operator|(
name|input_rel_hdr
operator|->
name|sh_entsize
operator|==
name|bed
operator|->
name|s
operator|->
name|sizeof_rela
operator|)
operator|)
expr_stmt|;
comment|/* Adjust the reloc addresses and symbol indices.  */
name|irela
operator|=
name|internal_relocs
expr_stmt|;
name|irelaend
operator|=
name|irela
operator|+
name|o
operator|->
name|reloc_count
operator|*
name|bed
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
expr_stmt|;
name|rel_hash
operator|=
operator|(
name|elf_section_data
argument_list|(
name|o
operator|->
name|output_section
argument_list|)
operator|->
name|rel_hashes
operator|+
name|elf_section_data
argument_list|(
name|o
operator|->
name|output_section
argument_list|)
operator|->
name|rel_count
operator|+
name|elf_section_data
argument_list|(
name|o
operator|->
name|output_section
argument_list|)
operator|->
name|rel_count2
operator|)
expr_stmt|;
name|rel_hash_list
operator|=
name|rel_hash
expr_stmt|;
name|last_offset
operator|=
name|o
operator|->
name|output_offset
expr_stmt|;
if|if
condition|(
operator|!
name|finfo
operator|->
name|info
operator|->
name|relocatable
condition|)
name|last_offset
operator|+=
name|o
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
for|for
control|(
name|next_erel
operator|=
literal|0
init|;
name|irela
operator|<
name|irelaend
condition|;
name|irela
operator|++
operator|,
name|next_erel
operator|++
control|)
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|Elf_Internal_Sym
name|sym
decl_stmt|;
if|if
condition|(
name|next_erel
operator|==
name|bed
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
condition|)
block|{
name|rel_hash
operator|++
expr_stmt|;
name|next_erel
operator|=
literal|0
expr_stmt|;
block|}
name|irela
operator|->
name|r_offset
operator|=
name|_bfd_elf_section_offset
argument_list|(
name|output_bfd
argument_list|,
name|finfo
operator|->
name|info
argument_list|,
name|o
argument_list|,
name|irela
operator|->
name|r_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|irela
operator|->
name|r_offset
operator|>=
operator|(
name|bfd_vma
operator|)
operator|-
literal|2
condition|)
block|{
comment|/* This is a reloc for a deleted entry or somesuch. 			 Turn it into an R_*_NONE reloc, at the same 			 offset as the last reloc.  elf_eh_frame.c and 			 bfd_elf_discard_info rely on reloc offsets 			 being ordered.  */
name|irela
operator|->
name|r_offset
operator|=
name|last_offset
expr_stmt|;
name|irela
operator|->
name|r_info
operator|=
literal|0
expr_stmt|;
name|irela
operator|->
name|r_addend
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|irela
operator|->
name|r_offset
operator|+=
name|o
operator|->
name|output_offset
expr_stmt|;
comment|/* Relocs in an executable have to be virtual addresses.  */
if|if
condition|(
operator|!
name|finfo
operator|->
name|info
operator|->
name|relocatable
condition|)
name|irela
operator|->
name|r_offset
operator|+=
name|o
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|last_offset
operator|=
name|irela
operator|->
name|r_offset
expr_stmt|;
name|r_symndx
operator|=
name|irela
operator|->
name|r_info
operator|>>
name|r_sym_shift
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|==
name|STN_UNDEF
condition|)
continue|continue;
if|if
condition|(
name|r_symndx
operator|>=
name|locsymcount
operator|||
operator|(
name|elf_bad_symtab
argument_list|(
name|input_bfd
argument_list|)
operator|&&
name|finfo
operator|->
name|sections
index|[
name|r_symndx
index|]
operator|==
name|NULL
operator|)
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|rh
decl_stmt|;
name|unsigned
name|long
name|indx
decl_stmt|;
comment|/* This is a reloc against a global symbol.  We 			 have not yet output all the local symbols, so 			 we do not know the symbol index of any global 			 symbol.  We set the rel_hash entry for this 			 reloc to point to the global hash table entry 			 for this symbol.  The symbol index is then 			 set at the end of bfd_elf_final_link.  */
name|indx
operator|=
name|r_symndx
operator|-
name|extsymoff
expr_stmt|;
name|rh
operator|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
index|[
name|indx
index|]
expr_stmt|;
while|while
condition|(
name|rh
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|rh
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|rh
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|rh
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
comment|/* Setting the index to -2 tells 			 elf_link_output_extsym that this symbol is 			 used by a reloc.  */
name|BFD_ASSERT
argument_list|(
name|rh
operator|->
name|indx
operator|<
literal|0
argument_list|)
expr_stmt|;
name|rh
operator|->
name|indx
operator|=
operator|-
literal|2
expr_stmt|;
operator|*
name|rel_hash
operator|=
name|rh
expr_stmt|;
continue|continue;
block|}
comment|/* This is a reloc against a local symbol.  */
operator|*
name|rel_hash
operator|=
name|NULL
expr_stmt|;
name|sym
operator|=
name|isymbuf
index|[
name|r_symndx
index|]
expr_stmt|;
name|sec
operator|=
name|finfo
operator|->
name|sections
index|[
name|r_symndx
index|]
expr_stmt|;
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|.
name|st_info
argument_list|)
operator|==
name|STT_SECTION
condition|)
block|{
comment|/* I suppose the backend ought to fill in the 			 section of any STT_SECTION symbol against a 			 processor specific section.  */
name|r_symndx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bfd_is_abs_section
argument_list|(
name|sec
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|sec
operator|==
name|NULL
operator|||
name|sec
operator|->
name|owner
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
else|else
block|{
name|asection
modifier|*
name|osec
init|=
name|sec
operator|->
name|output_section
decl_stmt|;
comment|/* If we have discarded a section, the output 			     section will be the absolute section.  In 			     case of discarded SEC_MERGE sections, use 			     the kept section.  relocate_section should 			     have already handled discarded linkonce 			     sections.  */
if|if
condition|(
name|bfd_is_abs_section
argument_list|(
name|osec
argument_list|)
operator|&&
name|sec
operator|->
name|kept_section
operator|!=
name|NULL
operator|&&
name|sec
operator|->
name|kept_section
operator|->
name|output_section
operator|!=
name|NULL
condition|)
block|{
name|osec
operator|=
name|sec
operator|->
name|kept_section
operator|->
name|output_section
expr_stmt|;
name|irela
operator|->
name|r_addend
operator|-=
name|osec
operator|->
name|vma
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bfd_is_abs_section
argument_list|(
name|osec
argument_list|)
condition|)
block|{
name|r_symndx
operator|=
name|osec
operator|->
name|target_index
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|==
literal|0
condition|)
block|{
name|struct
name|elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|asection
modifier|*
name|oi
decl_stmt|;
name|htab
operator|=
name|elf_hash_table
argument_list|(
name|finfo
operator|->
name|info
argument_list|)
expr_stmt|;
name|oi
operator|=
name|htab
operator|->
name|text_index_section
expr_stmt|;
if|if
condition|(
operator|(
name|osec
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|==
literal|0
operator|&&
name|htab
operator|->
name|data_index_section
operator|!=
name|NULL
condition|)
name|oi
operator|=
name|htab
operator|->
name|data_index_section
expr_stmt|;
if|if
condition|(
name|oi
operator|!=
name|NULL
condition|)
block|{
name|irela
operator|->
name|r_addend
operator|+=
name|osec
operator|->
name|vma
operator|-
name|oi
operator|->
name|vma
expr_stmt|;
name|r_symndx
operator|=
name|oi
operator|->
name|target_index
expr_stmt|;
block|}
block|}
name|BFD_ASSERT
argument_list|(
name|r_symndx
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Adjust the addend according to where the 			 section winds up in the output section.  */
if|if
condition|(
name|rela_normal
condition|)
name|irela
operator|->
name|r_addend
operator|+=
name|sec
operator|->
name|output_offset
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|finfo
operator|->
name|indices
index|[
name|r_symndx
index|]
operator|==
operator|-
literal|1
condition|)
block|{
name|unsigned
name|long
name|shlink
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|asection
modifier|*
name|osec
decl_stmt|;
if|if
condition|(
name|finfo
operator|->
name|info
operator|->
name|strip
operator|==
name|strip_all
condition|)
block|{
comment|/* You can't do ld -r -s.  */
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* This symbol was skipped earlier, but 			     since it is needed by a reloc, we 			     must output it now.  */
name|shlink
operator|=
name|symtab_hdr
operator|->
name|sh_link
expr_stmt|;
name|name
operator|=
operator|(
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|shlink
argument_list|,
name|sym
operator|.
name|st_name
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|osec
operator|=
name|sec
operator|->
name|output_section
expr_stmt|;
name|sym
operator|.
name|st_shndx
operator|=
name|_bfd_elf_section_from_bfd_section
argument_list|(
name|output_bfd
argument_list|,
name|osec
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|.
name|st_shndx
operator|==
name|SHN_BAD
condition|)
return|return
name|FALSE
return|;
name|sym
operator|.
name|st_value
operator|+=
name|sec
operator|->
name|output_offset
expr_stmt|;
if|if
condition|(
operator|!
name|finfo
operator|->
name|info
operator|->
name|relocatable
condition|)
block|{
name|sym
operator|.
name|st_value
operator|+=
name|osec
operator|->
name|vma
expr_stmt|;
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|.
name|st_info
argument_list|)
operator|==
name|STT_TLS
condition|)
block|{
comment|/* STT_TLS symbols are relative to PT_TLS 				     segment base.  */
name|BFD_ASSERT
argument_list|(
name|elf_hash_table
argument_list|(
name|finfo
operator|->
name|info
argument_list|)
operator|->
name|tls_sec
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|sym
operator|.
name|st_value
operator|-=
operator|(
name|elf_hash_table
argument_list|(
name|finfo
operator|->
name|info
argument_list|)
operator|->
name|tls_sec
operator|->
name|vma
operator|)
expr_stmt|;
block|}
block|}
name|finfo
operator|->
name|indices
index|[
name|r_symndx
index|]
operator|=
name|bfd_get_symcount
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|elf_link_output_sym
argument_list|(
name|finfo
argument_list|,
name|name
argument_list|,
operator|&
name|sym
argument_list|,
name|sec
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
name|r_symndx
operator|=
name|finfo
operator|->
name|indices
index|[
name|r_symndx
index|]
expr_stmt|;
block|}
name|irela
operator|->
name|r_info
operator|=
operator|(
operator|(
name|bfd_vma
operator|)
name|r_symndx
operator|<<
name|r_sym_shift
operator||
operator|(
name|irela
operator|->
name|r_info
operator|&
name|r_type_mask
operator|)
operator|)
expr_stmt|;
block|}
comment|/* Swap out the relocs.  */
if|if
condition|(
name|input_rel_hdr
operator|->
name|sh_size
operator|!=
literal|0
operator|&&
operator|!
name|bed
operator|->
name|elf_backend_emit_relocs
argument_list|(
name|output_bfd
argument_list|,
name|o
argument_list|,
name|input_rel_hdr
argument_list|,
name|internal_relocs
argument_list|,
name|rel_hash_list
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|input_rel_hdr2
operator|=
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_hdr2
expr_stmt|;
if|if
condition|(
name|input_rel_hdr2
operator|&&
name|input_rel_hdr2
operator|->
name|sh_size
operator|!=
literal|0
condition|)
block|{
name|internal_relocs
operator|+=
operator|(
name|NUM_SHDR_ENTRIES
argument_list|(
name|input_rel_hdr
argument_list|)
operator|*
name|bed
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
operator|)
expr_stmt|;
name|rel_hash_list
operator|+=
name|NUM_SHDR_ENTRIES
argument_list|(
name|input_rel_hdr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bed
operator|->
name|elf_backend_emit_relocs
argument_list|(
name|output_bfd
argument_list|,
name|o
argument_list|,
name|input_rel_hdr2
argument_list|,
name|internal_relocs
argument_list|,
name|rel_hash_list
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
block|}
comment|/* Write out the modified section contents.  */
if|if
condition|(
name|bed
operator|->
name|elf_backend_write_section
operator|&&
call|(
modifier|*
name|bed
operator|->
name|elf_backend_write_section
call|)
argument_list|(
name|output_bfd
argument_list|,
name|finfo
operator|->
name|info
argument_list|,
name|o
argument_list|,
name|contents
argument_list|)
condition|)
block|{
comment|/* Section written out.  */
block|}
else|else
switch|switch
condition|(
name|o
operator|->
name|sec_info_type
condition|)
block|{
case|case
name|ELF_INFO_TYPE_STABS
case|:
if|if
condition|(
operator|!
operator|(
name|_bfd_write_section_stabs
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|elf_hash_table
argument_list|(
name|finfo
operator|->
name|info
argument_list|)
operator|->
name|stab_info
argument_list|,
name|o
argument_list|,
operator|&
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|sec_info
argument_list|,
name|contents
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|ELF_INFO_TYPE_MERGE
case|:
if|if
condition|(
operator|!
name|_bfd_write_merged_section
argument_list|(
name|output_bfd
argument_list|,
name|o
argument_list|,
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|sec_info
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|ELF_INFO_TYPE_EH_FRAME
case|:
block|{
if|if
condition|(
operator|!
name|_bfd_elf_write_section_eh_frame
argument_list|(
name|output_bfd
argument_list|,
name|finfo
operator|->
name|info
argument_list|,
name|o
argument_list|,
name|contents
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
break|break;
default|default:
block|{
if|if
condition|(
operator|!
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_EXCLUDE
operator|)
operator|&&
operator|!
name|bfd_set_section_contents
argument_list|(
name|output_bfd
argument_list|,
name|o
operator|->
name|output_section
argument_list|,
name|contents
argument_list|,
operator|(
name|file_ptr
operator|)
name|o
operator|->
name|output_offset
argument_list|,
name|o
operator|->
name|size
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
break|break;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Generate a reloc when linking an ELF file.  This is a reloc    requested by the linker, and does not come from any input file.  This    is used to build constructor and destructor tables when linking    with -Ur.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_reloc_link_order
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|asection
modifier|*
name|output_section
parameter_list|,
name|struct
name|bfd_link_order
modifier|*
name|link_order
parameter_list|)
block|{
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|long
name|indx
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|rel_hash_ptr
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|rel_hdr
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|output_bfd
argument_list|)
decl_stmt|;
name|Elf_Internal_Rela
name|irel
index|[
name|MAX_INT_RELS_PER_EXT_REL
index|]
decl_stmt|;
name|bfd_byte
modifier|*
name|erel
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|output_bfd
argument_list|,
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|reloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|howto
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|addend
operator|=
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|addend
expr_stmt|;
comment|/* Figure out the symbol index.  */
name|rel_hash_ptr
operator|=
operator|(
name|elf_section_data
argument_list|(
name|output_section
argument_list|)
operator|->
name|rel_hashes
operator|+
name|elf_section_data
argument_list|(
name|output_section
argument_list|)
operator|->
name|rel_count
operator|+
name|elf_section_data
argument_list|(
name|output_section
argument_list|)
operator|->
name|rel_count2
operator|)
expr_stmt|;
if|if
condition|(
name|link_order
operator|->
name|type
operator|==
name|bfd_section_reloc_link_order
condition|)
block|{
name|indx
operator|=
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|u
operator|.
name|section
operator|->
name|target_index
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|indx
operator|!=
literal|0
argument_list|)
expr_stmt|;
operator|*
name|rel_hash_ptr
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
comment|/* Treat a reloc against a defined symbol as though it were 	 actually against the section.  */
name|h
operator|=
operator|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|bfd_wrapped_link_hash_lookup
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|u
operator|.
name|name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
condition|)
block|{
name|asection
modifier|*
name|section
decl_stmt|;
name|section
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|indx
operator|=
name|section
operator|->
name|output_section
operator|->
name|target_index
expr_stmt|;
operator|*
name|rel_hash_ptr
operator|=
name|NULL
expr_stmt|;
comment|/* It seems that we ought to add the symbol value to the 	     addend here, but in practice it has already been added 	     because it was passed to constructor_callback.  */
name|addend
operator|+=
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|section
operator|->
name|output_offset
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
comment|/* Setting the index to -2 tells elf_link_output_extsym that 	     this symbol is used by a reloc.  */
name|h
operator|->
name|indx
operator|=
operator|-
literal|2
expr_stmt|;
operator|*
name|rel_hash_ptr
operator|=
name|h
expr_stmt|;
name|indx
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|unattached_reloc
call|)
argument_list|(
name|info
argument_list|,
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|u
operator|.
name|name
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
name|indx
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* If this is an inplace reloc, we must write the addend into the      object file.  */
if|if
condition|(
name|howto
operator|->
name|partial_inplace
operator|&&
name|addend
operator|!=
literal|0
condition|)
block|{
name|bfd_size_type
name|size
decl_stmt|;
name|bfd_reloc_status_type
name|rstat
decl_stmt|;
name|bfd_byte
modifier|*
name|buf
decl_stmt|;
name|bfd_boolean
name|ok
decl_stmt|;
specifier|const
name|char
modifier|*
name|sym_name
decl_stmt|;
name|size
operator|=
name|bfd_get_reloc_size
argument_list|(
name|howto
argument_list|)
expr_stmt|;
name|buf
operator|=
name|bfd_zmalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|rstat
operator|=
name|_bfd_relocate_contents
argument_list|(
name|howto
argument_list|,
name|output_bfd
argument_list|,
name|addend
argument_list|,
name|buf
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rstat
condition|)
block|{
case|case
name|bfd_reloc_ok
case|:
break|break;
default|default:
case|case
name|bfd_reloc_outofrange
case|:
name|abort
argument_list|()
expr_stmt|;
case|case
name|bfd_reloc_overflow
case|:
if|if
condition|(
name|link_order
operator|->
name|type
operator|==
name|bfd_section_reloc_link_order
condition|)
name|sym_name
operator|=
name|bfd_section_name
argument_list|(
name|output_bfd
argument_list|,
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|u
operator|.
name|section
argument_list|)
expr_stmt|;
else|else
name|sym_name
operator|=
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|u
operator|.
name|name
expr_stmt|;
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|info
argument_list|,
name|NULL
argument_list|,
name|sym_name
argument_list|,
name|howto
operator|->
name|name
argument_list|,
name|addend
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
operator|)
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
break|break;
block|}
name|ok
operator|=
name|bfd_set_section_contents
argument_list|(
name|output_bfd
argument_list|,
name|output_section
argument_list|,
name|buf
argument_list|,
name|link_order
operator|->
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* The address of a reloc is relative to the section in a      relocatable file, and is a virtual address in an executable      file.  */
name|offset
operator|=
name|link_order
operator|->
name|offset
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|relocatable
condition|)
name|offset
operator|+=
name|output_section
operator|->
name|vma
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bed
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
condition|;
name|i
operator|++
control|)
block|{
name|irel
index|[
name|i
index|]
operator|.
name|r_offset
operator|=
name|offset
expr_stmt|;
name|irel
index|[
name|i
index|]
operator|.
name|r_info
operator|=
literal|0
expr_stmt|;
name|irel
index|[
name|i
index|]
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|bed
operator|->
name|s
operator|->
name|arch_size
operator|==
literal|32
condition|)
name|irel
index|[
literal|0
index|]
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|indx
argument_list|,
name|howto
operator|->
name|type
argument_list|)
expr_stmt|;
else|else
name|irel
index|[
literal|0
index|]
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|indx
argument_list|,
name|howto
operator|->
name|type
argument_list|)
expr_stmt|;
name|rel_hdr
operator|=
operator|&
name|elf_section_data
argument_list|(
name|output_section
argument_list|)
operator|->
name|rel_hdr
expr_stmt|;
name|erel
operator|=
name|rel_hdr
operator|->
name|contents
expr_stmt|;
if|if
condition|(
name|rel_hdr
operator|->
name|sh_type
operator|==
name|SHT_REL
condition|)
block|{
name|erel
operator|+=
operator|(
name|elf_section_data
argument_list|(
name|output_section
argument_list|)
operator|->
name|rel_count
operator|*
name|bed
operator|->
name|s
operator|->
name|sizeof_rel
operator|)
expr_stmt|;
call|(
modifier|*
name|bed
operator|->
name|s
operator|->
name|swap_reloc_out
call|)
argument_list|(
name|output_bfd
argument_list|,
name|irel
argument_list|,
name|erel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|irel
index|[
literal|0
index|]
operator|.
name|r_addend
operator|=
name|addend
expr_stmt|;
name|erel
operator|+=
operator|(
name|elf_section_data
argument_list|(
name|output_section
argument_list|)
operator|->
name|rel_count
operator|*
name|bed
operator|->
name|s
operator|->
name|sizeof_rela
operator|)
expr_stmt|;
call|(
modifier|*
name|bed
operator|->
name|s
operator|->
name|swap_reloca_out
call|)
argument_list|(
name|output_bfd
argument_list|,
name|irel
argument_list|,
name|erel
argument_list|)
expr_stmt|;
block|}
operator|++
name|elf_section_data
argument_list|(
name|output_section
argument_list|)
operator|->
name|rel_count
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Get the output vma of the section pointed to by the sh_link field.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|elf_get_linked_section_vma
parameter_list|(
name|struct
name|bfd_link_order
modifier|*
name|p
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
modifier|*
name|elf_shdrp
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|int
name|elfsec
decl_stmt|;
name|s
operator|=
name|p
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
expr_stmt|;
name|elf_shdrp
operator|=
name|elf_elfsections
argument_list|(
name|s
operator|->
name|owner
argument_list|)
expr_stmt|;
name|elfsec
operator|=
name|_bfd_elf_section_from_bfd_section
argument_list|(
name|s
operator|->
name|owner
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|elfsec
operator|=
name|elf_shdrp
index|[
name|elfsec
index|]
operator|->
name|sh_link
expr_stmt|;
comment|/* PR 290:      The Intel C compiler generates SHT_IA_64_UNWIND with      SHF_LINK_ORDER.  But it doesn't set the sh_link or      sh_info fields.  Hence we could get the situation      where elfsec is 0.  */
if|if
condition|(
name|elfsec
operator|==
literal|0
condition|)
block|{
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|s
operator|->
name|owner
argument_list|)
decl_stmt|;
if|if
condition|(
name|bed
operator|->
name|link_order_error_handler
condition|)
name|bed
operator|->
name|link_order_error_handler
argument_list|(
name|_
argument_list|(
literal|"%B: warning: sh_link not set for section `%A'"
argument_list|)
argument_list|,
name|s
operator|->
name|owner
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|s
operator|=
name|elf_shdrp
index|[
name|elfsec
index|]
operator|->
name|bfd_section
expr_stmt|;
return|return
name|s
operator|->
name|output_section
operator|->
name|vma
operator|+
name|s
operator|->
name|output_offset
return|;
block|}
block|}
end_function

begin_comment
comment|/* Compare two sections based on the locations of the sections they are    linked to.  Used by elf_fixup_link_order.  */
end_comment

begin_function
specifier|static
name|int
name|compare_link_order
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
name|bfd_vma
name|apos
decl_stmt|;
name|bfd_vma
name|bpos
decl_stmt|;
name|apos
operator|=
name|elf_get_linked_section_vma
argument_list|(
operator|*
operator|(
expr|struct
name|bfd_link_order
operator|*
operator|*
operator|)
name|a
argument_list|)
expr_stmt|;
name|bpos
operator|=
name|elf_get_linked_section_vma
argument_list|(
operator|*
operator|(
expr|struct
name|bfd_link_order
operator|*
operator|*
operator|)
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|apos
operator|<
name|bpos
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|apos
operator|>
name|bpos
return|;
block|}
end_function

begin_comment
comment|/* Looks for sections with SHF_LINK_ORDER set.  Rearranges them into the same    order as their linked sections.  Returns false if this could not be done    because an output section includes both ordered and unordered    sections.  Ideally we'd do this in the linker proper.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_fixup_link_order
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|o
parameter_list|)
block|{
name|int
name|seen_linkorder
decl_stmt|;
name|int
name|seen_other
decl_stmt|;
name|int
name|n
decl_stmt|;
name|struct
name|bfd_link_order
modifier|*
name|p
decl_stmt|;
name|bfd
modifier|*
name|sub
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|unsigned
name|elfsec
decl_stmt|;
name|struct
name|bfd_link_order
modifier|*
modifier|*
name|sections
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|,
modifier|*
name|other_sec
decl_stmt|,
modifier|*
name|linkorder_sec
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
name|other_sec
operator|=
name|NULL
expr_stmt|;
name|linkorder_sec
operator|=
name|NULL
expr_stmt|;
name|seen_other
operator|=
literal|0
expr_stmt|;
name|seen_linkorder
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|o
operator|->
name|map_head
operator|.
name|link_order
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_indirect_link_order
condition|)
block|{
name|s
operator|=
name|p
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
expr_stmt|;
name|sub
operator|=
name|s
operator|->
name|owner
expr_stmt|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|sub
argument_list|)
operator|==
name|bfd_target_elf_flavour
operator|&&
name|elf_elfheader
argument_list|(
name|sub
argument_list|)
operator|->
name|e_ident
index|[
name|EI_CLASS
index|]
operator|==
name|bed
operator|->
name|s
operator|->
name|elfclass
operator|&&
operator|(
name|elfsec
operator|=
name|_bfd_elf_section_from_bfd_section
argument_list|(
name|sub
argument_list|,
name|s
argument_list|)
operator|)
operator|&&
name|elfsec
operator|<
name|elf_numsections
argument_list|(
name|sub
argument_list|)
operator|&&
name|elf_elfsections
argument_list|(
name|sub
argument_list|)
index|[
name|elfsec
index|]
operator|->
name|sh_flags
operator|&
name|SHF_LINK_ORDER
condition|)
block|{
name|seen_linkorder
operator|++
expr_stmt|;
name|linkorder_sec
operator|=
name|s
expr_stmt|;
block|}
else|else
block|{
name|seen_other
operator|++
expr_stmt|;
name|other_sec
operator|=
name|s
expr_stmt|;
block|}
block|}
else|else
name|seen_other
operator|++
expr_stmt|;
if|if
condition|(
name|seen_other
operator|&&
name|seen_linkorder
condition|)
block|{
if|if
condition|(
name|other_sec
operator|&&
name|linkorder_sec
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%A has both ordered [`%A' in %B] and unordered [`%A' in %B] sections"
argument_list|)
argument_list|,
name|o
argument_list|,
name|linkorder_sec
argument_list|,
name|linkorder_sec
operator|->
name|owner
argument_list|,
name|other_sec
argument_list|,
name|other_sec
operator|->
name|owner
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%A has both ordered and unordered sections"
argument_list|)
argument_list|,
name|o
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
if|if
condition|(
operator|!
name|seen_linkorder
condition|)
return|return
name|TRUE
return|;
name|sections
operator|=
operator|(
expr|struct
name|bfd_link_order
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|seen_linkorder
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|bfd_link_order
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|seen_linkorder
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|o
operator|->
name|map_head
operator|.
name|link_order
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|sections
index|[
name|seen_linkorder
operator|++
index|]
operator|=
name|p
expr_stmt|;
block|}
comment|/* Sort the input sections in the order of their linked section.  */
name|qsort
argument_list|(
name|sections
argument_list|,
name|seen_linkorder
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bfd_link_order
operator|*
argument_list|)
argument_list|,
name|compare_link_order
argument_list|)
expr_stmt|;
comment|/* Change the offsets of the sections.  */
name|offset
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|seen_linkorder
condition|;
name|n
operator|++
control|)
block|{
name|s
operator|=
name|sections
index|[
name|n
index|]
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
expr_stmt|;
name|offset
operator|&=
operator|~
call|(
name|bfd_vma
call|)
argument_list|(
operator|(
literal|1
operator|<<
name|s
operator|->
name|alignment_power
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|s
operator|->
name|output_offset
operator|=
name|offset
expr_stmt|;
name|sections
index|[
name|n
index|]
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
name|offset
operator|+=
name|sections
index|[
name|n
index|]
operator|->
name|size
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Do the final step of an ELF link.  */
end_comment

begin_function
name|bfd_boolean
name|bfd_elf_final_link
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|bfd_boolean
name|dynamic
decl_stmt|;
name|bfd_boolean
name|emit_relocs
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|struct
name|elf_final_link_info
name|finfo
decl_stmt|;
specifier|register
name|asection
modifier|*
name|o
decl_stmt|;
specifier|register
name|struct
name|bfd_link_order
modifier|*
name|p
decl_stmt|;
specifier|register
name|bfd
modifier|*
name|sub
decl_stmt|;
name|bfd_size_type
name|max_contents_size
decl_stmt|;
name|bfd_size_type
name|max_external_reloc_size
decl_stmt|;
name|bfd_size_type
name|max_internal_reloc_count
decl_stmt|;
name|bfd_size_type
name|max_sym_count
decl_stmt|;
name|bfd_size_type
name|max_sym_shndx_count
decl_stmt|;
name|file_ptr
name|off
decl_stmt|;
name|Elf_Internal_Sym
name|elfsym
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_shndx_hdr
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symstrtab_hdr
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|struct
name|elf_outext_info
name|eoinfo
decl_stmt|;
name|bfd_boolean
name|merged
decl_stmt|;
name|size_t
name|relativecount
init|=
literal|0
decl_stmt|;
name|asection
modifier|*
name|reldyn
init|=
literal|0
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|asection
modifier|*
name|attr_section
init|=
name|NULL
decl_stmt|;
name|bfd_vma
name|attr_size
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|std_attrs_section
decl_stmt|;
if|if
condition|(
operator|!
name|is_elf_hash_table
argument_list|(
name|info
operator|->
name|hash
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
name|abfd
operator|->
name|flags
operator||=
name|DYNAMIC
expr_stmt|;
name|dynamic
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
expr_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|emit_relocs
operator|=
operator|(
name|info
operator|->
name|relocatable
operator|||
name|info
operator|->
name|emitrelocations
operator|)
expr_stmt|;
name|finfo
operator|.
name|info
operator|=
name|info
expr_stmt|;
name|finfo
operator|.
name|output_bfd
operator|=
name|abfd
expr_stmt|;
name|finfo
operator|.
name|symstrtab
operator|=
name|_bfd_elf_stringtab_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|symstrtab
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|dynamic
condition|)
block|{
name|finfo
operator|.
name|dynsym_sec
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|hash_sec
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|symver_sec
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|finfo
operator|.
name|dynsym_sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynsym"
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|hash_sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".hash"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|finfo
operator|.
name|dynsym_sec
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|symver_sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".gnu.version"
argument_list|)
expr_stmt|;
comment|/* Note that it is OK if symver_sec is NULL.  */
block|}
name|finfo
operator|.
name|contents
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|external_relocs
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|internal_relocs
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|external_syms
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|locsym_shndx
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|internal_syms
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|indices
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|sections
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|symbuf
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|symshndxbuf
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|symbuf_count
operator|=
literal|0
expr_stmt|;
name|finfo
operator|.
name|shndxbuf_size
operator|=
literal|0
expr_stmt|;
comment|/* The object attributes have been merged.  Remove the input      sections from the link, and set the contents of the output      secton.  */
name|std_attrs_section
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|obj_attrs_section
expr_stmt|;
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|std_attrs_section
operator|&&
name|strcmp
argument_list|(
name|o
operator|->
name|name
argument_list|,
name|std_attrs_section
argument_list|)
operator|==
literal|0
operator|)
operator|||
name|strcmp
argument_list|(
name|o
operator|->
name|name
argument_list|,
literal|".gnu.attributes"
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|p
operator|=
name|o
operator|->
name|map_head
operator|.
name|link_order
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|asection
modifier|*
name|input_section
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|type
operator|!=
name|bfd_indirect_link_order
condition|)
continue|continue;
name|input_section
operator|=
name|p
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
expr_stmt|;
comment|/* Hack: reset the SEC_HAS_CONTENTS flag so that 		 elf_link_input_bfd ignores this section.  */
name|input_section
operator|->
name|flags
operator|&=
operator|~
name|SEC_HAS_CONTENTS
expr_stmt|;
block|}
name|attr_size
operator|=
name|bfd_elf_obj_attr_size
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr_size
condition|)
block|{
name|bfd_set_section_size
argument_list|(
name|abfd
argument_list|,
name|o
argument_list|,
name|attr_size
argument_list|)
expr_stmt|;
name|attr_section
operator|=
name|o
expr_stmt|;
comment|/* Skip this section later on.  */
name|o
operator|->
name|map_head
operator|.
name|link_order
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|o
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
block|}
block|}
comment|/* Count up the number of relocations we will output for each output      section, so that we know the sizes of the reloc sections.  We      also figure out some maximum sizes.  */
name|max_contents_size
operator|=
literal|0
expr_stmt|;
name|max_external_reloc_size
operator|=
literal|0
expr_stmt|;
name|max_internal_reloc_count
operator|=
literal|0
expr_stmt|;
name|max_sym_count
operator|=
literal|0
expr_stmt|;
name|max_sym_shndx_count
operator|=
literal|0
expr_stmt|;
name|merged
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
name|struct
name|bfd_elf_section_data
modifier|*
name|esdo
init|=
name|elf_section_data
argument_list|(
name|o
argument_list|)
decl_stmt|;
name|o
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|o
operator|->
name|map_head
operator|.
name|link_order
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|unsigned
name|int
name|reloc_count
init|=
literal|0
decl_stmt|;
name|struct
name|bfd_elf_section_data
modifier|*
name|esdi
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
modifier|*
name|rel_count1
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_section_reloc_link_order
operator|||
name|p
operator|->
name|type
operator|==
name|bfd_symbol_reloc_link_order
condition|)
name|reloc_count
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_indirect_link_order
condition|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|sec
operator|=
name|p
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
expr_stmt|;
name|esdi
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
expr_stmt|;
comment|/* Mark all sections which are to be included in the 		 link.  This will normally be every section.  We need 		 to do this so that we can identify any sections which 		 the linker has decided to not include.  */
name|sec
operator|->
name|linker_mark
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|flags
operator|&
name|SEC_MERGE
condition|)
name|merged
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
operator|||
name|info
operator|->
name|emitrelocations
condition|)
name|reloc_count
operator|=
name|sec
operator|->
name|reloc_count
expr_stmt|;
elseif|else
if|if
condition|(
name|bed
operator|->
name|elf_backend_count_relocs
condition|)
block|{
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|;
name|relocs
operator|=
name|_bfd_elf_link_read_relocs
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|sec
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|relocs
operator|!=
name|NULL
condition|)
block|{
name|reloc_count
operator|=
call|(
modifier|*
name|bed
operator|->
name|elf_backend_count_relocs
call|)
argument_list|(
name|sec
argument_list|,
name|relocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|!=
name|relocs
condition|)
name|free
argument_list|(
name|relocs
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sec
operator|->
name|rawsize
operator|>
name|max_contents_size
condition|)
name|max_contents_size
operator|=
name|sec
operator|->
name|rawsize
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|size
operator|>
name|max_contents_size
condition|)
name|max_contents_size
operator|=
name|sec
operator|->
name|size
expr_stmt|;
comment|/* We are interested in just local symbols, not all 		 symbols.  */
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|sec
operator|->
name|owner
argument_list|)
operator|==
name|bfd_target_elf_flavour
operator|&&
operator|(
name|sec
operator|->
name|owner
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|==
literal|0
condition|)
block|{
name|size_t
name|sym_count
decl_stmt|;
if|if
condition|(
name|elf_bad_symtab
argument_list|(
name|sec
operator|->
name|owner
argument_list|)
condition|)
name|sym_count
operator|=
operator|(
name|elf_tdata
argument_list|(
name|sec
operator|->
name|owner
argument_list|)
operator|->
name|symtab_hdr
operator|.
name|sh_size
operator|/
name|bed
operator|->
name|s
operator|->
name|sizeof_sym
operator|)
expr_stmt|;
else|else
name|sym_count
operator|=
name|elf_tdata
argument_list|(
name|sec
operator|->
name|owner
argument_list|)
operator|->
name|symtab_hdr
operator|.
name|sh_info
expr_stmt|;
if|if
condition|(
name|sym_count
operator|>
name|max_sym_count
condition|)
name|max_sym_count
operator|=
name|sym_count
expr_stmt|;
if|if
condition|(
name|sym_count
operator|>
name|max_sym_shndx_count
operator|&&
name|elf_symtab_shndx
argument_list|(
name|sec
operator|->
name|owner
argument_list|)
operator|!=
literal|0
condition|)
name|max_sym_shndx_count
operator|=
name|sym_count
expr_stmt|;
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|!=
literal|0
condition|)
block|{
name|size_t
name|ext_size
decl_stmt|;
name|ext_size
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|rel_hdr
operator|.
name|sh_size
expr_stmt|;
if|if
condition|(
name|ext_size
operator|>
name|max_external_reloc_size
condition|)
name|max_external_reloc_size
operator|=
name|ext_size
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|reloc_count
operator|>
name|max_internal_reloc_count
condition|)
name|max_internal_reloc_count
operator|=
name|sec
operator|->
name|reloc_count
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|reloc_count
operator|==
literal|0
condition|)
continue|continue;
name|o
operator|->
name|reloc_count
operator|+=
name|reloc_count
expr_stmt|;
comment|/* MIPS may have a mix of REL and RELA relocs on sections. 	     To support this curious ABI we keep reloc counts in 	     elf_section_data too.  We must be careful to add the 	     relocations from the input section to the right output 	     count.  FIXME: Get rid of one count.  We have 	     o->reloc_count == esdo->rel_count + esdo->rel_count2.  */
name|rel_count1
operator|=
operator|&
name|esdo
operator|->
name|rel_count
expr_stmt|;
if|if
condition|(
name|esdi
operator|!=
name|NULL
condition|)
block|{
name|bfd_boolean
name|same_size
decl_stmt|;
name|bfd_size_type
name|entsize1
decl_stmt|;
name|entsize1
operator|=
name|esdi
operator|->
name|rel_hdr
operator|.
name|sh_entsize
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|entsize1
operator|==
name|bed
operator|->
name|s
operator|->
name|sizeof_rel
operator|||
name|entsize1
operator|==
name|bed
operator|->
name|s
operator|->
name|sizeof_rela
argument_list|)
expr_stmt|;
name|same_size
operator|=
operator|!
name|o
operator|->
name|use_rela_p
operator|==
operator|(
name|entsize1
operator|==
name|bed
operator|->
name|s
operator|->
name|sizeof_rel
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|same_size
condition|)
name|rel_count1
operator|=
operator|&
name|esdo
operator|->
name|rel_count2
expr_stmt|;
if|if
condition|(
name|esdi
operator|->
name|rel_hdr2
operator|!=
name|NULL
condition|)
block|{
name|bfd_size_type
name|entsize2
init|=
name|esdi
operator|->
name|rel_hdr2
operator|->
name|sh_entsize
decl_stmt|;
name|unsigned
name|int
name|alt_count
decl_stmt|;
name|unsigned
name|int
modifier|*
name|rel_count2
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|entsize2
operator|!=
name|entsize1
operator|&&
operator|(
name|entsize2
operator|==
name|bed
operator|->
name|s
operator|->
name|sizeof_rel
operator|||
name|entsize2
operator|==
name|bed
operator|->
name|s
operator|->
name|sizeof_rela
operator|)
argument_list|)
expr_stmt|;
name|rel_count2
operator|=
operator|&
name|esdo
operator|->
name|rel_count2
expr_stmt|;
if|if
condition|(
operator|!
name|same_size
condition|)
name|rel_count2
operator|=
operator|&
name|esdo
operator|->
name|rel_count
expr_stmt|;
comment|/* The following is probably too simplistic if the 		     backend counts output relocs unusually.  */
name|BFD_ASSERT
argument_list|(
name|bed
operator|->
name|elf_backend_count_relocs
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|alt_count
operator|=
name|NUM_SHDR_ENTRIES
argument_list|(
name|esdi
operator|->
name|rel_hdr2
argument_list|)
expr_stmt|;
operator|*
name|rel_count2
operator|+=
name|alt_count
expr_stmt|;
name|reloc_count
operator|-=
name|alt_count
expr_stmt|;
block|}
block|}
operator|*
name|rel_count1
operator|+=
name|reloc_count
expr_stmt|;
block|}
if|if
condition|(
name|o
operator|->
name|reloc_count
operator|>
literal|0
condition|)
name|o
operator|->
name|flags
operator||=
name|SEC_RELOC
expr_stmt|;
else|else
block|{
comment|/* Explicitly clear the SEC_RELOC flag.  The linker tends to 	     set it (this is probably a bug) and if it is set 	     assign_section_numbers will create a reloc section.  */
name|o
operator|->
name|flags
operator|&=
operator|~
name|SEC_RELOC
expr_stmt|;
block|}
comment|/* If the SEC_ALLOC flag is not set, force the section VMA to 	 zero.  This is done in elf_fake_sections as well, but forcing 	 the VMA to 0 here will ensure that relocs against these 	 sections are handled correctly.  */
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|==
literal|0
operator|&&
operator|!
name|o
operator|->
name|user_set_vma
condition|)
name|o
operator|->
name|vma
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|info
operator|->
name|relocatable
operator|&&
name|merged
condition|)
name|elf_link_hash_traverse
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|_bfd_elf_link_sec_merge_syms
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
comment|/* Figure out the file positions for everything but the symbol table      and the relocs.  We set symcount to force assign_section_numbers      to create a symbol table.  */
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|=
name|info
operator|->
name|strip
operator|==
name|strip_all
condition|?
literal|0
else|:
literal|1
expr_stmt|;
name|BFD_ASSERT
argument_list|(
operator|!
name|abfd
operator|->
name|output_has_begun
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|_bfd_elf_compute_section_file_positions
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* Set sizes, and assign file positions for reloc sections.  */
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|_bfd_elf_link_size_reloc_section
argument_list|(
name|abfd
argument_list|,
operator|&
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_hdr
argument_list|,
name|o
argument_list|)
operator|)
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_hdr2
operator|&&
operator|!
operator|(
name|_bfd_elf_link_size_reloc_section
argument_list|(
name|abfd
argument_list|,
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_hdr2
argument_list|,
name|o
argument_list|)
operator|)
condition|)
goto|goto
name|error_return
goto|;
block|}
comment|/* Now, reset REL_COUNT and REL_COUNT2 so that we can use them 	 to count upwards while actually outputting the relocations.  */
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_count
operator|=
literal|0
expr_stmt|;
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_count2
operator|=
literal|0
expr_stmt|;
block|}
name|_bfd_elf_assign_file_positions_for_relocs
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* We have now assigned file positions for all the sections except      .symtab and .strtab.  We start the .symtab section at the current      file position, and write directly to it.  We build the .strtab      section in memory.  */
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|=
literal|0
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
comment|/* sh_name is set in prep_headers.  */
name|symtab_hdr
operator|->
name|sh_type
operator|=
name|SHT_SYMTAB
expr_stmt|;
comment|/* sh_flags, sh_addr and sh_size all start off zero.  */
name|symtab_hdr
operator|->
name|sh_entsize
operator|=
name|bed
operator|->
name|s
operator|->
name|sizeof_sym
expr_stmt|;
comment|/* sh_link is set in assign_section_numbers.  */
comment|/* sh_info is set below.  */
comment|/* sh_offset is set just below.  */
name|symtab_hdr
operator|->
name|sh_addralign
operator|=
literal|1
operator|<<
name|bed
operator|->
name|s
operator|->
name|log_file_align
expr_stmt|;
name|off
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|next_file_pos
expr_stmt|;
name|off
operator|=
name|_bfd_elf_assign_file_position_for_section
argument_list|(
name|symtab_hdr
argument_list|,
name|off
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* Note that at this point elf_tdata (abfd)->next_file_pos is      incorrect.  We do not yet know the size of the .symtab section.      We correct next_file_pos below, after we do know the size.  */
comment|/* Allocate a buffer to hold swapped out symbols.  This is to avoid      continuously seeking to the right position in the file.  */
if|if
condition|(
operator|!
name|info
operator|->
name|keep_memory
operator|||
name|max_sym_count
operator|<
literal|20
condition|)
name|finfo
operator|.
name|symbuf_size
operator|=
literal|20
expr_stmt|;
else|else
name|finfo
operator|.
name|symbuf_size
operator|=
name|max_sym_count
expr_stmt|;
name|amt
operator|=
name|finfo
operator|.
name|symbuf_size
expr_stmt|;
name|amt
operator|*=
name|bed
operator|->
name|s
operator|->
name|sizeof_sym
expr_stmt|;
name|finfo
operator|.
name|symbuf
operator|=
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|symbuf
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|elf_numsections
argument_list|(
name|abfd
argument_list|)
operator|>
name|SHN_LORESERVE
condition|)
block|{
comment|/* Wild guess at number of output symbols.  realloc'd as needed.  */
name|amt
operator|=
literal|2
operator|*
name|max_sym_count
operator|+
name|elf_numsections
argument_list|(
name|abfd
argument_list|)
operator|+
literal|1000
expr_stmt|;
name|finfo
operator|.
name|shndxbuf_size
operator|=
name|amt
expr_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
name|Elf_External_Sym_Shndx
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|symshndxbuf
operator|=
name|bfd_zmalloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|symshndxbuf
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
block|}
comment|/* Start writing out the symbol table.  The first symbol is always a      dummy symbol.  */
if|if
condition|(
name|info
operator|->
name|strip
operator|!=
name|strip_all
operator|||
name|emit_relocs
condition|)
block|{
name|elfsym
operator|.
name|st_value
operator|=
literal|0
expr_stmt|;
name|elfsym
operator|.
name|st_size
operator|=
literal|0
expr_stmt|;
name|elfsym
operator|.
name|st_info
operator|=
literal|0
expr_stmt|;
name|elfsym
operator|.
name|st_other
operator|=
literal|0
expr_stmt|;
name|elfsym
operator|.
name|st_shndx
operator|=
name|SHN_UNDEF
expr_stmt|;
if|if
condition|(
operator|!
name|elf_link_output_sym
argument_list|(
operator|&
name|finfo
argument_list|,
name|NULL
argument_list|,
operator|&
name|elfsym
argument_list|,
name|bfd_und_section_ptr
argument_list|,
name|NULL
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
comment|/* Output a symbol for each section.  We output these even if we are      discarding local symbols, since they are used for relocs.  These      symbols have no names.  We store the index of each one in the      index field of the section, so that we can find it again when      outputting relocs.  */
if|if
condition|(
name|info
operator|->
name|strip
operator|!=
name|strip_all
operator|||
name|emit_relocs
condition|)
block|{
name|elfsym
operator|.
name|st_size
operator|=
literal|0
expr_stmt|;
name|elfsym
operator|.
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_LOCAL
argument_list|,
name|STT_SECTION
argument_list|)
expr_stmt|;
name|elfsym
operator|.
name|st_other
operator|=
literal|0
expr_stmt|;
name|elfsym
operator|.
name|st_value
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|elf_numsections
argument_list|(
name|abfd
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|o
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|abfd
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|!=
name|NULL
condition|)
block|{
name|o
operator|->
name|target_index
operator|=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|elfsym
operator|.
name|st_shndx
operator|=
name|i
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|relocatable
condition|)
name|elfsym
operator|.
name|st_value
operator|=
name|o
operator|->
name|vma
expr_stmt|;
if|if
condition|(
operator|!
name|elf_link_output_sym
argument_list|(
operator|&
name|finfo
argument_list|,
name|NULL
argument_list|,
operator|&
name|elfsym
argument_list|,
name|o
argument_list|,
name|NULL
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
if|if
condition|(
name|i
operator|==
name|SHN_LORESERVE
operator|-
literal|1
condition|)
name|i
operator|+=
name|SHN_HIRESERVE
operator|+
literal|1
operator|-
name|SHN_LORESERVE
expr_stmt|;
block|}
block|}
comment|/* Allocate some memory to hold information read in from the input      files.  */
if|if
condition|(
name|max_contents_size
operator|!=
literal|0
condition|)
block|{
name|finfo
operator|.
name|contents
operator|=
name|bfd_malloc
argument_list|(
name|max_contents_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|contents
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
block|}
if|if
condition|(
name|max_external_reloc_size
operator|!=
literal|0
condition|)
block|{
name|finfo
operator|.
name|external_relocs
operator|=
name|bfd_malloc
argument_list|(
name|max_external_reloc_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|external_relocs
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
block|}
if|if
condition|(
name|max_internal_reloc_count
operator|!=
literal|0
condition|)
block|{
name|amt
operator|=
name|max_internal_reloc_count
operator|*
name|bed
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
expr_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
name|Elf_Internal_Rela
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|internal_relocs
operator|=
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|internal_relocs
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
block|}
if|if
condition|(
name|max_sym_count
operator|!=
literal|0
condition|)
block|{
name|amt
operator|=
name|max_sym_count
operator|*
name|bed
operator|->
name|s
operator|->
name|sizeof_sym
expr_stmt|;
name|finfo
operator|.
name|external_syms
operator|=
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|external_syms
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|amt
operator|=
name|max_sym_count
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Internal_Sym
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|internal_syms
operator|=
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|internal_syms
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|amt
operator|=
name|max_sym_count
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|indices
operator|=
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|indices
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|amt
operator|=
name|max_sym_count
operator|*
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|sections
operator|=
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|sections
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
block|}
if|if
condition|(
name|max_sym_shndx_count
operator|!=
literal|0
condition|)
block|{
name|amt
operator|=
name|max_sym_shndx_count
operator|*
sizeof|sizeof
argument_list|(
name|Elf_External_Sym_Shndx
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|locsym_shndx
operator|=
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|locsym_shndx
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
block|}
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|tls_sec
condition|)
block|{
name|bfd_vma
name|base
decl_stmt|,
name|end
init|=
literal|0
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
for|for
control|(
name|sec
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|tls_sec
init|;
name|sec
operator|&&
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_THREAD_LOCAL
operator|)
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
block|{
name|bfd_size_type
name|size
init|=
name|sec
operator|->
name|size
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
operator|&&
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|==
literal|0
condition|)
block|{
name|struct
name|bfd_link_order
modifier|*
name|o
init|=
name|sec
operator|->
name|map_tail
operator|.
name|link_order
decl_stmt|;
if|if
condition|(
name|o
operator|!=
name|NULL
condition|)
name|size
operator|=
name|o
operator|->
name|offset
operator|+
name|o
operator|->
name|size
expr_stmt|;
block|}
name|end
operator|=
name|sec
operator|->
name|vma
operator|+
name|size
expr_stmt|;
block|}
name|base
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|tls_sec
operator|->
name|vma
expr_stmt|;
name|end
operator|=
name|align_power
argument_list|(
name|end
argument_list|,
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|tls_sec
operator|->
name|alignment_power
argument_list|)
expr_stmt|;
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|tls_size
operator|=
name|end
operator|-
name|base
expr_stmt|;
block|}
comment|/* Reorder SHF_LINK_ORDER sections.  */
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|elf_fixup_link_order
argument_list|(
name|abfd
argument_list|,
name|o
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Since ELF permits relocations to be against local symbols, we      must have the local symbols available when we do the relocations.      Since we would rather only read the local symbols once, and we      would rather not keep them in memory, we handle all the      relocations for a single input file at the same time.       Unfortunately, there is no way to know the total number of local      symbols until we have seen all of them, and the local symbol      indices precede the global symbol indices.  This means that when      we are generating relocatable output, and we see a reloc against      a global symbol, we can not know the symbol index until we have      finished examining all the local symbols to see which ones we are      going to output.  To deal with this, we keep the relocations in      memory, and don't output them until the end of the link.  This is      an unfortunate waste of memory, but I don't see a good way around      it.  Fortunately, it only happens when performing a relocatable      link, which is not the common case.  FIXME: If keep_memory is set      we could write the relocs out and then read them again; I don't      know how bad the memory loss will be.  */
for|for
control|(
name|sub
operator|=
name|info
operator|->
name|input_bfds
init|;
name|sub
operator|!=
name|NULL
condition|;
name|sub
operator|=
name|sub
operator|->
name|link_next
control|)
name|sub
operator|->
name|output_has_begun
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
for|for
control|(
name|p
operator|=
name|o
operator|->
name|map_head
operator|.
name|link_order
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_indirect_link_order
operator|&&
operator|(
name|bfd_get_flavour
argument_list|(
operator|(
name|sub
operator|=
name|p
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
operator|->
name|owner
operator|)
argument_list|)
operator|==
name|bfd_target_elf_flavour
operator|)
operator|&&
name|elf_elfheader
argument_list|(
name|sub
argument_list|)
operator|->
name|e_ident
index|[
name|EI_CLASS
index|]
operator|==
name|bed
operator|->
name|s
operator|->
name|elfclass
condition|)
block|{
if|if
condition|(
operator|!
name|sub
operator|->
name|output_has_begun
condition|)
block|{
if|if
condition|(
operator|!
name|elf_link_input_bfd
argument_list|(
operator|&
name|finfo
argument_list|,
name|sub
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
name|sub
operator|->
name|output_has_begun
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_section_reloc_link_order
operator|||
name|p
operator|->
name|type
operator|==
name|bfd_symbol_reloc_link_order
condition|)
block|{
if|if
condition|(
operator|!
name|elf_reloc_link_order
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|o
argument_list|,
name|p
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|_bfd_default_link_order
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|o
argument_list|,
name|p
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
block|}
block|}
comment|/* Free symbol buffer if needed.  */
if|if
condition|(
operator|!
name|info
operator|->
name|reduce_memory_overheads
condition|)
block|{
for|for
control|(
name|sub
operator|=
name|info
operator|->
name|input_bfds
init|;
name|sub
operator|!=
name|NULL
condition|;
name|sub
operator|=
name|sub
operator|->
name|link_next
control|)
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|sub
argument_list|)
operator|==
name|bfd_target_elf_flavour
operator|&&
name|elf_tdata
argument_list|(
name|sub
argument_list|)
operator|->
name|symbuf
condition|)
block|{
name|free
argument_list|(
name|elf_tdata
argument_list|(
name|sub
argument_list|)
operator|->
name|symbuf
argument_list|)
expr_stmt|;
name|elf_tdata
argument_list|(
name|sub
argument_list|)
operator|->
name|symbuf
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* Output any global symbols that got converted to local in a      version script or due to symbol visibility.  We do this in a      separate step since ELF requires all local symbols to appear      prior to any global symbols.  FIXME: We should only do this if      some global symbols were, in fact, converted to become local.      FIXME: Will this work correctly with the Irix 5 linker?  */
name|eoinfo
operator|.
name|failed
operator|=
name|FALSE
expr_stmt|;
name|eoinfo
operator|.
name|finfo
operator|=
operator|&
name|finfo
expr_stmt|;
name|eoinfo
operator|.
name|localsyms
operator|=
name|TRUE
expr_stmt|;
name|elf_link_hash_traverse
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|elf_link_output_extsym
argument_list|,
operator|&
name|eoinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|eoinfo
operator|.
name|failed
condition|)
return|return
name|FALSE
return|;
comment|/* If backend needs to output some local symbols not present in the hash      table, do it now.  */
if|if
condition|(
name|bed
operator|->
name|elf_backend_output_arch_local_syms
condition|)
block|{
typedef|typedef
name|bfd_boolean
function_decl|(
modifier|*
name|out_sym_func
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|Elf_Internal_Sym
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
parameter_list|)
function_decl|;
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|bed
operator|->
name|elf_backend_output_arch_local_syms
call|)
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
operator|&
name|finfo
argument_list|,
operator|(
name|out_sym_func
operator|)
name|elf_link_output_sym
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* That wrote out all the local symbols.  Finish up the symbol table      with the global symbols. Even if we want to strip everything we      can, we still need to deal with those global symbols that got      converted to local in a version script.  */
comment|/* The sh_info field records the index of the first non local symbol.  */
name|symtab_hdr
operator|->
name|sh_info
operator|=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynamic
operator|&&
name|finfo
operator|.
name|dynsym_sec
operator|->
name|output_section
operator|!=
name|bfd_abs_section_ptr
condition|)
block|{
name|Elf_Internal_Sym
name|sym
decl_stmt|;
name|bfd_byte
modifier|*
name|dynsym
init|=
name|finfo
operator|.
name|dynsym_sec
operator|->
name|contents
decl_stmt|;
name|long
name|last_local
init|=
literal|0
decl_stmt|;
comment|/* Write out the section symbols for the output sections.  */
if|if
condition|(
name|info
operator|->
name|shared
operator|||
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|is_relocatable_executable
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|sym
operator|.
name|st_size
operator|=
literal|0
expr_stmt|;
name|sym
operator|.
name|st_name
operator|=
literal|0
expr_stmt|;
name|sym
operator|.
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_LOCAL
argument_list|,
name|STT_SECTION
argument_list|)
expr_stmt|;
name|sym
operator|.
name|st_other
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|int
name|indx
decl_stmt|;
name|bfd_byte
modifier|*
name|dest
decl_stmt|;
name|long
name|dynindx
decl_stmt|;
name|dynindx
operator|=
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|dynindx
expr_stmt|;
if|if
condition|(
name|dynindx
operator|<=
literal|0
condition|)
continue|continue;
name|indx
operator|=
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|this_idx
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|indx
operator|>
literal|0
argument_list|)
expr_stmt|;
name|sym
operator|.
name|st_shndx
operator|=
name|indx
expr_stmt|;
if|if
condition|(
operator|!
name|check_dynsym
argument_list|(
name|abfd
argument_list|,
operator|&
name|sym
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|sym
operator|.
name|st_value
operator|=
name|s
operator|->
name|vma
expr_stmt|;
name|dest
operator|=
name|dynsym
operator|+
name|dynindx
operator|*
name|bed
operator|->
name|s
operator|->
name|sizeof_sym
expr_stmt|;
if|if
condition|(
name|last_local
operator|<
name|dynindx
condition|)
name|last_local
operator|=
name|dynindx
expr_stmt|;
name|bed
operator|->
name|s
operator|->
name|swap_symbol_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|sym
argument_list|,
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Write out the local dynsyms.  */
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynlocal
condition|)
block|{
name|struct
name|elf_link_local_dynamic_entry
modifier|*
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynlocal
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next
control|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_byte
modifier|*
name|dest
decl_stmt|;
name|sym
operator|.
name|st_size
operator|=
name|e
operator|->
name|isym
operator|.
name|st_size
expr_stmt|;
name|sym
operator|.
name|st_other
operator|=
name|e
operator|->
name|isym
operator|.
name|st_other
expr_stmt|;
comment|/* Copy the internal symbol as is. 		 Note that we saved a word of storage and overwrote 		 the original st_name with the dynstr_index.  */
name|sym
operator|=
name|e
operator|->
name|isym
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|isym
operator|.
name|st_shndx
operator|!=
name|SHN_UNDEF
operator|&&
operator|(
name|e
operator|->
name|isym
operator|.
name|st_shndx
operator|<
name|SHN_LORESERVE
operator|||
name|e
operator|->
name|isym
operator|.
name|st_shndx
operator|>
name|SHN_HIRESERVE
operator|)
condition|)
block|{
name|s
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|e
operator|->
name|input_bfd
argument_list|,
name|e
operator|->
name|isym
operator|.
name|st_shndx
argument_list|)
expr_stmt|;
name|sym
operator|.
name|st_shndx
operator|=
name|elf_section_data
argument_list|(
name|s
operator|->
name|output_section
argument_list|)
operator|->
name|this_idx
expr_stmt|;
if|if
condition|(
operator|!
name|check_dynsym
argument_list|(
name|abfd
argument_list|,
operator|&
name|sym
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|sym
operator|.
name|st_value
operator|=
operator|(
name|s
operator|->
name|output_section
operator|->
name|vma
operator|+
name|s
operator|->
name|output_offset
operator|+
name|e
operator|->
name|isym
operator|.
name|st_value
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|last_local
operator|<
name|e
operator|->
name|dynindx
condition|)
name|last_local
operator|=
name|e
operator|->
name|dynindx
expr_stmt|;
name|dest
operator|=
name|dynsym
operator|+
name|e
operator|->
name|dynindx
operator|*
name|bed
operator|->
name|s
operator|->
name|sizeof_sym
expr_stmt|;
name|bed
operator|->
name|s
operator|->
name|swap_symbol_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|sym
argument_list|,
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|elf_section_data
argument_list|(
name|finfo
operator|.
name|dynsym_sec
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_info
operator|=
name|last_local
operator|+
literal|1
expr_stmt|;
block|}
comment|/* We get the global symbols from the hash table.  */
name|eoinfo
operator|.
name|failed
operator|=
name|FALSE
expr_stmt|;
name|eoinfo
operator|.
name|localsyms
operator|=
name|FALSE
expr_stmt|;
name|eoinfo
operator|.
name|finfo
operator|=
operator|&
name|finfo
expr_stmt|;
name|elf_link_hash_traverse
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|elf_link_output_extsym
argument_list|,
operator|&
name|eoinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|eoinfo
operator|.
name|failed
condition|)
return|return
name|FALSE
return|;
comment|/* If backend needs to output some symbols not present in the hash      table, do it now.  */
if|if
condition|(
name|bed
operator|->
name|elf_backend_output_arch_syms
condition|)
block|{
typedef|typedef
name|bfd_boolean
function_decl|(
modifier|*
name|out_sym_func
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|Elf_Internal_Sym
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
parameter_list|)
function_decl|;
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|bed
operator|->
name|elf_backend_output_arch_syms
call|)
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
operator|&
name|finfo
argument_list|,
operator|(
name|out_sym_func
operator|)
name|elf_link_output_sym
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Flush all symbols to the file.  */
if|if
condition|(
operator|!
name|elf_link_flush_output_syms
argument_list|(
operator|&
name|finfo
argument_list|,
name|bed
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Now we know the size of the symtab section.  */
name|off
operator|+=
name|symtab_hdr
operator|->
name|sh_size
expr_stmt|;
name|symtab_shndx_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_shndx_hdr
expr_stmt|;
if|if
condition|(
name|symtab_shndx_hdr
operator|->
name|sh_name
operator|!=
literal|0
condition|)
block|{
name|symtab_shndx_hdr
operator|->
name|sh_type
operator|=
name|SHT_SYMTAB_SHNDX
expr_stmt|;
name|symtab_shndx_hdr
operator|->
name|sh_entsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf_External_Sym_Shndx
argument_list|)
expr_stmt|;
name|symtab_shndx_hdr
operator|->
name|sh_addralign
operator|=
sizeof|sizeof
argument_list|(
name|Elf_External_Sym_Shndx
argument_list|)
expr_stmt|;
name|amt
operator|=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|Elf_External_Sym_Shndx
argument_list|)
expr_stmt|;
name|symtab_shndx_hdr
operator|->
name|sh_size
operator|=
name|amt
expr_stmt|;
name|off
operator|=
name|_bfd_elf_assign_file_position_for_section
argument_list|(
name|symtab_shndx_hdr
argument_list|,
name|off
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|symtab_shndx_hdr
operator|->
name|sh_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|bfd_bwrite
argument_list|(
name|finfo
operator|.
name|symshndxbuf
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
operator|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Finish up and write out the symbol string table (.strtab)      section.  */
name|symstrtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|strtab_hdr
expr_stmt|;
comment|/* sh_name was set in prep_headers.  */
name|symstrtab_hdr
operator|->
name|sh_type
operator|=
name|SHT_STRTAB
expr_stmt|;
name|symstrtab_hdr
operator|->
name|sh_flags
operator|=
literal|0
expr_stmt|;
name|symstrtab_hdr
operator|->
name|sh_addr
operator|=
literal|0
expr_stmt|;
name|symstrtab_hdr
operator|->
name|sh_size
operator|=
name|_bfd_stringtab_size
argument_list|(
name|finfo
operator|.
name|symstrtab
argument_list|)
expr_stmt|;
name|symstrtab_hdr
operator|->
name|sh_entsize
operator|=
literal|0
expr_stmt|;
name|symstrtab_hdr
operator|->
name|sh_link
operator|=
literal|0
expr_stmt|;
name|symstrtab_hdr
operator|->
name|sh_info
operator|=
literal|0
expr_stmt|;
comment|/* sh_offset is set just below.  */
name|symstrtab_hdr
operator|->
name|sh_addralign
operator|=
literal|1
expr_stmt|;
name|off
operator|=
name|_bfd_elf_assign_file_position_for_section
argument_list|(
name|symstrtab_hdr
argument_list|,
name|off
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|next_file_pos
operator|=
name|off
expr_stmt|;
if|if
condition|(
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|symstrtab_hdr
operator|->
name|sh_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
operator|!
name|_bfd_stringtab_emit
argument_list|(
name|abfd
argument_list|,
name|finfo
operator|.
name|symstrtab
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Adjust the relocs to have the correct symbol indices.  */
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|elf_link_adjust_relocs
argument_list|(
name|abfd
argument_list|,
operator|&
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_hdr
argument_list|,
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_count
argument_list|,
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_hashes
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_hdr2
operator|!=
name|NULL
condition|)
name|elf_link_adjust_relocs
argument_list|(
name|abfd
argument_list|,
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_hdr2
argument_list|,
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_count2
argument_list|,
operator|(
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_hashes
operator|+
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_count
operator|)
argument_list|)
expr_stmt|;
comment|/* Set the reloc_count field to 0 to prevent write_relocs from 	 trying to swap the relocs out itself.  */
name|o
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|dynamic
operator|&&
name|info
operator|->
name|combreloc
operator|&&
name|dynobj
operator|!=
name|NULL
condition|)
name|relativecount
operator|=
name|elf_link_sort_relocs
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
operator|&
name|reldyn
argument_list|)
expr_stmt|;
comment|/* If we are linking against a dynamic object, or generating a      shared library, finish up the dynamic linking information.  */
if|if
condition|(
name|dynamic
condition|)
block|{
name|bfd_byte
modifier|*
name|dyncon
decl_stmt|,
modifier|*
name|dynconend
decl_stmt|;
comment|/* Fix up .dynamic entries.  */
name|o
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|o
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dyncon
operator|=
name|o
operator|->
name|contents
expr_stmt|;
name|dynconend
operator|=
name|o
operator|->
name|contents
operator|+
name|o
operator|->
name|size
expr_stmt|;
for|for
control|(
init|;
name|dyncon
operator|<
name|dynconend
condition|;
name|dyncon
operator|+=
name|bed
operator|->
name|s
operator|->
name|sizeof_dyn
control|)
block|{
name|Elf_Internal_Dyn
name|dyn
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|int
name|type
decl_stmt|;
name|bed
operator|->
name|s
operator|->
name|swap_dyn_in
argument_list|(
name|dynobj
argument_list|,
name|dyncon
argument_list|,
operator|&
name|dyn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dyn
operator|.
name|d_tag
condition|)
block|{
default|default:
continue|continue;
case|case
name|DT_NULL
case|:
if|if
condition|(
name|relativecount
operator|>
literal|0
operator|&&
name|dyncon
operator|+
name|bed
operator|->
name|s
operator|->
name|sizeof_dyn
operator|<
name|dynconend
condition|)
block|{
switch|switch
condition|(
name|elf_section_data
argument_list|(
name|reldyn
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_type
condition|)
block|{
case|case
name|SHT_REL
case|:
name|dyn
operator|.
name|d_tag
operator|=
name|DT_RELCOUNT
expr_stmt|;
break|break;
case|case
name|SHT_RELA
case|:
name|dyn
operator|.
name|d_tag
operator|=
name|DT_RELACOUNT
expr_stmt|;
break|break;
default|default:
continue|continue;
block|}
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|relativecount
expr_stmt|;
name|relativecount
operator|=
literal|0
expr_stmt|;
break|break;
block|}
continue|continue;
case|case
name|DT_INIT
case|:
name|name
operator|=
name|info
operator|->
name|init_function
expr_stmt|;
goto|goto
name|get_sym
goto|;
case|case
name|DT_FINI
case|:
name|name
operator|=
name|info
operator|->
name|fini_function
expr_stmt|;
name|get_sym
label|:
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
name|elf_link_hash_lookup
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
condition|)
block|{
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
name|o
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|output_section
operator|!=
name|NULL
condition|)
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|+=
operator|(
name|o
operator|->
name|output_section
operator|->
name|vma
operator|+
name|o
operator|->
name|output_offset
operator|)
expr_stmt|;
else|else
block|{
comment|/* The symbol is imported from another shared 			   library and does not apply to this one.  */
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
block|}
continue|continue;
case|case
name|DT_PREINIT_ARRAYSZ
case|:
name|name
operator|=
literal|".preinit_array"
expr_stmt|;
goto|goto
name|get_size
goto|;
case|case
name|DT_INIT_ARRAYSZ
case|:
name|name
operator|=
literal|".init_array"
expr_stmt|;
goto|goto
name|get_size
goto|;
case|case
name|DT_FINI_ARRAYSZ
case|:
name|name
operator|=
literal|".fini_array"
expr_stmt|;
name|get_size
label|:
name|o
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: could not find output section %s"
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
if|if
condition|(
name|o
operator|->
name|size
operator|==
literal|0
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"warning: %s section has zero size"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|o
operator|->
name|size
expr_stmt|;
break|break;
case|case
name|DT_PREINIT_ARRAY
case|:
name|name
operator|=
literal|".preinit_array"
expr_stmt|;
goto|goto
name|get_vma
goto|;
case|case
name|DT_INIT_ARRAY
case|:
name|name
operator|=
literal|".init_array"
expr_stmt|;
goto|goto
name|get_vma
goto|;
case|case
name|DT_FINI_ARRAY
case|:
name|name
operator|=
literal|".fini_array"
expr_stmt|;
goto|goto
name|get_vma
goto|;
case|case
name|DT_HASH
case|:
name|name
operator|=
literal|".hash"
expr_stmt|;
goto|goto
name|get_vma
goto|;
case|case
name|DT_GNU_HASH
case|:
name|name
operator|=
literal|".gnu.hash"
expr_stmt|;
goto|goto
name|get_vma
goto|;
case|case
name|DT_STRTAB
case|:
name|name
operator|=
literal|".dynstr"
expr_stmt|;
goto|goto
name|get_vma
goto|;
case|case
name|DT_SYMTAB
case|:
name|name
operator|=
literal|".dynsym"
expr_stmt|;
goto|goto
name|get_vma
goto|;
case|case
name|DT_VERDEF
case|:
name|name
operator|=
literal|".gnu.version_d"
expr_stmt|;
goto|goto
name|get_vma
goto|;
case|case
name|DT_VERNEED
case|:
name|name
operator|=
literal|".gnu.version_r"
expr_stmt|;
goto|goto
name|get_vma
goto|;
case|case
name|DT_VERSYM
case|:
name|name
operator|=
literal|".gnu.version"
expr_stmt|;
name|get_vma
label|:
name|o
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: could not find output section %s"
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|o
operator|->
name|vma
expr_stmt|;
break|break;
case|case
name|DT_REL
case|:
case|case
name|DT_RELA
case|:
case|case
name|DT_RELSZ
case|:
case|case
name|DT_RELASZ
case|:
if|if
condition|(
name|dyn
operator|.
name|d_tag
operator|==
name|DT_REL
operator|||
name|dyn
operator|.
name|d_tag
operator|==
name|DT_RELSZ
condition|)
name|type
operator|=
name|SHT_REL
expr_stmt|;
else|else
name|type
operator|=
name|SHT_RELA
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|elf_numsections
argument_list|(
name|abfd
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
name|hdr
operator|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|sh_type
operator|==
name|type
operator|&&
operator|(
name|hdr
operator|->
name|sh_flags
operator|&
name|SHF_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|dyn
operator|.
name|d_tag
operator|==
name|DT_RELSZ
operator|||
name|dyn
operator|.
name|d_tag
operator|==
name|DT_RELASZ
condition|)
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|+=
name|hdr
operator|->
name|sh_size
expr_stmt|;
else|else
block|{
if|if
condition|(
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|==
literal|0
operator|||
name|hdr
operator|->
name|sh_addr
operator|<
name|dyn
operator|.
name|d_un
operator|.
name|d_val
condition|)
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|hdr
operator|->
name|sh_addr
expr_stmt|;
block|}
block|}
block|}
break|break;
block|}
name|bed
operator|->
name|s
operator|->
name|swap_dyn_out
argument_list|(
name|dynobj
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If we have created any dynamic sections, then output them.  */
if|if
condition|(
name|dynobj
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
call|(
modifier|*
name|bed
operator|->
name|elf_backend_finish_dynamic_sections
call|)
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* Check for DT_TEXTREL (late, in case the backend removes it).  */
if|if
condition|(
name|info
operator|->
name|warn_shared_textrel
operator|&&
name|info
operator|->
name|shared
condition|)
block|{
name|bfd_byte
modifier|*
name|dyncon
decl_stmt|,
modifier|*
name|dynconend
decl_stmt|;
comment|/* Fix up .dynamic entries.  */
name|o
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|o
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dyncon
operator|=
name|o
operator|->
name|contents
expr_stmt|;
name|dynconend
operator|=
name|o
operator|->
name|contents
operator|+
name|o
operator|->
name|size
expr_stmt|;
for|for
control|(
init|;
name|dyncon
operator|<
name|dynconend
condition|;
name|dyncon
operator|+=
name|bed
operator|->
name|s
operator|->
name|sizeof_dyn
control|)
block|{
name|Elf_Internal_Dyn
name|dyn
decl_stmt|;
name|bed
operator|->
name|s
operator|->
name|swap_dyn_in
argument_list|(
name|dynobj
argument_list|,
name|dyncon
argument_list|,
operator|&
name|dyn
argument_list|)
expr_stmt|;
if|if
condition|(
name|dyn
operator|.
name|d_tag
operator|==
name|DT_TEXTREL
condition|)
block|{
name|info
operator|->
name|callbacks
operator|->
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P: warning: creating a DT_TEXTREL in a shared object.\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
for|for
control|(
name|o
operator|=
name|dynobj
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|==
literal|0
operator|||
name|o
operator|->
name|size
operator|==
literal|0
operator|||
name|o
operator|->
name|output_section
operator|==
name|bfd_abs_section_ptr
condition|)
continue|continue;
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_LINKER_CREATED
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* At this point, we are only interested in sections 		 created by _bfd_elf_link_create_dynamic_sections.  */
continue|continue;
block|}
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|stab_info
operator|.
name|stabstr
operator|==
name|o
condition|)
continue|continue;
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|eh_info
operator|.
name|hdr_sec
operator|==
name|o
condition|)
continue|continue;
if|if
condition|(
operator|(
name|elf_section_data
argument_list|(
name|o
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_type
operator|!=
name|SHT_STRTAB
operator|)
operator|||
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|o
argument_list|)
argument_list|,
literal|".dynstr"
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|o
operator|->
name|output_section
argument_list|,
name|o
operator|->
name|contents
argument_list|,
operator|(
name|file_ptr
operator|)
name|o
operator|->
name|output_offset
argument_list|,
name|o
operator|->
name|size
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
else|else
block|{
comment|/* The contents of the .dynstr section are actually in a 		 stringtab.  */
name|off
operator|=
name|elf_section_data
argument_list|(
name|o
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_offset
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|off
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
operator|!
name|_bfd_elf_strtab_emit
argument_list|(
name|abfd
argument_list|,
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
block|}
block|}
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
block|{
name|bfd_boolean
name|failed
init|=
name|FALSE
decl_stmt|;
name|bfd_map_over_sections
argument_list|(
name|abfd
argument_list|,
name|bfd_elf_set_group_contents
argument_list|,
operator|&
name|failed
argument_list|)
expr_stmt|;
if|if
condition|(
name|failed
condition|)
goto|goto
name|error_return
goto|;
block|}
comment|/* If we have optimized stabs strings, output them.  */
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|stab_info
operator|.
name|stabstr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|_bfd_write_stab_strings
argument_list|(
name|abfd
argument_list|,
operator|&
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|stab_info
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
if|if
condition|(
name|info
operator|->
name|eh_frame_hdr
condition|)
block|{
if|if
condition|(
operator|!
name|_bfd_elf_write_section_eh_frame_hdr
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
if|if
condition|(
name|finfo
operator|.
name|symstrtab
operator|!=
name|NULL
condition|)
name|_bfd_stringtab_free
argument_list|(
name|finfo
operator|.
name|symstrtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|contents
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|contents
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|external_relocs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|external_relocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|internal_relocs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|internal_relocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|external_syms
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|external_syms
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|locsym_shndx
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|locsym_shndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|internal_syms
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|internal_syms
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|indices
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|indices
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|sections
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|sections
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|symbuf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|symbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|symshndxbuf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|symshndxbuf
argument_list|)
expr_stmt|;
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|!=
literal|0
operator|&&
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_hashes
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_hashes
argument_list|)
expr_stmt|;
block|}
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|linker
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|attr_section
condition|)
block|{
name|bfd_byte
modifier|*
name|contents
init|=
name|bfd_malloc
argument_list|(
name|attr_size
argument_list|)
decl_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|bfd_elf_set_obj_attr_contents
argument_list|(
name|abfd
argument_list|,
name|contents
argument_list|,
name|attr_size
argument_list|)
expr_stmt|;
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|attr_section
argument_list|,
name|contents
argument_list|,
literal|0
argument_list|,
name|attr_size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
name|error_return
label|:
if|if
condition|(
name|finfo
operator|.
name|symstrtab
operator|!=
name|NULL
condition|)
name|_bfd_stringtab_free
argument_list|(
name|finfo
operator|.
name|symstrtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|contents
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|contents
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|external_relocs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|external_relocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|internal_relocs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|internal_relocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|external_syms
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|external_syms
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|locsym_shndx
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|locsym_shndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|internal_syms
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|internal_syms
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|indices
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|indices
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|sections
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|sections
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|symbuf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|symbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|symshndxbuf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|symshndxbuf
argument_list|)
expr_stmt|;
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|!=
literal|0
operator|&&
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_hashes
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|rel_hashes
argument_list|)
expr_stmt|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Garbage collect unused sections.  */
end_comment

begin_comment
comment|/* Default gc_mark_hook.  */
end_comment

begin_function
name|asection
modifier|*
name|_bfd_elf_gc_mark_hook
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|rel
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|)
block|{
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|h
operator|->
name|root
operator|.
name|type
condition|)
block|{
case|case
name|bfd_link_hash_defined
case|:
case|case
name|bfd_link_hash_defweak
case|:
return|return
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
return|;
case|case
name|bfd_link_hash_common
case|:
return|return
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
return|;
default|default:
break|break;
block|}
block|}
else|else
return|return
name|bfd_section_from_elf_index
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|sym
operator|->
name|st_shndx
argument_list|)
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* The mark phase of garbage collection.  For a given section, mark    it and any sections in this section's group, and all the sections    which define symbols to which it refers.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_elf_gc_mark
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|elf_gc_mark_hook_fn
name|gc_mark_hook
parameter_list|)
block|{
name|bfd_boolean
name|ret
decl_stmt|;
name|bfd_boolean
name|is_eh
decl_stmt|;
name|asection
modifier|*
name|group_sec
decl_stmt|;
name|sec
operator|->
name|gc_mark
operator|=
literal|1
expr_stmt|;
comment|/* Mark all the sections in the group.  */
name|group_sec
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|next_in_group
expr_stmt|;
if|if
condition|(
name|group_sec
operator|&&
operator|!
name|group_sec
operator|->
name|gc_mark
condition|)
if|if
condition|(
operator|!
name|_bfd_elf_gc_mark
argument_list|(
name|info
argument_list|,
name|group_sec
argument_list|,
name|gc_mark_hook
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Look through the section relocs.  */
name|ret
operator|=
name|TRUE
expr_stmt|;
name|is_eh
operator|=
name|strcmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
literal|".eh_frame"
argument_list|)
operator|==
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|!=
literal|0
operator|&&
name|sec
operator|->
name|reloc_count
operator|>
literal|0
condition|)
block|{
name|Elf_Internal_Rela
modifier|*
name|relstart
decl_stmt|,
modifier|*
name|rel
decl_stmt|,
modifier|*
name|relend
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|size_t
name|nlocsyms
decl_stmt|;
name|size_t
name|extsymoff
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
init|=
name|sec
operator|->
name|owner
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|input_bfd
argument_list|)
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isym
init|=
name|NULL
decl_stmt|;
name|int
name|r_sym_shift
decl_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
comment|/* Read the local symbols.  */
if|if
condition|(
name|elf_bad_symtab
argument_list|(
name|input_bfd
argument_list|)
condition|)
block|{
name|nlocsyms
operator|=
name|symtab_hdr
operator|->
name|sh_size
operator|/
name|bed
operator|->
name|s
operator|->
name|sizeof_sym
expr_stmt|;
name|extsymoff
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|extsymoff
operator|=
name|nlocsyms
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|isym
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
if|if
condition|(
name|isym
operator|==
name|NULL
operator|&&
name|nlocsyms
operator|!=
literal|0
condition|)
block|{
name|isym
operator|=
name|bfd_elf_get_elf_syms
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
argument_list|,
name|nlocsyms
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|isym
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Read the relocations.  */
name|relstart
operator|=
name|_bfd_elf_link_read_relocs
argument_list|(
name|input_bfd
argument_list|,
name|sec
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|relstart
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|out1
goto|;
block|}
name|relend
operator|=
name|relstart
operator|+
name|sec
operator|->
name|reloc_count
operator|*
name|bed
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
expr_stmt|;
if|if
condition|(
name|bed
operator|->
name|s
operator|->
name|arch_size
operator|==
literal|32
condition|)
name|r_sym_shift
operator|=
literal|8
expr_stmt|;
else|else
name|r_sym_shift
operator|=
literal|32
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relstart
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|asection
modifier|*
name|rsec
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|r_symndx
operator|=
name|rel
operator|->
name|r_info
operator|>>
name|r_sym_shift
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|r_symndx
operator|>=
name|nlocsyms
operator|||
name|ELF_ST_BIND
argument_list|(
name|isym
index|[
name|r_symndx
index|]
operator|.
name|st_info
argument_list|)
operator|!=
name|STB_LOCAL
condition|)
block|{
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|extsymoff
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|rsec
operator|=
call|(
modifier|*
name|gc_mark_hook
call|)
argument_list|(
name|sec
argument_list|,
name|info
argument_list|,
name|rel
argument_list|,
name|h
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rsec
operator|=
call|(
modifier|*
name|gc_mark_hook
call|)
argument_list|(
name|sec
argument_list|,
name|info
argument_list|,
name|rel
argument_list|,
name|NULL
argument_list|,
operator|&
name|isym
index|[
name|r_symndx
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rsec
operator|&&
operator|!
name|rsec
operator|->
name|gc_mark
condition|)
block|{
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|rsec
operator|->
name|owner
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
name|rsec
operator|->
name|gc_mark
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|is_eh
condition|)
name|rsec
operator|->
name|gc_mark_from_eh
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|_bfd_elf_gc_mark
argument_list|(
name|info
argument_list|,
name|rsec
argument_list|,
name|gc_mark_hook
argument_list|)
condition|)
block|{
name|ret
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|out2
goto|;
block|}
block|}
block|}
name|out2
label|:
if|if
condition|(
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|!=
name|relstart
condition|)
name|free
argument_list|(
name|relstart
argument_list|)
expr_stmt|;
name|out1
label|:
if|if
condition|(
name|isym
operator|!=
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isym
condition|)
block|{
if|if
condition|(
operator|!
name|info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|isym
argument_list|)
expr_stmt|;
else|else
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isym
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Sweep symbols in swept sections.  Called via elf_link_hash_traverse.  */
end_comment

begin_struct
struct|struct
name|elf_gc_sweep_symbol_info
block|{
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|void
function_decl|(
modifier|*
name|hide_symbol
function_decl|)
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
parameter_list|,
name|bfd_boolean
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|bfd_boolean
name|elf_gc_sweep_symbol
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
operator|!
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|gc_mark
operator|&&
operator|!
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
condition|)
block|{
name|struct
name|elf_gc_sweep_symbol_info
modifier|*
name|inf
init|=
name|data
decl_stmt|;
call|(
modifier|*
name|inf
operator|->
name|hide_symbol
call|)
argument_list|(
name|inf
operator|->
name|info
argument_list|,
name|h
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* The sweep phase of garbage collection.  Remove all garbage sections.  */
end_comment

begin_typedef
typedef|typedef
name|bfd_boolean
function_decl|(
modifier|*
name|gc_sweep_hook_fn
function_decl|)
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_function
specifier|static
name|bfd_boolean
name|elf_gc_sweep
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|bfd
modifier|*
name|sub
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|gc_sweep_hook_fn
name|gc_sweep_hook
init|=
name|bed
operator|->
name|gc_sweep_hook
decl_stmt|;
name|unsigned
name|long
name|section_sym_count
decl_stmt|;
name|struct
name|elf_gc_sweep_symbol_info
name|sweep_info
decl_stmt|;
for|for
control|(
name|sub
operator|=
name|info
operator|->
name|input_bfds
init|;
name|sub
operator|!=
name|NULL
condition|;
name|sub
operator|=
name|sub
operator|->
name|link_next
control|)
block|{
name|asection
modifier|*
name|o
decl_stmt|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|sub
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
continue|continue;
for|for
control|(
name|o
operator|=
name|sub
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
comment|/* Keep debug and special sections.  */
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
operator|(
name|SEC_DEBUGGING
operator||
name|SEC_LINKER_CREATED
operator|)
operator|)
operator|!=
literal|0
operator|||
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_type
operator|==
name|SHT_NOTE
operator|||
operator|(
name|o
operator|->
name|flags
operator|&
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator|)
operator|)
operator|==
literal|0
condition|)
name|o
operator|->
name|gc_mark
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|gc_mark
condition|)
continue|continue;
comment|/* Skip sweeping sections already excluded.  */
if|if
condition|(
name|o
operator|->
name|flags
operator|&
name|SEC_EXCLUDE
condition|)
continue|continue;
comment|/* Since this is early in the link process, it is simple 	     to remove a section from the output.  */
name|o
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|print_gc_sections
operator|&&
name|o
operator|->
name|size
operator|!=
literal|0
condition|)
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"Removing unused section '%s' in file '%B'"
argument_list|)
argument_list|,
name|sub
argument_list|,
name|o
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* But we also have to update some of the relocation 	     info we collected before.  */
if|if
condition|(
name|gc_sweep_hook
operator|&&
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|!=
literal|0
operator|&&
name|o
operator|->
name|reloc_count
operator|>
literal|0
operator|&&
operator|!
name|bfd_is_abs_section
argument_list|(
name|o
operator|->
name|output_section
argument_list|)
condition|)
block|{
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|;
name|bfd_boolean
name|r
decl_stmt|;
name|internal_relocs
operator|=
name|_bfd_elf_link_read_relocs
argument_list|(
name|o
operator|->
name|owner
argument_list|,
name|o
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|r
operator|=
call|(
modifier|*
name|gc_sweep_hook
call|)
argument_list|(
name|o
operator|->
name|owner
argument_list|,
name|info
argument_list|,
name|o
argument_list|,
name|internal_relocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|relocs
operator|!=
name|internal_relocs
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
return|return
name|FALSE
return|;
block|}
block|}
block|}
comment|/* Remove the symbols that were in the swept sections from the dynamic      symbol table.  GCFIXME: Anyone know how to get them out of the      static symbol table as well?  */
name|sweep_info
operator|.
name|info
operator|=
name|info
expr_stmt|;
name|sweep_info
operator|.
name|hide_symbol
operator|=
name|bed
operator|->
name|elf_backend_hide_symbol
expr_stmt|;
name|elf_link_hash_traverse
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|elf_gc_sweep_symbol
argument_list|,
operator|&
name|sweep_info
argument_list|)
expr_stmt|;
name|_bfd_elf_link_renumber_dynsyms
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
operator|&
name|section_sym_count
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Propagate collected vtable information.  This is called through    elf_link_hash_traverse.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_gc_propagate_vtable_entries_used
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|void
modifier|*
name|okp
parameter_list|)
block|{
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
comment|/* Those that are not vtables.  */
if|if
condition|(
name|h
operator|->
name|vtable
operator|==
name|NULL
operator|||
name|h
operator|->
name|vtable
operator|->
name|parent
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
comment|/* Those vtables that do not have parents, we cannot merge.  */
if|if
condition|(
name|h
operator|->
name|vtable
operator|->
name|parent
operator|==
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
operator|-
literal|1
condition|)
return|return
name|TRUE
return|;
comment|/* If we've already been done, exit.  */
if|if
condition|(
name|h
operator|->
name|vtable
operator|->
name|used
operator|&&
name|h
operator|->
name|vtable
operator|->
name|used
index|[
operator|-
literal|1
index|]
condition|)
return|return
name|TRUE
return|;
comment|/* Make sure the parent's table is up to date.  */
name|elf_gc_propagate_vtable_entries_used
argument_list|(
name|h
operator|->
name|vtable
operator|->
name|parent
argument_list|,
name|okp
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|vtable
operator|->
name|used
operator|==
name|NULL
condition|)
block|{
comment|/* None of this table's entries were referenced.  Re-use the 	 parent's table.  */
name|h
operator|->
name|vtable
operator|->
name|used
operator|=
name|h
operator|->
name|vtable
operator|->
name|parent
operator|->
name|vtable
operator|->
name|used
expr_stmt|;
name|h
operator|->
name|vtable
operator|->
name|size
operator|=
name|h
operator|->
name|vtable
operator|->
name|parent
operator|->
name|vtable
operator|->
name|size
expr_stmt|;
block|}
else|else
block|{
name|size_t
name|n
decl_stmt|;
name|bfd_boolean
modifier|*
name|cu
decl_stmt|,
modifier|*
name|pu
decl_stmt|;
comment|/* Or the parent's entries into ours.  */
name|cu
operator|=
name|h
operator|->
name|vtable
operator|->
name|used
expr_stmt|;
name|cu
index|[
operator|-
literal|1
index|]
operator|=
name|TRUE
expr_stmt|;
name|pu
operator|=
name|h
operator|->
name|vtable
operator|->
name|parent
operator|->
name|vtable
operator|->
name|used
expr_stmt|;
if|if
condition|(
name|pu
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
name|unsigned
name|int
name|log_file_align
decl_stmt|;
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
argument_list|)
expr_stmt|;
name|log_file_align
operator|=
name|bed
operator|->
name|s
operator|->
name|log_file_align
expr_stmt|;
name|n
operator|=
name|h
operator|->
name|vtable
operator|->
name|parent
operator|->
name|vtable
operator|->
name|size
operator|>>
name|log_file_align
expr_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
block|{
if|if
condition|(
operator|*
name|pu
condition|)
operator|*
name|cu
operator|=
name|TRUE
expr_stmt|;
name|pu
operator|++
expr_stmt|;
name|cu
operator|++
expr_stmt|;
block|}
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elf_gc_smash_unused_vtentry_relocs
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|void
modifier|*
name|okp
parameter_list|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_vma
name|hstart
decl_stmt|,
name|hend
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relstart
decl_stmt|,
modifier|*
name|relend
decl_stmt|,
modifier|*
name|rel
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
name|unsigned
name|int
name|log_file_align
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
comment|/* Take care of both those symbols that do not describe vtables as      well as those that are not loaded.  */
if|if
condition|(
name|h
operator|->
name|vtable
operator|==
name|NULL
operator|||
name|h
operator|->
name|vtable
operator|->
name|parent
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
argument_list|)
expr_stmt|;
name|sec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|hstart
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
name|hend
operator|=
name|hstart
operator|+
name|h
operator|->
name|size
expr_stmt|;
name|relstart
operator|=
name|_bfd_elf_link_read_relocs
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|sec
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|relstart
condition|)
return|return
operator|*
operator|(
name|bfd_boolean
operator|*
operator|)
name|okp
operator|=
name|FALSE
return|;
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|sec
operator|->
name|owner
argument_list|)
expr_stmt|;
name|log_file_align
operator|=
name|bed
operator|->
name|s
operator|->
name|log_file_align
expr_stmt|;
name|relend
operator|=
name|relstart
operator|+
name|sec
operator|->
name|reloc_count
operator|*
name|bed
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relstart
init|;
name|rel
operator|<
name|relend
condition|;
operator|++
name|rel
control|)
if|if
condition|(
name|rel
operator|->
name|r_offset
operator|>=
name|hstart
operator|&&
name|rel
operator|->
name|r_offset
operator|<
name|hend
condition|)
block|{
comment|/* If the entry is in use, do nothing.  */
if|if
condition|(
name|h
operator|->
name|vtable
operator|->
name|used
operator|&&
operator|(
name|rel
operator|->
name|r_offset
operator|-
name|hstart
operator|)
operator|<
name|h
operator|->
name|vtable
operator|->
name|size
condition|)
block|{
name|bfd_vma
name|entry
init|=
operator|(
name|rel
operator|->
name|r_offset
operator|-
name|hstart
operator|)
operator|>>
name|log_file_align
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|vtable
operator|->
name|used
index|[
name|entry
index|]
condition|)
continue|continue;
block|}
comment|/* Otherwise, kill it.  */
name|rel
operator|->
name|r_offset
operator|=
name|rel
operator|->
name|r_info
operator|=
name|rel
operator|->
name|r_addend
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Mark sections containing dynamically referenced symbols.  When    building shared libraries, we must assume that any visible symbol is    referenced.  */
end_comment

begin_function
name|bfd_boolean
name|bfd_elf_gc_mark_dynamic_ref_symbol
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|void
modifier|*
name|inf
parameter_list|)
block|{
name|struct
name|bfd_link_info
modifier|*
name|info
init|=
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|)
name|inf
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
operator|(
name|h
operator|->
name|ref_dynamic
operator|||
operator|(
operator|!
name|info
operator|->
name|executable
operator|&&
name|h
operator|->
name|def_regular
operator|&&
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|!=
name|STV_INTERNAL
operator|&&
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|!=
name|STV_HIDDEN
operator|)
operator|)
condition|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|flags
operator||=
name|SEC_KEEP
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Do mark and sweep of unused sections.  */
end_comment

begin_function
name|bfd_boolean
name|bfd_elf_gc_sections
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|bfd_boolean
name|ok
init|=
name|TRUE
decl_stmt|;
name|bfd
modifier|*
name|sub
decl_stmt|;
name|elf_gc_mark_hook_fn
name|gc_mark_hook
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|bed
operator|->
name|can_gc_sections
operator|||
name|info
operator|->
name|relocatable
operator|||
name|info
operator|->
name|emitrelocations
operator|||
operator|!
name|is_elf_hash_table
argument_list|(
name|info
operator|->
name|hash
argument_list|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Warning: gc-sections option ignored"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* Apply transitive closure to the vtable entry usage info.  */
name|elf_link_hash_traverse
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|elf_gc_propagate_vtable_entries_used
argument_list|,
operator|&
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|FALSE
return|;
comment|/* Kill the vtable relocations that were not used.  */
name|elf_link_hash_traverse
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|elf_gc_smash_unused_vtentry_relocs
argument_list|,
operator|&
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|FALSE
return|;
comment|/* Mark dynamically referenced symbols.  */
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
name|elf_link_hash_traverse
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|bed
operator|->
name|gc_mark_dynamic_ref
argument_list|,
name|info
argument_list|)
expr_stmt|;
comment|/* Grovel through relocs to find out who stays ...  */
name|gc_mark_hook
operator|=
name|bed
operator|->
name|gc_mark_hook
expr_stmt|;
for|for
control|(
name|sub
operator|=
name|info
operator|->
name|input_bfds
init|;
name|sub
operator|!=
name|NULL
condition|;
name|sub
operator|=
name|sub
operator|->
name|link_next
control|)
block|{
name|asection
modifier|*
name|o
decl_stmt|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|sub
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
continue|continue;
for|for
control|(
name|o
operator|=
name|sub
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
operator|(
name|SEC_EXCLUDE
operator||
name|SEC_KEEP
operator|)
operator|)
operator|==
name|SEC_KEEP
operator|&&
operator|!
name|o
operator|->
name|gc_mark
condition|)
if|if
condition|(
operator|!
name|_bfd_elf_gc_mark
argument_list|(
name|info
argument_list|,
name|o
argument_list|,
name|gc_mark_hook
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Allow the backend to mark additional target specific sections.  */
if|if
condition|(
name|bed
operator|->
name|gc_mark_extra_sections
condition|)
name|bed
operator|->
name|gc_mark_extra_sections
argument_list|(
name|info
argument_list|,
name|gc_mark_hook
argument_list|)
expr_stmt|;
comment|/* ... again for sections marked from eh_frame.  */
for|for
control|(
name|sub
operator|=
name|info
operator|->
name|input_bfds
init|;
name|sub
operator|!=
name|NULL
condition|;
name|sub
operator|=
name|sub
operator|->
name|link_next
control|)
block|{
name|asection
modifier|*
name|o
decl_stmt|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|sub
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
continue|continue;
comment|/* Keep .gcc_except_table.* if the associated .text.* (or the 	 associated .gnu.linkonce.t.* if .text.* doesn't exist) is 	 marked.  This isn't very nice, but the proper solution, 	 splitting .eh_frame up and using comdat doesn't pan out 	 easily due to needing special relocs to handle the 	 difference of two symbols in separate sections. 	 Don't keep code sections referenced by .eh_frame.  */
define|#
directive|define
name|TEXT_PREFIX
value|".text."
define|#
directive|define
name|TEXT_PREFIX2
value|".gnu.linkonce.t."
define|#
directive|define
name|GCC_EXCEPT_TABLE_PREFIX
value|".gcc_except_table."
for|for
control|(
name|o
operator|=
name|sub
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|o
operator|->
name|gc_mark
operator|&&
name|o
operator|->
name|gc_mark_from_eh
operator|&&
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_CODE
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|CONST_STRNEQ
argument_list|(
name|o
operator|->
name|name
argument_list|,
name|GCC_EXCEPT_TABLE_PREFIX
argument_list|)
condition|)
block|{
name|char
modifier|*
name|fn_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|sec_name
decl_stmt|;
name|asection
modifier|*
name|fn_text
decl_stmt|;
name|unsigned
name|o_name_prefix_len
decl_stmt|,
name|fn_name_prefix_len
decl_stmt|,
name|tmp
decl_stmt|;
name|o_name_prefix_len
operator|=
name|strlen
argument_list|(
name|GCC_EXCEPT_TABLE_PREFIX
argument_list|)
expr_stmt|;
name|sec_name
operator|=
name|o
operator|->
name|name
operator|+
name|o_name_prefix_len
expr_stmt|;
name|fn_name_prefix_len
operator|=
name|strlen
argument_list|(
name|TEXT_PREFIX
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|strlen
argument_list|(
name|TEXT_PREFIX2
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|>
name|fn_name_prefix_len
condition|)
name|fn_name_prefix_len
operator|=
name|tmp
expr_stmt|;
name|fn_name
operator|=
name|bfd_malloc
argument_list|(
name|fn_name_prefix_len
operator|+
name|strlen
argument_list|(
name|sec_name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn_name
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* Try the first prefix.  */
name|sprintf
argument_list|(
name|fn_name
argument_list|,
literal|"%s%s"
argument_list|,
name|TEXT_PREFIX
argument_list|,
name|sec_name
argument_list|)
expr_stmt|;
name|fn_text
operator|=
name|bfd_get_section_by_name
argument_list|(
name|sub
argument_list|,
name|fn_name
argument_list|)
expr_stmt|;
comment|/* Try the second prefix.  */
if|if
condition|(
name|fn_text
operator|==
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|fn_name
argument_list|,
literal|"%s%s"
argument_list|,
name|TEXT_PREFIX2
argument_list|,
name|sec_name
argument_list|)
expr_stmt|;
name|fn_text
operator|=
name|bfd_get_section_by_name
argument_list|(
name|sub
argument_list|,
name|fn_name
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|fn_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn_text
operator|==
name|NULL
operator|||
operator|!
name|fn_text
operator|->
name|gc_mark
condition|)
continue|continue;
block|}
comment|/* If not using specially named exception table section, 	       then keep whatever we are using.  */
if|if
condition|(
operator|!
name|_bfd_elf_gc_mark
argument_list|(
name|info
argument_list|,
name|o
argument_list|,
name|gc_mark_hook
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
comment|/* ... and mark SEC_EXCLUDE for those that go.  */
return|return
name|elf_gc_sweep
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Called from check_relocs to record the existence of a VTINHERIT reloc.  */
end_comment

begin_function
name|bfd_boolean
name|bfd_elf_gc_record_vtinherit
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|bfd_vma
name|offset
parameter_list|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|,
modifier|*
modifier|*
name|sym_hashes_end
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|search
decl_stmt|,
modifier|*
name|child
decl_stmt|;
name|bfd_size_type
name|extsymcount
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
comment|/* The sh_info field of the symtab header tells us where the      external symbols start.  We don't care about the local symbols at      this point.  */
name|extsymcount
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
operator|.
name|sh_size
operator|/
name|bed
operator|->
name|s
operator|->
name|sizeof_sym
expr_stmt|;
if|if
condition|(
operator|!
name|elf_bad_symtab
argument_list|(
name|abfd
argument_list|)
condition|)
name|extsymcount
operator|-=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
operator|.
name|sh_info
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|sym_hashes_end
operator|=
name|sym_hashes
operator|+
name|extsymcount
expr_stmt|;
comment|/* Hunt down the child symbol, which is in this section at the same      offset as the relocation.  */
for|for
control|(
name|search
operator|=
name|sym_hashes
init|;
name|search
operator|!=
name|sym_hashes_end
condition|;
operator|++
name|search
control|)
block|{
if|if
condition|(
operator|(
name|child
operator|=
operator|*
name|search
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|child
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|child
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
name|child
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|==
name|sec
operator|&&
name|child
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|==
name|offset
condition|)
goto|goto
name|win
goto|;
block|}
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"%B: %A+%lu: No symbol found for INHERIT"
argument_list|,
name|abfd
argument_list|,
name|sec
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|offset
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
name|win
label|:
if|if
condition|(
operator|!
name|child
operator|->
name|vtable
condition|)
block|{
name|child
operator|->
name|vtable
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|child
operator|->
name|vtable
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|child
operator|->
name|vtable
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|h
condition|)
block|{
comment|/* This *should* only be the absolute section.  It could potentially 	 be that someone has defined a non-global vtable though, which 	 would be bad.  It isn't worth paging in the local symbols to be 	 sure though; that case should simply be handled by the assembler.  */
name|child
operator|->
name|vtable
operator|->
name|parent
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|child
operator|->
name|vtable
operator|->
name|parent
operator|=
name|h
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Called from check_relocs to record the existence of a VTENTRY reloc.  */
end_comment

begin_function
name|bfd_boolean
name|bfd_elf_gc_record_vtentry
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|sec
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|bfd_vma
name|addend
parameter_list|)
block|{
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|log_file_align
init|=
name|bed
operator|->
name|s
operator|->
name|log_file_align
decl_stmt|;
if|if
condition|(
operator|!
name|h
operator|->
name|vtable
condition|)
block|{
name|h
operator|->
name|vtable
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|h
operator|->
name|vtable
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|h
operator|->
name|vtable
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|addend
operator|>=
name|h
operator|->
name|vtable
operator|->
name|size
condition|)
block|{
name|size_t
name|size
decl_stmt|,
name|bytes
decl_stmt|,
name|file_align
decl_stmt|;
name|bfd_boolean
modifier|*
name|ptr
init|=
name|h
operator|->
name|vtable
operator|->
name|used
decl_stmt|;
comment|/* While the symbol is undefined, we have to be prepared to handle 	 a zero size.  */
name|file_align
operator|=
literal|1
operator|<<
name|log_file_align
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
condition|)
name|size
operator|=
name|addend
operator|+
name|file_align
expr_stmt|;
else|else
block|{
name|size
operator|=
name|h
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|addend
operator|>=
name|size
condition|)
block|{
comment|/* Oops!  We've got a reference past the defined end of 		 the table.  This is probably a bug -- shall we warn?  */
name|size
operator|=
name|addend
operator|+
name|file_align
expr_stmt|;
block|}
block|}
name|size
operator|=
operator|(
name|size
operator|+
name|file_align
operator|-
literal|1
operator|)
operator|&
operator|-
name|file_align
expr_stmt|;
comment|/* Allocate one extra entry for use as a "done" flag for the 	 consolidation pass.  */
name|bytes
operator|=
operator|(
operator|(
name|size
operator|>>
name|log_file_align
operator|)
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|bfd_boolean
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
condition|)
block|{
name|ptr
operator|=
name|bfd_realloc
argument_list|(
name|ptr
operator|-
literal|1
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
block|{
name|size_t
name|oldbytes
decl_stmt|;
name|oldbytes
operator|=
operator|(
operator|(
operator|(
name|h
operator|->
name|vtable
operator|->
name|size
operator|>>
name|log_file_align
operator|)
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|bfd_boolean
argument_list|)
operator|)
expr_stmt|;
name|memset
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
name|ptr
operator|)
operator|+
name|oldbytes
argument_list|,
literal|0
argument_list|,
name|bytes
operator|-
name|oldbytes
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|ptr
operator|=
name|bfd_zmalloc
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* And arrange for that done flag to be at index -1.  */
name|h
operator|->
name|vtable
operator|->
name|used
operator|=
name|ptr
operator|+
literal|1
expr_stmt|;
name|h
operator|->
name|vtable
operator|->
name|size
operator|=
name|size
expr_stmt|;
block|}
name|h
operator|->
name|vtable
operator|->
name|used
index|[
name|addend
operator|>>
name|log_file_align
index|]
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_struct
struct|struct
name|alloc_got_off_arg
block|{
name|bfd_vma
name|gotoff
decl_stmt|;
name|unsigned
name|int
name|got_elt_size
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* We need a special top-level link routine to convert got reference counts    to real got offsets.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_gc_allocate_got_offsets
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|alloc_got_off_arg
modifier|*
name|gofarg
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|refcount
operator|>
literal|0
condition|)
block|{
name|h
operator|->
name|got
operator|.
name|offset
operator|=
name|gofarg
operator|->
name|gotoff
expr_stmt|;
name|gofarg
operator|->
name|gotoff
operator|+=
name|gofarg
operator|->
name|got_elt_size
expr_stmt|;
block|}
else|else
name|h
operator|->
name|got
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* And an accompanying bit to work out final got entry offsets once    we're done.  Should be called from final_link.  */
end_comment

begin_function
name|bfd_boolean
name|bfd_elf_gc_common_finalize_got_offsets
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|bfd
modifier|*
name|i
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|bfd_vma
name|gotoff
decl_stmt|;
name|unsigned
name|int
name|got_elt_size
init|=
name|bed
operator|->
name|s
operator|->
name|arch_size
operator|/
literal|8
decl_stmt|;
name|struct
name|alloc_got_off_arg
name|gofarg
decl_stmt|;
if|if
condition|(
operator|!
name|is_elf_hash_table
argument_list|(
name|info
operator|->
name|hash
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* The GOT offset is relative to the .got section, but the GOT header is      put into the .got.plt section, if the backend uses it.  */
if|if
condition|(
name|bed
operator|->
name|want_got_plt
condition|)
name|gotoff
operator|=
literal|0
expr_stmt|;
else|else
name|gotoff
operator|=
name|bed
operator|->
name|got_header_size
expr_stmt|;
comment|/* Do the local .got entries first.  */
for|for
control|(
name|i
operator|=
name|info
operator|->
name|input_bfds
init|;
name|i
condition|;
name|i
operator|=
name|i
operator|->
name|link_next
control|)
block|{
name|bfd_signed_vma
modifier|*
name|local_got
decl_stmt|;
name|bfd_size_type
name|j
decl_stmt|,
name|locsymcount
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|i
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
continue|continue;
name|local_got
operator|=
name|elf_local_got_refcounts
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|local_got
condition|)
continue|continue;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|i
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
if|if
condition|(
name|elf_bad_symtab
argument_list|(
name|i
argument_list|)
condition|)
name|locsymcount
operator|=
name|symtab_hdr
operator|->
name|sh_size
operator|/
name|bed
operator|->
name|s
operator|->
name|sizeof_sym
expr_stmt|;
else|else
name|locsymcount
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|locsymcount
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|local_got
index|[
name|j
index|]
operator|>
literal|0
condition|)
block|{
name|local_got
index|[
name|j
index|]
operator|=
name|gotoff
expr_stmt|;
name|gotoff
operator|+=
name|got_elt_size
expr_stmt|;
block|}
else|else
name|local_got
index|[
name|j
index|]
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
block|}
block|}
comment|/* Then the global .got entries.  .plt refcounts are handled by      adjust_dynamic_symbol  */
name|gofarg
operator|.
name|gotoff
operator|=
name|gotoff
expr_stmt|;
name|gofarg
operator|.
name|got_elt_size
operator|=
name|got_elt_size
expr_stmt|;
name|elf_link_hash_traverse
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|elf_gc_allocate_got_offsets
argument_list|,
operator|&
name|gofarg
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Many folk need no more in the way of final link than this, once    got entry reference counting is enabled.  */
end_comment

begin_function
name|bfd_boolean
name|bfd_elf_gc_common_final_link
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
if|if
condition|(
operator|!
name|bfd_elf_gc_common_finalize_got_offsets
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Invoke the regular ELF backend linker to do all the work.  */
return|return
name|bfd_elf_final_link
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|bfd_elf_reloc_symbol_deleted_p
parameter_list|(
name|bfd_vma
name|offset
parameter_list|,
name|void
modifier|*
name|cookie
parameter_list|)
block|{
name|struct
name|elf_reloc_cookie
modifier|*
name|rcookie
init|=
name|cookie
decl_stmt|;
if|if
condition|(
name|rcookie
operator|->
name|bad_symtab
condition|)
name|rcookie
operator|->
name|rel
operator|=
name|rcookie
operator|->
name|rels
expr_stmt|;
for|for
control|(
init|;
name|rcookie
operator|->
name|rel
operator|<
name|rcookie
operator|->
name|relend
condition|;
name|rcookie
operator|->
name|rel
operator|++
control|)
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
if|if
condition|(
operator|!
name|rcookie
operator|->
name|bad_symtab
condition|)
if|if
condition|(
name|rcookie
operator|->
name|rel
operator|->
name|r_offset
operator|>
name|offset
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|rcookie
operator|->
name|rel
operator|->
name|r_offset
operator|!=
name|offset
condition|)
continue|continue;
name|r_symndx
operator|=
name|rcookie
operator|->
name|rel
operator|->
name|r_info
operator|>>
name|rcookie
operator|->
name|r_sym_shift
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|==
name|SHN_UNDEF
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|r_symndx
operator|>=
name|rcookie
operator|->
name|locsymcount
operator|||
name|ELF_ST_BIND
argument_list|(
name|rcookie
operator|->
name|locsyms
index|[
name|r_symndx
index|]
operator|.
name|st_info
argument_list|)
operator|!=
name|STB_LOCAL
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
name|rcookie
operator|->
name|sym_hashes
index|[
name|r_symndx
operator|-
name|rcookie
operator|->
name|extsymoff
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
name|elf_discarded_section
argument_list|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
argument_list|)
condition|)
return|return
name|TRUE
return|;
else|else
return|return
name|FALSE
return|;
block|}
else|else
block|{
comment|/* It's not a relocation against a global symbol, 	     but it could be a relocation against a local 	     symbol for a discarded section.  */
name|asection
modifier|*
name|isec
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isym
decl_stmt|;
comment|/* Need to: get the symbol; get the section.  */
name|isym
operator|=
operator|&
name|rcookie
operator|->
name|locsyms
index|[
name|r_symndx
index|]
expr_stmt|;
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|<
name|SHN_LORESERVE
operator|||
name|isym
operator|->
name|st_shndx
operator|>
name|SHN_HIRESERVE
condition|)
block|{
name|isec
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|rcookie
operator|->
name|abfd
argument_list|,
name|isym
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|isec
operator|!=
name|NULL
operator|&&
name|elf_discarded_section
argument_list|(
name|isec
argument_list|)
condition|)
return|return
name|TRUE
return|;
block|}
block|}
return|return
name|FALSE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Discard unneeded references to discarded sections.    Returns TRUE if any section's size was changed.  */
end_comment

begin_comment
comment|/* This function assumes that the relocations are in sorted order,    which is true for all known assemblers.  */
end_comment

begin_function
name|bfd_boolean
name|bfd_elf_discard_info
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|elf_reloc_cookie
name|cookie
decl_stmt|;
name|asection
modifier|*
name|stab
decl_stmt|,
modifier|*
name|eh
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
name|bfd_boolean
name|ret
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|traditional_format
operator|||
operator|!
name|is_elf_hash_table
argument_list|(
name|info
operator|->
name|hash
argument_list|)
condition|)
return|return
name|FALSE
return|;
for|for
control|(
name|abfd
operator|=
name|info
operator|->
name|input_bfds
init|;
name|abfd
operator|!=
name|NULL
condition|;
name|abfd
operator|=
name|abfd
operator|->
name|link_next
control|)
block|{
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|abfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
continue|continue;
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
condition|)
continue|continue;
name|eh
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|relocatable
condition|)
block|{
name|eh
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".eh_frame"
argument_list|)
expr_stmt|;
if|if
condition|(
name|eh
operator|!=
name|NULL
operator|&&
operator|(
name|eh
operator|->
name|size
operator|==
literal|0
operator|||
name|bfd_is_abs_section
argument_list|(
name|eh
operator|->
name|output_section
argument_list|)
operator|)
condition|)
name|eh
operator|=
name|NULL
expr_stmt|;
block|}
name|stab
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".stab"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stab
operator|!=
name|NULL
operator|&&
operator|(
name|stab
operator|->
name|size
operator|==
literal|0
operator|||
name|bfd_is_abs_section
argument_list|(
name|stab
operator|->
name|output_section
argument_list|)
operator|||
name|stab
operator|->
name|sec_info_type
operator|!=
name|ELF_INFO_TYPE_STABS
operator|)
condition|)
name|stab
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|stab
operator|==
name|NULL
operator|&&
name|eh
operator|==
name|NULL
operator|&&
name|bed
operator|->
name|elf_backend_discard_info
operator|==
name|NULL
condition|)
continue|continue;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|cookie
operator|.
name|abfd
operator|=
name|abfd
expr_stmt|;
name|cookie
operator|.
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|cookie
operator|.
name|bad_symtab
operator|=
name|elf_bad_symtab
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|cookie
operator|.
name|bad_symtab
condition|)
block|{
name|cookie
operator|.
name|locsymcount
operator|=
name|symtab_hdr
operator|->
name|sh_size
operator|/
name|bed
operator|->
name|s
operator|->
name|sizeof_sym
expr_stmt|;
name|cookie
operator|.
name|extsymoff
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|cookie
operator|.
name|locsymcount
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|cookie
operator|.
name|extsymoff
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
block|}
if|if
condition|(
name|bed
operator|->
name|s
operator|->
name|arch_size
operator|==
literal|32
condition|)
name|cookie
operator|.
name|r_sym_shift
operator|=
literal|8
expr_stmt|;
else|else
name|cookie
operator|.
name|r_sym_shift
operator|=
literal|32
expr_stmt|;
name|cookie
operator|.
name|locsyms
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
if|if
condition|(
name|cookie
operator|.
name|locsyms
operator|==
name|NULL
operator|&&
name|cookie
operator|.
name|locsymcount
operator|!=
literal|0
condition|)
block|{
name|cookie
operator|.
name|locsyms
operator|=
name|bfd_elf_get_elf_syms
argument_list|(
name|abfd
argument_list|,
name|symtab_hdr
argument_list|,
name|cookie
operator|.
name|locsymcount
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|cookie
operator|.
name|locsyms
operator|==
name|NULL
condition|)
block|{
name|info
operator|->
name|callbacks
operator|->
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%X: can not read symbols: %E\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
if|if
condition|(
name|stab
operator|!=
name|NULL
condition|)
block|{
name|cookie
operator|.
name|rels
operator|=
name|NULL
expr_stmt|;
name|count
operator|=
name|stab
operator|->
name|reloc_count
expr_stmt|;
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
name|cookie
operator|.
name|rels
operator|=
name|_bfd_elf_link_read_relocs
argument_list|(
name|abfd
argument_list|,
name|stab
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|cookie
operator|.
name|rels
operator|!=
name|NULL
condition|)
block|{
name|cookie
operator|.
name|rel
operator|=
name|cookie
operator|.
name|rels
expr_stmt|;
name|cookie
operator|.
name|relend
operator|=
name|cookie
operator|.
name|rels
expr_stmt|;
name|cookie
operator|.
name|relend
operator|+=
name|count
operator|*
name|bed
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
expr_stmt|;
if|if
condition|(
name|_bfd_discard_section_stabs
argument_list|(
name|abfd
argument_list|,
name|stab
argument_list|,
name|elf_section_data
argument_list|(
name|stab
argument_list|)
operator|->
name|sec_info
argument_list|,
name|bfd_elf_reloc_symbol_deleted_p
argument_list|,
operator|&
name|cookie
argument_list|)
condition|)
name|ret
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|elf_section_data
argument_list|(
name|stab
argument_list|)
operator|->
name|relocs
operator|!=
name|cookie
operator|.
name|rels
condition|)
name|free
argument_list|(
name|cookie
operator|.
name|rels
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|eh
operator|!=
name|NULL
condition|)
block|{
name|cookie
operator|.
name|rels
operator|=
name|NULL
expr_stmt|;
name|count
operator|=
name|eh
operator|->
name|reloc_count
expr_stmt|;
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
name|cookie
operator|.
name|rels
operator|=
name|_bfd_elf_link_read_relocs
argument_list|(
name|abfd
argument_list|,
name|eh
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
name|cookie
operator|.
name|rel
operator|=
name|cookie
operator|.
name|rels
expr_stmt|;
name|cookie
operator|.
name|relend
operator|=
name|cookie
operator|.
name|rels
expr_stmt|;
if|if
condition|(
name|cookie
operator|.
name|rels
operator|!=
name|NULL
condition|)
name|cookie
operator|.
name|relend
operator|+=
name|count
operator|*
name|bed
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
expr_stmt|;
if|if
condition|(
name|_bfd_elf_discard_section_eh_frame
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|eh
argument_list|,
name|bfd_elf_reloc_symbol_deleted_p
argument_list|,
operator|&
name|cookie
argument_list|)
condition|)
name|ret
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|cookie
operator|.
name|rels
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|eh
argument_list|)
operator|->
name|relocs
operator|!=
name|cookie
operator|.
name|rels
condition|)
name|free
argument_list|(
name|cookie
operator|.
name|rels
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bed
operator|->
name|elf_backend_discard_info
operator|!=
name|NULL
operator|&&
call|(
modifier|*
name|bed
operator|->
name|elf_backend_discard_info
call|)
argument_list|(
name|abfd
argument_list|,
operator|&
name|cookie
argument_list|,
name|info
argument_list|)
condition|)
name|ret
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|cookie
operator|.
name|locsyms
operator|!=
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|cookie
operator|.
name|locsyms
condition|)
block|{
if|if
condition|(
operator|!
name|info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|cookie
operator|.
name|locsyms
argument_list|)
expr_stmt|;
else|else
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|cookie
operator|.
name|locsyms
expr_stmt|;
block|}
block|}
if|if
condition|(
name|info
operator|->
name|eh_frame_hdr
operator|&&
operator|!
name|info
operator|->
name|relocatable
operator|&&
name|_bfd_elf_discard_section_eh_frame_hdr
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|)
condition|)
name|ret
operator|=
name|TRUE
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
name|_bfd_elf_section_already_linked
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_section
modifier|*
name|sec
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|flagword
name|flags
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|struct
name|bfd_section_already_linked
modifier|*
name|l
decl_stmt|;
name|struct
name|bfd_section_already_linked_hash_entry
modifier|*
name|already_linked_list
decl_stmt|;
if|if
condition|(
name|sec
operator|->
name|output_section
operator|==
name|bfd_abs_section_ptr
condition|)
return|return;
name|flags
operator|=
name|sec
operator|->
name|flags
expr_stmt|;
comment|/* Return if it isn't a linkonce section.  A comdat group section      also has SEC_LINK_ONCE set.  */
if|if
condition|(
operator|(
name|flags
operator|&
name|SEC_LINK_ONCE
operator|)
operator|==
literal|0
condition|)
return|return;
comment|/* Don't put group member sections on our list of already linked      sections.  They are handled as a group via their group section.  */
if|if
condition|(
name|elf_sec_group
argument_list|(
name|sec
argument_list|)
operator|!=
name|NULL
condition|)
return|return;
comment|/* FIXME: When doing a relocatable link, we may have trouble      copying relocations in other sections that refer to local symbols      in the section being discarded.  Those relocations will have to      be converted somehow; as of this writing I'm not sure that any of      the backends handle that correctly.       It is tempting to instead not discard link once sections when      doing a relocatable link (technically, they should be discarded      whenever we are building constructors).  However, that fails,      because the linker winds up combining all the link once sections      into a single large link once section, which defeats the purpose      of having link once sections in the first place.       Also, not merging link once sections in a relocatable link      causes trouble for MIPS ELF, which relies on link once semantics      to handle the .reginfo section correctly.  */
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONST_STRNEQ
argument_list|(
name|name
argument_list|,
literal|".gnu.linkonce."
argument_list|)
operator|&&
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|name
operator|+
sizeof|sizeof
argument_list|(
literal|".gnu.linkonce."
argument_list|)
operator|-
literal|1
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|p
operator|++
expr_stmt|;
else|else
name|p
operator|=
name|name
expr_stmt|;
name|already_linked_list
operator|=
name|bfd_section_already_linked_table_lookup
argument_list|(
name|p
argument_list|)
expr_stmt|;
for|for
control|(
name|l
operator|=
name|already_linked_list
operator|->
name|entry
init|;
name|l
operator|!=
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
comment|/* We may have 2 different types of sections on the list: group 	 sections and linkonce sections.  Match like sections.  */
if|if
condition|(
operator|(
name|flags
operator|&
name|SEC_GROUP
operator|)
operator|==
operator|(
name|l
operator|->
name|sec
operator|->
name|flags
operator|&
name|SEC_GROUP
operator|)
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|l
operator|->
name|sec
operator|->
name|name
argument_list|)
operator|==
literal|0
operator|&&
name|bfd_coff_get_comdat_section
argument_list|(
name|l
operator|->
name|sec
operator|->
name|owner
argument_list|,
name|l
operator|->
name|sec
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* The section has already been linked.  See if we should 	     issue a warning.  */
switch|switch
condition|(
name|flags
operator|&
name|SEC_LINK_DUPLICATES
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|SEC_LINK_DUPLICATES_DISCARD
case|:
break|break;
case|case
name|SEC_LINK_DUPLICATES_ONE_ONLY
case|:
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: ignoring duplicate section `%A'"
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEC_LINK_DUPLICATES_SAME_SIZE
case|:
if|if
condition|(
name|sec
operator|->
name|size
operator|!=
name|l
operator|->
name|sec
operator|->
name|size
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: duplicate section `%A' has different size"
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEC_LINK_DUPLICATES_SAME_CONTENTS
case|:
if|if
condition|(
name|sec
operator|->
name|size
operator|!=
name|l
operator|->
name|sec
operator|->
name|size
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: duplicate section `%A' has different size"
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sec
operator|->
name|size
operator|!=
literal|0
condition|)
block|{
name|bfd_byte
modifier|*
name|sec_contents
decl_stmt|,
modifier|*
name|l_sec_contents
decl_stmt|;
if|if
condition|(
operator|!
name|bfd_malloc_and_get_section
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
operator|&
name|sec_contents
argument_list|)
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: warning: could not read contents of section `%A'"
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|bfd_malloc_and_get_section
argument_list|(
name|l
operator|->
name|sec
operator|->
name|owner
argument_list|,
name|l
operator|->
name|sec
argument_list|,
operator|&
name|l_sec_contents
argument_list|)
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: warning: could not read contents of section `%A'"
argument_list|)
argument_list|,
name|l
operator|->
name|sec
operator|->
name|owner
argument_list|,
name|l
operator|->
name|sec
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|memcmp
argument_list|(
name|sec_contents
argument_list|,
name|l_sec_contents
argument_list|,
name|sec
operator|->
name|size
argument_list|)
operator|!=
literal|0
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: warning: duplicate section `%A' has different contents"
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec_contents
condition|)
name|free
argument_list|(
name|sec_contents
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_sec_contents
condition|)
name|free
argument_list|(
name|l_sec_contents
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|/* Set the output_section field so that lang_add_section 	     does not create a lang_input_section structure for this 	     section.  Since there might be a symbol in the section 	     being discarded, we must retain a pointer to the section 	     which we are really going to use.  */
name|sec
operator|->
name|output_section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
name|sec
operator|->
name|kept_section
operator|=
name|l
operator|->
name|sec
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SEC_GROUP
condition|)
block|{
name|asection
modifier|*
name|first
init|=
name|elf_next_in_group
argument_list|(
name|sec
argument_list|)
decl_stmt|;
name|asection
modifier|*
name|s
init|=
name|first
decl_stmt|;
while|while
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
name|s
operator|->
name|output_section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
comment|/* Record which group discards it.  */
name|s
operator|->
name|kept_section
operator|=
name|l
operator|->
name|sec
expr_stmt|;
name|s
operator|=
name|elf_next_in_group
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* These lists are circular.  */
if|if
condition|(
name|s
operator|==
name|first
condition|)
break|break;
block|}
block|}
return|return;
block|}
block|}
comment|/* A single member comdat group section may be discarded by a      linkonce section and vice versa.  */
if|if
condition|(
operator|(
name|flags
operator|&
name|SEC_GROUP
operator|)
operator|!=
literal|0
condition|)
block|{
name|asection
modifier|*
name|first
init|=
name|elf_next_in_group
argument_list|(
name|sec
argument_list|)
decl_stmt|;
if|if
condition|(
name|first
operator|!=
name|NULL
operator|&&
name|elf_next_in_group
argument_list|(
name|first
argument_list|)
operator|==
name|first
condition|)
comment|/* Check this single member group against linkonce sections.  */
for|for
control|(
name|l
operator|=
name|already_linked_list
operator|->
name|entry
init|;
name|l
operator|!=
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
if|if
condition|(
operator|(
name|l
operator|->
name|sec
operator|->
name|flags
operator|&
name|SEC_GROUP
operator|)
operator|==
literal|0
operator|&&
name|bfd_coff_get_comdat_section
argument_list|(
name|l
operator|->
name|sec
operator|->
name|owner
argument_list|,
name|l
operator|->
name|sec
argument_list|)
operator|==
name|NULL
operator|&&
name|bfd_elf_match_symbols_in_sections
argument_list|(
name|l
operator|->
name|sec
argument_list|,
name|first
argument_list|,
name|info
argument_list|)
condition|)
block|{
name|first
operator|->
name|output_section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
name|first
operator|->
name|kept_section
operator|=
name|l
operator|->
name|sec
expr_stmt|;
name|sec
operator|->
name|output_section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
break|break;
block|}
block|}
else|else
comment|/* Check this linkonce section against single member groups.  */
for|for
control|(
name|l
operator|=
name|already_linked_list
operator|->
name|entry
init|;
name|l
operator|!=
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
if|if
condition|(
name|l
operator|->
name|sec
operator|->
name|flags
operator|&
name|SEC_GROUP
condition|)
block|{
name|asection
modifier|*
name|first
init|=
name|elf_next_in_group
argument_list|(
name|l
operator|->
name|sec
argument_list|)
decl_stmt|;
if|if
condition|(
name|first
operator|!=
name|NULL
operator|&&
name|elf_next_in_group
argument_list|(
name|first
argument_list|)
operator|==
name|first
operator|&&
name|bfd_elf_match_symbols_in_sections
argument_list|(
name|first
argument_list|,
name|sec
argument_list|,
name|info
argument_list|)
condition|)
block|{
name|sec
operator|->
name|output_section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
name|sec
operator|->
name|kept_section
operator|=
name|first
expr_stmt|;
break|break;
block|}
block|}
comment|/* This is the first section with this name.  Record it.  */
name|bfd_section_already_linked_table_insert
argument_list|(
name|already_linked_list
argument_list|,
name|sec
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|bfd_boolean
name|_bfd_elf_common_definition
parameter_list|(
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|)
block|{
return|return
name|sym
operator|->
name|st_shndx
operator|==
name|SHN_COMMON
return|;
block|}
end_function

begin_function
name|unsigned
name|int
name|_bfd_elf_common_section_index
parameter_list|(
name|asection
modifier|*
name|sec
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|SHN_COMMON
return|;
block|}
end_function

begin_function
name|asection
modifier|*
name|_bfd_elf_common_section
parameter_list|(
name|asection
modifier|*
name|sec
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|bfd_com_section_ptr
return|;
block|}
end_function

end_unit

