begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ELF linking support for BFD.    Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001    Free Software Foundation, Inc.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_define
define|#
directive|define
name|ARCH_SIZE
value|0
end_define

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_function
name|boolean
name|_bfd_elf_create_got_section
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|flagword
name|flags
decl_stmt|;
specifier|register
name|asection
modifier|*
name|s
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|int
name|ptralign
decl_stmt|;
comment|/* This function may be called more than once.  */
if|if
condition|(
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".got"
argument_list|)
operator|!=
name|NULL
condition|)
return|return
name|true
return|;
switch|switch
condition|(
name|bed
operator|->
name|s
operator|->
name|arch_size
condition|)
block|{
case|case
literal|32
case|:
name|ptralign
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|64
case|:
name|ptralign
operator|=
literal|3
expr_stmt|;
break|break;
default|default:
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|flags
operator|=
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator|)
expr_stmt|;
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|flags
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|ptralign
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bed
operator|->
name|want_got_plt
condition|)
block|{
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".got.plt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|flags
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|ptralign
argument_list|)
condition|)
return|return
name|false
return|;
block|}
comment|/* Define the symbol _GLOBAL_OFFSET_TABLE_ at the start of the .got      (or .got.plt) section.  We don't do this in the linker script      because we don't want to define the symbol if we are not creating      a global offset table.  */
name|h
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|,
name|BSF_GLOBAL
argument_list|,
name|s
argument_list|,
name|bed
operator|->
name|got_symbol_offset
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|false
argument_list|,
name|bed
operator|->
name|collect
argument_list|,
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|*
operator|)
operator|&
name|h
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_DEF_REGULAR
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|STT_OBJECT
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
operator|!
name|_bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|false
return|;
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|hgot
operator|=
name|h
expr_stmt|;
comment|/* The first bit of the global offset table is the header.  */
name|s
operator|->
name|_raw_size
operator|+=
name|bed
operator|->
name|got_header_size
operator|+
name|bed
operator|->
name|got_symbol_offset
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create dynamic sections when linking against a dynamic object.  */
end_comment

begin_function
name|boolean
name|_bfd_elf_create_dynamic_sections
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|flagword
name|flags
decl_stmt|,
name|pltflags
decl_stmt|;
specifier|register
name|asection
modifier|*
name|s
decl_stmt|;
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|int
name|ptralign
decl_stmt|;
switch|switch
condition|(
name|bed
operator|->
name|s
operator|->
name|arch_size
condition|)
block|{
case|case
literal|32
case|:
name|ptralign
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|64
case|:
name|ptralign
operator|=
literal|3
expr_stmt|;
break|break;
default|default:
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* We need to create .plt, .rel[a].plt, .got, .got.plt, .dynbss, and      .rel[a].bss sections.  */
name|flags
operator|=
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator|)
expr_stmt|;
name|pltflags
operator|=
name|flags
expr_stmt|;
name|pltflags
operator||=
name|SEC_CODE
expr_stmt|;
if|if
condition|(
name|bed
operator|->
name|plt_not_loaded
condition|)
name|pltflags
operator|&=
operator|~
operator|(
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator|)
expr_stmt|;
if|if
condition|(
name|bed
operator|->
name|plt_readonly
condition|)
name|pltflags
operator||=
name|SEC_READONLY
expr_stmt|;
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|pltflags
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|bed
operator|->
name|plt_alignment
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bed
operator|->
name|want_plt_sym
condition|)
block|{
comment|/* Define the symbol _PROCEDURE_LINKAGE_TABLE_ at the start of the 	 .plt section.  */
name|struct
name|elf_link_hash_entry
modifier|*
name|h
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
literal|"_PROCEDURE_LINKAGE_TABLE_"
argument_list|,
name|BSF_GLOBAL
argument_list|,
name|s
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|false
argument_list|,
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|collect
argument_list|,
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|*
operator|)
operator|&
name|h
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_DEF_REGULAR
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|STT_OBJECT
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
operator|!
name|_bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|false
return|;
block|}
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
name|bed
operator|->
name|default_use_rela_p
condition|?
literal|".rela.plt"
else|:
literal|".rel.plt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|flags
operator||
name|SEC_READONLY
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|ptralign
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|_bfd_elf_create_got_section
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bed
operator|->
name|want_dynbss
condition|)
block|{
comment|/* The .dynbss section is a place to put symbols which are defined 	 by dynamic objects, are referenced by regular objects, and are 	 not functions.  We must allocate space for them in the process 	 image and use a R_*_COPY reloc to tell the dynamic linker to 	 initialize them at run time.  The linker script puts the .dynbss 	 section into the .bss section of the final image.  */
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".dynbss"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|SEC_ALLOC
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* The .rel[a].bss section holds copy relocs.  This section is not      normally needed.  We need to create it here, though, so that the      linker will map it to an output section.  We can't just create it      only if we need it, because we will not know whether we need it      until we have seen all the input files, and the first time the      main linker code calls BFD after examining all the input files      (size_dynamic_sections) the input sections have already been      mapped to the output sections.  If the section turns out not to      be needed, we can discard it later.  We will never need this      section when generating a shared object, since they do not use      copy relocs.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
operator|(
name|bed
operator|->
name|default_use_rela_p
condition|?
literal|".rela.bss"
else|:
literal|".rel.bss"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|flags
operator||
name|SEC_READONLY
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|ptralign
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Record a new dynamic symbol.  We record the dynamic symbols as we    read the input files, since we need to have a list of all of them    before we can determine the final sizes of the output sections.    Note that we may actually call this function even though we are not    going to output any dynamic symbols; in some cases we know that a    symbol should be in the dynamic symbol table, but only if there is    one.  */
end_comment

begin_function
name|boolean
name|_bfd_elf_link_record_dynamic_symbol
parameter_list|(
name|info
parameter_list|,
name|h
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
block|{
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
block|{
name|struct
name|bfd_strtab_hash
modifier|*
name|dynstr
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|alc
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|boolean
name|copy
decl_stmt|;
name|bfd_size_type
name|indx
decl_stmt|;
comment|/* XXX: The ABI draft says the linker must turn hidden and 	 internal symbols into STB_LOCAL symbols when producing the 	 DSO. However, if ld.so honors st_other in the dynamic table, 	 this would not be necessary.  */
switch|switch
condition|(
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
condition|)
block|{
case|case
name|STV_INTERNAL
case|:
case|case
name|STV_HIDDEN
case|:
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefined
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefweak
condition|)
block|{
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_FORCED_LOCAL
expr_stmt|;
return|return
name|true
return|;
block|}
default|default:
break|break;
block|}
name|h
operator|->
name|dynindx
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynsymcount
expr_stmt|;
operator|++
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynsymcount
expr_stmt|;
name|dynstr
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
expr_stmt|;
if|if
condition|(
name|dynstr
operator|==
name|NULL
condition|)
block|{
comment|/* Create a strtab to hold the dynamic symbol names.  */
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
operator|=
name|dynstr
operator|=
name|_bfd_elf_stringtab_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|dynstr
operator|==
name|NULL
condition|)
return|return
name|false
return|;
block|}
comment|/* We don't put any version information in the dynamic string          table.  */
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
name|ELF_VER_CHR
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|alc
operator|=
name|NULL
expr_stmt|;
name|copy
operator|=
name|false
expr_stmt|;
block|}
else|else
block|{
name|alc
operator|=
name|bfd_malloc
argument_list|(
name|p
operator|-
name|name
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|alc
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|strncpy
argument_list|(
name|alc
argument_list|,
name|name
argument_list|,
name|p
operator|-
name|name
argument_list|)
expr_stmt|;
name|alc
index|[
name|p
operator|-
name|name
index|]
operator|=
literal|'\0'
expr_stmt|;
name|name
operator|=
name|alc
expr_stmt|;
name|copy
operator|=
name|true
expr_stmt|;
block|}
name|indx
operator|=
name|_bfd_stringtab_add
argument_list|(
name|dynstr
argument_list|,
name|name
argument_list|,
name|true
argument_list|,
name|copy
argument_list|)
expr_stmt|;
if|if
condition|(
name|alc
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|alc
argument_list|)
expr_stmt|;
if|if
condition|(
name|indx
operator|==
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
condition|)
return|return
name|false
return|;
name|h
operator|->
name|dynstr_index
operator|=
name|indx
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Return the dynindex of a local dynamic symbol.  */
end_comment

begin_function
name|long
name|_bfd_elf_link_lookup_local_dynindx
parameter_list|(
name|info
parameter_list|,
name|input_bfd
parameter_list|,
name|input_indx
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|long
name|input_indx
decl_stmt|;
block|{
name|struct
name|elf_link_local_dynamic_entry
modifier|*
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynlocal
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next
control|)
if|if
condition|(
name|e
operator|->
name|input_bfd
operator|==
name|input_bfd
operator|&&
name|e
operator|->
name|input_indx
operator|==
name|input_indx
condition|)
return|return
name|e
operator|->
name|dynindx
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* This function is used to renumber the dynamic symbols, if some of    them are removed because they are marked as local.  This is called    via elf_link_hash_traverse.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|elf_link_renumber_hash_table_dynsyms
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|boolean
name|elf_link_renumber_hash_table_dynsyms
parameter_list|(
name|h
parameter_list|,
name|data
parameter_list|)
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
name|size_t
modifier|*
name|count
init|=
operator|(
name|size_t
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
condition|)
name|h
operator|->
name|dynindx
operator|=
operator|++
operator|(
operator|*
name|count
operator|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Assign dynsym indices.  In a shared library we generate a section    symbol for each output section, which come first.  Next come all of    the back-end allocated local dynamic syms, followed by the rest of    the global symbols.  */
end_comment

begin_function
name|unsigned
name|long
name|_bfd_elf_link_renumber_dynsyms
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|unsigned
name|long
name|dynsymcount
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
name|asection
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|output_bfd
operator|->
name|sections
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
name|elf_section_data
argument_list|(
name|p
argument_list|)
operator|->
name|dynindx
operator|=
operator|++
name|dynsymcount
expr_stmt|;
block|}
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynlocal
condition|)
block|{
name|struct
name|elf_link_local_dynamic_entry
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynlocal
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
name|p
operator|->
name|dynindx
operator|=
operator|++
name|dynsymcount
expr_stmt|;
block|}
name|elf_link_hash_traverse
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|elf_link_renumber_hash_table_dynsyms
argument_list|,
operator|&
name|dynsymcount
argument_list|)
expr_stmt|;
comment|/* There is an unused NULL entry at the head of the table which      we must account for in our count.  Unless there weren't any      symbols, which means we'll have no table at all.  */
if|if
condition|(
name|dynsymcount
operator|!=
literal|0
condition|)
operator|++
name|dynsymcount
expr_stmt|;
return|return
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynsymcount
operator|=
name|dynsymcount
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create a special linker section, or return a pointer to a linker    section already created */
end_comment

begin_function
name|elf_linker_section_t
modifier|*
name|_bfd_elf_create_linker_section
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|which
parameter_list|,
name|defaults
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|enum
name|elf_linker_section_enum
name|which
decl_stmt|;
name|elf_linker_section_t
modifier|*
name|defaults
decl_stmt|;
block|{
name|bfd
modifier|*
name|dynobj
init|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
decl_stmt|;
name|elf_linker_section_t
modifier|*
name|lsect
decl_stmt|;
comment|/* Record the first bfd section that needs the special section */
if|if
condition|(
operator|!
name|dynobj
condition|)
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
operator|=
name|abfd
expr_stmt|;
comment|/* If this is the first time, create the section */
name|lsect
operator|=
name|elf_linker_section
argument_list|(
name|dynobj
argument_list|,
name|which
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lsect
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|lsect
operator|=
operator|(
name|elf_linker_section_t
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|dynobj
argument_list|,
sizeof|sizeof
argument_list|(
name|elf_linker_section_t
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|lsect
operator|=
operator|*
name|defaults
expr_stmt|;
name|elf_linker_section
argument_list|(
name|dynobj
argument_list|,
name|which
argument_list|)
operator|=
name|lsect
expr_stmt|;
name|lsect
operator|->
name|which
operator|=
name|which
expr_stmt|;
name|lsect
operator|->
name|hole_written_p
operator|=
name|false
expr_stmt|;
comment|/* See if the sections already exist */
name|lsect
operator|->
name|section
operator|=
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|lsect
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
operator|||
operator|(
name|s
operator|->
name|flags
operator|&
name|defaults
operator|->
name|flags
operator|)
operator|!=
name|defaults
operator|->
name|flags
condition|)
block|{
name|lsect
operator|->
name|section
operator|=
name|s
operator|=
name|bfd_make_section_anyway
argument_list|(
name|dynobj
argument_list|,
name|lsect
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
operator|(
name|elf_linker_section_t
operator|*
operator|)
literal|0
return|;
name|bfd_set_section_flags
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|,
name|defaults
operator|->
name|flags
argument_list|)
expr_stmt|;
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|,
name|lsect
operator|->
name|alignment
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bfd_get_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|)
operator|<
name|lsect
operator|->
name|alignment
condition|)
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|,
name|lsect
operator|->
name|alignment
argument_list|)
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|=
name|align_power
argument_list|(
name|s
operator|->
name|_raw_size
argument_list|,
name|lsect
operator|->
name|alignment
argument_list|)
expr_stmt|;
comment|/* Is there a hole we have to provide?  If so check whether the segment is 	 too big already */
if|if
condition|(
name|lsect
operator|->
name|hole_size
condition|)
block|{
name|lsect
operator|->
name|hole_offset
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|+=
name|lsect
operator|->
name|hole_size
expr_stmt|;
if|if
condition|(
name|lsect
operator|->
name|hole_offset
operator|>
name|lsect
operator|->
name|max_hole_offset
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: Section %s is already to large to put hole of %ld bytes in"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|lsect
operator|->
name|name
argument_list|,
operator|(
name|long
operator|)
name|lsect
operator|->
name|hole_size
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
operator|(
name|elf_linker_section_t
operator|*
operator|)
literal|0
return|;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Creating section %s, current size = %ld\n"
argument_list|,
name|lsect
operator|->
name|name
argument_list|,
operator|(
name|long
operator|)
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|lsect
operator|->
name|sym_name
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
init|=
name|NULL
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Adding %s to section %s\n"
argument_list|,
name|lsect
operator|->
name|sym_name
argument_list|,
name|lsect
operator|->
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|bfd_link_hash_lookup
argument_list|(
name|info
operator|->
name|hash
argument_list|,
name|lsect
operator|->
name|sym_name
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|h
operator|==
name|NULL
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
operator|)
operator|&&
operator|!
operator|(
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
name|lsect
operator|->
name|sym_name
argument_list|,
name|BSF_GLOBAL
argument_list|,
name|s
argument_list|,
operator|(
operator|(
name|lsect
operator|->
name|hole_size
operator|)
condition|?
name|s
operator|->
name|_raw_size
operator|-
name|lsect
operator|->
name|hole_size
operator|+
name|lsect
operator|->
name|sym_offset
else|:
name|lsect
operator|->
name|sym_offset
operator|)
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|false
argument_list|,
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|collect
argument_list|,
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|*
operator|)
operator|&
name|h
argument_list|)
operator|)
condition|)
return|return
operator|(
name|elf_linker_section_t
operator|*
operator|)
literal|0
return|;
if|if
condition|(
operator|(
name|defaults
operator|->
name|which
operator|!=
name|LINKER_SECTION_SDATA
operator|)
operator|&&
operator|(
name|defaults
operator|->
name|which
operator|!=
name|LINKER_SECTION_SDATA2
operator|)
condition|)
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_DEF_DYNAMIC
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|STT_OBJECT
expr_stmt|;
name|lsect
operator|->
name|sym_hash
operator|=
name|h
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
operator|!
name|_bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
operator|(
name|elf_linker_section_t
operator|*
operator|)
literal|0
return|;
block|}
block|}
if|#
directive|if
literal|0
comment|/* This does not make sense.  The sections which may exist in the      object file have nothing to do with the sections we want to      create.  */
comment|/* Find the related sections if they have been created */
block|if (lsect->bss_name&& !lsect->bss_section)     lsect->bss_section = bfd_get_section_by_name (dynobj, lsect->bss_name);    if (lsect->rel_name&& !lsect->rel_section)     lsect->rel_section = bfd_get_section_by_name (dynobj, lsect->rel_name);
endif|#
directive|endif
return|return
name|lsect
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find a linker generated pointer with a given addend and type.  */
end_comment

begin_function
name|elf_linker_section_pointers_t
modifier|*
name|_bfd_elf_find_pointer_linker_section
parameter_list|(
name|linker_pointers
parameter_list|,
name|addend
parameter_list|,
name|which
parameter_list|)
name|elf_linker_section_pointers_t
modifier|*
name|linker_pointers
decl_stmt|;
name|bfd_signed_vma
name|addend
decl_stmt|;
name|elf_linker_section_enum_t
name|which
decl_stmt|;
block|{
for|for
control|(
init|;
name|linker_pointers
operator|!=
name|NULL
condition|;
name|linker_pointers
operator|=
name|linker_pointers
operator|->
name|next
control|)
block|{
if|if
condition|(
name|which
operator|==
name|linker_pointers
operator|->
name|which
operator|&&
name|addend
operator|==
name|linker_pointers
operator|->
name|addend
condition|)
return|return
name|linker_pointers
return|;
block|}
return|return
operator|(
name|elf_linker_section_pointers_t
operator|*
operator|)
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make the .rela section corresponding to the generated linker section.  */
end_comment

begin_function
name|boolean
name|_bfd_elf_make_linker_section_rela
parameter_list|(
name|dynobj
parameter_list|,
name|lsect
parameter_list|,
name|alignment
parameter_list|)
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|elf_linker_section_t
modifier|*
name|lsect
decl_stmt|;
name|int
name|alignment
decl_stmt|;
block|{
if|if
condition|(
name|lsect
operator|->
name|rel_section
condition|)
return|return
name|true
return|;
name|lsect
operator|->
name|rel_section
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|lsect
operator|->
name|rel_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|lsect
operator|->
name|rel_section
operator|==
name|NULL
condition|)
block|{
name|lsect
operator|->
name|rel_section
operator|=
name|bfd_make_section
argument_list|(
name|dynobj
argument_list|,
name|lsect
operator|->
name|rel_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|lsect
operator|->
name|rel_section
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|dynobj
argument_list|,
name|lsect
operator|->
name|rel_section
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_READONLY
operator|)
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|lsect
operator|->
name|rel_section
argument_list|,
name|alignment
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

end_unit

