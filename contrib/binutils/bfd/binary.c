begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD back-end for binary objects.    Copyright 1994, 95, 96, 97, 98, 1999 Free Software Foundation, Inc.    Written by Ian Lance Taylor, Cygnus Support,<ian@cygnus.com>  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This is a BFD backend which may be used to write binary objects.    It may only be used for output, not input.  The intention is that    this may be used as an output format for objcopy in order to    generate raw binary data.     This is very simple.  The only complication is that the real data    will start at some address X, and in some cases we will not want to    include X zeroes just to get to that point.  Since the start    address is not meaningful for this object file format, we use it    instead to indicate the number of zeroes to skip at the start of    the file.  objcopy cooperates by specially setting the start    address to zero by default.  */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_comment
comment|/* Any bfd we create by reading a binary file has three symbols:    a start symbol, an end symbol, and an absolute length symbol.  */
end_comment

begin_define
define|#
directive|define
name|BIN_SYMS
value|3
end_define

begin_decl_stmt
specifier|static
name|boolean
name|binary_mkobject
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|bfd_target
modifier|*
name|binary_object_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|binary_get_section_contents
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|,
name|file_ptr
operator|,
name|bfd_size_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|binary_get_symtab_upper_bound
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|mangle_name
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|binary_get_symtab
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asymbol
modifier|*
name|binary_make_empty_symbol
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|binary_get_symbol_info
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|symbol_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|binary_set_section_contents
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|,
name|file_ptr
operator|,
name|bfd_size_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|binary_sizeof_headers
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Create a binary object.  Invoked via bfd_set_format.  */
end_comment

begin_function
specifier|static
name|boolean
name|binary_mkobject
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Any file may be considered to be a binary file, provided the target    was not defaulted.  That is, it must be explicitly specified as    being binary.  */
end_comment

begin_function
specifier|static
specifier|const
name|bfd_target
modifier|*
name|binary_object_p
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|stat
name|statbuf
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
if|if
condition|(
name|abfd
operator|->
name|target_defaulted
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|abfd
operator|->
name|symcount
operator|=
name|BIN_SYMS
expr_stmt|;
comment|/* Find the file size.  */
if|if
condition|(
name|bfd_stat
argument_list|(
name|abfd
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* One data section.  */
name|sec
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".data"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|sec
operator|->
name|flags
operator|=
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_DATA
operator||
name|SEC_HAS_CONTENTS
expr_stmt|;
name|sec
operator|->
name|vma
operator|=
literal|0
expr_stmt|;
name|sec
operator|->
name|_raw_size
operator|=
name|statbuf
operator|.
name|st_size
expr_stmt|;
name|sec
operator|->
name|filepos
operator|=
literal|0
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|any
operator|=
operator|(
name|PTR
operator|)
name|sec
expr_stmt|;
return|return
name|abfd
operator|->
name|xvec
return|;
block|}
end_function

begin_define
define|#
directive|define
name|binary_close_and_cleanup
value|_bfd_generic_close_and_cleanup
end_define

begin_define
define|#
directive|define
name|binary_bfd_free_cached_info
value|_bfd_generic_bfd_free_cached_info
end_define

begin_define
define|#
directive|define
name|binary_new_section_hook
value|_bfd_generic_new_section_hook
end_define

begin_comment
comment|/* Get contents of the only section.  */
end_comment

begin_function
specifier|static
name|boolean
name|binary_get_section_contents
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|location
parameter_list|,
name|offset
parameter_list|,
name|count
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|PTR
name|location
decl_stmt|;
name|file_ptr
name|offset
decl_stmt|;
name|bfd_size_type
name|count
decl_stmt|;
block|{
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_read
argument_list|(
name|location
argument_list|,
literal|1
argument_list|,
name|count
argument_list|,
name|abfd
argument_list|)
operator|!=
name|count
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Return the amount of memory needed to read the symbol table.  */
end_comment

begin_function
specifier|static
name|long
name|binary_get_symtab_upper_bound
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
name|BIN_SYMS
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Create a symbol name based on the bfd's filename.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|mangle_name
parameter_list|(
name|abfd
parameter_list|,
name|suffix
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|char
modifier|*
name|suffix
decl_stmt|;
block|{
name|int
name|size
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|size
operator|=
operator|(
name|strlen
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
operator|+
name|strlen
argument_list|(
name|suffix
argument_list|)
operator|+
sizeof|sizeof
expr|"_binary__"
operator|)
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
literal|""
return|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"_binary_%s_%s"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
comment|/* Change any non-alphanumeric characters to underscores.  */
for|for
control|(
name|p
operator|=
name|buf
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|!
name|isalnum
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
argument_list|)
condition|)
operator|*
name|p
operator|=
literal|'_'
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/* Return the symbol table.  */
end_comment

begin_function
specifier|static
name|long
name|binary_get_symtab
parameter_list|(
name|abfd
parameter_list|,
name|alocation
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|alocation
decl_stmt|;
block|{
name|asection
modifier|*
name|sec
init|=
operator|(
name|asection
operator|*
operator|)
name|abfd
operator|->
name|tdata
operator|.
name|any
decl_stmt|;
name|asymbol
modifier|*
name|syms
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|syms
operator|=
operator|(
name|asymbol
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|BIN_SYMS
operator|*
sizeof|sizeof
argument_list|(
name|asymbol
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|syms
operator|==
name|NULL
condition|)
return|return
name|false
return|;
comment|/* Start symbol.  */
name|syms
index|[
literal|0
index|]
operator|.
name|the_bfd
operator|=
name|abfd
expr_stmt|;
name|syms
index|[
literal|0
index|]
operator|.
name|name
operator|=
name|mangle_name
argument_list|(
name|abfd
argument_list|,
literal|"start"
argument_list|)
expr_stmt|;
name|syms
index|[
literal|0
index|]
operator|.
name|value
operator|=
literal|0
expr_stmt|;
name|syms
index|[
literal|0
index|]
operator|.
name|flags
operator|=
name|BSF_GLOBAL
expr_stmt|;
name|syms
index|[
literal|0
index|]
operator|.
name|section
operator|=
name|sec
expr_stmt|;
name|syms
index|[
literal|0
index|]
operator|.
name|udata
operator|.
name|p
operator|=
name|NULL
expr_stmt|;
comment|/* End symbol.  */
name|syms
index|[
literal|1
index|]
operator|.
name|the_bfd
operator|=
name|abfd
expr_stmt|;
name|syms
index|[
literal|1
index|]
operator|.
name|name
operator|=
name|mangle_name
argument_list|(
name|abfd
argument_list|,
literal|"end"
argument_list|)
expr_stmt|;
name|syms
index|[
literal|1
index|]
operator|.
name|value
operator|=
name|sec
operator|->
name|_raw_size
expr_stmt|;
name|syms
index|[
literal|1
index|]
operator|.
name|flags
operator|=
name|BSF_GLOBAL
expr_stmt|;
name|syms
index|[
literal|1
index|]
operator|.
name|section
operator|=
name|sec
expr_stmt|;
name|syms
index|[
literal|1
index|]
operator|.
name|udata
operator|.
name|p
operator|=
name|NULL
expr_stmt|;
comment|/* Size symbol.  */
name|syms
index|[
literal|2
index|]
operator|.
name|the_bfd
operator|=
name|abfd
expr_stmt|;
name|syms
index|[
literal|2
index|]
operator|.
name|name
operator|=
name|mangle_name
argument_list|(
name|abfd
argument_list|,
literal|"size"
argument_list|)
expr_stmt|;
name|syms
index|[
literal|2
index|]
operator|.
name|value
operator|=
name|sec
operator|->
name|_raw_size
expr_stmt|;
name|syms
index|[
literal|2
index|]
operator|.
name|flags
operator|=
name|BSF_GLOBAL
expr_stmt|;
name|syms
index|[
literal|2
index|]
operator|.
name|section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
name|syms
index|[
literal|2
index|]
operator|.
name|udata
operator|.
name|p
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BIN_SYMS
condition|;
name|i
operator|++
control|)
operator|*
name|alocation
operator|++
operator|=
name|syms
operator|++
expr_stmt|;
operator|*
name|alocation
operator|=
name|NULL
expr_stmt|;
return|return
name|BIN_SYMS
return|;
block|}
end_function

begin_comment
comment|/* Make an empty symbol.  */
end_comment

begin_function
specifier|static
name|asymbol
modifier|*
name|binary_make_empty_symbol
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
return|return
operator|(
name|asymbol
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|asymbol
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|binary_print_symbol
value|_bfd_nosymbols_print_symbol
end_define

begin_comment
comment|/* Get information about a symbol.  */
end_comment

begin_function
specifier|static
name|void
name|binary_get_symbol_info
parameter_list|(
name|ignore_abfd
parameter_list|,
name|symbol
parameter_list|,
name|ret
parameter_list|)
name|bfd
modifier|*
name|ignore_abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|symbol_info
modifier|*
name|ret
decl_stmt|;
block|{
name|bfd_symbol_info
argument_list|(
name|symbol
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|binary_bfd_is_local_label_name
value|bfd_generic_is_local_label_name
end_define

begin_define
define|#
directive|define
name|binary_get_lineno
value|_bfd_nosymbols_get_lineno
end_define

begin_define
define|#
directive|define
name|binary_find_nearest_line
value|_bfd_nosymbols_find_nearest_line
end_define

begin_define
define|#
directive|define
name|binary_bfd_make_debug_symbol
value|_bfd_nosymbols_bfd_make_debug_symbol
end_define

begin_define
define|#
directive|define
name|binary_read_minisymbols
value|_bfd_generic_read_minisymbols
end_define

begin_define
define|#
directive|define
name|binary_minisymbol_to_symbol
value|_bfd_generic_minisymbol_to_symbol
end_define

begin_define
define|#
directive|define
name|binary_get_reloc_upper_bound
define|\
value|((long (*) PARAMS ((bfd *, asection *))) bfd_0l)
end_define

begin_define
define|#
directive|define
name|binary_canonicalize_reloc
define|\
value|((long (*) PARAMS ((bfd *, asection *, arelent **, asymbol **))) bfd_0l)
end_define

begin_define
define|#
directive|define
name|binary_bfd_reloc_type_lookup
value|_bfd_norelocs_bfd_reloc_type_lookup
end_define

begin_comment
comment|/* Set the architecture of a binary file.  */
end_comment

begin_define
define|#
directive|define
name|binary_set_arch_mach
value|_bfd_generic_set_arch_mach
end_define

begin_comment
comment|/* Write section contents of a binary file.  */
end_comment

begin_function
specifier|static
name|boolean
name|binary_set_section_contents
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|data
parameter_list|,
name|offset
parameter_list|,
name|size
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|file_ptr
name|offset
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|abfd
operator|->
name|output_has_begun
condition|)
block|{
name|boolean
name|found_low
decl_stmt|;
name|bfd_vma
name|low
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
comment|/* The lowest section LMA sets the virtual address of the start          of the file.  We use this to set the file position of all the          sections.  */
name|found_low
operator|=
name|false
expr_stmt|;
name|low
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
if|if
condition|(
operator|(
operator|(
name|s
operator|->
name|flags
operator|&
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_LOAD
operator||
name|SEC_ALLOC
operator||
name|SEC_NEVER_LOAD
operator|)
operator|)
operator|==
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_LOAD
operator||
name|SEC_ALLOC
operator|)
operator|)
operator|&&
operator|(
operator|!
name|found_low
operator|||
name|s
operator|->
name|lma
operator|<
name|low
operator|)
condition|)
block|{
name|low
operator|=
name|s
operator|->
name|lma
expr_stmt|;
name|found_low
operator|=
name|true
expr_stmt|;
block|}
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|s
operator|->
name|filepos
operator|=
name|s
operator|->
name|lma
operator|-
name|low
expr_stmt|;
comment|/* Skip following warning check for sections that will not 	     occupy file space.  */
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_NEVER_LOAD
operator|)
operator|)
operator|!=
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator|)
condition|)
continue|continue;
comment|/* If attempting to generate a binary file from a bfd with 	     LMA's all over the place, huge (sparse?) binary files may 	     result.  This condition attempts to detect this situation 	     and print a warning.  Better heuristics would be nice to 	     have. */
if|if
condition|(
name|s
operator|->
name|filepos
operator|<
literal|0
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Warning: Writing section `%s' to huge (ie negative) file offset 0x%lx."
argument_list|)
argument_list|,
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|s
operator|->
name|filepos
argument_list|)
expr_stmt|;
block|}
name|abfd
operator|->
name|output_has_begun
operator|=
name|true
expr_stmt|;
block|}
comment|/* We don't want to output anything for a section that is neither      loaded nor allocated.  The contents of such a section are not      meaningful in the binary format.  */
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
operator|(
name|SEC_LOAD
operator||
name|SEC_ALLOC
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
name|true
return|;
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_NEVER_LOAD
operator|)
operator|!=
literal|0
condition|)
return|return
name|true
return|;
return|return
name|_bfd_generic_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|data
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* No space is required for header information.  */
end_comment

begin_function
specifier|static
name|int
name|binary_sizeof_headers
parameter_list|(
name|abfd
parameter_list|,
name|exec
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|boolean
name|exec
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|binary_bfd_get_relocated_section_contents
define|\
value|bfd_generic_get_relocated_section_contents
end_define

begin_define
define|#
directive|define
name|binary_bfd_relax_section
value|bfd_generic_relax_section
end_define

begin_define
define|#
directive|define
name|binary_bfd_gc_sections
value|bfd_generic_gc_sections
end_define

begin_define
define|#
directive|define
name|binary_bfd_link_hash_table_create
value|_bfd_generic_link_hash_table_create
end_define

begin_define
define|#
directive|define
name|binary_bfd_link_add_symbols
value|_bfd_generic_link_add_symbols
end_define

begin_define
define|#
directive|define
name|binary_bfd_final_link
value|_bfd_generic_final_link
end_define

begin_define
define|#
directive|define
name|binary_bfd_link_split_section
value|_bfd_generic_link_split_section
end_define

begin_define
define|#
directive|define
name|binary_get_section_contents_in_window
define|\
value|_bfd_generic_get_section_contents_in_window
end_define

begin_decl_stmt
specifier|const
name|bfd_target
name|binary_vec
init|=
block|{
literal|"binary"
block|,
comment|/* name */
name|bfd_target_unknown_flavour
block|,
comment|/* flavour */
name|BFD_ENDIAN_UNKNOWN
block|,
comment|/* byteorder */
name|BFD_ENDIAN_UNKNOWN
block|,
comment|/* header_byteorder */
name|EXEC_P
block|,
comment|/* object_flags */
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_READONLY
operator||
name|SEC_CODE
operator||
name|SEC_DATA
operator||
name|SEC_ROM
operator||
name|SEC_HAS_CONTENTS
operator|)
block|,
comment|/* section_flags */
literal|0
block|,
comment|/* symbol_leading_char */
literal|' '
block|,
comment|/* ar_pad_char */
literal|16
block|,
comment|/* ar_max_namelen */
name|bfd_getb64
block|,
name|bfd_getb_signed_64
block|,
name|bfd_putb64
block|,
name|bfd_getb32
block|,
name|bfd_getb_signed_32
block|,
name|bfd_putb32
block|,
name|bfd_getb16
block|,
name|bfd_getb_signed_16
block|,
name|bfd_putb16
block|,
comment|/* data */
name|bfd_getb64
block|,
name|bfd_getb_signed_64
block|,
name|bfd_putb64
block|,
name|bfd_getb32
block|,
name|bfd_getb_signed_32
block|,
name|bfd_putb32
block|,
name|bfd_getb16
block|,
name|bfd_getb_signed_16
block|,
name|bfd_putb16
block|,
comment|/* hdrs */
block|{
comment|/* bfd_check_format */
name|_bfd_dummy_target
block|,
name|binary_object_p
block|,
comment|/* bfd_check_format */
name|_bfd_dummy_target
block|,
name|_bfd_dummy_target
block|,   }
block|,
block|{
comment|/* bfd_set_format */
name|bfd_false
block|,
name|binary_mkobject
block|,
name|bfd_false
block|,
name|bfd_false
block|,   }
block|,
block|{
comment|/* bfd_write_contents */
name|bfd_false
block|,
name|bfd_true
block|,
name|bfd_false
block|,
name|bfd_false
block|,   }
block|,
name|BFD_JUMP_TABLE_GENERIC
argument_list|(
name|binary
argument_list|)
block|,
name|BFD_JUMP_TABLE_COPY
argument_list|(
name|_bfd_generic
argument_list|)
block|,
name|BFD_JUMP_TABLE_CORE
argument_list|(
name|_bfd_nocore
argument_list|)
block|,
name|BFD_JUMP_TABLE_ARCHIVE
argument_list|(
name|_bfd_noarchive
argument_list|)
block|,
name|BFD_JUMP_TABLE_SYMBOLS
argument_list|(
name|binary
argument_list|)
block|,
name|BFD_JUMP_TABLE_RELOCS
argument_list|(
name|binary
argument_list|)
block|,
name|BFD_JUMP_TABLE_WRITE
argument_list|(
name|binary
argument_list|)
block|,
name|BFD_JUMP_TABLE_LINK
argument_list|(
name|binary
argument_list|)
block|,
name|BFD_JUMP_TABLE_DYNAMIC
argument_list|(
name|_bfd_nodynamic
argument_list|)
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

end_unit

