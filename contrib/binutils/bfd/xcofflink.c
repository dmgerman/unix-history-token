begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* POWER/PowerPC XCOFF linker support.    Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003    Free Software Foundation, Inc.    Written by Ian Lance Taylor<ian@cygnus.com>, Cygnus Support.     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"coff/internal.h"
end_include

begin_include
include|#
directive|include
file|"coff/xcoff.h"
end_include

begin_include
include|#
directive|include
file|"libcoff.h"
end_include

begin_include
include|#
directive|include
file|"libxcoff.h"
end_include

begin_comment
comment|/* This file holds the XCOFF linker code.  */
end_comment

begin_define
define|#
directive|define
name|STRING_SIZE_SIZE
value|(4)
end_define

begin_comment
comment|/* We reuse the SEC_ROM flag as a mark flag for garbage collection.    This flag will only be used on input sections.  */
end_comment

begin_define
define|#
directive|define
name|SEC_MARK
value|(SEC_ROM)
end_define

begin_comment
comment|/* The list of import files.  */
end_comment

begin_struct
struct|struct
name|xcoff_import_file
block|{
comment|/* The next entry in the list.  */
name|struct
name|xcoff_import_file
modifier|*
name|next
decl_stmt|;
comment|/* The path.  */
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
comment|/* The file name.  */
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
comment|/* The member name.  */
specifier|const
name|char
modifier|*
name|member
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Information we keep for each section in the output file during the    final link phase.  */
end_comment

begin_struct
struct|struct
name|xcoff_link_section_info
block|{
comment|/* The relocs to be output.  */
name|struct
name|internal_reloc
modifier|*
name|relocs
decl_stmt|;
comment|/* For each reloc against a global symbol whose index was not known      when the reloc was handled, the global hash table entry.  */
name|struct
name|xcoff_link_hash_entry
modifier|*
modifier|*
name|rel_hashes
decl_stmt|;
comment|/* If there is a TOC relative reloc against a global symbol, and the      index of the TOC symbol is not known when the reloc was handled,      an entry is added to this linked list.  This is not an array,      like rel_hashes, because this case is quite uncommon.  */
struct|struct
name|xcoff_toc_rel_hash
block|{
name|struct
name|xcoff_toc_rel_hash
modifier|*
name|next
decl_stmt|;
name|struct
name|xcoff_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|rel
decl_stmt|;
block|}
modifier|*
name|toc_rel_hashes
struct|;
block|}
struct|;
end_struct

begin_comment
comment|/* Information that we pass around while doing the final link step.  */
end_comment

begin_struct
struct|struct
name|xcoff_final_link_info
block|{
comment|/* General link information.  */
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
comment|/* Output BFD.  */
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
comment|/* Hash table for long symbol names.  */
name|struct
name|bfd_strtab_hash
modifier|*
name|strtab
decl_stmt|;
comment|/* Array of information kept for each output section, indexed by the      target_index field.  */
name|struct
name|xcoff_link_section_info
modifier|*
name|section_info
decl_stmt|;
comment|/* Symbol index of last C_FILE symbol (-1 if none).  */
name|long
name|last_file_index
decl_stmt|;
comment|/* Contents of last C_FILE symbol.  */
name|struct
name|internal_syment
name|last_file
decl_stmt|;
comment|/* Symbol index of TOC symbol.  */
name|long
name|toc_symindx
decl_stmt|;
comment|/* Start of .loader symbols.  */
name|bfd_byte
modifier|*
name|ldsym
decl_stmt|;
comment|/* Next .loader reloc to swap out.  */
name|bfd_byte
modifier|*
name|ldrel
decl_stmt|;
comment|/* File position of start of line numbers.  */
name|file_ptr
name|line_filepos
decl_stmt|;
comment|/* Buffer large enough to hold swapped symbols of any input file.  */
name|struct
name|internal_syment
modifier|*
name|internal_syms
decl_stmt|;
comment|/* Buffer large enough to hold output indices of symbols of any      input file.  */
name|long
modifier|*
name|sym_indices
decl_stmt|;
comment|/* Buffer large enough to hold output symbols for any input file.  */
name|bfd_byte
modifier|*
name|outsyms
decl_stmt|;
comment|/* Buffer large enough to hold external line numbers for any input      section.  */
name|bfd_byte
modifier|*
name|linenos
decl_stmt|;
comment|/* Buffer large enough to hold any input section.  */
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
comment|/* Buffer large enough to hold external relocs of any input section.  */
name|bfd_byte
modifier|*
name|external_relocs
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|xcoff_link_hash_newfunc
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|,
expr|struct
name|bfd_hash_table
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|xcoff_get_section_contents
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|internal_reloc
modifier|*
name|xcoff_read_internal_relocs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_boolean
operator|,
name|bfd_byte
operator|*
operator|,
name|bfd_boolean
operator|,
expr|struct
name|internal_reloc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|xcoff_link_add_object_symbols
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|xcoff_link_check_archive_element
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd_boolean
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|xcoff_link_check_ar_symbols
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd_boolean
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|xcoff_link_check_dynamic_ar_symbols
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd_boolean
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_size_type
name|xcoff_find_reloc
name|PARAMS
argument_list|(
operator|(
expr|struct
name|internal_reloc
operator|*
operator|,
name|bfd_size_type
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|xcoff_link_add_symbols
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|xcoff_link_add_dynamic_symbols
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|xcoff_mark_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|xcoff_link_hash_entry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|xcoff_mark
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xcoff_sweep
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|xcoff_build_ldsyms
name|PARAMS
argument_list|(
operator|(
expr|struct
name|xcoff_link_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|xcoff_link_input_bfd
name|PARAMS
argument_list|(
operator|(
expr|struct
name|xcoff_final_link_info
operator|*
operator|,
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|xcoff_write_global_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|xcoff_link_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|xcoff_reloc_link_order
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|xcoff_final_link_info
operator|*
operator|,
name|asection
operator|*
operator|,
expr|struct
name|bfd_link_order
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|xcoff_sort_relocs
name|PARAMS
argument_list|(
operator|(
specifier|const
name|PTR
operator|,
specifier|const
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Routines to read XCOFF dynamic information.  This don't really    belong here, but we already have the ldsym manipulation routines    here.  */
end_comment

begin_comment
comment|/* Read the contents of a section.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|xcoff_get_section_contents
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
block|{
if|if
condition|(
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|coff_section_tdata
argument_list|)
decl_stmt|;
name|sec
operator|->
name|used_by_bfd
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|used_by_bfd
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|->
name|contents
operator|==
name|NULL
condition|)
block|{
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|->
name|contents
operator|=
operator|(
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|sec
operator|->
name|_raw_size
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|->
name|contents
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|sec
operator|->
name|_raw_size
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Get the size required to hold the dynamic symbols.  */
end_comment

begin_function
name|long
name|_bfd_xcoff_get_dynamic_symtab_upper_bound
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|asection
modifier|*
name|lsec
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|struct
name|internal_ldhdr
name|ldhdr
decl_stmt|;
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|==
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|lsec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".loader"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lsec
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_symbols
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|xcoff_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|lsec
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|contents
operator|=
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|lsec
argument_list|)
operator|->
name|contents
expr_stmt|;
name|bfd_xcoff_swap_ldhdr_in
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|contents
argument_list|,
operator|&
name|ldhdr
argument_list|)
expr_stmt|;
return|return
operator|(
name|ldhdr
operator|.
name|l_nsyms
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Get the dynamic symbols.  */
end_comment

begin_function
name|long
name|_bfd_xcoff_canonicalize_dynamic_symtab
parameter_list|(
name|abfd
parameter_list|,
name|psyms
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|psyms
decl_stmt|;
block|{
name|asection
modifier|*
name|lsec
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|struct
name|internal_ldhdr
name|ldhdr
decl_stmt|;
specifier|const
name|char
modifier|*
name|strings
decl_stmt|;
name|bfd_byte
modifier|*
name|elsym
decl_stmt|,
modifier|*
name|elsymend
decl_stmt|;
name|coff_symbol_type
modifier|*
name|symbuf
decl_stmt|;
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|==
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|lsec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".loader"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lsec
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_symbols
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|xcoff_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|lsec
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|contents
operator|=
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|lsec
argument_list|)
operator|->
name|contents
expr_stmt|;
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|lsec
argument_list|)
operator|->
name|keep_contents
operator|=
name|TRUE
expr_stmt|;
name|bfd_xcoff_swap_ldhdr_in
argument_list|(
name|abfd
argument_list|,
name|contents
argument_list|,
operator|&
name|ldhdr
argument_list|)
expr_stmt|;
name|strings
operator|=
operator|(
name|char
operator|*
operator|)
name|contents
operator|+
name|ldhdr
operator|.
name|l_stoff
expr_stmt|;
name|symbuf
operator|=
operator|(
operator|(
name|coff_symbol_type
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|ldhdr
operator|.
name|l_nsyms
operator|*
sizeof|sizeof
argument_list|(
name|coff_symbol_type
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|symbuf
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|elsym
operator|=
name|contents
operator|+
name|bfd_xcoff_loader_symbol_offset
argument_list|(
name|abfd
argument_list|,
operator|&
name|ldhdr
argument_list|)
expr_stmt|;
name|elsymend
operator|=
name|elsym
operator|+
name|ldhdr
operator|.
name|l_nsyms
operator|*
name|bfd_xcoff_ldsymsz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|elsym
operator|<
name|elsymend
condition|;
name|elsym
operator|+=
name|bfd_xcoff_ldsymsz
argument_list|(
name|abfd
argument_list|)
operator|,
name|symbuf
operator|++
operator|,
name|psyms
operator|++
control|)
block|{
name|struct
name|internal_ldsym
name|ldsym
decl_stmt|;
name|bfd_xcoff_swap_ldsym_in
argument_list|(
name|abfd
argument_list|,
name|elsym
argument_list|,
operator|&
name|ldsym
argument_list|)
expr_stmt|;
name|symbuf
operator|->
name|symbol
operator|.
name|the_bfd
operator|=
name|abfd
expr_stmt|;
if|if
condition|(
name|ldsym
operator|.
name|_l
operator|.
name|_l_l
operator|.
name|_l_zeroes
operator|==
literal|0
condition|)
name|symbuf
operator|->
name|symbol
operator|.
name|name
operator|=
name|strings
operator|+
name|ldsym
operator|.
name|_l
operator|.
name|_l_l
operator|.
name|_l_offset
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|c
decl_stmt|;
name|c
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|SYMNMLEN
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|memcpy
argument_list|(
name|c
argument_list|,
name|ldsym
operator|.
name|_l
operator|.
name|_l_name
argument_list|,
name|SYMNMLEN
argument_list|)
expr_stmt|;
name|c
index|[
name|SYMNMLEN
index|]
operator|=
literal|'\0'
expr_stmt|;
name|symbuf
operator|->
name|symbol
operator|.
name|name
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|ldsym
operator|.
name|l_smclas
operator|==
name|XMC_XO
condition|)
name|symbuf
operator|->
name|symbol
operator|.
name|section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
else|else
name|symbuf
operator|->
name|symbol
operator|.
name|section
operator|=
name|coff_section_from_bfd_index
argument_list|(
name|abfd
argument_list|,
name|ldsym
operator|.
name|l_scnum
argument_list|)
expr_stmt|;
name|symbuf
operator|->
name|symbol
operator|.
name|value
operator|=
name|ldsym
operator|.
name|l_value
operator|-
name|symbuf
operator|->
name|symbol
operator|.
name|section
operator|->
name|vma
expr_stmt|;
name|symbuf
operator|->
name|symbol
operator|.
name|flags
operator|=
name|BSF_NO_FLAGS
expr_stmt|;
if|if
condition|(
operator|(
name|ldsym
operator|.
name|l_smtype
operator|&
name|L_EXPORT
operator|)
operator|!=
literal|0
condition|)
name|symbuf
operator|->
name|symbol
operator|.
name|flags
operator||=
name|BSF_GLOBAL
expr_stmt|;
comment|/* FIXME: We have no way to record the other information stored 	 with the loader symbol.  */
operator|*
name|psyms
operator|=
operator|(
name|asymbol
operator|*
operator|)
name|symbuf
expr_stmt|;
block|}
operator|*
name|psyms
operator|=
name|NULL
expr_stmt|;
return|return
name|ldhdr
operator|.
name|l_nsyms
return|;
block|}
end_function

begin_comment
comment|/* Get the size required to hold the dynamic relocs.  */
end_comment

begin_function
name|long
name|_bfd_xcoff_get_dynamic_reloc_upper_bound
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|asection
modifier|*
name|lsec
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|struct
name|internal_ldhdr
name|ldhdr
decl_stmt|;
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|==
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|lsec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".loader"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lsec
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_symbols
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|xcoff_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|lsec
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|contents
operator|=
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|lsec
argument_list|)
operator|->
name|contents
expr_stmt|;
name|bfd_xcoff_swap_ldhdr_in
argument_list|(
name|abfd
argument_list|,
operator|(
expr|struct
name|external_ldhdr
operator|*
operator|)
name|contents
argument_list|,
operator|&
name|ldhdr
argument_list|)
expr_stmt|;
return|return
operator|(
name|ldhdr
operator|.
name|l_nreloc
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Get the dynamic relocs.  */
end_comment

begin_function
name|long
name|_bfd_xcoff_canonicalize_dynamic_reloc
parameter_list|(
name|abfd
parameter_list|,
name|prelocs
parameter_list|,
name|syms
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|prelocs
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|syms
decl_stmt|;
block|{
name|asection
modifier|*
name|lsec
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|struct
name|internal_ldhdr
name|ldhdr
decl_stmt|;
name|arelent
modifier|*
name|relbuf
decl_stmt|;
name|bfd_byte
modifier|*
name|elrel
decl_stmt|,
modifier|*
name|elrelend
decl_stmt|;
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|==
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|lsec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".loader"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lsec
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_symbols
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|xcoff_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|lsec
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|contents
operator|=
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|lsec
argument_list|)
operator|->
name|contents
expr_stmt|;
name|bfd_xcoff_swap_ldhdr_in
argument_list|(
name|abfd
argument_list|,
name|contents
argument_list|,
operator|&
name|ldhdr
argument_list|)
expr_stmt|;
name|relbuf
operator|=
operator|(
name|arelent
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|ldhdr
operator|.
name|l_nreloc
operator|*
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|relbuf
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|elrel
operator|=
name|contents
operator|+
name|bfd_xcoff_loader_reloc_offset
argument_list|(
name|abfd
argument_list|,
operator|&
name|ldhdr
argument_list|)
expr_stmt|;
name|elrelend
operator|=
name|elrel
operator|+
name|ldhdr
operator|.
name|l_nreloc
operator|*
name|bfd_xcoff_ldrelsz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|elrel
operator|<
name|elrelend
condition|;
name|elrel
operator|+=
name|bfd_xcoff_ldrelsz
argument_list|(
name|abfd
argument_list|)
operator|,
name|relbuf
operator|++
operator|,
name|prelocs
operator|++
control|)
block|{
name|struct
name|internal_ldrel
name|ldrel
decl_stmt|;
name|bfd_xcoff_swap_ldrel_in
argument_list|(
name|abfd
argument_list|,
name|elrel
argument_list|,
operator|&
name|ldrel
argument_list|)
expr_stmt|;
if|if
condition|(
name|ldrel
operator|.
name|l_symndx
operator|>=
literal|3
condition|)
name|relbuf
operator|->
name|sym_ptr_ptr
operator|=
name|syms
operator|+
operator|(
name|ldrel
operator|.
name|l_symndx
operator|-
literal|3
operator|)
expr_stmt|;
else|else
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
switch|switch
condition|(
name|ldrel
operator|.
name|l_symndx
condition|)
block|{
case|case
literal|0
case|:
name|name
operator|=
literal|".text"
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|name
operator|=
literal|".data"
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|name
operator|=
literal|".bss"
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|relbuf
operator|->
name|sym_ptr_ptr
operator|=
name|sec
operator|->
name|symbol_ptr_ptr
expr_stmt|;
block|}
name|relbuf
operator|->
name|address
operator|=
name|ldrel
operator|.
name|l_vaddr
expr_stmt|;
name|relbuf
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
comment|/* Most dynamic relocs have the same type.  FIXME: This is only 	 correct if ldrel.l_rtype == 0.  In other cases, we should use 	 a different howto.  */
name|relbuf
operator|->
name|howto
operator|=
name|bfd_xcoff_dynamic_reloc_howto
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* FIXME: We have no way to record the l_rsecnm field.  */
operator|*
name|prelocs
operator|=
name|relbuf
expr_stmt|;
block|}
operator|*
name|prelocs
operator|=
name|NULL
expr_stmt|;
return|return
name|ldhdr
operator|.
name|l_nreloc
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Routine to create an entry in an XCOFF link hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|xcoff_link_hash_newfunc
parameter_list|(
name|entry
parameter_list|,
name|table
parameter_list|,
name|string
parameter_list|)
name|struct
name|bfd_hash_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|bfd_hash_table
modifier|*
name|table
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|struct
name|xcoff_link_hash_entry
modifier|*
name|ret
init|=
operator|(
expr|struct
name|xcoff_link_hash_entry
operator|*
operator|)
name|entry
decl_stmt|;
comment|/* Allocate the structure if it has not already been allocated by a      subclass.  */
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|xcoff_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
name|ret
operator|=
operator|(
operator|(
expr|struct
name|xcoff_link_hash_entry
operator|*
operator|)
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|xcoff_link_hash_entry
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|xcoff_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
comment|/* Call the allocation method of the superclass.  */
name|ret
operator|=
operator|(
operator|(
expr|struct
name|xcoff_link_hash_entry
operator|*
operator|)
name|_bfd_link_hash_newfunc
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|NULL
condition|)
block|{
comment|/* Set local fields.  */
name|ret
operator|->
name|indx
operator|=
operator|-
literal|1
expr_stmt|;
name|ret
operator|->
name|toc_section
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|u
operator|.
name|toc_indx
operator|=
operator|-
literal|1
expr_stmt|;
name|ret
operator|->
name|descriptor
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|ldsym
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|ldindx
operator|=
operator|-
literal|1
expr_stmt|;
name|ret
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|smclas
operator|=
name|XMC_UA
expr_stmt|;
block|}
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Create a XCOFF link hash table.  */
end_comment

begin_function
name|struct
name|bfd_link_hash_table
modifier|*
name|_bfd_xcoff_bfd_link_hash_table_create
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|xcoff_link_hash_table
modifier|*
name|ret
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|xcoff_link_hash_table
argument_list|)
decl_stmt|;
name|ret
operator|=
operator|(
expr|struct
name|xcoff_link_hash_table
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|xcoff_link_hash_table
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
expr|struct
name|bfd_link_hash_table
operator|*
operator|)
name|NULL
return|;
if|if
condition|(
operator|!
name|_bfd_link_hash_table_init
argument_list|(
operator|&
name|ret
operator|->
name|root
argument_list|,
name|abfd
argument_list|,
name|xcoff_link_hash_newfunc
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|bfd_link_hash_table
operator|*
operator|)
name|NULL
return|;
block|}
name|ret
operator|->
name|debug_strtab
operator|=
name|_bfd_xcoff_stringtab_init
argument_list|()
expr_stmt|;
name|ret
operator|->
name|debug_section
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|loader_section
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|ldrel_count
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ret
operator|->
name|ldhdr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|internal_ldhdr
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|->
name|linkage_section
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|toc_section
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|descriptor_section
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|imports
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|file_align
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|textro
operator|=
name|FALSE
expr_stmt|;
name|ret
operator|->
name|gc
operator|=
name|FALSE
expr_stmt|;
name|memset
argument_list|(
name|ret
operator|->
name|special_sections
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ret
operator|->
name|special_sections
argument_list|)
expr_stmt|;
comment|/* The linker will always generate a full a.out header.  We need to      record that fact now, before the sizeof_headers routine could be      called.  */
name|xcoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|full_aouthdr
operator|=
name|TRUE
expr_stmt|;
return|return
operator|&
name|ret
operator|->
name|root
return|;
block|}
end_function

begin_comment
comment|/* Free a XCOFF link hash table.  */
end_comment

begin_function
name|void
name|_bfd_xcoff_bfd_link_hash_table_free
parameter_list|(
name|hash
parameter_list|)
name|struct
name|bfd_link_hash_table
modifier|*
name|hash
decl_stmt|;
block|{
name|struct
name|xcoff_link_hash_table
modifier|*
name|ret
init|=
operator|(
expr|struct
name|xcoff_link_hash_table
operator|*
operator|)
name|hash
decl_stmt|;
name|_bfd_stringtab_free
argument_list|(
name|ret
operator|->
name|debug_strtab
argument_list|)
expr_stmt|;
name|bfd_hash_table_free
argument_list|(
operator|&
name|ret
operator|->
name|root
operator|.
name|table
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read internal relocs for an XCOFF csect.  This is a wrapper around    _bfd_coff_read_internal_relocs which tries to take advantage of any    relocs which may have been cached for the enclosing section.  */
end_comment

begin_function
specifier|static
name|struct
name|internal_reloc
modifier|*
name|xcoff_read_internal_relocs
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|cache
parameter_list|,
name|external_relocs
parameter_list|,
name|require_internal
parameter_list|,
name|internal_relocs
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_boolean
name|cache
decl_stmt|;
name|bfd_byte
modifier|*
name|external_relocs
decl_stmt|;
name|bfd_boolean
name|require_internal
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|internal_relocs
decl_stmt|;
block|{
if|if
condition|(
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|!=
name|NULL
operator|&&
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|->
name|relocs
operator|==
name|NULL
operator|&&
name|xcoff_section_data
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|asection
modifier|*
name|enclosing
decl_stmt|;
name|enclosing
operator|=
name|xcoff_section_data
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|->
name|enclosing
expr_stmt|;
if|if
condition|(
name|enclosing
operator|!=
name|NULL
operator|&&
operator|(
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|enclosing
argument_list|)
operator|==
name|NULL
operator|||
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|enclosing
argument_list|)
operator|->
name|relocs
operator|==
name|NULL
operator|)
operator|&&
name|cache
operator|&&
name|enclosing
operator|->
name|reloc_count
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|_bfd_coff_read_internal_relocs
argument_list|(
name|abfd
argument_list|,
name|enclosing
argument_list|,
name|TRUE
argument_list|,
name|external_relocs
argument_list|,
name|FALSE
argument_list|,
operator|(
expr|struct
name|internal_reloc
operator|*
operator|)
name|NULL
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|enclosing
operator|!=
name|NULL
operator|&&
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|enclosing
argument_list|)
operator|!=
name|NULL
operator|&&
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|enclosing
argument_list|)
operator|->
name|relocs
operator|!=
name|NULL
condition|)
block|{
name|size_t
name|off
decl_stmt|;
name|off
operator|=
operator|(
operator|(
name|sec
operator|->
name|rel_filepos
operator|-
name|enclosing
operator|->
name|rel_filepos
operator|)
operator|/
name|bfd_coff_relsz
argument_list|(
name|abfd
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|require_internal
condition|)
return|return
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|enclosing
argument_list|)
operator|->
name|relocs
operator|+
name|off
return|;
name|memcpy
argument_list|(
name|internal_relocs
argument_list|,
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|enclosing
argument_list|)
operator|->
name|relocs
operator|+
name|off
argument_list|,
name|sec
operator|->
name|reloc_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|internal_reloc
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|internal_relocs
return|;
block|}
block|}
return|return
name|_bfd_coff_read_internal_relocs
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|cache
argument_list|,
name|external_relocs
argument_list|,
name|require_internal
argument_list|,
name|internal_relocs
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given an XCOFF BFD, add symbols to the global hash table as    appropriate.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_xcoff_bfd_link_add_symbols
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
switch|switch
condition|(
name|bfd_get_format
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
case|case
name|bfd_object
case|:
return|return
name|xcoff_link_add_object_symbols
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
return|;
case|case
name|bfd_archive
case|:
comment|/* If the archive has a map, do the usual search.  We then need 	 to check the archive for dynamic objects, because they may not 	 appear in the archive map even though they should, perhaps, be 	 included.  If the archive has no map, we just consider each object 	 file in turn, since that apparently is what the AIX native linker 	 does.  */
if|if
condition|(
name|bfd_has_map
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|_bfd_generic_link_add_archive_symbols
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|xcoff_link_check_archive_element
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
block|}
block|{
name|bfd
modifier|*
name|member
decl_stmt|;
name|member
operator|=
name|bfd_openr_next_archived_file
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
name|member
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|bfd_check_format
argument_list|(
name|member
argument_list|,
name|bfd_object
argument_list|)
operator|&&
operator|(
name|info
operator|->
name|hash
operator|->
name|creator
operator|==
name|member
operator|->
name|xvec
operator|)
operator|&&
operator|(
operator|!
name|bfd_has_map
argument_list|(
name|abfd
argument_list|)
operator|||
operator|(
name|member
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|bfd_boolean
name|needed
decl_stmt|;
if|if
condition|(
operator|!
name|xcoff_link_check_archive_element
argument_list|(
name|member
argument_list|,
name|info
argument_list|,
operator|&
name|needed
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|needed
condition|)
name|member
operator|->
name|archive_pass
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|member
operator|=
name|bfd_openr_next_archived_file
argument_list|(
name|abfd
argument_list|,
name|member
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
default|default:
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
end_function

begin_comment
comment|/* Add symbols from an XCOFF object file.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|xcoff_link_add_object_symbols
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|_bfd_coff_get_external_symbols
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|xcoff_link_add_symbols
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|info
operator|->
name|keep_memory
condition|)
block|{
if|if
condition|(
operator|!
name|_bfd_coff_free_symbols
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Check a single archive element to see if we need to include it in    the link.  *PNEEDED is set according to whether this element is    needed in the link or not.  This is called via    _bfd_generic_link_add_archive_symbols.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|xcoff_link_check_archive_element
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|pneeded
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd_boolean
modifier|*
name|pneeded
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|_bfd_coff_get_external_symbols
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|xcoff_link_check_ar_symbols
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|pneeded
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|*
name|pneeded
condition|)
block|{
if|if
condition|(
operator|!
name|xcoff_link_add_symbols
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|info
operator|->
name|keep_memory
operator|||
operator|!
operator|*
name|pneeded
condition|)
block|{
if|if
condition|(
operator|!
name|_bfd_coff_free_symbols
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Look through the symbols to see if this object file should be    included in the link.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|xcoff_link_check_ar_symbols
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|pneeded
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd_boolean
modifier|*
name|pneeded
decl_stmt|;
block|{
name|bfd_size_type
name|symesz
decl_stmt|;
name|bfd_byte
modifier|*
name|esym
decl_stmt|;
name|bfd_byte
modifier|*
name|esym_end
decl_stmt|;
operator|*
name|pneeded
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|info
operator|->
name|static_link
operator|&&
name|info
operator|->
name|hash
operator|->
name|creator
operator|==
name|abfd
operator|->
name|xvec
condition|)
return|return
name|xcoff_link_check_dynamic_ar_symbols
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|pneeded
argument_list|)
return|;
name|symesz
operator|=
name|bfd_coff_symesz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|esym
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|obj_coff_external_syms
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|esym_end
operator|=
name|esym
operator|+
name|obj_raw_syment_count
argument_list|(
name|abfd
argument_list|)
operator|*
name|symesz
expr_stmt|;
while|while
condition|(
name|esym
operator|<
name|esym_end
condition|)
block|{
name|struct
name|internal_syment
name|sym
decl_stmt|;
name|bfd_coff_swap_sym_in
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|esym
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|.
name|n_sclass
operator|==
name|C_EXT
operator|&&
name|sym
operator|.
name|n_scnum
operator|!=
name|N_UNDEF
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|buf
index|[
name|SYMNMLEN
operator|+
literal|1
index|]
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
comment|/* This symbol is externally visible, and is defined by this 	     object file.  */
name|name
operator|=
name|_bfd_coff_internal_syment_name
argument_list|(
name|abfd
argument_list|,
operator|&
name|sym
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|h
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|info
operator|->
name|hash
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* We are only interested in symbols that are currently 	     undefined.  If a symbol is currently known to be common, 	     XCOFF linkers do not bring in an object file which 	     defines it.  We also don't bring in symbols to satisfy 	     undefined references in shared objects.  */
if|if
condition|(
name|h
operator|!=
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|)
name|NULL
operator|&&
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_undefined
operator|&&
operator|(
name|info
operator|->
name|hash
operator|->
name|creator
operator|!=
name|abfd
operator|->
name|xvec
operator|||
operator|(
operator|(
operator|(
expr|struct
name|xcoff_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|flags
operator|&
name|XCOFF_DEF_DYNAMIC
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|!
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|add_archive_element
call|)
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|FALSE
return|;
operator|*
name|pneeded
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
name|esym
operator|+=
operator|(
name|sym
operator|.
name|n_numaux
operator|+
literal|1
operator|)
operator|*
name|symesz
expr_stmt|;
block|}
comment|/* We do not need this object file.  */
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Look through the loader symbols to see if this dynamic object    should be included in the link.  The native linker uses the loader    symbols, not the normal symbol table, so we do too.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|xcoff_link_check_dynamic_ar_symbols
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|pneeded
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd_boolean
modifier|*
name|pneeded
decl_stmt|;
block|{
name|asection
modifier|*
name|lsec
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|struct
name|internal_ldhdr
name|ldhdr
decl_stmt|;
specifier|const
name|char
modifier|*
name|strings
decl_stmt|;
name|bfd_byte
modifier|*
name|elsym
decl_stmt|,
modifier|*
name|elsymend
decl_stmt|;
operator|*
name|pneeded
operator|=
name|FALSE
expr_stmt|;
name|lsec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".loader"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lsec
operator|==
name|NULL
condition|)
block|{
comment|/* There are no symbols, so don't try to include it.  */
return|return
name|TRUE
return|;
block|}
if|if
condition|(
operator|!
name|xcoff_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|lsec
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|contents
operator|=
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|lsec
argument_list|)
operator|->
name|contents
expr_stmt|;
name|bfd_xcoff_swap_ldhdr_in
argument_list|(
name|abfd
argument_list|,
name|contents
argument_list|,
operator|&
name|ldhdr
argument_list|)
expr_stmt|;
name|strings
operator|=
operator|(
name|char
operator|*
operator|)
name|contents
operator|+
name|ldhdr
operator|.
name|l_stoff
expr_stmt|;
name|elsym
operator|=
name|contents
operator|+
name|bfd_xcoff_loader_symbol_offset
argument_list|(
name|abfd
argument_list|,
operator|&
name|ldhdr
argument_list|)
expr_stmt|;
name|elsymend
operator|=
name|elsym
operator|+
name|ldhdr
operator|.
name|l_nsyms
operator|*
name|bfd_xcoff_ldsymsz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|elsym
operator|<
name|elsymend
condition|;
name|elsym
operator|+=
name|bfd_xcoff_ldsymsz
argument_list|(
name|abfd
argument_list|)
control|)
block|{
name|struct
name|internal_ldsym
name|ldsym
decl_stmt|;
name|char
name|nambuf
index|[
name|SYMNMLEN
operator|+
literal|1
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|bfd_xcoff_swap_ldsym_in
argument_list|(
name|abfd
argument_list|,
name|elsym
argument_list|,
operator|&
name|ldsym
argument_list|)
expr_stmt|;
comment|/* We are only interested in exported symbols.  */
if|if
condition|(
operator|(
name|ldsym
operator|.
name|l_smtype
operator|&
name|L_EXPORT
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|ldsym
operator|.
name|_l
operator|.
name|_l_l
operator|.
name|_l_zeroes
operator|==
literal|0
condition|)
name|name
operator|=
name|strings
operator|+
name|ldsym
operator|.
name|_l
operator|.
name|_l_l
operator|.
name|_l_offset
expr_stmt|;
else|else
block|{
name|memcpy
argument_list|(
name|nambuf
argument_list|,
name|ldsym
operator|.
name|_l
operator|.
name|_l_name
argument_list|,
name|SYMNMLEN
argument_list|)
expr_stmt|;
name|nambuf
index|[
name|SYMNMLEN
index|]
operator|=
literal|'\0'
expr_stmt|;
name|name
operator|=
name|nambuf
expr_stmt|;
block|}
name|h
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|info
operator|->
name|hash
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* We are only interested in symbols that are currently 	 undefined.  At this point we know that we are using an XCOFF 	 hash table.  */
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_undefined
operator|&&
operator|(
operator|(
operator|(
expr|struct
name|xcoff_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|flags
operator|&
name|XCOFF_DEF_DYNAMIC
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|add_archive_element
call|)
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|FALSE
return|;
operator|*
name|pneeded
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
comment|/* We do not need this shared object.  */
if|if
condition|(
name|contents
operator|!=
name|NULL
operator|&&
operator|!
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|lsec
argument_list|)
operator|->
name|keep_contents
condition|)
block|{
name|free
argument_list|(
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|lsec
argument_list|)
operator|->
name|contents
argument_list|)
expr_stmt|;
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|lsec
argument_list|)
operator|->
name|contents
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Returns the index of reloc in RELOCS with the least address greater    than or equal to ADDRESS.  The relocs are sorted by address.  */
end_comment

begin_function
specifier|static
name|bfd_size_type
name|xcoff_find_reloc
parameter_list|(
name|relocs
parameter_list|,
name|count
parameter_list|,
name|address
parameter_list|)
name|struct
name|internal_reloc
modifier|*
name|relocs
decl_stmt|;
name|bfd_size_type
name|count
decl_stmt|;
name|bfd_vma
name|address
decl_stmt|;
block|{
name|bfd_size_type
name|min
decl_stmt|,
name|max
decl_stmt|,
name|this
decl_stmt|;
if|if
condition|(
name|count
operator|<
literal|2
condition|)
block|{
if|if
condition|(
name|count
operator|==
literal|1
operator|&&
name|relocs
index|[
literal|0
index|]
operator|.
name|r_vaddr
operator|<
name|address
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
name|min
operator|=
literal|0
expr_stmt|;
name|max
operator|=
name|count
expr_stmt|;
comment|/* Do a binary search over (min,max].  */
while|while
condition|(
name|min
operator|+
literal|1
operator|<
name|max
condition|)
block|{
name|bfd_vma
name|raddr
decl_stmt|;
name|this
operator|=
operator|(
name|max
operator|+
name|min
operator|)
operator|/
literal|2
expr_stmt|;
name|raddr
operator|=
name|relocs
index|[
name|this
index|]
operator|.
name|r_vaddr
expr_stmt|;
if|if
condition|(
name|raddr
operator|>
name|address
condition|)
name|max
operator|=
name|this
expr_stmt|;
elseif|else
if|if
condition|(
name|raddr
operator|<
name|address
condition|)
name|min
operator|=
name|this
expr_stmt|;
else|else
block|{
name|min
operator|=
name|this
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|relocs
index|[
name|min
index|]
operator|.
name|r_vaddr
operator|<
name|address
condition|)
return|return
name|min
operator|+
literal|1
return|;
while|while
condition|(
name|min
operator|>
literal|0
operator|&&
name|relocs
index|[
name|min
operator|-
literal|1
index|]
operator|.
name|r_vaddr
operator|==
name|address
condition|)
operator|--
name|min
expr_stmt|;
return|return
name|min
return|;
block|}
end_function

begin_comment
comment|/* xcoff_link_create_extra_sections     Takes care of creating the .loader, .gl, .ds, .debug and sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|xcoff_link_create_extra_sections
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|bfd_boolean
name|return_value
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|hash
operator|->
name|creator
operator|==
name|abfd
operator|->
name|xvec
condition|)
block|{
comment|/* We need to build a .loader section, so we do it here.  This 	 won't work if we're producing an XCOFF output file with no 	 XCOFF input files.  FIXME.  */
if|if
condition|(
name|xcoff_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|loader_section
operator|==
name|NULL
condition|)
block|{
name|asection
modifier|*
name|lsec
decl_stmt|;
name|lsec
operator|=
name|bfd_make_section_anyway
argument_list|(
name|abfd
argument_list|,
literal|".loader"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lsec
operator|==
name|NULL
condition|)
block|{
goto|goto
name|end_return
goto|;
block|}
name|xcoff_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|loader_section
operator|=
name|lsec
expr_stmt|;
name|lsec
operator|->
name|flags
operator||=
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
expr_stmt|;
block|}
comment|/* Likewise for the linkage section.  */
if|if
condition|(
name|xcoff_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|linkage_section
operator|==
name|NULL
condition|)
block|{
name|asection
modifier|*
name|lsec
decl_stmt|;
name|lsec
operator|=
name|bfd_make_section_anyway
argument_list|(
name|abfd
argument_list|,
literal|".gl"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lsec
operator|==
name|NULL
condition|)
block|{
goto|goto
name|end_return
goto|;
block|}
name|xcoff_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|linkage_section
operator|=
name|lsec
expr_stmt|;
name|lsec
operator|->
name|flags
operator||=
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator|)
expr_stmt|;
name|lsec
operator|->
name|alignment_power
operator|=
literal|2
expr_stmt|;
block|}
comment|/* Likewise for the TOC section.  */
if|if
condition|(
name|xcoff_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|toc_section
operator|==
name|NULL
condition|)
block|{
name|asection
modifier|*
name|tsec
decl_stmt|;
name|tsec
operator|=
name|bfd_make_section_anyway
argument_list|(
name|abfd
argument_list|,
literal|".tc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tsec
operator|==
name|NULL
condition|)
block|{
goto|goto
name|end_return
goto|;
block|}
name|xcoff_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|toc_section
operator|=
name|tsec
expr_stmt|;
name|tsec
operator|->
name|flags
operator||=
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator|)
expr_stmt|;
name|tsec
operator|->
name|alignment_power
operator|=
literal|2
expr_stmt|;
block|}
comment|/* Likewise for the descriptor section.  */
if|if
condition|(
name|xcoff_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|descriptor_section
operator|==
name|NULL
condition|)
block|{
name|asection
modifier|*
name|dsec
decl_stmt|;
name|dsec
operator|=
name|bfd_make_section_anyway
argument_list|(
name|abfd
argument_list|,
literal|".ds"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsec
operator|==
name|NULL
condition|)
block|{
goto|goto
name|end_return
goto|;
block|}
name|xcoff_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|descriptor_section
operator|=
name|dsec
expr_stmt|;
name|dsec
operator|->
name|flags
operator||=
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator|)
expr_stmt|;
name|dsec
operator|->
name|alignment_power
operator|=
literal|2
expr_stmt|;
block|}
comment|/* Likewise for the .debug section.  */
if|if
condition|(
name|xcoff_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|debug_section
operator|==
name|NULL
operator|&&
name|info
operator|->
name|strip
operator|!=
name|strip_all
condition|)
block|{
name|asection
modifier|*
name|dsec
decl_stmt|;
name|dsec
operator|=
name|bfd_make_section_anyway
argument_list|(
name|abfd
argument_list|,
literal|".debug"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsec
operator|==
name|NULL
condition|)
block|{
goto|goto
name|end_return
goto|;
block|}
name|xcoff_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|debug_section
operator|=
name|dsec
expr_stmt|;
name|dsec
operator|->
name|flags
operator||=
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
expr_stmt|;
block|}
block|}
name|return_value
operator|=
name|TRUE
expr_stmt|;
name|end_return
label|:
return|return
name|return_value
return|;
block|}
end_function

begin_comment
comment|/* Add all the symbols from an object file to the hash table.     XCOFF is a weird format.  A normal XCOFF .o files will have three    COFF sections--.text, .data, and .bss--but each COFF section will    contain many csects.  These csects are described in the symbol    table.  From the linker's point of view, each csect must be    considered a section in its own right.  For example, a TOC entry is    handled as a small XMC_TC csect.  The linker must be able to merge    different TOC entries together, which means that it must be able to    extract the XMC_TC csects from the .data section of the input .o    file.     From the point of view of our linker, this is, of course, a hideous    nightmare.  We cope by actually creating sections for each csect,    and discarding the original sections.  We then have to handle the    relocation entries carefully, since the only way to tell which    csect they belong to is to examine the address.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|xcoff_link_add_symbols
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|unsigned
name|int
name|n_tmask
decl_stmt|;
name|unsigned
name|int
name|n_btshft
decl_stmt|;
name|bfd_boolean
name|default_copy
decl_stmt|;
name|bfd_size_type
name|symcount
decl_stmt|;
name|struct
name|xcoff_link_hash_entry
modifier|*
modifier|*
name|sym_hash
decl_stmt|;
name|asection
modifier|*
modifier|*
name|csect_cache
decl_stmt|;
name|bfd_size_type
name|linesz
decl_stmt|;
name|asection
modifier|*
name|o
decl_stmt|;
name|asection
modifier|*
name|last_real
decl_stmt|;
name|bfd_boolean
name|keep_syms
decl_stmt|;
name|asection
modifier|*
name|csect
decl_stmt|;
name|unsigned
name|int
name|csect_index
decl_stmt|;
name|asection
modifier|*
name|first_csect
decl_stmt|;
name|bfd_size_type
name|symesz
decl_stmt|;
name|bfd_byte
modifier|*
name|esym
decl_stmt|;
name|bfd_byte
modifier|*
name|esym_end
decl_stmt|;
struct|struct
name|reloc_info_struct
block|{
name|struct
name|internal_reloc
modifier|*
name|relocs
decl_stmt|;
name|asection
modifier|*
modifier|*
name|csects
decl_stmt|;
name|bfd_byte
modifier|*
name|linenos
decl_stmt|;
block|}
modifier|*
name|reloc_info
init|=
name|NULL
struct|;
name|bfd_size_type
name|amt
decl_stmt|;
name|keep_syms
operator|=
name|obj_coff_keep_syms
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|info
operator|->
name|static_link
condition|)
block|{
if|if
condition|(
operator|!
name|xcoff_link_add_dynamic_symbols
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* create the loader, toc, gl, ds and debug sections, if needed */
if|if
condition|(
operator|!
name|xcoff_link_create_extra_sections
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|info
operator|->
name|static_link
condition|)
return|return
name|TRUE
return|;
name|n_tmask
operator|=
name|coff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|local_n_tmask
expr_stmt|;
name|n_btshft
operator|=
name|coff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|local_n_btshft
expr_stmt|;
comment|/* Define macros so that ISFCN, et. al., macros work correctly.  */
define|#
directive|define
name|N_TMASK
value|n_tmask
define|#
directive|define
name|N_BTSHFT
value|n_btshft
if|if
condition|(
name|info
operator|->
name|keep_memory
condition|)
name|default_copy
operator|=
name|FALSE
expr_stmt|;
else|else
name|default_copy
operator|=
name|TRUE
expr_stmt|;
name|symcount
operator|=
name|obj_raw_syment_count
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* We keep a list of the linker hash table entries that correspond      to each external symbol.  */
name|amt
operator|=
name|symcount
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|xcoff_link_hash_entry
operator|*
argument_list|)
expr_stmt|;
name|sym_hash
operator|=
operator|(
expr|struct
name|xcoff_link_hash_entry
operator|*
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_hash
operator|==
name|NULL
operator|&&
name|symcount
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
name|coff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|sym_hashes
operator|=
operator|(
expr|struct
name|coff_link_hash_entry
operator|*
operator|*
operator|)
name|sym_hash
expr_stmt|;
comment|/* Because of the weird stuff we are doing with XCOFF csects, we can      not easily determine which section a symbol is in, so we store      the information in the tdata for the input file.  */
name|amt
operator|=
name|symcount
operator|*
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
expr_stmt|;
name|csect_cache
operator|=
operator|(
name|asection
operator|*
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|csect_cache
operator|==
name|NULL
operator|&&
name|symcount
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
name|xcoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|csects
operator|=
name|csect_cache
expr_stmt|;
comment|/* While splitting sections into csects, we need to assign the      relocs correctly.  The relocs and the csects must both be in      order by VMA within a given section, so we handle this by      scanning along the relocs as we process the csects.  We index      into reloc_info using the section target_index.  */
name|amt
operator|=
name|abfd
operator|->
name|section_count
operator|+
literal|1
expr_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
expr|struct
name|reloc_info_struct
argument_list|)
expr_stmt|;
name|reloc_info
operator|=
operator|(
expr|struct
name|reloc_info_struct
operator|*
operator|)
name|bfd_zmalloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc_info
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
comment|/* Read in the relocs and line numbers for each section.  */
name|linesz
operator|=
name|bfd_coff_linesz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|last_real
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
name|last_real
operator|=
name|o
expr_stmt|;
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|!=
literal|0
condition|)
block|{
name|reloc_info
index|[
name|o
operator|->
name|target_index
index|]
operator|.
name|relocs
operator|=
name|xcoff_read_internal_relocs
argument_list|(
name|abfd
argument_list|,
name|o
argument_list|,
name|TRUE
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|NULL
argument_list|,
name|FALSE
argument_list|,
operator|(
expr|struct
name|internal_reloc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|amt
operator|=
name|o
operator|->
name|reloc_count
expr_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
expr_stmt|;
name|reloc_info
index|[
name|o
operator|->
name|target_index
index|]
operator|.
name|csects
operator|=
operator|(
name|asection
operator|*
operator|*
operator|)
name|bfd_zmalloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc_info
index|[
name|o
operator|->
name|target_index
index|]
operator|.
name|csects
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
block|}
if|if
condition|(
operator|(
name|info
operator|->
name|strip
operator|==
name|strip_none
operator|||
name|info
operator|->
name|strip
operator|==
name|strip_some
operator|)
operator|&&
name|o
operator|->
name|lineno_count
operator|>
literal|0
condition|)
block|{
name|bfd_byte
modifier|*
name|linenos
decl_stmt|;
name|amt
operator|=
name|linesz
operator|*
name|o
operator|->
name|lineno_count
expr_stmt|;
name|linenos
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|linenos
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|reloc_info
index|[
name|o
operator|->
name|target_index
index|]
operator|.
name|linenos
operator|=
name|linenos
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|o
operator|->
name|line_filepos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bread
argument_list|(
name|linenos
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
goto|goto
name|error_return
goto|;
block|}
block|}
comment|/* Don't let the linker relocation routines discard the symbols.  */
name|obj_coff_keep_syms
argument_list|(
name|abfd
argument_list|)
operator|=
name|TRUE
expr_stmt|;
name|csect
operator|=
name|NULL
expr_stmt|;
name|csect_index
operator|=
literal|0
expr_stmt|;
name|first_csect
operator|=
name|NULL
expr_stmt|;
name|symesz
operator|=
name|bfd_coff_symesz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|symesz
operator|==
name|bfd_coff_auxesz
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|esym
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|obj_coff_external_syms
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|esym_end
operator|=
name|esym
operator|+
name|symcount
operator|*
name|symesz
expr_stmt|;
while|while
condition|(
name|esym
operator|<
name|esym_end
condition|)
block|{
name|struct
name|internal_syment
name|sym
decl_stmt|;
name|union
name|internal_auxent
name|aux
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|buf
index|[
name|SYMNMLEN
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|smtyp
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
name|struct
name|xcoff_link_hash_entry
modifier|*
name|set_toc
decl_stmt|;
name|bfd_coff_swap_sym_in
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|esym
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|sym
argument_list|)
expr_stmt|;
comment|/* In this pass we are only interested in symbols with csect 	 information.  */
if|if
condition|(
name|sym
operator|.
name|n_sclass
operator|!=
name|C_EXT
operator|&&
name|sym
operator|.
name|n_sclass
operator|!=
name|C_HIDEXT
condition|)
block|{
comment|/* Set csect_cache, 	     Normally csect is a .pr, .rw  etc. created in the loop 	     If C_FILE or first time, handle special  	     Advance esym, sym_hash, csect_hash ptr's 	     Keep track of the last_symndx for the current file.  */
if|if
condition|(
name|sym
operator|.
name|n_sclass
operator|==
name|C_FILE
operator|&&
name|csect
operator|!=
name|NULL
condition|)
block|{
name|xcoff_section_data
argument_list|(
name|abfd
argument_list|,
name|csect
argument_list|)
operator|->
name|last_symndx
operator|=
operator|(
operator|(
name|esym
operator|-
operator|(
name|bfd_byte
operator|*
operator|)
name|obj_coff_external_syms
argument_list|(
name|abfd
argument_list|)
operator|)
operator|/
name|symesz
operator|)
expr_stmt|;
name|csect
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|csect
operator|!=
name|NULL
condition|)
operator|*
name|csect_cache
operator|=
name|csect
expr_stmt|;
elseif|else
if|if
condition|(
name|first_csect
operator|==
name|NULL
operator|||
name|sym
operator|.
name|n_sclass
operator|==
name|C_FILE
condition|)
operator|*
name|csect_cache
operator|=
name|coff_section_from_bfd_index
argument_list|(
name|abfd
argument_list|,
name|sym
operator|.
name|n_scnum
argument_list|)
expr_stmt|;
else|else
operator|*
name|csect_cache
operator|=
name|NULL
expr_stmt|;
name|esym
operator|+=
operator|(
name|sym
operator|.
name|n_numaux
operator|+
literal|1
operator|)
operator|*
name|symesz
expr_stmt|;
name|sym_hash
operator|+=
name|sym
operator|.
name|n_numaux
operator|+
literal|1
expr_stmt|;
name|csect_cache
operator|+=
name|sym
operator|.
name|n_numaux
operator|+
literal|1
expr_stmt|;
continue|continue;
block|}
name|name
operator|=
name|_bfd_coff_internal_syment_name
argument_list|(
name|abfd
argument_list|,
operator|&
name|sym
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
comment|/* If this symbol has line number information attached to it, 	 and we're not stripping it, count the number of entries and 	 add them to the count for this csect.  In the final link pass 	 we are going to attach line number information by symbol, 	 rather than by section, in order to more easily handle 	 garbage collection.  */
if|if
condition|(
operator|(
name|info
operator|->
name|strip
operator|==
name|strip_none
operator|||
name|info
operator|->
name|strip
operator|==
name|strip_some
operator|)
operator|&&
name|sym
operator|.
name|n_numaux
operator|>
literal|1
operator|&&
name|csect
operator|!=
name|NULL
operator|&&
name|ISFCN
argument_list|(
name|sym
operator|.
name|n_type
argument_list|)
condition|)
block|{
name|union
name|internal_auxent
name|auxlin
decl_stmt|;
name|bfd_coff_swap_aux_in
argument_list|(
name|abfd
argument_list|,
call|(
name|PTR
call|)
argument_list|(
name|esym
operator|+
name|symesz
argument_list|)
argument_list|,
name|sym
operator|.
name|n_type
argument_list|,
name|sym
operator|.
name|n_sclass
argument_list|,
literal|0
argument_list|,
name|sym
operator|.
name|n_numaux
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|auxlin
argument_list|)
expr_stmt|;
if|if
condition|(
name|auxlin
operator|.
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_lnnoptr
operator|!=
literal|0
condition|)
block|{
name|asection
modifier|*
name|enclosing
decl_stmt|;
name|bfd_signed_vma
name|linoff
decl_stmt|;
name|enclosing
operator|=
name|xcoff_section_data
argument_list|(
name|abfd
argument_list|,
name|csect
argument_list|)
operator|->
name|enclosing
expr_stmt|;
if|if
condition|(
name|enclosing
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: `%s' has line numbers but no enclosing section"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|linoff
operator|=
operator|(
name|auxlin
operator|.
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_lnnoptr
operator|-
name|enclosing
operator|->
name|line_filepos
operator|)
expr_stmt|;
comment|/* explicit cast to bfd_signed_vma for compiler */
if|if
condition|(
name|linoff
operator|<
call|(
name|bfd_signed_vma
call|)
argument_list|(
name|enclosing
operator|->
name|lineno_count
operator|*
name|linesz
argument_list|)
condition|)
block|{
name|struct
name|internal_lineno
name|lin
decl_stmt|;
name|bfd_byte
modifier|*
name|linpstart
decl_stmt|;
name|linpstart
operator|=
operator|(
name|reloc_info
index|[
name|enclosing
operator|->
name|target_index
index|]
operator|.
name|linenos
operator|+
name|linoff
operator|)
expr_stmt|;
name|bfd_coff_swap_lineno_in
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|linpstart
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|lin
argument_list|)
expr_stmt|;
if|if
condition|(
name|lin
operator|.
name|l_lnno
operator|==
literal|0
operator|&&
operator|(
operator|(
name|bfd_size_type
operator|)
name|lin
operator|.
name|l_addr
operator|.
name|l_symndx
operator|==
operator|(
operator|(
name|esym
operator|-
operator|(
name|bfd_byte
operator|*
operator|)
name|obj_coff_external_syms
argument_list|(
name|abfd
argument_list|)
operator|)
operator|/
name|symesz
operator|)
operator|)
condition|)
block|{
name|bfd_byte
modifier|*
name|linpend
decl_stmt|,
modifier|*
name|linp
decl_stmt|;
name|linpend
operator|=
operator|(
name|reloc_info
index|[
name|enclosing
operator|->
name|target_index
index|]
operator|.
name|linenos
operator|+
name|enclosing
operator|->
name|lineno_count
operator|*
name|linesz
operator|)
expr_stmt|;
for|for
control|(
name|linp
operator|=
name|linpstart
operator|+
name|linesz
init|;
name|linp
operator|<
name|linpend
condition|;
name|linp
operator|+=
name|linesz
control|)
block|{
name|bfd_coff_swap_lineno_in
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|linp
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|lin
argument_list|)
expr_stmt|;
if|if
condition|(
name|lin
operator|.
name|l_lnno
operator|==
literal|0
condition|)
break|break;
block|}
name|csect
operator|->
name|lineno_count
operator|+=
operator|(
name|linp
operator|-
name|linpstart
operator|)
operator|/
name|linesz
expr_stmt|;
comment|/* The setting of line_filepos will only be 			 useful if all the line number entries for a 			 csect are contiguous; this only matters for 			 error reporting.  */
if|if
condition|(
name|csect
operator|->
name|line_filepos
operator|==
literal|0
condition|)
name|csect
operator|->
name|line_filepos
operator|=
name|auxlin
operator|.
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_lnnoptr
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Pick up the csect auxiliary information.  */
if|if
condition|(
name|sym
operator|.
name|n_numaux
operator|==
literal|0
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: class %d symbol `%s' has no aux entries"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|sym
operator|.
name|n_sclass
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|bfd_coff_swap_aux_in
argument_list|(
name|abfd
argument_list|,
call|(
name|PTR
call|)
argument_list|(
name|esym
operator|+
name|symesz
operator|*
name|sym
operator|.
name|n_numaux
argument_list|)
argument_list|,
name|sym
operator|.
name|n_type
argument_list|,
name|sym
operator|.
name|n_sclass
argument_list|,
name|sym
operator|.
name|n_numaux
operator|-
literal|1
argument_list|,
name|sym
operator|.
name|n_numaux
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|aux
argument_list|)
expr_stmt|;
name|smtyp
operator|=
name|SMTYP_SMTYP
argument_list|(
name|aux
operator|.
name|x_csect
operator|.
name|x_smtyp
argument_list|)
expr_stmt|;
name|flags
operator|=
name|BSF_GLOBAL
expr_stmt|;
name|section
operator|=
name|NULL
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
name|set_toc
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|smtyp
condition|)
block|{
default|default:
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: symbol `%s' has unrecognized csect type %d"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|name
argument_list|,
name|smtyp
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
case|case
name|XTY_ER
case|:
comment|/* This is an external reference.  */
if|if
condition|(
name|sym
operator|.
name|n_sclass
operator|==
name|C_HIDEXT
operator|||
name|sym
operator|.
name|n_scnum
operator|!=
name|N_UNDEF
operator|||
name|aux
operator|.
name|x_csect
operator|.
name|x_scnlen
operator|.
name|l
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: bad XTY_ER symbol `%s': class %d scnum %d scnlen %d"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|name
argument_list|,
name|sym
operator|.
name|n_sclass
argument_list|,
name|sym
operator|.
name|n_scnum
argument_list|,
name|aux
operator|.
name|x_csect
operator|.
name|x_scnlen
operator|.
name|l
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
comment|/* An XMC_XO external reference is actually a reference to 	     an absolute location.  */
if|if
condition|(
name|aux
operator|.
name|x_csect
operator|.
name|x_smclas
operator|!=
name|XMC_XO
condition|)
name|section
operator|=
name|bfd_und_section_ptr
expr_stmt|;
else|else
block|{
name|section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
name|value
operator|=
name|sym
operator|.
name|n_value
expr_stmt|;
block|}
break|break;
case|case
name|XTY_SD
case|:
comment|/* This is a csect definition.  */
if|if
condition|(
name|csect
operator|!=
name|NULL
condition|)
block|{
name|xcoff_section_data
argument_list|(
name|abfd
argument_list|,
name|csect
argument_list|)
operator|->
name|last_symndx
operator|=
operator|(
operator|(
name|esym
operator|-
operator|(
name|bfd_byte
operator|*
operator|)
name|obj_coff_external_syms
argument_list|(
name|abfd
argument_list|)
operator|)
operator|/
name|symesz
operator|)
expr_stmt|;
block|}
name|csect
operator|=
name|NULL
expr_stmt|;
name|csect_index
operator|=
operator|-
operator|(
name|unsigned
operator|)
literal|1
expr_stmt|;
comment|/* When we see a TOC anchor, we record the TOC value.  */
if|if
condition|(
name|aux
operator|.
name|x_csect
operator|.
name|x_smclas
operator|==
name|XMC_TC0
condition|)
block|{
if|if
condition|(
name|sym
operator|.
name|n_sclass
operator|!=
name|C_HIDEXT
operator|||
name|aux
operator|.
name|x_csect
operator|.
name|x_scnlen
operator|.
name|l
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: XMC_TC0 symbol `%s' is class %d scnlen %d"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|name
argument_list|,
name|sym
operator|.
name|n_sclass
argument_list|,
name|aux
operator|.
name|x_csect
operator|.
name|x_scnlen
operator|.
name|l
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|xcoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|toc
operator|=
name|sym
operator|.
name|n_value
expr_stmt|;
block|}
comment|/* We must merge TOC entries for the same symbol.  We can 	     merge two TOC entries if they are both C_HIDEXT, they 	     both have the same name, they are both 4 or 8 bytes long, and 	     they both have a relocation table entry for an external 	     symbol with the same name.  Unfortunately, this means 	     that we must look through the relocations.  Ick.  	     Logic for 32 bit vs 64 bit. 	     32 bit has a csect length of 4 for TOC 	     64 bit has a csect length of 8 for TOC  	     The conditions to get past the if-check are not that bad. 	     They are what is used to create the TOC csects in the first 	     place.  */
if|if
condition|(
name|aux
operator|.
name|x_csect
operator|.
name|x_smclas
operator|==
name|XMC_TC
operator|&&
name|sym
operator|.
name|n_sclass
operator|==
name|C_HIDEXT
operator|&&
name|info
operator|->
name|hash
operator|->
name|creator
operator|==
name|abfd
operator|->
name|xvec
operator|&&
operator|(
operator|(
name|bfd_xcoff_is_xcoff32
argument_list|(
name|abfd
argument_list|)
operator|&&
name|aux
operator|.
name|x_csect
operator|.
name|x_scnlen
operator|.
name|l
operator|==
literal|4
operator|)
operator|||
operator|(
name|bfd_xcoff_is_xcoff64
argument_list|(
name|abfd
argument_list|)
operator|&&
name|aux
operator|.
name|x_csect
operator|.
name|x_scnlen
operator|.
name|l
operator|==
literal|8
operator|)
operator|)
condition|)
block|{
name|asection
modifier|*
name|enclosing
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|relocs
decl_stmt|;
name|bfd_size_type
name|relindx
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|rel
decl_stmt|;
name|enclosing
operator|=
name|coff_section_from_bfd_index
argument_list|(
name|abfd
argument_list|,
name|sym
operator|.
name|n_scnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|enclosing
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|relocs
operator|=
name|reloc_info
index|[
name|enclosing
operator|->
name|target_index
index|]
operator|.
name|relocs
expr_stmt|;
name|amt
operator|=
name|enclosing
operator|->
name|reloc_count
expr_stmt|;
name|relindx
operator|=
name|xcoff_find_reloc
argument_list|(
name|relocs
argument_list|,
name|amt
argument_list|,
name|sym
operator|.
name|n_value
argument_list|)
expr_stmt|;
name|rel
operator|=
name|relocs
operator|+
name|relindx
expr_stmt|;
comment|/* 32 bit R_POS r_size is 31 		 64 bit R_POS r_size is 63  */
if|if
condition|(
name|relindx
operator|<
name|enclosing
operator|->
name|reloc_count
operator|&&
name|rel
operator|->
name|r_vaddr
operator|==
operator|(
name|bfd_vma
operator|)
name|sym
operator|.
name|n_value
operator|&&
name|rel
operator|->
name|r_type
operator|==
name|R_POS
operator|&&
operator|(
operator|(
name|bfd_xcoff_is_xcoff32
argument_list|(
name|abfd
argument_list|)
operator|&&
name|rel
operator|->
name|r_size
operator|==
literal|31
operator|)
operator|||
operator|(
name|bfd_xcoff_is_xcoff64
argument_list|(
name|abfd
argument_list|)
operator|&&
name|rel
operator|->
name|r_size
operator|==
literal|63
operator|)
operator|)
condition|)
block|{
name|bfd_byte
modifier|*
name|erelsym
decl_stmt|;
name|struct
name|internal_syment
name|relsym
decl_stmt|;
name|erelsym
operator|=
operator|(
operator|(
name|bfd_byte
operator|*
operator|)
name|obj_coff_external_syms
argument_list|(
name|abfd
argument_list|)
operator|+
name|rel
operator|->
name|r_symndx
operator|*
name|symesz
operator|)
expr_stmt|;
name|bfd_coff_swap_sym_in
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|erelsym
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|relsym
argument_list|)
expr_stmt|;
if|if
condition|(
name|relsym
operator|.
name|n_sclass
operator|==
name|C_EXT
condition|)
block|{
specifier|const
name|char
modifier|*
name|relname
decl_stmt|;
name|char
name|relbuf
index|[
name|SYMNMLEN
operator|+
literal|1
index|]
decl_stmt|;
name|bfd_boolean
name|copy
decl_stmt|;
name|struct
name|xcoff_link_hash_entry
modifier|*
name|h
decl_stmt|;
comment|/* At this point we know that the TOC entry is 			 for an externally visible symbol.  */
name|relname
operator|=
name|_bfd_coff_internal_syment_name
argument_list|(
name|abfd
argument_list|,
operator|&
name|relsym
argument_list|,
name|relbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|relname
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
comment|/* We only merge TOC entries if the TC name is 			 the same as the symbol name.  This handles 			 the normal case, but not common cases like 			 SYM.P4 which gcc generates to store SYM + 4 			 in the TOC.  FIXME.  */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|relname
argument_list|)
operator|==
literal|0
condition|)
block|{
name|copy
operator|=
operator|(
operator|!
name|info
operator|->
name|keep_memory
operator|||
name|relsym
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_zeroes
operator|!=
literal|0
operator|||
name|relsym
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
operator|==
literal|0
operator|)
expr_stmt|;
name|h
operator|=
name|xcoff_link_hash_lookup
argument_list|(
name|xcoff_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|relname
argument_list|,
name|TRUE
argument_list|,
name|copy
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
comment|/* At this point h->root.type could be 			     bfd_link_hash_new.  That should be OK, 			     since we know for sure that we will come 			     across this symbol as we step through the 			     file.  */
comment|/* We store h in *sym_hash for the 			     convenience of the relocate_section 			     function.  */
operator|*
name|sym_hash
operator|=
name|h
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|toc_section
operator|!=
name|NULL
condition|)
block|{
name|asection
modifier|*
modifier|*
name|rel_csects
decl_stmt|;
comment|/* We already have a TOC entry for this 				 symbol, so we can just ignore this 				 one.  */
name|rel_csects
operator|=
name|reloc_info
index|[
name|enclosing
operator|->
name|target_index
index|]
operator|.
name|csects
expr_stmt|;
name|rel_csects
index|[
name|relindx
index|]
operator|=
name|bfd_und_section_ptr
expr_stmt|;
break|break;
block|}
comment|/* We are about to create a TOC entry for 			     this symbol.  */
name|set_toc
operator|=
name|h
expr_stmt|;
block|}
comment|/* merge toc reloc */
block|}
comment|/* c_ext */
block|}
comment|/* reloc */
block|}
comment|/* merge toc */
block|{
name|asection
modifier|*
name|enclosing
decl_stmt|;
comment|/* We need to create a new section.  We get the name from 	       the csect storage mapping class, so that the linker can 	       accumulate similar csects together.  */
name|csect
operator|=
name|bfd_xcoff_create_csect_from_smclas
argument_list|(
name|abfd
argument_list|,
operator|&
name|aux
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|csect
condition|)
block|{
goto|goto
name|error_return
goto|;
block|}
comment|/* The enclosing section is the main section : .data, .text 	       or .bss that the csect is coming from.  */
name|enclosing
operator|=
name|coff_section_from_bfd_index
argument_list|(
name|abfd
argument_list|,
name|sym
operator|.
name|n_scnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|enclosing
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|bfd_is_abs_section
argument_list|(
name|enclosing
argument_list|)
operator|&&
operator|(
operator|(
name|bfd_vma
operator|)
name|sym
operator|.
name|n_value
operator|<
name|enclosing
operator|->
name|vma
operator|||
operator|(
operator|(
name|bfd_vma
operator|)
name|sym
operator|.
name|n_value
operator|+
name|aux
operator|.
name|x_csect
operator|.
name|x_scnlen
operator|.
name|l
operator|>
name|enclosing
operator|->
name|vma
operator|+
name|enclosing
operator|->
name|_raw_size
operator|)
operator|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: csect `%s' not in enclosing section"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|csect
operator|->
name|vma
operator|=
name|sym
operator|.
name|n_value
expr_stmt|;
name|csect
operator|->
name|filepos
operator|=
operator|(
name|enclosing
operator|->
name|filepos
operator|+
name|sym
operator|.
name|n_value
operator|-
name|enclosing
operator|->
name|vma
operator|)
expr_stmt|;
name|csect
operator|->
name|_raw_size
operator|=
name|aux
operator|.
name|x_csect
operator|.
name|x_scnlen
operator|.
name|l
expr_stmt|;
name|csect
operator|->
name|flags
operator||=
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
expr_stmt|;
name|csect
operator|->
name|alignment_power
operator|=
name|SMTYP_ALIGN
argument_list|(
name|aux
operator|.
name|x_csect
operator|.
name|x_smtyp
argument_list|)
expr_stmt|;
comment|/* Record the enclosing section in the tdata for this new 	       section.  */
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|coff_section_tdata
argument_list|)
expr_stmt|;
name|csect
operator|->
name|used_by_bfd
operator|=
operator|(
name|PTR
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|csect
operator|->
name|used_by_bfd
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|xcoff_section_tdata
argument_list|)
expr_stmt|;
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|csect
argument_list|)
operator|->
name|tdata
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|csect
argument_list|)
operator|->
name|tdata
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|xcoff_section_data
argument_list|(
name|abfd
argument_list|,
name|csect
argument_list|)
operator|->
name|enclosing
operator|=
name|enclosing
expr_stmt|;
name|xcoff_section_data
argument_list|(
name|abfd
argument_list|,
name|csect
argument_list|)
operator|->
name|lineno_count
operator|=
name|enclosing
operator|->
name|lineno_count
expr_stmt|;
if|if
condition|(
name|enclosing
operator|->
name|owner
operator|==
name|abfd
condition|)
block|{
name|struct
name|internal_reloc
modifier|*
name|relocs
decl_stmt|;
name|bfd_size_type
name|relindx
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|rel
decl_stmt|;
name|asection
modifier|*
modifier|*
name|rel_csect
decl_stmt|;
name|relocs
operator|=
name|reloc_info
index|[
name|enclosing
operator|->
name|target_index
index|]
operator|.
name|relocs
expr_stmt|;
name|amt
operator|=
name|enclosing
operator|->
name|reloc_count
expr_stmt|;
name|relindx
operator|=
name|xcoff_find_reloc
argument_list|(
name|relocs
argument_list|,
name|amt
argument_list|,
name|csect
operator|->
name|vma
argument_list|)
expr_stmt|;
name|rel
operator|=
name|relocs
operator|+
name|relindx
expr_stmt|;
name|rel_csect
operator|=
operator|(
name|reloc_info
index|[
name|enclosing
operator|->
name|target_index
index|]
operator|.
name|csects
operator|+
name|relindx
operator|)
expr_stmt|;
name|csect
operator|->
name|rel_filepos
operator|=
operator|(
name|enclosing
operator|->
name|rel_filepos
operator|+
name|relindx
operator|*
name|bfd_coff_relsz
argument_list|(
name|abfd
argument_list|)
operator|)
expr_stmt|;
while|while
condition|(
name|relindx
operator|<
name|enclosing
operator|->
name|reloc_count
operator|&&
operator|*
name|rel_csect
operator|==
name|NULL
operator|&&
name|rel
operator|->
name|r_vaddr
operator|<
name|csect
operator|->
name|vma
operator|+
name|csect
operator|->
name|_raw_size
condition|)
block|{
operator|*
name|rel_csect
operator|=
name|csect
expr_stmt|;
name|csect
operator|->
name|flags
operator||=
name|SEC_RELOC
expr_stmt|;
operator|++
name|csect
operator|->
name|reloc_count
expr_stmt|;
operator|++
name|relindx
expr_stmt|;
operator|++
name|rel
expr_stmt|;
operator|++
name|rel_csect
expr_stmt|;
block|}
block|}
comment|/* There are a number of other fields and section flags 	       which we do not bother to set.  */
name|csect_index
operator|=
operator|(
operator|(
name|esym
operator|-
operator|(
name|bfd_byte
operator|*
operator|)
name|obj_coff_external_syms
argument_list|(
name|abfd
argument_list|)
operator|)
operator|/
name|symesz
operator|)
expr_stmt|;
name|xcoff_section_data
argument_list|(
name|abfd
argument_list|,
name|csect
argument_list|)
operator|->
name|first_symndx
operator|=
name|csect_index
expr_stmt|;
if|if
condition|(
name|first_csect
operator|==
name|NULL
condition|)
name|first_csect
operator|=
name|csect
expr_stmt|;
comment|/* If this symbol is C_EXT, we treat it as starting at the 	       beginning of the newly created section.  */
if|if
condition|(
name|sym
operator|.
name|n_sclass
operator|==
name|C_EXT
condition|)
block|{
name|section
operator|=
name|csect
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If this is a TOC section for a symbol, record it.  */
if|if
condition|(
name|set_toc
operator|!=
name|NULL
condition|)
name|set_toc
operator|->
name|toc_section
operator|=
name|csect
expr_stmt|;
block|}
break|break;
case|case
name|XTY_LD
case|:
comment|/* This is a label definition.  The x_scnlen field is the 	     symbol index of the csect.  Usually the XTY_LD symbol will 	     follow its appropriate XTY_SD symbol.  The .set pseudo op can 	     cause the XTY_LD to not follow the XTY_SD symbol. */
block|{
name|bfd_boolean
name|bad
decl_stmt|;
name|bad
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|aux
operator|.
name|x_csect
operator|.
name|x_scnlen
operator|.
name|l
operator|<
literal|0
operator|||
operator|(
name|aux
operator|.
name|x_csect
operator|.
name|x_scnlen
operator|.
name|l
operator|>=
name|esym
operator|-
operator|(
name|bfd_byte
operator|*
operator|)
name|obj_coff_external_syms
argument_list|(
name|abfd
argument_list|)
operator|)
condition|)
name|bad
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|bad
condition|)
block|{
name|section
operator|=
name|xcoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|csects
index|[
name|aux
operator|.
name|x_csect
operator|.
name|x_scnlen
operator|.
name|l
index|]
expr_stmt|;
if|if
condition|(
name|section
operator|==
name|NULL
operator|||
operator|(
name|section
operator|->
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|==
literal|0
condition|)
name|bad
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|bad
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: misplaced XTY_LD `%s'"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|csect
operator|=
name|section
expr_stmt|;
name|value
operator|=
name|sym
operator|.
name|n_value
operator|-
name|csect
operator|->
name|vma
expr_stmt|;
block|}
break|break;
case|case
name|XTY_CM
case|:
comment|/* This is an unitialized csect.  We could base the name on 	     the storage mapping class, but we don't bother except for 	     an XMC_TD symbol.  If this csect is externally visible, 	     it is a common symbol.  We put XMC_TD symbols in sections 	     named .tocbss, and rely on the linker script to put that 	     in the TOC area.  */
if|if
condition|(
name|csect
operator|!=
name|NULL
condition|)
block|{
name|xcoff_section_data
argument_list|(
name|abfd
argument_list|,
name|csect
argument_list|)
operator|->
name|last_symndx
operator|=
operator|(
operator|(
name|esym
operator|-
operator|(
name|bfd_byte
operator|*
operator|)
name|obj_coff_external_syms
argument_list|(
name|abfd
argument_list|)
operator|)
operator|/
name|symesz
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|aux
operator|.
name|x_csect
operator|.
name|x_smclas
operator|==
name|XMC_TD
condition|)
block|{
comment|/* The linker script puts the .td section in the data 		 section after the .tc section.  */
name|csect
operator|=
name|bfd_make_section_anyway
argument_list|(
name|abfd
argument_list|,
literal|".td"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|csect
operator|=
name|bfd_make_section_anyway
argument_list|(
name|abfd
argument_list|,
literal|".bss"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|csect
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|csect
operator|->
name|vma
operator|=
name|sym
operator|.
name|n_value
expr_stmt|;
name|csect
operator|->
name|_raw_size
operator|=
name|aux
operator|.
name|x_csect
operator|.
name|x_scnlen
operator|.
name|l
expr_stmt|;
name|csect
operator|->
name|flags
operator||=
name|SEC_ALLOC
expr_stmt|;
name|csect
operator|->
name|alignment_power
operator|=
name|SMTYP_ALIGN
argument_list|(
name|aux
operator|.
name|x_csect
operator|.
name|x_smtyp
argument_list|)
expr_stmt|;
comment|/* There are a number of other fields and section flags 	     which we do not bother to set.  */
name|csect_index
operator|=
operator|(
operator|(
name|esym
operator|-
operator|(
name|bfd_byte
operator|*
operator|)
name|obj_coff_external_syms
argument_list|(
name|abfd
argument_list|)
operator|)
operator|/
name|symesz
operator|)
expr_stmt|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|coff_section_tdata
argument_list|)
expr_stmt|;
name|csect
operator|->
name|used_by_bfd
operator|=
operator|(
name|PTR
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|csect
operator|->
name|used_by_bfd
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|xcoff_section_tdata
argument_list|)
expr_stmt|;
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|csect
argument_list|)
operator|->
name|tdata
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|csect
argument_list|)
operator|->
name|tdata
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|xcoff_section_data
argument_list|(
name|abfd
argument_list|,
name|csect
argument_list|)
operator|->
name|first_symndx
operator|=
name|csect_index
expr_stmt|;
if|if
condition|(
name|first_csect
operator|==
name|NULL
condition|)
name|first_csect
operator|=
name|csect
expr_stmt|;
if|if
condition|(
name|sym
operator|.
name|n_sclass
operator|==
name|C_EXT
condition|)
block|{
name|csect
operator|->
name|flags
operator||=
name|SEC_IS_COMMON
expr_stmt|;
name|csect
operator|->
name|_raw_size
operator|=
literal|0
expr_stmt|;
name|section
operator|=
name|csect
expr_stmt|;
name|value
operator|=
name|aux
operator|.
name|x_csect
operator|.
name|x_scnlen
operator|.
name|l
expr_stmt|;
block|}
break|break;
block|}
comment|/* Check for magic symbol names.  */
if|if
condition|(
operator|(
name|smtyp
operator|==
name|XTY_SD
operator|||
name|smtyp
operator|==
name|XTY_CM
operator|)
operator|&&
name|aux
operator|.
name|x_csect
operator|.
name|x_smclas
operator|!=
name|XMC_TC
operator|&&
name|aux
operator|.
name|x_csect
operator|.
name|x_smclas
operator|!=
name|XMC_TD
condition|)
block|{
name|int
name|i
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'_'
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"_text"
argument_list|)
operator|==
literal|0
condition|)
name|i
operator|=
name|XCOFF_SPECIAL_SECTION_TEXT
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"_etext"
argument_list|)
operator|==
literal|0
condition|)
name|i
operator|=
name|XCOFF_SPECIAL_SECTION_ETEXT
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"_data"
argument_list|)
operator|==
literal|0
condition|)
name|i
operator|=
name|XCOFF_SPECIAL_SECTION_DATA
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"_edata"
argument_list|)
operator|==
literal|0
condition|)
name|i
operator|=
name|XCOFF_SPECIAL_SECTION_EDATA
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"_end"
argument_list|)
operator|==
literal|0
condition|)
name|i
operator|=
name|XCOFF_SPECIAL_SECTION_END
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'e'
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"end"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i
operator|=
name|XCOFF_SPECIAL_SECTION_END2
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|!=
operator|-
literal|1
condition|)
block|{
name|xcoff_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|special_sections
index|[
name|i
index|]
operator|=
name|csect
expr_stmt|;
block|}
block|}
comment|/* Now we have enough information to add the symbol to the 	 linker hash table.  */
if|if
condition|(
name|sym
operator|.
name|n_sclass
operator|==
name|C_EXT
condition|)
block|{
name|bfd_boolean
name|copy
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|section
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* We must copy the name into memory if we got it from the 	     syment itself, rather than the string table.  */
name|copy
operator|=
name|default_copy
expr_stmt|;
if|if
condition|(
name|sym
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_zeroes
operator|!=
literal|0
operator|||
name|sym
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
operator|==
literal|0
condition|)
name|copy
operator|=
name|TRUE
expr_stmt|;
comment|/* The AIX linker appears to only detect multiple symbol 	     definitions when there is a reference to the symbol.  If 	     a symbol is defined multiple times, and the only 	     references are from the same object file, the AIX linker 	     appears to permit it.  It does not merge the different 	     definitions, but handles them independently.  On the 	     other hand, if there is a reference, the linker reports 	     an error.  	     This matters because the AIX<net/net_globals.h> header 	     file actually defines an initialized array, so we have to 	     actually permit that to work.  	     Just to make matters even more confusing, the AIX linker 	     appears to permit multiple symbol definitions whenever 	     the second definition is in an archive rather than an 	     object file.  This may be a consequence of the manner in 	     which it handles archives: I think it may load the entire 	     archive in as separate csects, and then let garbage 	     collection discard symbols.  	     We also have to handle the case of statically linking a 	     shared object, which will cause symbol redefinitions, 	     although this is an easier case to detect.  */
if|if
condition|(
name|info
operator|->
name|hash
operator|->
name|creator
operator|==
name|abfd
operator|->
name|xvec
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_is_und_section
argument_list|(
name|section
argument_list|)
condition|)
block|{
operator|*
name|sym_hash
operator|=
name|xcoff_link_hash_lookup
argument_list|(
name|xcoff_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|name
argument_list|,
name|TRUE
argument_list|,
name|copy
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Make a copy of the symbol name to prevent problems with 		     merging symbols.  */
operator|*
name|sym_hash
operator|=
operator|(
operator|(
expr|struct
name|xcoff_link_hash_entry
operator|*
operator|)
name|bfd_wrapped_link_hash_lookup
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|name
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|sym_hash
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|(
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
operator|!
name|bfd_is_und_section
argument_list|(
name|section
argument_list|)
operator|&&
operator|!
name|bfd_is_com_section
argument_list|(
name|section
argument_list|)
condition|)
block|{
comment|/* This is a second definition of a defined symbol.  */
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|smclas
operator|!=
name|XMC_GL
operator|||
name|aux
operator|.
name|x_csect
operator|.
name|x_smclas
operator|==
name|XMC_GL
operator|||
operator|(
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* The new symbol is from a shared library, and 			 either the existing symbol is not global 			 linkage code or this symbol is global linkage 			 code.  If the existing symbol is global 			 linkage code and the new symbol is not, then 			 we want to use the new symbol.  */
name|section
operator|=
name|bfd_und_section_ptr
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* The existing symbol is from a shared library. 			 Replace it.  */
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|root
operator|.
name|type
operator|=
name|bfd_link_hash_undefined
expr_stmt|;
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|root
operator|.
name|u
operator|.
name|undef
operator|.
name|abfd
operator|=
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|abfd
operator|->
name|my_archive
operator|!=
name|NULL
condition|)
block|{
comment|/* This is a redefinition in an object contained 			 in an archive.  Just ignore it.  See the 			 comment above.  */
name|section
operator|=
name|bfd_und_section_ptr
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|root
operator|.
name|und_next
operator|!=
name|NULL
operator|||
name|info
operator|->
name|hash
operator|->
name|undefs_tail
operator|==
operator|&
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|root
condition|)
block|{
comment|/* This symbol has been referenced.  In this 			 case, we just continue and permit the 			 multiple definition error.  See the comment 			 above about the behaviour of the AIX linker.  */
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|smclas
operator|==
name|aux
operator|.
name|x_csect
operator|.
name|x_smclas
condition|)
block|{
comment|/* The symbols are both csects of the same 			 class.  There is at least a chance that this 			 is a semi-legitimate redefinition.  */
name|section
operator|=
name|bfd_und_section_ptr
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|flags
operator||=
name|XCOFF_MULTIPLY_DEFINED
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|flags
operator|&
name|XCOFF_MULTIPLY_DEFINED
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
operator|(
name|bfd_is_und_section
argument_list|(
name|section
argument_list|)
operator|||
name|bfd_is_com_section
argument_list|(
name|section
argument_list|)
operator|)
condition|)
block|{
comment|/* This is a reference to a multiply defined symbol. 		     Report the error now.  See the comment above 		     about the behaviour of the AIX linker.  We could 		     also do this with warning symbols, but I'm not 		     sure the XCOFF linker is wholly prepared to 		     handle them, and that would only be a warning, 		     not an error.  */
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|multiple_definition
call|)
argument_list|(
name|info
argument_list|,
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
operator|(
name|bfd
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|asection
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
argument_list|,
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
argument_list|,
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
argument_list|)
operator|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* Try not to give this error too many times.  */
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|flags
operator|&=
operator|~
name|XCOFF_MULTIPLY_DEFINED
expr_stmt|;
block|}
block|}
comment|/* _bfd_generic_link_add_one_symbol may call the linker to 	     generate an error message, and the linker may try to read 	     the symbol table to give a good error.  Right now, the 	     line numbers are in an inconsistent state, since they are 	     counted both in the real sections and in the new csects. 	     We need to leave the count in the real sections so that 	     the linker can report the line number of the error 	     correctly, so temporarily clobber the link to the csects 	     so that the linker will not try to read the line numbers 	     a second time from the csects.  */
name|BFD_ASSERT
argument_list|(
name|last_real
operator|->
name|next
operator|==
name|first_csect
argument_list|)
expr_stmt|;
name|last_real
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
name|name
argument_list|,
name|flags
argument_list|,
name|section
argument_list|,
name|value
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|copy
argument_list|,
name|TRUE
argument_list|,
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|*
operator|)
name|sym_hash
argument_list|)
operator|)
condition|)
goto|goto
name|error_return
goto|;
name|last_real
operator|->
name|next
operator|=
name|first_csect
expr_stmt|;
if|if
condition|(
name|smtyp
operator|==
name|XTY_CM
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_common
operator|||
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
operator|!=
name|csect
condition|)
block|{
comment|/* We don't need the common csect we just created.  */
name|csect
operator|->
name|_raw_size
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|alignment_power
operator|=
name|csect
operator|->
name|alignment_power
expr_stmt|;
block|}
block|}
if|if
condition|(
name|info
operator|->
name|hash
operator|->
name|creator
operator|==
name|abfd
operator|->
name|xvec
condition|)
block|{
name|int
name|flag
decl_stmt|;
if|if
condition|(
name|smtyp
operator|==
name|XTY_ER
operator|||
name|smtyp
operator|==
name|XTY_CM
condition|)
name|flag
operator|=
name|XCOFF_REF_REGULAR
expr_stmt|;
else|else
name|flag
operator|=
name|XCOFF_DEF_REGULAR
expr_stmt|;
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|flags
operator||=
name|flag
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|smclas
operator|==
name|XMC_UA
operator|||
name|flag
operator|==
name|XCOFF_DEF_REGULAR
condition|)
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|smclas
operator|=
name|aux
operator|.
name|x_csect
operator|.
name|x_smclas
expr_stmt|;
block|}
block|}
operator|*
name|csect_cache
operator|=
name|csect
expr_stmt|;
name|esym
operator|+=
operator|(
name|sym
operator|.
name|n_numaux
operator|+
literal|1
operator|)
operator|*
name|symesz
expr_stmt|;
name|sym_hash
operator|+=
name|sym
operator|.
name|n_numaux
operator|+
literal|1
expr_stmt|;
name|csect_cache
operator|+=
name|sym
operator|.
name|n_numaux
operator|+
literal|1
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
name|last_real
operator|==
name|NULL
operator|||
name|last_real
operator|->
name|next
operator|==
name|first_csect
argument_list|)
expr_stmt|;
comment|/* Make sure that we have seen all the relocs.  */
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
name|first_csect
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
comment|/* Reset the section size and the line number count, since the 	 data is now attached to the csects.  Don't reset the size of 	 the .debug section, since we need to read it below in 	 bfd_xcoff_size_dynamic_sections.  */
if|if
condition|(
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|o
argument_list|)
argument_list|,
literal|".debug"
argument_list|)
operator|!=
literal|0
condition|)
name|o
operator|->
name|_raw_size
operator|=
literal|0
expr_stmt|;
name|o
operator|->
name|lineno_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|!=
literal|0
condition|)
block|{
name|bfd_size_type
name|i
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|rel
decl_stmt|;
name|asection
modifier|*
modifier|*
name|rel_csect
decl_stmt|;
name|rel
operator|=
name|reloc_info
index|[
name|o
operator|->
name|target_index
index|]
operator|.
name|relocs
expr_stmt|;
name|rel_csect
operator|=
name|reloc_info
index|[
name|o
operator|->
name|target_index
index|]
operator|.
name|csects
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|o
operator|->
name|reloc_count
condition|;
name|i
operator|++
operator|,
name|rel
operator|++
operator|,
name|rel_csect
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|rel_csect
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: reloc %s:%d not in csect"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|o
operator|->
name|name
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
comment|/* We identify all symbols which are called, so that we 		 can create glue code for calls to functions imported 		 from dynamic objects.  */
if|if
condition|(
name|info
operator|->
name|hash
operator|->
name|creator
operator|==
name|abfd
operator|->
name|xvec
operator|&&
operator|*
name|rel_csect
operator|!=
name|bfd_und_section_ptr
operator|&&
operator|(
name|rel
operator|->
name|r_type
operator|==
name|R_BR
operator|||
name|rel
operator|->
name|r_type
operator|==
name|R_RBR
operator|)
operator|&&
name|obj_xcoff_sym_hashes
argument_list|(
name|abfd
argument_list|)
index|[
name|rel
operator|->
name|r_symndx
index|]
operator|!=
name|NULL
condition|)
block|{
name|struct
name|xcoff_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
name|obj_xcoff_sym_hashes
argument_list|(
name|abfd
argument_list|)
index|[
name|rel
operator|->
name|r_symndx
index|]
expr_stmt|;
name|h
operator|->
name|flags
operator||=
name|XCOFF_CALLED
expr_stmt|;
comment|/* If the symbol name starts with a period, it is 		     the code of a function.  If the symbol is 		     currently undefined, then add an undefined symbol 		     for the function descriptor.  This should do no 		     harm, because any regular object that defines the 		     function should also define the function 		     descriptor.  It helps, because it means that we 		     will identify the function descriptor with a 		     dynamic object if a dynamic object defines it.  */
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|h
operator|->
name|descriptor
operator|==
name|NULL
condition|)
block|{
name|struct
name|xcoff_link_hash_entry
modifier|*
name|hds
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|bh
decl_stmt|;
name|hds
operator|=
name|xcoff_link_hash_lookup
argument_list|(
name|xcoff_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
operator|+
literal|1
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|hds
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|hds
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_new
condition|)
block|{
name|bh
operator|=
operator|&
name|hds
operator|->
name|root
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
name|hds
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
operator|(
name|flagword
operator|)
literal|0
argument_list|,
name|bfd_und_section_ptr
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
operator|&
name|bh
argument_list|)
operator|)
condition|)
goto|goto
name|error_return
goto|;
name|hds
operator|=
operator|(
expr|struct
name|xcoff_link_hash_entry
operator|*
operator|)
name|bh
expr_stmt|;
block|}
name|hds
operator|->
name|flags
operator||=
name|XCOFF_DESCRIPTOR
expr_stmt|;
name|BFD_ASSERT
argument_list|(
operator|(
name|hds
operator|->
name|flags
operator|&
name|XCOFF_CALLED
operator|)
operator|==
literal|0
operator|&&
operator|(
name|h
operator|->
name|flags
operator|&
name|XCOFF_DESCRIPTOR
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|hds
operator|->
name|descriptor
operator|=
name|h
expr_stmt|;
name|h
operator|->
name|descriptor
operator|=
name|hds
expr_stmt|;
block|}
block|}
block|}
name|free
argument_list|(
name|reloc_info
index|[
name|o
operator|->
name|target_index
index|]
operator|.
name|csects
argument_list|)
expr_stmt|;
name|reloc_info
index|[
name|o
operator|->
name|target_index
index|]
operator|.
name|csects
operator|=
name|NULL
expr_stmt|;
comment|/* Reset SEC_RELOC and the reloc_count, since the reloc 	     information is now attached to the csects.  */
name|o
operator|->
name|flags
operator|&=
operator|~
name|SEC_RELOC
expr_stmt|;
name|o
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
comment|/* If we are not keeping memory, free the reloc information.  */
if|if
condition|(
operator|!
name|info
operator|->
name|keep_memory
operator|&&
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|o
argument_list|)
operator|!=
name|NULL
operator|&&
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|o
argument_list|)
operator|->
name|relocs
operator|!=
name|NULL
operator|&&
operator|!
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|o
argument_list|)
operator|->
name|keep_relocs
condition|)
block|{
name|free
argument_list|(
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|o
argument_list|)
operator|->
name|relocs
argument_list|)
expr_stmt|;
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|o
argument_list|)
operator|->
name|relocs
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* Free up the line numbers.  FIXME: We could cache these 	 somewhere for the final link, to avoid reading them again.  */
if|if
condition|(
name|reloc_info
index|[
name|o
operator|->
name|target_index
index|]
operator|.
name|linenos
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|reloc_info
index|[
name|o
operator|->
name|target_index
index|]
operator|.
name|linenos
argument_list|)
expr_stmt|;
name|reloc_info
index|[
name|o
operator|->
name|target_index
index|]
operator|.
name|linenos
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|reloc_info
argument_list|)
expr_stmt|;
name|obj_coff_keep_syms
argument_list|(
name|abfd
argument_list|)
operator|=
name|keep_syms
expr_stmt|;
return|return
name|TRUE
return|;
name|error_return
label|:
if|if
condition|(
name|reloc_info
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
if|if
condition|(
name|reloc_info
index|[
name|o
operator|->
name|target_index
index|]
operator|.
name|csects
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|reloc_info
index|[
name|o
operator|->
name|target_index
index|]
operator|.
name|csects
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc_info
index|[
name|o
operator|->
name|target_index
index|]
operator|.
name|linenos
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|reloc_info
index|[
name|o
operator|->
name|target_index
index|]
operator|.
name|linenos
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|reloc_info
argument_list|)
expr_stmt|;
block|}
name|obj_coff_keep_syms
argument_list|(
name|abfd
argument_list|)
operator|=
name|keep_syms
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|N_TMASK
end_undef

begin_undef
undef|#
directive|undef
name|N_BTSHFT
end_undef

begin_comment
comment|/* This function is used to add symbols from a dynamic object to the    global symbol table.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|xcoff_link_add_dynamic_symbols
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|asection
modifier|*
name|lsec
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|struct
name|internal_ldhdr
name|ldhdr
decl_stmt|;
specifier|const
name|char
modifier|*
name|strings
decl_stmt|;
name|bfd_byte
modifier|*
name|elsym
decl_stmt|,
modifier|*
name|elsymend
decl_stmt|;
name|struct
name|xcoff_import_file
modifier|*
name|n
decl_stmt|;
specifier|const
name|char
modifier|*
name|bname
decl_stmt|;
specifier|const
name|char
modifier|*
name|mname
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|unsigned
name|int
name|c
decl_stmt|;
name|struct
name|xcoff_import_file
modifier|*
modifier|*
name|pp
decl_stmt|;
comment|/* We can only handle a dynamic object if we are generating an XCOFF      output file.  */
if|if
condition|(
name|info
operator|->
name|hash
operator|->
name|creator
operator|!=
name|abfd
operator|->
name|xvec
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: XCOFF shared object when not producing XCOFF output"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* The symbols we use from a dynamic object are not the symbols in      the normal symbol table, but, rather, the symbols in the export      table.  If there is a global symbol in a dynamic object which is      not in the export table, the loader will not be able to find it,      so we don't want to find it either.  Also, on AIX 4.1.3, shr.o in      libc.a has symbols in the export table which are not in the      symbol table.  */
comment|/* Read in the .loader section.  FIXME: We should really use the      o_snloader field in the a.out header, rather than grabbing the      section by name.  */
name|lsec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".loader"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lsec
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: dynamic object with no .loader section"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_no_symbols
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|xcoff_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|lsec
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|contents
operator|=
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|lsec
argument_list|)
operator|->
name|contents
expr_stmt|;
comment|/* Remove the sections from this object, so that they do not get      included in the link.  */
name|bfd_section_list_clear
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|bfd_xcoff_swap_ldhdr_in
argument_list|(
name|abfd
argument_list|,
name|contents
argument_list|,
operator|&
name|ldhdr
argument_list|)
expr_stmt|;
name|strings
operator|=
operator|(
name|char
operator|*
operator|)
name|contents
operator|+
name|ldhdr
operator|.
name|l_stoff
expr_stmt|;
name|elsym
operator|=
name|contents
operator|+
name|bfd_xcoff_loader_symbol_offset
argument_list|(
name|abfd
argument_list|,
operator|&
name|ldhdr
argument_list|)
expr_stmt|;
name|elsymend
operator|=
name|elsym
operator|+
name|ldhdr
operator|.
name|l_nsyms
operator|*
name|bfd_xcoff_ldsymsz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|elsym
operator|<
name|elsymend
condition|;
name|elsym
operator|+=
name|bfd_xcoff_ldsymsz
argument_list|(
name|abfd
argument_list|)
control|)
block|{
name|struct
name|internal_ldsym
name|ldsym
decl_stmt|;
name|char
name|nambuf
index|[
name|SYMNMLEN
operator|+
literal|1
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|xcoff_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|bfd_xcoff_swap_ldsym_in
argument_list|(
name|abfd
argument_list|,
name|elsym
argument_list|,
operator|&
name|ldsym
argument_list|)
expr_stmt|;
comment|/* We are only interested in exported symbols.  */
if|if
condition|(
operator|(
name|ldsym
operator|.
name|l_smtype
operator|&
name|L_EXPORT
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|ldsym
operator|.
name|_l
operator|.
name|_l_l
operator|.
name|_l_zeroes
operator|==
literal|0
condition|)
name|name
operator|=
name|strings
operator|+
name|ldsym
operator|.
name|_l
operator|.
name|_l_l
operator|.
name|_l_offset
expr_stmt|;
else|else
block|{
name|memcpy
argument_list|(
name|nambuf
argument_list|,
name|ldsym
operator|.
name|_l
operator|.
name|_l_name
argument_list|,
name|SYMNMLEN
argument_list|)
expr_stmt|;
name|nambuf
index|[
name|SYMNMLEN
index|]
operator|=
literal|'\0'
expr_stmt|;
name|name
operator|=
name|nambuf
expr_stmt|;
block|}
comment|/* Normally we could not call xcoff_link_hash_lookup in an add 	 symbols routine, since we might not be using an XCOFF hash 	 table.  However, we verified above that we are using an XCOFF 	 hash table.  */
name|h
operator|=
name|xcoff_link_hash_lookup
argument_list|(
name|xcoff_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|name
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|h
operator|->
name|flags
operator||=
name|XCOFF_DEF_DYNAMIC
expr_stmt|;
comment|/* If the symbol is undefined, and the BFD it was found in is 	 not a dynamic object, change the BFD to this dynamic object, 	 so that we can get the correct import file ID.  */
if|if
condition|(
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|)
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|undef
operator|.
name|abfd
operator|==
name|NULL
operator|||
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|undef
operator|.
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|==
literal|0
operator|)
condition|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|undef
operator|.
name|abfd
operator|=
name|abfd
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_new
condition|)
block|{
name|h
operator|->
name|root
operator|.
name|type
operator|=
name|bfd_link_hash_undefined
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|undef
operator|.
name|abfd
operator|=
name|abfd
expr_stmt|;
comment|/* We do not want to add this to the undefined symbol list.  */
block|}
if|if
condition|(
name|h
operator|->
name|smclas
operator|==
name|XMC_UA
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
name|h
operator|->
name|smclas
operator|=
name|ldsym
operator|.
name|l_smclas
expr_stmt|;
comment|/* Unless this is an XMC_XO symbol, we don't bother to actually 	 define it, since we don't have a section to put it in anyhow. 	 Instead, the relocation routines handle the DEF_DYNAMIC flag 	 correctly.  */
if|if
condition|(
name|h
operator|->
name|smclas
operator|==
name|XMC_XO
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|)
condition|)
block|{
comment|/* This symbol has an absolute value.  */
name|h
operator|->
name|root
operator|.
name|type
operator|=
name|bfd_link_hash_defined
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|ldsym
operator|.
name|l_value
expr_stmt|;
block|}
comment|/* If this symbol defines a function descriptor, then it 	 implicitly defines the function code as well.  */
if|if
condition|(
name|h
operator|->
name|smclas
operator|==
name|XMC_DS
operator|||
operator|(
name|h
operator|->
name|smclas
operator|==
name|XMC_XO
operator|&&
name|name
index|[
literal|0
index|]
operator|!=
literal|'.'
operator|)
condition|)
name|h
operator|->
name|flags
operator||=
name|XCOFF_DESCRIPTOR
expr_stmt|;
if|if
condition|(
operator|(
name|h
operator|->
name|flags
operator|&
name|XCOFF_DESCRIPTOR
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|xcoff_link_hash_entry
modifier|*
name|hds
decl_stmt|;
name|hds
operator|=
name|h
operator|->
name|descriptor
expr_stmt|;
if|if
condition|(
name|hds
operator|==
name|NULL
condition|)
block|{
name|char
modifier|*
name|dsnm
decl_stmt|;
name|dsnm
operator|=
name|bfd_malloc
argument_list|(
operator|(
name|bfd_size_type
operator|)
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsnm
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|dsnm
index|[
literal|0
index|]
operator|=
literal|'.'
expr_stmt|;
name|strcpy
argument_list|(
name|dsnm
operator|+
literal|1
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|hds
operator|=
name|xcoff_link_hash_lookup
argument_list|(
name|xcoff_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|dsnm
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dsnm
argument_list|)
expr_stmt|;
if|if
condition|(
name|hds
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|hds
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_new
condition|)
block|{
name|hds
operator|->
name|root
operator|.
name|type
operator|=
name|bfd_link_hash_undefined
expr_stmt|;
name|hds
operator|->
name|root
operator|.
name|u
operator|.
name|undef
operator|.
name|abfd
operator|=
name|abfd
expr_stmt|;
comment|/* We do not want to add this to the undefined 		     symbol list.  */
block|}
name|hds
operator|->
name|descriptor
operator|=
name|h
expr_stmt|;
name|h
operator|->
name|descriptor
operator|=
name|hds
expr_stmt|;
block|}
name|hds
operator|->
name|flags
operator||=
name|XCOFF_DEF_DYNAMIC
expr_stmt|;
if|if
condition|(
name|hds
operator|->
name|smclas
operator|==
name|XMC_UA
condition|)
name|hds
operator|->
name|smclas
operator|=
name|XMC_PR
expr_stmt|;
comment|/* An absolute symbol appears to actually define code, not a 	     function descriptor.  This is how some math functions are 	     implemented on AIX 4.1.  */
if|if
condition|(
name|h
operator|->
name|smclas
operator|==
name|XMC_XO
operator|&&
operator|(
name|hds
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
operator|||
name|hds
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|)
condition|)
block|{
name|hds
operator|->
name|smclas
operator|=
name|XMC_XO
expr_stmt|;
name|hds
operator|->
name|root
operator|.
name|type
operator|=
name|bfd_link_hash_defined
expr_stmt|;
name|hds
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
name|hds
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|ldsym
operator|.
name|l_value
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|contents
operator|!=
name|NULL
operator|&&
operator|!
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|lsec
argument_list|)
operator|->
name|keep_contents
condition|)
block|{
name|free
argument_list|(
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|lsec
argument_list|)
operator|->
name|contents
argument_list|)
expr_stmt|;
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|lsec
argument_list|)
operator|->
name|contents
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Record this file in the import files.  */
name|n
operator|=
operator|(
operator|(
expr|struct
name|xcoff_import_file
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_size_type
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|xcoff_import_file
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|n
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
comment|/* For some reason, the path entry in the import file list for a      shared object appears to always be empty.  The file name is the      base name.  */
name|n
operator|->
name|path
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|my_archive
operator|==
name|NULL
condition|)
block|{
name|bname
operator|=
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|mname
operator|=
literal|""
expr_stmt|;
block|}
else|else
block|{
name|bname
operator|=
name|bfd_get_filename
argument_list|(
name|abfd
operator|->
name|my_archive
argument_list|)
expr_stmt|;
name|mname
operator|=
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|strrchr
argument_list|(
name|bname
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|bname
operator|=
name|s
operator|+
literal|1
expr_stmt|;
name|n
operator|->
name|file
operator|=
name|bname
expr_stmt|;
name|n
operator|->
name|member
operator|=
name|mname
expr_stmt|;
comment|/* We start c at 1 because the first import file number is reserved      for LIBPATH.  */
for|for
control|(
name|pp
operator|=
operator|&
name|xcoff_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|imports
operator|,
name|c
operator|=
literal|1
init|;
operator|*
name|pp
operator|!=
name|NULL
condition|;
name|pp
operator|=
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|next
operator|,
operator|++
name|c
control|)
empty_stmt|;
operator|*
name|pp
operator|=
name|n
expr_stmt|;
name|xcoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|import_file_id
operator|=
name|c
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Routines that are called after all the input files have been    handled, but before the sections are laid out in memory.  */
end_comment

begin_comment
comment|/* Mark a symbol as not being garbage, including the section in which    it is defined.  */
end_comment

begin_function
specifier|static
name|INLINE
name|bfd_boolean
name|xcoff_mark_symbol
parameter_list|(
name|info
parameter_list|,
name|h
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|xcoff_link_hash_entry
modifier|*
name|h
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|h
operator|->
name|flags
operator|&
name|XCOFF_MARK
operator|)
operator|!=
literal|0
condition|)
return|return
name|TRUE
return|;
name|h
operator|->
name|flags
operator||=
name|XCOFF_MARK
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
block|{
name|asection
modifier|*
name|hsec
decl_stmt|;
name|hsec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_is_abs_section
argument_list|(
name|hsec
argument_list|)
operator|&&
operator|(
name|hsec
operator|->
name|flags
operator|&
name|SEC_MARK
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|xcoff_mark
argument_list|(
name|info
argument_list|,
name|hsec
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
if|if
condition|(
name|h
operator|->
name|toc_section
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|toc_section
operator|->
name|flags
operator|&
name|SEC_MARK
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|xcoff_mark
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|toc_section
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* The mark phase of garbage collection.  For a given section, mark    it, and all the sections which define symbols to which it refers.    Because this function needs to look at the relocs, we also count    the number of relocs which need to be copied into the .loader    section.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|xcoff_mark
parameter_list|(
name|info
parameter_list|,
name|sec
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
block|{
if|if
condition|(
name|bfd_is_abs_section
argument_list|(
name|sec
argument_list|)
operator|||
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_MARK
operator|)
operator|!=
literal|0
condition|)
return|return
name|TRUE
return|;
name|sec
operator|->
name|flags
operator||=
name|SEC_MARK
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|owner
operator|->
name|xvec
operator|==
name|info
operator|->
name|hash
operator|->
name|creator
operator|&&
name|coff_section_data
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|sec
argument_list|)
operator|!=
name|NULL
operator|&&
name|xcoff_section_data
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|sec
argument_list|)
operator|!=
name|NULL
condition|)
block|{
specifier|register
name|struct
name|xcoff_link_hash_entry
modifier|*
modifier|*
name|hp
decl_stmt|,
modifier|*
modifier|*
name|hpend
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|rel
decl_stmt|,
modifier|*
name|relend
decl_stmt|;
comment|/* Mark all the symbols in this section.  */
name|hp
operator|=
operator|(
name|obj_xcoff_sym_hashes
argument_list|(
name|sec
operator|->
name|owner
argument_list|)
operator|+
name|xcoff_section_data
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|sec
argument_list|)
operator|->
name|first_symndx
operator|)
expr_stmt|;
name|hpend
operator|=
operator|(
name|obj_xcoff_sym_hashes
argument_list|(
name|sec
operator|->
name|owner
argument_list|)
operator|+
name|xcoff_section_data
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|sec
argument_list|)
operator|->
name|last_symndx
operator|)
expr_stmt|;
for|for
control|(
init|;
name|hp
operator|<
name|hpend
condition|;
name|hp
operator|++
control|)
block|{
specifier|register
name|struct
name|xcoff_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
operator|*
name|hp
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|flags
operator|&
name|XCOFF_MARK
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|xcoff_mark_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
comment|/* Look through the section relocs.  */
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|!=
literal|0
operator|&&
name|sec
operator|->
name|reloc_count
operator|>
literal|0
condition|)
block|{
name|rel
operator|=
name|xcoff_read_internal_relocs
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|sec
argument_list|,
name|TRUE
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|NULL
argument_list|,
name|FALSE
argument_list|,
operator|(
expr|struct
name|internal_reloc
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rel
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|relend
operator|=
name|rel
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|asection
modifier|*
name|rsec
decl_stmt|;
name|struct
name|xcoff_link_hash_entry
modifier|*
name|h
decl_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|int
operator|)
name|rel
operator|->
name|r_symndx
operator|>
name|obj_raw_syment_count
argument_list|(
name|sec
operator|->
name|owner
argument_list|)
condition|)
continue|continue;
name|h
operator|=
name|obj_xcoff_sym_hashes
argument_list|(
name|sec
operator|->
name|owner
argument_list|)
index|[
name|rel
operator|->
name|r_symndx
index|]
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|flags
operator|&
name|XCOFF_MARK
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|xcoff_mark_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
name|rsec
operator|=
name|xcoff_data
argument_list|(
name|sec
operator|->
name|owner
argument_list|)
operator|->
name|csects
index|[
name|rel
operator|->
name|r_symndx
index|]
expr_stmt|;
if|if
condition|(
name|rsec
operator|!=
name|NULL
operator|&&
operator|(
name|rsec
operator|->
name|flags
operator|&
name|SEC_MARK
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|xcoff_mark
argument_list|(
name|info
argument_list|,
name|rsec
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* See if this reloc needs to be copied into the .loader 		 section.  */
switch|switch
condition|(
name|rel
operator|->
name|r_type
condition|)
block|{
default|default:
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_common
operator|||
operator|(
operator|(
name|h
operator|->
name|flags
operator|&
name|XCOFF_CALLED
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|)
operator|&&
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|h
operator|->
name|descriptor
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|h
operator|->
name|descriptor
operator|->
name|flags
operator|&
name|XCOFF_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|||
operator|(
operator|(
name|h
operator|->
name|descriptor
operator|->
name|flags
operator|&
name|XCOFF_IMPORT
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|descriptor
operator|->
name|flags
operator|&
name|XCOFF_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
operator|)
operator|)
condition|)
break|break;
comment|/* Fall through.  */
case|case
name|R_POS
case|:
case|case
name|R_NEG
case|:
case|case
name|R_RL
case|:
case|case
name|R_RLA
case|:
operator|++
name|xcoff_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|ldrel_count
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|h
operator|->
name|flags
operator||=
name|XCOFF_LDREL
expr_stmt|;
break|break;
case|case
name|R_TOC
case|:
case|case
name|R_GL
case|:
case|case
name|R_TCL
case|:
case|case
name|R_TRL
case|:
case|case
name|R_TRLA
case|:
comment|/* We should never need a .loader reloc for a TOC 		     relative reloc.  */
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|info
operator|->
name|keep_memory
operator|&&
name|coff_section_data
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|sec
argument_list|)
operator|!=
name|NULL
operator|&&
name|coff_section_data
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|sec
argument_list|)
operator|->
name|relocs
operator|!=
name|NULL
operator|&&
operator|!
name|coff_section_data
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|sec
argument_list|)
operator|->
name|keep_relocs
condition|)
block|{
name|free
argument_list|(
name|coff_section_data
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|sec
argument_list|)
operator|->
name|relocs
argument_list|)
expr_stmt|;
name|coff_section_data
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|sec
argument_list|)
operator|->
name|relocs
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* The sweep phase of garbage collection.  Remove all garbage    sections.  */
end_comment

begin_function
specifier|static
name|void
name|xcoff_sweep
parameter_list|(
name|info
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|bfd
modifier|*
name|sub
decl_stmt|;
for|for
control|(
name|sub
operator|=
name|info
operator|->
name|input_bfds
init|;
name|sub
operator|!=
name|NULL
condition|;
name|sub
operator|=
name|sub
operator|->
name|link_next
control|)
block|{
name|asection
modifier|*
name|o
decl_stmt|;
for|for
control|(
name|o
operator|=
name|sub
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_MARK
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Keep all sections from non-XCOFF input files.  Keep 		 special sections.  Keep .debug sections for the 		 moment.  */
if|if
condition|(
name|sub
operator|->
name|xvec
operator|!=
name|info
operator|->
name|hash
operator|->
name|creator
operator|||
name|o
operator|==
name|xcoff_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|debug_section
operator|||
name|o
operator|==
name|xcoff_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|loader_section
operator|||
name|o
operator|==
name|xcoff_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|linkage_section
operator|||
name|o
operator|==
name|xcoff_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|toc_section
operator|||
name|o
operator|==
name|xcoff_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|descriptor_section
operator|||
name|strcmp
argument_list|(
name|o
operator|->
name|name
argument_list|,
literal|".debug"
argument_list|)
operator|==
literal|0
condition|)
name|o
operator|->
name|flags
operator||=
name|SEC_MARK
expr_stmt|;
else|else
block|{
name|o
operator|->
name|_raw_size
operator|=
literal|0
expr_stmt|;
name|o
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
name|o
operator|->
name|lineno_count
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Record the number of elements in a set.  This is used to output the    correct csect length.  */
end_comment

begin_function
name|bfd_boolean
name|bfd_xcoff_link_record_set
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|harg
parameter_list|,
name|size
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|harg
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
block|{
name|struct
name|xcoff_link_hash_entry
modifier|*
name|h
init|=
operator|(
expr|struct
name|xcoff_link_hash_entry
operator|*
operator|)
name|harg
decl_stmt|;
name|struct
name|xcoff_link_size_list
modifier|*
name|n
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|output_bfd
argument_list|)
operator|!=
name|bfd_target_xcoff_flavour
condition|)
return|return
name|TRUE
return|;
comment|/* This will hardly ever be called.  I don't want to burn four bytes      per global symbol, so instead the size is kept on a linked list      attached to the hash table.  */
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|xcoff_link_size_list
argument_list|)
expr_stmt|;
name|n
operator|=
operator|(
expr|struct
name|xcoff_link_size_list
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|output_bfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|n
operator|->
name|next
operator|=
name|xcoff_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|size_list
expr_stmt|;
name|n
operator|->
name|h
operator|=
name|h
expr_stmt|;
name|n
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|xcoff_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|size_list
operator|=
name|n
expr_stmt|;
name|h
operator|->
name|flags
operator||=
name|XCOFF_HAS_SIZE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Import a symbol.  */
end_comment

begin_function
name|bfd_boolean
name|bfd_xcoff_import_symbol
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|harg
parameter_list|,
name|val
parameter_list|,
name|imppath
parameter_list|,
name|impfile
parameter_list|,
name|impmember
parameter_list|,
name|syscall_flag
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|harg
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
specifier|const
name|char
modifier|*
name|imppath
decl_stmt|;
specifier|const
name|char
modifier|*
name|impfile
decl_stmt|;
specifier|const
name|char
modifier|*
name|impmember
decl_stmt|;
name|unsigned
name|int
name|syscall_flag
decl_stmt|;
block|{
name|struct
name|xcoff_link_hash_entry
modifier|*
name|h
init|=
operator|(
expr|struct
name|xcoff_link_hash_entry
operator|*
operator|)
name|harg
decl_stmt|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|output_bfd
argument_list|)
operator|!=
name|bfd_target_xcoff_flavour
condition|)
return|return
name|TRUE
return|;
comment|/* A symbol name which starts with a period is the code for a      function.  If the symbol is undefined, then add an undefined      symbol for the function descriptor, and import that instead.  */
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
operator|&&
name|val
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
name|struct
name|xcoff_link_hash_entry
modifier|*
name|hds
decl_stmt|;
name|hds
operator|=
name|h
operator|->
name|descriptor
expr_stmt|;
if|if
condition|(
name|hds
operator|==
name|NULL
condition|)
block|{
name|hds
operator|=
name|xcoff_link_hash_lookup
argument_list|(
name|xcoff_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
operator|+
literal|1
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|hds
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|hds
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_new
condition|)
block|{
name|hds
operator|->
name|root
operator|.
name|type
operator|=
name|bfd_link_hash_undefined
expr_stmt|;
name|hds
operator|->
name|root
operator|.
name|u
operator|.
name|undef
operator|.
name|abfd
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|undef
operator|.
name|abfd
expr_stmt|;
block|}
name|hds
operator|->
name|flags
operator||=
name|XCOFF_DESCRIPTOR
expr_stmt|;
name|BFD_ASSERT
argument_list|(
operator|(
name|hds
operator|->
name|flags
operator|&
name|XCOFF_CALLED
operator|)
operator|==
literal|0
operator|&&
operator|(
name|h
operator|->
name|flags
operator|&
name|XCOFF_DESCRIPTOR
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|hds
operator|->
name|descriptor
operator|=
name|h
expr_stmt|;
name|h
operator|->
name|descriptor
operator|=
name|hds
expr_stmt|;
block|}
comment|/* Now, if the descriptor is undefined, import the descriptor 	 rather than the symbol we were told to import.  FIXME: Is 	 this correct in all cases?  */
if|if
condition|(
name|hds
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
condition|)
name|h
operator|=
name|hds
expr_stmt|;
block|}
name|h
operator|->
name|flags
operator||=
operator|(
name|XCOFF_IMPORT
operator||
name|syscall_flag
operator|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|&&
operator|(
operator|!
name|bfd_is_abs_section
argument_list|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
argument_list|)
operator|||
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|!=
name|val
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|multiple_definition
call|)
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
argument_list|,
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
argument_list|,
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
argument_list|,
name|output_bfd
argument_list|,
name|bfd_abs_section_ptr
argument_list|,
name|val
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
block|}
name|h
operator|->
name|root
operator|.
name|type
operator|=
name|bfd_link_hash_defined
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|val
expr_stmt|;
block|}
comment|/* We overload the ldindx field to hold the l_ifile value for this      symbol.  */
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|ldsym
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
operator|(
name|h
operator|->
name|flags
operator|&
name|XCOFF_BUILT_LDSYM
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|imppath
operator|==
name|NULL
condition|)
name|h
operator|->
name|ldindx
operator|=
operator|-
literal|1
expr_stmt|;
else|else
block|{
name|unsigned
name|int
name|c
decl_stmt|;
name|struct
name|xcoff_import_file
modifier|*
modifier|*
name|pp
decl_stmt|;
comment|/* We start c at 1 because the first entry in the import list is 	 reserved for the library search path.  */
for|for
control|(
name|pp
operator|=
operator|&
name|xcoff_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|imports
operator|,
name|c
operator|=
literal|1
init|;
operator|*
name|pp
operator|!=
name|NULL
condition|;
name|pp
operator|=
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|next
operator|,
operator|++
name|c
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|(
operator|*
name|pp
operator|)
operator|->
name|path
argument_list|,
name|imppath
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
operator|(
operator|*
name|pp
operator|)
operator|->
name|file
argument_list|,
name|impfile
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
operator|(
operator|*
name|pp
operator|)
operator|->
name|member
argument_list|,
name|impmember
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
operator|*
name|pp
operator|==
name|NULL
condition|)
block|{
name|struct
name|xcoff_import_file
modifier|*
name|n
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|xcoff_import_file
argument_list|)
decl_stmt|;
name|n
operator|=
operator|(
expr|struct
name|xcoff_import_file
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|output_bfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|n
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|n
operator|->
name|path
operator|=
name|imppath
expr_stmt|;
name|n
operator|->
name|file
operator|=
name|impfile
expr_stmt|;
name|n
operator|->
name|member
operator|=
name|impmember
expr_stmt|;
operator|*
name|pp
operator|=
name|n
expr_stmt|;
block|}
name|h
operator|->
name|ldindx
operator|=
name|c
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Export a symbol.  */
end_comment

begin_function
name|bfd_boolean
name|bfd_xcoff_export_symbol
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|harg
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|harg
decl_stmt|;
block|{
name|struct
name|xcoff_link_hash_entry
modifier|*
name|h
init|=
operator|(
expr|struct
name|xcoff_link_hash_entry
operator|*
operator|)
name|harg
decl_stmt|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|output_bfd
argument_list|)
operator|!=
name|bfd_target_xcoff_flavour
condition|)
return|return
name|TRUE
return|;
name|h
operator|->
name|flags
operator||=
name|XCOFF_EXPORT
expr_stmt|;
comment|/* FIXME: I'm not at all sure what syscall is supposed to mean, so      I'm just going to ignore it until somebody explains it.  */
comment|/* See if this is a function descriptor.  It may be one even though      it is not so marked.  */
if|if
condition|(
operator|(
name|h
operator|->
name|flags
operator|&
name|XCOFF_DESCRIPTOR
operator|)
operator|==
literal|0
operator|&&
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
index|[
literal|0
index|]
operator|!=
literal|'.'
condition|)
block|{
name|char
modifier|*
name|fnname
decl_stmt|;
name|struct
name|xcoff_link_hash_entry
modifier|*
name|hfn
decl_stmt|;
name|bfd_size_type
name|amt
init|=
name|strlen
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
operator|+
literal|2
decl_stmt|;
name|fnname
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|fnname
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|fnname
index|[
literal|0
index|]
operator|=
literal|'.'
expr_stmt|;
name|strcpy
argument_list|(
name|fnname
operator|+
literal|1
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
name|hfn
operator|=
name|xcoff_link_hash_lookup
argument_list|(
name|xcoff_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|fnname
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fnname
argument_list|)
expr_stmt|;
if|if
condition|(
name|hfn
operator|!=
name|NULL
operator|&&
name|hfn
operator|->
name|smclas
operator|==
name|XMC_PR
operator|&&
operator|(
name|hfn
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|hfn
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
condition|)
block|{
name|h
operator|->
name|flags
operator||=
name|XCOFF_DESCRIPTOR
expr_stmt|;
name|h
operator|->
name|descriptor
operator|=
name|hfn
expr_stmt|;
name|hfn
operator|->
name|descriptor
operator|=
name|h
expr_stmt|;
block|}
block|}
comment|/* Make sure we don't garbage collect this symbol.  */
if|if
condition|(
operator|!
name|xcoff_mark_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* If this is a function descriptor, make sure we don't garbage      collect the associated function code.  We normally don't have to      worry about this, because the descriptor will be attached to a      section with relocs, but if we are creating the descriptor      ourselves those relocs will not be visible to the mark code.  */
if|if
condition|(
operator|(
name|h
operator|->
name|flags
operator|&
name|XCOFF_DESCRIPTOR
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|xcoff_mark_symbol
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|descriptor
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Count a reloc against a symbol.  This is called for relocs    generated by the linker script, typically for global constructors    and destructors.  */
end_comment

begin_function
name|bfd_boolean
name|bfd_xcoff_link_count_reloc
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|name
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|xcoff_link_hash_entry
modifier|*
name|h
decl_stmt|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|output_bfd
argument_list|)
operator|!=
name|bfd_target_xcoff_flavour
condition|)
return|return
name|TRUE
return|;
name|h
operator|=
operator|(
operator|(
expr|struct
name|xcoff_link_hash_entry
operator|*
operator|)
name|bfd_wrapped_link_hash_lookup
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: no such symbol"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_no_symbols
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|h
operator|->
name|flags
operator||=
name|XCOFF_REF_REGULAR
operator||
name|XCOFF_LDREL
expr_stmt|;
operator|++
name|xcoff_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|ldrel_count
expr_stmt|;
comment|/* Mark the symbol to avoid garbage collection.  */
if|if
condition|(
operator|!
name|xcoff_mark_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* This function is called for each symbol to which the linker script    assigns a value.  */
end_comment

begin_function
name|bfd_boolean
name|bfd_xcoff_record_link_assignment
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|name
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|xcoff_link_hash_entry
modifier|*
name|h
decl_stmt|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|output_bfd
argument_list|)
operator|!=
name|bfd_target_xcoff_flavour
condition|)
return|return
name|TRUE
return|;
name|h
operator|=
name|xcoff_link_hash_lookup
argument_list|(
name|xcoff_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|name
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|h
operator|->
name|flags
operator||=
name|XCOFF_DEF_REGULAR
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Build the .loader section.  This is called by the XCOFF linker    emulation before_allocation routine.  We must set the size of the    .loader section before the linker lays out the output file.    LIBPATH is the library path to search for shared objects; this is    normally built from the -L arguments passed to the linker.  ENTRY    is the name of the entry point symbol (the -e linker option).    FILE_ALIGN is the alignment to use for sections within the file    (the -H linker option).  MAXSTACK is the maximum stack size (the    -bmaxstack linker option).  MAXDATA is the maximum data size (the    -bmaxdata linker option).  GC is whether to do garbage collection    (the -bgc linker option).  MODTYPE is the module type (the    -bmodtype linker option).  TEXTRO is whether the text section must    be read only (the -btextro linker option).  EXPORT_DEFINEDS is    whether all defined symbols should be exported (the -unix linker    option).  SPECIAL_SECTIONS is set by this routine to csects with    magic names like _end.  */
end_comment

begin_function
name|bfd_boolean
name|bfd_xcoff_size_dynamic_sections
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|libpath
parameter_list|,
name|entry
parameter_list|,
name|file_align
parameter_list|,
name|maxstack
parameter_list|,
name|maxdata
parameter_list|,
name|gc
parameter_list|,
name|modtype
parameter_list|,
name|textro
parameter_list|,
name|export_defineds
parameter_list|,
name|special_sections
parameter_list|,
name|rtld
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
specifier|const
name|char
modifier|*
name|libpath
decl_stmt|;
specifier|const
name|char
modifier|*
name|entry
decl_stmt|;
name|unsigned
name|long
name|file_align
decl_stmt|;
name|unsigned
name|long
name|maxstack
decl_stmt|;
name|unsigned
name|long
name|maxdata
decl_stmt|;
name|bfd_boolean
name|gc
decl_stmt|;
name|int
name|modtype
decl_stmt|;
name|bfd_boolean
name|textro
decl_stmt|;
name|bfd_boolean
name|export_defineds
decl_stmt|;
name|asection
modifier|*
modifier|*
name|special_sections
decl_stmt|;
name|bfd_boolean
name|rtld
decl_stmt|;
block|{
name|struct
name|xcoff_link_hash_entry
modifier|*
name|hentry
decl_stmt|;
name|asection
modifier|*
name|lsec
decl_stmt|;
name|struct
name|xcoff_loader_info
name|ldinfo
decl_stmt|;
name|int
name|i
decl_stmt|;
name|size_t
name|impsize
decl_stmt|,
name|impcount
decl_stmt|;
name|struct
name|xcoff_import_file
modifier|*
name|fl
decl_stmt|;
name|struct
name|internal_ldhdr
modifier|*
name|ldhdr
decl_stmt|;
name|bfd_size_type
name|stoff
decl_stmt|;
specifier|register
name|char
modifier|*
name|out
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd
modifier|*
name|sub
decl_stmt|;
name|struct
name|bfd_strtab_hash
modifier|*
name|debug_strtab
decl_stmt|;
name|bfd_byte
modifier|*
name|debug_contents
init|=
name|NULL
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|output_bfd
argument_list|)
operator|!=
name|bfd_target_xcoff_flavour
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XCOFF_NUMBER_OF_SPECIAL_SECTIONS
condition|;
name|i
operator|++
control|)
name|special_sections
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|ldinfo
operator|.
name|failed
operator|=
name|FALSE
expr_stmt|;
name|ldinfo
operator|.
name|output_bfd
operator|=
name|output_bfd
expr_stmt|;
name|ldinfo
operator|.
name|info
operator|=
name|info
expr_stmt|;
name|ldinfo
operator|.
name|export_defineds
operator|=
name|export_defineds
expr_stmt|;
name|ldinfo
operator|.
name|ldsym_count
operator|=
literal|0
expr_stmt|;
name|ldinfo
operator|.
name|string_size
operator|=
literal|0
expr_stmt|;
name|ldinfo
operator|.
name|strings
operator|=
name|NULL
expr_stmt|;
name|ldinfo
operator|.
name|string_alc
operator|=
literal|0
expr_stmt|;
name|xcoff_data
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|maxstack
operator|=
name|maxstack
expr_stmt|;
name|xcoff_data
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|maxdata
operator|=
name|maxdata
expr_stmt|;
name|xcoff_data
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|modtype
operator|=
name|modtype
expr_stmt|;
name|xcoff_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|file_align
operator|=
name|file_align
expr_stmt|;
name|xcoff_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|textro
operator|=
name|textro
expr_stmt|;
name|hentry
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|entry
operator|!=
name|NULL
condition|)
block|{
name|hentry
operator|=
name|xcoff_link_hash_lookup
argument_list|(
name|xcoff_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|entry
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|hentry
operator|!=
name|NULL
condition|)
name|hentry
operator|->
name|flags
operator||=
name|XCOFF_ENTRY
expr_stmt|;
block|}
comment|/* __rtinit */
if|if
condition|(
name|info
operator|->
name|init_function
operator|||
name|info
operator|->
name|fini_function
operator|||
name|rtld
condition|)
block|{
name|struct
name|xcoff_link_hash_entry
modifier|*
name|hsym
decl_stmt|;
name|struct
name|internal_ldsym
modifier|*
name|ldsym
decl_stmt|;
name|hsym
operator|=
name|xcoff_link_hash_lookup
argument_list|(
name|xcoff_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
literal|"__rtinit"
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|hsym
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"error: undefined symbol __rtinit"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|xcoff_mark_symbol
argument_list|(
name|info
argument_list|,
name|hsym
argument_list|)
expr_stmt|;
name|hsym
operator|->
name|flags
operator||=
operator|(
name|XCOFF_DEF_REGULAR
operator||
name|XCOFF_RTINIT
operator|)
expr_stmt|;
comment|/* __rtinit initialized */
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|internal_ldsym
argument_list|)
expr_stmt|;
name|ldsym
operator|=
operator|(
expr|struct
name|internal_ldsym
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
name|ldsym
operator|->
name|l_value
operator|=
literal|0
expr_stmt|;
comment|/* will be filled in later */
name|ldsym
operator|->
name|l_scnum
operator|=
literal|2
expr_stmt|;
comment|/* data section */
name|ldsym
operator|->
name|l_smtype
operator|=
name|XTY_SD
expr_stmt|;
comment|/* csect section definition */
name|ldsym
operator|->
name|l_smclas
operator|=
literal|5
expr_stmt|;
comment|/* .rw */
name|ldsym
operator|->
name|l_ifile
operator|=
literal|0
expr_stmt|;
comment|/* special system loader symbol */
name|ldsym
operator|->
name|l_parm
operator|=
literal|0
expr_stmt|;
comment|/* NA */
comment|/* Force __rtinit to be the first symbol in the loader symbol table 	 See xcoff_build_ldsyms  	 The first 3 symbol table indices are reserved to indicate the data, 	 text and bss sections.  */
name|BFD_ASSERT
argument_list|(
literal|0
operator|==
name|ldinfo
operator|.
name|ldsym_count
argument_list|)
expr_stmt|;
name|hsym
operator|->
name|ldindx
operator|=
literal|3
expr_stmt|;
name|ldinfo
operator|.
name|ldsym_count
operator|=
literal|1
expr_stmt|;
name|hsym
operator|->
name|ldsym
operator|=
name|ldsym
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_xcoff_put_ldsymbol_name
argument_list|(
name|ldinfo
operator|.
name|output_bfd
argument_list|,
operator|&
name|ldinfo
argument_list|,
name|hsym
operator|->
name|ldsym
argument_list|,
name|hsym
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* This symbol is written out by xcoff_write_global_symbol 	 Set stuff up so xcoff_write_global_symbol logic works.  */
name|hsym
operator|->
name|flags
operator||=
name|XCOFF_DEF_REGULAR
operator||
name|XCOFF_MARK
expr_stmt|;
name|hsym
operator|->
name|root
operator|.
name|type
operator|=
name|bfd_link_hash_defined
expr_stmt|;
name|hsym
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Garbage collect unused sections.  */
if|if
condition|(
name|info
operator|->
name|relocatable
operator|||
operator|!
name|gc
operator|||
name|hentry
operator|==
name|NULL
operator|||
operator|(
name|hentry
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defined
operator|&&
name|hentry
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
operator|)
condition|)
block|{
name|gc
operator|=
name|FALSE
expr_stmt|;
name|xcoff_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|gc
operator|=
name|FALSE
expr_stmt|;
comment|/* We still need to call xcoff_mark, in order to set ldrel_count 	 correctly.  */
for|for
control|(
name|sub
operator|=
name|info
operator|->
name|input_bfds
init|;
name|sub
operator|!=
name|NULL
condition|;
name|sub
operator|=
name|sub
operator|->
name|link_next
control|)
block|{
name|asection
modifier|*
name|o
decl_stmt|;
for|for
control|(
name|o
operator|=
name|sub
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_MARK
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|xcoff_mark
argument_list|(
name|info
argument_list|,
name|o
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|xcoff_mark
argument_list|(
name|info
argument_list|,
name|hentry
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
name|xcoff_sweep
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|xcoff_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|gc
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Return special sections to the caller.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XCOFF_NUMBER_OF_SPECIAL_SECTIONS
condition|;
name|i
operator|++
control|)
block|{
name|sec
operator|=
name|xcoff_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|special_sections
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|sec
operator|!=
name|NULL
operator|&&
name|gc
operator|&&
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_MARK
operator|)
operator|==
literal|0
condition|)
block|{
name|sec
operator|=
name|NULL
expr_stmt|;
block|}
name|special_sections
index|[
name|i
index|]
operator|=
name|sec
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|input_bfds
operator|==
name|NULL
condition|)
block|{
comment|/* I'm not sure what to do in this bizarre case.  */
return|return
name|TRUE
return|;
block|}
name|xcoff_link_hash_traverse
argument_list|(
name|xcoff_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|xcoff_build_ldsyms
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|ldinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|ldinfo
operator|.
name|failed
condition|)
goto|goto
name|error_return
goto|;
comment|/* Work out the size of the import file names.  Each import file ID      consists of three null terminated strings: the path, the file      name, and the archive member name.  The first entry in the list      of names is the path to use to find objects, which the linker has      passed in as the libpath argument.  For some reason, the path      entry in the other import file names appears to always be empty.  */
name|impsize
operator|=
name|strlen
argument_list|(
name|libpath
argument_list|)
operator|+
literal|3
expr_stmt|;
name|impcount
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|fl
operator|=
name|xcoff_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|imports
init|;
name|fl
operator|!=
name|NULL
condition|;
name|fl
operator|=
name|fl
operator|->
name|next
control|)
block|{
operator|++
name|impcount
expr_stmt|;
name|impsize
operator|+=
operator|(
name|strlen
argument_list|(
name|fl
operator|->
name|path
argument_list|)
operator|+
name|strlen
argument_list|(
name|fl
operator|->
name|file
argument_list|)
operator|+
name|strlen
argument_list|(
name|fl
operator|->
name|member
argument_list|)
operator|+
literal|3
operator|)
expr_stmt|;
block|}
comment|/* Set up the .loader section header.  */
name|ldhdr
operator|=
operator|&
name|xcoff_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|ldhdr
expr_stmt|;
name|ldhdr
operator|->
name|l_version
operator|=
name|bfd_xcoff_ldhdr_version
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
name|ldhdr
operator|->
name|l_nsyms
operator|=
name|ldinfo
operator|.
name|ldsym_count
expr_stmt|;
name|ldhdr
operator|->
name|l_nreloc
operator|=
name|xcoff_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|ldrel_count
expr_stmt|;
name|ldhdr
operator|->
name|l_istlen
operator|=
name|impsize
expr_stmt|;
name|ldhdr
operator|->
name|l_nimpid
operator|=
name|impcount
expr_stmt|;
name|ldhdr
operator|->
name|l_impoff
operator|=
operator|(
name|bfd_xcoff_ldhdrsz
argument_list|(
name|output_bfd
argument_list|)
operator|+
name|ldhdr
operator|->
name|l_nsyms
operator|*
name|bfd_xcoff_ldsymsz
argument_list|(
name|output_bfd
argument_list|)
operator|+
name|ldhdr
operator|->
name|l_nreloc
operator|*
name|bfd_xcoff_ldrelsz
argument_list|(
name|output_bfd
argument_list|)
operator|)
expr_stmt|;
name|ldhdr
operator|->
name|l_stlen
operator|=
name|ldinfo
operator|.
name|string_size
expr_stmt|;
name|stoff
operator|=
name|ldhdr
operator|->
name|l_impoff
operator|+
name|impsize
expr_stmt|;
if|if
condition|(
name|ldinfo
operator|.
name|string_size
operator|==
literal|0
condition|)
name|ldhdr
operator|->
name|l_stoff
operator|=
literal|0
expr_stmt|;
else|else
name|ldhdr
operator|->
name|l_stoff
operator|=
name|stoff
expr_stmt|;
comment|/* 64 bit elements to ldhdr      The swap out routine for 32 bit will ignore them.      Nothing fancy, symbols come after the header and relocs come      after symbols.  */
name|ldhdr
operator|->
name|l_symoff
operator|=
name|bfd_xcoff_ldhdrsz
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
name|ldhdr
operator|->
name|l_rldoff
operator|=
operator|(
name|bfd_xcoff_ldhdrsz
argument_list|(
name|output_bfd
argument_list|)
operator|+
name|ldhdr
operator|->
name|l_nsyms
operator|*
name|bfd_xcoff_ldsymsz
argument_list|(
name|output_bfd
argument_list|)
operator|)
expr_stmt|;
comment|/* We now know the final size of the .loader section.  Allocate      space for it.  */
name|lsec
operator|=
name|xcoff_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|loader_section
expr_stmt|;
name|lsec
operator|->
name|_raw_size
operator|=
name|stoff
operator|+
name|ldhdr
operator|->
name|l_stlen
expr_stmt|;
name|lsec
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|output_bfd
argument_list|,
name|lsec
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|lsec
operator|->
name|contents
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
comment|/* Set up the header.  */
name|bfd_xcoff_swap_ldhdr_out
argument_list|(
name|output_bfd
argument_list|,
name|ldhdr
argument_list|,
name|lsec
operator|->
name|contents
argument_list|)
expr_stmt|;
comment|/* Set up the import file names.  */
name|out
operator|=
operator|(
name|char
operator|*
operator|)
name|lsec
operator|->
name|contents
operator|+
name|ldhdr
operator|->
name|l_impoff
expr_stmt|;
name|strcpy
argument_list|(
name|out
argument_list|,
name|libpath
argument_list|)
expr_stmt|;
name|out
operator|+=
name|strlen
argument_list|(
name|libpath
argument_list|)
operator|+
literal|1
expr_stmt|;
operator|*
name|out
operator|++
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|out
operator|++
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|fl
operator|=
name|xcoff_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|imports
init|;
name|fl
operator|!=
name|NULL
condition|;
name|fl
operator|=
name|fl
operator|->
name|next
control|)
block|{
specifier|register
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|fl
operator|->
name|path
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|out
operator|++
operator|=
operator|*
name|s
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
empty_stmt|;
name|s
operator|=
name|fl
operator|->
name|file
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|out
operator|++
operator|=
operator|*
name|s
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
empty_stmt|;
name|s
operator|=
name|fl
operator|->
name|member
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|out
operator|++
operator|=
operator|*
name|s
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
empty_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
call|(
name|bfd_size_type
call|)
argument_list|(
operator|(
name|bfd_byte
operator|*
operator|)
name|out
operator|-
name|lsec
operator|->
name|contents
argument_list|)
operator|==
name|stoff
argument_list|)
expr_stmt|;
comment|/* Set up the symbol string table.  */
if|if
condition|(
name|ldinfo
operator|.
name|string_size
operator|>
literal|0
condition|)
block|{
name|memcpy
argument_list|(
name|out
argument_list|,
name|ldinfo
operator|.
name|strings
argument_list|,
name|ldinfo
operator|.
name|string_size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ldinfo
operator|.
name|strings
argument_list|)
expr_stmt|;
name|ldinfo
operator|.
name|strings
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* We can't set up the symbol table or the relocs yet, because we      don't yet know the final position of the various sections.  The      .loader symbols are written out when the corresponding normal      symbols are written out in xcoff_link_input_bfd or      xcoff_write_global_symbol.  The .loader relocs are written out      when the corresponding normal relocs are handled in      xcoff_link_input_bfd.   */
comment|/* Allocate space for the magic sections.  */
name|sec
operator|=
name|xcoff_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|linkage_section
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|_raw_size
operator|>
literal|0
condition|)
block|{
name|sec
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|output_bfd
argument_list|,
name|sec
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|contents
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
block|}
name|sec
operator|=
name|xcoff_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|toc_section
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|_raw_size
operator|>
literal|0
condition|)
block|{
name|sec
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|output_bfd
argument_list|,
name|sec
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|contents
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
block|}
name|sec
operator|=
name|xcoff_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|descriptor_section
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|_raw_size
operator|>
literal|0
condition|)
block|{
name|sec
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|output_bfd
argument_list|,
name|sec
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|contents
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
block|}
comment|/* Now that we've done garbage collection, figure out the contents      of the .debug section.  */
name|debug_strtab
operator|=
name|xcoff_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|debug_strtab
expr_stmt|;
for|for
control|(
name|sub
operator|=
name|info
operator|->
name|input_bfds
init|;
name|sub
operator|!=
name|NULL
condition|;
name|sub
operator|=
name|sub
operator|->
name|link_next
control|)
block|{
name|asection
modifier|*
name|subdeb
decl_stmt|;
name|bfd_size_type
name|symcount
decl_stmt|;
name|unsigned
name|long
modifier|*
name|debug_index
decl_stmt|;
name|asection
modifier|*
modifier|*
name|csectpp
decl_stmt|;
name|bfd_byte
modifier|*
name|esym
decl_stmt|,
modifier|*
name|esymend
decl_stmt|;
name|bfd_size_type
name|symesz
decl_stmt|;
if|if
condition|(
name|sub
operator|->
name|xvec
operator|!=
name|info
operator|->
name|hash
operator|->
name|creator
condition|)
continue|continue;
name|subdeb
operator|=
name|bfd_get_section_by_name
argument_list|(
name|sub
argument_list|,
literal|".debug"
argument_list|)
expr_stmt|;
if|if
condition|(
name|subdeb
operator|==
name|NULL
operator|||
name|subdeb
operator|->
name|_raw_size
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|info
operator|->
name|strip
operator|==
name|strip_all
operator|||
name|info
operator|->
name|strip
operator|==
name|strip_debugger
operator|||
name|info
operator|->
name|discard
operator|==
name|discard_all
condition|)
block|{
name|subdeb
operator|->
name|_raw_size
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|_bfd_coff_get_external_symbols
argument_list|(
name|sub
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
name|symcount
operator|=
name|obj_raw_syment_count
argument_list|(
name|sub
argument_list|)
expr_stmt|;
name|debug_index
operator|=
operator|(
operator|(
name|unsigned
name|long
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|sub
argument_list|,
name|symcount
operator|*
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|debug_index
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|xcoff_data
argument_list|(
name|sub
argument_list|)
operator|->
name|debug_indices
operator|=
name|debug_index
expr_stmt|;
comment|/* Grab the contents of the .debug section.  We use malloc and 	 copy the names into the debug stringtab, rather than 	 bfd_alloc, because I expect that, when linking many files 	 together, many of the strings will be the same.  Storing the 	 strings in the hash table should save space in this case.  */
name|debug_contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|subdeb
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_contents
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|sub
argument_list|,
name|subdeb
argument_list|,
operator|(
name|PTR
operator|)
name|debug_contents
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|subdeb
operator|->
name|_raw_size
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
name|csectpp
operator|=
name|xcoff_data
argument_list|(
name|sub
argument_list|)
operator|->
name|csects
expr_stmt|;
comment|/* Dynamic object do not have csectpp's.  */
if|if
condition|(
name|NULL
operator|!=
name|csectpp
condition|)
block|{
name|symesz
operator|=
name|bfd_coff_symesz
argument_list|(
name|sub
argument_list|)
expr_stmt|;
name|esym
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|obj_coff_external_syms
argument_list|(
name|sub
argument_list|)
expr_stmt|;
name|esymend
operator|=
name|esym
operator|+
name|symcount
operator|*
name|symesz
expr_stmt|;
while|while
condition|(
name|esym
operator|<
name|esymend
condition|)
block|{
name|struct
name|internal_syment
name|sym
decl_stmt|;
name|bfd_coff_swap_sym_in
argument_list|(
name|sub
argument_list|,
operator|(
name|PTR
operator|)
name|esym
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|sym
argument_list|)
expr_stmt|;
operator|*
name|debug_index
operator|=
operator|(
name|unsigned
name|long
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|sym
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_zeroes
operator|==
literal|0
operator|&&
operator|*
name|csectpp
operator|!=
name|NULL
operator|&&
operator|(
operator|!
name|gc
operator|||
operator|(
operator|(
operator|*
name|csectpp
operator|)
operator|->
name|flags
operator|&
name|SEC_MARK
operator|)
operator|!=
literal|0
operator|||
operator|*
name|csectpp
operator|==
name|bfd_abs_section_ptr
operator|)
operator|&&
name|bfd_coff_symname_in_debug
argument_list|(
name|sub
argument_list|,
operator|&
name|sym
argument_list|)
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|bfd_size_type
name|indx
decl_stmt|;
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|debug_contents
operator|+
name|sym
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
expr_stmt|;
name|indx
operator|=
name|_bfd_stringtab_add
argument_list|(
name|debug_strtab
argument_list|,
name|name
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|indx
operator|==
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
condition|)
goto|goto
name|error_return
goto|;
operator|*
name|debug_index
operator|=
name|indx
expr_stmt|;
block|}
name|esym
operator|+=
operator|(
name|sym
operator|.
name|n_numaux
operator|+
literal|1
operator|)
operator|*
name|symesz
expr_stmt|;
name|csectpp
operator|+=
name|sym
operator|.
name|n_numaux
operator|+
literal|1
expr_stmt|;
name|debug_index
operator|+=
name|sym
operator|.
name|n_numaux
operator|+
literal|1
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|debug_contents
argument_list|)
expr_stmt|;
name|debug_contents
operator|=
name|NULL
expr_stmt|;
comment|/* Clear the size of subdeb, so that it is not included directly 	 in the output file.  */
name|subdeb
operator|->
name|_raw_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|keep_memory
condition|)
block|{
if|if
condition|(
operator|!
name|_bfd_coff_free_symbols
argument_list|(
name|sub
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
block|}
if|if
condition|(
name|info
operator|->
name|strip
operator|!=
name|strip_all
condition|)
name|xcoff_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|debug_section
operator|->
name|_raw_size
operator|=
name|_bfd_stringtab_size
argument_list|(
name|debug_strtab
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
name|error_return
label|:
if|if
condition|(
name|ldinfo
operator|.
name|strings
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ldinfo
operator|.
name|strings
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_contents
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug_contents
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|bfd_xcoff_link_generate_rtinit
parameter_list|(
name|abfd
parameter_list|,
name|init
parameter_list|,
name|fini
parameter_list|,
name|rtld
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|char
modifier|*
name|init
decl_stmt|;
specifier|const
name|char
modifier|*
name|fini
decl_stmt|;
name|bfd_boolean
name|rtld
decl_stmt|;
block|{
name|struct
name|bfd_in_memory
modifier|*
name|bim
decl_stmt|;
name|bim
operator|=
operator|(
operator|(
expr|struct
name|bfd_in_memory
operator|*
operator|)
name|bfd_malloc
argument_list|(
operator|(
name|bfd_size_type
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|bfd_in_memory
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|bim
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|bim
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|bim
operator|->
name|buffer
operator|=
literal|0
expr_stmt|;
name|abfd
operator|->
name|link_next
operator|=
literal|0
expr_stmt|;
name|abfd
operator|->
name|format
operator|=
name|bfd_object
expr_stmt|;
name|abfd
operator|->
name|iostream
operator|=
operator|(
name|PTR
operator|)
name|bim
expr_stmt|;
name|abfd
operator|->
name|flags
operator|=
name|BFD_IN_MEMORY
expr_stmt|;
name|abfd
operator|->
name|direction
operator|=
name|write_direction
expr_stmt|;
name|abfd
operator|->
name|where
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_xcoff_generate_rtinit
argument_list|(
name|abfd
argument_list|,
name|init
argument_list|,
name|fini
argument_list|,
name|rtld
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* need to reset to unknown or it will not be read back in correctly */
name|abfd
operator|->
name|format
operator|=
name|bfd_unknown
expr_stmt|;
name|abfd
operator|->
name|direction
operator|=
name|read_direction
expr_stmt|;
name|abfd
operator|->
name|where
operator|=
literal|0
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Add a symbol to the .loader symbols, if necessary.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|xcoff_build_ldsyms
parameter_list|(
name|h
parameter_list|,
name|p
parameter_list|)
name|struct
name|xcoff_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|PTR
name|p
decl_stmt|;
block|{
name|struct
name|xcoff_loader_info
modifier|*
name|ldinfo
init|=
operator|(
expr|struct
name|xcoff_loader_info
operator|*
operator|)
name|p
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|xcoff_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
comment|/* __rtinit, this symbol has special handling. */
if|if
condition|(
name|h
operator|->
name|flags
operator|&
name|XCOFF_RTINIT
condition|)
return|return
name|TRUE
return|;
comment|/* If this is a final link, and the symbol was defined as a common      symbol in a regular object file, and there was no definition in      any dynamic object, then the linker will have allocated space for      the symbol in a common section but the XCOFF_DEF_REGULAR flag      will not have been set.  */
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|&&
operator|(
name|h
operator|->
name|flags
operator|&
name|XCOFF_DEF_REGULAR
operator|)
operator|==
literal|0
operator|&&
operator|(
name|h
operator|->
name|flags
operator|&
name|XCOFF_REF_REGULAR
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|flags
operator|&
name|XCOFF_DEF_DYNAMIC
operator|)
operator|==
literal|0
operator|&&
operator|(
name|bfd_is_abs_section
argument_list|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
argument_list|)
operator|||
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|==
literal|0
operator|)
condition|)
name|h
operator|->
name|flags
operator||=
name|XCOFF_DEF_REGULAR
expr_stmt|;
comment|/* If all defined symbols should be exported, mark them now.  We      don't want to export the actual functions, just the function      descriptors.  */
if|if
condition|(
name|ldinfo
operator|->
name|export_defineds
operator|&&
operator|(
name|h
operator|->
name|flags
operator|&
name|XCOFF_DEF_REGULAR
operator|)
operator|!=
literal|0
operator|&&
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
index|[
literal|0
index|]
operator|!=
literal|'.'
condition|)
block|{
name|bfd_boolean
name|export
decl_stmt|;
comment|/* We don't export a symbol which is being defined by an object 	 included from an archive which contains a shared object.  The 	 rationale is that if an archive contains both an unshared and 	 a shared object, then there must be some reason that the 	 unshared object is unshared, and we don't want to start 	 providing a shared version of it.  In particular, this solves 	 a bug involving the _savefNN set of functions.  gcc will call 	 those functions without providing a slot to restore the TOC, 	 so it is essential that these functions be linked in directly 	 and not from a shared object, which means that a shared 	 object which also happens to link them in must not export 	 them.  This is confusing, but I haven't been able to think of 	 a different approach.  Note that the symbols can, of course, 	 be exported explicitly.  */
name|export
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
operator|->
name|my_archive
operator|!=
name|NULL
condition|)
block|{
name|bfd
modifier|*
name|arbfd
decl_stmt|,
modifier|*
name|member
decl_stmt|;
name|arbfd
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
operator|->
name|my_archive
expr_stmt|;
name|member
operator|=
name|bfd_openr_next_archived_file
argument_list|(
name|arbfd
argument_list|,
operator|(
name|bfd
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
name|member
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|member
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
condition|)
block|{
name|export
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
name|member
operator|=
name|bfd_openr_next_archived_file
argument_list|(
name|arbfd
argument_list|,
name|member
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|export
condition|)
name|h
operator|->
name|flags
operator||=
name|XCOFF_EXPORT
expr_stmt|;
block|}
comment|/* We don't want to garbage collect symbols which are not defined in      XCOFF files.  This is a convenient place to mark them.  */
if|if
condition|(
name|xcoff_hash_table
argument_list|(
name|ldinfo
operator|->
name|info
argument_list|)
operator|->
name|gc
operator|&&
operator|(
name|h
operator|->
name|flags
operator|&
name|XCOFF_MARK
operator|)
operator|==
literal|0
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
operator|==
name|NULL
operator|||
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
operator|->
name|xvec
operator|!=
name|ldinfo
operator|->
name|info
operator|->
name|hash
operator|->
name|creator
operator|)
operator|)
condition|)
name|h
operator|->
name|flags
operator||=
name|XCOFF_MARK
expr_stmt|;
comment|/* If this symbol is called and defined in a dynamic object, or it      is imported, then we need to set up global linkage code for it.      (Unless we did garbage collection and we didn't need this      symbol.)  */
if|if
condition|(
operator|(
name|h
operator|->
name|flags
operator|&
name|XCOFF_CALLED
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|)
operator|&&
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|h
operator|->
name|descriptor
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|h
operator|->
name|descriptor
operator|->
name|flags
operator|&
name|XCOFF_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|||
operator|(
operator|(
name|h
operator|->
name|descriptor
operator|->
name|flags
operator|&
name|XCOFF_IMPORT
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|descriptor
operator|->
name|flags
operator|&
name|XCOFF_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
operator|)
operator|&&
operator|(
operator|!
name|xcoff_hash_table
argument_list|(
name|ldinfo
operator|->
name|info
argument_list|)
operator|->
name|gc
operator|||
operator|(
name|h
operator|->
name|flags
operator|&
name|XCOFF_MARK
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|xcoff_link_hash_entry
modifier|*
name|hds
decl_stmt|;
name|sec
operator|=
name|xcoff_hash_table
argument_list|(
name|ldinfo
operator|->
name|info
argument_list|)
operator|->
name|linkage_section
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|type
operator|=
name|bfd_link_hash_defined
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|sec
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|sec
operator|->
name|_raw_size
expr_stmt|;
name|h
operator|->
name|smclas
operator|=
name|XMC_GL
expr_stmt|;
name|h
operator|->
name|flags
operator||=
name|XCOFF_DEF_REGULAR
expr_stmt|;
name|sec
operator|->
name|_raw_size
operator|+=
name|bfd_xcoff_glink_code_size
argument_list|(
name|ldinfo
operator|->
name|output_bfd
argument_list|)
expr_stmt|;
comment|/* The global linkage code requires a TOC entry for the 	 descriptor.  */
name|hds
operator|=
name|h
operator|->
name|descriptor
expr_stmt|;
name|BFD_ASSERT
argument_list|(
operator|(
name|hds
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
operator|||
name|hds
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|)
operator|&&
operator|(
name|hds
operator|->
name|flags
operator|&
name|XCOFF_DEF_REGULAR
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|hds
operator|->
name|flags
operator||=
name|XCOFF_MARK
expr_stmt|;
if|if
condition|(
name|hds
operator|->
name|toc_section
operator|==
name|NULL
condition|)
block|{
name|int
name|byte_size
decl_stmt|;
comment|/* 32 vs 64 	     xcoff32 uses 4 bytes in the toc. 	     xcoff64 uses 8 bytes in the toc.  */
if|if
condition|(
name|bfd_xcoff_is_xcoff64
argument_list|(
name|ldinfo
operator|->
name|output_bfd
argument_list|)
condition|)
name|byte_size
operator|=
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|bfd_xcoff_is_xcoff32
argument_list|(
name|ldinfo
operator|->
name|output_bfd
argument_list|)
condition|)
name|byte_size
operator|=
literal|4
expr_stmt|;
else|else
return|return
name|FALSE
return|;
name|hds
operator|->
name|toc_section
operator|=
name|xcoff_hash_table
argument_list|(
name|ldinfo
operator|->
name|info
argument_list|)
operator|->
name|toc_section
expr_stmt|;
name|hds
operator|->
name|u
operator|.
name|toc_offset
operator|=
name|hds
operator|->
name|toc_section
operator|->
name|_raw_size
expr_stmt|;
name|hds
operator|->
name|toc_section
operator|->
name|_raw_size
operator|+=
name|byte_size
expr_stmt|;
operator|++
name|xcoff_hash_table
argument_list|(
name|ldinfo
operator|->
name|info
argument_list|)
operator|->
name|ldrel_count
expr_stmt|;
operator|++
name|hds
operator|->
name|toc_section
operator|->
name|reloc_count
expr_stmt|;
name|hds
operator|->
name|indx
operator|=
operator|-
literal|2
expr_stmt|;
name|hds
operator|->
name|flags
operator||=
name|XCOFF_SET_TOC
operator||
name|XCOFF_LDREL
expr_stmt|;
comment|/* We need to call xcoff_build_ldsyms recursively here, 	     because we may already have passed hds on the traversal.  */
name|xcoff_build_ldsyms
argument_list|(
name|hds
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If this symbol is exported, but not defined, we need to try to      define it.  */
if|if
condition|(
operator|(
name|h
operator|->
name|flags
operator|&
name|XCOFF_EXPORT
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|flags
operator|&
name|XCOFF_IMPORT
operator|)
operator|==
literal|0
operator|&&
operator|(
name|h
operator|->
name|flags
operator|&
name|XCOFF_DEF_REGULAR
operator|)
operator|==
literal|0
operator|&&
operator|(
name|h
operator|->
name|flags
operator|&
name|XCOFF_DEF_DYNAMIC
operator|)
operator|==
literal|0
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|h
operator|->
name|flags
operator|&
name|XCOFF_DESCRIPTOR
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|descriptor
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|descriptor
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
condition|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
comment|/* This is an undefined function descriptor associated with 	     a defined entry point.  We can build up a function 	     descriptor ourselves.  Believe it or not, the AIX linker 	     actually does this, and there are cases where we need to 	     do it as well.  */
name|sec
operator|=
name|xcoff_hash_table
argument_list|(
name|ldinfo
operator|->
name|info
argument_list|)
operator|->
name|descriptor_section
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|type
operator|=
name|bfd_link_hash_defined
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|sec
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|sec
operator|->
name|_raw_size
expr_stmt|;
name|h
operator|->
name|smclas
operator|=
name|XMC_DS
expr_stmt|;
name|h
operator|->
name|flags
operator||=
name|XCOFF_DEF_REGULAR
expr_stmt|;
comment|/* The size of the function descriptor depends if this is an 	     xcoff32 (12) or xcoff64 (24).  */
name|sec
operator|->
name|_raw_size
operator|+=
name|bfd_xcoff_function_descriptor_size
argument_list|(
name|ldinfo
operator|->
name|output_bfd
argument_list|)
expr_stmt|;
comment|/* A function descriptor uses two relocs: one for the 	     associated code, and one for the TOC address.  */
name|xcoff_hash_table
argument_list|(
name|ldinfo
operator|->
name|info
argument_list|)
operator|->
name|ldrel_count
operator|+=
literal|2
expr_stmt|;
name|sec
operator|->
name|reloc_count
operator|+=
literal|2
expr_stmt|;
comment|/* We handle writing out the contents of the descriptor in 	     xcoff_write_global_symbol.  */
block|}
else|else
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"warning: attempt to export undefined symbol `%s'"
argument_list|)
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
name|h
operator|->
name|ldsym
operator|=
name|NULL
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
comment|/* If this is still a common symbol, and it wasn't garbage      collected, we need to actually allocate space for it in the .bss      section.  */
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_common
operator|&&
operator|(
operator|!
name|xcoff_hash_table
argument_list|(
name|ldinfo
operator|->
name|info
argument_list|)
operator|->
name|gc
operator|||
operator|(
name|h
operator|->
name|flags
operator|&
name|XCOFF_MARK
operator|)
operator|!=
literal|0
operator|)
operator|&&
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
operator|->
name|_raw_size
operator|==
literal|0
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|bfd_is_com_section
argument_list|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
operator|->
name|_raw_size
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|size
expr_stmt|;
block|}
comment|/* We need to add a symbol to the .loader section if it is mentioned      in a reloc which we are copying to the .loader section and it was      not defined or common, or if it is the entry point, or if it is      being exported.  */
if|if
condition|(
operator|(
operator|(
name|h
operator|->
name|flags
operator|&
name|XCOFF_LDREL
operator|)
operator|==
literal|0
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_common
operator|)
operator|&&
operator|(
name|h
operator|->
name|flags
operator|&
name|XCOFF_ENTRY
operator|)
operator|==
literal|0
operator|&&
operator|(
name|h
operator|->
name|flags
operator|&
name|XCOFF_EXPORT
operator|)
operator|==
literal|0
condition|)
block|{
name|h
operator|->
name|ldsym
operator|=
name|NULL
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* We don't need to add this symbol if we did garbage collection and      we did not mark this symbol.  */
if|if
condition|(
name|xcoff_hash_table
argument_list|(
name|ldinfo
operator|->
name|info
argument_list|)
operator|->
name|gc
operator|&&
operator|(
name|h
operator|->
name|flags
operator|&
name|XCOFF_MARK
operator|)
operator|==
literal|0
condition|)
block|{
name|h
operator|->
name|ldsym
operator|=
name|NULL
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* We may have already processed this symbol due to the recursive      call above.  */
if|if
condition|(
operator|(
name|h
operator|->
name|flags
operator|&
name|XCOFF_BUILT_LDSYM
operator|)
operator|!=
literal|0
condition|)
return|return
name|TRUE
return|;
comment|/* We need to add this symbol to the .loader symbols.  */
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|ldsym
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|internal_ldsym
argument_list|)
expr_stmt|;
name|h
operator|->
name|ldsym
operator|=
operator|(
expr|struct
name|internal_ldsym
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|ldinfo
operator|->
name|output_bfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|ldsym
operator|==
name|NULL
condition|)
block|{
name|ldinfo
operator|->
name|failed
operator|=
name|TRUE
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|(
name|h
operator|->
name|flags
operator|&
name|XCOFF_IMPORT
operator|)
operator|!=
literal|0
condition|)
name|h
operator|->
name|ldsym
operator|->
name|l_ifile
operator|=
name|h
operator|->
name|ldindx
expr_stmt|;
comment|/* The first 3 symbol table indices are reserved to indicate the      data, text and bss sections.  */
name|h
operator|->
name|ldindx
operator|=
name|ldinfo
operator|->
name|ldsym_count
operator|+
literal|3
expr_stmt|;
operator|++
name|ldinfo
operator|->
name|ldsym_count
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_xcoff_put_ldsymbol_name
argument_list|(
name|ldinfo
operator|->
name|output_bfd
argument_list|,
name|ldinfo
argument_list|,
name|h
operator|->
name|ldsym
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
condition|)
block|{
return|return
name|FALSE
return|;
block|}
name|h
operator|->
name|flags
operator||=
name|XCOFF_BUILT_LDSYM
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Do the final link step.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_xcoff_bfd_final_link
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|bfd_size_type
name|symesz
decl_stmt|;
name|struct
name|xcoff_final_link_info
name|finfo
decl_stmt|;
name|asection
modifier|*
name|o
decl_stmt|;
name|struct
name|bfd_link_order
modifier|*
name|p
decl_stmt|;
name|bfd_size_type
name|max_contents_size
decl_stmt|;
name|bfd_size_type
name|max_sym_count
decl_stmt|;
name|bfd_size_type
name|max_lineno_count
decl_stmt|;
name|bfd_size_type
name|max_reloc_count
decl_stmt|;
name|bfd_size_type
name|max_output_reloc_count
decl_stmt|;
name|file_ptr
name|rel_filepos
decl_stmt|;
name|unsigned
name|int
name|relsz
decl_stmt|;
name|file_ptr
name|line_filepos
decl_stmt|;
name|unsigned
name|int
name|linesz
decl_stmt|;
name|bfd
modifier|*
name|sub
decl_stmt|;
name|bfd_byte
modifier|*
name|external_relocs
init|=
name|NULL
decl_stmt|;
name|char
name|strbuf
index|[
name|STRING_SIZE_SIZE
index|]
decl_stmt|;
name|file_ptr
name|pos
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
name|abfd
operator|->
name|flags
operator||=
name|DYNAMIC
expr_stmt|;
name|symesz
operator|=
name|bfd_coff_symesz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|info
operator|=
name|info
expr_stmt|;
name|finfo
operator|.
name|output_bfd
operator|=
name|abfd
expr_stmt|;
name|finfo
operator|.
name|strtab
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|section_info
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|last_file_index
operator|=
operator|-
literal|1
expr_stmt|;
name|finfo
operator|.
name|toc_symindx
operator|=
operator|-
literal|1
expr_stmt|;
name|finfo
operator|.
name|internal_syms
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|sym_indices
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|outsyms
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|linenos
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|contents
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|external_relocs
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|ldsym
operator|=
operator|(
name|xcoff_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|loader_section
operator|->
name|contents
operator|+
name|bfd_xcoff_ldhdrsz
argument_list|(
name|abfd
argument_list|)
operator|)
expr_stmt|;
name|finfo
operator|.
name|ldrel
operator|=
operator|(
name|xcoff_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|loader_section
operator|->
name|contents
operator|+
name|bfd_xcoff_ldhdrsz
argument_list|(
name|abfd
argument_list|)
operator|+
operator|(
name|xcoff_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|ldhdr
operator|.
name|l_nsyms
operator|*
name|bfd_xcoff_ldsymsz
argument_list|(
name|abfd
argument_list|)
operator|)
operator|)
expr_stmt|;
name|xcoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|coff
operator|.
name|link_info
operator|=
name|info
expr_stmt|;
name|finfo
operator|.
name|strtab
operator|=
name|_bfd_stringtab_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|strtab
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
comment|/* Count the line number and relocation entries required for the      output file.  Determine a few maximum sizes.  */
name|max_contents_size
operator|=
literal|0
expr_stmt|;
name|max_lineno_count
operator|=
literal|0
expr_stmt|;
name|max_reloc_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
name|o
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
name|o
operator|->
name|lineno_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|o
operator|->
name|link_order_head
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_indirect_link_order
condition|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|sec
operator|=
name|p
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
expr_stmt|;
comment|/* Mark all sections which are to be included in the 		 link.  This will normally be every section.  We need 		 to do this so that we can identify any sections which 		 the linker has decided to not include.  */
name|sec
operator|->
name|linker_mark
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|strip
operator|==
name|strip_none
operator|||
name|info
operator|->
name|strip
operator|==
name|strip_some
condition|)
name|o
operator|->
name|lineno_count
operator|+=
name|sec
operator|->
name|lineno_count
expr_stmt|;
name|o
operator|->
name|reloc_count
operator|+=
name|sec
operator|->
name|reloc_count
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|_raw_size
operator|>
name|max_contents_size
condition|)
name|max_contents_size
operator|=
name|sec
operator|->
name|_raw_size
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|lineno_count
operator|>
name|max_lineno_count
condition|)
name|max_lineno_count
operator|=
name|sec
operator|->
name|lineno_count
expr_stmt|;
if|if
condition|(
name|coff_section_data
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|sec
argument_list|)
operator|!=
name|NULL
operator|&&
name|xcoff_section_data
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|sec
argument_list|)
operator|!=
name|NULL
operator|&&
operator|(
name|xcoff_section_data
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|sec
argument_list|)
operator|->
name|lineno_count
operator|>
name|max_lineno_count
operator|)
condition|)
name|max_lineno_count
operator|=
name|xcoff_section_data
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|sec
argument_list|)
operator|->
name|lineno_count
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|reloc_count
operator|>
name|max_reloc_count
condition|)
name|max_reloc_count
operator|=
name|sec
operator|->
name|reloc_count
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_section_reloc_link_order
operator|||
name|p
operator|->
name|type
operator|==
name|bfd_symbol_reloc_link_order
condition|)
operator|++
name|o
operator|->
name|reloc_count
expr_stmt|;
block|}
block|}
comment|/* Compute the file positions for all the sections.  */
if|if
condition|(
name|abfd
operator|->
name|output_has_begun
condition|)
block|{
if|if
condition|(
name|xcoff_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|file_align
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|bfd_vma
name|file_align
decl_stmt|;
name|file_align
operator|=
name|xcoff_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|file_align
expr_stmt|;
if|if
condition|(
name|file_align
operator|!=
literal|0
condition|)
block|{
name|bfd_boolean
name|saw_contents
decl_stmt|;
name|int
name|indx
decl_stmt|;
name|asection
modifier|*
modifier|*
name|op
decl_stmt|;
name|file_ptr
name|sofar
decl_stmt|;
comment|/* Insert .pad sections before every section which has 	     contents and is loaded, if it is preceded by some other 	     section which has contents and is loaded.  */
name|saw_contents
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|op
operator|=
operator|&
name|abfd
operator|->
name|sections
init|;
operator|*
name|op
operator|!=
name|NULL
condition|;
name|op
operator|=
operator|&
operator|(
operator|*
name|op
operator|)
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|(
operator|*
name|op
operator|)
operator|->
name|name
argument_list|,
literal|".pad"
argument_list|)
operator|==
literal|0
condition|)
name|saw_contents
operator|=
name|FALSE
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|(
operator|*
name|op
operator|)
operator|->
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
operator|*
name|op
operator|)
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|saw_contents
condition|)
name|saw_contents
operator|=
name|TRUE
expr_stmt|;
else|else
block|{
name|asection
modifier|*
name|n
decl_stmt|,
modifier|*
modifier|*
name|st
decl_stmt|;
comment|/* Create a pad section and place it before the section 			 that needs padding.  This requires unlinking and 			 relinking the bfd's section list.  */
name|st
operator|=
name|abfd
operator|->
name|section_tail
expr_stmt|;
name|n
operator|=
name|bfd_make_section_anyway
argument_list|(
name|abfd
argument_list|,
literal|".pad"
argument_list|)
expr_stmt|;
name|n
operator|->
name|flags
operator|=
name|SEC_HAS_CONTENTS
expr_stmt|;
name|n
operator|->
name|alignment_power
operator|=
literal|0
expr_stmt|;
name|BFD_ASSERT
argument_list|(
operator|*
name|st
operator|==
name|n
argument_list|)
expr_stmt|;
name|bfd_section_list_remove
argument_list|(
name|abfd
argument_list|,
name|st
argument_list|)
expr_stmt|;
name|bfd_section_list_insert
argument_list|(
name|abfd
argument_list|,
name|op
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|op
operator|=
operator|&
name|n
operator|->
name|next
expr_stmt|;
name|saw_contents
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
block|}
comment|/* Reset the section indices after inserting the new 	     sections.  */
name|indx
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
operator|++
name|indx
expr_stmt|;
name|o
operator|->
name|target_index
operator|=
name|indx
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|indx
operator|==
name|abfd
operator|->
name|section_count
argument_list|)
expr_stmt|;
comment|/* Work out appropriate sizes for the .pad sections to force 	     each section to land on a page boundary.  This bit of 	     code knows what compute_section_file_positions is going 	     to do.  */
name|sofar
operator|=
name|bfd_coff_filhsz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|sofar
operator|+=
name|bfd_coff_aoutsz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|sofar
operator|+=
name|abfd
operator|->
name|section_count
operator|*
name|bfd_coff_scnhsz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
if|if
condition|(
operator|(
name|bfd_xcoff_is_reloc_count_overflow
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|o
operator|->
name|reloc_count
argument_list|)
operator|)
operator|||
operator|(
name|bfd_xcoff_is_lineno_count_overflow
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|o
operator|->
name|lineno_count
argument_list|)
operator|)
condition|)
comment|/* 64 does not overflow, need to check if 32 does */
name|sofar
operator|+=
name|bfd_coff_scnhsz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|o
operator|->
name|name
argument_list|,
literal|".pad"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|bfd_vma
name|pageoff
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|o
operator|->
name|_raw_size
operator|==
literal|0
argument_list|)
expr_stmt|;
name|pageoff
operator|=
name|sofar
operator|&
operator|(
name|file_align
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|pageoff
operator|!=
literal|0
condition|)
block|{
name|o
operator|->
name|_raw_size
operator|=
name|file_align
operator|-
name|pageoff
expr_stmt|;
name|sofar
operator|+=
name|file_align
operator|-
name|pageoff
expr_stmt|;
name|o
operator|->
name|flags
operator||=
name|SEC_HAS_CONTENTS
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|!=
literal|0
condition|)
name|sofar
operator|+=
name|BFD_ALIGN
argument_list|(
name|o
operator|->
name|_raw_size
argument_list|,
literal|1
operator|<<
name|o
operator|->
name|alignment_power
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|bfd_coff_compute_section_file_positions
argument_list|(
name|abfd
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
comment|/* Allocate space for the pointers we need to keep for the relocs.  */
block|{
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* We use section_count + 1, rather than section_count, because        the target_index fields are 1 based.  */
name|amt
operator|=
name|abfd
operator|->
name|section_count
operator|+
literal|1
expr_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
expr|struct
name|xcoff_link_section_info
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|section_info
operator|=
operator|(
expr|struct
name|xcoff_link_section_info
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|section_info
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|abfd
operator|->
name|section_count
condition|;
name|i
operator|++
control|)
block|{
name|finfo
operator|.
name|section_info
index|[
name|i
index|]
operator|.
name|relocs
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|section_info
index|[
name|i
index|]
operator|.
name|rel_hashes
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|section_info
index|[
name|i
index|]
operator|.
name|toc_rel_hashes
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* Set the file positions for the relocs.  */
name|rel_filepos
operator|=
name|obj_relocbase
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|relsz
operator|=
name|bfd_coff_relsz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|max_output_reloc_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
if|if
condition|(
name|o
operator|->
name|reloc_count
operator|==
literal|0
condition|)
name|o
operator|->
name|rel_filepos
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* A stripped file has no relocs.  However, we still 	     allocate the buffers, so that later code doesn't have to 	     worry about whether we are stripping or not.  */
if|if
condition|(
name|info
operator|->
name|strip
operator|==
name|strip_all
condition|)
name|o
operator|->
name|rel_filepos
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|o
operator|->
name|flags
operator||=
name|SEC_RELOC
expr_stmt|;
name|o
operator|->
name|rel_filepos
operator|=
name|rel_filepos
expr_stmt|;
name|rel_filepos
operator|+=
name|o
operator|->
name|reloc_count
operator|*
name|relsz
expr_stmt|;
block|}
comment|/* We don't know the indices of global symbols until we have 	     written out all the local symbols.  For each section in 	     the output file, we keep an array of pointers to hash 	     table entries.  Each entry in the array corresponds to a 	     reloc.  When we find a reloc against a global symbol, we 	     set the corresponding entry in this array so that we can 	     fix up the symbol index after we have written out all the 	     local symbols.  	     Because of this problem, we also keep the relocs in 	     memory until the end of the link.  This wastes memory. 	     We could backpatch the file later, I suppose, although it 	     would be slow.  */
name|amt
operator|=
name|o
operator|->
name|reloc_count
expr_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
expr|struct
name|internal_reloc
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|section_info
index|[
name|o
operator|->
name|target_index
index|]
operator|.
name|relocs
operator|=
operator|(
expr|struct
name|internal_reloc
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
name|amt
operator|=
name|o
operator|->
name|reloc_count
expr_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
expr|struct
name|xcoff_link_hash_entry
operator|*
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|section_info
index|[
name|o
operator|->
name|target_index
index|]
operator|.
name|rel_hashes
operator|=
operator|(
expr|struct
name|xcoff_link_hash_entry
operator|*
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|section_info
index|[
name|o
operator|->
name|target_index
index|]
operator|.
name|relocs
operator|==
name|NULL
operator|||
name|finfo
operator|.
name|section_info
index|[
name|o
operator|->
name|target_index
index|]
operator|.
name|rel_hashes
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|o
operator|->
name|reloc_count
operator|>
name|max_output_reloc_count
condition|)
name|max_output_reloc_count
operator|=
name|o
operator|->
name|reloc_count
expr_stmt|;
block|}
block|}
comment|/* We now know the size of the relocs, so we can determine the file      positions of the line numbers.  */
name|line_filepos
operator|=
name|rel_filepos
expr_stmt|;
name|finfo
operator|.
name|line_filepos
operator|=
name|line_filepos
expr_stmt|;
name|linesz
operator|=
name|bfd_coff_linesz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
if|if
condition|(
name|o
operator|->
name|lineno_count
operator|==
literal|0
condition|)
name|o
operator|->
name|line_filepos
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|o
operator|->
name|line_filepos
operator|=
name|line_filepos
expr_stmt|;
name|line_filepos
operator|+=
name|o
operator|->
name|lineno_count
operator|*
name|linesz
expr_stmt|;
block|}
comment|/* Reset the reloc and lineno counts, so that we can use them to 	 count the number of entries we have output so far.  */
name|o
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
name|o
operator|->
name|lineno_count
operator|=
literal|0
expr_stmt|;
block|}
name|obj_sym_filepos
argument_list|(
name|abfd
argument_list|)
operator|=
name|line_filepos
expr_stmt|;
comment|/* Figure out the largest number of symbols in an input BFD.  Take      the opportunity to clear the output_has_begun fields of all the      input BFD's.  We want at least 6 symbols, since that is the      number which xcoff_write_global_symbol may need.  */
name|max_sym_count
operator|=
literal|6
expr_stmt|;
for|for
control|(
name|sub
operator|=
name|info
operator|->
name|input_bfds
init|;
name|sub
operator|!=
name|NULL
condition|;
name|sub
operator|=
name|sub
operator|->
name|link_next
control|)
block|{
name|bfd_size_type
name|sz
decl_stmt|;
name|sub
operator|->
name|output_has_begun
operator|=
name|FALSE
expr_stmt|;
name|sz
operator|=
name|obj_raw_syment_count
argument_list|(
name|sub
argument_list|)
expr_stmt|;
if|if
condition|(
name|sz
operator|>
name|max_sym_count
condition|)
name|max_sym_count
operator|=
name|sz
expr_stmt|;
block|}
comment|/* Allocate some buffers used while linking.  */
name|amt
operator|=
name|max_sym_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|internal_syment
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|internal_syms
operator|=
operator|(
expr|struct
name|internal_syment
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
name|amt
operator|=
name|max_sym_count
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|sym_indices
operator|=
operator|(
name|long
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
name|amt
operator|=
operator|(
name|max_sym_count
operator|+
literal|1
operator|)
operator|*
name|symesz
expr_stmt|;
name|finfo
operator|.
name|outsyms
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
name|amt
operator|=
name|max_lineno_count
operator|*
name|bfd_coff_linesz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|linenos
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
name|amt
operator|=
name|max_contents_size
expr_stmt|;
name|finfo
operator|.
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
name|amt
operator|=
name|max_reloc_count
operator|*
name|relsz
expr_stmt|;
name|finfo
operator|.
name|external_relocs
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|finfo
operator|.
name|internal_syms
operator|==
name|NULL
operator|&&
name|max_sym_count
operator|>
literal|0
operator|)
operator|||
operator|(
name|finfo
operator|.
name|sym_indices
operator|==
name|NULL
operator|&&
name|max_sym_count
operator|>
literal|0
operator|)
operator|||
name|finfo
operator|.
name|outsyms
operator|==
name|NULL
operator|||
operator|(
name|finfo
operator|.
name|linenos
operator|==
name|NULL
operator|&&
name|max_lineno_count
operator|>
literal|0
operator|)
operator|||
operator|(
name|finfo
operator|.
name|contents
operator|==
name|NULL
operator|&&
name|max_contents_size
operator|>
literal|0
operator|)
operator|||
operator|(
name|finfo
operator|.
name|external_relocs
operator|==
name|NULL
operator|&&
name|max_reloc_count
operator|>
literal|0
operator|)
condition|)
goto|goto
name|error_return
goto|;
name|obj_raw_syment_count
argument_list|(
name|abfd
argument_list|)
operator|=
literal|0
expr_stmt|;
name|xcoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|toc
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* We now know the position of everything in the file, except that      we don't know the size of the symbol table and therefore we don't      know where the string table starts.  We just build the string      table in memory as we go along.  We process all the relocations      for a single input file at once.  */
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
for|for
control|(
name|p
operator|=
name|o
operator|->
name|link_order_head
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_indirect_link_order
operator|&&
name|p
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
operator|->
name|owner
operator|->
name|xvec
operator|==
name|abfd
operator|->
name|xvec
condition|)
block|{
name|sub
operator|=
name|p
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
operator|->
name|owner
expr_stmt|;
if|if
condition|(
operator|!
name|sub
operator|->
name|output_has_begun
condition|)
block|{
if|if
condition|(
operator|!
name|xcoff_link_input_bfd
argument_list|(
operator|&
name|finfo
argument_list|,
name|sub
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
name|sub
operator|->
name|output_has_begun
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_section_reloc_link_order
operator|||
name|p
operator|->
name|type
operator|==
name|bfd_symbol_reloc_link_order
condition|)
block|{
if|if
condition|(
operator|!
name|xcoff_reloc_link_order
argument_list|(
name|abfd
argument_list|,
operator|&
name|finfo
argument_list|,
name|o
argument_list|,
name|p
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|_bfd_default_link_order
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|o
argument_list|,
name|p
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
block|}
block|}
comment|/* Free up the buffers used by xcoff_link_input_bfd.  */
if|if
condition|(
name|finfo
operator|.
name|internal_syms
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|finfo
operator|.
name|internal_syms
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|internal_syms
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|finfo
operator|.
name|sym_indices
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|finfo
operator|.
name|sym_indices
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|sym_indices
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|finfo
operator|.
name|linenos
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|finfo
operator|.
name|linenos
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|linenos
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|finfo
operator|.
name|contents
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|finfo
operator|.
name|contents
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|contents
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|finfo
operator|.
name|external_relocs
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|finfo
operator|.
name|external_relocs
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|external_relocs
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* The value of the last C_FILE symbol is supposed to be -1.  Write      it out again.  */
if|if
condition|(
name|finfo
operator|.
name|last_file_index
operator|!=
operator|-
literal|1
condition|)
block|{
name|finfo
operator|.
name|last_file
operator|.
name|n_value
operator|=
operator|-
operator|(
name|bfd_vma
operator|)
literal|1
expr_stmt|;
name|bfd_coff_swap_sym_out
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|finfo
operator|.
name|last_file
argument_list|,
operator|(
name|PTR
operator|)
name|finfo
operator|.
name|outsyms
argument_list|)
expr_stmt|;
name|pos
operator|=
name|obj_sym_filepos
argument_list|(
name|abfd
argument_list|)
operator|+
name|finfo
operator|.
name|last_file_index
operator|*
name|symesz
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|pos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bwrite
argument_list|(
name|finfo
operator|.
name|outsyms
argument_list|,
name|symesz
argument_list|,
name|abfd
argument_list|)
operator|!=
name|symesz
condition|)
goto|goto
name|error_return
goto|;
block|}
comment|/* Write out all the global symbols which do not come from XCOFF      input files.  */
name|xcoff_link_hash_traverse
argument_list|(
name|xcoff_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|xcoff_write_global_symbol
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|finfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|outsyms
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|finfo
operator|.
name|outsyms
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|outsyms
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Now that we have written out all the global symbols, we know the      symbol indices to use for relocs against them, and we can finally      write out the relocs.  */
name|amt
operator|=
name|max_output_reloc_count
operator|*
name|relsz
expr_stmt|;
name|external_relocs
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|external_relocs
operator|==
name|NULL
operator|&&
name|max_output_reloc_count
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
name|struct
name|internal_reloc
modifier|*
name|irel
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|irelend
decl_stmt|;
name|struct
name|xcoff_link_hash_entry
modifier|*
modifier|*
name|rel_hash
decl_stmt|;
name|struct
name|xcoff_toc_rel_hash
modifier|*
name|toc_rel_hash
decl_stmt|;
name|bfd_byte
modifier|*
name|erel
decl_stmt|;
name|bfd_size_type
name|rel_size
decl_stmt|;
comment|/* A stripped file has no relocs.  */
if|if
condition|(
name|info
operator|->
name|strip
operator|==
name|strip_all
condition|)
block|{
name|o
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|o
operator|->
name|reloc_count
operator|==
literal|0
condition|)
continue|continue;
name|irel
operator|=
name|finfo
operator|.
name|section_info
index|[
name|o
operator|->
name|target_index
index|]
operator|.
name|relocs
expr_stmt|;
name|irelend
operator|=
name|irel
operator|+
name|o
operator|->
name|reloc_count
expr_stmt|;
name|rel_hash
operator|=
name|finfo
operator|.
name|section_info
index|[
name|o
operator|->
name|target_index
index|]
operator|.
name|rel_hashes
expr_stmt|;
for|for
control|(
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
operator|,
name|rel_hash
operator|++
operator|,
name|erel
operator|+=
name|relsz
control|)
block|{
if|if
condition|(
operator|*
name|rel_hash
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|rel_hash
operator|)
operator|->
name|indx
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|unattached_reloc
call|)
argument_list|(
name|info
argument_list|,
operator|(
operator|*
name|rel_hash
operator|)
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
operator|(
name|bfd
operator|*
operator|)
name|NULL
argument_list|,
name|o
argument_list|,
name|irel
operator|->
name|r_vaddr
argument_list|)
operator|)
condition|)
goto|goto
name|error_return
goto|;
operator|(
operator|*
name|rel_hash
operator|)
operator|->
name|indx
operator|=
literal|0
expr_stmt|;
block|}
name|irel
operator|->
name|r_symndx
operator|=
operator|(
operator|*
name|rel_hash
operator|)
operator|->
name|indx
expr_stmt|;
block|}
block|}
for|for
control|(
name|toc_rel_hash
operator|=
name|finfo
operator|.
name|section_info
index|[
name|o
operator|->
name|target_index
index|]
operator|.
name|toc_rel_hashes
init|;
name|toc_rel_hash
operator|!=
name|NULL
condition|;
name|toc_rel_hash
operator|=
name|toc_rel_hash
operator|->
name|next
control|)
block|{
if|if
condition|(
name|toc_rel_hash
operator|->
name|h
operator|->
name|u
operator|.
name|toc_indx
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|unattached_reloc
call|)
argument_list|(
name|info
argument_list|,
name|toc_rel_hash
operator|->
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
operator|(
name|bfd
operator|*
operator|)
name|NULL
argument_list|,
name|o
argument_list|,
name|toc_rel_hash
operator|->
name|rel
operator|->
name|r_vaddr
argument_list|)
operator|)
condition|)
goto|goto
name|error_return
goto|;
name|toc_rel_hash
operator|->
name|h
operator|->
name|u
operator|.
name|toc_indx
operator|=
literal|0
expr_stmt|;
block|}
name|toc_rel_hash
operator|->
name|rel
operator|->
name|r_symndx
operator|=
name|toc_rel_hash
operator|->
name|h
operator|->
name|u
operator|.
name|toc_indx
expr_stmt|;
block|}
comment|/* XCOFF requires that the relocs be sorted by address.  We tend 	 to produce them in the order in which their containing csects 	 appear in the symbol table, which is not necessarily by 	 address.  So we sort them here.  There may be a better way to 	 do this.  */
name|qsort
argument_list|(
operator|(
name|PTR
operator|)
name|finfo
operator|.
name|section_info
index|[
name|o
operator|->
name|target_index
index|]
operator|.
name|relocs
argument_list|,
name|o
operator|->
name|reloc_count
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|internal_reloc
argument_list|)
argument_list|,
name|xcoff_sort_relocs
argument_list|)
expr_stmt|;
name|irel
operator|=
name|finfo
operator|.
name|section_info
index|[
name|o
operator|->
name|target_index
index|]
operator|.
name|relocs
expr_stmt|;
name|irelend
operator|=
name|irel
operator|+
name|o
operator|->
name|reloc_count
expr_stmt|;
name|erel
operator|=
name|external_relocs
expr_stmt|;
for|for
control|(
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
operator|,
name|rel_hash
operator|++
operator|,
name|erel
operator|+=
name|relsz
control|)
name|bfd_coff_swap_reloc_out
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|irel
argument_list|,
operator|(
name|PTR
operator|)
name|erel
argument_list|)
expr_stmt|;
name|rel_size
operator|=
name|relsz
operator|*
name|o
operator|->
name|reloc_count
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|o
operator|->
name|rel_filepos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bwrite
argument_list|(
operator|(
name|PTR
operator|)
name|external_relocs
argument_list|,
name|rel_size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|rel_size
condition|)
goto|goto
name|error_return
goto|;
block|}
if|if
condition|(
name|external_relocs
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|external_relocs
argument_list|)
expr_stmt|;
name|external_relocs
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Free up the section information.  */
if|if
condition|(
name|finfo
operator|.
name|section_info
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|abfd
operator|->
name|section_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|finfo
operator|.
name|section_info
index|[
name|i
index|]
operator|.
name|relocs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|section_info
index|[
name|i
index|]
operator|.
name|relocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|section_info
index|[
name|i
index|]
operator|.
name|rel_hashes
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|section_info
index|[
name|i
index|]
operator|.
name|rel_hashes
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|finfo
operator|.
name|section_info
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|section_info
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Write out the loader section contents.  */
name|BFD_ASSERT
argument_list|(
operator|(
name|bfd_byte
operator|*
operator|)
name|finfo
operator|.
name|ldrel
operator|==
operator|(
name|xcoff_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|loader_section
operator|->
name|contents
operator|+
name|xcoff_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|ldhdr
operator|.
name|l_impoff
operator|)
argument_list|)
expr_stmt|;
name|o
operator|=
name|xcoff_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|loader_section
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|o
operator|->
name|output_section
argument_list|,
name|o
operator|->
name|contents
argument_list|,
operator|(
name|file_ptr
operator|)
name|o
operator|->
name|output_offset
argument_list|,
name|o
operator|->
name|_raw_size
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* Write out the magic sections.  */
name|o
operator|=
name|xcoff_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|linkage_section
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|_raw_size
operator|>
literal|0
operator|&&
operator|!
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|o
operator|->
name|output_section
argument_list|,
name|o
operator|->
name|contents
argument_list|,
operator|(
name|file_ptr
operator|)
name|o
operator|->
name|output_offset
argument_list|,
name|o
operator|->
name|_raw_size
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
name|o
operator|=
name|xcoff_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|toc_section
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|_raw_size
operator|>
literal|0
operator|&&
operator|!
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|o
operator|->
name|output_section
argument_list|,
name|o
operator|->
name|contents
argument_list|,
operator|(
name|file_ptr
operator|)
name|o
operator|->
name|output_offset
argument_list|,
name|o
operator|->
name|_raw_size
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
name|o
operator|=
name|xcoff_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|descriptor_section
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|_raw_size
operator|>
literal|0
operator|&&
operator|!
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|o
operator|->
name|output_section
argument_list|,
name|o
operator|->
name|contents
argument_list|,
operator|(
name|file_ptr
operator|)
name|o
operator|->
name|output_offset
argument_list|,
name|o
operator|->
name|_raw_size
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* Write out the string table.  */
name|pos
operator|=
name|obj_sym_filepos
argument_list|(
name|abfd
argument_list|)
operator|+
name|obj_raw_syment_count
argument_list|(
name|abfd
argument_list|)
operator|*
name|symesz
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|pos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|_bfd_stringtab_size
argument_list|(
name|finfo
operator|.
name|strtab
argument_list|)
operator|+
name|STRING_SIZE_SIZE
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
name|amt
operator|=
name|STRING_SIZE_SIZE
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
name|strbuf
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|_bfd_stringtab_emit
argument_list|(
name|abfd
argument_list|,
name|finfo
operator|.
name|strtab
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
name|_bfd_stringtab_free
argument_list|(
name|finfo
operator|.
name|strtab
argument_list|)
expr_stmt|;
comment|/* Write out the debugging string table.  */
name|o
operator|=
name|xcoff_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|debug_section
expr_stmt|;
if|if
condition|(
name|o
operator|!=
name|NULL
condition|)
block|{
name|struct
name|bfd_strtab_hash
modifier|*
name|debug_strtab
decl_stmt|;
name|debug_strtab
operator|=
name|xcoff_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|debug_strtab
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|o
operator|->
name|output_section
operator|->
name|_raw_size
operator|-
name|o
operator|->
name|output_offset
operator|>=
name|_bfd_stringtab_size
argument_list|(
name|debug_strtab
argument_list|)
argument_list|)
expr_stmt|;
name|pos
operator|=
name|o
operator|->
name|output_section
operator|->
name|filepos
operator|+
name|o
operator|->
name|output_offset
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|pos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|_bfd_stringtab_emit
argument_list|(
name|abfd
argument_list|,
name|debug_strtab
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
comment|/* Setting bfd_get_symcount to 0 will cause write_object_contents to      not try to write out the symbols.  */
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|TRUE
return|;
name|error_return
label|:
if|if
condition|(
name|finfo
operator|.
name|strtab
operator|!=
name|NULL
condition|)
name|_bfd_stringtab_free
argument_list|(
name|finfo
operator|.
name|strtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|section_info
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|abfd
operator|->
name|section_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|finfo
operator|.
name|section_info
index|[
name|i
index|]
operator|.
name|relocs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|section_info
index|[
name|i
index|]
operator|.
name|relocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|section_info
index|[
name|i
index|]
operator|.
name|rel_hashes
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|section_info
index|[
name|i
index|]
operator|.
name|rel_hashes
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|finfo
operator|.
name|section_info
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|finfo
operator|.
name|internal_syms
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|internal_syms
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|sym_indices
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|sym_indices
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|outsyms
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|outsyms
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|linenos
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|linenos
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|contents
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|contents
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|.
name|external_relocs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|finfo
operator|.
name|external_relocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|external_relocs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|external_relocs
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Link an input file into the linker output file.  This function    handles all the sections and relocations of the input file at once.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|xcoff_link_input_bfd
parameter_list|(
name|finfo
parameter_list|,
name|input_bfd
parameter_list|)
name|struct
name|xcoff_final_link_info
modifier|*
name|finfo
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
block|{
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
specifier|const
name|char
modifier|*
name|strings
decl_stmt|;
name|bfd_size_type
name|syment_base
decl_stmt|;
name|unsigned
name|int
name|n_tmask
decl_stmt|;
name|unsigned
name|int
name|n_btshft
decl_stmt|;
name|bfd_boolean
name|copy
decl_stmt|,
name|hash
decl_stmt|;
name|bfd_size_type
name|isymesz
decl_stmt|;
name|bfd_size_type
name|osymesz
decl_stmt|;
name|bfd_size_type
name|linesz
decl_stmt|;
name|bfd_byte
modifier|*
name|esym
decl_stmt|;
name|bfd_byte
modifier|*
name|esym_end
decl_stmt|;
name|struct
name|xcoff_link_hash_entry
modifier|*
modifier|*
name|sym_hash
decl_stmt|;
name|struct
name|internal_syment
modifier|*
name|isymp
decl_stmt|;
name|asection
modifier|*
modifier|*
name|csectpp
decl_stmt|;
name|unsigned
name|long
modifier|*
name|debug_index
decl_stmt|;
name|long
modifier|*
name|indexp
decl_stmt|;
name|unsigned
name|long
name|output_index
decl_stmt|;
name|bfd_byte
modifier|*
name|outsym
decl_stmt|;
name|unsigned
name|int
name|incls
decl_stmt|;
name|asection
modifier|*
name|oline
decl_stmt|;
name|bfd_boolean
name|keep_syms
decl_stmt|;
name|asection
modifier|*
name|o
decl_stmt|;
comment|/* We can just skip DYNAMIC files, unless this is a static link.  */
if|if
condition|(
operator|(
name|input_bfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|finfo
operator|->
name|info
operator|->
name|static_link
condition|)
return|return
name|TRUE
return|;
comment|/* Move all the symbols to the output file.  */
name|output_bfd
operator|=
name|finfo
operator|->
name|output_bfd
expr_stmt|;
name|strings
operator|=
name|NULL
expr_stmt|;
name|syment_base
operator|=
name|obj_raw_syment_count
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
name|isymesz
operator|=
name|bfd_coff_symesz
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|osymesz
operator|=
name|bfd_coff_symesz
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
name|linesz
operator|=
name|bfd_coff_linesz
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|linesz
operator|==
name|bfd_coff_linesz
argument_list|(
name|output_bfd
argument_list|)
argument_list|)
expr_stmt|;
name|n_tmask
operator|=
name|coff_data
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|local_n_tmask
expr_stmt|;
name|n_btshft
operator|=
name|coff_data
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|local_n_btshft
expr_stmt|;
comment|/* Define macros so that ISFCN, et. al., macros work correctly.  */
define|#
directive|define
name|N_TMASK
value|n_tmask
define|#
directive|define
name|N_BTSHFT
value|n_btshft
name|copy
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|finfo
operator|->
name|info
operator|->
name|keep_memory
condition|)
name|copy
operator|=
name|TRUE
expr_stmt|;
name|hash
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|(
name|output_bfd
operator|->
name|flags
operator|&
name|BFD_TRADITIONAL_FORMAT
operator|)
operator|!=
literal|0
condition|)
name|hash
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|_bfd_coff_get_external_symbols
argument_list|(
name|input_bfd
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|esym
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|obj_coff_external_syms
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|esym_end
operator|=
name|esym
operator|+
name|obj_raw_syment_count
argument_list|(
name|input_bfd
argument_list|)
operator|*
name|isymesz
expr_stmt|;
name|sym_hash
operator|=
name|obj_xcoff_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|csectpp
operator|=
name|xcoff_data
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|csects
expr_stmt|;
name|debug_index
operator|=
name|xcoff_data
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|debug_indices
expr_stmt|;
name|isymp
operator|=
name|finfo
operator|->
name|internal_syms
expr_stmt|;
name|indexp
operator|=
name|finfo
operator|->
name|sym_indices
expr_stmt|;
name|output_index
operator|=
name|syment_base
expr_stmt|;
name|outsym
operator|=
name|finfo
operator|->
name|outsyms
expr_stmt|;
name|incls
operator|=
literal|0
expr_stmt|;
name|oline
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|esym
operator|<
name|esym_end
condition|)
block|{
name|struct
name|internal_syment
name|isym
decl_stmt|;
name|union
name|internal_auxent
name|aux
decl_stmt|;
name|int
name|smtyp
init|=
literal|0
decl_stmt|;
name|bfd_boolean
name|skip
decl_stmt|;
name|bfd_boolean
name|require
decl_stmt|;
name|int
name|add
decl_stmt|;
name|bfd_coff_swap_sym_in
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|PTR
operator|)
name|esym
argument_list|,
operator|(
name|PTR
operator|)
name|isymp
argument_list|)
expr_stmt|;
comment|/* If this is a C_EXT or C_HIDEXT symbol, we need the csect 	 information.  */
if|if
condition|(
name|isymp
operator|->
name|n_sclass
operator|==
name|C_EXT
operator|||
name|isymp
operator|->
name|n_sclass
operator|==
name|C_HIDEXT
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|isymp
operator|->
name|n_numaux
operator|>
literal|0
argument_list|)
expr_stmt|;
name|bfd_coff_swap_aux_in
argument_list|(
name|input_bfd
argument_list|,
call|(
name|PTR
call|)
argument_list|(
name|esym
operator|+
name|isymesz
operator|*
name|isymp
operator|->
name|n_numaux
argument_list|)
argument_list|,
name|isymp
operator|->
name|n_type
argument_list|,
name|isymp
operator|->
name|n_sclass
argument_list|,
name|isymp
operator|->
name|n_numaux
operator|-
literal|1
argument_list|,
name|isymp
operator|->
name|n_numaux
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|aux
argument_list|)
expr_stmt|;
name|smtyp
operator|=
name|SMTYP_SMTYP
argument_list|(
name|aux
operator|.
name|x_csect
operator|.
name|x_smtyp
argument_list|)
expr_stmt|;
block|}
comment|/* Make a copy of *isymp so that the relocate_section function 	 always sees the original values.  This is more reliable than 	 always recomputing the symbol value even if we are stripping 	 the symbol.  */
name|isym
operator|=
operator|*
name|isymp
expr_stmt|;
comment|/* If this symbol is in the .loader section, swap out the 	 .loader symbol information.  If this is an external symbol 	 reference to a defined symbol, though, then wait until we get 	 to the definition.  */
if|if
condition|(
name|isym
operator|.
name|n_sclass
operator|==
name|C_EXT
operator|&&
operator|*
name|sym_hash
operator|!=
name|NULL
operator|&&
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|ldsym
operator|!=
name|NULL
operator|&&
operator|(
name|smtyp
operator|!=
name|XTY_ER
operator|||
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
operator|)
condition|)
block|{
name|struct
name|xcoff_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|internal_ldsym
modifier|*
name|ldsym
decl_stmt|;
name|h
operator|=
operator|*
name|sym_hash
expr_stmt|;
name|ldsym
operator|=
name|h
operator|->
name|ldsym
expr_stmt|;
if|if
condition|(
name|isym
operator|.
name|n_scnum
operator|>
literal|0
condition|)
block|{
name|ldsym
operator|->
name|l_scnum
operator|=
operator|(
operator|*
name|csectpp
operator|)
operator|->
name|output_section
operator|->
name|target_index
expr_stmt|;
name|ldsym
operator|->
name|l_value
operator|=
operator|(
name|isym
operator|.
name|n_value
operator|+
operator|(
operator|*
name|csectpp
operator|)
operator|->
name|output_section
operator|->
name|vma
operator|+
operator|(
operator|*
name|csectpp
operator|)
operator|->
name|output_offset
operator|-
operator|(
operator|*
name|csectpp
operator|)
operator|->
name|vma
operator|)
expr_stmt|;
block|}
else|else
block|{
name|ldsym
operator|->
name|l_scnum
operator|=
name|isym
operator|.
name|n_scnum
expr_stmt|;
name|ldsym
operator|->
name|l_value
operator|=
name|isym
operator|.
name|n_value
expr_stmt|;
block|}
name|ldsym
operator|->
name|l_smtype
operator|=
name|smtyp
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|h
operator|->
name|flags
operator|&
name|XCOFF_DEF_REGULAR
operator|)
operator|==
literal|0
operator|&&
operator|(
name|h
operator|->
name|flags
operator|&
name|XCOFF_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|h
operator|->
name|flags
operator|&
name|XCOFF_IMPORT
operator|)
operator|!=
literal|0
condition|)
name|ldsym
operator|->
name|l_smtype
operator||=
name|L_IMPORT
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|h
operator|->
name|flags
operator|&
name|XCOFF_DEF_REGULAR
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|flags
operator|&
name|XCOFF_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|h
operator|->
name|flags
operator|&
name|XCOFF_EXPORT
operator|)
operator|!=
literal|0
condition|)
name|ldsym
operator|->
name|l_smtype
operator||=
name|L_EXPORT
expr_stmt|;
if|if
condition|(
operator|(
name|h
operator|->
name|flags
operator|&
name|XCOFF_ENTRY
operator|)
operator|!=
literal|0
condition|)
name|ldsym
operator|->
name|l_smtype
operator||=
name|L_ENTRY
expr_stmt|;
name|ldsym
operator|->
name|l_smclas
operator|=
name|aux
operator|.
name|x_csect
operator|.
name|x_smclas
expr_stmt|;
if|if
condition|(
name|ldsym
operator|->
name|l_ifile
operator|==
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
condition|)
name|ldsym
operator|->
name|l_ifile
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|ldsym
operator|->
name|l_ifile
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ldsym
operator|->
name|l_smtype
operator|&
name|L_IMPORT
operator|)
operator|==
literal|0
condition|)
name|ldsym
operator|->
name|l_ifile
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|bfd
modifier|*
name|impbfd
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
name|impbfd
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
name|impbfd
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|undef
operator|.
name|abfd
expr_stmt|;
else|else
name|impbfd
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|impbfd
operator|==
name|NULL
condition|)
name|ldsym
operator|->
name|l_ifile
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|BFD_ASSERT
argument_list|(
name|impbfd
operator|->
name|xvec
operator|==
name|finfo
operator|->
name|output_bfd
operator|->
name|xvec
argument_list|)
expr_stmt|;
name|ldsym
operator|->
name|l_ifile
operator|=
name|xcoff_data
argument_list|(
name|impbfd
argument_list|)
operator|->
name|import_file_id
expr_stmt|;
block|}
block|}
block|}
name|ldsym
operator|->
name|l_parm
operator|=
literal|0
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|ldindx
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|bfd_xcoff_swap_ldsym_out
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|,
name|ldsym
argument_list|,
operator|(
name|finfo
operator|->
name|ldsym
operator|+
operator|(
operator|(
name|h
operator|->
name|ldindx
operator|-
literal|3
operator|)
operator|*
name|bfd_xcoff_ldsymsz
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|)
operator|)
operator|)
argument_list|)
expr_stmt|;
name|h
operator|->
name|ldsym
operator|=
name|NULL
expr_stmt|;
comment|/* Fill in snentry now that we know the target_index.  */
if|if
condition|(
operator|(
name|h
operator|->
name|flags
operator|&
name|XCOFF_ENTRY
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
condition|)
block|{
name|xcoff_data
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|snentry
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|target_index
expr_stmt|;
block|}
block|}
operator|*
name|indexp
operator|=
operator|-
literal|1
expr_stmt|;
name|skip
operator|=
name|FALSE
expr_stmt|;
name|require
operator|=
name|FALSE
expr_stmt|;
name|add
operator|=
literal|1
operator|+
name|isym
operator|.
name|n_numaux
expr_stmt|;
comment|/* If we are skipping this csect, we want to skip this symbol.  */
if|if
condition|(
operator|*
name|csectpp
operator|==
name|NULL
condition|)
name|skip
operator|=
name|TRUE
expr_stmt|;
comment|/* If we garbage collected this csect, we want to skip this 	 symbol.  */
if|if
condition|(
operator|!
name|skip
operator|&&
name|xcoff_hash_table
argument_list|(
name|finfo
operator|->
name|info
argument_list|)
operator|->
name|gc
operator|&&
operator|(
operator|(
operator|*
name|csectpp
operator|)
operator|->
name|flags
operator|&
name|SEC_MARK
operator|)
operator|==
literal|0
operator|&&
operator|*
name|csectpp
operator|!=
name|bfd_abs_section_ptr
condition|)
name|skip
operator|=
name|TRUE
expr_stmt|;
comment|/* An XCOFF linker always skips C_STAT symbols.  */
if|if
condition|(
operator|!
name|skip
operator|&&
name|isymp
operator|->
name|n_sclass
operator|==
name|C_STAT
condition|)
name|skip
operator|=
name|TRUE
expr_stmt|;
comment|/* We skip all but the first TOC anchor.  */
if|if
condition|(
operator|!
name|skip
operator|&&
name|isymp
operator|->
name|n_sclass
operator|==
name|C_HIDEXT
operator|&&
name|aux
operator|.
name|x_csect
operator|.
name|x_smclas
operator|==
name|XMC_TC0
condition|)
block|{
if|if
condition|(
name|finfo
operator|->
name|toc_symindx
operator|!=
operator|-
literal|1
condition|)
name|skip
operator|=
name|TRUE
expr_stmt|;
else|else
block|{
name|bfd_vma
name|tocval
decl_stmt|,
name|tocend
decl_stmt|;
name|bfd
modifier|*
name|inp
decl_stmt|;
name|tocval
operator|=
operator|(
operator|(
operator|*
name|csectpp
operator|)
operator|->
name|output_section
operator|->
name|vma
operator|+
operator|(
operator|*
name|csectpp
operator|)
operator|->
name|output_offset
operator|+
name|isym
operator|.
name|n_value
operator|-
operator|(
operator|*
name|csectpp
operator|)
operator|->
name|vma
operator|)
expr_stmt|;
comment|/* We want to find out if tocval is a good value to use 		 as the TOC anchor--that is, whether we can access all 		 of the TOC using a 16 bit offset from tocval.  This 		 test assumes that the TOC comes at the end of the 		 output section, as it does in the default linker 		 script.  */
name|tocend
operator|=
operator|(
operator|(
operator|*
name|csectpp
operator|)
operator|->
name|output_section
operator|->
name|vma
operator|+
operator|(
operator|*
name|csectpp
operator|)
operator|->
name|output_section
operator|->
name|_raw_size
operator|)
expr_stmt|;
for|for
control|(
name|inp
operator|=
name|finfo
operator|->
name|info
operator|->
name|input_bfds
init|;
name|inp
operator|!=
name|NULL
condition|;
name|inp
operator|=
name|inp
operator|->
name|link_next
control|)
block|{
for|for
control|(
name|o
operator|=
name|inp
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|o
operator|->
name|name
argument_list|,
literal|".tocbss"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|bfd_vma
name|new_toc_end
decl_stmt|;
name|new_toc_end
operator|=
operator|(
name|o
operator|->
name|output_section
operator|->
name|vma
operator|+
name|o
operator|->
name|output_offset
operator|+
name|o
operator|->
name|_cooked_size
operator|)
expr_stmt|;
if|if
condition|(
name|new_toc_end
operator|>
name|tocend
condition|)
name|tocend
operator|=
name|new_toc_end
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tocval
operator|+
literal|0x10000
operator|<
name|tocend
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"TOC overflow: 0x%lx> 0x10000; try -mminimal-toc when compiling"
argument_list|)
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|tocend
operator|-
name|tocval
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_file_too_big
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|tocval
operator|+
literal|0x8000
operator|<
name|tocend
condition|)
block|{
name|bfd_vma
name|tocadd
decl_stmt|;
name|tocadd
operator|=
name|tocend
operator|-
operator|(
name|tocval
operator|+
literal|0x8000
operator|)
expr_stmt|;
name|tocval
operator|+=
name|tocadd
expr_stmt|;
name|isym
operator|.
name|n_value
operator|+=
name|tocadd
expr_stmt|;
block|}
name|finfo
operator|->
name|toc_symindx
operator|=
name|output_index
expr_stmt|;
name|xcoff_data
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|)
operator|->
name|toc
operator|=
name|tocval
expr_stmt|;
name|xcoff_data
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|)
operator|->
name|sntoc
operator|=
operator|(
operator|*
name|csectpp
operator|)
operator|->
name|output_section
operator|->
name|target_index
expr_stmt|;
name|require
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
comment|/* If we are stripping all symbols, we want to skip this one.  */
if|if
condition|(
operator|!
name|skip
operator|&&
name|finfo
operator|->
name|info
operator|->
name|strip
operator|==
name|strip_all
condition|)
name|skip
operator|=
name|TRUE
expr_stmt|;
comment|/* We can skip resolved external references.  */
if|if
condition|(
operator|!
name|skip
operator|&&
name|isym
operator|.
name|n_sclass
operator|==
name|C_EXT
operator|&&
name|smtyp
operator|==
name|XTY_ER
operator|&&
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefined
condition|)
name|skip
operator|=
name|TRUE
expr_stmt|;
comment|/* We can skip common symbols if they got defined somewhere 	 else.  */
if|if
condition|(
operator|!
name|skip
operator|&&
name|isym
operator|.
name|n_sclass
operator|==
name|C_EXT
operator|&&
name|smtyp
operator|==
name|XTY_CM
operator|&&
operator|(
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_common
operator|||
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
operator|!=
operator|*
name|csectpp
operator|)
operator|&&
operator|(
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defined
operator|||
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|!=
operator|*
name|csectpp
operator|)
condition|)
name|skip
operator|=
name|TRUE
expr_stmt|;
comment|/* Skip local symbols if we are discarding them.  */
if|if
condition|(
operator|!
name|skip
operator|&&
name|finfo
operator|->
name|info
operator|->
name|discard
operator|==
name|discard_all
operator|&&
name|isym
operator|.
name|n_sclass
operator|!=
name|C_EXT
operator|&&
operator|(
name|isym
operator|.
name|n_sclass
operator|!=
name|C_HIDEXT
operator|||
name|smtyp
operator|!=
name|XTY_SD
operator|)
condition|)
name|skip
operator|=
name|TRUE
expr_stmt|;
comment|/* If we stripping debugging symbols, and this is a debugging 	 symbol, then skip it.  */
if|if
condition|(
operator|!
name|skip
operator|&&
name|finfo
operator|->
name|info
operator|->
name|strip
operator|==
name|strip_debugger
operator|&&
name|isym
operator|.
name|n_scnum
operator|==
name|N_DEBUG
condition|)
name|skip
operator|=
name|TRUE
expr_stmt|;
comment|/* If some symbols are stripped based on the name, work out the 	 name and decide whether to skip this symbol.  We don't handle 	 this correctly for symbols whose names are in the .debug 	 section; to get it right we would need a new bfd_strtab_hash 	 function to return the string given the index.  */
if|if
condition|(
operator|!
name|skip
operator|&&
operator|(
name|finfo
operator|->
name|info
operator|->
name|strip
operator|==
name|strip_some
operator|||
name|finfo
operator|->
name|info
operator|->
name|discard
operator|==
name|discard_l
operator|)
operator|&&
operator|(
name|debug_index
operator|==
name|NULL
operator|||
operator|*
name|debug_index
operator|==
operator|(
name|unsigned
name|long
operator|)
operator|-
literal|1
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|buf
index|[
name|SYMNMLEN
operator|+
literal|1
index|]
decl_stmt|;
name|name
operator|=
name|_bfd_coff_internal_syment_name
argument_list|(
name|input_bfd
argument_list|,
operator|&
name|isym
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|(
name|finfo
operator|->
name|info
operator|->
name|strip
operator|==
name|strip_some
operator|&&
operator|(
name|bfd_hash_lookup
argument_list|(
name|finfo
operator|->
name|info
operator|->
name|keep_hash
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
operator|==
name|NULL
operator|)
operator|)
operator|||
operator|(
name|finfo
operator|->
name|info
operator|->
name|discard
operator|==
name|discard_l
operator|&&
operator|(
name|isym
operator|.
name|n_sclass
operator|!=
name|C_EXT
operator|&&
operator|(
name|isym
operator|.
name|n_sclass
operator|!=
name|C_HIDEXT
operator|||
name|smtyp
operator|!=
name|XTY_SD
operator|)
operator|)
operator|&&
name|bfd_is_local_label_name
argument_list|(
name|input_bfd
argument_list|,
name|name
argument_list|)
operator|)
condition|)
name|skip
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* We can not skip the first TOC anchor.  */
if|if
condition|(
name|skip
operator|&&
name|require
operator|&&
name|finfo
operator|->
name|info
operator|->
name|strip
operator|!=
name|strip_all
condition|)
name|skip
operator|=
name|FALSE
expr_stmt|;
comment|/* We now know whether we are to skip this symbol or not.  */
if|if
condition|(
operator|!
name|skip
condition|)
block|{
comment|/* Adjust the symbol in order to output it.  */
if|if
condition|(
name|isym
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_zeroes
operator|==
literal|0
operator|&&
name|isym
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
operator|!=
literal|0
condition|)
block|{
comment|/* This symbol has a long name.  Enter it in the string 		 table we are building.  If *debug_index != -1, the 		 name has already been entered in the .debug section.  */
if|if
condition|(
name|debug_index
operator|!=
name|NULL
operator|&&
operator|*
name|debug_index
operator|!=
operator|(
name|unsigned
name|long
operator|)
operator|-
literal|1
condition|)
name|isym
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
operator|=
operator|*
name|debug_index
expr_stmt|;
else|else
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bfd_size_type
name|indx
decl_stmt|;
name|name
operator|=
name|_bfd_coff_internal_syment_name
argument_list|(
name|input_bfd
argument_list|,
operator|&
name|isym
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|indx
operator|=
name|_bfd_stringtab_add
argument_list|(
name|finfo
operator|->
name|strtab
argument_list|,
name|name
argument_list|,
name|hash
argument_list|,
name|copy
argument_list|)
expr_stmt|;
if|if
condition|(
name|indx
operator|==
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
condition|)
return|return
name|FALSE
return|;
name|isym
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
operator|=
name|STRING_SIZE_SIZE
operator|+
name|indx
expr_stmt|;
block|}
block|}
if|if
condition|(
name|isym
operator|.
name|n_sclass
operator|!=
name|C_BSTAT
operator|&&
name|isym
operator|.
name|n_sclass
operator|!=
name|C_ESTAT
operator|&&
name|isym
operator|.
name|n_sclass
operator|!=
name|C_DECL
operator|&&
name|isym
operator|.
name|n_scnum
operator|>
literal|0
condition|)
block|{
name|isym
operator|.
name|n_scnum
operator|=
operator|(
operator|*
name|csectpp
operator|)
operator|->
name|output_section
operator|->
name|target_index
expr_stmt|;
name|isym
operator|.
name|n_value
operator|+=
operator|(
operator|(
operator|*
name|csectpp
operator|)
operator|->
name|output_section
operator|->
name|vma
operator|+
operator|(
operator|*
name|csectpp
operator|)
operator|->
name|output_offset
operator|-
operator|(
operator|*
name|csectpp
operator|)
operator|->
name|vma
operator|)
expr_stmt|;
block|}
comment|/* The value of a C_FILE symbol is the symbol index of the 	     next C_FILE symbol.  The value of the last C_FILE symbol 	     is -1.  We try to get this right, below, just before we 	     write the symbols out, but in the general case we may 	     have to write the symbol out twice.  */
if|if
condition|(
name|isym
operator|.
name|n_sclass
operator|==
name|C_FILE
condition|)
block|{
if|if
condition|(
name|finfo
operator|->
name|last_file_index
operator|!=
operator|-
literal|1
operator|&&
name|finfo
operator|->
name|last_file
operator|.
name|n_value
operator|!=
operator|(
name|bfd_vma
operator|)
name|output_index
condition|)
block|{
comment|/* We must correct the value of the last C_FILE entry.  */
name|finfo
operator|->
name|last_file
operator|.
name|n_value
operator|=
name|output_index
expr_stmt|;
if|if
condition|(
operator|(
name|bfd_size_type
operator|)
name|finfo
operator|->
name|last_file_index
operator|>=
name|syment_base
condition|)
block|{
comment|/* The last C_FILE symbol is in this input file.  */
name|bfd_coff_swap_sym_out
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|finfo
operator|->
name|last_file
argument_list|,
call|(
name|PTR
call|)
argument_list|(
name|finfo
operator|->
name|outsyms
operator|+
operator|(
operator|(
name|finfo
operator|->
name|last_file_index
operator|-
name|syment_base
operator|)
operator|*
name|osymesz
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We have already written out the last C_FILE 			 symbol.  We need to write it out again.  We 			 borrow *outsym temporarily.  */
name|file_ptr
name|pos
decl_stmt|;
name|bfd_coff_swap_sym_out
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|finfo
operator|->
name|last_file
argument_list|,
operator|(
name|PTR
operator|)
name|outsym
argument_list|)
expr_stmt|;
name|pos
operator|=
name|obj_sym_filepos
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|finfo
operator|->
name|last_file_index
operator|*
name|osymesz
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|output_bfd
argument_list|,
name|pos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|bfd_bwrite
argument_list|(
name|outsym
argument_list|,
name|osymesz
argument_list|,
name|output_bfd
argument_list|)
operator|!=
name|osymesz
operator|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
name|finfo
operator|->
name|last_file_index
operator|=
name|output_index
expr_stmt|;
name|finfo
operator|->
name|last_file
operator|=
name|isym
expr_stmt|;
block|}
comment|/* The value of a C_BINCL or C_EINCL symbol is a file offset 	     into the line numbers.  We update the symbol values when 	     we handle the line numbers.  */
if|if
condition|(
name|isym
operator|.
name|n_sclass
operator|==
name|C_BINCL
operator|||
name|isym
operator|.
name|n_sclass
operator|==
name|C_EINCL
condition|)
block|{
name|isym
operator|.
name|n_value
operator|=
name|finfo
operator|->
name|line_filepos
expr_stmt|;
operator|++
name|incls
expr_stmt|;
block|}
comment|/* Output the symbol.  */
name|bfd_coff_swap_sym_out
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|isym
argument_list|,
operator|(
name|PTR
operator|)
name|outsym
argument_list|)
expr_stmt|;
operator|*
name|indexp
operator|=
name|output_index
expr_stmt|;
if|if
condition|(
name|isym
operator|.
name|n_sclass
operator|==
name|C_EXT
condition|)
block|{
name|long
name|indx
decl_stmt|;
name|struct
name|xcoff_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|indx
operator|=
operator|(
operator|(
name|esym
operator|-
operator|(
name|bfd_byte
operator|*
operator|)
name|obj_coff_external_syms
argument_list|(
name|input_bfd
argument_list|)
operator|)
operator|/
name|isymesz
operator|)
expr_stmt|;
name|h
operator|=
name|obj_xcoff_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
index|[
name|indx
index|]
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|h
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|h
operator|->
name|indx
operator|=
name|output_index
expr_stmt|;
block|}
comment|/* If this is a symbol in the TOC which we may have merged 	     (class XMC_TC), remember the symbol index of the TOC 	     symbol.  */
if|if
condition|(
name|isym
operator|.
name|n_sclass
operator|==
name|C_HIDEXT
operator|&&
name|aux
operator|.
name|x_csect
operator|.
name|x_smclas
operator|==
name|XMC_TC
operator|&&
operator|*
name|sym_hash
operator|!=
name|NULL
condition|)
block|{
name|BFD_ASSERT
argument_list|(
operator|(
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|flags
operator|&
name|XCOFF_SET_TOC
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|toc_section
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|u
operator|.
name|toc_indx
operator|=
name|output_index
expr_stmt|;
block|}
name|output_index
operator|+=
name|add
expr_stmt|;
name|outsym
operator|+=
name|add
operator|*
name|osymesz
expr_stmt|;
block|}
name|esym
operator|+=
name|add
operator|*
name|isymesz
expr_stmt|;
name|isymp
operator|+=
name|add
expr_stmt|;
name|csectpp
operator|+=
name|add
expr_stmt|;
name|sym_hash
operator|+=
name|add
expr_stmt|;
if|if
condition|(
name|debug_index
operator|!=
name|NULL
condition|)
name|debug_index
operator|+=
name|add
expr_stmt|;
operator|++
name|indexp
expr_stmt|;
for|for
control|(
operator|--
name|add
init|;
name|add
operator|>
literal|0
condition|;
operator|--
name|add
control|)
operator|*
name|indexp
operator|++
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Fix up the aux entries and the C_BSTAT symbols.  This must be      done in a separate pass, because we don't know the correct symbol      indices until we have already decided which symbols we are going      to keep.  */
name|esym
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|obj_coff_external_syms
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|esym_end
operator|=
name|esym
operator|+
name|obj_raw_syment_count
argument_list|(
name|input_bfd
argument_list|)
operator|*
name|isymesz
expr_stmt|;
name|isymp
operator|=
name|finfo
operator|->
name|internal_syms
expr_stmt|;
name|indexp
operator|=
name|finfo
operator|->
name|sym_indices
expr_stmt|;
name|csectpp
operator|=
name|xcoff_data
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|csects
expr_stmt|;
name|outsym
operator|=
name|finfo
operator|->
name|outsyms
expr_stmt|;
while|while
condition|(
name|esym
operator|<
name|esym_end
condition|)
block|{
name|int
name|add
decl_stmt|;
name|add
operator|=
literal|1
operator|+
name|isymp
operator|->
name|n_numaux
expr_stmt|;
if|if
condition|(
operator|*
name|indexp
operator|<
literal|0
condition|)
name|esym
operator|+=
name|add
operator|*
name|isymesz
expr_stmt|;
else|else
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|isymp
operator|->
name|n_sclass
operator|==
name|C_BSTAT
condition|)
block|{
name|struct
name|internal_syment
name|isym
decl_stmt|;
name|bfd_vma
name|indx
decl_stmt|;
comment|/* The value of a C_BSTAT symbol is the symbol table 		 index of the containing csect.  */
name|bfd_coff_swap_sym_in
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|PTR
operator|)
name|outsym
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|isym
argument_list|)
expr_stmt|;
name|indx
operator|=
name|isym
operator|.
name|n_value
expr_stmt|;
if|if
condition|(
name|indx
operator|<
name|obj_raw_syment_count
argument_list|(
name|input_bfd
argument_list|)
condition|)
block|{
name|long
name|symindx
decl_stmt|;
name|symindx
operator|=
name|finfo
operator|->
name|sym_indices
index|[
name|indx
index|]
expr_stmt|;
if|if
condition|(
name|symindx
operator|<
literal|0
condition|)
name|isym
operator|.
name|n_value
operator|=
literal|0
expr_stmt|;
else|else
name|isym
operator|.
name|n_value
operator|=
name|symindx
expr_stmt|;
name|bfd_coff_swap_sym_out
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|isym
argument_list|,
operator|(
name|PTR
operator|)
name|outsym
argument_list|)
expr_stmt|;
block|}
block|}
name|esym
operator|+=
name|isymesz
expr_stmt|;
name|outsym
operator|+=
name|osymesz
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|isymp
operator|->
name|n_numaux
operator|&&
name|esym
operator|<
name|esym_end
condition|;
name|i
operator|++
control|)
block|{
name|union
name|internal_auxent
name|aux
decl_stmt|;
name|bfd_coff_swap_aux_in
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|PTR
operator|)
name|esym
argument_list|,
name|isymp
operator|->
name|n_type
argument_list|,
name|isymp
operator|->
name|n_sclass
argument_list|,
name|i
argument_list|,
name|isymp
operator|->
name|n_numaux
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|aux
argument_list|)
expr_stmt|;
if|if
condition|(
name|isymp
operator|->
name|n_sclass
operator|==
name|C_FILE
condition|)
block|{
comment|/* This is the file name (or some comment put in by 		     the compiler).  If it is long, we must put it in 		     the string table.  */
if|if
condition|(
name|aux
operator|.
name|x_file
operator|.
name|x_n
operator|.
name|x_zeroes
operator|==
literal|0
operator|&&
name|aux
operator|.
name|x_file
operator|.
name|x_n
operator|.
name|x_offset
operator|!=
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|bfd_size_type
name|indx
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|aux
operator|.
name|x_file
operator|.
name|x_n
operator|.
name|x_offset
operator|>=
name|STRING_SIZE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|strings
operator|==
name|NULL
condition|)
block|{
name|strings
operator|=
name|_bfd_coff_read_string_table
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|strings
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
name|filename
operator|=
name|strings
operator|+
name|aux
operator|.
name|x_file
operator|.
name|x_n
operator|.
name|x_offset
expr_stmt|;
name|indx
operator|=
name|_bfd_stringtab_add
argument_list|(
name|finfo
operator|->
name|strtab
argument_list|,
name|filename
argument_list|,
name|hash
argument_list|,
name|copy
argument_list|)
expr_stmt|;
if|if
condition|(
name|indx
operator|==
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
condition|)
return|return
name|FALSE
return|;
name|aux
operator|.
name|x_file
operator|.
name|x_n
operator|.
name|x_offset
operator|=
name|STRING_SIZE_SIZE
operator|+
name|indx
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|isymp
operator|->
name|n_sclass
operator|==
name|C_EXT
operator|||
name|isymp
operator|->
name|n_sclass
operator|==
name|C_HIDEXT
operator|)
operator|&&
name|i
operator|+
literal|1
operator|==
name|isymp
operator|->
name|n_numaux
condition|)
block|{
comment|/* We don't support type checking.  I don't know if 		     anybody does.  */
name|aux
operator|.
name|x_csect
operator|.
name|x_parmhash
operator|=
literal|0
expr_stmt|;
comment|/* I don't think anybody uses these fields, but we'd 		     better clobber them just in case.  */
name|aux
operator|.
name|x_csect
operator|.
name|x_stab
operator|=
literal|0
expr_stmt|;
name|aux
operator|.
name|x_csect
operator|.
name|x_snstab
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|SMTYP_SMTYP
argument_list|(
name|aux
operator|.
name|x_csect
operator|.
name|x_smtyp
argument_list|)
operator|==
name|XTY_LD
condition|)
block|{
name|unsigned
name|long
name|indx
decl_stmt|;
name|indx
operator|=
name|aux
operator|.
name|x_csect
operator|.
name|x_scnlen
operator|.
name|l
expr_stmt|;
if|if
condition|(
name|indx
operator|<
name|obj_raw_syment_count
argument_list|(
name|input_bfd
argument_list|)
condition|)
block|{
name|long
name|symindx
decl_stmt|;
name|symindx
operator|=
name|finfo
operator|->
name|sym_indices
index|[
name|indx
index|]
expr_stmt|;
if|if
condition|(
name|symindx
operator|<
literal|0
condition|)
block|{
name|aux
operator|.
name|x_csect
operator|.
name|x_scnlen
operator|.
name|l
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|aux
operator|.
name|x_csect
operator|.
name|x_scnlen
operator|.
name|l
operator|=
name|symindx
expr_stmt|;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|isymp
operator|->
name|n_sclass
operator|!=
name|C_STAT
operator|||
name|isymp
operator|->
name|n_type
operator|!=
name|T_NULL
condition|)
block|{
name|unsigned
name|long
name|indx
decl_stmt|;
if|if
condition|(
name|ISFCN
argument_list|(
name|isymp
operator|->
name|n_type
argument_list|)
operator|||
name|ISTAG
argument_list|(
name|isymp
operator|->
name|n_sclass
argument_list|)
operator|||
name|isymp
operator|->
name|n_sclass
operator|==
name|C_BLOCK
operator|||
name|isymp
operator|->
name|n_sclass
operator|==
name|C_FCN
condition|)
block|{
name|indx
operator|=
name|aux
operator|.
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_endndx
operator|.
name|l
expr_stmt|;
if|if
condition|(
name|indx
operator|>
literal|0
operator|&&
name|indx
operator|<
name|obj_raw_syment_count
argument_list|(
name|input_bfd
argument_list|)
condition|)
block|{
comment|/* We look forward through the symbol for 			     the index of the next symbol we are going 			     to include.  I don't know if this is 			     entirely right.  */
while|while
condition|(
name|finfo
operator|->
name|sym_indices
index|[
name|indx
index|]
operator|<
literal|0
operator|&&
name|indx
operator|<
name|obj_raw_syment_count
argument_list|(
name|input_bfd
argument_list|)
condition|)
operator|++
name|indx
expr_stmt|;
if|if
condition|(
name|indx
operator|>=
name|obj_raw_syment_count
argument_list|(
name|input_bfd
argument_list|)
condition|)
name|indx
operator|=
name|output_index
expr_stmt|;
else|else
name|indx
operator|=
name|finfo
operator|->
name|sym_indices
index|[
name|indx
index|]
expr_stmt|;
name|aux
operator|.
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_endndx
operator|.
name|l
operator|=
name|indx
expr_stmt|;
block|}
block|}
name|indx
operator|=
name|aux
operator|.
name|x_sym
operator|.
name|x_tagndx
operator|.
name|l
expr_stmt|;
if|if
condition|(
name|indx
operator|>
literal|0
operator|&&
name|indx
operator|<
name|obj_raw_syment_count
argument_list|(
name|input_bfd
argument_list|)
condition|)
block|{
name|long
name|symindx
decl_stmt|;
name|symindx
operator|=
name|finfo
operator|->
name|sym_indices
index|[
name|indx
index|]
expr_stmt|;
if|if
condition|(
name|symindx
operator|<
literal|0
condition|)
name|aux
operator|.
name|x_sym
operator|.
name|x_tagndx
operator|.
name|l
operator|=
literal|0
expr_stmt|;
else|else
name|aux
operator|.
name|x_sym
operator|.
name|x_tagndx
operator|.
name|l
operator|=
name|symindx
expr_stmt|;
block|}
block|}
comment|/* Copy over the line numbers, unless we are stripping 		 them.  We do this on a symbol by symbol basis in 		 order to more easily handle garbage collection.  */
if|if
condition|(
operator|(
name|isymp
operator|->
name|n_sclass
operator|==
name|C_EXT
operator|||
name|isymp
operator|->
name|n_sclass
operator|==
name|C_HIDEXT
operator|)
operator|&&
name|i
operator|==
literal|0
operator|&&
name|isymp
operator|->
name|n_numaux
operator|>
literal|1
operator|&&
name|ISFCN
argument_list|(
name|isymp
operator|->
name|n_type
argument_list|)
operator|&&
name|aux
operator|.
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_lnnoptr
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|finfo
operator|->
name|info
operator|->
name|strip
operator|!=
name|strip_none
operator|&&
name|finfo
operator|->
name|info
operator|->
name|strip
operator|!=
name|strip_some
condition|)
name|aux
operator|.
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_lnnoptr
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|asection
modifier|*
name|enclosing
decl_stmt|;
name|unsigned
name|int
name|enc_count
decl_stmt|;
name|bfd_signed_vma
name|linoff
decl_stmt|;
name|struct
name|internal_lineno
name|lin
decl_stmt|;
name|o
operator|=
operator|*
name|csectpp
expr_stmt|;
name|enclosing
operator|=
name|xcoff_section_data
argument_list|(
name|abfd
argument_list|,
name|o
argument_list|)
operator|->
name|enclosing
expr_stmt|;
name|enc_count
operator|=
name|xcoff_section_data
argument_list|(
name|abfd
argument_list|,
name|o
argument_list|)
operator|->
name|lineno_count
expr_stmt|;
if|if
condition|(
name|oline
operator|!=
name|enclosing
condition|)
block|{
name|file_ptr
name|pos
init|=
name|enclosing
operator|->
name|line_filepos
decl_stmt|;
name|bfd_size_type
name|amt
init|=
name|linesz
operator|*
name|enc_count
decl_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|input_bfd
argument_list|,
name|pos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|bfd_bread
argument_list|(
name|finfo
operator|->
name|linenos
argument_list|,
name|amt
argument_list|,
name|input_bfd
argument_list|)
operator|!=
name|amt
operator|)
condition|)
return|return
name|FALSE
return|;
name|oline
operator|=
name|enclosing
expr_stmt|;
block|}
name|linoff
operator|=
operator|(
name|aux
operator|.
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_lnnoptr
operator|-
name|enclosing
operator|->
name|line_filepos
operator|)
expr_stmt|;
name|bfd_coff_swap_lineno_in
argument_list|(
name|input_bfd
argument_list|,
call|(
name|PTR
call|)
argument_list|(
name|finfo
operator|->
name|linenos
operator|+
name|linoff
argument_list|)
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|lin
argument_list|)
expr_stmt|;
if|if
condition|(
name|lin
operator|.
name|l_lnno
operator|!=
literal|0
operator|||
operator|(
operator|(
name|bfd_size_type
operator|)
name|lin
operator|.
name|l_addr
operator|.
name|l_symndx
operator|!=
operator|(
operator|(
name|esym
operator|-
name|isymesz
operator|-
operator|(
operator|(
name|bfd_byte
operator|*
operator|)
name|obj_coff_external_syms
argument_list|(
name|input_bfd
argument_list|)
operator|)
operator|)
operator|/
name|isymesz
operator|)
operator|)
condition|)
name|aux
operator|.
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_lnnoptr
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|bfd_byte
modifier|*
name|linpend
decl_stmt|,
modifier|*
name|linp
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
name|bfd_size_type
name|count
decl_stmt|;
name|lin
operator|.
name|l_addr
operator|.
name|l_symndx
operator|=
operator|*
name|indexp
expr_stmt|;
name|bfd_coff_swap_lineno_out
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|lin
argument_list|,
call|(
name|PTR
call|)
argument_list|(
name|finfo
operator|->
name|linenos
operator|+
name|linoff
argument_list|)
argument_list|)
expr_stmt|;
name|linpend
operator|=
operator|(
name|finfo
operator|->
name|linenos
operator|+
name|enc_count
operator|*
name|linesz
operator|)
expr_stmt|;
name|offset
operator|=
operator|(
name|o
operator|->
name|output_section
operator|->
name|vma
operator|+
name|o
operator|->
name|output_offset
operator|-
name|o
operator|->
name|vma
operator|)
expr_stmt|;
for|for
control|(
name|linp
operator|=
name|finfo
operator|->
name|linenos
operator|+
name|linoff
operator|+
name|linesz
init|;
name|linp
operator|<
name|linpend
condition|;
name|linp
operator|+=
name|linesz
control|)
block|{
name|bfd_coff_swap_lineno_in
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|PTR
operator|)
name|linp
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|lin
argument_list|)
expr_stmt|;
if|if
condition|(
name|lin
operator|.
name|l_lnno
operator|==
literal|0
condition|)
break|break;
name|lin
operator|.
name|l_addr
operator|.
name|l_paddr
operator|+=
name|offset
expr_stmt|;
name|bfd_coff_swap_lineno_out
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|lin
argument_list|,
operator|(
name|PTR
operator|)
name|linp
argument_list|)
expr_stmt|;
block|}
name|count
operator|=
operator|(
name|linp
operator|-
operator|(
name|finfo
operator|->
name|linenos
operator|+
name|linoff
operator|)
operator|)
operator|/
name|linesz
expr_stmt|;
name|aux
operator|.
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_lnnoptr
operator|=
operator|(
name|o
operator|->
name|output_section
operator|->
name|line_filepos
operator|+
name|o
operator|->
name|output_section
operator|->
name|lineno_count
operator|*
name|linesz
operator|)
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|output_bfd
argument_list|,
name|aux
operator|.
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_lnnoptr
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|bfd_bwrite
argument_list|(
name|finfo
operator|->
name|linenos
operator|+
name|linoff
argument_list|,
name|linesz
operator|*
name|count
argument_list|,
name|output_bfd
argument_list|)
operator|!=
name|linesz
operator|*
name|count
operator|)
condition|)
return|return
name|FALSE
return|;
name|o
operator|->
name|output_section
operator|->
name|lineno_count
operator|+=
name|count
expr_stmt|;
if|if
condition|(
name|incls
operator|>
literal|0
condition|)
block|{
name|struct
name|internal_syment
modifier|*
name|iisp
decl_stmt|,
modifier|*
name|iispend
decl_stmt|;
name|long
modifier|*
name|iindp
decl_stmt|;
name|bfd_byte
modifier|*
name|oos
decl_stmt|;
name|int
name|iiadd
decl_stmt|;
comment|/* Update any C_BINCL or C_EINCL symbols 				 that refer to a line number in the 				 range we just output.  */
name|iisp
operator|=
name|finfo
operator|->
name|internal_syms
expr_stmt|;
name|iispend
operator|=
operator|(
name|iisp
operator|+
name|obj_raw_syment_count
argument_list|(
name|input_bfd
argument_list|)
operator|)
expr_stmt|;
name|iindp
operator|=
name|finfo
operator|->
name|sym_indices
expr_stmt|;
name|oos
operator|=
name|finfo
operator|->
name|outsyms
expr_stmt|;
while|while
condition|(
name|iisp
operator|<
name|iispend
condition|)
block|{
if|if
condition|(
operator|*
name|iindp
operator|>=
literal|0
operator|&&
operator|(
name|iisp
operator|->
name|n_sclass
operator|==
name|C_BINCL
operator|||
name|iisp
operator|->
name|n_sclass
operator|==
name|C_EINCL
operator|)
operator|&&
operator|(
operator|(
name|bfd_size_type
operator|)
name|iisp
operator|->
name|n_value
operator|>=
call|(
name|bfd_size_type
call|)
argument_list|(
name|enclosing
operator|->
name|line_filepos
operator|+
name|linoff
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|bfd_size_type
operator|)
name|iisp
operator|->
name|n_value
operator|<
operator|(
name|enclosing
operator|->
name|line_filepos
operator|+
name|enc_count
operator|*
name|linesz
operator|)
operator|)
condition|)
block|{
name|struct
name|internal_syment
name|iis
decl_stmt|;
name|bfd_coff_swap_sym_in
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|PTR
operator|)
name|oos
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|iis
argument_list|)
expr_stmt|;
name|iis
operator|.
name|n_value
operator|=
operator|(
name|iisp
operator|->
name|n_value
operator|-
name|enclosing
operator|->
name|line_filepos
operator|-
name|linoff
operator|+
name|aux
operator|.
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_lnnoptr
operator|)
expr_stmt|;
name|bfd_coff_swap_sym_out
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|iis
argument_list|,
operator|(
name|PTR
operator|)
name|oos
argument_list|)
expr_stmt|;
operator|--
name|incls
expr_stmt|;
block|}
name|iiadd
operator|=
literal|1
operator|+
name|iisp
operator|->
name|n_numaux
expr_stmt|;
if|if
condition|(
operator|*
name|iindp
operator|>=
literal|0
condition|)
name|oos
operator|+=
name|iiadd
operator|*
name|osymesz
expr_stmt|;
name|iisp
operator|+=
name|iiadd
expr_stmt|;
name|iindp
operator|+=
name|iiadd
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
name|bfd_coff_swap_aux_out
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|aux
argument_list|,
name|isymp
operator|->
name|n_type
argument_list|,
name|isymp
operator|->
name|n_sclass
argument_list|,
name|i
argument_list|,
name|isymp
operator|->
name|n_numaux
argument_list|,
operator|(
name|PTR
operator|)
name|outsym
argument_list|)
expr_stmt|;
name|outsym
operator|+=
name|osymesz
expr_stmt|;
name|esym
operator|+=
name|isymesz
expr_stmt|;
block|}
block|}
name|indexp
operator|+=
name|add
expr_stmt|;
name|isymp
operator|+=
name|add
expr_stmt|;
name|csectpp
operator|+=
name|add
expr_stmt|;
block|}
comment|/* If we swapped out a C_FILE symbol, guess that the next C_FILE      symbol will be the first symbol in the next input file.  In the      normal case, this will save us from writing out the C_FILE symbol      again.  */
if|if
condition|(
name|finfo
operator|->
name|last_file_index
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|bfd_size_type
operator|)
name|finfo
operator|->
name|last_file_index
operator|>=
name|syment_base
condition|)
block|{
name|finfo
operator|->
name|last_file
operator|.
name|n_value
operator|=
name|output_index
expr_stmt|;
name|bfd_coff_swap_sym_out
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|finfo
operator|->
name|last_file
argument_list|,
call|(
name|PTR
call|)
argument_list|(
name|finfo
operator|->
name|outsyms
operator|+
operator|(
operator|(
name|finfo
operator|->
name|last_file_index
operator|-
name|syment_base
operator|)
operator|*
name|osymesz
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Write the modified symbols to the output file.  */
if|if
condition|(
name|outsym
operator|>
name|finfo
operator|->
name|outsyms
condition|)
block|{
name|file_ptr
name|pos
init|=
name|obj_sym_filepos
argument_list|(
name|output_bfd
argument_list|)
operator|+
name|syment_base
operator|*
name|osymesz
decl_stmt|;
name|bfd_size_type
name|amt
init|=
name|outsym
operator|-
name|finfo
operator|->
name|outsyms
decl_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|output_bfd
argument_list|,
name|pos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bwrite
argument_list|(
name|finfo
operator|->
name|outsyms
argument_list|,
name|amt
argument_list|,
name|output_bfd
argument_list|)
operator|!=
name|amt
condition|)
return|return
name|FALSE
return|;
name|BFD_ASSERT
argument_list|(
operator|(
name|obj_raw_syment_count
argument_list|(
name|output_bfd
argument_list|)
operator|+
operator|(
name|outsym
operator|-
name|finfo
operator|->
name|outsyms
operator|)
operator|/
name|osymesz
operator|)
operator|==
name|output_index
argument_list|)
expr_stmt|;
name|obj_raw_syment_count
argument_list|(
name|output_bfd
argument_list|)
operator|=
name|output_index
expr_stmt|;
block|}
comment|/* Don't let the linker relocation routines discard the symbols.  */
name|keep_syms
operator|=
name|obj_coff_keep_syms
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|obj_coff_keep_syms
argument_list|(
name|input_bfd
argument_list|)
operator|=
name|TRUE
expr_stmt|;
comment|/* Relocate the contents of each section.  */
for|for
control|(
name|o
operator|=
name|input_bfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
if|if
condition|(
operator|!
name|o
operator|->
name|linker_mark
condition|)
block|{
comment|/* This section was omitted from the link.  */
continue|continue;
block|}
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|==
literal|0
operator|||
name|o
operator|->
name|_raw_size
operator|==
literal|0
operator|||
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_IN_MEMORY
operator|)
operator|!=
literal|0
condition|)
continue|continue;
comment|/* We have set filepos correctly for the sections we created to 	 represent csects, so bfd_get_section_contents should work.  */
if|if
condition|(
name|coff_section_data
argument_list|(
name|input_bfd
argument_list|,
name|o
argument_list|)
operator|!=
name|NULL
operator|&&
name|coff_section_data
argument_list|(
name|input_bfd
argument_list|,
name|o
argument_list|)
operator|->
name|contents
operator|!=
name|NULL
condition|)
name|contents
operator|=
name|coff_section_data
argument_list|(
name|input_bfd
argument_list|,
name|o
argument_list|)
operator|->
name|contents
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|input_bfd
argument_list|,
name|o
argument_list|,
name|finfo
operator|->
name|contents
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|o
operator|->
name|_raw_size
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|contents
operator|=
name|finfo
operator|->
name|contents
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|!=
literal|0
condition|)
block|{
name|int
name|target_index
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|internal_relocs
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|irel
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|irelend
decl_stmt|;
name|struct
name|xcoff_link_hash_entry
modifier|*
modifier|*
name|rel_hash
decl_stmt|;
name|long
name|r_symndx
decl_stmt|;
comment|/* Read in the relocs.  */
name|target_index
operator|=
name|o
operator|->
name|output_section
operator|->
name|target_index
expr_stmt|;
name|internal_relocs
operator|=
operator|(
name|xcoff_read_internal_relocs
argument_list|(
name|input_bfd
argument_list|,
name|o
argument_list|,
name|FALSE
argument_list|,
name|finfo
operator|->
name|external_relocs
argument_list|,
name|TRUE
argument_list|,
operator|(
name|finfo
operator|->
name|section_info
index|[
name|target_index
index|]
operator|.
name|relocs
operator|+
name|o
operator|->
name|output_section
operator|->
name|reloc_count
operator|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* Call processor specific code to relocate the section 	     contents.  */
if|if
condition|(
operator|!
name|bfd_coff_relocate_section
argument_list|(
name|output_bfd
argument_list|,
name|finfo
operator|->
name|info
argument_list|,
name|input_bfd
argument_list|,
name|o
argument_list|,
name|contents
argument_list|,
name|internal_relocs
argument_list|,
name|finfo
operator|->
name|internal_syms
argument_list|,
name|xcoff_data
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|csects
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|offset
operator|=
name|o
operator|->
name|output_section
operator|->
name|vma
operator|+
name|o
operator|->
name|output_offset
operator|-
name|o
operator|->
name|vma
expr_stmt|;
name|irel
operator|=
name|internal_relocs
expr_stmt|;
name|irelend
operator|=
name|irel
operator|+
name|o
operator|->
name|reloc_count
expr_stmt|;
name|rel_hash
operator|=
operator|(
name|finfo
operator|->
name|section_info
index|[
name|target_index
index|]
operator|.
name|rel_hashes
operator|+
name|o
operator|->
name|output_section
operator|->
name|reloc_count
operator|)
expr_stmt|;
for|for
control|(
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
operator|,
name|rel_hash
operator|++
control|)
block|{
name|struct
name|xcoff_link_hash_entry
modifier|*
name|h
init|=
name|NULL
decl_stmt|;
name|struct
name|internal_ldrel
name|ldrel
decl_stmt|;
name|bfd_boolean
name|quiet
decl_stmt|;
operator|*
name|rel_hash
operator|=
name|NULL
expr_stmt|;
comment|/* Adjust the reloc address and symbol index.  */
name|irel
operator|->
name|r_vaddr
operator|+=
name|offset
expr_stmt|;
name|r_symndx
operator|=
name|irel
operator|->
name|r_symndx
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|==
operator|-
literal|1
condition|)
name|h
operator|=
name|NULL
expr_stmt|;
else|else
name|h
operator|=
name|obj_xcoff_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
index|[
name|r_symndx
index|]
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|!=
operator|-
literal|1
operator|&&
name|finfo
operator|->
name|info
operator|->
name|strip
operator|!=
name|strip_all
condition|)
block|{
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|smclas
operator|!=
name|XMC_TD
operator|&&
operator|(
name|irel
operator|->
name|r_type
operator|==
name|R_TOC
operator|||
name|irel
operator|->
name|r_type
operator|==
name|R_GL
operator|||
name|irel
operator|->
name|r_type
operator|==
name|R_TCL
operator|||
name|irel
operator|->
name|r_type
operator|==
name|R_TRL
operator|||
name|irel
operator|->
name|r_type
operator|==
name|R_TRLA
operator|)
condition|)
block|{
comment|/* This is a TOC relative reloc with a symbol 			 attached.  The symbol should be the one which 			 this reloc is for.  We want to make this 			 reloc against the TOC address of the symbol, 			 not the symbol itself.  */
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|toc_section
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
operator|(
name|h
operator|->
name|flags
operator|&
name|XCOFF_SET_TOC
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|u
operator|.
name|toc_indx
operator|!=
operator|-
literal|1
condition|)
name|irel
operator|->
name|r_symndx
operator|=
name|h
operator|->
name|u
operator|.
name|toc_indx
expr_stmt|;
else|else
block|{
name|struct
name|xcoff_toc_rel_hash
modifier|*
name|n
decl_stmt|;
name|struct
name|xcoff_link_section_info
modifier|*
name|si
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|xcoff_toc_rel_hash
argument_list|)
expr_stmt|;
name|n
operator|=
operator|(
operator|(
expr|struct
name|xcoff_toc_rel_hash
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|,
name|amt
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|si
operator|=
name|finfo
operator|->
name|section_info
operator|+
name|target_index
expr_stmt|;
name|n
operator|->
name|next
operator|=
name|si
operator|->
name|toc_rel_hashes
expr_stmt|;
name|n
operator|->
name|h
operator|=
name|h
expr_stmt|;
name|n
operator|->
name|rel
operator|=
name|irel
expr_stmt|;
name|si
operator|->
name|toc_rel_hashes
operator|=
name|n
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
comment|/* This is a global symbol.  */
if|if
condition|(
name|h
operator|->
name|indx
operator|>=
literal|0
condition|)
name|irel
operator|->
name|r_symndx
operator|=
name|h
operator|->
name|indx
expr_stmt|;
else|else
block|{
comment|/* This symbol is being written at the end 			     of the file, and we do not yet know the 			     symbol index.  We save the pointer to the 			     hash table entry in the rel_hash list. 			     We set the indx field to -2 to indicate 			     that this symbol must not be stripped.  */
operator|*
name|rel_hash
operator|=
name|h
expr_stmt|;
name|h
operator|->
name|indx
operator|=
operator|-
literal|2
expr_stmt|;
block|}
block|}
else|else
block|{
name|long
name|indx
decl_stmt|;
name|indx
operator|=
name|finfo
operator|->
name|sym_indices
index|[
name|r_symndx
index|]
expr_stmt|;
if|if
condition|(
name|indx
operator|==
operator|-
literal|1
condition|)
block|{
name|struct
name|internal_syment
modifier|*
name|is
decl_stmt|;
comment|/* Relocations against a TC0 TOC anchor are 			     automatically transformed to be against 			     the TOC anchor in the output file.  */
name|is
operator|=
name|finfo
operator|->
name|internal_syms
operator|+
name|r_symndx
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|n_sclass
operator|==
name|C_HIDEXT
operator|&&
name|is
operator|->
name|n_numaux
operator|>
literal|0
condition|)
block|{
name|PTR
name|auxptr
decl_stmt|;
name|union
name|internal_auxent
name|aux
decl_stmt|;
name|auxptr
operator|=
operator|(
call|(
name|PTR
call|)
argument_list|(
operator|(
operator|(
name|bfd_byte
operator|*
operator|)
name|obj_coff_external_syms
argument_list|(
name|input_bfd
argument_list|)
operator|)
operator|+
operator|(
operator|(
name|r_symndx
operator|+
name|is
operator|->
name|n_numaux
operator|)
operator|*
name|isymesz
operator|)
argument_list|)
operator|)
expr_stmt|;
name|bfd_coff_swap_aux_in
argument_list|(
name|input_bfd
argument_list|,
name|auxptr
argument_list|,
name|is
operator|->
name|n_type
argument_list|,
name|is
operator|->
name|n_sclass
argument_list|,
name|is
operator|->
name|n_numaux
operator|-
literal|1
argument_list|,
name|is
operator|->
name|n_numaux
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|aux
argument_list|)
expr_stmt|;
if|if
condition|(
name|SMTYP_SMTYP
argument_list|(
name|aux
operator|.
name|x_csect
operator|.
name|x_smtyp
argument_list|)
operator|==
name|XTY_SD
operator|&&
name|aux
operator|.
name|x_csect
operator|.
name|x_smclas
operator|==
name|XMC_TC0
condition|)
name|indx
operator|=
name|finfo
operator|->
name|toc_symindx
expr_stmt|;
block|}
block|}
if|if
condition|(
name|indx
operator|!=
operator|-
literal|1
condition|)
name|irel
operator|->
name|r_symndx
operator|=
name|indx
expr_stmt|;
else|else
block|{
name|struct
name|internal_syment
modifier|*
name|is
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|buf
index|[
name|SYMNMLEN
operator|+
literal|1
index|]
decl_stmt|;
comment|/* This reloc is against a symbol we are 			     stripping.  It would be possible to handle 			     this case, but I don't think it's worth it.  */
name|is
operator|=
name|finfo
operator|->
name|internal_syms
operator|+
name|r_symndx
expr_stmt|;
name|name
operator|=
operator|(
name|_bfd_coff_internal_syment_name
argument_list|(
name|input_bfd
argument_list|,
name|is
argument_list|,
name|buf
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|finfo
operator|->
name|info
operator|->
name|callbacks
operator|->
name|unattached_reloc
call|)
argument_list|(
name|finfo
operator|->
name|info
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|o
argument_list|,
name|irel
operator|->
name|r_vaddr
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
block|}
name|quiet
operator|=
name|FALSE
expr_stmt|;
switch|switch
condition|(
name|irel
operator|->
name|r_type
condition|)
block|{
default|default:
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_common
condition|)
break|break;
comment|/* Fall through.  */
case|case
name|R_POS
case|:
case|case
name|R_NEG
case|:
case|case
name|R_RL
case|:
case|case
name|R_RLA
case|:
comment|/* This reloc needs to be copied into the .loader 		     section.  */
name|ldrel
operator|.
name|l_vaddr
operator|=
name|irel
operator|->
name|r_vaddr
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|==
operator|-
literal|1
condition|)
name|ldrel
operator|.
name|l_symndx
operator|=
operator|-
operator|(
name|bfd_size_type
operator|)
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_common
operator|)
condition|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
name|sec
operator|=
name|xcoff_data
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|csects
index|[
name|r_symndx
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_common
condition|)
name|sec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
expr_stmt|;
else|else
name|sec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|sec
operator|=
name|sec
operator|->
name|output_section
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
literal|".text"
argument_list|)
operator|==
literal|0
condition|)
name|ldrel
operator|.
name|l_symndx
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
literal|".data"
argument_list|)
operator|==
literal|0
condition|)
name|ldrel
operator|.
name|l_symndx
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
literal|".bss"
argument_list|)
operator|==
literal|0
condition|)
name|ldrel
operator|.
name|l_symndx
operator|=
literal|2
expr_stmt|;
else|else
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: loader reloc in unrecognized section `%s'"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|sec
operator|->
name|name
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_nonrepresentable_section
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|finfo
operator|->
name|info
operator|->
name|relocatable
operator|&&
operator|(
name|h
operator|->
name|flags
operator|&
name|XCOFF_DEF_DYNAMIC
operator|)
operator|==
literal|0
operator|&&
operator|(
name|h
operator|->
name|flags
operator|&
name|XCOFF_IMPORT
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* We already called the undefined_symbol 			     callback for this relocation, in 			     _bfd_ppc_xcoff_relocate_section.  Don't 			     issue any more warnings.  */
name|quiet
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|->
name|ldindx
operator|<
literal|0
operator|&&
operator|!
name|quiet
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: `%s' in loader reloc but not loader sym"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|ldrel
operator|.
name|l_symndx
operator|=
name|h
operator|->
name|ldindx
expr_stmt|;
block|}
name|ldrel
operator|.
name|l_rtype
operator|=
operator|(
name|irel
operator|->
name|r_size
operator|<<
literal|8
operator|)
operator||
name|irel
operator|->
name|r_type
expr_stmt|;
name|ldrel
operator|.
name|l_rsecnm
operator|=
name|o
operator|->
name|output_section
operator|->
name|target_index
expr_stmt|;
if|if
condition|(
name|xcoff_hash_table
argument_list|(
name|finfo
operator|->
name|info
argument_list|)
operator|->
name|textro
operator|&&
name|strcmp
argument_list|(
name|o
operator|->
name|output_section
operator|->
name|name
argument_list|,
literal|".text"
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|quiet
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: loader reloc in read-only section %s"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|bfd_get_section_name
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|,
name|o
operator|->
name|output_section
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|bfd_xcoff_swap_ldrel_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|ldrel
argument_list|,
name|finfo
operator|->
name|ldrel
argument_list|)
expr_stmt|;
name|finfo
operator|->
name|ldrel
operator|+=
name|bfd_xcoff_ldrelsz
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_TOC
case|:
case|case
name|R_GL
case|:
case|case
name|R_TCL
case|:
case|case
name|R_TRL
case|:
case|case
name|R_TRLA
case|:
comment|/* We should never need a .loader reloc for a TOC 		     relative reloc.  */
break|break;
block|}
block|}
name|o
operator|->
name|output_section
operator|->
name|reloc_count
operator|+=
name|o
operator|->
name|reloc_count
expr_stmt|;
block|}
comment|/* Write out the modified section contents.  */
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|output_bfd
argument_list|,
name|o
operator|->
name|output_section
argument_list|,
name|contents
argument_list|,
operator|(
name|file_ptr
operator|)
name|o
operator|->
name|output_offset
argument_list|,
operator|(
name|o
operator|->
name|_cooked_size
operator|!=
literal|0
condition|?
name|o
operator|->
name|_cooked_size
else|:
name|o
operator|->
name|_raw_size
operator|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
name|obj_coff_keep_syms
argument_list|(
name|input_bfd
argument_list|)
operator|=
name|keep_syms
expr_stmt|;
if|if
condition|(
operator|!
name|finfo
operator|->
name|info
operator|->
name|keep_memory
condition|)
block|{
if|if
condition|(
operator|!
name|_bfd_coff_free_symbols
argument_list|(
name|input_bfd
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|N_TMASK
end_undef

begin_undef
undef|#
directive|undef
name|N_BTSHFT
end_undef

begin_comment
comment|/* Write out a non-XCOFF global symbol.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|xcoff_write_global_symbol
parameter_list|(
name|h
parameter_list|,
name|inf
parameter_list|)
name|struct
name|xcoff_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|PTR
name|inf
decl_stmt|;
block|{
name|struct
name|xcoff_final_link_info
modifier|*
name|finfo
init|=
operator|(
expr|struct
name|xcoff_final_link_info
operator|*
operator|)
name|inf
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|bfd_byte
modifier|*
name|outsym
decl_stmt|;
name|struct
name|internal_syment
name|isym
decl_stmt|;
name|union
name|internal_auxent
name|aux
decl_stmt|;
name|bfd_boolean
name|result
decl_stmt|;
name|file_ptr
name|pos
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|output_bfd
operator|=
name|finfo
operator|->
name|output_bfd
expr_stmt|;
name|outsym
operator|=
name|finfo
operator|->
name|outsyms
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
block|{
name|h
operator|=
operator|(
expr|struct
name|xcoff_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_new
condition|)
return|return
name|TRUE
return|;
block|}
comment|/* If this symbol was garbage collected, just skip it.  */
if|if
condition|(
name|xcoff_hash_table
argument_list|(
name|finfo
operator|->
name|info
argument_list|)
operator|->
name|gc
operator|&&
operator|(
name|h
operator|->
name|flags
operator|&
name|XCOFF_MARK
operator|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
comment|/* If we need a .loader section entry, write it out.  */
if|if
condition|(
name|h
operator|->
name|ldsym
operator|!=
name|NULL
condition|)
block|{
name|struct
name|internal_ldsym
modifier|*
name|ldsym
decl_stmt|;
name|bfd
modifier|*
name|impbfd
decl_stmt|;
name|ldsym
operator|=
name|h
operator|->
name|ldsym
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
block|{
name|ldsym
operator|->
name|l_value
operator|=
literal|0
expr_stmt|;
name|ldsym
operator|->
name|l_scnum
operator|=
name|N_UNDEF
expr_stmt|;
name|ldsym
operator|->
name|l_smtype
operator|=
name|XTY_ER
expr_stmt|;
name|impbfd
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|undef
operator|.
name|abfd
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|sec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|ldsym
operator|->
name|l_value
operator|=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|)
expr_stmt|;
name|ldsym
operator|->
name|l_scnum
operator|=
name|sec
operator|->
name|output_section
operator|->
name|target_index
expr_stmt|;
name|ldsym
operator|->
name|l_smtype
operator|=
name|XTY_SD
expr_stmt|;
name|impbfd
operator|=
name|sec
operator|->
name|owner
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|h
operator|->
name|flags
operator|&
name|XCOFF_DEF_REGULAR
operator|)
operator|==
literal|0
operator|&&
operator|(
name|h
operator|->
name|flags
operator|&
name|XCOFF_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|h
operator|->
name|flags
operator|&
name|XCOFF_IMPORT
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Clear l_smtype 	     Import symbols are defined so the check above will make 	     the l_smtype XTY_SD.  But this is not correct, it should 	     be cleared.  */
name|ldsym
operator|->
name|l_smtype
operator||=
name|L_IMPORT
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|h
operator|->
name|flags
operator|&
name|XCOFF_DEF_REGULAR
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|flags
operator|&
name|XCOFF_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|h
operator|->
name|flags
operator|&
name|XCOFF_EXPORT
operator|)
operator|!=
literal|0
condition|)
block|{
name|ldsym
operator|->
name|l_smtype
operator||=
name|L_EXPORT
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|h
operator|->
name|flags
operator|&
name|XCOFF_ENTRY
operator|)
operator|!=
literal|0
condition|)
block|{
name|ldsym
operator|->
name|l_smtype
operator||=
name|L_ENTRY
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|h
operator|->
name|flags
operator|&
name|XCOFF_RTINIT
operator|)
operator|!=
literal|0
condition|)
block|{
name|ldsym
operator|->
name|l_smtype
operator|=
name|XTY_SD
expr_stmt|;
block|}
name|ldsym
operator|->
name|l_smclas
operator|=
name|h
operator|->
name|smclas
expr_stmt|;
if|if
condition|(
name|ldsym
operator|->
name|l_smtype
operator|&
name|L_IMPORT
condition|)
block|{
if|if
condition|(
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|!=
literal|0
operator|)
condition|)
block|{
name|ldsym
operator|->
name|l_smclas
operator|=
name|XMC_XO
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|h
operator|->
name|flags
operator|&
operator|(
name|XCOFF_SYSCALL32
operator||
name|XCOFF_SYSCALL64
operator|)
operator|)
operator|==
operator|(
name|XCOFF_SYSCALL32
operator||
name|XCOFF_SYSCALL64
operator|)
condition|)
block|{
name|ldsym
operator|->
name|l_smclas
operator|=
name|XMC_SV3264
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|->
name|flags
operator|&
name|XCOFF_SYSCALL32
condition|)
block|{
name|ldsym
operator|->
name|l_smclas
operator|=
name|XMC_SV
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|->
name|flags
operator|&
name|XCOFF_SYSCALL64
condition|)
block|{
name|ldsym
operator|->
name|l_smclas
operator|=
name|XMC_SV64
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ldsym
operator|->
name|l_ifile
operator|==
operator|-
operator|(
name|bfd_size_type
operator|)
literal|1
condition|)
block|{
name|ldsym
operator|->
name|l_ifile
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ldsym
operator|->
name|l_ifile
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ldsym
operator|->
name|l_smtype
operator|&
name|L_IMPORT
operator|)
operator|==
literal|0
condition|)
block|{
name|ldsym
operator|->
name|l_ifile
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|impbfd
operator|==
name|NULL
condition|)
block|{
name|ldsym
operator|->
name|l_ifile
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|BFD_ASSERT
argument_list|(
name|impbfd
operator|->
name|xvec
operator|==
name|output_bfd
operator|->
name|xvec
argument_list|)
expr_stmt|;
name|ldsym
operator|->
name|l_ifile
operator|=
name|xcoff_data
argument_list|(
name|impbfd
argument_list|)
operator|->
name|import_file_id
expr_stmt|;
block|}
block|}
name|ldsym
operator|->
name|l_parm
operator|=
literal|0
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|ldindx
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|bfd_xcoff_swap_ldsym_out
argument_list|(
name|output_bfd
argument_list|,
name|ldsym
argument_list|,
operator|(
name|finfo
operator|->
name|ldsym
operator|+
operator|(
name|h
operator|->
name|ldindx
operator|-
literal|3
operator|)
operator|*
name|bfd_xcoff_ldsymsz
argument_list|(
name|finfo
operator|->
name|output_bfd
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|h
operator|->
name|ldsym
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* If this symbol needs global linkage code, write it out.  */
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|==
name|xcoff_hash_table
argument_list|(
name|finfo
operator|->
name|info
argument_list|)
operator|->
name|linkage_section
operator|)
condition|)
block|{
name|bfd_byte
modifier|*
name|p
decl_stmt|;
name|bfd_vma
name|tocoff
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|p
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|contents
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
comment|/* The first instruction in the global linkage code loads a 	 specific TOC element.  */
name|tocoff
operator|=
operator|(
name|h
operator|->
name|descriptor
operator|->
name|toc_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|descriptor
operator|->
name|toc_section
operator|->
name|output_offset
operator|-
name|xcoff_data
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|toc
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|h
operator|->
name|descriptor
operator|->
name|flags
operator|&
name|XCOFF_SET_TOC
operator|)
operator|!=
literal|0
condition|)
block|{
name|tocoff
operator|+=
name|h
operator|->
name|descriptor
operator|->
name|u
operator|.
name|toc_offset
expr_stmt|;
block|}
comment|/* The first instruction in the glink code needs to be 	 cooked to to hold the correct offset in the toc.  The 	 rest are just output raw.  */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|bfd_xcoff_glink_code
argument_list|(
name|output_bfd
argument_list|,
literal|0
argument_list|)
operator||
operator|(
name|tocoff
operator|&
literal|0xffff
operator|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* Start with i == 1 to get past the first instruction done above 	 The /4 is because the glink code is in bytes and we are going 	 4 at a pop.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|bfd_xcoff_glink_code_size
argument_list|(
name|output_bfd
argument_list|)
operator|/
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|bfd_xcoff_glink_code
argument_list|(
name|output_bfd
argument_list|,
name|i
argument_list|)
argument_list|,
operator|&
name|p
index|[
literal|4
operator|*
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If we created a TOC entry for this symbol, write out the required      relocs.  */
if|if
condition|(
operator|(
name|h
operator|->
name|flags
operator|&
name|XCOFF_SET_TOC
operator|)
operator|!=
literal|0
condition|)
block|{
name|asection
modifier|*
name|tocsec
decl_stmt|;
name|asection
modifier|*
name|osec
decl_stmt|;
name|int
name|oindx
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|irel
decl_stmt|;
name|struct
name|internal_ldrel
name|ldrel
decl_stmt|;
name|struct
name|internal_syment
name|irsym
decl_stmt|;
name|union
name|internal_auxent
name|iraux
decl_stmt|;
name|tocsec
operator|=
name|h
operator|->
name|toc_section
expr_stmt|;
name|osec
operator|=
name|tocsec
operator|->
name|output_section
expr_stmt|;
name|oindx
operator|=
name|osec
operator|->
name|target_index
expr_stmt|;
name|irel
operator|=
name|finfo
operator|->
name|section_info
index|[
name|oindx
index|]
operator|.
name|relocs
operator|+
name|osec
operator|->
name|reloc_count
expr_stmt|;
name|irel
operator|->
name|r_vaddr
operator|=
operator|(
name|osec
operator|->
name|vma
operator|+
name|tocsec
operator|->
name|output_offset
operator|+
name|h
operator|->
name|u
operator|.
name|toc_offset
operator|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|indx
operator|>=
literal|0
condition|)
block|{
name|irel
operator|->
name|r_symndx
operator|=
name|h
operator|->
name|indx
expr_stmt|;
block|}
else|else
block|{
name|h
operator|->
name|indx
operator|=
operator|-
literal|2
expr_stmt|;
name|irel
operator|->
name|r_symndx
operator|=
name|obj_raw_syment_count
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|ldindx
operator|>=
literal|0
argument_list|)
expr_stmt|;
comment|/* Initialize the aux union here instead of closer to when it is 	 written out below because the length of the csect depends on 	 whether the output is 32 or 64 bit.  */
name|memset
argument_list|(
operator|&
name|iraux
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|iraux
argument_list|)
expr_stmt|;
name|iraux
operator|.
name|x_csect
operator|.
name|x_smtyp
operator|=
name|XTY_SD
expr_stmt|;
comment|/* iraux.x_csect.x_scnlen.l = 4 or 8, see below */
name|iraux
operator|.
name|x_csect
operator|.
name|x_smclas
operator|=
name|XMC_TC
expr_stmt|;
comment|/* 32 bit uses a 32 bit R_POS to do the relocations 	 64 bit uses a 64 bit R_POS to do the relocations  	 Also needs to change the csect size : 4 for 32 bit, 8 for 64 bit  	 Which one is determined by the backend.  */
if|if
condition|(
name|bfd_xcoff_is_xcoff64
argument_list|(
name|output_bfd
argument_list|)
condition|)
block|{
name|irel
operator|->
name|r_size
operator|=
literal|63
expr_stmt|;
name|iraux
operator|.
name|x_csect
operator|.
name|x_scnlen
operator|.
name|l
operator|=
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bfd_xcoff_is_xcoff32
argument_list|(
name|output_bfd
argument_list|)
condition|)
block|{
name|irel
operator|->
name|r_size
operator|=
literal|31
expr_stmt|;
name|iraux
operator|.
name|x_csect
operator|.
name|x_scnlen
operator|.
name|l
operator|=
literal|4
expr_stmt|;
block|}
else|else
block|{
return|return
name|FALSE
return|;
block|}
name|irel
operator|->
name|r_type
operator|=
name|R_POS
expr_stmt|;
name|finfo
operator|->
name|section_info
index|[
name|oindx
index|]
operator|.
name|rel_hashes
index|[
name|osec
operator|->
name|reloc_count
index|]
operator|=
name|NULL
expr_stmt|;
operator|++
name|osec
operator|->
name|reloc_count
expr_stmt|;
name|ldrel
operator|.
name|l_vaddr
operator|=
name|irel
operator|->
name|r_vaddr
expr_stmt|;
name|ldrel
operator|.
name|l_symndx
operator|=
name|h
operator|->
name|ldindx
expr_stmt|;
name|ldrel
operator|.
name|l_rtype
operator|=
operator|(
name|irel
operator|->
name|r_size
operator|<<
literal|8
operator|)
operator||
name|R_POS
expr_stmt|;
name|ldrel
operator|.
name|l_rsecnm
operator|=
name|oindx
expr_stmt|;
name|bfd_xcoff_swap_ldrel_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|ldrel
argument_list|,
name|finfo
operator|->
name|ldrel
argument_list|)
expr_stmt|;
name|finfo
operator|->
name|ldrel
operator|+=
name|bfd_xcoff_ldrelsz
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
comment|/* We need to emit a symbol to define a csect which holds 	 the reloc.  */
if|if
condition|(
name|finfo
operator|->
name|info
operator|->
name|strip
operator|!=
name|strip_all
condition|)
block|{
name|result
operator|=
name|bfd_xcoff_put_symbol_name
argument_list|(
name|output_bfd
argument_list|,
name|finfo
operator|->
name|strtab
argument_list|,
operator|&
name|irsym
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
return|return
name|FALSE
return|;
name|irsym
operator|.
name|n_value
operator|=
name|irel
operator|->
name|r_vaddr
expr_stmt|;
name|irsym
operator|.
name|n_scnum
operator|=
name|osec
operator|->
name|target_index
expr_stmt|;
name|irsym
operator|.
name|n_sclass
operator|=
name|C_HIDEXT
expr_stmt|;
name|irsym
operator|.
name|n_type
operator|=
name|T_NULL
expr_stmt|;
name|irsym
operator|.
name|n_numaux
operator|=
literal|1
expr_stmt|;
name|bfd_coff_swap_sym_out
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|irsym
argument_list|,
operator|(
name|PTR
operator|)
name|outsym
argument_list|)
expr_stmt|;
name|outsym
operator|+=
name|bfd_coff_symesz
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
comment|/* note : iraux is initialized above */
name|bfd_coff_swap_aux_out
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|iraux
argument_list|,
name|T_NULL
argument_list|,
name|C_HIDEXT
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
operator|(
name|PTR
operator|)
name|outsym
argument_list|)
expr_stmt|;
name|outsym
operator|+=
name|bfd_coff_auxesz
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|indx
operator|>=
literal|0
condition|)
block|{
comment|/* We aren't going to write out the symbols below, so we 		 need to write them out now.  */
name|pos
operator|=
name|obj_sym_filepos
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
name|pos
operator|+=
operator|(
name|obj_raw_syment_count
argument_list|(
name|output_bfd
argument_list|)
operator|*
name|bfd_coff_symesz
argument_list|(
name|output_bfd
argument_list|)
operator|)
expr_stmt|;
name|amt
operator|=
name|outsym
operator|-
name|finfo
operator|->
name|outsyms
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|output_bfd
argument_list|,
name|pos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bwrite
argument_list|(
name|finfo
operator|->
name|outsyms
argument_list|,
name|amt
argument_list|,
name|output_bfd
argument_list|)
operator|!=
name|amt
condition|)
return|return
name|FALSE
return|;
name|obj_raw_syment_count
argument_list|(
name|output_bfd
argument_list|)
operator|+=
operator|(
name|outsym
operator|-
name|finfo
operator|->
name|outsyms
operator|)
operator|/
name|bfd_coff_symesz
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
name|outsym
operator|=
name|finfo
operator|->
name|outsyms
expr_stmt|;
block|}
block|}
block|}
comment|/* If this symbol is a specially defined function descriptor, write      it out.  The first word is the address of the function code      itself, the second word is the address of the TOC, and the third      word is zero.       32 bit vs 64 bit      The addresses for the 32 bit will take 4 bytes and the addresses      for 64 bit will take 8 bytes.  Similar for the relocs.  This type      of logic was also done above to create a TOC entry in      xcoff_write_global_symbol.  */
if|if
condition|(
operator|(
name|h
operator|->
name|flags
operator|&
name|XCOFF_DESCRIPTOR
operator|)
operator|!=
literal|0
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|==
name|xcoff_hash_table
argument_list|(
name|finfo
operator|->
name|info
argument_list|)
operator|->
name|descriptor_section
operator|)
condition|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|asection
modifier|*
name|osec
decl_stmt|;
name|int
name|oindx
decl_stmt|;
name|bfd_byte
modifier|*
name|p
decl_stmt|;
name|struct
name|xcoff_link_hash_entry
modifier|*
name|hentry
decl_stmt|;
name|asection
modifier|*
name|esec
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|irel
decl_stmt|;
name|struct
name|internal_ldrel
name|ldrel
decl_stmt|;
name|asection
modifier|*
name|tsec
decl_stmt|;
name|unsigned
name|int
name|reloc_size
decl_stmt|,
name|byte_size
decl_stmt|;
if|if
condition|(
name|bfd_xcoff_is_xcoff64
argument_list|(
name|output_bfd
argument_list|)
condition|)
block|{
name|reloc_size
operator|=
literal|63
expr_stmt|;
name|byte_size
operator|=
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bfd_xcoff_is_xcoff32
argument_list|(
name|output_bfd
argument_list|)
condition|)
block|{
name|reloc_size
operator|=
literal|31
expr_stmt|;
name|byte_size
operator|=
literal|4
expr_stmt|;
block|}
else|else
block|{
return|return
name|FALSE
return|;
block|}
name|sec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|osec
operator|=
name|sec
operator|->
name|output_section
expr_stmt|;
name|oindx
operator|=
name|osec
operator|->
name|target_index
expr_stmt|;
name|p
operator|=
name|sec
operator|->
name|contents
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
name|hentry
operator|=
name|h
operator|->
name|descriptor
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|hentry
operator|!=
name|NULL
operator|&&
operator|(
name|hentry
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|hentry
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
argument_list|)
expr_stmt|;
name|esec
operator|=
name|hentry
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|irel
operator|=
name|finfo
operator|->
name|section_info
index|[
name|oindx
index|]
operator|.
name|relocs
operator|+
name|osec
operator|->
name|reloc_count
expr_stmt|;
name|irel
operator|->
name|r_vaddr
operator|=
operator|(
name|osec
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|)
expr_stmt|;
name|irel
operator|->
name|r_symndx
operator|=
name|esec
operator|->
name|output_section
operator|->
name|target_index
expr_stmt|;
name|irel
operator|->
name|r_type
operator|=
name|R_POS
expr_stmt|;
name|irel
operator|->
name|r_size
operator|=
name|reloc_size
expr_stmt|;
name|finfo
operator|->
name|section_info
index|[
name|oindx
index|]
operator|.
name|rel_hashes
index|[
name|osec
operator|->
name|reloc_count
index|]
operator|=
name|NULL
expr_stmt|;
operator|++
name|osec
operator|->
name|reloc_count
expr_stmt|;
name|ldrel
operator|.
name|l_vaddr
operator|=
name|irel
operator|->
name|r_vaddr
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|esec
operator|->
name|output_section
operator|->
name|name
argument_list|,
literal|".text"
argument_list|)
operator|==
literal|0
condition|)
name|ldrel
operator|.
name|l_symndx
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|esec
operator|->
name|output_section
operator|->
name|name
argument_list|,
literal|".data"
argument_list|)
operator|==
literal|0
condition|)
name|ldrel
operator|.
name|l_symndx
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|esec
operator|->
name|output_section
operator|->
name|name
argument_list|,
literal|".bss"
argument_list|)
operator|==
literal|0
condition|)
name|ldrel
operator|.
name|l_symndx
operator|=
literal|2
expr_stmt|;
else|else
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: loader reloc in unrecognized section `%s'"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|output_bfd
argument_list|)
argument_list|,
name|esec
operator|->
name|output_section
operator|->
name|name
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_nonrepresentable_section
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|ldrel
operator|.
name|l_rtype
operator|=
operator|(
name|reloc_size
operator|<<
literal|8
operator|)
operator||
name|R_POS
expr_stmt|;
name|ldrel
operator|.
name|l_rsecnm
operator|=
name|oindx
expr_stmt|;
name|bfd_xcoff_swap_ldrel_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|ldrel
argument_list|,
name|finfo
operator|->
name|ldrel
argument_list|)
expr_stmt|;
name|finfo
operator|->
name|ldrel
operator|+=
name|bfd_xcoff_ldrelsz
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
comment|/* There are three items to write out, 	 the address of the code 	 the address of the toc anchor 	 the environment pointer. 	 We are ignoring the environment pointer.  So set it to zero.  */
if|if
condition|(
name|bfd_xcoff_is_xcoff64
argument_list|(
name|output_bfd
argument_list|)
condition|)
block|{
name|bfd_put_64
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|esec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|esec
operator|->
name|output_offset
operator|+
name|hentry
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|bfd_put_64
argument_list|(
name|output_bfd
argument_list|,
name|xcoff_data
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|toc
argument_list|,
name|p
operator|+
literal|8
argument_list|)
expr_stmt|;
name|bfd_put_64
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|p
operator|+
literal|16
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 32 bit backend 	     This logic was already called above so the error case where 	     the backend is neither has already been checked.  */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|esec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|esec
operator|->
name|output_offset
operator|+
name|hentry
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|xcoff_data
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|toc
argument_list|,
name|p
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|p
operator|+
literal|8
argument_list|)
expr_stmt|;
block|}
name|tsec
operator|=
name|coff_section_from_bfd_index
argument_list|(
name|output_bfd
argument_list|,
name|xcoff_data
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|sntoc
argument_list|)
expr_stmt|;
operator|++
name|irel
expr_stmt|;
name|irel
operator|->
name|r_vaddr
operator|=
operator|(
name|osec
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|byte_size
operator|)
expr_stmt|;
name|irel
operator|->
name|r_symndx
operator|=
name|tsec
operator|->
name|output_section
operator|->
name|target_index
expr_stmt|;
name|irel
operator|->
name|r_type
operator|=
name|R_POS
expr_stmt|;
name|irel
operator|->
name|r_size
operator|=
name|reloc_size
expr_stmt|;
name|finfo
operator|->
name|section_info
index|[
name|oindx
index|]
operator|.
name|rel_hashes
index|[
name|osec
operator|->
name|reloc_count
index|]
operator|=
name|NULL
expr_stmt|;
operator|++
name|osec
operator|->
name|reloc_count
expr_stmt|;
name|ldrel
operator|.
name|l_vaddr
operator|=
name|irel
operator|->
name|r_vaddr
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|tsec
operator|->
name|output_section
operator|->
name|name
argument_list|,
literal|".text"
argument_list|)
operator|==
literal|0
condition|)
name|ldrel
operator|.
name|l_symndx
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|tsec
operator|->
name|output_section
operator|->
name|name
argument_list|,
literal|".data"
argument_list|)
operator|==
literal|0
condition|)
name|ldrel
operator|.
name|l_symndx
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|tsec
operator|->
name|output_section
operator|->
name|name
argument_list|,
literal|".bss"
argument_list|)
operator|==
literal|0
condition|)
name|ldrel
operator|.
name|l_symndx
operator|=
literal|2
expr_stmt|;
else|else
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: loader reloc in unrecognized section `%s'"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|output_bfd
argument_list|)
argument_list|,
name|tsec
operator|->
name|output_section
operator|->
name|name
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_nonrepresentable_section
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|ldrel
operator|.
name|l_rtype
operator|=
operator|(
name|reloc_size
operator|<<
literal|8
operator|)
operator||
name|R_POS
expr_stmt|;
name|ldrel
operator|.
name|l_rsecnm
operator|=
name|oindx
expr_stmt|;
name|bfd_xcoff_swap_ldrel_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|ldrel
argument_list|,
name|finfo
operator|->
name|ldrel
argument_list|)
expr_stmt|;
name|finfo
operator|->
name|ldrel
operator|+=
name|bfd_xcoff_ldrelsz
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|->
name|indx
operator|>=
literal|0
operator|||
name|finfo
operator|->
name|info
operator|->
name|strip
operator|==
name|strip_all
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|outsym
operator|==
name|finfo
operator|->
name|outsyms
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
name|h
operator|->
name|indx
operator|!=
operator|-
literal|2
operator|&&
operator|(
name|finfo
operator|->
name|info
operator|->
name|strip
operator|==
name|strip_all
operator|||
operator|(
name|finfo
operator|->
name|info
operator|->
name|strip
operator|==
name|strip_some
operator|&&
name|bfd_hash_lookup
argument_list|(
name|finfo
operator|->
name|info
operator|->
name|keep_hash
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
operator|==
name|NULL
operator|)
operator|)
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|outsym
operator|==
name|finfo
operator|->
name|outsyms
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
name|h
operator|->
name|indx
operator|!=
operator|-
literal|2
operator|&&
operator|(
name|h
operator|->
name|flags
operator|&
operator|(
name|XCOFF_REF_REGULAR
operator||
name|XCOFF_DEF_REGULAR
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|outsym
operator|==
name|finfo
operator|->
name|outsyms
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|memset
argument_list|(
operator|&
name|aux
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|aux
argument_list|)
expr_stmt|;
name|h
operator|->
name|indx
operator|=
name|obj_raw_syment_count
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
name|result
operator|=
name|bfd_xcoff_put_symbol_name
argument_list|(
name|output_bfd
argument_list|,
name|finfo
operator|->
name|strtab
argument_list|,
operator|&
name|isym
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
block|{
name|isym
operator|.
name|n_value
operator|=
literal|0
expr_stmt|;
name|isym
operator|.
name|n_scnum
operator|=
name|N_UNDEF
expr_stmt|;
name|isym
operator|.
name|n_sclass
operator|=
name|C_EXT
expr_stmt|;
name|aux
operator|.
name|x_csect
operator|.
name|x_smtyp
operator|=
name|XTY_ER
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
name|h
operator|->
name|smclas
operator|==
name|XMC_XO
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|bfd_is_abs_section
argument_list|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
argument_list|)
argument_list|)
expr_stmt|;
name|isym
operator|.
name|n_value
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
name|isym
operator|.
name|n_scnum
operator|=
name|N_UNDEF
expr_stmt|;
name|isym
operator|.
name|n_sclass
operator|=
name|C_EXT
expr_stmt|;
name|aux
operator|.
name|x_csect
operator|.
name|x_smtyp
operator|=
name|XTY_ER
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
block|{
name|struct
name|xcoff_link_size_list
modifier|*
name|l
decl_stmt|;
name|isym
operator|.
name|n_value
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|)
expr_stmt|;
if|if
condition|(
name|bfd_is_abs_section
argument_list|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
argument_list|)
condition|)
name|isym
operator|.
name|n_scnum
operator|=
name|N_ABS
expr_stmt|;
else|else
name|isym
operator|.
name|n_scnum
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|target_index
expr_stmt|;
name|isym
operator|.
name|n_sclass
operator|=
name|C_HIDEXT
expr_stmt|;
name|aux
operator|.
name|x_csect
operator|.
name|x_smtyp
operator|=
name|XTY_SD
expr_stmt|;
if|if
condition|(
operator|(
name|h
operator|->
name|flags
operator|&
name|XCOFF_HAS_SIZE
operator|)
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|l
operator|=
name|xcoff_hash_table
argument_list|(
name|finfo
operator|->
name|info
argument_list|)
operator|->
name|size_list
init|;
name|l
operator|!=
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
if|if
condition|(
name|l
operator|->
name|h
operator|==
name|h
condition|)
block|{
name|aux
operator|.
name|x_csect
operator|.
name|x_scnlen
operator|.
name|l
operator|=
name|l
operator|->
name|size
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_common
condition|)
block|{
name|isym
operator|.
name|n_value
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|isym
operator|.
name|n_scnum
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
operator|->
name|output_section
operator|->
name|target_index
expr_stmt|;
name|isym
operator|.
name|n_sclass
operator|=
name|C_EXT
expr_stmt|;
name|aux
operator|.
name|x_csect
operator|.
name|x_smtyp
operator|=
name|XTY_CM
expr_stmt|;
name|aux
operator|.
name|x_csect
operator|.
name|x_scnlen
operator|.
name|l
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|size
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
name|isym
operator|.
name|n_type
operator|=
name|T_NULL
expr_stmt|;
name|isym
operator|.
name|n_numaux
operator|=
literal|1
expr_stmt|;
name|bfd_coff_swap_sym_out
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|isym
argument_list|,
operator|(
name|PTR
operator|)
name|outsym
argument_list|)
expr_stmt|;
name|outsym
operator|+=
name|bfd_coff_symesz
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
name|aux
operator|.
name|x_csect
operator|.
name|x_smclas
operator|=
name|h
operator|->
name|smclas
expr_stmt|;
name|bfd_coff_swap_aux_out
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|aux
argument_list|,
name|T_NULL
argument_list|,
name|isym
operator|.
name|n_sclass
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
operator|(
name|PTR
operator|)
name|outsym
argument_list|)
expr_stmt|;
name|outsym
operator|+=
name|bfd_coff_auxesz
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
name|h
operator|->
name|smclas
operator|!=
name|XMC_XO
condition|)
block|{
comment|/* We just output an SD symbol.  Now output an LD symbol.  */
name|h
operator|->
name|indx
operator|+=
literal|2
expr_stmt|;
name|isym
operator|.
name|n_sclass
operator|=
name|C_EXT
expr_stmt|;
name|bfd_coff_swap_sym_out
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|isym
argument_list|,
operator|(
name|PTR
operator|)
name|outsym
argument_list|)
expr_stmt|;
name|outsym
operator|+=
name|bfd_coff_symesz
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
name|aux
operator|.
name|x_csect
operator|.
name|x_smtyp
operator|=
name|XTY_LD
expr_stmt|;
name|aux
operator|.
name|x_csect
operator|.
name|x_scnlen
operator|.
name|l
operator|=
name|obj_raw_syment_count
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
name|bfd_coff_swap_aux_out
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|aux
argument_list|,
name|T_NULL
argument_list|,
name|C_EXT
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
operator|(
name|PTR
operator|)
name|outsym
argument_list|)
expr_stmt|;
name|outsym
operator|+=
name|bfd_coff_auxesz
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
block|}
name|pos
operator|=
name|obj_sym_filepos
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|obj_raw_syment_count
argument_list|(
name|output_bfd
argument_list|)
operator|*
name|bfd_coff_symesz
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
name|amt
operator|=
name|outsym
operator|-
name|finfo
operator|->
name|outsyms
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|output_bfd
argument_list|,
name|pos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bwrite
argument_list|(
name|finfo
operator|->
name|outsyms
argument_list|,
name|amt
argument_list|,
name|output_bfd
argument_list|)
operator|!=
name|amt
condition|)
return|return
name|FALSE
return|;
name|obj_raw_syment_count
argument_list|(
name|output_bfd
argument_list|)
operator|+=
operator|(
name|outsym
operator|-
name|finfo
operator|->
name|outsyms
operator|)
operator|/
name|bfd_coff_symesz
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Handle a link order which is supposed to generate a reloc.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|xcoff_reloc_link_order
parameter_list|(
name|output_bfd
parameter_list|,
name|finfo
parameter_list|,
name|output_section
parameter_list|,
name|link_order
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|xcoff_final_link_info
modifier|*
name|finfo
decl_stmt|;
name|asection
modifier|*
name|output_section
decl_stmt|;
name|struct
name|bfd_link_order
modifier|*
name|link_order
decl_stmt|;
block|{
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|struct
name|xcoff_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|asection
modifier|*
name|hsec
decl_stmt|;
name|bfd_vma
name|hval
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|irel
decl_stmt|;
name|struct
name|xcoff_link_hash_entry
modifier|*
modifier|*
name|rel_hash_ptr
decl_stmt|;
name|struct
name|internal_ldrel
name|ldrel
decl_stmt|;
if|if
condition|(
name|link_order
operator|->
name|type
operator|==
name|bfd_section_reloc_link_order
condition|)
block|{
comment|/* We need to somehow locate a symbol in the right section.  The 	 symbol must either have a value of zero, or we must adjust 	 the addend by the value of the symbol.  FIXME: Write this 	 when we need it.  The old linker couldn't handle this anyhow.  */
name|abort
argument_list|()
expr_stmt|;
block|}
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|output_bfd
argument_list|,
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|reloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|howto
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|h
operator|=
operator|(
operator|(
expr|struct
name|xcoff_link_hash_entry
operator|*
operator|)
name|bfd_wrapped_link_hash_lookup
argument_list|(
name|output_bfd
argument_list|,
name|finfo
operator|->
name|info
argument_list|,
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|u
operator|.
name|name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|finfo
operator|->
name|info
operator|->
name|callbacks
operator|->
name|unattached_reloc
call|)
argument_list|(
name|finfo
operator|->
name|info
argument_list|,
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|u
operator|.
name|name
argument_list|,
operator|(
name|bfd
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|asection
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_common
condition|)
block|{
name|hsec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
expr_stmt|;
name|hval
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
block|{
name|hsec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|hval
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
block|}
else|else
block|{
name|hsec
operator|=
name|NULL
expr_stmt|;
name|hval
operator|=
literal|0
expr_stmt|;
block|}
name|addend
operator|=
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|addend
expr_stmt|;
if|if
condition|(
name|hsec
operator|!=
name|NULL
condition|)
name|addend
operator|+=
operator|(
name|hsec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|hsec
operator|->
name|output_offset
operator|+
name|hval
operator|)
expr_stmt|;
if|if
condition|(
name|addend
operator|!=
literal|0
condition|)
block|{
name|bfd_size_type
name|size
decl_stmt|;
name|bfd_byte
modifier|*
name|buf
decl_stmt|;
name|bfd_reloc_status_type
name|rstat
decl_stmt|;
name|bfd_boolean
name|ok
decl_stmt|;
name|size
operator|=
name|bfd_get_reloc_size
argument_list|(
name|howto
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_zmalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|rstat
operator|=
name|_bfd_relocate_contents
argument_list|(
name|howto
argument_list|,
name|output_bfd
argument_list|,
name|addend
argument_list|,
name|buf
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rstat
condition|)
block|{
case|case
name|bfd_reloc_ok
case|:
break|break;
default|default:
case|case
name|bfd_reloc_outofrange
case|:
name|abort
argument_list|()
expr_stmt|;
case|case
name|bfd_reloc_overflow
case|:
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|finfo
operator|->
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|finfo
operator|->
name|info
argument_list|,
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|u
operator|.
name|name
argument_list|,
name|howto
operator|->
name|name
argument_list|,
name|addend
argument_list|,
operator|(
name|bfd
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|asection
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
operator|)
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
break|break;
block|}
name|ok
operator|=
name|bfd_set_section_contents
argument_list|(
name|output_bfd
argument_list|,
name|output_section
argument_list|,
operator|(
name|PTR
operator|)
name|buf
argument_list|,
operator|(
name|file_ptr
operator|)
name|link_order
operator|->
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Store the reloc information in the right place.  It will get      swapped and written out at the end of the final_link routine.  */
name|irel
operator|=
operator|(
name|finfo
operator|->
name|section_info
index|[
name|output_section
operator|->
name|target_index
index|]
operator|.
name|relocs
operator|+
name|output_section
operator|->
name|reloc_count
operator|)
expr_stmt|;
name|rel_hash_ptr
operator|=
operator|(
name|finfo
operator|->
name|section_info
index|[
name|output_section
operator|->
name|target_index
index|]
operator|.
name|rel_hashes
operator|+
name|output_section
operator|->
name|reloc_count
operator|)
expr_stmt|;
name|memset
argument_list|(
name|irel
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|internal_reloc
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|rel_hash_ptr
operator|=
name|NULL
expr_stmt|;
name|irel
operator|->
name|r_vaddr
operator|=
name|output_section
operator|->
name|vma
operator|+
name|link_order
operator|->
name|offset
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|indx
operator|>=
literal|0
condition|)
name|irel
operator|->
name|r_symndx
operator|=
name|h
operator|->
name|indx
expr_stmt|;
else|else
block|{
comment|/* Set the index to -2 to force this symbol to get written out.  */
name|h
operator|->
name|indx
operator|=
operator|-
literal|2
expr_stmt|;
operator|*
name|rel_hash_ptr
operator|=
name|h
expr_stmt|;
name|irel
operator|->
name|r_symndx
operator|=
literal|0
expr_stmt|;
block|}
name|irel
operator|->
name|r_type
operator|=
name|howto
operator|->
name|type
expr_stmt|;
name|irel
operator|->
name|r_size
operator|=
name|howto
operator|->
name|bitsize
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|howto
operator|->
name|complain_on_overflow
operator|==
name|complain_overflow_signed
condition|)
name|irel
operator|->
name|r_size
operator||=
literal|0x80
expr_stmt|;
operator|++
name|output_section
operator|->
name|reloc_count
expr_stmt|;
comment|/* Now output the reloc to the .loader section.  */
name|ldrel
operator|.
name|l_vaddr
operator|=
name|irel
operator|->
name|r_vaddr
expr_stmt|;
if|if
condition|(
name|hsec
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|secname
decl_stmt|;
name|secname
operator|=
name|hsec
operator|->
name|output_section
operator|->
name|name
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|secname
argument_list|,
literal|".text"
argument_list|)
operator|==
literal|0
condition|)
name|ldrel
operator|.
name|l_symndx
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|secname
argument_list|,
literal|".data"
argument_list|)
operator|==
literal|0
condition|)
name|ldrel
operator|.
name|l_symndx
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|secname
argument_list|,
literal|".bss"
argument_list|)
operator|==
literal|0
condition|)
name|ldrel
operator|.
name|l_symndx
operator|=
literal|2
expr_stmt|;
else|else
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: loader reloc in unrecognized section `%s'"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|output_bfd
argument_list|)
argument_list|,
name|secname
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_nonrepresentable_section
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|h
operator|->
name|ldindx
operator|<
literal|0
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: `%s' in loader reloc but not loader sym"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|output_bfd
argument_list|)
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|ldrel
operator|.
name|l_symndx
operator|=
name|h
operator|->
name|ldindx
expr_stmt|;
block|}
name|ldrel
operator|.
name|l_rtype
operator|=
operator|(
name|irel
operator|->
name|r_size
operator|<<
literal|8
operator|)
operator||
name|irel
operator|->
name|r_type
expr_stmt|;
name|ldrel
operator|.
name|l_rsecnm
operator|=
name|output_section
operator|->
name|target_index
expr_stmt|;
name|bfd_xcoff_swap_ldrel_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|ldrel
argument_list|,
name|finfo
operator|->
name|ldrel
argument_list|)
expr_stmt|;
name|finfo
operator|->
name|ldrel
operator|+=
name|bfd_xcoff_ldrelsz
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Sort relocs by VMA.  This is called via qsort.  */
end_comment

begin_function
specifier|static
name|int
name|xcoff_sort_relocs
parameter_list|(
name|p1
parameter_list|,
name|p2
parameter_list|)
specifier|const
name|PTR
name|p1
decl_stmt|;
specifier|const
name|PTR
name|p2
decl_stmt|;
block|{
specifier|const
name|struct
name|internal_reloc
modifier|*
name|r1
init|=
operator|(
specifier|const
expr|struct
name|internal_reloc
operator|*
operator|)
name|p1
decl_stmt|;
specifier|const
name|struct
name|internal_reloc
modifier|*
name|r2
init|=
operator|(
specifier|const
expr|struct
name|internal_reloc
operator|*
operator|)
name|p2
decl_stmt|;
if|if
condition|(
name|r1
operator|->
name|r_vaddr
operator|>
name|r2
operator|->
name|r_vaddr
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|r1
operator|->
name|r_vaddr
operator|<
name|r2
operator|->
name|r_vaddr
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

end_unit

