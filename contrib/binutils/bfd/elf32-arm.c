begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* 32-bit ELF support for ARM    Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007    Free Software Foundation, Inc.     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf-vxworks.h"
end_include

begin_include
include|#
directive|include
file|"elf/arm.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NUM_ELEM
end_ifndef

begin_define
define|#
directive|define
name|NUM_ELEM
parameter_list|(
name|a
parameter_list|)
value|(sizeof (a) / (sizeof (a)[0]))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Return the relocation section associated with NAME.  HTAB is the    bfd's elf32_arm_link_hash_entry.  */
end_comment

begin_define
define|#
directive|define
name|RELOC_SECTION
parameter_list|(
name|HTAB
parameter_list|,
name|NAME
parameter_list|)
define|\
value|((HTAB)->use_rel ? ".rel" NAME : ".rela" NAME)
end_define

begin_comment
comment|/* Return size of a relocation entry.  HTAB is the bfd's    elf32_arm_link_hash_entry.  */
end_comment

begin_define
define|#
directive|define
name|RELOC_SIZE
parameter_list|(
name|HTAB
parameter_list|)
define|\
value|((HTAB)->use_rel \    ? sizeof (Elf32_External_Rel) \    : sizeof (Elf32_External_Rela))
end_define

begin_comment
comment|/* Return function to swap relocations in.  HTAB is the bfd's    elf32_arm_link_hash_entry.  */
end_comment

begin_define
define|#
directive|define
name|SWAP_RELOC_IN
parameter_list|(
name|HTAB
parameter_list|)
define|\
value|((HTAB)->use_rel \    ? bfd_elf32_swap_reloc_in \    : bfd_elf32_swap_reloca_in)
end_define

begin_comment
comment|/* Return function to swap relocations out.  HTAB is the bfd's    elf32_arm_link_hash_entry.  */
end_comment

begin_define
define|#
directive|define
name|SWAP_RELOC_OUT
parameter_list|(
name|HTAB
parameter_list|)
define|\
value|((HTAB)->use_rel \    ? bfd_elf32_swap_reloc_out \    : bfd_elf32_swap_reloca_out)
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto
value|0
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto_rel
value|elf32_arm_info_to_howto
end_define

begin_define
define|#
directive|define
name|ARM_ELF_ABI_VERSION
value|0
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_define
define|#
directive|define
name|ARM_ELF_OS_ABI_VERSION
value|ELFOSABI_FREEBSD
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ARM_ELF_OS_ABI_VERSION
value|ELFOSABI_ARM
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|elf_backend_data
name|elf32_arm_vxworks_bed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Note: code such as elf32_arm_reloc_type_lookup expect to use e.g.    R_ARM_PC24 as an index into this, and find the R_ARM_PC24 HOWTO    in that slot.  */
end_comment

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|elf32_arm_howto_table_1
index|[]
init|=
block|{
comment|/* No relocation */
name|HOWTO
argument_list|(
name|R_ARM_NONE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_NONE"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_PC24
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|24
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_PC24"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x00ffffff
argument_list|,
comment|/* src_mask */
literal|0x00ffffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 32 bit absolute */
name|HOWTO
argument_list|(
name|R_ARM_ABS32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_ABS32"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* standard 32bit pc-relative reloc */
name|HOWTO
argument_list|(
name|R_ARM_REL32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_REL32"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 8 bit absolute - R_ARM_LDR_PC_G0 in AAELF */
name|HOWTO
argument_list|(
name|R_ARM_LDR_PC_G0
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_LDR_PC_G0"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16 bit absolute */
name|HOWTO
argument_list|(
name|R_ARM_ABS16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_ABS16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 12 bit absolute */
name|HOWTO
argument_list|(
name|R_ARM_ABS12
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|12
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_ABS12"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x00000fff
argument_list|,
comment|/* src_mask */
literal|0x00000fff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_THM_ABS5
argument_list|,
comment|/* type */
literal|6
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|5
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_THM_ABS5"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x000007e0
argument_list|,
comment|/* src_mask */
literal|0x000007e0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 8 bit absolute */
name|HOWTO
argument_list|(
name|R_ARM_ABS8
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_ABS8"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x000000ff
argument_list|,
comment|/* src_mask */
literal|0x000000ff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_SBREL32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_SBREL32"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_THM_CALL
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|25
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_THM_CALL"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x07ff07ff
argument_list|,
comment|/* src_mask */
literal|0x07ff07ff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_THM_PC8
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_THM_PC8"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x000000ff
argument_list|,
comment|/* src_mask */
literal|0x000000ff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_BREL_ADJ
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_BREL_ADJ"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_SWI24
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_SWI24"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x00000000
argument_list|,
comment|/* src_mask */
literal|0x00000000
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_THM_SWI8
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_SWI8"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x00000000
argument_list|,
comment|/* src_mask */
literal|0x00000000
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* BLX instruction for the ARM.  */
name|HOWTO
argument_list|(
name|R_ARM_XPC25
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|25
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_XPC25"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x00ffffff
argument_list|,
comment|/* src_mask */
literal|0x00ffffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* BLX instruction for the Thumb.  */
name|HOWTO
argument_list|(
name|R_ARM_THM_XPC22
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|22
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_THM_XPC22"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x07ff07ff
argument_list|,
comment|/* src_mask */
literal|0x07ff07ff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Dynamic TLS relocations.  */
name|HOWTO
argument_list|(
name|R_ARM_TLS_DTPMOD32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_TLS_DTPMOD32"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_TLS_DTPOFF32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_TLS_DTPOFF32"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_TLS_TPOFF32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_TLS_TPOFF32"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Relocs used in ARM Linux */
name|HOWTO
argument_list|(
name|R_ARM_COPY
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_COPY"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_GLOB_DAT
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_GLOB_DAT"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_JUMP_SLOT
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_JUMP_SLOT"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_RELATIVE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_RELATIVE"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_GOTOFF32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_GOTOFF32"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_GOTPC
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_GOTPC"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_GOT32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_GOT32"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_PLT32
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|24
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_PLT32"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x00ffffff
argument_list|,
comment|/* src_mask */
literal|0x00ffffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_CALL
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|24
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_CALL"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x00ffffff
argument_list|,
comment|/* src_mask */
literal|0x00ffffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_JUMP24
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|24
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_JUMP24"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x00ffffff
argument_list|,
comment|/* src_mask */
literal|0x00ffffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_THM_JUMP24
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|24
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_THM_JUMP24"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x07ff2fff
argument_list|,
comment|/* src_mask */
literal|0x07ff2fff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_BASE_ABS
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_BASE_ABS"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_ALU_PCREL7_0
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|12
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_ALU_PCREL_7_0"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x00000fff
argument_list|,
comment|/* src_mask */
literal|0x00000fff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_ALU_PCREL15_8
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|12
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|8
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_ALU_PCREL_15_8"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x00000fff
argument_list|,
comment|/* src_mask */
literal|0x00000fff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_ALU_PCREL23_15
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|12
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|16
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_ALU_PCREL_23_15"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x00000fff
argument_list|,
comment|/* src_mask */
literal|0x00000fff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_LDR_SBREL_11_0
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|12
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_LDR_SBREL_11_0"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x00000fff
argument_list|,
comment|/* src_mask */
literal|0x00000fff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_ALU_SBREL_19_12
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|12
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_ALU_SBREL_19_12"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x000ff000
argument_list|,
comment|/* src_mask */
literal|0x000ff000
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_ALU_SBREL_27_20
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|20
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_ALU_SBREL_27_20"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x0ff00000
argument_list|,
comment|/* src_mask */
literal|0x0ff00000
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_TARGET1
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_TARGET1"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_ROSEGREL32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_ROSEGREL32"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_V4BX
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_V4BX"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_TARGET2
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_TARGET2"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_PREL31
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|31
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_PREL31"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x7fffffff
argument_list|,
comment|/* src_mask */
literal|0x7fffffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_MOVW_ABS_NC
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_MOVW_ABS_NC"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_MOVT_ABS
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_MOVT_ABS"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_MOVW_PREL_NC
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_MOVW_PREL_NC"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_MOVT_PREL
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_MOVT_PREL"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_THM_MOVW_ABS_NC
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_THM_MOVW_ABS_NC"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x040f70ff
argument_list|,
comment|/* src_mask */
literal|0x040f70ff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_THM_MOVT_ABS
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_THM_MOVT_ABS"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x040f70ff
argument_list|,
comment|/* src_mask */
literal|0x040f70ff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_THM_MOVW_PREL_NC
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_THM_MOVW_PREL_NC"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x040f70ff
argument_list|,
comment|/* src_mask */
literal|0x040f70ff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_THM_MOVT_PREL
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_THM_MOVT_PREL"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x040f70ff
argument_list|,
comment|/* src_mask */
literal|0x040f70ff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_THM_JUMP19
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|19
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_THM_JUMP19"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x043f2fff
argument_list|,
comment|/* src_mask */
literal|0x043f2fff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_THM_JUMP6
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|6
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_unsigned
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_THM_JUMP6"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x02f8
argument_list|,
comment|/* src_mask */
literal|0x02f8
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* These are declared as 13-bit signed relocations because we can      address -4095 .. 4095(base) by altering ADDW to SUBW or vice      versa.  */
name|HOWTO
argument_list|(
name|R_ARM_THM_ALU_PREL_11_0
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|13
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_THM_ALU_PREL_11_0"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_THM_PC12
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|13
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_THM_PC12"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_ABS32_NOI
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_ABS32_NOI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_REL32_NOI
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_REL32_NOI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Group relocations.  */
name|HOWTO
argument_list|(
name|R_ARM_ALU_PC_G0_NC
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_ALU_PC_G0_NC"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_ALU_PC_G0
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_ALU_PC_G0"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_ALU_PC_G1_NC
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_ALU_PC_G1_NC"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_ALU_PC_G1
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_ALU_PC_G1"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_ALU_PC_G2
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_ALU_PC_G2"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_LDR_PC_G1
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_LDR_PC_G1"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_LDR_PC_G2
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_LDR_PC_G2"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_LDRS_PC_G0
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_LDRS_PC_G0"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_LDRS_PC_G1
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_LDRS_PC_G1"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_LDRS_PC_G2
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_LDRS_PC_G2"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_LDC_PC_G0
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_LDC_PC_G0"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_LDC_PC_G1
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_LDC_PC_G1"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_LDC_PC_G2
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_LDC_PC_G2"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_ALU_SB_G0_NC
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_ALU_SB_G0_NC"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_ALU_SB_G0
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_ALU_SB_G0"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_ALU_SB_G1_NC
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_ALU_SB_G1_NC"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_ALU_SB_G1
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_ALU_SB_G1"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_ALU_SB_G2
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_ALU_SB_G2"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_LDR_SB_G0
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_LDR_SB_G0"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_LDR_SB_G1
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_LDR_SB_G1"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_LDR_SB_G2
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_LDR_SB_G2"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_LDRS_SB_G0
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_LDRS_SB_G0"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_LDRS_SB_G1
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_LDRS_SB_G1"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_LDRS_SB_G2
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_LDRS_SB_G2"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_LDC_SB_G0
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_LDC_SB_G0"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_LDC_SB_G1
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_LDC_SB_G1"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_LDC_SB_G2
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_LDC_SB_G2"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* End of group relocations.  */
name|HOWTO
argument_list|(
name|R_ARM_MOVW_BREL_NC
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_MOVW_BREL_NC"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_MOVT_BREL
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_MOVT_BREL"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_MOVW_BREL
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_MOVW_BREL"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_THM_MOVW_BREL_NC
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_THM_MOVW_BREL_NC"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x040f70ff
argument_list|,
comment|/* src_mask */
literal|0x040f70ff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_THM_MOVT_BREL
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_THM_MOVT_BREL"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x040f70ff
argument_list|,
comment|/* src_mask */
literal|0x040f70ff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_THM_MOVW_BREL
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_THM_MOVW_BREL"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x040f70ff
argument_list|,
comment|/* src_mask */
literal|0x040f70ff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|EMPTY_HOWTO
argument_list|(
literal|90
argument_list|)
block|,
comment|/* unallocated */
name|EMPTY_HOWTO
argument_list|(
literal|91
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|92
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|93
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_ARM_PLT32_ABS
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_PLT32_ABS"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_GOT_ABS
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_GOT_ABS"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_GOT_PREL
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_GOT_PREL"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_GOT_BREL12
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|12
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_GOT_BREL12"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x00000fff
argument_list|,
comment|/* src_mask */
literal|0x00000fff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_GOTOFF12
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|12
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_GOTOFF12"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x00000fff
argument_list|,
comment|/* src_mask */
literal|0x00000fff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|EMPTY_HOWTO
argument_list|(
name|R_ARM_GOTRELAX
argument_list|)
block|,
comment|/* reserved for future GOT-load optimizations */
comment|/* GNU extension to record C++ vtable member usage */
name|HOWTO
argument_list|(
name|R_ARM_GNU_VTENTRY
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|_bfd_elf_rel_vtable_reloc_fn
argument_list|,
comment|/* special_function */
literal|"R_ARM_GNU_VTENTRY"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* GNU extension to record C++ vtable hierarchy */
name|HOWTO
argument_list|(
name|R_ARM_GNU_VTINHERIT
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|NULL
argument_list|,
comment|/* special_function */
literal|"R_ARM_GNU_VTINHERIT"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_THM_JUMP11
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|11
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_THM_JUMP11"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x000007ff
argument_list|,
comment|/* src_mask */
literal|0x000007ff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_THM_JUMP8
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_THM_JUMP8"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x000000ff
argument_list|,
comment|/* src_mask */
literal|0x000000ff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* TLS relocations */
name|HOWTO
argument_list|(
name|R_ARM_TLS_GD32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|NULL
argument_list|,
comment|/* special_function */
literal|"R_ARM_TLS_GD32"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_TLS_LDM32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_TLS_LDM32"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_TLS_LDO32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_TLS_LDO32"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_TLS_IE32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|NULL
argument_list|,
comment|/* special_function */
literal|"R_ARM_TLS_IE32"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_TLS_LE32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_TLS_LE32"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_TLS_LDO12
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|12
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_TLS_LDO12"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x00000fff
argument_list|,
comment|/* src_mask */
literal|0x00000fff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_TLS_LE12
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|12
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_TLS_LE12"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x00000fff
argument_list|,
comment|/* src_mask */
literal|0x00000fff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_TLS_IE12GP
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|12
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_TLS_IE12GP"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x00000fff
argument_list|,
comment|/* src_mask */
literal|0x00000fff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 112-127 private relocations    128 R_ARM_ME_TOO, obsolete    129-255 unallocated in AAELF.     249-255 extended, currently unused, relocations:  */
end_comment

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|elf32_arm_howto_table_2
index|[
literal|4
index|]
init|=
block|{
name|HOWTO
argument_list|(
name|R_ARM_RREL32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_RREL32"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_RABS32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_RABS32"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_ARM_RPC24
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_RPC24"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
argument|R_ARM_RBASE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
argument|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
argument|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
argument|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_ARM_RBASE"
argument_list|,
comment|/* name */
argument|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
argument|FALSE
argument_list|)
comment|/* pcrel_offset */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|elf32_arm_howto_from_type
parameter_list|(
name|unsigned
name|int
name|r_type
parameter_list|)
block|{
if|if
condition|(
name|r_type
operator|<
name|NUM_ELEM
argument_list|(
name|elf32_arm_howto_table_1
argument_list|)
condition|)
return|return
operator|&
name|elf32_arm_howto_table_1
index|[
name|r_type
index|]
return|;
if|if
condition|(
name|r_type
operator|>=
name|R_ARM_RREL32
operator|&&
name|r_type
operator|<
name|R_ARM_RREL32
operator|+
name|NUM_ELEM
argument_list|(
name|elf32_arm_howto_table_2
argument_list|)
condition|)
return|return
operator|&
name|elf32_arm_howto_table_2
index|[
name|r_type
operator|-
name|R_ARM_RREL32
index|]
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|elf32_arm_info_to_howto
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|arelent
modifier|*
name|bfd_reloc
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|elf_reloc
parameter_list|)
block|{
name|unsigned
name|int
name|r_type
decl_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|elf_reloc
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|bfd_reloc
operator|->
name|howto
operator|=
name|elf32_arm_howto_from_type
argument_list|(
name|r_type
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|elf32_arm_reloc_map
block|{
name|bfd_reloc_code_real_type
name|bfd_reloc_val
decl_stmt|;
name|unsigned
name|char
name|elf_reloc_val
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* All entries in this list must also be present in elf32_arm_howto_table.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|elf32_arm_reloc_map
name|elf32_arm_reloc_map
index|[]
init|=
block|{
block|{
name|BFD_RELOC_NONE
block|,
name|R_ARM_NONE
block|}
block|,
block|{
name|BFD_RELOC_ARM_PCREL_BRANCH
block|,
name|R_ARM_PC24
block|}
block|,
block|{
name|BFD_RELOC_ARM_PCREL_CALL
block|,
name|R_ARM_CALL
block|}
block|,
block|{
name|BFD_RELOC_ARM_PCREL_JUMP
block|,
name|R_ARM_JUMP24
block|}
block|,
block|{
name|BFD_RELOC_ARM_PCREL_BLX
block|,
name|R_ARM_XPC25
block|}
block|,
block|{
name|BFD_RELOC_THUMB_PCREL_BLX
block|,
name|R_ARM_THM_XPC22
block|}
block|,
block|{
name|BFD_RELOC_32
block|,
name|R_ARM_ABS32
block|}
block|,
block|{
name|BFD_RELOC_32_PCREL
block|,
name|R_ARM_REL32
block|}
block|,
block|{
name|BFD_RELOC_8
block|,
name|R_ARM_ABS8
block|}
block|,
block|{
name|BFD_RELOC_16
block|,
name|R_ARM_ABS16
block|}
block|,
block|{
name|BFD_RELOC_ARM_OFFSET_IMM
block|,
name|R_ARM_ABS12
block|}
block|,
block|{
name|BFD_RELOC_ARM_THUMB_OFFSET
block|,
name|R_ARM_THM_ABS5
block|}
block|,
block|{
name|BFD_RELOC_THUMB_PCREL_BRANCH25
block|,
name|R_ARM_THM_JUMP24
block|}
block|,
block|{
name|BFD_RELOC_THUMB_PCREL_BRANCH23
block|,
name|R_ARM_THM_CALL
block|}
block|,
block|{
name|BFD_RELOC_THUMB_PCREL_BRANCH12
block|,
name|R_ARM_THM_JUMP11
block|}
block|,
block|{
name|BFD_RELOC_THUMB_PCREL_BRANCH20
block|,
name|R_ARM_THM_JUMP19
block|}
block|,
block|{
name|BFD_RELOC_THUMB_PCREL_BRANCH9
block|,
name|R_ARM_THM_JUMP8
block|}
block|,
block|{
name|BFD_RELOC_THUMB_PCREL_BRANCH7
block|,
name|R_ARM_THM_JUMP6
block|}
block|,
block|{
name|BFD_RELOC_ARM_GLOB_DAT
block|,
name|R_ARM_GLOB_DAT
block|}
block|,
block|{
name|BFD_RELOC_ARM_JUMP_SLOT
block|,
name|R_ARM_JUMP_SLOT
block|}
block|,
block|{
name|BFD_RELOC_ARM_RELATIVE
block|,
name|R_ARM_RELATIVE
block|}
block|,
block|{
name|BFD_RELOC_ARM_GOTOFF
block|,
name|R_ARM_GOTOFF32
block|}
block|,
block|{
name|BFD_RELOC_ARM_GOTPC
block|,
name|R_ARM_GOTPC
block|}
block|,
block|{
name|BFD_RELOC_ARM_GOT32
block|,
name|R_ARM_GOT32
block|}
block|,
block|{
name|BFD_RELOC_ARM_PLT32
block|,
name|R_ARM_PLT32
block|}
block|,
block|{
name|BFD_RELOC_ARM_TARGET1
block|,
name|R_ARM_TARGET1
block|}
block|,
block|{
name|BFD_RELOC_ARM_ROSEGREL32
block|,
name|R_ARM_ROSEGREL32
block|}
block|,
block|{
name|BFD_RELOC_ARM_SBREL32
block|,
name|R_ARM_SBREL32
block|}
block|,
block|{
name|BFD_RELOC_ARM_PREL31
block|,
name|R_ARM_PREL31
block|}
block|,
block|{
name|BFD_RELOC_ARM_TARGET2
block|,
name|R_ARM_TARGET2
block|}
block|,
block|{
name|BFD_RELOC_ARM_PLT32
block|,
name|R_ARM_PLT32
block|}
block|,
block|{
name|BFD_RELOC_ARM_TLS_GD32
block|,
name|R_ARM_TLS_GD32
block|}
block|,
block|{
name|BFD_RELOC_ARM_TLS_LDO32
block|,
name|R_ARM_TLS_LDO32
block|}
block|,
block|{
name|BFD_RELOC_ARM_TLS_LDM32
block|,
name|R_ARM_TLS_LDM32
block|}
block|,
block|{
name|BFD_RELOC_ARM_TLS_DTPMOD32
block|,
name|R_ARM_TLS_DTPMOD32
block|}
block|,
block|{
name|BFD_RELOC_ARM_TLS_DTPOFF32
block|,
name|R_ARM_TLS_DTPOFF32
block|}
block|,
block|{
name|BFD_RELOC_ARM_TLS_TPOFF32
block|,
name|R_ARM_TLS_TPOFF32
block|}
block|,
block|{
name|BFD_RELOC_ARM_TLS_IE32
block|,
name|R_ARM_TLS_IE32
block|}
block|,
block|{
name|BFD_RELOC_ARM_TLS_LE32
block|,
name|R_ARM_TLS_LE32
block|}
block|,
block|{
name|BFD_RELOC_VTABLE_INHERIT
block|,
name|R_ARM_GNU_VTINHERIT
block|}
block|,
block|{
name|BFD_RELOC_VTABLE_ENTRY
block|,
name|R_ARM_GNU_VTENTRY
block|}
block|,
block|{
name|BFD_RELOC_ARM_MOVW
block|,
name|R_ARM_MOVW_ABS_NC
block|}
block|,
block|{
name|BFD_RELOC_ARM_MOVT
block|,
name|R_ARM_MOVT_ABS
block|}
block|,
block|{
name|BFD_RELOC_ARM_MOVW_PCREL
block|,
name|R_ARM_MOVW_PREL_NC
block|}
block|,
block|{
name|BFD_RELOC_ARM_MOVT_PCREL
block|,
name|R_ARM_MOVT_PREL
block|}
block|,
block|{
name|BFD_RELOC_ARM_THUMB_MOVW
block|,
name|R_ARM_THM_MOVW_ABS_NC
block|}
block|,
block|{
name|BFD_RELOC_ARM_THUMB_MOVT
block|,
name|R_ARM_THM_MOVT_ABS
block|}
block|,
block|{
name|BFD_RELOC_ARM_THUMB_MOVW_PCREL
block|,
name|R_ARM_THM_MOVW_PREL_NC
block|}
block|,
block|{
name|BFD_RELOC_ARM_THUMB_MOVT_PCREL
block|,
name|R_ARM_THM_MOVT_PREL
block|}
block|,
block|{
name|BFD_RELOC_ARM_ALU_PC_G0_NC
block|,
name|R_ARM_ALU_PC_G0_NC
block|}
block|,
block|{
name|BFD_RELOC_ARM_ALU_PC_G0
block|,
name|R_ARM_ALU_PC_G0
block|}
block|,
block|{
name|BFD_RELOC_ARM_ALU_PC_G1_NC
block|,
name|R_ARM_ALU_PC_G1_NC
block|}
block|,
block|{
name|BFD_RELOC_ARM_ALU_PC_G1
block|,
name|R_ARM_ALU_PC_G1
block|}
block|,
block|{
name|BFD_RELOC_ARM_ALU_PC_G2
block|,
name|R_ARM_ALU_PC_G2
block|}
block|,
block|{
name|BFD_RELOC_ARM_LDR_PC_G0
block|,
name|R_ARM_LDR_PC_G0
block|}
block|,
block|{
name|BFD_RELOC_ARM_LDR_PC_G1
block|,
name|R_ARM_LDR_PC_G1
block|}
block|,
block|{
name|BFD_RELOC_ARM_LDR_PC_G2
block|,
name|R_ARM_LDR_PC_G2
block|}
block|,
block|{
name|BFD_RELOC_ARM_LDRS_PC_G0
block|,
name|R_ARM_LDRS_PC_G0
block|}
block|,
block|{
name|BFD_RELOC_ARM_LDRS_PC_G1
block|,
name|R_ARM_LDRS_PC_G1
block|}
block|,
block|{
name|BFD_RELOC_ARM_LDRS_PC_G2
block|,
name|R_ARM_LDRS_PC_G2
block|}
block|,
block|{
name|BFD_RELOC_ARM_LDC_PC_G0
block|,
name|R_ARM_LDC_PC_G0
block|}
block|,
block|{
name|BFD_RELOC_ARM_LDC_PC_G1
block|,
name|R_ARM_LDC_PC_G1
block|}
block|,
block|{
name|BFD_RELOC_ARM_LDC_PC_G2
block|,
name|R_ARM_LDC_PC_G2
block|}
block|,
block|{
name|BFD_RELOC_ARM_ALU_SB_G0_NC
block|,
name|R_ARM_ALU_SB_G0_NC
block|}
block|,
block|{
name|BFD_RELOC_ARM_ALU_SB_G0
block|,
name|R_ARM_ALU_SB_G0
block|}
block|,
block|{
name|BFD_RELOC_ARM_ALU_SB_G1_NC
block|,
name|R_ARM_ALU_SB_G1_NC
block|}
block|,
block|{
name|BFD_RELOC_ARM_ALU_SB_G1
block|,
name|R_ARM_ALU_SB_G1
block|}
block|,
block|{
name|BFD_RELOC_ARM_ALU_SB_G2
block|,
name|R_ARM_ALU_SB_G2
block|}
block|,
block|{
name|BFD_RELOC_ARM_LDR_SB_G0
block|,
name|R_ARM_LDR_SB_G0
block|}
block|,
block|{
name|BFD_RELOC_ARM_LDR_SB_G1
block|,
name|R_ARM_LDR_SB_G1
block|}
block|,
block|{
name|BFD_RELOC_ARM_LDR_SB_G2
block|,
name|R_ARM_LDR_SB_G2
block|}
block|,
block|{
name|BFD_RELOC_ARM_LDRS_SB_G0
block|,
name|R_ARM_LDRS_SB_G0
block|}
block|,
block|{
name|BFD_RELOC_ARM_LDRS_SB_G1
block|,
name|R_ARM_LDRS_SB_G1
block|}
block|,
block|{
name|BFD_RELOC_ARM_LDRS_SB_G2
block|,
name|R_ARM_LDRS_SB_G2
block|}
block|,
block|{
name|BFD_RELOC_ARM_LDC_SB_G0
block|,
name|R_ARM_LDC_SB_G0
block|}
block|,
block|{
name|BFD_RELOC_ARM_LDC_SB_G1
block|,
name|R_ARM_LDC_SB_G1
block|}
block|,
block|{
name|BFD_RELOC_ARM_LDC_SB_G2
block|,
name|R_ARM_LDC_SB_G2
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|elf32_arm_reloc_type_lookup
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd_reloc_code_real_type
name|code
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_ELEM
argument_list|(
name|elf32_arm_reloc_map
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|elf32_arm_reloc_map
index|[
name|i
index|]
operator|.
name|bfd_reloc_val
operator|==
name|code
condition|)
return|return
name|elf32_arm_howto_from_type
argument_list|(
name|elf32_arm_reloc_map
index|[
name|i
index|]
operator|.
name|elf_reloc_val
argument_list|)
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|elf32_arm_reloc_name_lookup
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|r_name
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|elf32_arm_howto_table_1
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|elf32_arm_howto_table_1
index|[
literal|0
index|]
argument_list|)
operator|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|elf32_arm_howto_table_1
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
operator|&&
name|strcasecmp
argument_list|(
name|elf32_arm_howto_table_1
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|r_name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|&
name|elf32_arm_howto_table_1
index|[
name|i
index|]
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|elf32_arm_howto_table_2
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|elf32_arm_howto_table_2
index|[
literal|0
index|]
argument_list|)
operator|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|elf32_arm_howto_table_2
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
operator|&&
name|strcasecmp
argument_list|(
name|elf32_arm_howto_table_2
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|r_name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|&
name|elf32_arm_howto_table_2
index|[
name|i
index|]
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Support for core dump NOTE sections */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_arm_nabi_grok_prstatus
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Note
modifier|*
name|note
parameter_list|)
block|{
name|int
name|offset
decl_stmt|;
name|size_t
name|size
decl_stmt|;
switch|switch
condition|(
name|note
operator|->
name|descsz
condition|)
block|{
default|default:
return|return
name|FALSE
return|;
case|case
literal|148
case|:
comment|/* Linux/ARM 32-bit*/
comment|/* pr_cursig */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_signal
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|note
operator|->
name|descdata
operator|+
literal|12
argument_list|)
expr_stmt|;
comment|/* pr_pid */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_pid
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|note
operator|->
name|descdata
operator|+
literal|24
argument_list|)
expr_stmt|;
comment|/* pr_reg */
name|offset
operator|=
literal|72
expr_stmt|;
name|size
operator|=
literal|72
expr_stmt|;
break|break;
case|case
literal|96
case|:
comment|/* FreeBSD/ARM */
comment|/* pr_cursig */
if|if
condition|(
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_signal
operator|==
literal|0
condition|)
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_signal
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
operator|(
name|note
operator|->
name|descdata
operator|)
operator|)
index|[
literal|5
index|]
expr_stmt|;
comment|/* pr_pid */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_pid
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
operator|(
name|note
operator|->
name|descdata
operator|)
operator|)
index|[
literal|6
index|]
expr_stmt|;
comment|/* pr_reg */
name|offset
operator|=
literal|28
expr_stmt|;
name|size
operator|=
literal|68
expr_stmt|;
break|break;
block|}
comment|/* Make a ".reg/999" section.  */
return|return
name|_bfd_elfcore_make_pseudosection
argument_list|(
name|abfd
argument_list|,
literal|".reg"
argument_list|,
name|size
argument_list|,
name|note
operator|->
name|descpos
operator|+
name|offset
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elf32_arm_nabi_grok_psinfo
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Note
modifier|*
name|note
parameter_list|)
block|{
switch|switch
condition|(
name|note
operator|->
name|descsz
condition|)
block|{
default|default:
return|return
name|FALSE
return|;
case|case
literal|124
case|:
comment|/* Linux/ARM elf_prpsinfo */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_program
operator|=
name|_bfd_elfcore_strndup
argument_list|(
name|abfd
argument_list|,
name|note
operator|->
name|descdata
operator|+
literal|28
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_command
operator|=
name|_bfd_elfcore_strndup
argument_list|(
name|abfd
argument_list|,
name|note
operator|->
name|descdata
operator|+
literal|44
argument_list|,
literal|80
argument_list|)
expr_stmt|;
block|}
comment|/* Note that for some reason, a spurious space is tacked      onto the end of the args in some (at least one anyway)      implementations, so strip it off if it exists.  */
block|{
name|char
modifier|*
name|command
init|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_command
decl_stmt|;
name|int
name|n
init|=
name|strlen
argument_list|(
name|command
argument_list|)
decl_stmt|;
if|if
condition|(
literal|0
operator|<
name|n
operator|&&
name|command
index|[
name|n
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
name|command
index|[
name|n
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_define
define|#
directive|define
name|TARGET_LITTLE_SYM
value|bfd_elf32_littlearm_vec
end_define

begin_define
define|#
directive|define
name|TARGET_LITTLE_NAME
value|"elf32-littlearm"
end_define

begin_define
define|#
directive|define
name|TARGET_BIG_SYM
value|bfd_elf32_bigarm_vec
end_define

begin_define
define|#
directive|define
name|TARGET_BIG_NAME
value|"elf32-bigarm"
end_define

begin_define
define|#
directive|define
name|elf_backend_grok_prstatus
value|elf32_arm_nabi_grok_prstatus
end_define

begin_define
define|#
directive|define
name|elf_backend_grok_psinfo
value|elf32_arm_nabi_grok_psinfo
end_define

begin_typedef
typedef|typedef
name|unsigned
name|long
name|int
name|insn32
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|short
name|int
name|insn16
typedef|;
end_typedef

begin_comment
comment|/* In lieu of proper flags, assume all EABIv4 or later objects are    interworkable.  */
end_comment

begin_define
define|#
directive|define
name|INTERWORK_FLAG
parameter_list|(
name|abfd
parameter_list|)
define|\
value|(EF_ARM_EABI_VERSION (elf_elfheader (abfd)->e_flags)>= EF_ARM_EABI_VER4 \   || (elf_elfheader (abfd)->e_flags& EF_ARM_INTERWORK))
end_define

begin_comment
comment|/* The linker script knows the section names for placement.    The entry_names are used to do simple name mangling on the stubs.    Given a function name, and its type, the stub can be found. The    name can be changed. The only requirement is the %s be present.  */
end_comment

begin_define
define|#
directive|define
name|THUMB2ARM_GLUE_SECTION_NAME
value|".glue_7t"
end_define

begin_define
define|#
directive|define
name|THUMB2ARM_GLUE_ENTRY_NAME
value|"__%s_from_thumb"
end_define

begin_define
define|#
directive|define
name|ARM2THUMB_GLUE_SECTION_NAME
value|".glue_7"
end_define

begin_define
define|#
directive|define
name|ARM2THUMB_GLUE_ENTRY_NAME
value|"__%s_from_arm"
end_define

begin_define
define|#
directive|define
name|VFP11_ERRATUM_VENEER_SECTION_NAME
value|".vfp11_veneer"
end_define

begin_define
define|#
directive|define
name|VFP11_ERRATUM_VENEER_ENTRY_NAME
value|"__vfp11_veneer_%x"
end_define

begin_comment
comment|/* The name of the dynamic interpreter.  This is put in the .interp    section.  */
end_comment

begin_define
define|#
directive|define
name|ELF_DYNAMIC_INTERPRETER
value|"/usr/lib/ld.so.1"
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|FOUR_WORD_PLT
end_ifdef

begin_comment
comment|/* The first entry in a procedure linkage table looks like    this.  It is set up so that any shared library function that is    called before the relocation has been set up calls the dynamic    linker first.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|bfd_vma
name|elf32_arm_plt0_entry
index|[]
init|=
block|{
literal|0xe52de004
block|,
comment|/* str   lr, [sp, #-4]! */
literal|0xe59fe010
block|,
comment|/* ldr   lr, [pc, #16]  */
literal|0xe08fe00e
block|,
comment|/* add   lr, pc, lr     */
literal|0xe5bef008
block|,
comment|/* ldr   pc, [lr, #8]!  */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Subsequent entries in a procedure linkage table look like    this.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|bfd_vma
name|elf32_arm_plt_entry
index|[]
init|=
block|{
literal|0xe28fc600
block|,
comment|/* add   ip, pc, #NN	*/
literal|0xe28cca00
block|,
comment|/* add	 ip, ip, #NN	*/
literal|0xe5bcf000
block|,
comment|/* ldr	 pc, [ip, #NN]! */
literal|0x00000000
block|,
comment|/* unused		*/
block|}
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* The first entry in a procedure linkage table looks like    this.  It is set up so that any shared library function that is    called before the relocation has been set up calls the dynamic    linker first.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|bfd_vma
name|elf32_arm_plt0_entry
index|[]
init|=
block|{
literal|0xe52de004
block|,
comment|/* str   lr, [sp, #-4]! */
literal|0xe59fe004
block|,
comment|/* ldr   lr, [pc, #4]   */
literal|0xe08fe00e
block|,
comment|/* add   lr, pc, lr     */
literal|0xe5bef008
block|,
comment|/* ldr   pc, [lr, #8]!  */
literal|0x00000000
block|,
comment|/*&GOT[0] - .          */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Subsequent entries in a procedure linkage table look like    this.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|bfd_vma
name|elf32_arm_plt_entry
index|[]
init|=
block|{
literal|0xe28fc600
block|,
comment|/* add   ip, pc, #0xNN00000 */
literal|0xe28cca00
block|,
comment|/* add	 ip, ip, #0xNN000   */
literal|0xe5bcf000
block|,
comment|/* ldr	 pc, [ip, #0xNNN]!  */
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The format of the first entry in the procedure linkage table    for a VxWorks executable.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|bfd_vma
name|elf32_arm_vxworks_exec_plt0_entry
index|[]
init|=
block|{
literal|0xe52dc008
block|,
comment|/* str    ip,[sp,#-8]!			*/
literal|0xe59fc000
block|,
comment|/* ldr    ip,[pc]			*/
literal|0xe59cf008
block|,
comment|/* ldr    pc,[ip,#8]			*/
literal|0x00000000
block|,
comment|/* .long  _GLOBAL_OFFSET_TABLE_		*/
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The format of subsequent entries in a VxWorks executable.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|bfd_vma
name|elf32_arm_vxworks_exec_plt_entry
index|[]
init|=
block|{
literal|0xe59fc000
block|,
comment|/* ldr    ip,[pc]			*/
literal|0xe59cf000
block|,
comment|/* ldr    pc,[ip]			*/
literal|0x00000000
block|,
comment|/* .long  @got				*/
literal|0xe59fc000
block|,
comment|/* ldr    ip,[pc]			*/
literal|0xea000000
block|,
comment|/* b      _PLT				*/
literal|0x00000000
block|,
comment|/* .long  @pltindex*sizeof(Elf32_Rela)	*/
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The format of entries in a VxWorks shared library.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|bfd_vma
name|elf32_arm_vxworks_shared_plt_entry
index|[]
init|=
block|{
literal|0xe59fc000
block|,
comment|/* ldr    ip,[pc]			*/
literal|0xe79cf009
block|,
comment|/* ldr    pc,[ip,r9]			*/
literal|0x00000000
block|,
comment|/* .long  @got				*/
literal|0xe59fc000
block|,
comment|/* ldr    ip,[pc]			*/
literal|0xe599f008
block|,
comment|/* ldr    pc,[r9,#8]			*/
literal|0x00000000
block|,
comment|/* .long  @pltindex*sizeof(Elf32_Rela)	*/
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* An initial stub used if the PLT entry is referenced from Thumb code.  */
end_comment

begin_define
define|#
directive|define
name|PLT_THUMB_STUB_SIZE
value|4
end_define

begin_decl_stmt
specifier|static
specifier|const
name|bfd_vma
name|elf32_arm_plt_thumb_stub
index|[]
init|=
block|{
literal|0x4778
block|,
comment|/* bx pc */
literal|0x46c0
comment|/* nop   */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The entries in a PLT when using a DLL-based target with multiple    address spaces.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|bfd_vma
name|elf32_arm_symbian_plt_entry
index|[]
init|=
block|{
literal|0xe51ff004
block|,
comment|/* ldr   pc, [pc, #-4] */
literal|0x00000000
block|,
comment|/* dcd   R_ARM_GLOB_DAT(X) */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used to build a map of a section.  This is required for mixed-endian    code/data.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|elf32_elf_section_map
block|{
name|bfd_vma
name|vma
decl_stmt|;
name|char
name|type
decl_stmt|;
block|}
name|elf32_arm_section_map
typedef|;
end_typedef

begin_comment
comment|/* Information about a VFP11 erratum veneer, or a branch to such a veneer.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|VFP11_ERRATUM_BRANCH_TO_ARM_VENEER
block|,
name|VFP11_ERRATUM_BRANCH_TO_THUMB_VENEER
block|,
name|VFP11_ERRATUM_ARM_VENEER
block|,
name|VFP11_ERRATUM_THUMB_VENEER
block|}
name|elf32_vfp11_erratum_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|elf32_vfp11_erratum_list
block|{
name|struct
name|elf32_vfp11_erratum_list
modifier|*
name|next
decl_stmt|;
name|bfd_vma
name|vma
decl_stmt|;
union|union
block|{
struct|struct
block|{
name|struct
name|elf32_vfp11_erratum_list
modifier|*
name|veneer
decl_stmt|;
name|unsigned
name|int
name|vfp_insn
decl_stmt|;
block|}
name|b
struct|;
struct|struct
block|{
name|struct
name|elf32_vfp11_erratum_list
modifier|*
name|branch
decl_stmt|;
name|unsigned
name|int
name|id
decl_stmt|;
block|}
name|v
struct|;
block|}
name|u
union|;
name|elf32_vfp11_erratum_type
name|type
decl_stmt|;
block|}
name|elf32_vfp11_erratum_list
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|_arm_elf_section_data
block|{
name|struct
name|bfd_elf_section_data
name|elf
decl_stmt|;
name|unsigned
name|int
name|mapcount
decl_stmt|;
name|unsigned
name|int
name|mapsize
decl_stmt|;
name|elf32_arm_section_map
modifier|*
name|map
decl_stmt|;
name|unsigned
name|int
name|erratumcount
decl_stmt|;
name|elf32_vfp11_erratum_list
modifier|*
name|erratumlist
decl_stmt|;
block|}
name|_arm_elf_section_data
typedef|;
end_typedef

begin_define
define|#
directive|define
name|elf32_arm_section_data
parameter_list|(
name|sec
parameter_list|)
define|\
value|((_arm_elf_section_data *) elf_section_data (sec))
end_define

begin_comment
comment|/* The size of the thread control block.  */
end_comment

begin_define
define|#
directive|define
name|TCB_SIZE
value|8
end_define

begin_struct
struct|struct
name|elf32_arm_obj_tdata
block|{
name|struct
name|elf_obj_tdata
name|root
decl_stmt|;
comment|/* tls_type for each local got entry.  */
name|char
modifier|*
name|local_got_tls_type
decl_stmt|;
comment|/* Zero to warn when linking objects with incompatible enum sizes.  */
name|int
name|no_enum_size_warning
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|elf32_arm_tdata
parameter_list|(
name|abfd
parameter_list|)
define|\
value|((struct elf32_arm_obj_tdata *) (abfd)->tdata.any)
end_define

begin_define
define|#
directive|define
name|elf32_arm_local_got_tls_type
parameter_list|(
name|abfd
parameter_list|)
define|\
value|(elf32_arm_tdata (abfd)->local_got_tls_type)
end_define

begin_function
specifier|static
name|bfd_boolean
name|elf32_arm_mkobject
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
if|if
condition|(
name|abfd
operator|->
name|tdata
operator|.
name|any
operator|==
name|NULL
condition|)
block|{
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|elf32_arm_obj_tdata
argument_list|)
decl_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|any
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|tdata
operator|.
name|any
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|bfd_elf_mkobject
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The ARM linker needs to keep track of the number of relocs that it    decides to copy in check_relocs for each symbol.  This is so that    it can discard PC relative relocs if it doesn't need them when    linking with -Bsymbolic.  We store the information in a field    extending the regular ELF linker hash table.  */
end_comment

begin_comment
comment|/* This structure keeps track of the number of relocs we have copied    for a given symbol.  */
end_comment

begin_struct
struct|struct
name|elf32_arm_relocs_copied
block|{
comment|/* Next section.  */
name|struct
name|elf32_arm_relocs_copied
modifier|*
name|next
decl_stmt|;
comment|/* A section in dynobj.  */
name|asection
modifier|*
name|section
decl_stmt|;
comment|/* Number of relocs copied in this section.  */
name|bfd_size_type
name|count
decl_stmt|;
comment|/* Number of PC-relative relocs copied in this section.  */
name|bfd_size_type
name|pc_count
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|elf32_arm_hash_entry
parameter_list|(
name|ent
parameter_list|)
value|((struct elf32_arm_link_hash_entry *)(ent))
end_define

begin_comment
comment|/* Arm ELF linker hash entry.  */
end_comment

begin_struct
struct|struct
name|elf32_arm_link_hash_entry
block|{
name|struct
name|elf_link_hash_entry
name|root
decl_stmt|;
comment|/* Number of PC relative relocs copied for this symbol.  */
name|struct
name|elf32_arm_relocs_copied
modifier|*
name|relocs_copied
decl_stmt|;
comment|/* We reference count Thumb references to a PLT entry separately,        so that we can emit the Thumb trampoline only if needed.  */
name|bfd_signed_vma
name|plt_thumb_refcount
decl_stmt|;
comment|/* Since PLT entries have variable size if the Thumb prologue is        used, we need to record the index into .got.plt instead of        recomputing it from the PLT offset.  */
name|bfd_signed_vma
name|plt_got_offset
decl_stmt|;
define|#
directive|define
name|GOT_UNKNOWN
value|0
define|#
directive|define
name|GOT_NORMAL
value|1
define|#
directive|define
name|GOT_TLS_GD
value|2
define|#
directive|define
name|GOT_TLS_IE
value|4
name|unsigned
name|char
name|tls_type
decl_stmt|;
comment|/* The symbol marking the real symbol location for exported thumb        symbols with Arm stubs.  */
name|struct
name|elf_link_hash_entry
modifier|*
name|export_glue
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Traverse an arm ELF linker hash table.  */
end_comment

begin_define
define|#
directive|define
name|elf32_arm_link_hash_traverse
parameter_list|(
name|table
parameter_list|,
name|func
parameter_list|,
name|info
parameter_list|)
define|\
value|(elf_link_hash_traverse						\    (&(table)->root,							\     (bfd_boolean (*) (struct elf_link_hash_entry *, void *)) (func),	\     (info)))
end_define

begin_comment
comment|/* Get the ARM elf linker hash table from a link_info structure.  */
end_comment

begin_define
define|#
directive|define
name|elf32_arm_hash_table
parameter_list|(
name|info
parameter_list|)
define|\
value|((struct elf32_arm_link_hash_table *) ((info)->hash))
end_define

begin_comment
comment|/* ARM ELF linker hash table.  */
end_comment

begin_struct
struct|struct
name|elf32_arm_link_hash_table
block|{
comment|/* The main hash table.  */
name|struct
name|elf_link_hash_table
name|root
decl_stmt|;
comment|/* The size in bytes of the section containing the Thumb-to-ARM glue.  */
name|bfd_size_type
name|thumb_glue_size
decl_stmt|;
comment|/* The size in bytes of the section containing the ARM-to-Thumb glue.  */
name|bfd_size_type
name|arm_glue_size
decl_stmt|;
comment|/* The size in bytes of the section containing glue for VFP11 erratum        veneers.  */
name|bfd_size_type
name|vfp11_erratum_glue_size
decl_stmt|;
comment|/* An arbitrary input BFD chosen to hold the glue sections.  */
name|bfd
modifier|*
name|bfd_of_glue_owner
decl_stmt|;
comment|/* Nonzero to output a BE8 image.  */
name|int
name|byteswap_code
decl_stmt|;
comment|/* Zero if R_ARM_TARGET1 means R_ARM_ABS32.        Nonzero if R_ARM_TARGET1 means R_ARM_REL32.  */
name|int
name|target1_is_rel
decl_stmt|;
comment|/* The relocation to use for R_ARM_TARGET2 relocations.  */
name|int
name|target2_reloc
decl_stmt|;
comment|/* Nonzero to fix BX instructions for ARMv4 targets.  */
name|int
name|fix_v4bx
decl_stmt|;
comment|/* Nonzero if the ARM/Thumb BLX instructions are available for use.  */
name|int
name|use_blx
decl_stmt|;
comment|/* What sort of code sequences we should look for which may trigger the        VFP11 denorm erratum.  */
name|bfd_arm_vfp11_fix
name|vfp11_fix
decl_stmt|;
comment|/* Global counter for the number of fixes we have emitted.  */
name|int
name|num_vfp11_fixes
decl_stmt|;
comment|/* Nonzero to force PIC branch veneers.  */
name|int
name|pic_veneer
decl_stmt|;
comment|/* The number of bytes in the initial entry in the PLT.  */
name|bfd_size_type
name|plt_header_size
decl_stmt|;
comment|/* The number of bytes in the subsequent PLT etries.  */
name|bfd_size_type
name|plt_entry_size
decl_stmt|;
comment|/* True if the target system is VxWorks.  */
name|int
name|vxworks_p
decl_stmt|;
comment|/* True if the target system is Symbian OS.  */
name|int
name|symbian_p
decl_stmt|;
comment|/* True if the target uses REL relocations.  */
name|int
name|use_rel
decl_stmt|;
comment|/* Short-cuts to get to dynamic linker sections.  */
name|asection
modifier|*
name|sgot
decl_stmt|;
name|asection
modifier|*
name|sgotplt
decl_stmt|;
name|asection
modifier|*
name|srelgot
decl_stmt|;
name|asection
modifier|*
name|splt
decl_stmt|;
name|asection
modifier|*
name|srelplt
decl_stmt|;
name|asection
modifier|*
name|sdynbss
decl_stmt|;
name|asection
modifier|*
name|srelbss
decl_stmt|;
comment|/* The (unloaded but important) VxWorks .rela.plt.unloaded section.  */
name|asection
modifier|*
name|srelplt2
decl_stmt|;
comment|/* Data for R_ARM_TLS_LDM32 relocations.  */
union|union
block|{
name|bfd_signed_vma
name|refcount
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
block|}
name|tls_ldm_got
union|;
comment|/* Small local sym to section mapping cache.  */
name|struct
name|sym_sec_cache
name|sym_sec
decl_stmt|;
comment|/* For convenience in allocate_dynrelocs.  */
name|bfd
modifier|*
name|obfd
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Create an entry in an ARM ELF linker hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|elf32_arm_link_hash_newfunc
parameter_list|(
name|struct
name|bfd_hash_entry
modifier|*
name|entry
parameter_list|,
name|struct
name|bfd_hash_table
modifier|*
name|table
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|struct
name|elf32_arm_link_hash_entry
modifier|*
name|ret
init|=
operator|(
expr|struct
name|elf32_arm_link_hash_entry
operator|*
operator|)
name|entry
decl_stmt|;
comment|/* Allocate the structure if it has not already been allocated by a      subclass.  */
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|elf32_arm_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
name|ret
operator|=
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|elf32_arm_link_hash_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
comment|/* Call the allocation method of the superclass.  */
name|ret
operator|=
operator|(
operator|(
expr|struct
name|elf32_arm_link_hash_entry
operator|*
operator|)
name|_bfd_elf_link_hash_newfunc
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|NULL
condition|)
block|{
name|ret
operator|->
name|relocs_copied
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|tls_type
operator|=
name|GOT_UNKNOWN
expr_stmt|;
name|ret
operator|->
name|plt_thumb_refcount
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|plt_got_offset
operator|=
operator|-
literal|1
expr_stmt|;
name|ret
operator|->
name|export_glue
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Return true if NAME is the name of the relocation section associated    with S.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|reloc_section_p
parameter_list|(
name|struct
name|elf32_arm_link_hash_table
modifier|*
name|htab
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|asection
modifier|*
name|s
parameter_list|)
block|{
if|if
condition|(
name|htab
operator|->
name|use_rel
condition|)
return|return
name|CONST_STRNEQ
argument_list|(
name|name
argument_list|,
literal|".rel"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|s
operator|->
name|name
argument_list|,
name|name
operator|+
literal|4
argument_list|)
operator|==
literal|0
return|;
else|else
return|return
name|CONST_STRNEQ
argument_list|(
name|name
argument_list|,
literal|".rela"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|s
operator|->
name|name
argument_list|,
name|name
operator|+
literal|5
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Create .got, .gotplt, and .rel(a).got sections in DYNOBJ, and set up    shortcuts to them in our hash table.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|create_got_section
parameter_list|(
name|bfd
modifier|*
name|dynobj
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|elf32_arm_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|htab
operator|=
name|elf32_arm_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* BPABI objects never have a GOT, or associated sections.  */
if|if
condition|(
name|htab
operator|->
name|symbian_p
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
operator|!
name|_bfd_elf_create_got_section
argument_list|(
name|dynobj
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|htab
operator|->
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
name|htab
operator|->
name|sgotplt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got.plt"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|htab
operator|->
name|sgot
operator|||
operator|!
name|htab
operator|->
name|sgotplt
condition|)
name|abort
argument_list|()
expr_stmt|;
name|htab
operator|->
name|srelgot
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|dynobj
argument_list|,
name|RELOC_SECTION
argument_list|(
name|htab
argument_list|,
literal|".got"
argument_list|)
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_READONLY
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|srelgot
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|htab
operator|->
name|srelgot
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Create .plt, .rel(a).plt, .got, .got.plt, .rel(a).got, .dynbss, and    .rel(a).bss sections in DYNOBJ, and set up shortcuts to them in our    hash table.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_arm_create_dynamic_sections
parameter_list|(
name|bfd
modifier|*
name|dynobj
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|elf32_arm_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|htab
operator|=
name|elf32_arm_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|htab
operator|->
name|sgot
operator|&&
operator|!
name|create_got_section
argument_list|(
name|dynobj
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|_bfd_elf_create_dynamic_sections
argument_list|(
name|dynobj
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|htab
operator|->
name|splt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
name|htab
operator|->
name|srelplt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|RELOC_SECTION
argument_list|(
name|htab
argument_list|,
literal|".plt"
argument_list|)
argument_list|)
expr_stmt|;
name|htab
operator|->
name|sdynbss
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynbss"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
name|htab
operator|->
name|srelbss
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|RELOC_SECTION
argument_list|(
name|htab
argument_list|,
literal|".bss"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|vxworks_p
condition|)
block|{
if|if
condition|(
operator|!
name|elf_vxworks_create_dynamic_sections
argument_list|(
name|dynobj
argument_list|,
name|info
argument_list|,
operator|&
name|htab
operator|->
name|srelplt2
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
name|htab
operator|->
name|plt_header_size
operator|=
literal|0
expr_stmt|;
name|htab
operator|->
name|plt_entry_size
operator|=
literal|4
operator|*
name|ARRAY_SIZE
argument_list|(
name|elf32_arm_vxworks_shared_plt_entry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|htab
operator|->
name|plt_header_size
operator|=
literal|4
operator|*
name|ARRAY_SIZE
argument_list|(
name|elf32_arm_vxworks_exec_plt0_entry
argument_list|)
expr_stmt|;
name|htab
operator|->
name|plt_entry_size
operator|=
literal|4
operator|*
name|ARRAY_SIZE
argument_list|(
name|elf32_arm_vxworks_exec_plt_entry
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|htab
operator|->
name|splt
operator|||
operator|!
name|htab
operator|->
name|srelplt
operator|||
operator|!
name|htab
operator|->
name|sdynbss
operator|||
operator|(
operator|!
name|info
operator|->
name|shared
operator|&&
operator|!
name|htab
operator|->
name|srelbss
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Copy the extra info we tack onto an elf_link_hash_entry.  */
end_comment

begin_function
specifier|static
name|void
name|elf32_arm_copy_indirect_symbol
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|dir
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|ind
parameter_list|)
block|{
name|struct
name|elf32_arm_link_hash_entry
modifier|*
name|edir
decl_stmt|,
modifier|*
name|eind
decl_stmt|;
name|edir
operator|=
operator|(
expr|struct
name|elf32_arm_link_hash_entry
operator|*
operator|)
name|dir
expr_stmt|;
name|eind
operator|=
operator|(
expr|struct
name|elf32_arm_link_hash_entry
operator|*
operator|)
name|ind
expr_stmt|;
if|if
condition|(
name|eind
operator|->
name|relocs_copied
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|edir
operator|->
name|relocs_copied
operator|!=
name|NULL
condition|)
block|{
name|struct
name|elf32_arm_relocs_copied
modifier|*
modifier|*
name|pp
decl_stmt|;
name|struct
name|elf32_arm_relocs_copied
modifier|*
name|p
decl_stmt|;
comment|/* Add reloc counts against the indirect sym to the direct sym 	     list.  Merge any entries against the same section.  */
for|for
control|(
name|pp
operator|=
operator|&
name|eind
operator|->
name|relocs_copied
init|;
operator|(
name|p
operator|=
operator|*
name|pp
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
name|struct
name|elf32_arm_relocs_copied
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|q
operator|=
name|edir
operator|->
name|relocs_copied
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|next
control|)
if|if
condition|(
name|q
operator|->
name|section
operator|==
name|p
operator|->
name|section
condition|)
block|{
name|q
operator|->
name|pc_count
operator|+=
name|p
operator|->
name|pc_count
expr_stmt|;
name|q
operator|->
name|count
operator|+=
name|p
operator|->
name|count
expr_stmt|;
operator|*
name|pp
operator|=
name|p
operator|->
name|next
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
name|pp
operator|=
operator|&
name|p
operator|->
name|next
expr_stmt|;
block|}
operator|*
name|pp
operator|=
name|edir
operator|->
name|relocs_copied
expr_stmt|;
block|}
name|edir
operator|->
name|relocs_copied
operator|=
name|eind
operator|->
name|relocs_copied
expr_stmt|;
name|eind
operator|->
name|relocs_copied
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ind
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
condition|)
block|{
comment|/* Copy over PLT info.  */
name|edir
operator|->
name|plt_thumb_refcount
operator|+=
name|eind
operator|->
name|plt_thumb_refcount
expr_stmt|;
name|eind
operator|->
name|plt_thumb_refcount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dir
operator|->
name|got
operator|.
name|refcount
operator|<=
literal|0
condition|)
block|{
name|edir
operator|->
name|tls_type
operator|=
name|eind
operator|->
name|tls_type
expr_stmt|;
name|eind
operator|->
name|tls_type
operator|=
name|GOT_UNKNOWN
expr_stmt|;
block|}
block|}
name|_bfd_elf_link_hash_copy_indirect
argument_list|(
name|info
argument_list|,
name|dir
argument_list|,
name|ind
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create an ARM elf linker hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_link_hash_table
modifier|*
name|elf32_arm_link_hash_table_create
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|struct
name|elf32_arm_link_hash_table
modifier|*
name|ret
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|elf32_arm_link_hash_table
argument_list|)
decl_stmt|;
name|ret
operator|=
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|_bfd_elf_link_hash_table_init
argument_list|(
operator|&
name|ret
operator|->
name|root
argument_list|,
name|abfd
argument_list|,
name|elf32_arm_link_hash_newfunc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|elf32_arm_link_hash_entry
argument_list|)
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ret
operator|->
name|sgot
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|sgotplt
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|srelgot
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|splt
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|srelplt
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|sdynbss
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|srelbss
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|srelplt2
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|thumb_glue_size
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|arm_glue_size
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|vfp11_fix
operator|=
name|BFD_ARM_VFP11_FIX_NONE
expr_stmt|;
name|ret
operator|->
name|vfp11_erratum_glue_size
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|num_vfp11_fixes
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|bfd_of_glue_owner
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|byteswap_code
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|target1_is_rel
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|target2_reloc
operator|=
name|R_ARM_NONE
expr_stmt|;
ifdef|#
directive|ifdef
name|FOUR_WORD_PLT
name|ret
operator|->
name|plt_header_size
operator|=
literal|16
expr_stmt|;
name|ret
operator|->
name|plt_entry_size
operator|=
literal|16
expr_stmt|;
else|#
directive|else
name|ret
operator|->
name|plt_header_size
operator|=
literal|20
expr_stmt|;
name|ret
operator|->
name|plt_entry_size
operator|=
literal|12
expr_stmt|;
endif|#
directive|endif
name|ret
operator|->
name|fix_v4bx
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|use_blx
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|vxworks_p
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|symbian_p
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|use_rel
operator|=
literal|1
expr_stmt|;
name|ret
operator|->
name|sym_sec
operator|.
name|abfd
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|obfd
operator|=
name|abfd
expr_stmt|;
name|ret
operator|->
name|tls_ldm_got
operator|.
name|refcount
operator|=
literal|0
expr_stmt|;
return|return
operator|&
name|ret
operator|->
name|root
operator|.
name|root
return|;
block|}
end_function

begin_comment
comment|/* Locate the Thumb encoded calling stub for NAME.  */
end_comment

begin_function
specifier|static
name|struct
name|elf_link_hash_entry
modifier|*
name|find_thumb_glue
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|link_info
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
parameter_list|)
block|{
name|char
modifier|*
name|tmp_name
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|hash
decl_stmt|;
name|struct
name|elf32_arm_link_hash_table
modifier|*
name|hash_table
decl_stmt|;
comment|/* We need a pointer to the armelf specific hash table.  */
name|hash_table
operator|=
name|elf32_arm_hash_table
argument_list|(
name|link_info
argument_list|)
expr_stmt|;
name|tmp_name
operator|=
name|bfd_malloc
argument_list|(
operator|(
name|bfd_size_type
operator|)
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|THUMB2ARM_GLUE_ENTRY_NAME
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|tmp_name
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tmp_name
argument_list|,
name|THUMB2ARM_GLUE_ENTRY_NAME
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|hash
operator|=
name|elf_link_hash_lookup
argument_list|(
operator|&
operator|(
name|hash_table
operator|)
operator|->
name|root
argument_list|,
name|tmp_name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash
operator|==
name|NULL
condition|)
name|asprintf
argument_list|(
name|error_message
argument_list|,
name|_
argument_list|(
literal|"unable to find THUMB glue '%s' for '%s'"
argument_list|)
argument_list|,
name|tmp_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp_name
argument_list|)
expr_stmt|;
return|return
name|hash
return|;
block|}
end_function

begin_comment
comment|/* Locate the ARM encoded calling stub for NAME.  */
end_comment

begin_function
specifier|static
name|struct
name|elf_link_hash_entry
modifier|*
name|find_arm_glue
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|link_info
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
parameter_list|)
block|{
name|char
modifier|*
name|tmp_name
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|myh
decl_stmt|;
name|struct
name|elf32_arm_link_hash_table
modifier|*
name|hash_table
decl_stmt|;
comment|/* We need a pointer to the elfarm specific hash table.  */
name|hash_table
operator|=
name|elf32_arm_hash_table
argument_list|(
name|link_info
argument_list|)
expr_stmt|;
name|tmp_name
operator|=
name|bfd_malloc
argument_list|(
operator|(
name|bfd_size_type
operator|)
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|ARM2THUMB_GLUE_ENTRY_NAME
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|tmp_name
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tmp_name
argument_list|,
name|ARM2THUMB_GLUE_ENTRY_NAME
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|myh
operator|=
name|elf_link_hash_lookup
argument_list|(
operator|&
operator|(
name|hash_table
operator|)
operator|->
name|root
argument_list|,
name|tmp_name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|myh
operator|==
name|NULL
condition|)
name|asprintf
argument_list|(
name|error_message
argument_list|,
name|_
argument_list|(
literal|"unable to find ARM glue '%s' for '%s'"
argument_list|)
argument_list|,
name|tmp_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp_name
argument_list|)
expr_stmt|;
return|return
name|myh
return|;
block|}
end_function

begin_comment
comment|/* ARM->Thumb glue (static images):     .arm    __func_from_arm:    ldr r12, __func_addr    bx  r12    __func_addr:    .word func    @ behave as if you saw a ARM_32 reloc.       (v5t static images)    .arm    __func_from_arm:    ldr pc, __func_addr    __func_addr:    .word func    @ behave as if you saw a ARM_32 reloc.       (relocatable images)    .arm    __func_from_arm:    ldr r12, __func_offset    add r12, r12, pc    bx  r12    __func_offset:    .word func - .    */
end_comment

begin_define
define|#
directive|define
name|ARM2THUMB_STATIC_GLUE_SIZE
value|12
end_define

begin_decl_stmt
specifier|static
specifier|const
name|insn32
name|a2t1_ldr_insn
init|=
literal|0xe59fc000
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|insn32
name|a2t2_bx_r12_insn
init|=
literal|0xe12fff1c
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|insn32
name|a2t3_func_addr_insn
init|=
literal|0x00000001
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ARM2THUMB_V5_STATIC_GLUE_SIZE
value|8
end_define

begin_decl_stmt
specifier|static
specifier|const
name|insn32
name|a2t1v5_ldr_insn
init|=
literal|0xe51ff004
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|insn32
name|a2t2v5_func_addr_insn
init|=
literal|0x00000001
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ARM2THUMB_PIC_GLUE_SIZE
value|16
end_define

begin_decl_stmt
specifier|static
specifier|const
name|insn32
name|a2t1p_ldr_insn
init|=
literal|0xe59fc004
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|insn32
name|a2t2p_add_pc_insn
init|=
literal|0xe08cc00f
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|insn32
name|a2t3p_bx_r12_insn
init|=
literal|0xe12fff1c
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Thumb->ARM:                          Thumb->(non-interworking aware) ARM     .thumb                               .thumb    .align 2                             .align 2    __func_from_thumb:              __func_from_thumb:    bx pc                                push {r6, lr}    nop                                  ldr  r6, __func_addr    .arm                                         mov  lr, pc    __func_change_to_arm:                        bx   r6    b func                       .arm    __func_back_to_thumb:    ldmia r13! {r6, lr}    bx    lr    __func_addr:    .word        func  */
end_comment

begin_define
define|#
directive|define
name|THUMB2ARM_GLUE_SIZE
value|8
end_define

begin_decl_stmt
specifier|static
specifier|const
name|insn16
name|t2a1_bx_pc_insn
init|=
literal|0x4778
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|insn16
name|t2a2_noop_insn
init|=
literal|0x46c0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|insn32
name|t2a3_b_insn
init|=
literal|0xea000000
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|VFP11_ERRATUM_VENEER_SIZE
value|8
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|ELFARM_NABI_C_INCLUDED
end_ifndef

begin_function
name|bfd_boolean
name|bfd_elf32_arm_allocate_interworking_sections
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_byte
modifier|*
name|foo
decl_stmt|;
name|struct
name|elf32_arm_link_hash_table
modifier|*
name|globals
decl_stmt|;
name|globals
operator|=
name|elf32_arm_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|globals
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|globals
operator|->
name|arm_glue_size
operator|!=
literal|0
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|globals
operator|->
name|bfd_of_glue_owner
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|globals
operator|->
name|bfd_of_glue_owner
argument_list|,
name|ARM2THUMB_GLUE_SECTION_NAME
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|foo
operator|=
name|bfd_alloc
argument_list|(
name|globals
operator|->
name|bfd_of_glue_owner
argument_list|,
name|globals
operator|->
name|arm_glue_size
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|->
name|size
operator|==
name|globals
operator|->
name|arm_glue_size
argument_list|)
expr_stmt|;
name|s
operator|->
name|contents
operator|=
name|foo
expr_stmt|;
block|}
if|if
condition|(
name|globals
operator|->
name|thumb_glue_size
operator|!=
literal|0
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|globals
operator|->
name|bfd_of_glue_owner
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|globals
operator|->
name|bfd_of_glue_owner
argument_list|,
name|THUMB2ARM_GLUE_SECTION_NAME
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|foo
operator|=
name|bfd_alloc
argument_list|(
name|globals
operator|->
name|bfd_of_glue_owner
argument_list|,
name|globals
operator|->
name|thumb_glue_size
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|->
name|size
operator|==
name|globals
operator|->
name|thumb_glue_size
argument_list|)
expr_stmt|;
name|s
operator|->
name|contents
operator|=
name|foo
expr_stmt|;
block|}
if|if
condition|(
name|globals
operator|->
name|vfp11_erratum_glue_size
operator|!=
literal|0
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|globals
operator|->
name|bfd_of_glue_owner
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|globals
operator|->
name|bfd_of_glue_owner
argument_list|,
name|VFP11_ERRATUM_VENEER_SECTION_NAME
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|foo
operator|=
name|bfd_alloc
argument_list|(
name|globals
operator|->
name|bfd_of_glue_owner
argument_list|,
name|globals
operator|->
name|vfp11_erratum_glue_size
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|->
name|size
operator|==
name|globals
operator|->
name|vfp11_erratum_glue_size
argument_list|)
expr_stmt|;
name|s
operator|->
name|contents
operator|=
name|foo
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Allocate space and symbols for calling a Thumb function from Arm mode.    returns the symbol identifying teh stub.  */
end_comment

begin_function
specifier|static
name|struct
name|elf_link_hash_entry
modifier|*
name|record_arm_to_thumb_glue
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|link_info
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|tmp_name
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|myh
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|bh
decl_stmt|;
name|struct
name|elf32_arm_link_hash_table
modifier|*
name|globals
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
name|globals
operator|=
name|elf32_arm_hash_table
argument_list|(
name|link_info
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|globals
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|globals
operator|->
name|bfd_of_glue_owner
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|globals
operator|->
name|bfd_of_glue_owner
argument_list|,
name|ARM2THUMB_GLUE_SECTION_NAME
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|tmp_name
operator|=
name|bfd_malloc
argument_list|(
operator|(
name|bfd_size_type
operator|)
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|ARM2THUMB_GLUE_ENTRY_NAME
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|tmp_name
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tmp_name
argument_list|,
name|ARM2THUMB_GLUE_ENTRY_NAME
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|myh
operator|=
name|elf_link_hash_lookup
argument_list|(
operator|&
operator|(
name|globals
operator|)
operator|->
name|root
argument_list|,
name|tmp_name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|myh
operator|!=
name|NULL
condition|)
block|{
comment|/* We've already seen this guy.  */
name|free
argument_list|(
name|tmp_name
argument_list|)
expr_stmt|;
return|return
name|myh
return|;
block|}
comment|/* The only trick here is using hash_table->arm_glue_size as the value.      Even though the section isn't allocated yet, this is where we will be      putting it.  */
name|bh
operator|=
name|NULL
expr_stmt|;
name|val
operator|=
name|globals
operator|->
name|arm_glue_size
operator|+
literal|1
expr_stmt|;
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|link_info
argument_list|,
name|globals
operator|->
name|bfd_of_glue_owner
argument_list|,
name|tmp_name
argument_list|,
name|BSF_GLOBAL
argument_list|,
name|s
argument_list|,
name|val
argument_list|,
name|NULL
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
operator|&
name|bh
argument_list|)
expr_stmt|;
name|myh
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|bh
expr_stmt|;
name|myh
operator|->
name|type
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_LOCAL
argument_list|,
name|STT_FUNC
argument_list|)
expr_stmt|;
name|myh
operator|->
name|forced_local
operator|=
literal|1
expr_stmt|;
name|free
argument_list|(
name|tmp_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|link_info
operator|->
name|shared
operator|||
name|globals
operator|->
name|root
operator|.
name|is_relocatable_executable
operator|||
name|globals
operator|->
name|pic_veneer
condition|)
name|size
operator|=
name|ARM2THUMB_PIC_GLUE_SIZE
expr_stmt|;
elseif|else
if|if
condition|(
name|globals
operator|->
name|use_blx
condition|)
name|size
operator|=
name|ARM2THUMB_V5_STATIC_GLUE_SIZE
expr_stmt|;
else|else
name|size
operator|=
name|ARM2THUMB_STATIC_GLUE_SIZE
expr_stmt|;
name|s
operator|->
name|size
operator|+=
name|size
expr_stmt|;
name|globals
operator|->
name|arm_glue_size
operator|+=
name|size
expr_stmt|;
return|return
name|myh
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|record_thumb_to_arm_glue
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|link_info
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|tmp_name
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|myh
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|bh
decl_stmt|;
name|struct
name|elf32_arm_link_hash_table
modifier|*
name|hash_table
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
name|hash_table
operator|=
name|elf32_arm_hash_table
argument_list|(
name|link_info
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|hash_table
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|hash_table
operator|->
name|bfd_of_glue_owner
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|hash_table
operator|->
name|bfd_of_glue_owner
argument_list|,
name|THUMB2ARM_GLUE_SECTION_NAME
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|tmp_name
operator|=
name|bfd_malloc
argument_list|(
operator|(
name|bfd_size_type
operator|)
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|THUMB2ARM_GLUE_ENTRY_NAME
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|tmp_name
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tmp_name
argument_list|,
name|THUMB2ARM_GLUE_ENTRY_NAME
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|myh
operator|=
name|elf_link_hash_lookup
argument_list|(
operator|&
operator|(
name|hash_table
operator|)
operator|->
name|root
argument_list|,
name|tmp_name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|myh
operator|!=
name|NULL
condition|)
block|{
comment|/* We've already seen this guy.  */
name|free
argument_list|(
name|tmp_name
argument_list|)
expr_stmt|;
return|return;
block|}
name|bh
operator|=
name|NULL
expr_stmt|;
name|val
operator|=
name|hash_table
operator|->
name|thumb_glue_size
operator|+
literal|1
expr_stmt|;
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|link_info
argument_list|,
name|hash_table
operator|->
name|bfd_of_glue_owner
argument_list|,
name|tmp_name
argument_list|,
name|BSF_GLOBAL
argument_list|,
name|s
argument_list|,
name|val
argument_list|,
name|NULL
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
operator|&
name|bh
argument_list|)
expr_stmt|;
comment|/* If we mark it 'Thumb', the disassembler will do a better job.  */
name|myh
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|bh
expr_stmt|;
name|myh
operator|->
name|type
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_LOCAL
argument_list|,
name|STT_ARM_TFUNC
argument_list|)
expr_stmt|;
name|myh
operator|->
name|forced_local
operator|=
literal|1
expr_stmt|;
name|free
argument_list|(
name|tmp_name
argument_list|)
expr_stmt|;
define|#
directive|define
name|CHANGE_TO_ARM
value|"__%s_change_to_arm"
define|#
directive|define
name|BACK_FROM_ARM
value|"__%s_back_from_arm"
comment|/* Allocate another symbol to mark where we switch to Arm mode.  */
name|tmp_name
operator|=
name|bfd_malloc
argument_list|(
operator|(
name|bfd_size_type
operator|)
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|CHANGE_TO_ARM
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|tmp_name
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tmp_name
argument_list|,
name|CHANGE_TO_ARM
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|bh
operator|=
name|NULL
expr_stmt|;
name|val
operator|=
name|hash_table
operator|->
name|thumb_glue_size
operator|+
literal|4
operator|,
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|link_info
argument_list|,
name|hash_table
operator|->
name|bfd_of_glue_owner
argument_list|,
name|tmp_name
argument_list|,
name|BSF_LOCAL
argument_list|,
name|s
argument_list|,
name|val
argument_list|,
name|NULL
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
operator|&
name|bh
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp_name
argument_list|)
expr_stmt|;
name|s
operator|->
name|size
operator|+=
name|THUMB2ARM_GLUE_SIZE
expr_stmt|;
name|hash_table
operator|->
name|thumb_glue_size
operator|+=
name|THUMB2ARM_GLUE_SIZE
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Add an entry to the code/data map for section SEC.  */
end_comment

begin_function
specifier|static
name|void
name|elf32_arm_section_map_add
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|,
name|char
name|type
parameter_list|,
name|bfd_vma
name|vma
parameter_list|)
block|{
name|struct
name|_arm_elf_section_data
modifier|*
name|sec_data
init|=
name|elf32_arm_section_data
argument_list|(
name|sec
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|newidx
decl_stmt|;
if|if
condition|(
name|sec_data
operator|->
name|map
operator|==
name|NULL
condition|)
block|{
name|sec_data
operator|->
name|map
operator|=
name|bfd_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|elf32_arm_section_map
argument_list|)
argument_list|)
expr_stmt|;
name|sec_data
operator|->
name|mapcount
operator|=
literal|0
expr_stmt|;
name|sec_data
operator|->
name|mapsize
operator|=
literal|1
expr_stmt|;
block|}
name|newidx
operator|=
name|sec_data
operator|->
name|mapcount
operator|++
expr_stmt|;
if|if
condition|(
name|sec_data
operator|->
name|mapcount
operator|>
name|sec_data
operator|->
name|mapsize
condition|)
block|{
name|sec_data
operator|->
name|mapsize
operator|*=
literal|2
expr_stmt|;
name|sec_data
operator|->
name|map
operator|=
name|bfd_realloc
argument_list|(
name|sec_data
operator|->
name|map
argument_list|,
name|sec_data
operator|->
name|mapsize
operator|*
sizeof|sizeof
argument_list|(
name|elf32_arm_section_map
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sec_data
operator|->
name|map
index|[
name|newidx
index|]
operator|.
name|vma
operator|=
name|vma
expr_stmt|;
name|sec_data
operator|->
name|map
index|[
name|newidx
index|]
operator|.
name|type
operator|=
name|type
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record information about a VFP11 denorm-erratum veneer.  Only ARM-mode    veneers are handled for now.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|record_vfp11_erratum_veneer
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|link_info
parameter_list|,
name|elf32_vfp11_erratum_list
modifier|*
name|branch
parameter_list|,
name|bfd
modifier|*
name|branch_bfd
parameter_list|,
name|asection
modifier|*
name|branch_sec
parameter_list|,
name|unsigned
name|int
name|offset
parameter_list|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|struct
name|elf32_arm_link_hash_table
modifier|*
name|hash_table
decl_stmt|;
name|char
modifier|*
name|tmp_name
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|myh
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|bh
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
name|struct
name|_arm_elf_section_data
modifier|*
name|sec_data
decl_stmt|;
name|int
name|errcount
decl_stmt|;
name|elf32_vfp11_erratum_list
modifier|*
name|newerr
decl_stmt|;
name|hash_table
operator|=
name|elf32_arm_hash_table
argument_list|(
name|link_info
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|hash_table
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|hash_table
operator|->
name|bfd_of_glue_owner
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|hash_table
operator|->
name|bfd_of_glue_owner
argument_list|,
name|VFP11_ERRATUM_VENEER_SECTION_NAME
argument_list|)
expr_stmt|;
name|sec_data
operator|=
name|elf32_arm_section_data
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|tmp_name
operator|=
name|bfd_malloc
argument_list|(
operator|(
name|bfd_size_type
operator|)
name|strlen
argument_list|(
name|VFP11_ERRATUM_VENEER_ENTRY_NAME
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|tmp_name
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tmp_name
argument_list|,
name|VFP11_ERRATUM_VENEER_ENTRY_NAME
argument_list|,
name|hash_table
operator|->
name|num_vfp11_fixes
argument_list|)
expr_stmt|;
name|myh
operator|=
name|elf_link_hash_lookup
argument_list|(
operator|&
operator|(
name|hash_table
operator|)
operator|->
name|root
argument_list|,
name|tmp_name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|myh
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|bh
operator|=
name|NULL
expr_stmt|;
name|val
operator|=
name|hash_table
operator|->
name|vfp11_erratum_glue_size
expr_stmt|;
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|link_info
argument_list|,
name|hash_table
operator|->
name|bfd_of_glue_owner
argument_list|,
name|tmp_name
argument_list|,
name|BSF_FUNCTION
operator||
name|BSF_LOCAL
argument_list|,
name|s
argument_list|,
name|val
argument_list|,
name|NULL
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
operator|&
name|bh
argument_list|)
expr_stmt|;
name|myh
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|bh
expr_stmt|;
name|myh
operator|->
name|type
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_LOCAL
argument_list|,
name|STT_FUNC
argument_list|)
expr_stmt|;
name|myh
operator|->
name|forced_local
operator|=
literal|1
expr_stmt|;
comment|/* Link veneer back to calling location.  */
name|errcount
operator|=
operator|++
operator|(
name|sec_data
operator|->
name|erratumcount
operator|)
expr_stmt|;
name|newerr
operator|=
name|bfd_zmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|elf32_vfp11_erratum_list
argument_list|)
argument_list|)
expr_stmt|;
name|newerr
operator|->
name|type
operator|=
name|VFP11_ERRATUM_ARM_VENEER
expr_stmt|;
name|newerr
operator|->
name|vma
operator|=
operator|-
literal|1
expr_stmt|;
name|newerr
operator|->
name|u
operator|.
name|v
operator|.
name|branch
operator|=
name|branch
expr_stmt|;
name|newerr
operator|->
name|u
operator|.
name|v
operator|.
name|id
operator|=
name|hash_table
operator|->
name|num_vfp11_fixes
expr_stmt|;
name|branch
operator|->
name|u
operator|.
name|b
operator|.
name|veneer
operator|=
name|newerr
expr_stmt|;
name|newerr
operator|->
name|next
operator|=
name|sec_data
operator|->
name|erratumlist
expr_stmt|;
name|sec_data
operator|->
name|erratumlist
operator|=
name|newerr
expr_stmt|;
comment|/* A symbol for the return from the veneer.  */
name|sprintf
argument_list|(
name|tmp_name
argument_list|,
name|VFP11_ERRATUM_VENEER_ENTRY_NAME
literal|"_r"
argument_list|,
name|hash_table
operator|->
name|num_vfp11_fixes
argument_list|)
expr_stmt|;
name|myh
operator|=
name|elf_link_hash_lookup
argument_list|(
operator|&
operator|(
name|hash_table
operator|)
operator|->
name|root
argument_list|,
name|tmp_name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|myh
operator|!=
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|bh
operator|=
name|NULL
expr_stmt|;
name|val
operator|=
name|offset
operator|+
literal|4
expr_stmt|;
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|link_info
argument_list|,
name|branch_bfd
argument_list|,
name|tmp_name
argument_list|,
name|BSF_LOCAL
argument_list|,
name|branch_sec
argument_list|,
name|val
argument_list|,
name|NULL
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
operator|&
name|bh
argument_list|)
expr_stmt|;
name|myh
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|bh
expr_stmt|;
name|myh
operator|->
name|type
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_LOCAL
argument_list|,
name|STT_FUNC
argument_list|)
expr_stmt|;
name|myh
operator|->
name|forced_local
operator|=
literal|1
expr_stmt|;
name|free
argument_list|(
name|tmp_name
argument_list|)
expr_stmt|;
comment|/* Generate a mapping symbol for the veneer section, and explicitly add an      entry for that symbol to the code/data map for the section.  */
if|if
condition|(
name|hash_table
operator|->
name|vfp11_erratum_glue_size
operator|==
literal|0
condition|)
block|{
name|bh
operator|=
name|NULL
expr_stmt|;
comment|/* FIXME: Creates an ARM symbol.  Thumb mode will need attention if it          ever requires this erratum fix.  */
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|link_info
argument_list|,
name|hash_table
operator|->
name|bfd_of_glue_owner
argument_list|,
literal|"$a"
argument_list|,
name|BSF_LOCAL
argument_list|,
name|s
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
operator|&
name|bh
argument_list|)
expr_stmt|;
name|myh
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|bh
expr_stmt|;
name|myh
operator|->
name|type
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_LOCAL
argument_list|,
name|STT_NOTYPE
argument_list|)
expr_stmt|;
name|myh
operator|->
name|forced_local
operator|=
literal|1
expr_stmt|;
comment|/* The elf32_arm_init_maps function only cares about symbols from input          BFDs.  We must make a note of this generated mapping symbol          ourselves so that code byteswapping works properly in          elf32_arm_write_section.  */
name|elf32_arm_section_map_add
argument_list|(
name|s
argument_list|,
literal|'a'
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|s
operator|->
name|size
operator|+=
name|VFP11_ERRATUM_VENEER_SIZE
expr_stmt|;
name|hash_table
operator|->
name|vfp11_erratum_glue_size
operator|+=
name|VFP11_ERRATUM_VENEER_SIZE
expr_stmt|;
name|hash_table
operator|->
name|num_vfp11_fixes
operator|++
expr_stmt|;
comment|/* The offset of the veneer.  */
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Add the glue sections to ABFD.  This function is called from the    linker scripts in ld/emultempl/{armelf}.em.  */
end_comment

begin_function
name|bfd_boolean
name|bfd_elf32_arm_add_glue_sections_to_bfd
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|flagword
name|flags
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
comment|/* If we are only performing a partial      link do not bother adding the glue.  */
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
return|return
name|TRUE
return|;
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|ARM2THUMB_GLUE_SECTION_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
block|{
comment|/* Note: we do not include the flag SEC_LINKER_CREATED, as this 	 will prevent elf_link_input_bfd() from processing the contents 	 of this section.  */
name|flags
operator|=
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_CODE
operator||
name|SEC_READONLY
operator|)
expr_stmt|;
name|sec
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|abfd
argument_list|,
name|ARM2THUMB_GLUE_SECTION_NAME
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Set the gc mark to prevent the section from being removed by garbage 	 collection, despite the fact that no relocs refer to this section.  */
name|sec
operator|->
name|gc_mark
operator|=
literal|1
expr_stmt|;
block|}
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|THUMB2ARM_GLUE_SECTION_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
block|{
name|flags
operator|=
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_CODE
operator||
name|SEC_READONLY
operator|)
expr_stmt|;
name|sec
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|abfd
argument_list|,
name|THUMB2ARM_GLUE_SECTION_NAME
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|sec
operator|->
name|gc_mark
operator|=
literal|1
expr_stmt|;
block|}
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|VFP11_ERRATUM_VENEER_SECTION_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
block|{
name|flags
operator|=
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_CODE
operator||
name|SEC_READONLY
operator|)
expr_stmt|;
name|sec
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|abfd
argument_list|,
name|VFP11_ERRATUM_VENEER_SECTION_NAME
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|sec
operator|->
name|gc_mark
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Select a BFD to be used to hold the sections used by the glue code.    This function is called from the linker scripts in ld/emultempl/    {armelf/pe}.em  */
end_comment

begin_function
name|bfd_boolean
name|bfd_elf32_arm_get_bfd_for_interworking
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|elf32_arm_link_hash_table
modifier|*
name|globals
decl_stmt|;
comment|/* If we are only performing a partial link      do not bother getting a bfd to hold the glue.  */
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
return|return
name|TRUE
return|;
comment|/* Make sure we don't attach the glue sections to a dynamic object.  */
name|BFD_ASSERT
argument_list|(
operator|!
operator|(
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
argument_list|)
expr_stmt|;
name|globals
operator|=
name|elf32_arm_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|globals
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|globals
operator|->
name|bfd_of_glue_owner
operator|!=
name|NULL
condition|)
return|return
name|TRUE
return|;
comment|/* Save the bfd for later use.  */
name|globals
operator|->
name|bfd_of_glue_owner
operator|=
name|abfd
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|check_use_blx
parameter_list|(
name|struct
name|elf32_arm_link_hash_table
modifier|*
name|globals
parameter_list|)
block|{
if|if
condition|(
name|bfd_elf_get_obj_attr_int
argument_list|(
name|globals
operator|->
name|obfd
argument_list|,
name|OBJ_ATTR_PROC
argument_list|,
name|Tag_CPU_arch
argument_list|)
operator|>
literal|2
condition|)
name|globals
operator|->
name|use_blx
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|bfd_boolean
name|bfd_elf32_arm_process_before_allocation
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|,
modifier|*
name|irelend
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
init|=
name|NULL
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|elf32_arm_link_hash_table
modifier|*
name|globals
decl_stmt|;
comment|/* If we are only performing a partial link do not bother      to construct any glue.  */
if|if
condition|(
name|link_info
operator|->
name|relocatable
condition|)
return|return
name|TRUE
return|;
comment|/* Here we have a bfd that is to be included on the link.  We have a hook      to do reloc rummaging, before section sizes are nailed down.  */
name|globals
operator|=
name|elf32_arm_hash_table
argument_list|(
name|link_info
argument_list|)
expr_stmt|;
name|check_use_blx
argument_list|(
name|globals
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|globals
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|globals
operator|->
name|bfd_of_glue_owner
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|globals
operator|->
name|byteswap_code
operator|&&
operator|!
name|bfd_big_endian
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"%B: BE8 images only valid in big-endian mode."
argument_list|)
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Rummage around all the relocs and map the glue vectors.  */
name|sec
operator|=
name|abfd
operator|->
name|sections
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
for|for
control|(
init|;
name|sec
operator|!=
name|NULL
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
block|{
if|if
condition|(
name|sec
operator|->
name|reloc_count
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_EXCLUDE
operator|)
operator|!=
literal|0
condition|)
continue|continue;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
comment|/* Load the relocs.  */
name|internal_relocs
operator|=
name|_bfd_elf_link_read_relocs
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
operator|(
name|void
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|irelend
operator|=
name|internal_relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|irel
operator|=
name|internal_relocs
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
control|)
block|{
name|long
name|r_type
decl_stmt|;
name|unsigned
name|long
name|r_index
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|r_index
operator|=
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
expr_stmt|;
comment|/* These are the only relocation types we care about.  */
if|if
condition|(
name|r_type
operator|!=
name|R_ARM_PC24
operator|&&
name|r_type
operator|!=
name|R_ARM_PLT32
operator|&&
name|r_type
operator|!=
name|R_ARM_CALL
operator|&&
name|r_type
operator|!=
name|R_ARM_JUMP24
operator|&&
name|r_type
operator|!=
name|R_ARM_THM_CALL
condition|)
continue|continue;
comment|/* Get the section contents if we haven't done so already.  */
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
block|{
comment|/* Get cached copy if it exists.  */
if|if
condition|(
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|NULL
condition|)
name|contents
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
expr_stmt|;
else|else
block|{
comment|/* Go get them off disk.  */
if|if
condition|(
operator|!
name|bfd_malloc_and_get_section
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
operator|&
name|contents
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
block|}
comment|/* If the relocation is not against a symbol it cannot concern us.  */
name|h
operator|=
name|NULL
expr_stmt|;
comment|/* We don't care about local symbols.  */
if|if
condition|(
name|r_index
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
continue|continue;
comment|/* This is an external symbol.  */
name|r_index
operator|-=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
index|[
name|r_index
index|]
expr_stmt|;
comment|/* If the relocation is against a static symbol it must be within 	     the current section and so cannot be a cross ARM/Thumb relocation.  */
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
continue|continue;
comment|/* If the call will go through a PLT entry then we do not need 	     glue.  */
if|if
condition|(
name|globals
operator|->
name|splt
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|plt
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
continue|continue;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_ARM_PC24
case|:
case|case
name|R_ARM_PLT32
case|:
case|case
name|R_ARM_CALL
case|:
case|case
name|R_ARM_JUMP24
case|:
comment|/* This one is a call from arm code.  We need to look up 	         the target of the call.  If it is a thumb target, we 	         insert glue.  */
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|h
operator|->
name|type
argument_list|)
operator|==
name|STT_ARM_TFUNC
operator|&&
operator|!
operator|(
name|r_type
operator|==
name|R_ARM_CALL
operator|&&
name|globals
operator|->
name|use_blx
operator|)
condition|)
name|record_arm_to_thumb_glue
argument_list|(
name|link_info
argument_list|,
name|h
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_ARM_THM_CALL
case|:
comment|/* This one is a call from thumb code.  We look 	         up the target of the call.  If it is not a thumb                  target, we insert glue.  */
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|h
operator|->
name|type
argument_list|)
operator|!=
name|STT_ARM_TFUNC
operator|&&
operator|!
name|globals
operator|->
name|use_blx
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefweak
condition|)
name|record_thumb_to_arm_glue
argument_list|(
name|link_info
argument_list|,
name|h
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|contents
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|contents
condition|)
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
name|contents
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|!=
name|internal_relocs
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
name|internal_relocs
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|TRUE
return|;
name|error_return
label|:
if|if
condition|(
name|contents
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|contents
condition|)
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|!=
name|internal_relocs
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Initialise maps of ARM/Thumb/data for input BFDs.  */
end_comment

begin_function
name|void
name|bfd_elf32_arm_init_maps
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|Elf_Internal_Sym
modifier|*
name|isymbuf
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|localsyms
decl_stmt|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|abfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
operator|||
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
condition|)
return|return;
name|hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|localsyms
operator|=
name|hdr
operator|->
name|sh_info
expr_stmt|;
comment|/* Obtain a buffer full of symbols for this BFD. The hdr->sh_info field      should contain the number of local symbols, which should come before any      global symbols.  Mapping symbols are always local.  */
name|isymbuf
operator|=
name|bfd_elf_get_elf_syms
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|,
name|localsyms
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* No internal symbols read?  Skip this BFD.  */
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|localsyms
condition|;
name|i
operator|++
control|)
block|{
name|Elf_Internal_Sym
modifier|*
name|isym
init|=
operator|&
name|isymbuf
index|[
name|i
index|]
decl_stmt|;
name|asection
modifier|*
name|sec
init|=
name|bfd_section_from_elf_index
argument_list|(
name|abfd
argument_list|,
name|isym
operator|->
name|st_shndx
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|sec
operator|!=
name|NULL
operator|&&
name|ELF_ST_BIND
argument_list|(
name|isym
operator|->
name|st_info
argument_list|)
operator|==
name|STB_LOCAL
condition|)
block|{
name|name
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|sh_link
argument_list|,
name|isym
operator|->
name|st_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_is_arm_special_symbol_name
argument_list|(
name|name
argument_list|,
name|BFD_ARM_SPECIAL_SYM_TYPE_MAP
argument_list|)
condition|)
name|elf32_arm_section_map_add
argument_list|(
name|sec
argument_list|,
name|name
index|[
literal|1
index|]
argument_list|,
name|isym
operator|->
name|st_value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|bfd_elf32_arm_set_vfp11_fix
parameter_list|(
name|bfd
modifier|*
name|obfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
parameter_list|)
block|{
name|struct
name|elf32_arm_link_hash_table
modifier|*
name|globals
init|=
name|elf32_arm_hash_table
argument_list|(
name|link_info
argument_list|)
decl_stmt|;
name|obj_attribute
modifier|*
name|out_attr
init|=
name|elf_known_obj_attributes_proc
argument_list|(
name|obfd
argument_list|)
decl_stmt|;
comment|/* We assume that ARMv7+ does not need the VFP11 denorm erratum fix.  */
if|if
condition|(
name|out_attr
index|[
name|Tag_CPU_arch
index|]
operator|.
name|i
operator|>=
name|TAG_CPU_ARCH_V7
condition|)
block|{
switch|switch
condition|(
name|globals
operator|->
name|vfp11_fix
condition|)
block|{
case|case
name|BFD_ARM_VFP11_FIX_DEFAULT
case|:
case|case
name|BFD_ARM_VFP11_FIX_NONE
case|:
name|globals
operator|->
name|vfp11_fix
operator|=
name|BFD_ARM_VFP11_FIX_NONE
expr_stmt|;
break|break;
default|default:
comment|/* Give a warning, but do as the user requests anyway.  */
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: warning: selected VFP11 erratum "
literal|"workaround is not necessary for target architecture"
argument_list|)
argument_list|,
name|obfd
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|globals
operator|->
name|vfp11_fix
operator|==
name|BFD_ARM_VFP11_FIX_DEFAULT
condition|)
comment|/* For earlier architectures, we might need the workaround, but do not        enable it by default.  If users is running with broken hardware, they        must enable the erratum fix explicitly.  */
name|globals
operator|->
name|vfp11_fix
operator|=
name|BFD_ARM_VFP11_FIX_NONE
expr_stmt|;
block|}
end_function

begin_enum
enum|enum
name|bfd_arm_vfp11_pipe
block|{
name|VFP11_FMAC
block|,
name|VFP11_LS
block|,
name|VFP11_DS
block|,
name|VFP11_BAD
block|}
enum|;
end_enum

begin_comment
comment|/* Return a VFP register number.  This is encoded as RX:X for single-precision    registers, or X:RX for double-precision registers, where RX is the group of    four bits in the instruction encoding and X is the single extension bit.    RX and X fields are specified using their lowest (starting) bit.  The return    value is:       0...31: single-precision registers s0...s31      32...63: double-precision registers d0...d31.       Although X should be zero for VFP11 (encoding d0...d15 only), we might    encounter VFP3 instructions, so we allow the full range for DP registers.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|bfd_arm_vfp11_regno
parameter_list|(
name|unsigned
name|int
name|insn
parameter_list|,
name|bfd_boolean
name|is_double
parameter_list|,
name|unsigned
name|int
name|rx
parameter_list|,
name|unsigned
name|int
name|x
parameter_list|)
block|{
if|if
condition|(
name|is_double
condition|)
return|return
operator|(
operator|(
operator|(
name|insn
operator|>>
name|rx
operator|)
operator|&
literal|0xf
operator|)
operator||
operator|(
operator|(
operator|(
name|insn
operator|>>
name|x
operator|)
operator|&
literal|1
operator|)
operator|<<
literal|4
operator|)
operator|)
operator|+
literal|32
return|;
else|else
return|return
operator|(
operator|(
operator|(
name|insn
operator|>>
name|rx
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|1
operator|)
operator||
operator|(
operator|(
name|insn
operator|>>
name|x
operator|)
operator|&
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Set bits in *WMASK according to a register number REG as encoded by    bfd_arm_vfp11_regno().  Ignore d16-d31.  */
end_comment

begin_function
specifier|static
name|void
name|bfd_arm_vfp11_write_mask
parameter_list|(
name|unsigned
name|int
modifier|*
name|wmask
parameter_list|,
name|unsigned
name|int
name|reg
parameter_list|)
block|{
if|if
condition|(
name|reg
operator|<
literal|32
condition|)
operator|*
name|wmask
operator||=
literal|1
operator|<<
name|reg
expr_stmt|;
elseif|else
if|if
condition|(
name|reg
operator|<
literal|48
condition|)
operator|*
name|wmask
operator||=
literal|3
operator|<<
operator|(
operator|(
name|reg
operator|-
literal|32
operator|)
operator|*
literal|2
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return TRUE if WMASK overwrites anything in REGS.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|bfd_arm_vfp11_antidependency
parameter_list|(
name|unsigned
name|int
name|wmask
parameter_list|,
name|int
modifier|*
name|regs
parameter_list|,
name|int
name|numregs
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numregs
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|reg
init|=
name|regs
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|reg
operator|<
literal|32
operator|&&
operator|(
name|wmask
operator|&
operator|(
literal|1
operator|<<
name|reg
operator|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|TRUE
return|;
name|reg
operator|-=
literal|32
expr_stmt|;
if|if
condition|(
name|reg
operator|>=
literal|16
condition|)
continue|continue;
if|if
condition|(
operator|(
name|wmask
operator|&
operator|(
literal|3
operator|<<
operator|(
name|reg
operator|*
literal|2
operator|)
operator|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* In this function, we're interested in two things: finding input registers    for VFP data-processing instructions, and finding the set of registers which    arbitrary VFP instructions may write to.  We use a 32-bit unsigned int to    hold the written set, so FLDM etc. are easy to deal with (we're only    interested in 32 SP registers or 16 dp registers, due to the VFP version    implemented by the chip in question).  DP registers are marked by setting    both SP registers in the write mask).  */
end_comment

begin_function
specifier|static
name|enum
name|bfd_arm_vfp11_pipe
name|bfd_arm_vfp11_insn_decode
parameter_list|(
name|unsigned
name|int
name|insn
parameter_list|,
name|unsigned
name|int
modifier|*
name|destmask
parameter_list|,
name|int
modifier|*
name|regs
parameter_list|,
name|int
modifier|*
name|numregs
parameter_list|)
block|{
name|enum
name|bfd_arm_vfp11_pipe
name|pipe
init|=
name|VFP11_BAD
decl_stmt|;
name|bfd_boolean
name|is_double
init|=
operator|(
operator|(
name|insn
operator|&
literal|0xf00
operator|)
operator|==
literal|0xb00
operator|)
condition|?
literal|1
else|:
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|insn
operator|&
literal|0x0f000e10
operator|)
operator|==
literal|0x0e000a00
condition|)
comment|/* A data-processing insn.  */
block|{
name|unsigned
name|int
name|pqrs
decl_stmt|;
name|unsigned
name|int
name|fd
init|=
name|bfd_arm_vfp11_regno
argument_list|(
name|insn
argument_list|,
name|is_double
argument_list|,
literal|12
argument_list|,
literal|22
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|fm
init|=
name|bfd_arm_vfp11_regno
argument_list|(
name|insn
argument_list|,
name|is_double
argument_list|,
literal|0
argument_list|,
literal|5
argument_list|)
decl_stmt|;
name|pqrs
operator|=
operator|(
operator|(
name|insn
operator|&
literal|0x00800000
operator|)
operator|>>
literal|20
operator|)
operator||
operator|(
operator|(
name|insn
operator|&
literal|0x00300000
operator|)
operator|>>
literal|19
operator|)
operator||
operator|(
operator|(
name|insn
operator|&
literal|0x00000040
operator|)
operator|>>
literal|6
operator|)
expr_stmt|;
switch|switch
condition|(
name|pqrs
condition|)
block|{
case|case
literal|0
case|:
comment|/* fmac[sd].  */
case|case
literal|1
case|:
comment|/* fnmac[sd].  */
case|case
literal|2
case|:
comment|/* fmsc[sd].  */
case|case
literal|3
case|:
comment|/* fnmsc[sd].  */
name|pipe
operator|=
name|VFP11_FMAC
expr_stmt|;
name|bfd_arm_vfp11_write_mask
argument_list|(
name|destmask
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|regs
index|[
literal|0
index|]
operator|=
name|fd
expr_stmt|;
name|regs
index|[
literal|1
index|]
operator|=
name|bfd_arm_vfp11_regno
argument_list|(
name|insn
argument_list|,
name|is_double
argument_list|,
literal|16
argument_list|,
literal|7
argument_list|)
expr_stmt|;
comment|/* Fn.  */
name|regs
index|[
literal|2
index|]
operator|=
name|fm
expr_stmt|;
operator|*
name|numregs
operator|=
literal|3
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/* fmul[sd].  */
case|case
literal|5
case|:
comment|/* fnmul[sd].  */
case|case
literal|6
case|:
comment|/* fadd[sd].  */
case|case
literal|7
case|:
comment|/* fsub[sd].  */
name|pipe
operator|=
name|VFP11_FMAC
expr_stmt|;
goto|goto
name|vfp_binop
goto|;
case|case
literal|8
case|:
comment|/* fdiv[sd].  */
name|pipe
operator|=
name|VFP11_DS
expr_stmt|;
name|vfp_binop
label|:
name|bfd_arm_vfp11_write_mask
argument_list|(
name|destmask
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|regs
index|[
literal|0
index|]
operator|=
name|bfd_arm_vfp11_regno
argument_list|(
name|insn
argument_list|,
name|is_double
argument_list|,
literal|16
argument_list|,
literal|7
argument_list|)
expr_stmt|;
comment|/* Fn.  */
name|regs
index|[
literal|1
index|]
operator|=
name|fm
expr_stmt|;
operator|*
name|numregs
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|15
case|:
comment|/* extended opcode.  */
block|{
name|unsigned
name|int
name|extn
init|=
operator|(
operator|(
name|insn
operator|>>
literal|15
operator|)
operator|&
literal|0x1e
operator|)
operator||
operator|(
operator|(
name|insn
operator|>>
literal|7
operator|)
operator|&
literal|1
operator|)
decl_stmt|;
switch|switch
condition|(
name|extn
condition|)
block|{
case|case
literal|0
case|:
comment|/* fcpy[sd].  */
case|case
literal|1
case|:
comment|/* fabs[sd].  */
case|case
literal|2
case|:
comment|/* fneg[sd].  */
case|case
literal|8
case|:
comment|/* fcmp[sd].  */
case|case
literal|9
case|:
comment|/* fcmpe[sd].  */
case|case
literal|10
case|:
comment|/* fcmpz[sd].  */
case|case
literal|11
case|:
comment|/* fcmpez[sd].  */
case|case
literal|16
case|:
comment|/* fuito[sd].  */
case|case
literal|17
case|:
comment|/* fsito[sd].  */
case|case
literal|24
case|:
comment|/* ftoui[sd].  */
case|case
literal|25
case|:
comment|/* ftouiz[sd].  */
case|case
literal|26
case|:
comment|/* ftosi[sd].  */
case|case
literal|27
case|:
comment|/* ftosiz[sd].  */
comment|/* These instructions will not bounce due to underflow.  */
operator|*
name|numregs
operator|=
literal|0
expr_stmt|;
name|pipe
operator|=
name|VFP11_FMAC
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* fsqrt[sd].  */
comment|/* fsqrt cannot underflow, but it can (perhaps) overwrite                    registers to cause the erratum in previous instructions.  */
name|bfd_arm_vfp11_write_mask
argument_list|(
name|destmask
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|pipe
operator|=
name|VFP11_DS
expr_stmt|;
break|break;
case|case
literal|15
case|:
comment|/* fcvt{ds,sd}.  */
block|{
name|int
name|rnum
init|=
literal|0
decl_stmt|;
name|bfd_arm_vfp11_write_mask
argument_list|(
name|destmask
argument_list|,
name|fd
argument_list|)
expr_stmt|;
comment|/* Only FCVTSD can underflow.  */
if|if
condition|(
operator|(
name|insn
operator|&
literal|0x100
operator|)
operator|!=
literal|0
condition|)
name|regs
index|[
name|rnum
operator|++
index|]
operator|=
name|fm
expr_stmt|;
operator|*
name|numregs
operator|=
name|rnum
expr_stmt|;
name|pipe
operator|=
name|VFP11_FMAC
expr_stmt|;
block|}
break|break;
default|default:
return|return
name|VFP11_BAD
return|;
block|}
block|}
break|break;
default|default:
return|return
name|VFP11_BAD
return|;
block|}
block|}
comment|/* Two-register transfer.  */
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
literal|0x0fe00ed0
operator|)
operator|==
literal|0x0c400a10
condition|)
block|{
name|unsigned
name|int
name|fm
init|=
name|bfd_arm_vfp11_regno
argument_list|(
name|insn
argument_list|,
name|is_double
argument_list|,
literal|0
argument_list|,
literal|5
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|insn
operator|&
literal|0x100000
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|is_double
condition|)
name|bfd_arm_vfp11_write_mask
argument_list|(
name|destmask
argument_list|,
name|fm
argument_list|)
expr_stmt|;
else|else
block|{
name|bfd_arm_vfp11_write_mask
argument_list|(
name|destmask
argument_list|,
name|fm
argument_list|)
expr_stmt|;
name|bfd_arm_vfp11_write_mask
argument_list|(
name|destmask
argument_list|,
name|fm
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|pipe
operator|=
name|VFP11_LS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
literal|0x0e100e00
operator|)
operator|==
literal|0x0c100a00
condition|)
comment|/* A load insn.  */
block|{
name|int
name|fd
init|=
name|bfd_arm_vfp11_regno
argument_list|(
name|insn
argument_list|,
name|is_double
argument_list|,
literal|12
argument_list|,
literal|22
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|puw
init|=
operator|(
operator|(
name|insn
operator|>>
literal|21
operator|)
operator|&
literal|0x1
operator|)
operator||
operator|(
operator|(
operator|(
name|insn
operator|>>
literal|23
operator|)
operator|&
literal|3
operator|)
operator|<<
literal|1
operator|)
decl_stmt|;
switch|switch
condition|(
name|puw
condition|)
block|{
case|case
literal|0
case|:
comment|/* Two-reg transfer.  We should catch these above.  */
name|abort
argument_list|()
expr_stmt|;
case|case
literal|2
case|:
comment|/* fldm[sdx].  */
case|case
literal|3
case|:
case|case
literal|5
case|:
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|offset
init|=
name|insn
operator|&
literal|0xff
decl_stmt|;
if|if
condition|(
name|is_double
condition|)
name|offset
operator|>>=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|fd
init|;
name|i
operator|<
name|fd
operator|+
name|offset
condition|;
name|i
operator|++
control|)
name|bfd_arm_vfp11_write_mask
argument_list|(
name|destmask
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|4
case|:
comment|/* fld[sd].  */
case|case
literal|6
case|:
name|bfd_arm_vfp11_write_mask
argument_list|(
name|destmask
argument_list|,
name|fd
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|VFP11_BAD
return|;
block|}
name|pipe
operator|=
name|VFP11_LS
expr_stmt|;
block|}
comment|/* Single-register transfer. Note L==0.  */
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
literal|0x0f100e10
operator|)
operator|==
literal|0x0e000a10
condition|)
block|{
name|unsigned
name|int
name|opcode
init|=
operator|(
name|insn
operator|>>
literal|21
operator|)
operator|&
literal|7
decl_stmt|;
name|unsigned
name|int
name|fn
init|=
name|bfd_arm_vfp11_regno
argument_list|(
name|insn
argument_list|,
name|is_double
argument_list|,
literal|16
argument_list|,
literal|7
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
literal|0
case|:
comment|/* fmsr/fmdlr.  */
case|case
literal|1
case|:
comment|/* fmdhr.  */
comment|/* Mark fmdhr and fmdlr as writing to the whole of the DP              destination register.  I don't know if this is exactly right,              but it is the conservative choice.  */
name|bfd_arm_vfp11_write_mask
argument_list|(
name|destmask
argument_list|,
name|fn
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
comment|/* fmxr.  */
break|break;
block|}
name|pipe
operator|=
name|VFP11_LS
expr_stmt|;
block|}
return|return
name|pipe
return|;
block|}
end_function

begin_function_decl
specifier|static
name|int
name|elf32_arm_compare_mapping
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Look for potentially-troublesome code sequences which might trigger the    VFP11 denormal/antidependency erratum.  See, e.g., the ARM1136 errata sheet    (available from ARM) for details of the erratum.  A short version is    described in ld.texinfo.  */
end_comment

begin_function
name|bfd_boolean
name|bfd_elf32_arm_vfp11_erratum_scan
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
parameter_list|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
init|=
name|NULL
decl_stmt|;
name|int
name|state
init|=
literal|0
decl_stmt|;
name|int
name|regs
index|[
literal|3
index|]
decl_stmt|,
name|numregs
init|=
literal|0
decl_stmt|;
name|struct
name|elf32_arm_link_hash_table
modifier|*
name|globals
init|=
name|elf32_arm_hash_table
argument_list|(
name|link_info
argument_list|)
decl_stmt|;
name|int
name|use_vector
init|=
operator|(
name|globals
operator|->
name|vfp11_fix
operator|==
name|BFD_ARM_VFP11_FIX_VECTOR
operator|)
decl_stmt|;
comment|/* We use a simple FSM to match troublesome VFP11 instruction sequences.      The states transition as follows:              0 -> 1 (vector) or 0 -> 2 (scalar)            A VFP FMAC-pipeline instruction has been seen. Fill            regs[0]..regs[numregs-1] with its input operands. Remember this            instruction in 'first_fmac'.         1 -> 2            Any instruction, except for a VFP instruction which overwrites            regs[*].                1 -> 3 [ -> 0 ]  or        2 -> 3 [ -> 0 ]            A VFP instruction has been seen which overwrites any of regs[*].            We must make a veneer!  Reset state to 0 before examining next            instruction.                2 -> 0            If we fail to match anything in state 2, reset to state 0 and reset            the instruction pointer to the instruction after 'first_fmac'.       If the VFP11 vector mode is in use, there must be at least two unrelated      instructions between anti-dependent VFP11 instructions to properly avoid      triggering the erratum, hence the use of the extra state 1.   */
comment|/* If we are only performing a partial link do not bother      to construct any glue.  */
if|if
condition|(
name|link_info
operator|->
name|relocatable
condition|)
return|return
name|TRUE
return|;
comment|/* We should have chosen a fix type by the time we get here.  */
name|BFD_ASSERT
argument_list|(
name|globals
operator|->
name|vfp11_fix
operator|!=
name|BFD_ARM_VFP11_FIX_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|globals
operator|->
name|vfp11_fix
operator|==
name|BFD_ARM_VFP11_FIX_NONE
condition|)
return|return
name|TRUE
return|;
comment|/* Skip if this bfd does not correspond to an ELF image.  */
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|abfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
return|return
name|TRUE
return|;
for|for
control|(
name|sec
operator|=
name|abfd
operator|->
name|sections
init|;
name|sec
operator|!=
name|NULL
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|span
decl_stmt|,
name|first_fmac
init|=
literal|0
decl_stmt|,
name|veneer_of_insn
init|=
literal|0
decl_stmt|;
name|struct
name|_arm_elf_section_data
modifier|*
name|sec_data
decl_stmt|;
comment|/* If we don't have executable progbits, we're not interested in this          section.  Also skip if section is to be excluded.  */
if|if
condition|(
name|elf_section_type
argument_list|(
name|sec
argument_list|)
operator|!=
name|SHT_PROGBITS
operator|||
operator|(
name|elf_section_flags
argument_list|(
name|sec
argument_list|)
operator|&
name|SHF_EXECINSTR
operator|)
operator|==
literal|0
operator|||
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_EXCLUDE
operator|)
operator|!=
literal|0
operator|||
name|strcmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
name|VFP11_ERRATUM_VENEER_SECTION_NAME
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|sec_data
operator|=
name|elf32_arm_section_data
argument_list|(
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec_data
operator|->
name|mapcount
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|NULL
condition|)
name|contents
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|bfd_malloc_and_get_section
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
operator|&
name|contents
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
name|qsort
argument_list|(
name|sec_data
operator|->
name|map
argument_list|,
name|sec_data
operator|->
name|mapcount
argument_list|,
sizeof|sizeof
argument_list|(
name|elf32_arm_section_map
argument_list|)
argument_list|,
name|elf32_arm_compare_mapping
argument_list|)
expr_stmt|;
for|for
control|(
name|span
operator|=
literal|0
init|;
name|span
operator|<
name|sec_data
operator|->
name|mapcount
condition|;
name|span
operator|++
control|)
block|{
name|unsigned
name|int
name|span_start
init|=
name|sec_data
operator|->
name|map
index|[
name|span
index|]
operator|.
name|vma
decl_stmt|;
name|unsigned
name|int
name|span_end
init|=
operator|(
name|span
operator|==
name|sec_data
operator|->
name|mapcount
operator|-
literal|1
operator|)
condition|?
name|sec
operator|->
name|size
else|:
name|sec_data
operator|->
name|map
index|[
name|span
operator|+
literal|1
index|]
operator|.
name|vma
decl_stmt|;
name|char
name|span_type
init|=
name|sec_data
operator|->
name|map
index|[
name|span
index|]
operator|.
name|type
decl_stmt|;
comment|/* FIXME: Only ARM mode is supported at present.  We may need to              support Thumb-2 mode also at some point.  */
if|if
condition|(
name|span_type
operator|!=
literal|'a'
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
name|span_start
init|;
name|i
operator|<
name|span_end
condition|;
control|)
block|{
name|unsigned
name|int
name|next_i
init|=
name|i
operator|+
literal|4
decl_stmt|;
name|unsigned
name|int
name|insn
init|=
name|bfd_big_endian
argument_list|(
name|abfd
argument_list|)
condition|?
operator|(
name|contents
index|[
name|i
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|contents
index|[
name|i
operator|+
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|contents
index|[
name|i
operator|+
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
name|contents
index|[
name|i
operator|+
literal|3
index|]
else|:
operator|(
name|contents
index|[
name|i
operator|+
literal|3
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|contents
index|[
name|i
operator|+
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|contents
index|[
name|i
operator|+
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|contents
index|[
name|i
index|]
decl_stmt|;
name|unsigned
name|int
name|writemask
init|=
literal|0
decl_stmt|;
name|enum
name|bfd_arm_vfp11_pipe
name|pipe
decl_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
literal|0
case|:
name|pipe
operator|=
name|bfd_arm_vfp11_insn_decode
argument_list|(
name|insn
argument_list|,
operator|&
name|writemask
argument_list|,
name|regs
argument_list|,
operator|&
name|numregs
argument_list|)
expr_stmt|;
comment|/* I'm assuming the VFP11 erratum can trigger with denorm                      operands on either the FMAC or the DS pipeline. This might                      lead to slightly overenthusiastic veneer insertion.  */
if|if
condition|(
name|pipe
operator|==
name|VFP11_FMAC
operator|||
name|pipe
operator|==
name|VFP11_DS
condition|)
block|{
name|state
operator|=
name|use_vector
condition|?
literal|1
else|:
literal|2
expr_stmt|;
name|first_fmac
operator|=
name|i
expr_stmt|;
name|veneer_of_insn
operator|=
name|insn
expr_stmt|;
block|}
break|break;
case|case
literal|1
case|:
block|{
name|int
name|other_regs
index|[
literal|3
index|]
decl_stmt|,
name|other_numregs
decl_stmt|;
name|pipe
operator|=
name|bfd_arm_vfp11_insn_decode
argument_list|(
name|insn
argument_list|,
operator|&
name|writemask
argument_list|,
name|other_regs
argument_list|,
operator|&
name|other_numregs
argument_list|)
expr_stmt|;
if|if
condition|(
name|pipe
operator|!=
name|VFP11_BAD
operator|&&
name|bfd_arm_vfp11_antidependency
argument_list|(
name|writemask
argument_list|,
name|regs
argument_list|,
name|numregs
argument_list|)
condition|)
name|state
operator|=
literal|3
expr_stmt|;
else|else
name|state
operator|=
literal|2
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
block|{
name|int
name|other_regs
index|[
literal|3
index|]
decl_stmt|,
name|other_numregs
decl_stmt|;
name|pipe
operator|=
name|bfd_arm_vfp11_insn_decode
argument_list|(
name|insn
argument_list|,
operator|&
name|writemask
argument_list|,
name|other_regs
argument_list|,
operator|&
name|other_numregs
argument_list|)
expr_stmt|;
if|if
condition|(
name|pipe
operator|!=
name|VFP11_BAD
operator|&&
name|bfd_arm_vfp11_antidependency
argument_list|(
name|writemask
argument_list|,
name|regs
argument_list|,
name|numregs
argument_list|)
condition|)
name|state
operator|=
literal|3
expr_stmt|;
else|else
block|{
name|state
operator|=
literal|0
expr_stmt|;
name|next_i
operator|=
name|first_fmac
operator|+
literal|4
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|3
case|:
name|abort
argument_list|()
expr_stmt|;
comment|/* Should be unreachable.  */
block|}
if|if
condition|(
name|state
operator|==
literal|3
condition|)
block|{
name|elf32_vfp11_erratum_list
modifier|*
name|newerr
init|=
name|bfd_zmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|elf32_vfp11_erratum_list
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|errcount
decl_stmt|;
name|errcount
operator|=
operator|++
operator|(
name|elf32_arm_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|erratumcount
operator|)
expr_stmt|;
name|newerr
operator|->
name|u
operator|.
name|b
operator|.
name|vfp_insn
operator|=
name|veneer_of_insn
expr_stmt|;
switch|switch
condition|(
name|span_type
condition|)
block|{
case|case
literal|'a'
case|:
name|newerr
operator|->
name|type
operator|=
name|VFP11_ERRATUM_BRANCH_TO_ARM_VENEER
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|record_vfp11_erratum_veneer
argument_list|(
name|link_info
argument_list|,
name|newerr
argument_list|,
name|abfd
argument_list|,
name|sec
argument_list|,
name|first_fmac
argument_list|)
expr_stmt|;
name|newerr
operator|->
name|vma
operator|=
operator|-
literal|1
expr_stmt|;
name|newerr
operator|->
name|next
operator|=
name|sec_data
operator|->
name|erratumlist
expr_stmt|;
name|sec_data
operator|->
name|erratumlist
operator|=
name|newerr
expr_stmt|;
name|state
operator|=
literal|0
expr_stmt|;
block|}
name|i
operator|=
name|next_i
expr_stmt|;
block|}
block|}
if|if
condition|(
name|contents
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|contents
condition|)
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
name|contents
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|TRUE
return|;
name|error_return
label|:
if|if
condition|(
name|contents
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|contents
condition|)
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Find virtual-memory addresses for VFP11 erratum veneers and return locations    after sections have been laid out, using specially-named symbols.  */
end_comment

begin_function
name|void
name|bfd_elf32_arm_vfp11_fix_veneer_locations
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
parameter_list|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|elf32_arm_link_hash_table
modifier|*
name|globals
decl_stmt|;
name|char
modifier|*
name|tmp_name
decl_stmt|;
if|if
condition|(
name|link_info
operator|->
name|relocatable
condition|)
return|return;
comment|/* Skip if this bfd does not correspond to an ELF image.  */
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|abfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
return|return;
name|globals
operator|=
name|elf32_arm_hash_table
argument_list|(
name|link_info
argument_list|)
expr_stmt|;
name|tmp_name
operator|=
name|bfd_malloc
argument_list|(
operator|(
name|bfd_size_type
operator|)
name|strlen
argument_list|(
name|VFP11_ERRATUM_VENEER_ENTRY_NAME
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
for|for
control|(
name|sec
operator|=
name|abfd
operator|->
name|sections
init|;
name|sec
operator|!=
name|NULL
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
block|{
name|struct
name|_arm_elf_section_data
modifier|*
name|sec_data
init|=
name|elf32_arm_section_data
argument_list|(
name|sec
argument_list|)
decl_stmt|;
name|elf32_vfp11_erratum_list
modifier|*
name|errnode
init|=
name|sec_data
operator|->
name|erratumlist
decl_stmt|;
for|for
control|(
init|;
name|errnode
operator|!=
name|NULL
condition|;
name|errnode
operator|=
name|errnode
operator|->
name|next
control|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|myh
decl_stmt|;
name|bfd_vma
name|vma
decl_stmt|;
switch|switch
condition|(
name|errnode
operator|->
name|type
condition|)
block|{
case|case
name|VFP11_ERRATUM_BRANCH_TO_ARM_VENEER
case|:
case|case
name|VFP11_ERRATUM_BRANCH_TO_THUMB_VENEER
case|:
comment|/* Find veneer symbol.  */
name|sprintf
argument_list|(
name|tmp_name
argument_list|,
name|VFP11_ERRATUM_VENEER_ENTRY_NAME
argument_list|,
name|errnode
operator|->
name|u
operator|.
name|b
operator|.
name|veneer
operator|->
name|u
operator|.
name|v
operator|.
name|id
argument_list|)
expr_stmt|;
name|myh
operator|=
name|elf_link_hash_lookup
argument_list|(
operator|&
operator|(
name|globals
operator|)
operator|->
name|root
argument_list|,
name|tmp_name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|myh
operator|==
name|NULL
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: unable to find VFP11 veneer "
literal|"`%s'"
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|tmp_name
argument_list|)
expr_stmt|;
name|vma
operator|=
name|myh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|myh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|+
name|myh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
name|errnode
operator|->
name|u
operator|.
name|b
operator|.
name|veneer
operator|->
name|vma
operator|=
name|vma
expr_stmt|;
break|break;
case|case
name|VFP11_ERRATUM_ARM_VENEER
case|:
case|case
name|VFP11_ERRATUM_THUMB_VENEER
case|:
comment|/* Find return location.  */
name|sprintf
argument_list|(
name|tmp_name
argument_list|,
name|VFP11_ERRATUM_VENEER_ENTRY_NAME
literal|"_r"
argument_list|,
name|errnode
operator|->
name|u
operator|.
name|v
operator|.
name|id
argument_list|)
expr_stmt|;
name|myh
operator|=
name|elf_link_hash_lookup
argument_list|(
operator|&
operator|(
name|globals
operator|)
operator|->
name|root
argument_list|,
name|tmp_name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|myh
operator|==
name|NULL
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: unable to find VFP11 veneer "
literal|"`%s'"
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|tmp_name
argument_list|)
expr_stmt|;
name|vma
operator|=
name|myh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|myh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|+
name|myh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
name|errnode
operator|->
name|u
operator|.
name|v
operator|.
name|branch
operator|->
name|vma
operator|=
name|vma
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|free
argument_list|(
name|tmp_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set target relocation values needed during linking.  */
end_comment

begin_function
name|void
name|bfd_elf32_arm_set_target_relocs
parameter_list|(
name|struct
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
parameter_list|,
name|int
name|target1_is_rel
parameter_list|,
name|char
modifier|*
name|target2_type
parameter_list|,
name|int
name|fix_v4bx
parameter_list|,
name|int
name|use_blx
parameter_list|,
name|bfd_arm_vfp11_fix
name|vfp11_fix
parameter_list|,
name|int
name|no_enum_warn
parameter_list|,
name|int
name|pic_veneer
parameter_list|)
block|{
name|struct
name|elf32_arm_link_hash_table
modifier|*
name|globals
decl_stmt|;
name|globals
operator|=
name|elf32_arm_hash_table
argument_list|(
name|link_info
argument_list|)
expr_stmt|;
name|globals
operator|->
name|target1_is_rel
operator|=
name|target1_is_rel
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|target2_type
argument_list|,
literal|"rel"
argument_list|)
operator|==
literal|0
condition|)
name|globals
operator|->
name|target2_reloc
operator|=
name|R_ARM_REL32
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|target2_type
argument_list|,
literal|"abs"
argument_list|)
operator|==
literal|0
condition|)
name|globals
operator|->
name|target2_reloc
operator|=
name|R_ARM_ABS32
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|target2_type
argument_list|,
literal|"got-rel"
argument_list|)
operator|==
literal|0
condition|)
name|globals
operator|->
name|target2_reloc
operator|=
name|R_ARM_GOT_PREL
expr_stmt|;
else|else
block|{
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"Invalid TARGET2 relocation type '%s'."
argument_list|)
argument_list|,
name|target2_type
argument_list|)
expr_stmt|;
block|}
name|globals
operator|->
name|fix_v4bx
operator|=
name|fix_v4bx
expr_stmt|;
name|globals
operator|->
name|use_blx
operator||=
name|use_blx
expr_stmt|;
name|globals
operator|->
name|vfp11_fix
operator|=
name|vfp11_fix
expr_stmt|;
name|globals
operator|->
name|pic_veneer
operator|=
name|pic_veneer
expr_stmt|;
name|elf32_arm_tdata
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|no_enum_size_warning
operator|=
name|no_enum_warn
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The thumb form of a long branch is a bit finicky, because the offset    encoding is split over two fields, each in it's own instruction. They    can occur in any order. So given a thumb form of long branch, and an    offset, insert the offset into the thumb branch and return finished    instruction.     It takes two thumb instructions to encode the target address. Each has    11 bits to invest. The upper 11 bits are stored in one (identified by    H-0.. see below), the lower 11 bits are stored in the other (identified    by H-1).     Combine together and shifted left by 1 (it's a half word address) and    there you have it.     Op: 1111 = F,    H-0, upper address-0 = 000    Op: 1111 = F,    H-1, lower address-0 = 800     They can be ordered either way, but the arm tools I've seen always put    the lower one first. It probably doesn't matter. krk@cygnus.com     XXX:  Actually the order does matter.  The second instruction (H-1)    moves the computed address into the PC, so it must be the second one    in the sequence.  The problem, however is that whilst little endian code    stores the instructions in HI then LOW order, big endian code does the    reverse.  nickc@cygnus.com.  */
end_comment

begin_define
define|#
directive|define
name|LOW_HI_ORDER
value|0xF800F000
end_define

begin_define
define|#
directive|define
name|HI_LOW_ORDER
value|0xF000F800
end_define

begin_function
specifier|static
name|insn32
name|insert_thumb_branch
parameter_list|(
name|insn32
name|br_insn
parameter_list|,
name|int
name|rel_off
parameter_list|)
block|{
name|unsigned
name|int
name|low_bits
decl_stmt|;
name|unsigned
name|int
name|high_bits
decl_stmt|;
name|BFD_ASSERT
argument_list|(
operator|(
name|rel_off
operator|&
literal|1
operator|)
operator|!=
literal|1
argument_list|)
expr_stmt|;
name|rel_off
operator|>>=
literal|1
expr_stmt|;
comment|/* Half word aligned address.  */
name|low_bits
operator|=
name|rel_off
operator|&
literal|0x000007FF
expr_stmt|;
comment|/* The bottom 11 bits.  */
name|high_bits
operator|=
operator|(
name|rel_off
operator|>>
literal|11
operator|)
operator|&
literal|0x000007FF
expr_stmt|;
comment|/* The top 11 bits.  */
if|if
condition|(
operator|(
name|br_insn
operator|&
name|LOW_HI_ORDER
operator|)
operator|==
name|LOW_HI_ORDER
condition|)
name|br_insn
operator|=
name|LOW_HI_ORDER
operator||
operator|(
name|low_bits
operator|<<
literal|16
operator|)
operator||
name|high_bits
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|br_insn
operator|&
name|HI_LOW_ORDER
operator|)
operator|==
name|HI_LOW_ORDER
condition|)
name|br_insn
operator|=
name|HI_LOW_ORDER
operator||
operator|(
name|high_bits
operator|<<
literal|16
operator|)
operator||
name|low_bits
expr_stmt|;
else|else
comment|/* FIXME: abort is probably not the right call. krk@cygnus.com  */
name|abort
argument_list|()
expr_stmt|;
comment|/* Error - not a valid branch instruction form.  */
return|return
name|br_insn
return|;
block|}
end_function

begin_comment
comment|/* Store an Arm insn into an output section not processed by    elf32_arm_write_section.  */
end_comment

begin_function
specifier|static
name|void
name|put_arm_insn
parameter_list|(
name|struct
name|elf32_arm_link_hash_table
modifier|*
name|htab
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|bfd_vma
name|val
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
if|if
condition|(
name|htab
operator|->
name|byteswap_code
operator|!=
name|bfd_little_endian
argument_list|(
name|output_bfd
argument_list|)
condition|)
name|bfd_putl32
argument_list|(
name|val
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
else|else
name|bfd_putb32
argument_list|(
name|val
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store a 16-bit Thumb insn into an output section not processed by    elf32_arm_write_section.  */
end_comment

begin_function
specifier|static
name|void
name|put_thumb_insn
parameter_list|(
name|struct
name|elf32_arm_link_hash_table
modifier|*
name|htab
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|bfd_vma
name|val
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
if|if
condition|(
name|htab
operator|->
name|byteswap_code
operator|!=
name|bfd_little_endian
argument_list|(
name|output_bfd
argument_list|)
condition|)
name|bfd_putl16
argument_list|(
name|val
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
else|else
name|bfd_putb16
argument_list|(
name|val
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Thumb code calling an ARM function.  */
end_comment

begin_function
specifier|static
name|int
name|elf32_thumb_to_arm_stub
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd_byte
modifier|*
name|hit_data
parameter_list|,
name|asection
modifier|*
name|sym_sec
parameter_list|,
name|bfd_vma
name|offset
parameter_list|,
name|bfd_signed_vma
name|addend
parameter_list|,
name|bfd_vma
name|val
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
parameter_list|)
block|{
name|asection
modifier|*
name|s
init|=
literal|0
decl_stmt|;
name|bfd_vma
name|my_offset
decl_stmt|;
name|unsigned
name|long
name|int
name|tmp
decl_stmt|;
name|long
name|int
name|ret_offset
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|myh
decl_stmt|;
name|struct
name|elf32_arm_link_hash_table
modifier|*
name|globals
decl_stmt|;
name|myh
operator|=
name|find_thumb_glue
argument_list|(
name|info
argument_list|,
name|name
argument_list|,
name|error_message
argument_list|)
expr_stmt|;
if|if
condition|(
name|myh
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|globals
operator|=
name|elf32_arm_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|globals
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|globals
operator|->
name|bfd_of_glue_owner
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|my_offset
operator|=
name|myh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|globals
operator|->
name|bfd_of_glue_owner
argument_list|,
name|THUMB2ARM_GLUE_SECTION_NAME
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|->
name|contents
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|->
name|output_section
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|my_offset
operator|&
literal|0x01
operator|)
operator|==
literal|0x01
condition|)
block|{
if|if
condition|(
name|sym_sec
operator|!=
name|NULL
operator|&&
name|sym_sec
operator|->
name|owner
operator|!=
name|NULL
operator|&&
operator|!
name|INTERWORK_FLAG
argument_list|(
name|sym_sec
operator|->
name|owner
argument_list|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B(%s): warning: interworking not enabled.\n"
literal|"  first occurrence: %B: thumb call to arm"
argument_list|)
argument_list|,
name|sym_sec
operator|->
name|owner
argument_list|,
name|input_bfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
operator|--
name|my_offset
expr_stmt|;
name|myh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|my_offset
expr_stmt|;
name|put_thumb_insn
argument_list|(
name|globals
argument_list|,
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|t2a1_bx_pc_insn
argument_list|,
name|s
operator|->
name|contents
operator|+
name|my_offset
argument_list|)
expr_stmt|;
name|put_thumb_insn
argument_list|(
name|globals
argument_list|,
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|t2a2_noop_insn
argument_list|,
name|s
operator|->
name|contents
operator|+
name|my_offset
operator|+
literal|2
argument_list|)
expr_stmt|;
name|ret_offset
operator|=
comment|/* Address of destination of the stub.  */
operator|(
operator|(
name|bfd_signed_vma
operator|)
name|val
operator|)
operator|-
operator|(
call|(
name|bfd_signed_vma
call|)
comment|/* Offset from the start of the current section 	      to the start of the stubs.  */
argument_list|(
name|s
operator|->
name|output_offset
comment|/* Offset of the start of this stub from the start of the stubs.  */
operator|+
name|my_offset
comment|/* Address of the start of the current section.  */
operator|+
name|s
operator|->
name|output_section
operator|->
name|vma
argument_list|)
comment|/* The branch instruction is 4 bytes into the stub.  */
operator|+
literal|4
comment|/* ARM branches work from the pc of the instruction + 8.  */
operator|+
literal|8
operator|)
expr_stmt|;
name|put_arm_insn
argument_list|(
name|globals
argument_list|,
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|t2a3_b_insn
operator||
operator|(
operator|(
name|ret_offset
operator|>>
literal|2
operator|)
operator|&
literal|0x00FFFFFF
operator|)
argument_list|,
name|s
operator|->
name|contents
operator|+
name|my_offset
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
name|my_offset
operator|<=
name|globals
operator|->
name|thumb_glue_size
argument_list|)
expr_stmt|;
comment|/* Now go back and fix up the original BL insn to point to here.  */
name|ret_offset
operator|=
comment|/* Address of where the stub is located.  */
operator|(
name|s
operator|->
name|output_section
operator|->
name|vma
operator|+
name|s
operator|->
name|output_offset
operator|+
name|my_offset
operator|)
comment|/* Address of where the BL is located.  */
operator|-
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|offset
operator|)
comment|/* Addend in the relocation.  */
operator|-
name|addend
comment|/* Biassing for PC-relative addressing.  */
operator|-
literal|8
expr_stmt|;
name|tmp
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
operator|-
name|input_section
operator|->
name|vma
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|insert_thumb_branch
argument_list|(
name|tmp
argument_list|,
name|ret_offset
argument_list|)
argument_list|,
name|hit_data
operator|-
name|input_section
operator|->
name|vma
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Populate an Arm to Thumb stub.  Returns the stub symbol.  */
end_comment

begin_function
specifier|static
name|struct
name|elf_link_hash_entry
modifier|*
name|elf32_arm_create_thumb_stub
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|asection
modifier|*
name|sym_sec
parameter_list|,
name|bfd_vma
name|val
parameter_list|,
name|asection
modifier|*
name|s
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
parameter_list|)
block|{
name|bfd_vma
name|my_offset
decl_stmt|;
name|long
name|int
name|ret_offset
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|myh
decl_stmt|;
name|struct
name|elf32_arm_link_hash_table
modifier|*
name|globals
decl_stmt|;
name|myh
operator|=
name|find_arm_glue
argument_list|(
name|info
argument_list|,
name|name
argument_list|,
name|error_message
argument_list|)
expr_stmt|;
if|if
condition|(
name|myh
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|globals
operator|=
name|elf32_arm_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|globals
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|globals
operator|->
name|bfd_of_glue_owner
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|my_offset
operator|=
name|myh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
if|if
condition|(
operator|(
name|my_offset
operator|&
literal|0x01
operator|)
operator|==
literal|0x01
condition|)
block|{
if|if
condition|(
name|sym_sec
operator|!=
name|NULL
operator|&&
name|sym_sec
operator|->
name|owner
operator|!=
name|NULL
operator|&&
operator|!
name|INTERWORK_FLAG
argument_list|(
name|sym_sec
operator|->
name|owner
argument_list|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B(%s): warning: interworking not enabled.\n"
literal|"  first occurrence: %B: arm call to thumb"
argument_list|)
argument_list|,
name|sym_sec
operator|->
name|owner
argument_list|,
name|input_bfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
operator|--
name|my_offset
expr_stmt|;
name|myh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|my_offset
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
operator|||
name|globals
operator|->
name|root
operator|.
name|is_relocatable_executable
operator|||
name|globals
operator|->
name|pic_veneer
condition|)
block|{
comment|/* For relocatable objects we can't use absolute addresses, 	     so construct the address from a relative offset.  */
comment|/* TODO: If the offset is small it's probably worth 	     constructing the address with adds.  */
name|put_arm_insn
argument_list|(
name|globals
argument_list|,
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|a2t1p_ldr_insn
argument_list|,
name|s
operator|->
name|contents
operator|+
name|my_offset
argument_list|)
expr_stmt|;
name|put_arm_insn
argument_list|(
name|globals
argument_list|,
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|a2t2p_add_pc_insn
argument_list|,
name|s
operator|->
name|contents
operator|+
name|my_offset
operator|+
literal|4
argument_list|)
expr_stmt|;
name|put_arm_insn
argument_list|(
name|globals
argument_list|,
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|a2t3p_bx_r12_insn
argument_list|,
name|s
operator|->
name|contents
operator|+
name|my_offset
operator|+
literal|8
argument_list|)
expr_stmt|;
comment|/* Adjust the offset by 4 for the position of the add, 	     and 8 for the pipeline offset.  */
name|ret_offset
operator|=
operator|(
name|val
operator|-
operator|(
name|s
operator|->
name|output_offset
operator|+
name|s
operator|->
name|output_section
operator|->
name|vma
operator|+
name|my_offset
operator|+
literal|12
operator|)
operator|)
operator||
literal|1
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|ret_offset
argument_list|,
name|s
operator|->
name|contents
operator|+
name|my_offset
operator|+
literal|12
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|globals
operator|->
name|use_blx
condition|)
block|{
name|put_arm_insn
argument_list|(
name|globals
argument_list|,
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|a2t1v5_ldr_insn
argument_list|,
name|s
operator|->
name|contents
operator|+
name|my_offset
argument_list|)
expr_stmt|;
comment|/* It's a thumb address.  Add the low order bit.  */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|val
operator||
name|a2t2v5_func_addr_insn
argument_list|,
name|s
operator|->
name|contents
operator|+
name|my_offset
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|put_arm_insn
argument_list|(
name|globals
argument_list|,
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|a2t1_ldr_insn
argument_list|,
name|s
operator|->
name|contents
operator|+
name|my_offset
argument_list|)
expr_stmt|;
name|put_arm_insn
argument_list|(
name|globals
argument_list|,
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|a2t2_bx_r12_insn
argument_list|,
name|s
operator|->
name|contents
operator|+
name|my_offset
operator|+
literal|4
argument_list|)
expr_stmt|;
comment|/* It's a thumb address.  Add the low order bit.  */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|val
operator||
name|a2t3_func_addr_insn
argument_list|,
name|s
operator|->
name|contents
operator|+
name|my_offset
operator|+
literal|8
argument_list|)
expr_stmt|;
block|}
block|}
name|BFD_ASSERT
argument_list|(
name|my_offset
operator|<=
name|globals
operator|->
name|arm_glue_size
argument_list|)
expr_stmt|;
return|return
name|myh
return|;
block|}
end_function

begin_comment
comment|/* Arm code calling a Thumb function.  */
end_comment

begin_function
specifier|static
name|int
name|elf32_arm_to_thumb_stub
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd_byte
modifier|*
name|hit_data
parameter_list|,
name|asection
modifier|*
name|sym_sec
parameter_list|,
name|bfd_vma
name|offset
parameter_list|,
name|bfd_signed_vma
name|addend
parameter_list|,
name|bfd_vma
name|val
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
parameter_list|)
block|{
name|unsigned
name|long
name|int
name|tmp
decl_stmt|;
name|bfd_vma
name|my_offset
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|long
name|int
name|ret_offset
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|myh
decl_stmt|;
name|struct
name|elf32_arm_link_hash_table
modifier|*
name|globals
decl_stmt|;
name|globals
operator|=
name|elf32_arm_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|globals
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|globals
operator|->
name|bfd_of_glue_owner
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|globals
operator|->
name|bfd_of_glue_owner
argument_list|,
name|ARM2THUMB_GLUE_SECTION_NAME
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|->
name|contents
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|->
name|output_section
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|myh
operator|=
name|elf32_arm_create_thumb_stub
argument_list|(
name|info
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|output_bfd
argument_list|,
name|sym_sec
argument_list|,
name|val
argument_list|,
name|s
argument_list|,
name|error_message
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|myh
condition|)
return|return
name|FALSE
return|;
name|my_offset
operator|=
name|myh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
name|tmp
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|tmp
operator|&
literal|0xFF000000
expr_stmt|;
comment|/* Somehow these are both 4 too far, so subtract 8.  */
name|ret_offset
operator|=
operator|(
name|s
operator|->
name|output_offset
operator|+
name|my_offset
operator|+
name|s
operator|->
name|output_section
operator|->
name|vma
operator|-
operator|(
name|input_section
operator|->
name|output_offset
operator|+
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|offset
operator|+
name|addend
operator|)
operator|-
literal|8
operator|)
expr_stmt|;
name|tmp
operator|=
name|tmp
operator||
operator|(
operator|(
name|ret_offset
operator|>>
literal|2
operator|)
operator|&
literal|0x00FFFFFF
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|tmp
argument_list|,
name|hit_data
operator|-
name|input_section
operator|->
name|vma
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Populate Arm stub for an exported Thumb function.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_arm_to_thumb_export_stub
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|void
modifier|*
name|inf
parameter_list|)
block|{
name|struct
name|bfd_link_info
modifier|*
name|info
init|=
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|)
name|inf
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|myh
decl_stmt|;
name|struct
name|elf32_arm_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|struct
name|elf32_arm_link_hash_table
modifier|*
name|globals
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
name|char
modifier|*
name|error_message
decl_stmt|;
name|eh
operator|=
name|elf32_arm_hash_entry
argument_list|(
name|h
argument_list|)
expr_stmt|;
comment|/* Allocate stubs for exported Thumb functions on v4t.  */
if|if
condition|(
name|eh
operator|->
name|export_glue
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
name|globals
operator|=
name|elf32_arm_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|globals
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|globals
operator|->
name|bfd_of_glue_owner
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|globals
operator|->
name|bfd_of_glue_owner
argument_list|,
name|ARM2THUMB_GLUE_SECTION_NAME
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|->
name|contents
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|->
name|output_section
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|sec
operator|=
name|eh
operator|->
name|export_glue
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sec
operator|->
name|output_section
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|val
operator|=
name|eh
operator|->
name|export_glue
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|sec
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|myh
operator|=
name|elf32_arm_create_thumb_stub
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
argument_list|,
name|globals
operator|->
name|obfd
argument_list|,
name|sec
argument_list|,
name|val
argument_list|,
name|s
argument_list|,
operator|&
name|error_message
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|myh
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Generate Arm stubs for exported Thumb symbols.  */
end_comment

begin_function
specifier|static
name|void
name|elf32_arm_begin_write_processing
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
parameter_list|)
block|{
name|struct
name|elf32_arm_link_hash_table
modifier|*
name|globals
decl_stmt|;
if|if
condition|(
operator|!
name|link_info
condition|)
return|return;
name|globals
operator|=
name|elf32_arm_hash_table
argument_list|(
name|link_info
argument_list|)
expr_stmt|;
comment|/* If blx is available then exported Thumb symbols are OK and there is      nothing to do.  */
if|if
condition|(
name|globals
operator|->
name|use_blx
condition|)
return|return;
name|elf_link_hash_traverse
argument_list|(
operator|&
name|globals
operator|->
name|root
argument_list|,
name|elf32_arm_to_thumb_export_stub
argument_list|,
name|link_info
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Some relocations map to different relocations depending on the    target.  Return the real relocation.  */
end_comment

begin_function
specifier|static
name|int
name|arm_real_reloc_type
parameter_list|(
name|struct
name|elf32_arm_link_hash_table
modifier|*
name|globals
parameter_list|,
name|int
name|r_type
parameter_list|)
block|{
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_ARM_TARGET1
case|:
if|if
condition|(
name|globals
operator|->
name|target1_is_rel
condition|)
return|return
name|R_ARM_REL32
return|;
else|else
return|return
name|R_ARM_ABS32
return|;
case|case
name|R_ARM_TARGET2
case|:
return|return
name|globals
operator|->
name|target2_reloc
return|;
default|default:
return|return
name|r_type
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return the base VMA address which should be subtracted from real addresses    when resolving @dtpoff relocation.    This is PT_TLS segment p_vaddr.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|dtpoff_base
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
comment|/* If tls_sec is NULL, we should have signalled an error already.  */
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|tls_sec
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
return|return
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|tls_sec
operator|->
name|vma
return|;
block|}
end_function

begin_comment
comment|/* Return the relocation value for @tpoff relocation    if STT_TLS virtual address is ADDRESS.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|tpoff
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd_vma
name|address
parameter_list|)
block|{
name|struct
name|elf_link_hash_table
modifier|*
name|htab
init|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
decl_stmt|;
name|bfd_vma
name|base
decl_stmt|;
comment|/* If tls_sec is NULL, we should have signalled an error already.  */
if|if
condition|(
name|htab
operator|->
name|tls_sec
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|base
operator|=
name|align_power
argument_list|(
operator|(
name|bfd_vma
operator|)
name|TCB_SIZE
argument_list|,
name|htab
operator|->
name|tls_sec
operator|->
name|alignment_power
argument_list|)
expr_stmt|;
return|return
name|address
operator|-
name|htab
operator|->
name|tls_sec
operator|->
name|vma
operator|+
name|base
return|;
block|}
end_function

begin_comment
comment|/* Perform an R_ARM_ABS12 relocation on the field pointed to by DATA.    VALUE is the relocation value.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|elf32_arm_abs12_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|bfd_vma
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|>
literal|0xfff
condition|)
return|return
name|bfd_reloc_overflow
return|;
name|value
operator||=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|data
argument_list|)
operator|&
literal|0xfffff000
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|value
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_comment
comment|/* For a given value of n, calculate the value of G_n as required to    deal with group relocations.  We return it in the form of an    encoded constant-and-rotation, together with the final residual.  If n is    specified as less than zero, then final_residual is filled with the    input value and no further action is performed.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|calculate_group_reloc_mask
parameter_list|(
name|bfd_vma
name|value
parameter_list|,
name|int
name|n
parameter_list|,
name|bfd_vma
modifier|*
name|final_residual
parameter_list|)
block|{
name|int
name|current_n
decl_stmt|;
name|bfd_vma
name|g_n
decl_stmt|;
name|bfd_vma
name|encoded_g_n
init|=
literal|0
decl_stmt|;
name|bfd_vma
name|residual
init|=
name|value
decl_stmt|;
comment|/* Also known as Y_n.  */
for|for
control|(
name|current_n
operator|=
literal|0
init|;
name|current_n
operator|<=
name|n
condition|;
name|current_n
operator|++
control|)
block|{
name|int
name|shift
decl_stmt|;
comment|/* Calculate which part of the value to mask.  */
if|if
condition|(
name|residual
operator|==
literal|0
condition|)
name|shift
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|int
name|msb
decl_stmt|;
comment|/* Determine the most significant bit in the residual and              align the resulting value to a 2-bit boundary.  */
for|for
control|(
name|msb
operator|=
literal|30
init|;
name|msb
operator|>=
literal|0
condition|;
name|msb
operator|-=
literal|2
control|)
if|if
condition|(
name|residual
operator|&
operator|(
literal|3
operator|<<
name|msb
operator|)
condition|)
break|break;
comment|/* The desired shift is now (msb - 6), or zero, whichever              is the greater.  */
name|shift
operator|=
name|msb
operator|-
literal|6
expr_stmt|;
if|if
condition|(
name|shift
operator|<
literal|0
condition|)
name|shift
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Calculate g_n in 32-bit as well as encoded constant+rotation form.  */
name|g_n
operator|=
name|residual
operator|&
operator|(
literal|0xff
operator|<<
name|shift
operator|)
expr_stmt|;
name|encoded_g_n
operator|=
operator|(
name|g_n
operator|>>
name|shift
operator|)
operator||
operator|(
operator|(
name|g_n
operator|<=
literal|0xff
condition|?
literal|0
else|:
operator|(
literal|32
operator|-
name|shift
operator|)
operator|/
literal|2
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
comment|/* Calculate the residual for the next time around.  */
name|residual
operator|&=
operator|~
name|g_n
expr_stmt|;
block|}
operator|*
name|final_residual
operator|=
name|residual
expr_stmt|;
return|return
name|encoded_g_n
return|;
block|}
end_function

begin_comment
comment|/* Given an ARM instruction, determine whether it is an ADD or a SUB.    Returns 1 if it is an ADD, -1 if it is a SUB, and 0 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|identify_add_or_sub
parameter_list|(
name|bfd_vma
name|insn
parameter_list|)
block|{
name|int
name|opcode
init|=
name|insn
operator|&
literal|0x1e00000
decl_stmt|;
if|if
condition|(
name|opcode
operator|==
literal|1
operator|<<
literal|23
condition|)
comment|/* ADD */
return|return
literal|1
return|;
if|if
condition|(
name|opcode
operator|==
literal|1
operator|<<
literal|22
condition|)
comment|/* SUB */
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Determine if we're dealing with a Thumb-2 object.  */
end_comment

begin_function
specifier|static
name|int
name|using_thumb2
parameter_list|(
name|struct
name|elf32_arm_link_hash_table
modifier|*
name|globals
parameter_list|)
block|{
name|int
name|arch
init|=
name|bfd_elf_get_obj_attr_int
argument_list|(
name|globals
operator|->
name|obfd
argument_list|,
name|OBJ_ATTR_PROC
argument_list|,
name|Tag_CPU_arch
argument_list|)
decl_stmt|;
return|return
name|arch
operator|==
name|TAG_CPU_ARCH_V6T2
operator|||
name|arch
operator|>=
name|TAG_CPU_ARCH_V7
return|;
block|}
end_function

begin_comment
comment|/* Perform a relocation as part of a final link.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|elf32_arm_final_link_relocate
parameter_list|(
name|reloc_howto_type
modifier|*
name|howto
parameter_list|,
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|rel
parameter_list|,
name|bfd_vma
name|value
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|asection
modifier|*
name|sym_sec
parameter_list|,
specifier|const
name|char
modifier|*
name|sym_name
parameter_list|,
name|int
name|sym_flags
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|bfd_boolean
modifier|*
name|unresolved_reloc_p
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
parameter_list|)
block|{
name|unsigned
name|long
name|r_type
init|=
name|howto
operator|->
name|type
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|bfd_byte
modifier|*
name|hit_data
init|=
name|contents
operator|+
name|rel
operator|->
name|r_offset
decl_stmt|;
name|bfd
modifier|*
name|dynobj
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|bfd_vma
modifier|*
name|local_got_offsets
decl_stmt|;
name|asection
modifier|*
name|sgot
init|=
name|NULL
decl_stmt|;
name|asection
modifier|*
name|splt
init|=
name|NULL
decl_stmt|;
name|asection
modifier|*
name|sreloc
init|=
name|NULL
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|;
name|bfd_signed_vma
name|signed_addend
decl_stmt|;
name|struct
name|elf32_arm_link_hash_table
modifier|*
name|globals
decl_stmt|;
name|globals
operator|=
name|elf32_arm_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* Some relocation type map to different relocations depending on the      target.  We pick the right one here.  */
name|r_type
operator|=
name|arm_real_reloc_type
argument_list|(
name|globals
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|!=
name|howto
operator|->
name|type
condition|)
name|howto
operator|=
name|elf32_arm_howto_from_type
argument_list|(
name|r_type
argument_list|)
expr_stmt|;
comment|/* If the start address has been set, then set the EF_ARM_HASENTRY      flag.  Setting this more than once is redundant, but the cost is      not too high, and it keeps the code simple.       The test is done  here, rather than somewhere else, because the      start address is only set just before the final link commences.       Note - if the user deliberately sets a start address of 0, the      flag will not be set.  */
if|if
condition|(
name|bfd_get_start_address
argument_list|(
name|output_bfd
argument_list|)
operator|!=
literal|0
condition|)
name|elf_elfheader
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|e_flags
operator||=
name|EF_ARM_HASENTRY
expr_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
if|if
condition|(
name|dynobj
condition|)
block|{
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
name|splt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
block|}
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|local_got_offsets
operator|=
name|elf_local_got_offsets
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|globals
operator|->
name|use_rel
condition|)
block|{
name|addend
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
argument_list|)
operator|&
name|howto
operator|->
name|src_mask
expr_stmt|;
if|if
condition|(
name|addend
operator|&
operator|(
operator|(
name|howto
operator|->
name|src_mask
operator|+
literal|1
operator|)
operator|>>
literal|1
operator|)
condition|)
block|{
name|signed_addend
operator|=
operator|-
literal|1
expr_stmt|;
name|signed_addend
operator|&=
operator|~
name|howto
operator|->
name|src_mask
expr_stmt|;
name|signed_addend
operator||=
name|addend
expr_stmt|;
block|}
else|else
name|signed_addend
operator|=
name|addend
expr_stmt|;
block|}
else|else
name|addend
operator|=
name|signed_addend
operator|=
name|rel
operator|->
name|r_addend
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_ARM_NONE
case|:
comment|/* We don't need to find a value for this symbol.  It's just a 	 marker.  */
operator|*
name|unresolved_reloc_p
operator|=
name|FALSE
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_ARM_ABS12
case|:
if|if
condition|(
operator|!
name|globals
operator|->
name|vxworks_p
condition|)
return|return
name|elf32_arm_abs12_reloc
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
argument_list|,
name|value
operator|+
name|addend
argument_list|)
return|;
case|case
name|R_ARM_PC24
case|:
case|case
name|R_ARM_ABS32
case|:
case|case
name|R_ARM_ABS32_NOI
case|:
case|case
name|R_ARM_REL32
case|:
case|case
name|R_ARM_REL32_NOI
case|:
case|case
name|R_ARM_CALL
case|:
case|case
name|R_ARM_JUMP24
case|:
case|case
name|R_ARM_XPC25
case|:
case|case
name|R_ARM_PREL31
case|:
case|case
name|R_ARM_PLT32
case|:
comment|/* Handle relocations which should use the PLT entry.  ABS32/REL32 	 will use the symbol's value, which may point to a PLT entry, but we 	 don't need to handle that here.  If we created a PLT entry, all 	 branches in this object should go to it.  */
if|if
condition|(
operator|(
name|r_type
operator|!=
name|R_ARM_ABS32
operator|&&
name|r_type
operator|!=
name|R_ARM_REL32
operator|&&
name|r_type
operator|!=
name|R_ARM_ABS32_NOI
operator|&&
name|r_type
operator|!=
name|R_ARM_REL32_NOI
operator|)
operator|&&
name|h
operator|!=
name|NULL
operator|&&
name|splt
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|plt
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
comment|/* If we've created a .plt section, and assigned a PLT entry to 	     this function, it should not be known to bind locally.  If 	     it were, we would have cleared the PLT entry.  */
name|BFD_ASSERT
argument_list|(
operator|!
name|SYMBOL_CALLS_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
argument_list|)
expr_stmt|;
name|value
operator|=
operator|(
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|splt
operator|->
name|output_offset
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|)
expr_stmt|;
operator|*
name|unresolved_reloc_p
operator|=
name|FALSE
expr_stmt|;
return|return
name|_bfd_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|value
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
return|;
block|}
comment|/* When generating a shared object or relocatable executable, these 	 relocations are copied into the output file to be resolved at 	 run time.  */
if|if
condition|(
operator|(
name|info
operator|->
name|shared
operator|||
name|globals
operator|->
name|root
operator|.
name|is_relocatable_executable
operator|)
operator|&&
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|&&
operator|(
operator|(
name|r_type
operator|!=
name|R_ARM_REL32
operator|&&
name|r_type
operator|!=
name|R_ARM_REL32_NOI
operator|)
operator|||
operator|!
name|SYMBOL_CALLS_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
operator|)
operator|&&
operator|(
name|h
operator|==
name|NULL
operator|||
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_DEFAULT
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefweak
operator|)
operator|&&
name|r_type
operator|!=
name|R_ARM_PC24
operator|&&
name|r_type
operator|!=
name|R_ARM_CALL
operator|&&
name|r_type
operator|!=
name|R_ARM_JUMP24
operator|&&
name|r_type
operator|!=
name|R_ARM_PREL31
operator|&&
name|r_type
operator|!=
name|R_ARM_PLT32
condition|)
block|{
name|Elf_Internal_Rela
name|outrel
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|bfd_boolean
name|skip
decl_stmt|,
name|relocate
decl_stmt|;
operator|*
name|unresolved_reloc_p
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
operator|(
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|elf_elfheader
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|e_shstrndx
argument_list|,
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|rel_hdr
operator|.
name|sh_name
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|bfd_reloc_notsupported
return|;
name|BFD_ASSERT
argument_list|(
name|reloc_section_p
argument_list|(
name|globals
argument_list|,
name|name
argument_list|,
name|input_section
argument_list|)
argument_list|)
expr_stmt|;
name|sreloc
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sreloc
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
name|skip
operator|=
name|FALSE
expr_stmt|;
name|relocate
operator|=
name|FALSE
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
name|addend
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|=
name|_bfd_elf_section_offset
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|outrel
operator|.
name|r_offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
name|skip
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|outrel
operator|.
name|r_offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|2
condition|)
name|skip
operator|=
name|TRUE
operator|,
name|relocate
operator|=
name|TRUE
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|+=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
if|if
condition|(
name|skip
condition|)
name|memset
argument_list|(
operator|&
name|outrel
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|outrel
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|&&
operator|(
operator|!
name|info
operator|->
name|shared
operator|||
operator|!
name|info
operator|->
name|symbolic
operator|||
operator|!
name|h
operator|->
name|def_regular
operator|)
condition|)
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|symbol
decl_stmt|;
comment|/* This symbol is local, or marked to become local.  */
if|if
condition|(
name|sym_flags
operator|==
name|STT_ARM_TFUNC
condition|)
name|value
operator||=
literal|1
expr_stmt|;
if|if
condition|(
name|globals
operator|->
name|symbian_p
condition|)
block|{
name|asection
modifier|*
name|osec
decl_stmt|;
comment|/* On Symbian OS, the data segment and text segement 		     can be relocated independently.  Therefore, we 		     must indicate the segment to which this 		     relocation is relative.  The BPABI allows us to 		     use any symbol in the right segment; we just use 		     the section symbol as it is convenient.  (We 		     cannot use the symbol given by "h" directly as it 		     will not appear in the dynamic symbol table.)  		     Note that the dynamic linker ignores the section 		     symbol value, so we don't subtract osec->vma 		     from the emitted reloc addend.  */
if|if
condition|(
name|sym_sec
condition|)
name|osec
operator|=
name|sym_sec
operator|->
name|output_section
expr_stmt|;
else|else
name|osec
operator|=
name|input_section
operator|->
name|output_section
expr_stmt|;
name|symbol
operator|=
name|elf_section_data
argument_list|(
name|osec
argument_list|)
operator|->
name|dynindx
expr_stmt|;
if|if
condition|(
name|symbol
operator|==
literal|0
condition|)
block|{
name|struct
name|elf_link_hash_table
modifier|*
name|htab
init|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|osec
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|==
literal|0
operator|&&
name|htab
operator|->
name|data_index_section
operator|!=
name|NULL
condition|)
name|osec
operator|=
name|htab
operator|->
name|data_index_section
expr_stmt|;
else|else
name|osec
operator|=
name|htab
operator|->
name|text_index_section
expr_stmt|;
name|symbol
operator|=
name|elf_section_data
argument_list|(
name|osec
argument_list|)
operator|->
name|dynindx
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
name|symbol
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* On SVR4-ish systems, the dynamic loader cannot 		   relocate the text and data segments independently, 		   so the symbol does not matter.  */
name|symbol
operator|=
literal|0
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|symbol
argument_list|,
name|R_ARM_RELATIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|globals
operator|->
name|use_rel
condition|)
name|relocate
operator|=
name|TRUE
expr_stmt|;
else|else
name|outrel
operator|.
name|r_addend
operator|+=
name|value
expr_stmt|;
block|}
name|loc
operator|=
name|sreloc
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
name|sreloc
operator|->
name|reloc_count
operator|++
operator|*
name|RELOC_SIZE
argument_list|(
name|globals
argument_list|)
expr_stmt|;
name|SWAP_RELOC_OUT
argument_list|(
name|globals
argument_list|)
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
comment|/* If this reloc is against an external symbol, we do not want to 	     fiddle with the addend.  Otherwise, we need to include the symbol 	     value so that it becomes an addend for the dynamic reloc.  */
if|if
condition|(
operator|!
name|relocate
condition|)
return|return
name|bfd_reloc_ok
return|;
return|return
name|_bfd_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|value
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
return|;
block|}
else|else
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_ARM_ABS12
case|:
return|return
name|elf32_arm_abs12_reloc
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
argument_list|,
name|value
operator|+
name|addend
argument_list|)
return|;
case|case
name|R_ARM_XPC25
case|:
comment|/* Arm BLX instruction.  */
case|case
name|R_ARM_CALL
case|:
case|case
name|R_ARM_JUMP24
case|:
case|case
name|R_ARM_PC24
case|:
comment|/* Arm B/BL instruction */
case|case
name|R_ARM_PLT32
case|:
if|if
condition|(
name|r_type
operator|==
name|R_ARM_XPC25
condition|)
block|{
comment|/* Check for Arm calling Arm function.  */
comment|/* FIXME: Should we translate the instruction into a BL 		 instruction instead ?  */
if|if
condition|(
name|sym_flags
operator|!=
name|STT_ARM_TFUNC
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"\%B: Warning: Arm BLX instruction targets Arm function '%s'."
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|h
condition|?
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
else|:
literal|"(local)"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r_type
operator|!=
name|R_ARM_CALL
operator|||
operator|!
name|globals
operator|->
name|use_blx
condition|)
block|{
comment|/* Check for Arm calling Thumb function.  */
if|if
condition|(
name|sym_flags
operator|==
name|STT_ARM_TFUNC
condition|)
block|{
if|if
condition|(
name|elf32_arm_to_thumb_stub
argument_list|(
name|info
argument_list|,
name|sym_name
argument_list|,
name|input_bfd
argument_list|,
name|output_bfd
argument_list|,
name|input_section
argument_list|,
name|hit_data
argument_list|,
name|sym_sec
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|signed_addend
argument_list|,
name|value
argument_list|,
name|error_message
argument_list|)
condition|)
return|return
name|bfd_reloc_ok
return|;
else|else
return|return
name|bfd_reloc_dangerous
return|;
block|}
block|}
comment|/* The ARM ELF ABI says that this reloc is computed as: S - P + A 	     where: 	      S is the address of the symbol in the relocation. 	      P is address of the instruction being relocated. 	      A is the addend (extracted from the instruction) in bytes.  	     S is held in 'value'. 	     P is the base address of the section containing the 	       instruction plus the offset of the reloc into that 	       section, ie: 		 (input_section->output_section->vma + 		  input_section->output_offset + 		  rel->r_offset). 	     A is the addend, converted into bytes, ie: 		 (signed_addend * 4)  	     Note: None of these operations have knowledge of the pipeline 	     size of the processor, thus it is up to the assembler to 	     encode this information into the addend.  */
name|value
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|value
operator|-=
name|rel
operator|->
name|r_offset
expr_stmt|;
if|if
condition|(
name|globals
operator|->
name|use_rel
condition|)
name|value
operator|+=
operator|(
name|signed_addend
operator|<<
name|howto
operator|->
name|size
operator|)
expr_stmt|;
else|else
comment|/* RELA addends do not have to be adjusted by howto->size.  */
name|value
operator|+=
name|signed_addend
expr_stmt|;
name|signed_addend
operator|=
name|value
expr_stmt|;
name|signed_addend
operator|>>=
name|howto
operator|->
name|rightshift
expr_stmt|;
comment|/* A branch to an undefined weak symbol is turned into a jump to 	     the next instruction.  */
if|if
condition|(
name|h
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
block|{
name|value
operator|=
operator|(
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
argument_list|)
operator|&
literal|0xf0000000
operator|)
operator||
literal|0x0affffff
expr_stmt|;
block|}
else|else
block|{
comment|/* Perform a signed range check.  */
if|if
condition|(
name|signed_addend
operator|>
operator|(
call|(
name|bfd_signed_vma
call|)
argument_list|(
name|howto
operator|->
name|dst_mask
operator|>>
literal|1
argument_list|)
operator|)
operator|||
name|signed_addend
operator|<
operator|-
operator|(
call|(
name|bfd_signed_vma
call|)
argument_list|(
operator|(
name|howto
operator|->
name|dst_mask
operator|+
literal|1
operator|)
operator|>>
literal|1
argument_list|)
operator|)
condition|)
return|return
name|bfd_reloc_overflow
return|;
name|addend
operator|=
operator|(
name|value
operator|&
literal|2
operator|)
expr_stmt|;
name|value
operator|=
operator|(
name|signed_addend
operator|&
name|howto
operator|->
name|dst_mask
operator|)
operator||
operator|(
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
argument_list|)
operator|&
operator|(
operator|~
name|howto
operator|->
name|dst_mask
operator|)
operator|)
expr_stmt|;
comment|/* Set the H bit in the BLX instruction.  */
if|if
condition|(
name|sym_flags
operator|==
name|STT_ARM_TFUNC
condition|)
block|{
if|if
condition|(
name|addend
condition|)
name|value
operator||=
operator|(
literal|1
operator|<<
literal|24
operator|)
expr_stmt|;
else|else
name|value
operator|&=
operator|~
call|(
name|bfd_vma
call|)
argument_list|(
literal|1
operator|<<
literal|24
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r_type
operator|==
name|R_ARM_CALL
condition|)
block|{
comment|/* Select the correct instruction (BL or BLX).  */
if|if
condition|(
name|sym_flags
operator|==
name|STT_ARM_TFUNC
condition|)
name|value
operator||=
operator|(
literal|1
operator|<<
literal|28
operator|)
expr_stmt|;
else|else
block|{
name|value
operator|&=
operator|~
call|(
name|bfd_vma
call|)
argument_list|(
literal|1
operator|<<
literal|28
argument_list|)
expr_stmt|;
name|value
operator||=
operator|(
literal|1
operator|<<
literal|24
operator|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|R_ARM_ABS32
case|:
name|value
operator|+=
name|addend
expr_stmt|;
if|if
condition|(
name|sym_flags
operator|==
name|STT_ARM_TFUNC
condition|)
name|value
operator||=
literal|1
expr_stmt|;
break|break;
case|case
name|R_ARM_ABS32_NOI
case|:
name|value
operator|+=
name|addend
expr_stmt|;
break|break;
case|case
name|R_ARM_REL32
case|:
name|value
operator|+=
name|addend
expr_stmt|;
if|if
condition|(
name|sym_flags
operator|==
name|STT_ARM_TFUNC
condition|)
name|value
operator||=
literal|1
expr_stmt|;
name|value
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|rel
operator|->
name|r_offset
operator|)
expr_stmt|;
break|break;
case|case
name|R_ARM_REL32_NOI
case|:
name|value
operator|+=
name|addend
expr_stmt|;
name|value
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|rel
operator|->
name|r_offset
operator|)
expr_stmt|;
break|break;
case|case
name|R_ARM_PREL31
case|:
name|value
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|rel
operator|->
name|r_offset
operator|)
expr_stmt|;
name|value
operator|+=
name|signed_addend
expr_stmt|;
if|if
condition|(
operator|!
name|h
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefweak
condition|)
block|{
comment|/* Check for overflow */
if|if
condition|(
operator|(
name|value
operator|^
operator|(
name|value
operator|>>
literal|1
operator|)
operator|)
operator|&
operator|(
literal|1
operator|<<
literal|30
operator|)
condition|)
return|return
name|bfd_reloc_overflow
return|;
block|}
name|value
operator|&=
literal|0x7fffffff
expr_stmt|;
name|value
operator||=
operator|(
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
argument_list|)
operator|&
literal|0x80000000
operator|)
expr_stmt|;
if|if
condition|(
name|sym_flags
operator|==
name|STT_ARM_TFUNC
condition|)
name|value
operator||=
literal|1
expr_stmt|;
break|break;
block|}
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|value
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_ARM_ABS8
case|:
name|value
operator|+=
name|addend
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|value
operator|>
literal|0x7f
operator|||
operator|(
name|long
operator|)
name|value
operator|<
operator|-
literal|0x80
condition|)
return|return
name|bfd_reloc_overflow
return|;
name|bfd_put_8
argument_list|(
name|input_bfd
argument_list|,
name|value
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_ARM_ABS16
case|:
name|value
operator|+=
name|addend
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|value
operator|>
literal|0x7fff
operator|||
operator|(
name|long
operator|)
name|value
operator|<
operator|-
literal|0x8000
condition|)
return|return
name|bfd_reloc_overflow
return|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|value
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_ARM_THM_ABS5
case|:
comment|/* Support ldr and str instructions for the thumb.  */
if|if
condition|(
name|globals
operator|->
name|use_rel
condition|)
block|{
comment|/* Need to refetch addend.  */
name|addend
operator|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
argument_list|)
operator|&
name|howto
operator|->
name|src_mask
expr_stmt|;
comment|/* ??? Need to determine shift amount from operand size.  */
name|addend
operator|>>=
name|howto
operator|->
name|rightshift
expr_stmt|;
block|}
name|value
operator|+=
name|addend
expr_stmt|;
comment|/* ??? Isn't value unsigned?  */
if|if
condition|(
operator|(
name|long
operator|)
name|value
operator|>
literal|0x1f
operator|||
operator|(
name|long
operator|)
name|value
operator|<
operator|-
literal|0x10
condition|)
return|return
name|bfd_reloc_overflow
return|;
comment|/* ??? Value needs to be properly shifted into place first.  */
name|value
operator||=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
argument_list|)
operator|&
literal|0xf83f
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|value
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_ARM_THM_ALU_PREL_11_0
case|:
comment|/* Corresponds to: addw.w reg, pc, #offset (and similarly for subw).  */
block|{
name|bfd_vma
name|insn
decl_stmt|;
name|bfd_signed_vma
name|relocation
decl_stmt|;
name|insn
operator|=
operator|(
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
argument_list|)
operator|<<
literal|16
operator|)
operator||
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|globals
operator|->
name|use_rel
condition|)
block|{
name|signed_addend
operator|=
operator|(
name|insn
operator|&
literal|0xff
operator|)
operator||
operator|(
operator|(
name|insn
operator|&
literal|0x7000
operator|)
operator|>>
literal|4
operator|)
operator||
operator|(
operator|(
name|insn
operator|&
operator|(
literal|1
operator|<<
literal|26
operator|)
operator|)
operator|>>
literal|15
operator|)
expr_stmt|;
if|if
condition|(
name|insn
operator|&
literal|0xf00000
condition|)
name|signed_addend
operator|=
operator|-
name|signed_addend
expr_stmt|;
block|}
name|relocation
operator|=
name|value
operator|+
name|signed_addend
expr_stmt|;
name|relocation
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|rel
operator|->
name|r_offset
operator|)
expr_stmt|;
name|value
operator|=
name|llabs
argument_list|(
name|relocation
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|>=
literal|0x1000
condition|)
return|return
name|bfd_reloc_overflow
return|;
name|insn
operator|=
operator|(
name|insn
operator|&
literal|0xfb0f8f00
operator|)
operator||
operator|(
name|value
operator|&
literal|0xff
operator|)
operator||
operator|(
operator|(
name|value
operator|&
literal|0x700
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
name|value
operator|&
literal|0x800
operator|)
operator|<<
literal|15
operator|)
expr_stmt|;
if|if
condition|(
name|relocation
operator|<
literal|0
condition|)
name|insn
operator||=
literal|0xa00000
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|insn
operator|>>
literal|16
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|insn
operator|&
literal|0xffff
argument_list|,
name|hit_data
operator|+
literal|2
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
case|case
name|R_ARM_THM_PC12
case|:
comment|/* Corresponds to: ldr.w reg, [pc, #offset].  */
block|{
name|bfd_vma
name|insn
decl_stmt|;
name|bfd_signed_vma
name|relocation
decl_stmt|;
name|insn
operator|=
operator|(
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
argument_list|)
operator|<<
literal|16
operator|)
operator||
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|globals
operator|->
name|use_rel
condition|)
block|{
name|signed_addend
operator|=
name|insn
operator|&
literal|0xfff
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|insn
operator|&
operator|(
literal|1
operator|<<
literal|23
operator|)
operator|)
condition|)
name|signed_addend
operator|=
operator|-
name|signed_addend
expr_stmt|;
block|}
name|relocation
operator|=
name|value
operator|+
name|signed_addend
expr_stmt|;
name|relocation
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|rel
operator|->
name|r_offset
operator|)
expr_stmt|;
name|value
operator|=
name|llabs
argument_list|(
name|relocation
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|>=
literal|0x1000
condition|)
return|return
name|bfd_reloc_overflow
return|;
name|insn
operator|=
operator|(
name|insn
operator|&
literal|0xff7ff000
operator|)
operator||
name|value
expr_stmt|;
if|if
condition|(
name|relocation
operator|>=
literal|0
condition|)
name|insn
operator||=
operator|(
literal|1
operator|<<
literal|23
operator|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|insn
operator|>>
literal|16
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|insn
operator|&
literal|0xffff
argument_list|,
name|hit_data
operator|+
literal|2
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
case|case
name|R_ARM_THM_XPC22
case|:
case|case
name|R_ARM_THM_CALL
case|:
comment|/* Thumb BL (branch long instruction).  */
block|{
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_vma
name|reloc_sign
decl_stmt|;
name|bfd_boolean
name|overflow
init|=
name|FALSE
decl_stmt|;
name|bfd_vma
name|upper_insn
init|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
argument_list|)
decl_stmt|;
name|bfd_vma
name|lower_insn
init|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
operator|+
literal|2
argument_list|)
decl_stmt|;
name|bfd_signed_vma
name|reloc_signed_max
decl_stmt|;
name|bfd_signed_vma
name|reloc_signed_min
decl_stmt|;
name|bfd_vma
name|check
decl_stmt|;
name|bfd_signed_vma
name|signed_check
decl_stmt|;
name|int
name|bitsize
decl_stmt|;
name|int
name|thumb2
init|=
name|using_thumb2
argument_list|(
name|globals
argument_list|)
decl_stmt|;
comment|/* A branch to an undefined weak symbol is turned into a jump to 	   the next instruction.  */
if|if
condition|(
name|h
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
block|{
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
literal|0xe000
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
literal|0xbf00
argument_list|,
name|hit_data
operator|+
literal|2
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
comment|/* Fetch the addend.  We use the Thumb-2 encoding (backwards compatible            with Thumb-1) involving the J1 and J2 bits.  */
if|if
condition|(
name|globals
operator|->
name|use_rel
condition|)
block|{
name|bfd_vma
name|s
init|=
operator|(
name|upper_insn
operator|&
operator|(
literal|1
operator|<<
literal|10
operator|)
operator|)
operator|>>
literal|10
decl_stmt|;
name|bfd_vma
name|upper
init|=
name|upper_insn
operator|&
literal|0x3ff
decl_stmt|;
name|bfd_vma
name|lower
init|=
name|lower_insn
operator|&
literal|0x7ff
decl_stmt|;
name|bfd_vma
name|j1
init|=
operator|(
name|lower_insn
operator|&
operator|(
literal|1
operator|<<
literal|13
operator|)
operator|)
operator|>>
literal|13
decl_stmt|;
name|bfd_vma
name|j2
init|=
operator|(
name|lower_insn
operator|&
operator|(
literal|1
operator|<<
literal|11
operator|)
operator|)
operator|>>
literal|11
decl_stmt|;
name|bfd_vma
name|i1
init|=
name|j1
operator|^
name|s
condition|?
literal|0
else|:
literal|1
decl_stmt|;
name|bfd_vma
name|i2
init|=
name|j2
operator|^
name|s
condition|?
literal|0
else|:
literal|1
decl_stmt|;
name|addend
operator|=
operator|(
name|i1
operator|<<
literal|23
operator|)
operator||
operator|(
name|i2
operator|<<
literal|22
operator|)
operator||
operator|(
name|upper
operator|<<
literal|12
operator|)
operator||
operator|(
name|lower
operator|<<
literal|1
operator|)
expr_stmt|;
comment|/* Sign extend.  */
name|addend
operator|=
operator|(
name|addend
operator||
operator|(
operator|(
name|s
condition|?
literal|0
else|:
literal|1
operator|)
operator|<<
literal|24
operator|)
operator|)
operator|-
operator|(
literal|1
operator|<<
literal|24
operator|)
expr_stmt|;
name|signed_addend
operator|=
name|addend
expr_stmt|;
block|}
if|if
condition|(
name|r_type
operator|==
name|R_ARM_THM_XPC22
condition|)
block|{
comment|/* Check for Thumb to Thumb call.  */
comment|/* FIXME: Should we translate the instruction into a BL 	       instruction instead ?  */
if|if
condition|(
name|sym_flags
operator|==
name|STT_ARM_TFUNC
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: Warning: Thumb BLX instruction targets thumb function '%s'."
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|h
condition|?
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
else|:
literal|"(local)"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If it is not a call to Thumb, assume call to Arm. 	       If it is a call relative to a section name, then it is not a 	       function call at all, but rather a long jump.  Calls through 	       the PLT do not require stubs.  */
if|if
condition|(
name|sym_flags
operator|!=
name|STT_ARM_TFUNC
operator|&&
name|sym_flags
operator|!=
name|STT_SECTION
operator|&&
operator|(
name|h
operator|==
name|NULL
operator|||
name|splt
operator|==
name|NULL
operator|||
name|h
operator|->
name|plt
operator|.
name|offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|globals
operator|->
name|use_blx
condition|)
block|{
comment|/* Convert BL to BLX.  */
name|lower_insn
operator|=
operator|(
name|lower_insn
operator|&
operator|~
literal|0x1000
operator|)
operator||
literal|0x0800
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|elf32_thumb_to_arm_stub
argument_list|(
name|info
argument_list|,
name|sym_name
argument_list|,
name|input_bfd
argument_list|,
name|output_bfd
argument_list|,
name|input_section
argument_list|,
name|hit_data
argument_list|,
name|sym_sec
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|signed_addend
argument_list|,
name|value
argument_list|,
name|error_message
argument_list|)
condition|)
return|return
name|bfd_reloc_ok
return|;
else|else
return|return
name|bfd_reloc_dangerous
return|;
block|}
elseif|else
if|if
condition|(
name|sym_flags
operator|==
name|STT_ARM_TFUNC
operator|&&
name|globals
operator|->
name|use_blx
condition|)
block|{
comment|/* Make sure this is a BL.  */
name|lower_insn
operator||=
literal|0x1800
expr_stmt|;
block|}
block|}
comment|/* Handle calls via the PLT.  */
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|splt
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|plt
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
name|value
operator|=
operator|(
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|splt
operator|->
name|output_offset
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|)
expr_stmt|;
if|if
condition|(
name|globals
operator|->
name|use_blx
condition|)
block|{
comment|/* If the Thumb BLX instruction is available, convert the 		   BL to a BLX instruction to call the ARM-mode PLT entry.  */
name|lower_insn
operator|=
operator|(
name|lower_insn
operator|&
operator|~
literal|0x1000
operator|)
operator||
literal|0x0800
expr_stmt|;
block|}
else|else
comment|/* Target the Thumb stub before the ARM PLT entry.  */
name|value
operator|-=
name|PLT_THUMB_STUB_SIZE
expr_stmt|;
operator|*
name|unresolved_reloc_p
operator|=
name|FALSE
expr_stmt|;
block|}
name|relocation
operator|=
name|value
operator|+
name|signed_addend
expr_stmt|;
name|relocation
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|rel
operator|->
name|r_offset
operator|)
expr_stmt|;
name|check
operator|=
name|relocation
operator|>>
name|howto
operator|->
name|rightshift
expr_stmt|;
comment|/* If this is a signed value, the rightshift just dropped 	   leading 1 bits (assuming twos complement).  */
if|if
condition|(
operator|(
name|bfd_signed_vma
operator|)
name|relocation
operator|>=
literal|0
condition|)
name|signed_check
operator|=
name|check
expr_stmt|;
else|else
name|signed_check
operator|=
name|check
operator||
operator|~
operator|(
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|>>
name|howto
operator|->
name|rightshift
operator|)
expr_stmt|;
comment|/* Calculate the permissable maximum and minimum values for 	   this relocation according to whether we're relocating for 	   Thumb-2 or not.  */
name|bitsize
operator|=
name|howto
operator|->
name|bitsize
expr_stmt|;
if|if
condition|(
operator|!
name|thumb2
condition|)
name|bitsize
operator|-=
literal|2
expr_stmt|;
name|reloc_signed_max
operator|=
operator|(
operator|(
literal|1
operator|<<
operator|(
name|bitsize
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
operator|>>
name|howto
operator|->
name|rightshift
expr_stmt|;
name|reloc_signed_min
operator|=
operator|~
name|reloc_signed_max
expr_stmt|;
comment|/* Assumes two's complement.  */
if|if
condition|(
name|signed_check
operator|>
name|reloc_signed_max
operator|||
name|signed_check
operator|<
name|reloc_signed_min
condition|)
name|overflow
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|(
name|lower_insn
operator|&
literal|0x1800
operator|)
operator|==
literal|0x0800
condition|)
comment|/* For a BLX instruction, make sure that the relocation is rounded up 	     to a word boundary.  This follows the semantics of the instruction 	     which specifies that bit 1 of the target address will come from bit 	     1 of the base address.  */
name|relocation
operator|=
operator|(
name|relocation
operator|+
literal|2
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
comment|/* Put RELOCATION back into the insn.  Assumes two's complement. 	   We use the Thumb-2 encoding, which is safe even if dealing with 	   a Thumb-1 instruction by virtue of our overflow check above.  */
name|reloc_sign
operator|=
operator|(
name|signed_check
operator|<
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|upper_insn
operator|=
operator|(
name|upper_insn
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
literal|0x7ff
operator|)
operator||
operator|(
operator|(
name|relocation
operator|>>
literal|12
operator|)
operator|&
literal|0x3ff
operator|)
operator||
operator|(
name|reloc_sign
operator|<<
literal|10
operator|)
expr_stmt|;
name|lower_insn
operator|=
operator|(
name|lower_insn
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
literal|0x2fff
operator|)
operator||
operator|(
operator|(
operator|(
operator|!
operator|(
operator|(
name|relocation
operator|>>
literal|23
operator|)
operator|&
literal|1
operator|)
operator|)
operator|^
name|reloc_sign
operator|)
operator|<<
literal|13
operator|)
operator||
operator|(
operator|(
operator|(
operator|!
operator|(
operator|(
name|relocation
operator|>>
literal|22
operator|)
operator|&
literal|1
operator|)
operator|)
operator|^
name|reloc_sign
operator|)
operator|<<
literal|11
operator|)
operator||
operator|(
operator|(
name|relocation
operator|>>
literal|1
operator|)
operator|&
literal|0x7ff
operator|)
expr_stmt|;
comment|/* Put the relocated value back in the object file:  */
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|upper_insn
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|lower_insn
argument_list|,
name|hit_data
operator|+
literal|2
argument_list|)
expr_stmt|;
return|return
operator|(
name|overflow
condition|?
name|bfd_reloc_overflow
else|:
name|bfd_reloc_ok
operator|)
return|;
block|}
break|break;
case|case
name|R_ARM_THM_JUMP24
case|:
comment|/* Thumb32 unconditional branch instruction.  */
block|{
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_boolean
name|overflow
init|=
name|FALSE
decl_stmt|;
name|bfd_vma
name|upper_insn
init|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
argument_list|)
decl_stmt|;
name|bfd_vma
name|lower_insn
init|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
operator|+
literal|2
argument_list|)
decl_stmt|;
name|bfd_signed_vma
name|reloc_signed_max
init|=
operator|(
operator|(
literal|1
operator|<<
operator|(
name|howto
operator|->
name|bitsize
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
operator|>>
name|howto
operator|->
name|rightshift
decl_stmt|;
name|bfd_signed_vma
name|reloc_signed_min
init|=
operator|~
name|reloc_signed_max
decl_stmt|;
name|bfd_vma
name|check
decl_stmt|;
name|bfd_signed_vma
name|signed_check
decl_stmt|;
comment|/* Need to refetch the addend, reconstruct the top three bits, and glue the 	   two pieces together.  */
if|if
condition|(
name|globals
operator|->
name|use_rel
condition|)
block|{
name|bfd_vma
name|S
init|=
operator|(
name|upper_insn
operator|&
literal|0x0400
operator|)
operator|>>
literal|10
decl_stmt|;
name|bfd_vma
name|hi
init|=
operator|(
name|upper_insn
operator|&
literal|0x03ff
operator|)
decl_stmt|;
name|bfd_vma
name|I1
init|=
operator|(
name|lower_insn
operator|&
literal|0x2000
operator|)
operator|>>
literal|13
decl_stmt|;
name|bfd_vma
name|I2
init|=
operator|(
name|lower_insn
operator|&
literal|0x0800
operator|)
operator|>>
literal|11
decl_stmt|;
name|bfd_vma
name|lo
init|=
operator|(
name|lower_insn
operator|&
literal|0x07ff
operator|)
decl_stmt|;
name|I1
operator|=
operator|!
operator|(
name|I1
operator|^
name|S
operator|)
expr_stmt|;
name|I2
operator|=
operator|!
operator|(
name|I2
operator|^
name|S
operator|)
expr_stmt|;
name|S
operator|=
operator|!
name|S
expr_stmt|;
name|signed_addend
operator|=
operator|(
name|S
operator|<<
literal|24
operator|)
operator||
operator|(
name|I1
operator|<<
literal|23
operator|)
operator||
operator|(
name|I2
operator|<<
literal|22
operator|)
operator||
operator|(
name|hi
operator|<<
literal|12
operator|)
operator||
operator|(
name|lo
operator|<<
literal|1
operator|)
expr_stmt|;
name|signed_addend
operator|-=
operator|(
literal|1
operator|<<
literal|24
operator|)
expr_stmt|;
comment|/* Sign extend.  */
block|}
comment|/* ??? Should handle interworking?  GCC might someday try to 	   use this for tail calls.  */
name|relocation
operator|=
name|value
operator|+
name|signed_addend
expr_stmt|;
name|relocation
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|rel
operator|->
name|r_offset
operator|)
expr_stmt|;
name|check
operator|=
name|relocation
operator|>>
name|howto
operator|->
name|rightshift
expr_stmt|;
comment|/* If this is a signed value, the rightshift just dropped 	   leading 1 bits (assuming twos complement).  */
if|if
condition|(
operator|(
name|bfd_signed_vma
operator|)
name|relocation
operator|>=
literal|0
condition|)
name|signed_check
operator|=
name|check
expr_stmt|;
else|else
name|signed_check
operator|=
name|check
operator||
operator|~
operator|(
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|>>
name|howto
operator|->
name|rightshift
operator|)
expr_stmt|;
comment|/* Assumes two's complement.  */
if|if
condition|(
name|signed_check
operator|>
name|reloc_signed_max
operator|||
name|signed_check
operator|<
name|reloc_signed_min
condition|)
name|overflow
operator|=
name|TRUE
expr_stmt|;
comment|/* Put RELOCATION back into the insn.  */
block|{
name|bfd_vma
name|S
init|=
operator|(
name|relocation
operator|&
literal|0x01000000
operator|)
operator|>>
literal|24
decl_stmt|;
name|bfd_vma
name|I1
init|=
operator|(
name|relocation
operator|&
literal|0x00800000
operator|)
operator|>>
literal|23
decl_stmt|;
name|bfd_vma
name|I2
init|=
operator|(
name|relocation
operator|&
literal|0x00400000
operator|)
operator|>>
literal|22
decl_stmt|;
name|bfd_vma
name|hi
init|=
operator|(
name|relocation
operator|&
literal|0x003ff000
operator|)
operator|>>
literal|12
decl_stmt|;
name|bfd_vma
name|lo
init|=
operator|(
name|relocation
operator|&
literal|0x00000ffe
operator|)
operator|>>
literal|1
decl_stmt|;
name|I1
operator|=
operator|!
operator|(
name|I1
operator|^
name|S
operator|)
expr_stmt|;
name|I2
operator|=
operator|!
operator|(
name|I2
operator|^
name|S
operator|)
expr_stmt|;
name|upper_insn
operator|=
operator|(
name|upper_insn
operator|&
operator|(
name|bfd_vma
operator|)
literal|0xf800
operator|)
operator||
operator|(
name|S
operator|<<
literal|10
operator|)
operator||
name|hi
expr_stmt|;
name|lower_insn
operator|=
operator|(
name|lower_insn
operator|&
operator|(
name|bfd_vma
operator|)
literal|0xd000
operator|)
operator||
operator|(
name|I1
operator|<<
literal|13
operator|)
operator||
operator|(
name|I2
operator|<<
literal|11
operator|)
operator||
name|lo
expr_stmt|;
block|}
comment|/* Put the relocated value back in the object file:  */
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|upper_insn
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|lower_insn
argument_list|,
name|hit_data
operator|+
literal|2
argument_list|)
expr_stmt|;
return|return
operator|(
name|overflow
condition|?
name|bfd_reloc_overflow
else|:
name|bfd_reloc_ok
operator|)
return|;
block|}
case|case
name|R_ARM_THM_JUMP19
case|:
comment|/* Thumb32 conditional branch instruction.  */
block|{
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_boolean
name|overflow
init|=
name|FALSE
decl_stmt|;
name|bfd_vma
name|upper_insn
init|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
argument_list|)
decl_stmt|;
name|bfd_vma
name|lower_insn
init|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
operator|+
literal|2
argument_list|)
decl_stmt|;
name|bfd_signed_vma
name|reloc_signed_max
init|=
literal|0xffffe
decl_stmt|;
name|bfd_signed_vma
name|reloc_signed_min
init|=
operator|-
literal|0x100000
decl_stmt|;
name|bfd_signed_vma
name|signed_check
decl_stmt|;
comment|/* Need to refetch the addend, reconstruct the top three bits, 	   and squish the two 11 bit pieces together.  */
if|if
condition|(
name|globals
operator|->
name|use_rel
condition|)
block|{
name|bfd_vma
name|S
init|=
operator|(
name|upper_insn
operator|&
literal|0x0400
operator|)
operator|>>
literal|10
decl_stmt|;
name|bfd_vma
name|upper
init|=
operator|(
name|upper_insn
operator|&
literal|0x003f
operator|)
decl_stmt|;
name|bfd_vma
name|J1
init|=
operator|(
name|lower_insn
operator|&
literal|0x2000
operator|)
operator|>>
literal|13
decl_stmt|;
name|bfd_vma
name|J2
init|=
operator|(
name|lower_insn
operator|&
literal|0x0800
operator|)
operator|>>
literal|11
decl_stmt|;
name|bfd_vma
name|lower
init|=
operator|(
name|lower_insn
operator|&
literal|0x07ff
operator|)
decl_stmt|;
name|upper
operator||=
name|J1
operator|<<
literal|6
expr_stmt|;
name|upper
operator||=
name|J2
operator|<<
literal|7
expr_stmt|;
name|upper
operator||=
operator|(
operator|!
name|S
operator|)
operator|<<
literal|8
expr_stmt|;
name|upper
operator|-=
literal|0x0100
expr_stmt|;
comment|/* Sign extend.  */
name|addend
operator|=
operator|(
name|upper
operator|<<
literal|12
operator|)
operator||
operator|(
name|lower
operator|<<
literal|1
operator|)
expr_stmt|;
name|signed_addend
operator|=
name|addend
expr_stmt|;
block|}
comment|/* ??? Should handle interworking?  GCC might someday try to 	   use this for tail calls.  */
name|relocation
operator|=
name|value
operator|+
name|signed_addend
expr_stmt|;
name|relocation
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|rel
operator|->
name|r_offset
operator|)
expr_stmt|;
name|signed_check
operator|=
operator|(
name|bfd_signed_vma
operator|)
name|relocation
expr_stmt|;
if|if
condition|(
name|signed_check
operator|>
name|reloc_signed_max
operator|||
name|signed_check
operator|<
name|reloc_signed_min
condition|)
name|overflow
operator|=
name|TRUE
expr_stmt|;
comment|/* Put RELOCATION back into the insn.  */
block|{
name|bfd_vma
name|S
init|=
operator|(
name|relocation
operator|&
literal|0x00100000
operator|)
operator|>>
literal|20
decl_stmt|;
name|bfd_vma
name|J2
init|=
operator|(
name|relocation
operator|&
literal|0x00080000
operator|)
operator|>>
literal|19
decl_stmt|;
name|bfd_vma
name|J1
init|=
operator|(
name|relocation
operator|&
literal|0x00040000
operator|)
operator|>>
literal|18
decl_stmt|;
name|bfd_vma
name|hi
init|=
operator|(
name|relocation
operator|&
literal|0x0003f000
operator|)
operator|>>
literal|12
decl_stmt|;
name|bfd_vma
name|lo
init|=
operator|(
name|relocation
operator|&
literal|0x00000ffe
operator|)
operator|>>
literal|1
decl_stmt|;
name|upper_insn
operator|=
operator|(
name|upper_insn
operator|&
literal|0xfbc0
operator|)
operator||
operator|(
name|S
operator|<<
literal|10
operator|)
operator||
name|hi
expr_stmt|;
name|lower_insn
operator|=
operator|(
name|lower_insn
operator|&
literal|0xd000
operator|)
operator||
operator|(
name|J1
operator|<<
literal|13
operator|)
operator||
operator|(
name|J2
operator|<<
literal|11
operator|)
operator||
name|lo
expr_stmt|;
block|}
comment|/* Put the relocated value back in the object file:  */
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|upper_insn
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|lower_insn
argument_list|,
name|hit_data
operator|+
literal|2
argument_list|)
expr_stmt|;
return|return
operator|(
name|overflow
condition|?
name|bfd_reloc_overflow
else|:
name|bfd_reloc_ok
operator|)
return|;
block|}
case|case
name|R_ARM_THM_JUMP11
case|:
case|case
name|R_ARM_THM_JUMP8
case|:
case|case
name|R_ARM_THM_JUMP6
case|:
comment|/* Thumb B (branch) instruction).  */
block|{
name|bfd_signed_vma
name|relocation
decl_stmt|;
name|bfd_signed_vma
name|reloc_signed_max
init|=
operator|(
literal|1
operator|<<
operator|(
name|howto
operator|->
name|bitsize
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
decl_stmt|;
name|bfd_signed_vma
name|reloc_signed_min
init|=
operator|~
name|reloc_signed_max
decl_stmt|;
name|bfd_signed_vma
name|signed_check
decl_stmt|;
comment|/* CZB cannot jump backward.  */
if|if
condition|(
name|r_type
operator|==
name|R_ARM_THM_JUMP6
condition|)
name|reloc_signed_min
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|globals
operator|->
name|use_rel
condition|)
block|{
comment|/* Need to refetch addend.  */
name|addend
operator|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
argument_list|)
operator|&
name|howto
operator|->
name|src_mask
expr_stmt|;
if|if
condition|(
name|addend
operator|&
operator|(
operator|(
name|howto
operator|->
name|src_mask
operator|+
literal|1
operator|)
operator|>>
literal|1
operator|)
condition|)
block|{
name|signed_addend
operator|=
operator|-
literal|1
expr_stmt|;
name|signed_addend
operator|&=
operator|~
name|howto
operator|->
name|src_mask
expr_stmt|;
name|signed_addend
operator||=
name|addend
expr_stmt|;
block|}
else|else
name|signed_addend
operator|=
name|addend
expr_stmt|;
comment|/* The value in the insn has been right shifted.  We need to 	       undo this, so that we can perform the address calculation 	       in terms of bytes.  */
name|signed_addend
operator|<<=
name|howto
operator|->
name|rightshift
expr_stmt|;
block|}
name|relocation
operator|=
name|value
operator|+
name|signed_addend
expr_stmt|;
name|relocation
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|rel
operator|->
name|r_offset
operator|)
expr_stmt|;
name|relocation
operator|>>=
name|howto
operator|->
name|rightshift
expr_stmt|;
name|signed_check
operator|=
name|relocation
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_ARM_THM_JUMP6
condition|)
name|relocation
operator|=
operator|(
operator|(
name|relocation
operator|&
literal|0x0020
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
name|relocation
operator|&
literal|0x001f
operator|)
operator|<<
literal|3
operator|)
expr_stmt|;
else|else
name|relocation
operator|&=
name|howto
operator|->
name|dst_mask
expr_stmt|;
name|relocation
operator||=
operator|(
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
argument_list|)
operator|&
operator|(
operator|~
name|howto
operator|->
name|dst_mask
operator|)
operator|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|relocation
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
comment|/* Assumes two's complement.  */
if|if
condition|(
name|signed_check
operator|>
name|reloc_signed_max
operator|||
name|signed_check
operator|<
name|reloc_signed_min
condition|)
return|return
name|bfd_reloc_overflow
return|;
return|return
name|bfd_reloc_ok
return|;
block|}
case|case
name|R_ARM_ALU_PCREL7_0
case|:
case|case
name|R_ARM_ALU_PCREL15_8
case|:
case|case
name|R_ARM_ALU_PCREL23_15
case|:
block|{
name|bfd_vma
name|insn
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|globals
operator|->
name|use_rel
condition|)
block|{
comment|/* Extract the addend.  */
name|addend
operator|=
operator|(
name|insn
operator|&
literal|0xff
operator|)
operator|<<
operator|(
operator|(
name|insn
operator|&
literal|0xf00
operator|)
operator|>>
literal|7
operator|)
expr_stmt|;
name|signed_addend
operator|=
name|addend
expr_stmt|;
block|}
name|relocation
operator|=
name|value
operator|+
name|signed_addend
expr_stmt|;
name|relocation
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|rel
operator|->
name|r_offset
operator|)
expr_stmt|;
name|insn
operator|=
operator|(
name|insn
operator|&
operator|~
literal|0xfff
operator|)
operator||
operator|(
operator|(
name|howto
operator|->
name|bitpos
operator|<<
literal|7
operator|)
operator|&
literal|0xf00
operator|)
operator||
operator|(
operator|(
name|relocation
operator|>>
name|howto
operator|->
name|bitpos
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|value
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
block|}
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_ARM_GNU_VTINHERIT
case|:
case|case
name|R_ARM_GNU_VTENTRY
case|:
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_ARM_GOTOFF32
case|:
comment|/* Relocation is relative to the start of the          global offset table.  */
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sgot
operator|==
name|NULL
condition|)
return|return
name|bfd_reloc_notsupported
return|;
comment|/* If we are addressing a Thumb function, we need to adjust the 	 address by one, so that attempts to call the function pointer will 	 correctly interpret it as Thumb code.  */
if|if
condition|(
name|sym_flags
operator|==
name|STT_ARM_TFUNC
condition|)
name|value
operator|+=
literal|1
expr_stmt|;
comment|/* Note that sgot->output_offset is not involved in this          calculation.  We always want the start of .got.  If we          define _GLOBAL_OFFSET_TABLE in a different way, as is          permitted by the ABI, we might have to change this          calculation.  */
name|value
operator|-=
name|sgot
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
return|return
name|_bfd_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|value
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
return|;
case|case
name|R_ARM_GOTPC
case|:
comment|/* Use global offset table as symbol value.  */
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sgot
operator|==
name|NULL
condition|)
return|return
name|bfd_reloc_notsupported
return|;
operator|*
name|unresolved_reloc_p
operator|=
name|FALSE
expr_stmt|;
name|value
operator|=
name|sgot
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
return|return
name|_bfd_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|value
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
return|;
case|case
name|R_ARM_GOT32
case|:
case|case
name|R_ARM_GOT_PREL
case|:
comment|/* Relocation is to the entry for this symbol in the          global offset table.  */
if|if
condition|(
name|sgot
operator|==
name|NULL
condition|)
return|return
name|bfd_reloc_notsupported
return|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|bfd_vma
name|off
decl_stmt|;
name|bfd_boolean
name|dyn
decl_stmt|;
name|off
operator|=
name|h
operator|->
name|got
operator|.
name|offset
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|off
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|dyn
operator|=
name|globals
operator|->
name|root
operator|.
name|dynamic_sections_created
expr_stmt|;
if|if
condition|(
operator|!
name|WILL_CALL_FINISH_DYNAMIC_SYMBOL
argument_list|(
name|dyn
argument_list|,
name|info
operator|->
name|shared
argument_list|,
name|h
argument_list|)
operator|||
operator|(
name|info
operator|->
name|shared
operator|&&
name|SYMBOL_REFERENCES_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
operator|)
operator|||
operator|(
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|)
condition|)
block|{
comment|/* This is actually a static link, or it is a -Bsymbolic link 		 and the symbol is defined locally.  We must initialize this 		 entry in the global offset table.  Since the offset must 		 always be a multiple of 4, we use the least significant bit 		 to record whether we have initialized it already.  		 When doing a dynamic link, we create a .rel(a).got relocation 		 entry to initialize the value.  This is done in the 		 finish_dynamic_symbol routine.  */
if|if
condition|(
operator|(
name|off
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|off
operator|&=
operator|~
literal|1
expr_stmt|;
else|else
block|{
comment|/* If we are addressing a Thumb function, we need to 		     adjust the address by one, so that attempts to 		     call the function pointer will correctly 		     interpret it as Thumb code.  */
if|if
condition|(
name|sym_flags
operator|==
name|STT_ARM_TFUNC
condition|)
name|value
operator||=
literal|1
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|value
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|off
argument_list|)
expr_stmt|;
name|h
operator|->
name|got
operator|.
name|offset
operator||=
literal|1
expr_stmt|;
block|}
block|}
else|else
operator|*
name|unresolved_reloc_p
operator|=
name|FALSE
expr_stmt|;
name|value
operator|=
name|sgot
operator|->
name|output_offset
operator|+
name|off
expr_stmt|;
block|}
else|else
block|{
name|bfd_vma
name|off
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|local_got_offsets
operator|!=
name|NULL
operator|&&
name|local_got_offsets
index|[
name|r_symndx
index|]
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|off
operator|=
name|local_got_offsets
index|[
name|r_symndx
index|]
expr_stmt|;
comment|/* The offset must always be a multiple of 4.  We use the 	     least significant bit to record whether we have already 	     generated the necessary reloc.  */
if|if
condition|(
operator|(
name|off
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|off
operator|&=
operator|~
literal|1
expr_stmt|;
else|else
block|{
comment|/* If we are addressing a Thumb function, we need to 		 adjust the address by one, so that attempts to 		 call the function pointer will correctly 		 interpret it as Thumb code.  */
if|if
condition|(
name|sym_flags
operator|==
name|STT_ARM_TFUNC
condition|)
name|value
operator||=
literal|1
expr_stmt|;
if|if
condition|(
name|globals
operator|->
name|use_rel
condition|)
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|value
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|off
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
name|asection
modifier|*
name|srelgot
decl_stmt|;
name|Elf_Internal_Rela
name|outrel
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|srelgot
operator|=
operator|(
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|RELOC_SECTION
argument_list|(
name|globals
argument_list|,
literal|".got"
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|srelgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
name|addend
operator|+
name|value
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|=
operator|(
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
name|off
operator|)
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_ARM_RELATIVE
argument_list|)
expr_stmt|;
name|loc
operator|=
name|srelgot
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
name|srelgot
operator|->
name|reloc_count
operator|++
operator|*
name|RELOC_SIZE
argument_list|(
name|globals
argument_list|)
expr_stmt|;
name|SWAP_RELOC_OUT
argument_list|(
name|globals
argument_list|)
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
name|local_got_offsets
index|[
name|r_symndx
index|]
operator||=
literal|1
expr_stmt|;
block|}
name|value
operator|=
name|sgot
operator|->
name|output_offset
operator|+
name|off
expr_stmt|;
block|}
if|if
condition|(
name|r_type
operator|!=
name|R_ARM_GOT32
condition|)
name|value
operator|+=
name|sgot
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
return|return
name|_bfd_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|value
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
return|;
case|case
name|R_ARM_TLS_LDO32
case|:
name|value
operator|=
name|value
operator|-
name|dtpoff_base
argument_list|(
name|info
argument_list|)
expr_stmt|;
return|return
name|_bfd_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|value
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
return|;
case|case
name|R_ARM_TLS_LDM32
case|:
block|{
name|bfd_vma
name|off
decl_stmt|;
if|if
condition|(
name|globals
operator|->
name|sgot
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|off
operator|=
name|globals
operator|->
name|tls_ldm_got
operator|.
name|offset
expr_stmt|;
if|if
condition|(
operator|(
name|off
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|off
operator|&=
operator|~
literal|1
expr_stmt|;
else|else
block|{
comment|/* If we don't know the module number, create a relocation 	       for it.  */
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
name|Elf_Internal_Rela
name|outrel
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
if|if
condition|(
name|globals
operator|->
name|srelgot
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|=
operator|(
name|globals
operator|->
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|globals
operator|->
name|sgot
operator|->
name|output_offset
operator|+
name|off
operator|)
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_ARM_TLS_DTPMOD32
argument_list|)
expr_stmt|;
if|if
condition|(
name|globals
operator|->
name|use_rel
condition|)
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|outrel
operator|.
name|r_addend
argument_list|,
name|globals
operator|->
name|sgot
operator|->
name|contents
operator|+
name|off
argument_list|)
expr_stmt|;
name|loc
operator|=
name|globals
operator|->
name|srelgot
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
name|globals
operator|->
name|srelgot
operator|->
name|reloc_count
operator|++
operator|*
name|RELOC_SIZE
argument_list|(
name|globals
argument_list|)
expr_stmt|;
name|SWAP_RELOC_OUT
argument_list|(
name|globals
argument_list|)
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
else|else
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
literal|1
argument_list|,
name|globals
operator|->
name|sgot
operator|->
name|contents
operator|+
name|off
argument_list|)
expr_stmt|;
name|globals
operator|->
name|tls_ldm_got
operator|.
name|offset
operator||=
literal|1
expr_stmt|;
block|}
name|value
operator|=
name|globals
operator|->
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|globals
operator|->
name|sgot
operator|->
name|output_offset
operator|+
name|off
operator|-
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|rel
operator|->
name|r_offset
operator|)
expr_stmt|;
return|return
name|_bfd_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|value
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
return|;
block|}
case|case
name|R_ARM_TLS_GD32
case|:
case|case
name|R_ARM_TLS_IE32
case|:
block|{
name|bfd_vma
name|off
decl_stmt|;
name|int
name|indx
decl_stmt|;
name|char
name|tls_type
decl_stmt|;
if|if
condition|(
name|globals
operator|->
name|sgot
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|indx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|bfd_boolean
name|dyn
decl_stmt|;
name|dyn
operator|=
name|globals
operator|->
name|root
operator|.
name|dynamic_sections_created
expr_stmt|;
if|if
condition|(
name|WILL_CALL_FINISH_DYNAMIC_SYMBOL
argument_list|(
name|dyn
argument_list|,
name|info
operator|->
name|shared
argument_list|,
name|h
argument_list|)
operator|&&
operator|(
operator|!
name|info
operator|->
name|shared
operator|||
operator|!
name|SYMBOL_REFERENCES_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
operator|)
condition|)
block|{
operator|*
name|unresolved_reloc_p
operator|=
name|FALSE
expr_stmt|;
name|indx
operator|=
name|h
operator|->
name|dynindx
expr_stmt|;
block|}
name|off
operator|=
name|h
operator|->
name|got
operator|.
name|offset
expr_stmt|;
name|tls_type
operator|=
operator|(
operator|(
expr|struct
name|elf32_arm_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|tls_type
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|local_got_offsets
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|off
operator|=
name|local_got_offsets
index|[
name|r_symndx
index|]
expr_stmt|;
name|tls_type
operator|=
name|elf32_arm_local_got_tls_type
argument_list|(
name|input_bfd
argument_list|)
index|[
name|r_symndx
index|]
expr_stmt|;
block|}
if|if
condition|(
name|tls_type
operator|==
name|GOT_UNKNOWN
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|off
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|off
operator|&=
operator|~
literal|1
expr_stmt|;
else|else
block|{
name|bfd_boolean
name|need_relocs
init|=
name|FALSE
decl_stmt|;
name|Elf_Internal_Rela
name|outrel
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
init|=
name|NULL
decl_stmt|;
name|int
name|cur_off
init|=
name|off
decl_stmt|;
comment|/* The GOT entries have not been initialized yet.  Do it 	       now, and emit any relocations.  If both an IE GOT and a 	       GD GOT are necessary, we emit the GD first.  */
if|if
condition|(
operator|(
name|info
operator|->
name|shared
operator|||
name|indx
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|h
operator|==
name|NULL
operator|||
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_DEFAULT
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefweak
operator|)
condition|)
block|{
name|need_relocs
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|globals
operator|->
name|srelgot
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|loc
operator|=
name|globals
operator|->
name|srelgot
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
name|globals
operator|->
name|srelgot
operator|->
name|reloc_count
operator|*
name|RELOC_SIZE
argument_list|(
name|globals
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tls_type
operator|&
name|GOT_TLS_GD
condition|)
block|{
if|if
condition|(
name|need_relocs
condition|)
block|{
name|outrel
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|=
operator|(
name|globals
operator|->
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|globals
operator|->
name|sgot
operator|->
name|output_offset
operator|+
name|cur_off
operator|)
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|indx
argument_list|,
name|R_ARM_TLS_DTPMOD32
argument_list|)
expr_stmt|;
if|if
condition|(
name|globals
operator|->
name|use_rel
condition|)
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|outrel
operator|.
name|r_addend
argument_list|,
name|globals
operator|->
name|sgot
operator|->
name|contents
operator|+
name|cur_off
argument_list|)
expr_stmt|;
name|SWAP_RELOC_OUT
argument_list|(
name|globals
argument_list|)
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|globals
operator|->
name|srelgot
operator|->
name|reloc_count
operator|++
expr_stmt|;
name|loc
operator|+=
name|RELOC_SIZE
argument_list|(
name|globals
argument_list|)
expr_stmt|;
if|if
condition|(
name|indx
operator|==
literal|0
condition|)
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|value
operator|-
name|dtpoff_base
argument_list|(
name|info
argument_list|)
argument_list|,
name|globals
operator|->
name|sgot
operator|->
name|contents
operator|+
name|cur_off
operator|+
literal|4
argument_list|)
expr_stmt|;
else|else
block|{
name|outrel
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|indx
argument_list|,
name|R_ARM_TLS_DTPOFF32
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|globals
operator|->
name|use_rel
condition|)
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|outrel
operator|.
name|r_addend
argument_list|,
name|globals
operator|->
name|sgot
operator|->
name|contents
operator|+
name|cur_off
operator|+
literal|4
argument_list|)
expr_stmt|;
name|SWAP_RELOC_OUT
argument_list|(
name|globals
argument_list|)
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|globals
operator|->
name|srelgot
operator|->
name|reloc_count
operator|++
expr_stmt|;
name|loc
operator|+=
name|RELOC_SIZE
argument_list|(
name|globals
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* If we are not emitting relocations for a 		       general dynamic reference, then we must be in a 		       static link or an executable link with the 		       symbol binding locally.  Mark it as belonging 		       to module 1, the executable.  */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
literal|1
argument_list|,
name|globals
operator|->
name|sgot
operator|->
name|contents
operator|+
name|cur_off
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|value
operator|-
name|dtpoff_base
argument_list|(
name|info
argument_list|)
argument_list|,
name|globals
operator|->
name|sgot
operator|->
name|contents
operator|+
name|cur_off
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
name|cur_off
operator|+=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|tls_type
operator|&
name|GOT_TLS_IE
condition|)
block|{
if|if
condition|(
name|need_relocs
condition|)
block|{
if|if
condition|(
name|indx
operator|==
literal|0
condition|)
name|outrel
operator|.
name|r_addend
operator|=
name|value
operator|-
name|dtpoff_base
argument_list|(
name|info
argument_list|)
expr_stmt|;
else|else
name|outrel
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|=
operator|(
name|globals
operator|->
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|globals
operator|->
name|sgot
operator|->
name|output_offset
operator|+
name|cur_off
operator|)
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|indx
argument_list|,
name|R_ARM_TLS_TPOFF32
argument_list|)
expr_stmt|;
if|if
condition|(
name|globals
operator|->
name|use_rel
condition|)
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|outrel
operator|.
name|r_addend
argument_list|,
name|globals
operator|->
name|sgot
operator|->
name|contents
operator|+
name|cur_off
argument_list|)
expr_stmt|;
name|SWAP_RELOC_OUT
argument_list|(
name|globals
argument_list|)
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|globals
operator|->
name|srelgot
operator|->
name|reloc_count
operator|++
expr_stmt|;
name|loc
operator|+=
name|RELOC_SIZE
argument_list|(
name|globals
argument_list|)
expr_stmt|;
block|}
else|else
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|tpoff
argument_list|(
name|info
argument_list|,
name|value
argument_list|)
argument_list|,
name|globals
operator|->
name|sgot
operator|->
name|contents
operator|+
name|cur_off
argument_list|)
expr_stmt|;
name|cur_off
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|h
operator|->
name|got
operator|.
name|offset
operator||=
literal|1
expr_stmt|;
else|else
name|local_got_offsets
index|[
name|r_symndx
index|]
operator||=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|tls_type
operator|&
name|GOT_TLS_GD
operator|)
operator|&&
name|r_type
operator|!=
name|R_ARM_TLS_GD32
condition|)
name|off
operator|+=
literal|8
expr_stmt|;
name|value
operator|=
name|globals
operator|->
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|globals
operator|->
name|sgot
operator|->
name|output_offset
operator|+
name|off
operator|-
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|rel
operator|->
name|r_offset
operator|)
expr_stmt|;
return|return
name|_bfd_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|value
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
return|;
block|}
case|case
name|R_ARM_TLS_LE32
case|:
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B(%A+0x%lx): R_ARM_TLS_LE32 relocation not permitted in shared object"
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
name|long
operator|)
name|rel
operator|->
name|r_offset
argument_list|,
name|howto
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
else|else
name|value
operator|=
name|tpoff
argument_list|(
name|info
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|_bfd_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|value
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
return|;
case|case
name|R_ARM_V4BX
case|:
if|if
condition|(
name|globals
operator|->
name|fix_v4bx
condition|)
block|{
name|bfd_vma
name|insn
init|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
argument_list|)
decl_stmt|;
comment|/* Ensure that we have a BX instruction.  */
name|BFD_ASSERT
argument_list|(
operator|(
name|insn
operator|&
literal|0x0ffffff0
operator|)
operator|==
literal|0x012fff10
argument_list|)
expr_stmt|;
comment|/* Preserve Rm (lowest four bits) and the condition code              (highest four bits). Other bits encode MOV PC,Rm.  */
name|insn
operator|=
operator|(
name|insn
operator|&
literal|0xf000000f
operator|)
operator||
literal|0x01a0f000
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|insn
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
block|}
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_ARM_MOVW_ABS_NC
case|:
case|case
name|R_ARM_MOVT_ABS
case|:
case|case
name|R_ARM_MOVW_PREL_NC
case|:
case|case
name|R_ARM_MOVT_PREL
case|:
comment|/* Until we properly support segment-base-relative addressing then        we assume the segment base to be zero, as for the group relocations.        Thus R_ARM_MOVW_BREL_NC has the same semantics as R_ARM_MOVW_ABS_NC        and R_ARM_MOVT_BREL has the same semantics as R_ARM_MOVT_ABS.  */
case|case
name|R_ARM_MOVW_BREL_NC
case|:
case|case
name|R_ARM_MOVW_BREL
case|:
case|case
name|R_ARM_MOVT_BREL
case|:
block|{
name|bfd_vma
name|insn
init|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
argument_list|)
decl_stmt|;
if|if
condition|(
name|globals
operator|->
name|use_rel
condition|)
block|{
name|addend
operator|=
operator|(
operator|(
name|insn
operator|>>
literal|4
operator|)
operator|&
literal|0xf000
operator|)
operator||
operator|(
name|insn
operator|&
literal|0xfff
operator|)
expr_stmt|;
name|signed_addend
operator|=
operator|(
name|addend
operator|^
literal|0x10000
operator|)
operator|-
literal|0x10000
expr_stmt|;
block|}
name|value
operator|+=
name|signed_addend
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_ARM_MOVW_PREL_NC
operator|||
name|r_type
operator|==
name|R_ARM_MOVT_PREL
condition|)
name|value
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|rel
operator|->
name|r_offset
operator|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_ARM_MOVW_BREL
operator|&&
name|value
operator|>=
literal|0x10000
condition|)
return|return
name|bfd_reloc_overflow
return|;
if|if
condition|(
name|sym_flags
operator|==
name|STT_ARM_TFUNC
condition|)
name|value
operator||=
literal|1
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_ARM_MOVT_ABS
operator|||
name|r_type
operator|==
name|R_ARM_MOVT_PREL
operator|||
name|r_type
operator|==
name|R_ARM_MOVT_BREL
condition|)
name|value
operator|>>=
literal|16
expr_stmt|;
name|insn
operator|&=
literal|0xfff0f000
expr_stmt|;
name|insn
operator||=
name|value
operator|&
literal|0xfff
expr_stmt|;
name|insn
operator||=
operator|(
name|value
operator|&
literal|0xf000
operator|)
operator|<<
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|insn
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
block|}
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_ARM_THM_MOVW_ABS_NC
case|:
case|case
name|R_ARM_THM_MOVT_ABS
case|:
case|case
name|R_ARM_THM_MOVW_PREL_NC
case|:
case|case
name|R_ARM_THM_MOVT_PREL
case|:
comment|/* Until we properly support segment-base-relative addressing then        we assume the segment base to be zero, as for the above relocations.        Thus R_ARM_THM_MOVW_BREL_NC has the same semantics as        R_ARM_THM_MOVW_ABS_NC and R_ARM_THM_MOVT_BREL has the same semantics        as R_ARM_THM_MOVT_ABS.  */
case|case
name|R_ARM_THM_MOVW_BREL_NC
case|:
case|case
name|R_ARM_THM_MOVW_BREL
case|:
case|case
name|R_ARM_THM_MOVT_BREL
case|:
block|{
name|bfd_vma
name|insn
decl_stmt|;
name|insn
operator|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
argument_list|)
operator|<<
literal|16
expr_stmt|;
name|insn
operator||=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|globals
operator|->
name|use_rel
condition|)
block|{
name|addend
operator|=
operator|(
operator|(
name|insn
operator|>>
literal|4
operator|)
operator|&
literal|0xf000
operator|)
operator||
operator|(
operator|(
name|insn
operator|>>
literal|15
operator|)
operator|&
literal|0x0800
operator|)
operator||
operator|(
operator|(
name|insn
operator|>>
literal|4
operator|)
operator|&
literal|0x0700
operator|)
operator||
operator|(
name|insn
operator|&
literal|0x00ff
operator|)
expr_stmt|;
name|signed_addend
operator|=
operator|(
name|addend
operator|^
literal|0x10000
operator|)
operator|-
literal|0x10000
expr_stmt|;
block|}
name|value
operator|+=
name|signed_addend
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_ARM_THM_MOVW_PREL_NC
operator|||
name|r_type
operator|==
name|R_ARM_THM_MOVT_PREL
condition|)
name|value
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|rel
operator|->
name|r_offset
operator|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_ARM_THM_MOVW_BREL
operator|&&
name|value
operator|>=
literal|0x10000
condition|)
return|return
name|bfd_reloc_overflow
return|;
if|if
condition|(
name|sym_flags
operator|==
name|STT_ARM_TFUNC
condition|)
name|value
operator||=
literal|1
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_ARM_THM_MOVT_ABS
operator|||
name|r_type
operator|==
name|R_ARM_THM_MOVT_PREL
operator|||
name|r_type
operator|==
name|R_ARM_THM_MOVT_BREL
condition|)
name|value
operator|>>=
literal|16
expr_stmt|;
name|insn
operator|&=
literal|0xfbf08f00
expr_stmt|;
name|insn
operator||=
operator|(
name|value
operator|&
literal|0xf000
operator|)
operator|<<
literal|4
expr_stmt|;
name|insn
operator||=
operator|(
name|value
operator|&
literal|0x0800
operator|)
operator|<<
literal|15
expr_stmt|;
name|insn
operator||=
operator|(
name|value
operator|&
literal|0x0700
operator|)
operator|<<
literal|4
expr_stmt|;
name|insn
operator||=
operator|(
name|value
operator|&
literal|0x00ff
operator|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|insn
operator|>>
literal|16
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|insn
operator|&
literal|0xffff
argument_list|,
name|hit_data
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_ARM_ALU_PC_G0_NC
case|:
case|case
name|R_ARM_ALU_PC_G1_NC
case|:
case|case
name|R_ARM_ALU_PC_G0
case|:
case|case
name|R_ARM_ALU_PC_G1
case|:
case|case
name|R_ARM_ALU_PC_G2
case|:
case|case
name|R_ARM_ALU_SB_G0_NC
case|:
case|case
name|R_ARM_ALU_SB_G1_NC
case|:
case|case
name|R_ARM_ALU_SB_G0
case|:
case|case
name|R_ARM_ALU_SB_G1
case|:
case|case
name|R_ARM_ALU_SB_G2
case|:
block|{
name|bfd_vma
name|insn
init|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
argument_list|)
decl_stmt|;
name|bfd_vma
name|pc
init|=
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|rel
operator|->
name|r_offset
decl_stmt|;
comment|/* sb should be the origin of the *segment* containing the symbol.            It is not clear how to obtain this OS-dependent value, so we            make an arbitrary choice of zero.  */
name|bfd_vma
name|sb
init|=
literal|0
decl_stmt|;
name|bfd_vma
name|residual
decl_stmt|;
name|bfd_vma
name|g_n
decl_stmt|;
name|bfd_signed_vma
name|signed_value
decl_stmt|;
name|int
name|group
init|=
literal|0
decl_stmt|;
comment|/* Determine which group of bits to select.  */
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_ARM_ALU_PC_G0_NC
case|:
case|case
name|R_ARM_ALU_PC_G0
case|:
case|case
name|R_ARM_ALU_SB_G0_NC
case|:
case|case
name|R_ARM_ALU_SB_G0
case|:
name|group
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|R_ARM_ALU_PC_G1_NC
case|:
case|case
name|R_ARM_ALU_PC_G1
case|:
case|case
name|R_ARM_ALU_SB_G1_NC
case|:
case|case
name|R_ARM_ALU_SB_G1
case|:
name|group
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|R_ARM_ALU_PC_G2
case|:
case|case
name|R_ARM_ALU_SB_G2
case|:
name|group
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* If REL, extract the addend from the insn.  If RELA, it will            have already been fetched for us.  */
if|if
condition|(
name|globals
operator|->
name|use_rel
condition|)
block|{
name|int
name|negative
decl_stmt|;
name|bfd_vma
name|constant
init|=
name|insn
operator|&
literal|0xff
decl_stmt|;
name|bfd_vma
name|rotation
init|=
operator|(
name|insn
operator|&
literal|0xf00
operator|)
operator|>>
literal|8
decl_stmt|;
if|if
condition|(
name|rotation
operator|==
literal|0
condition|)
name|signed_addend
operator|=
name|constant
expr_stmt|;
else|else
block|{
comment|/* Compensate for the fact that in the instruction, the                    rotation is stored in multiples of 2 bits.  */
name|rotation
operator|*=
literal|2
expr_stmt|;
comment|/* Rotate "constant" right by "rotation" bits.  */
name|signed_addend
operator|=
operator|(
name|constant
operator|>>
name|rotation
operator|)
operator||
operator|(
name|constant
operator|<<
operator|(
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|bfd_vma
argument_list|)
operator|-
name|rotation
operator|)
operator|)
expr_stmt|;
block|}
comment|/* Determine if the instruction is an ADD or a SUB.                (For REL, this determines the sign of the addend.)  */
name|negative
operator|=
name|identify_add_or_sub
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|negative
operator|==
literal|0
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B(%A+0x%lx): Only ADD or SUB instructions are allowed for ALU group relocations"
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
name|long
operator|)
name|rel
operator|->
name|r_offset
argument_list|,
name|howto
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_overflow
return|;
block|}
name|signed_addend
operator|*=
name|negative
expr_stmt|;
block|}
comment|/* Compute the value (X) to go in the place.  */
if|if
condition|(
name|r_type
operator|==
name|R_ARM_ALU_PC_G0_NC
operator|||
name|r_type
operator|==
name|R_ARM_ALU_PC_G1_NC
operator|||
name|r_type
operator|==
name|R_ARM_ALU_PC_G0
operator|||
name|r_type
operator|==
name|R_ARM_ALU_PC_G1
operator|||
name|r_type
operator|==
name|R_ARM_ALU_PC_G2
condition|)
comment|/* PC relative.  */
name|signed_value
operator|=
name|value
operator|-
name|pc
operator|+
name|signed_addend
expr_stmt|;
else|else
comment|/* Section base relative.  */
name|signed_value
operator|=
name|value
operator|-
name|sb
operator|+
name|signed_addend
expr_stmt|;
comment|/* If the target symbol is a Thumb function, then set the            Thumb bit in the address.  */
if|if
condition|(
name|sym_flags
operator|==
name|STT_ARM_TFUNC
condition|)
name|signed_value
operator||=
literal|1
expr_stmt|;
comment|/* Calculate the value of the relevant G_n, in encoded            constant-with-rotation format.  */
name|g_n
operator|=
name|calculate_group_reloc_mask
argument_list|(
name|llabs
argument_list|(
name|signed_value
argument_list|)
argument_list|,
name|group
argument_list|,
operator|&
name|residual
argument_list|)
expr_stmt|;
comment|/* Check for overflow if required.  */
if|if
condition|(
operator|(
name|r_type
operator|==
name|R_ARM_ALU_PC_G0
operator|||
name|r_type
operator|==
name|R_ARM_ALU_PC_G1
operator|||
name|r_type
operator|==
name|R_ARM_ALU_PC_G2
operator|||
name|r_type
operator|==
name|R_ARM_ALU_SB_G0
operator|||
name|r_type
operator|==
name|R_ARM_ALU_SB_G1
operator|||
name|r_type
operator|==
name|R_ARM_ALU_SB_G2
operator|)
operator|&&
name|residual
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B(%A+0x%lx): Overflow whilst splitting 0x%lx for group relocation %s"
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
name|long
operator|)
name|rel
operator|->
name|r_offset
argument_list|,
name|llabs
argument_list|(
name|signed_value
argument_list|)
argument_list|,
name|howto
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_overflow
return|;
block|}
comment|/* Mask out the value and the ADD/SUB part of the opcode; take care            not to destroy the S bit.  */
name|insn
operator|&=
literal|0xff1ff000
expr_stmt|;
comment|/* Set the opcode according to whether the value to go in the            place is negative.  */
if|if
condition|(
name|signed_value
operator|<
literal|0
condition|)
name|insn
operator||=
literal|1
operator|<<
literal|22
expr_stmt|;
else|else
name|insn
operator||=
literal|1
operator|<<
literal|23
expr_stmt|;
comment|/* Encode the offset.  */
name|insn
operator||=
name|g_n
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|insn
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
block|}
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_ARM_LDR_PC_G0
case|:
case|case
name|R_ARM_LDR_PC_G1
case|:
case|case
name|R_ARM_LDR_PC_G2
case|:
case|case
name|R_ARM_LDR_SB_G0
case|:
case|case
name|R_ARM_LDR_SB_G1
case|:
case|case
name|R_ARM_LDR_SB_G2
case|:
block|{
name|bfd_vma
name|insn
init|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
argument_list|)
decl_stmt|;
name|bfd_vma
name|pc
init|=
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|rel
operator|->
name|r_offset
decl_stmt|;
name|bfd_vma
name|sb
init|=
literal|0
decl_stmt|;
comment|/* See note above.  */
name|bfd_vma
name|residual
decl_stmt|;
name|bfd_signed_vma
name|signed_value
decl_stmt|;
name|int
name|group
init|=
literal|0
decl_stmt|;
comment|/* Determine which groups of bits to calculate.  */
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_ARM_LDR_PC_G0
case|:
case|case
name|R_ARM_LDR_SB_G0
case|:
name|group
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|R_ARM_LDR_PC_G1
case|:
case|case
name|R_ARM_LDR_SB_G1
case|:
name|group
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|R_ARM_LDR_PC_G2
case|:
case|case
name|R_ARM_LDR_SB_G2
case|:
name|group
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* If REL, extract the addend from the insn.  If RELA, it will            have already been fetched for us.  */
if|if
condition|(
name|globals
operator|->
name|use_rel
condition|)
block|{
name|int
name|negative
init|=
operator|(
name|insn
operator|&
operator|(
literal|1
operator|<<
literal|23
operator|)
operator|)
condition|?
literal|1
else|:
operator|-
literal|1
decl_stmt|;
name|signed_addend
operator|=
name|negative
operator|*
operator|(
name|insn
operator|&
literal|0xfff
operator|)
expr_stmt|;
block|}
comment|/* Compute the value (X) to go in the place.  */
if|if
condition|(
name|r_type
operator|==
name|R_ARM_LDR_PC_G0
operator|||
name|r_type
operator|==
name|R_ARM_LDR_PC_G1
operator|||
name|r_type
operator|==
name|R_ARM_LDR_PC_G2
condition|)
comment|/* PC relative.  */
name|signed_value
operator|=
name|value
operator|-
name|pc
operator|+
name|signed_addend
expr_stmt|;
else|else
comment|/* Section base relative.  */
name|signed_value
operator|=
name|value
operator|-
name|sb
operator|+
name|signed_addend
expr_stmt|;
comment|/* Calculate the value of the relevant G_{n-1} to obtain            the residual at that stage.  */
name|calculate_group_reloc_mask
argument_list|(
name|llabs
argument_list|(
name|signed_value
argument_list|)
argument_list|,
name|group
operator|-
literal|1
argument_list|,
operator|&
name|residual
argument_list|)
expr_stmt|;
comment|/* Check for overflow.  */
if|if
condition|(
name|residual
operator|>=
literal|0x1000
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B(%A+0x%lx): Overflow whilst splitting 0x%lx for group relocation %s"
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
name|long
operator|)
name|rel
operator|->
name|r_offset
argument_list|,
name|llabs
argument_list|(
name|signed_value
argument_list|)
argument_list|,
name|howto
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_overflow
return|;
block|}
comment|/* Mask out the value and U bit.  */
name|insn
operator|&=
literal|0xff7ff000
expr_stmt|;
comment|/* Set the U bit if the value to go in the place is non-negative.  */
if|if
condition|(
name|signed_value
operator|>=
literal|0
condition|)
name|insn
operator||=
literal|1
operator|<<
literal|23
expr_stmt|;
comment|/* Encode the offset.  */
name|insn
operator||=
name|residual
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|insn
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
block|}
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_ARM_LDRS_PC_G0
case|:
case|case
name|R_ARM_LDRS_PC_G1
case|:
case|case
name|R_ARM_LDRS_PC_G2
case|:
case|case
name|R_ARM_LDRS_SB_G0
case|:
case|case
name|R_ARM_LDRS_SB_G1
case|:
case|case
name|R_ARM_LDRS_SB_G2
case|:
block|{
name|bfd_vma
name|insn
init|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
argument_list|)
decl_stmt|;
name|bfd_vma
name|pc
init|=
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|rel
operator|->
name|r_offset
decl_stmt|;
name|bfd_vma
name|sb
init|=
literal|0
decl_stmt|;
comment|/* See note above.  */
name|bfd_vma
name|residual
decl_stmt|;
name|bfd_signed_vma
name|signed_value
decl_stmt|;
name|int
name|group
init|=
literal|0
decl_stmt|;
comment|/* Determine which groups of bits to calculate.  */
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_ARM_LDRS_PC_G0
case|:
case|case
name|R_ARM_LDRS_SB_G0
case|:
name|group
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|R_ARM_LDRS_PC_G1
case|:
case|case
name|R_ARM_LDRS_SB_G1
case|:
name|group
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|R_ARM_LDRS_PC_G2
case|:
case|case
name|R_ARM_LDRS_SB_G2
case|:
name|group
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* If REL, extract the addend from the insn.  If RELA, it will            have already been fetched for us.  */
if|if
condition|(
name|globals
operator|->
name|use_rel
condition|)
block|{
name|int
name|negative
init|=
operator|(
name|insn
operator|&
operator|(
literal|1
operator|<<
literal|23
operator|)
operator|)
condition|?
literal|1
else|:
operator|-
literal|1
decl_stmt|;
name|signed_addend
operator|=
name|negative
operator|*
operator|(
operator|(
operator|(
name|insn
operator|&
literal|0xf00
operator|)
operator|>>
literal|4
operator|)
operator|+
operator|(
name|insn
operator|&
literal|0xf
operator|)
operator|)
expr_stmt|;
block|}
comment|/* Compute the value (X) to go in the place.  */
if|if
condition|(
name|r_type
operator|==
name|R_ARM_LDRS_PC_G0
operator|||
name|r_type
operator|==
name|R_ARM_LDRS_PC_G1
operator|||
name|r_type
operator|==
name|R_ARM_LDRS_PC_G2
condition|)
comment|/* PC relative.  */
name|signed_value
operator|=
name|value
operator|-
name|pc
operator|+
name|signed_addend
expr_stmt|;
else|else
comment|/* Section base relative.  */
name|signed_value
operator|=
name|value
operator|-
name|sb
operator|+
name|signed_addend
expr_stmt|;
comment|/* Calculate the value of the relevant G_{n-1} to obtain            the residual at that stage.  */
name|calculate_group_reloc_mask
argument_list|(
name|llabs
argument_list|(
name|signed_value
argument_list|)
argument_list|,
name|group
operator|-
literal|1
argument_list|,
operator|&
name|residual
argument_list|)
expr_stmt|;
comment|/* Check for overflow.  */
if|if
condition|(
name|residual
operator|>=
literal|0x100
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B(%A+0x%lx): Overflow whilst splitting 0x%lx for group relocation %s"
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
name|long
operator|)
name|rel
operator|->
name|r_offset
argument_list|,
name|llabs
argument_list|(
name|signed_value
argument_list|)
argument_list|,
name|howto
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_overflow
return|;
block|}
comment|/* Mask out the value and U bit.  */
name|insn
operator|&=
literal|0xff7ff0f0
expr_stmt|;
comment|/* Set the U bit if the value to go in the place is non-negative.  */
if|if
condition|(
name|signed_value
operator|>=
literal|0
condition|)
name|insn
operator||=
literal|1
operator|<<
literal|23
expr_stmt|;
comment|/* Encode the offset.  */
name|insn
operator||=
operator|(
operator|(
name|residual
operator|&
literal|0xf0
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
name|residual
operator|&
literal|0xf
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|insn
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
block|}
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_ARM_LDC_PC_G0
case|:
case|case
name|R_ARM_LDC_PC_G1
case|:
case|case
name|R_ARM_LDC_PC_G2
case|:
case|case
name|R_ARM_LDC_SB_G0
case|:
case|case
name|R_ARM_LDC_SB_G1
case|:
case|case
name|R_ARM_LDC_SB_G2
case|:
block|{
name|bfd_vma
name|insn
init|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
argument_list|)
decl_stmt|;
name|bfd_vma
name|pc
init|=
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|rel
operator|->
name|r_offset
decl_stmt|;
name|bfd_vma
name|sb
init|=
literal|0
decl_stmt|;
comment|/* See note above.  */
name|bfd_vma
name|residual
decl_stmt|;
name|bfd_signed_vma
name|signed_value
decl_stmt|;
name|int
name|group
init|=
literal|0
decl_stmt|;
comment|/* Determine which groups of bits to calculate.  */
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_ARM_LDC_PC_G0
case|:
case|case
name|R_ARM_LDC_SB_G0
case|:
name|group
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|R_ARM_LDC_PC_G1
case|:
case|case
name|R_ARM_LDC_SB_G1
case|:
name|group
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|R_ARM_LDC_PC_G2
case|:
case|case
name|R_ARM_LDC_SB_G2
case|:
name|group
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* If REL, extract the addend from the insn.  If RELA, it will            have already been fetched for us.  */
if|if
condition|(
name|globals
operator|->
name|use_rel
condition|)
block|{
name|int
name|negative
init|=
operator|(
name|insn
operator|&
operator|(
literal|1
operator|<<
literal|23
operator|)
operator|)
condition|?
literal|1
else|:
operator|-
literal|1
decl_stmt|;
name|signed_addend
operator|=
name|negative
operator|*
operator|(
operator|(
name|insn
operator|&
literal|0xff
operator|)
operator|<<
literal|2
operator|)
expr_stmt|;
block|}
comment|/* Compute the value (X) to go in the place.  */
if|if
condition|(
name|r_type
operator|==
name|R_ARM_LDC_PC_G0
operator|||
name|r_type
operator|==
name|R_ARM_LDC_PC_G1
operator|||
name|r_type
operator|==
name|R_ARM_LDC_PC_G2
condition|)
comment|/* PC relative.  */
name|signed_value
operator|=
name|value
operator|-
name|pc
operator|+
name|signed_addend
expr_stmt|;
else|else
comment|/* Section base relative.  */
name|signed_value
operator|=
name|value
operator|-
name|sb
operator|+
name|signed_addend
expr_stmt|;
comment|/* Calculate the value of the relevant G_{n-1} to obtain            the residual at that stage.  */
name|calculate_group_reloc_mask
argument_list|(
name|llabs
argument_list|(
name|signed_value
argument_list|)
argument_list|,
name|group
operator|-
literal|1
argument_list|,
operator|&
name|residual
argument_list|)
expr_stmt|;
comment|/* Check for overflow.  (The absolute value to go in the place must be            divisible by four and, after having been divided by four, must            fit in eight bits.)  */
if|if
condition|(
operator|(
name|residual
operator|&
literal|0x3
operator|)
operator|!=
literal|0
operator|||
name|residual
operator|>=
literal|0x400
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B(%A+0x%lx): Overflow whilst splitting 0x%lx for group relocation %s"
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
name|long
operator|)
name|rel
operator|->
name|r_offset
argument_list|,
name|llabs
argument_list|(
name|signed_value
argument_list|)
argument_list|,
name|howto
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_overflow
return|;
block|}
comment|/* Mask out the value and U bit.  */
name|insn
operator|&=
literal|0xff7fff00
expr_stmt|;
comment|/* Set the U bit if the value to go in the place is non-negative.  */
if|if
condition|(
name|signed_value
operator|>=
literal|0
condition|)
name|insn
operator||=
literal|1
operator|<<
literal|23
expr_stmt|;
comment|/* Encode the offset.  */
name|insn
operator||=
name|residual
operator|>>
literal|2
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|insn
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
block|}
return|return
name|bfd_reloc_ok
return|;
default|default:
return|return
name|bfd_reloc_notsupported
return|;
block|}
block|}
end_function

begin_comment
comment|/* Add INCREMENT to the reloc (of type HOWTO) at ADDRESS.  */
end_comment

begin_function
specifier|static
name|void
name|arm_add_to_rel
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_byte
modifier|*
name|address
parameter_list|,
name|reloc_howto_type
modifier|*
name|howto
parameter_list|,
name|bfd_signed_vma
name|increment
parameter_list|)
block|{
name|bfd_signed_vma
name|addend
decl_stmt|;
if|if
condition|(
name|howto
operator|->
name|type
operator|==
name|R_ARM_THM_CALL
condition|)
block|{
name|int
name|upper_insn
decl_stmt|,
name|lower_insn
decl_stmt|;
name|int
name|upper
decl_stmt|,
name|lower
decl_stmt|;
name|upper_insn
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|address
argument_list|)
expr_stmt|;
name|lower_insn
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|address
operator|+
literal|2
argument_list|)
expr_stmt|;
name|upper
operator|=
name|upper_insn
operator|&
literal|0x7ff
expr_stmt|;
name|lower
operator|=
name|lower_insn
operator|&
literal|0x7ff
expr_stmt|;
name|addend
operator|=
operator|(
name|upper
operator|<<
literal|12
operator|)
operator||
operator|(
name|lower
operator|<<
literal|1
operator|)
expr_stmt|;
name|addend
operator|+=
name|increment
expr_stmt|;
name|addend
operator|>>=
literal|1
expr_stmt|;
name|upper_insn
operator|=
operator|(
name|upper_insn
operator|&
literal|0xf800
operator|)
operator||
operator|(
operator|(
name|addend
operator|>>
literal|11
operator|)
operator|&
literal|0x7ff
operator|)
expr_stmt|;
name|lower_insn
operator|=
operator|(
name|lower_insn
operator|&
literal|0xf800
operator|)
operator||
operator|(
name|addend
operator|&
literal|0x7ff
operator|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|upper_insn
argument_list|,
name|address
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|lower_insn
argument_list|,
name|address
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bfd_vma
name|contents
decl_stmt|;
name|contents
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|address
argument_list|)
expr_stmt|;
comment|/* Get the (signed) value from the instruction.  */
name|addend
operator|=
name|contents
operator|&
name|howto
operator|->
name|src_mask
expr_stmt|;
if|if
condition|(
name|addend
operator|&
operator|(
operator|(
name|howto
operator|->
name|src_mask
operator|+
literal|1
operator|)
operator|>>
literal|1
operator|)
condition|)
block|{
name|bfd_signed_vma
name|mask
decl_stmt|;
name|mask
operator|=
operator|-
literal|1
expr_stmt|;
name|mask
operator|&=
operator|~
name|howto
operator|->
name|src_mask
expr_stmt|;
name|addend
operator||=
name|mask
expr_stmt|;
block|}
comment|/* Add in the increment, (which is a byte value).  */
switch|switch
condition|(
name|howto
operator|->
name|type
condition|)
block|{
default|default:
name|addend
operator|+=
name|increment
expr_stmt|;
break|break;
case|case
name|R_ARM_PC24
case|:
case|case
name|R_ARM_PLT32
case|:
case|case
name|R_ARM_CALL
case|:
case|case
name|R_ARM_JUMP24
case|:
name|addend
operator|<<=
name|howto
operator|->
name|size
expr_stmt|;
name|addend
operator|+=
name|increment
expr_stmt|;
comment|/* Should we check for overflow here ?  */
comment|/* Drop any undesired bits.  */
name|addend
operator|>>=
name|howto
operator|->
name|rightshift
expr_stmt|;
break|break;
block|}
name|contents
operator|=
operator|(
name|contents
operator|&
operator|~
name|howto
operator|->
name|dst_mask
operator|)
operator||
operator|(
name|addend
operator|&
name|howto
operator|->
name|dst_mask
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|contents
argument_list|,
name|address
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|IS_ARM_TLS_RELOC
parameter_list|(
name|R_TYPE
parameter_list|)
define|\
value|((R_TYPE) == R_ARM_TLS_GD32		\    || (R_TYPE) == R_ARM_TLS_LDO32	\    || (R_TYPE) == R_ARM_TLS_LDM32	\    || (R_TYPE) == R_ARM_TLS_DTPOFF32	\    || (R_TYPE) == R_ARM_TLS_DTPMOD32	\    || (R_TYPE) == R_ARM_TLS_TPOFF32	\    || (R_TYPE) == R_ARM_TLS_LE32	\    || (R_TYPE) == R_ARM_TLS_IE32)
end_define

begin_comment
comment|/* Relocate an ARM ELF section.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_arm_relocate_section
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|relocs
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|local_syms
parameter_list|,
name|asection
modifier|*
modifier|*
name|local_sections
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relend
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|elf32_arm_link_hash_table
modifier|*
name|globals
decl_stmt|;
name|globals
operator|=
name|elf32_arm_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|rel
operator|=
name|relocs
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|input_section
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|int
name|r_type
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_reloc_status_type
name|r
decl_stmt|;
name|arelent
name|bfd_reloc
decl_stmt|;
name|char
name|sym_type
decl_stmt|;
name|bfd_boolean
name|unresolved_reloc
init|=
name|FALSE
decl_stmt|;
name|char
modifier|*
name|error_message
init|=
name|NULL
decl_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|arm_real_reloc_type
argument_list|(
name|globals
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_ARM_GNU_VTENTRY
operator|||
name|r_type
operator|==
name|R_ARM_GNU_VTINHERIT
condition|)
continue|continue;
name|bfd_reloc
operator|.
name|howto
operator|=
name|elf32_arm_howto_from_type
argument_list|(
name|r_type
argument_list|)
expr_stmt|;
name|howto
operator|=
name|bfd_reloc
operator|.
name|howto
expr_stmt|;
name|h
operator|=
name|NULL
expr_stmt|;
name|sym
operator|=
name|NULL
expr_stmt|;
name|sec
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
name|sym_type
operator|=
name|ELF32_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
expr_stmt|;
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
if|if
condition|(
name|globals
operator|->
name|use_rel
condition|)
block|{
name|relocation
operator|=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|sym
operator|->
name|st_value
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|relocatable
operator|&&
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_MERGE
operator|)
operator|&&
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_SECTION
condition|)
block|{
name|asection
modifier|*
name|msec
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|,
name|value
decl_stmt|;
if|if
condition|(
name|howto
operator|->
name|rightshift
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B(%A+0x%lx): %s relocation against SEC_MERGE section"
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
name|long
operator|)
name|rel
operator|->
name|r_offset
argument_list|,
name|howto
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|value
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
comment|/* Get the (signed) value from the instruction.  */
name|addend
operator|=
name|value
operator|&
name|howto
operator|->
name|src_mask
expr_stmt|;
if|if
condition|(
name|addend
operator|&
operator|(
operator|(
name|howto
operator|->
name|src_mask
operator|+
literal|1
operator|)
operator|>>
literal|1
operator|)
condition|)
block|{
name|bfd_signed_vma
name|mask
decl_stmt|;
name|mask
operator|=
operator|-
literal|1
expr_stmt|;
name|mask
operator|&=
operator|~
name|howto
operator|->
name|src_mask
expr_stmt|;
name|addend
operator||=
name|mask
expr_stmt|;
block|}
name|msec
operator|=
name|sec
expr_stmt|;
name|addend
operator|=
name|_bfd_elf_rel_local_sym
argument_list|(
name|output_bfd
argument_list|,
name|sym
argument_list|,
operator|&
name|msec
argument_list|,
name|addend
argument_list|)
operator|-
name|relocation
expr_stmt|;
name|addend
operator|+=
name|msec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|msec
operator|->
name|output_offset
expr_stmt|;
name|value
operator|=
operator|(
name|value
operator|&
operator|~
name|howto
operator|->
name|dst_mask
operator|)
operator||
operator|(
name|addend
operator|&
name|howto
operator|->
name|dst_mask
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|value
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|relocation
operator|=
name|_bfd_elf_rela_local_sym
argument_list|(
name|output_bfd
argument_list|,
name|sym
argument_list|,
operator|&
name|sec
argument_list|,
name|rel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bfd_boolean
name|warned
decl_stmt|;
name|RELOC_FOR_GLOBAL_SYMBOL
argument_list|(
name|info
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
argument_list|,
name|r_symndx
argument_list|,
name|symtab_hdr
argument_list|,
name|sym_hashes
argument_list|,
name|h
argument_list|,
name|sec
argument_list|,
name|relocation
argument_list|,
name|unresolved_reloc
argument_list|,
name|warned
argument_list|)
expr_stmt|;
name|sym_type
operator|=
name|h
operator|->
name|type
expr_stmt|;
block|}
if|if
condition|(
name|sec
operator|!=
name|NULL
operator|&&
name|elf_discarded_section
argument_list|(
name|sec
argument_list|)
condition|)
block|{
comment|/* For relocs against symbols from removed linkonce sections, 	     or sections discarded by a linker script, we just want the 	     section contents zeroed.  Avoid any special processing.  */
name|_bfd_clear_contents
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|rel
operator|->
name|r_info
operator|=
literal|0
expr_stmt|;
name|rel
operator|->
name|r_addend
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
block|{
comment|/* This is a relocatable link.  We don't have to change 	     anything, unless the reloc is against a section symbol, 	     in which case we have to adjust according to where the 	     section symbol winds up in the output section.  */
if|if
condition|(
name|sym
operator|!=
name|NULL
operator|&&
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_SECTION
condition|)
block|{
if|if
condition|(
name|globals
operator|->
name|use_rel
condition|)
name|arm_add_to_rel
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|,
name|howto
argument_list|,
operator|(
name|bfd_signed_vma
operator|)
name|sec
operator|->
name|output_offset
argument_list|)
expr_stmt|;
else|else
name|rel
operator|->
name|r_addend
operator|+=
name|sec
operator|->
name|output_offset
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
else|else
block|{
name|name
operator|=
operator|(
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_link
argument_list|,
name|sym
operator|->
name|st_name
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
operator|||
operator|*
name|name
operator|==
literal|'\0'
condition|)
name|name
operator|=
name|bfd_section_name
argument_list|(
name|input_bfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r_symndx
operator|!=
literal|0
operator|&&
name|r_type
operator|!=
name|R_ARM_NONE
operator|&&
operator|(
name|h
operator|==
name|NULL
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
name|IS_ARM_TLS_RELOC
argument_list|(
name|r_type
argument_list|)
operator|!=
operator|(
name|sym_type
operator|==
name|STT_TLS
operator|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
operator|(
name|sym_type
operator|==
name|STT_TLS
condition|?
name|_
argument_list|(
literal|"%B(%A+0x%lx): %s used with TLS symbol %s"
argument_list|)
else|:
name|_
argument_list|(
literal|"%B(%A+0x%lx): %s used with non-TLS symbol %s"
argument_list|)
operator|)
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
name|long
operator|)
name|rel
operator|->
name|r_offset
argument_list|,
name|howto
operator|->
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|r
operator|=
name|elf32_arm_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|output_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
argument_list|,
name|relocation
argument_list|,
name|info
argument_list|,
name|sec
argument_list|,
name|name
argument_list|,
operator|(
name|h
condition|?
name|ELF_ST_TYPE
argument_list|(
name|h
operator|->
name|type
argument_list|)
else|:
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|)
argument_list|,
name|h
argument_list|,
operator|&
name|unresolved_reloc
argument_list|,
operator|&
name|error_message
argument_list|)
expr_stmt|;
comment|/* Dynamic relocs are not propagated for SEC_DEBUGGING sections 	 because such sections are not SEC_ALLOC and thus ld.so will 	 not process them.  */
if|if
condition|(
name|unresolved_reloc
operator|&&
operator|!
operator|(
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_DEBUGGING
operator|)
operator|!=
literal|0
operator|&&
name|h
operator|->
name|def_dynamic
operator|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B(%A+0x%lx): unresolvable %s relocation against symbol `%s'"
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
name|long
operator|)
name|rel
operator|->
name|r_offset
argument_list|,
name|howto
operator|->
name|name
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|r
operator|!=
name|bfd_reloc_ok
condition|)
block|{
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|bfd_reloc_overflow
case|:
comment|/* If the overflowing reloc was to an undefined symbol, 		 we have already printed one error message and there 		 is no point complaining again.  */
if|if
condition|(
operator|(
operator|!
name|h
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefined
operator|)
operator|&&
operator|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|info
argument_list|,
operator|(
name|h
condition|?
operator|&
name|h
operator|->
name|root
else|:
name|NULL
operator|)
argument_list|,
name|name
argument_list|,
name|howto
operator|->
name|name
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
operator|)
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|bfd_reloc_undefined
case|:
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|info
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|TRUE
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|bfd_reloc_outofrange
case|:
name|error_message
operator|=
name|_
argument_list|(
literal|"out of range"
argument_list|)
expr_stmt|;
goto|goto
name|common_error
goto|;
case|case
name|bfd_reloc_notsupported
case|:
name|error_message
operator|=
name|_
argument_list|(
literal|"unsupported relocation"
argument_list|)
expr_stmt|;
goto|goto
name|common_error
goto|;
case|case
name|bfd_reloc_dangerous
case|:
comment|/* error_message should already be set.  */
goto|goto
name|common_error
goto|;
default|default:
name|error_message
operator|=
name|_
argument_list|(
literal|"unknown error"
argument_list|)
expr_stmt|;
comment|/* fall through */
name|common_error
label|:
name|BFD_ASSERT
argument_list|(
name|error_message
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_dangerous
call|)
argument_list|(
name|info
argument_list|,
name|error_message
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
break|break;
block|}
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Set the right machine number.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_arm_object_p
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|unsigned
name|int
name|mach
decl_stmt|;
name|mach
operator|=
name|bfd_arm_get_mach_from_notes
argument_list|(
name|abfd
argument_list|,
name|ARM_NOTE_SECTION
argument_list|)
expr_stmt|;
if|if
condition|(
name|mach
operator|!=
name|bfd_mach_arm_unknown
condition|)
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_arm
argument_list|,
name|mach
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_ARM_MAVERICK_FLOAT
condition|)
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_arm
argument_list|,
name|bfd_mach_arm_ep9312
argument_list|)
expr_stmt|;
else|else
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_arm
argument_list|,
name|mach
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Function to keep ARM specific flags in the ELF header.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_arm_set_private_flags
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|flagword
name|flags
parameter_list|)
block|{
if|if
condition|(
name|elf_flags_init
argument_list|(
name|abfd
argument_list|)
operator|&&
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|!=
name|flags
condition|)
block|{
if|if
condition|(
name|EF_ARM_EABI_VERSION
argument_list|(
name|flags
argument_list|)
operator|==
name|EF_ARM_EABI_UNKNOWN
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|EF_ARM_INTERWORK
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Warning: Not setting interworking flag of %B since it has already been specified as non-interworking"
argument_list|)
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
else|else
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"Warning: Clearing the interworking flag of %B due to outside request"
argument_list|)
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|=
name|flags
expr_stmt|;
name|elf_flags_init
argument_list|(
name|abfd
argument_list|)
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Copy backend specific data from one object module to another.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_arm_copy_private_bfd_data
parameter_list|(
name|bfd
modifier|*
name|ibfd
parameter_list|,
name|bfd
modifier|*
name|obfd
parameter_list|)
block|{
name|flagword
name|in_flags
decl_stmt|;
name|flagword
name|out_flags
decl_stmt|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|ibfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
operator|||
name|bfd_get_flavour
argument_list|(
name|obfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
return|return
name|TRUE
return|;
name|in_flags
operator|=
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
name|out_flags
operator|=
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
if|if
condition|(
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
operator|&&
name|EF_ARM_EABI_VERSION
argument_list|(
name|out_flags
argument_list|)
operator|==
name|EF_ARM_EABI_UNKNOWN
operator|&&
name|in_flags
operator|!=
name|out_flags
condition|)
block|{
comment|/* Cannot mix APCS26 and APCS32 code.  */
if|if
condition|(
operator|(
name|in_flags
operator|&
name|EF_ARM_APCS_26
operator|)
operator|!=
operator|(
name|out_flags
operator|&
name|EF_ARM_APCS_26
operator|)
condition|)
return|return
name|FALSE
return|;
comment|/* Cannot mix float APCS and non-float APCS code.  */
if|if
condition|(
operator|(
name|in_flags
operator|&
name|EF_ARM_APCS_FLOAT
operator|)
operator|!=
operator|(
name|out_flags
operator|&
name|EF_ARM_APCS_FLOAT
operator|)
condition|)
return|return
name|FALSE
return|;
comment|/* If the src and dest have different interworking flags          then turn off the interworking bit.  */
if|if
condition|(
operator|(
name|in_flags
operator|&
name|EF_ARM_INTERWORK
operator|)
operator|!=
operator|(
name|out_flags
operator|&
name|EF_ARM_INTERWORK
operator|)
condition|)
block|{
if|if
condition|(
name|out_flags
operator|&
name|EF_ARM_INTERWORK
condition|)
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"Warning: Clearing the interworking flag of %B because non-interworking code in %B has been linked with it"
argument_list|)
argument_list|,
name|obfd
argument_list|,
name|ibfd
argument_list|)
expr_stmt|;
name|in_flags
operator|&=
operator|~
name|EF_ARM_INTERWORK
expr_stmt|;
block|}
comment|/* Likewise for PIC, though don't warn for this case.  */
if|if
condition|(
operator|(
name|in_flags
operator|&
name|EF_ARM_PIC
operator|)
operator|!=
operator|(
name|out_flags
operator|&
name|EF_ARM_PIC
operator|)
condition|)
name|in_flags
operator|&=
operator|~
name|EF_ARM_PIC
expr_stmt|;
block|}
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|=
name|in_flags
expr_stmt|;
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
operator|=
name|TRUE
expr_stmt|;
comment|/* Also copy the EI_OSABI field.  */
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_ident
index|[
name|EI_OSABI
index|]
operator|=
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
operator|->
name|e_ident
index|[
name|EI_OSABI
index|]
expr_stmt|;
comment|/* Copy object attributes.  */
name|_bfd_elf_copy_obj_attributes
argument_list|(
name|ibfd
argument_list|,
name|obfd
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Values for Tag_ABI_PCS_R9_use.  */
end_comment

begin_enum
enum|enum
block|{
name|AEABI_R9_V6
block|,
name|AEABI_R9_SB
block|,
name|AEABI_R9_TLS
block|,
name|AEABI_R9_unused
block|}
enum|;
end_enum

begin_comment
comment|/* Values for Tag_ABI_PCS_RW_data.  */
end_comment

begin_enum
enum|enum
block|{
name|AEABI_PCS_RW_data_absolute
block|,
name|AEABI_PCS_RW_data_PCrel
block|,
name|AEABI_PCS_RW_data_SBrel
block|,
name|AEABI_PCS_RW_data_unused
block|}
enum|;
end_enum

begin_comment
comment|/* Values for Tag_ABI_enum_size.  */
end_comment

begin_enum
enum|enum
block|{
name|AEABI_enum_unused
block|,
name|AEABI_enum_short
block|,
name|AEABI_enum_wide
block|,
name|AEABI_enum_forced_wide
block|}
enum|;
end_enum

begin_comment
comment|/* Determine whether an object attribute tag takes an integer, a    string or both.  */
end_comment

begin_function
specifier|static
name|int
name|elf32_arm_obj_attrs_arg_type
parameter_list|(
name|int
name|tag
parameter_list|)
block|{
if|if
condition|(
name|tag
operator|==
name|Tag_compatibility
condition|)
return|return
literal|3
return|;
elseif|else
if|if
condition|(
name|tag
operator|==
literal|4
operator|||
name|tag
operator|==
literal|5
condition|)
return|return
literal|2
return|;
elseif|else
if|if
condition|(
name|tag
operator|<
literal|32
condition|)
return|return
literal|1
return|;
else|else
return|return
operator|(
name|tag
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|?
literal|2
else|:
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Merge EABI object attributes from IBFD into OBFD.  Raise an error if there    are conflicting attributes.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_arm_merge_eabi_attributes
parameter_list|(
name|bfd
modifier|*
name|ibfd
parameter_list|,
name|bfd
modifier|*
name|obfd
parameter_list|)
block|{
name|obj_attribute
modifier|*
name|in_attr
decl_stmt|;
name|obj_attribute
modifier|*
name|out_attr
decl_stmt|;
name|obj_attribute_list
modifier|*
name|in_list
decl_stmt|;
comment|/* Some tags have 0 = don't care, 1 = strong requirement,      2 = weak requirement.  */
specifier|static
specifier|const
name|int
name|order_312
index|[
literal|3
index|]
init|=
block|{
literal|3
block|,
literal|1
block|,
literal|2
block|}
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|elf_known_obj_attributes_proc
argument_list|(
name|obfd
argument_list|)
index|[
literal|0
index|]
operator|.
name|i
condition|)
block|{
comment|/* This is the first object.  Copy the attributes.  */
name|_bfd_elf_copy_obj_attributes
argument_list|(
name|ibfd
argument_list|,
name|obfd
argument_list|)
expr_stmt|;
comment|/* Use the Tag_null value to indicate the attributes have been 	 initialized.  */
name|elf_known_obj_attributes_proc
argument_list|(
name|obfd
argument_list|)
index|[
literal|0
index|]
operator|.
name|i
operator|=
literal|1
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|in_attr
operator|=
name|elf_known_obj_attributes_proc
argument_list|(
name|ibfd
argument_list|)
expr_stmt|;
name|out_attr
operator|=
name|elf_known_obj_attributes_proc
argument_list|(
name|obfd
argument_list|)
expr_stmt|;
comment|/* This needs to happen before Tag_ABI_FP_number_model is merged.  */
if|if
condition|(
name|in_attr
index|[
name|Tag_ABI_VFP_args
index|]
operator|.
name|i
operator|!=
name|out_attr
index|[
name|Tag_ABI_VFP_args
index|]
operator|.
name|i
condition|)
block|{
comment|/* Ignore mismatches if teh object doesn't use floating point.  */
if|if
condition|(
name|out_attr
index|[
name|Tag_ABI_FP_number_model
index|]
operator|.
name|i
operator|==
literal|0
condition|)
name|out_attr
index|[
name|Tag_ABI_VFP_args
index|]
operator|.
name|i
operator|=
name|in_attr
index|[
name|Tag_ABI_VFP_args
index|]
operator|.
name|i
expr_stmt|;
elseif|else
if|if
condition|(
name|in_attr
index|[
name|Tag_ABI_FP_number_model
index|]
operator|.
name|i
operator|!=
literal|0
condition|)
block|{
name|bfd
modifier|*
name|hasbfd
decl_stmt|,
modifier|*
name|hasnotbfd
decl_stmt|;
if|if
condition|(
name|in_attr
index|[
name|Tag_ABI_VFP_args
index|]
operator|.
name|i
condition|)
block|{
name|hasbfd
operator|=
name|ibfd
expr_stmt|;
name|hasnotbfd
operator|=
name|obfd
expr_stmt|;
block|}
else|else
block|{
name|hasbfd
operator|=
name|obfd
expr_stmt|;
name|hasnotbfd
operator|=
name|ibfd
expr_stmt|;
block|}
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"ERROR: %B uses VFP register arguments, %B does not"
argument_list|)
argument_list|,
name|hasbfd
argument_list|,
name|hasnotbfd
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|4
init|;
name|i
operator|<
name|NUM_KNOWN_OBJ_ATTRIBUTES
condition|;
name|i
operator|++
control|)
block|{
comment|/* Merge this attribute with existing attributes.  */
switch|switch
condition|(
name|i
condition|)
block|{
case|case
name|Tag_CPU_raw_name
case|:
case|case
name|Tag_CPU_name
case|:
comment|/* Use whichever has the greatest architecture requirements.  We 	     won't necessarily have both the above tags, so make sure input 	     name is non-NULL.  */
if|if
condition|(
name|in_attr
index|[
name|Tag_CPU_arch
index|]
operator|.
name|i
operator|>
name|out_attr
index|[
name|Tag_CPU_arch
index|]
operator|.
name|i
operator|&&
name|in_attr
index|[
name|i
index|]
operator|.
name|s
condition|)
name|out_attr
index|[
name|i
index|]
operator|.
name|s
operator|=
name|_bfd_elf_attr_strdup
argument_list|(
name|obfd
argument_list|,
name|in_attr
index|[
name|i
index|]
operator|.
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|Tag_ABI_optimization_goals
case|:
case|case
name|Tag_ABI_FP_optimization_goals
case|:
comment|/* Use the first value seen.  */
break|break;
case|case
name|Tag_CPU_arch
case|:
case|case
name|Tag_ARM_ISA_use
case|:
case|case
name|Tag_THUMB_ISA_use
case|:
case|case
name|Tag_VFP_arch
case|:
case|case
name|Tag_WMMX_arch
case|:
case|case
name|Tag_NEON_arch
case|:
comment|/* ??? Do NEON and WMMX conflict?  */
case|case
name|Tag_ABI_FP_rounding
case|:
case|case
name|Tag_ABI_FP_denormal
case|:
case|case
name|Tag_ABI_FP_exceptions
case|:
case|case
name|Tag_ABI_FP_user_exceptions
case|:
case|case
name|Tag_ABI_FP_number_model
case|:
case|case
name|Tag_ABI_align8_preserved
case|:
case|case
name|Tag_ABI_HardFP_use
case|:
case|case
name|Tag_CPU_unaligned_access
case|:
case|case
name|Tag_FP_HP_extension
case|:
comment|/* Use the largest value specified.  */
if|if
condition|(
name|in_attr
index|[
name|i
index|]
operator|.
name|i
operator|>
name|out_attr
index|[
name|i
index|]
operator|.
name|i
condition|)
name|out_attr
index|[
name|i
index|]
operator|.
name|i
operator|=
name|in_attr
index|[
name|i
index|]
operator|.
name|i
expr_stmt|;
break|break;
case|case
name|Tag_CPU_arch_profile
case|:
comment|/* Warn if conflicting architecture profiles used.  */
if|if
condition|(
name|out_attr
index|[
name|i
index|]
operator|.
name|i
operator|&&
name|in_attr
index|[
name|i
index|]
operator|.
name|i
operator|&&
name|in_attr
index|[
name|i
index|]
operator|.
name|i
operator|!=
name|out_attr
index|[
name|i
index|]
operator|.
name|i
condition|)
block|{
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"ERROR: %B: Conflicting architecture profiles %c/%c"
argument_list|)
argument_list|,
name|ibfd
argument_list|,
name|in_attr
index|[
name|i
index|]
operator|.
name|i
argument_list|,
name|out_attr
index|[
name|i
index|]
operator|.
name|i
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|in_attr
index|[
name|i
index|]
operator|.
name|i
condition|)
name|out_attr
index|[
name|i
index|]
operator|.
name|i
operator|=
name|in_attr
index|[
name|i
index|]
operator|.
name|i
expr_stmt|;
break|break;
case|case
name|Tag_PCS_config
case|:
if|if
condition|(
name|out_attr
index|[
name|i
index|]
operator|.
name|i
operator|==
literal|0
condition|)
name|out_attr
index|[
name|i
index|]
operator|.
name|i
operator|=
name|in_attr
index|[
name|i
index|]
operator|.
name|i
expr_stmt|;
elseif|else
if|if
condition|(
name|in_attr
index|[
name|i
index|]
operator|.
name|i
operator|!=
literal|0
operator|&&
name|out_attr
index|[
name|i
index|]
operator|.
name|i
operator|!=
literal|0
condition|)
block|{
comment|/* It's sometimes ok to mix different configs, so this is only 	         a warning.  */
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"Warning: %B: Conflicting platform configuration"
argument_list|)
argument_list|,
name|ibfd
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Tag_ABI_PCS_R9_use
case|:
if|if
condition|(
name|in_attr
index|[
name|i
index|]
operator|.
name|i
operator|!=
name|out_attr
index|[
name|i
index|]
operator|.
name|i
operator|&&
name|out_attr
index|[
name|i
index|]
operator|.
name|i
operator|!=
name|AEABI_R9_unused
operator|&&
name|in_attr
index|[
name|i
index|]
operator|.
name|i
operator|!=
name|AEABI_R9_unused
condition|)
block|{
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"ERROR: %B: Conflicting use of R9"
argument_list|)
argument_list|,
name|ibfd
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|out_attr
index|[
name|i
index|]
operator|.
name|i
operator|==
name|AEABI_R9_unused
condition|)
name|out_attr
index|[
name|i
index|]
operator|.
name|i
operator|=
name|in_attr
index|[
name|i
index|]
operator|.
name|i
expr_stmt|;
break|break;
case|case
name|Tag_ABI_PCS_RW_data
case|:
if|if
condition|(
name|in_attr
index|[
name|i
index|]
operator|.
name|i
operator|==
name|AEABI_PCS_RW_data_SBrel
operator|&&
name|out_attr
index|[
name|Tag_ABI_PCS_R9_use
index|]
operator|.
name|i
operator|!=
name|AEABI_R9_SB
operator|&&
name|out_attr
index|[
name|Tag_ABI_PCS_R9_use
index|]
operator|.
name|i
operator|!=
name|AEABI_R9_unused
condition|)
block|{
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"ERROR: %B: SB relative addressing conflicts with use of R9"
argument_list|)
argument_list|,
name|ibfd
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Use the smallest value specified.  */
if|if
condition|(
name|in_attr
index|[
name|i
index|]
operator|.
name|i
operator|<
name|out_attr
index|[
name|i
index|]
operator|.
name|i
condition|)
name|out_attr
index|[
name|i
index|]
operator|.
name|i
operator|=
name|in_attr
index|[
name|i
index|]
operator|.
name|i
expr_stmt|;
break|break;
case|case
name|Tag_ABI_PCS_RO_data
case|:
comment|/* Use the smallest value specified.  */
if|if
condition|(
name|in_attr
index|[
name|i
index|]
operator|.
name|i
operator|<
name|out_attr
index|[
name|i
index|]
operator|.
name|i
condition|)
name|out_attr
index|[
name|i
index|]
operator|.
name|i
operator|=
name|in_attr
index|[
name|i
index|]
operator|.
name|i
expr_stmt|;
break|break;
case|case
name|Tag_ABI_PCS_GOT_use
case|:
if|if
condition|(
name|in_attr
index|[
name|i
index|]
operator|.
name|i
operator|>
literal|2
operator|||
name|out_attr
index|[
name|i
index|]
operator|.
name|i
operator|>
literal|2
operator|||
name|order_312
index|[
name|in_attr
index|[
name|i
index|]
operator|.
name|i
index|]
operator|<
name|order_312
index|[
name|out_attr
index|[
name|i
index|]
operator|.
name|i
index|]
condition|)
name|out_attr
index|[
name|i
index|]
operator|.
name|i
operator|=
name|in_attr
index|[
name|i
index|]
operator|.
name|i
expr_stmt|;
break|break;
case|case
name|Tag_ABI_PCS_wchar_t
case|:
if|if
condition|(
name|out_attr
index|[
name|i
index|]
operator|.
name|i
operator|&&
name|in_attr
index|[
name|i
index|]
operator|.
name|i
operator|&&
name|out_attr
index|[
name|i
index|]
operator|.
name|i
operator|!=
name|in_attr
index|[
name|i
index|]
operator|.
name|i
condition|)
block|{
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"ERROR: %B: Conflicting definitions of wchar_t"
argument_list|)
argument_list|,
name|ibfd
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|in_attr
index|[
name|i
index|]
operator|.
name|i
condition|)
name|out_attr
index|[
name|i
index|]
operator|.
name|i
operator|=
name|in_attr
index|[
name|i
index|]
operator|.
name|i
expr_stmt|;
break|break;
case|case
name|Tag_ABI_align8_needed
case|:
comment|/* ??? Check against Tag_ABI_align8_preserved.  */
if|if
condition|(
name|in_attr
index|[
name|i
index|]
operator|.
name|i
operator|>
literal|2
operator|||
name|out_attr
index|[
name|i
index|]
operator|.
name|i
operator|>
literal|2
operator|||
name|order_312
index|[
name|in_attr
index|[
name|i
index|]
operator|.
name|i
index|]
operator|<
name|order_312
index|[
name|out_attr
index|[
name|i
index|]
operator|.
name|i
index|]
condition|)
name|out_attr
index|[
name|i
index|]
operator|.
name|i
operator|=
name|in_attr
index|[
name|i
index|]
operator|.
name|i
expr_stmt|;
break|break;
case|case
name|Tag_ABI_enum_size
case|:
if|if
condition|(
name|in_attr
index|[
name|i
index|]
operator|.
name|i
operator|!=
name|AEABI_enum_unused
condition|)
block|{
if|if
condition|(
name|out_attr
index|[
name|i
index|]
operator|.
name|i
operator|==
name|AEABI_enum_unused
operator|||
name|out_attr
index|[
name|i
index|]
operator|.
name|i
operator|==
name|AEABI_enum_forced_wide
condition|)
block|{
comment|/* The existing object is compatible with anything. 		     Use whatever requirements the new object has.  */
name|out_attr
index|[
name|i
index|]
operator|.
name|i
operator|=
name|in_attr
index|[
name|i
index|]
operator|.
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|in_attr
index|[
name|i
index|]
operator|.
name|i
operator|!=
name|AEABI_enum_forced_wide
operator|&&
name|out_attr
index|[
name|i
index|]
operator|.
name|i
operator|!=
name|in_attr
index|[
name|i
index|]
operator|.
name|i
operator|&&
operator|!
name|elf32_arm_tdata
argument_list|(
name|obfd
argument_list|)
operator|->
name|no_enum_size_warning
condition|)
block|{
specifier|const
name|char
modifier|*
name|aeabi_enum_names
index|[]
init|=
block|{
literal|""
block|,
literal|"variable-size"
block|,
literal|"32-bit"
block|,
literal|""
block|}
decl_stmt|;
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"warning: %B uses %s enums yet the output is to use %s enums; use of enum values across objects may fail"
argument_list|)
argument_list|,
name|ibfd
argument_list|,
name|aeabi_enum_names
index|[
name|in_attr
index|[
name|i
index|]
operator|.
name|i
index|]
argument_list|,
name|aeabi_enum_names
index|[
name|out_attr
index|[
name|i
index|]
operator|.
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|Tag_ABI_VFP_args
case|:
comment|/* Aready done.  */
break|break;
case|case
name|Tag_ABI_WMMX_args
case|:
if|if
condition|(
name|in_attr
index|[
name|i
index|]
operator|.
name|i
operator|!=
name|out_attr
index|[
name|i
index|]
operator|.
name|i
condition|)
block|{
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"ERROR: %B uses iWMMXt register arguments, %B does not"
argument_list|)
argument_list|,
name|ibfd
argument_list|,
name|obfd
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
break|break;
default|default:
comment|/* All known attributes should be explicitly covered.   */
comment|/* XXX Not now */
comment|/* abort (); */
break|break;
block|}
block|}
comment|/* Merge Tag_compatibility attributes and any common GNU ones.  */
name|_bfd_elf_merge_object_attributes
argument_list|(
name|ibfd
argument_list|,
name|obfd
argument_list|)
expr_stmt|;
comment|/* Check for any attributes not known on ARM.  */
name|in_list
operator|=
name|elf_other_obj_attributes_proc
argument_list|(
name|ibfd
argument_list|)
expr_stmt|;
while|while
condition|(
name|in_list
operator|&&
name|in_list
operator|->
name|tag
operator|==
name|Tag_compatibility
condition|)
name|in_list
operator|=
name|in_list
operator|->
name|next
expr_stmt|;
for|for
control|(
init|;
name|in_list
condition|;
name|in_list
operator|=
name|in_list
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|in_list
operator|->
name|tag
operator|&
literal|128
operator|)
operator|<
literal|64
operator|&&
name|in_list
operator|->
name|tag
operator|!=
name|Tag_Virtualization_use
condition|)
block|{
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"Warning: %B: Unknown EABI object attribute %d"
argument_list|)
argument_list|,
name|ibfd
argument_list|,
name|in_list
operator|->
name|tag
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if the two EABI versions are incompatible.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_arm_versions_compatible
parameter_list|(
name|unsigned
name|iver
parameter_list|,
name|unsigned
name|over
parameter_list|)
block|{
comment|/* v4 and v5 are the same spec before and after it was released,      so allow mixing them.  */
if|if
condition|(
operator|(
name|iver
operator|==
name|EF_ARM_EABI_VER4
operator|&&
name|over
operator|==
name|EF_ARM_EABI_VER5
operator|)
operator|||
operator|(
name|iver
operator|==
name|EF_ARM_EABI_VER5
operator|&&
name|over
operator|==
name|EF_ARM_EABI_VER4
operator|)
condition|)
return|return
name|TRUE
return|;
return|return
operator|(
name|iver
operator|==
name|over
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Merge backend specific data from an object file to the output    object file when linking.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_arm_merge_private_bfd_data
parameter_list|(
name|bfd
modifier|*
name|ibfd
parameter_list|,
name|bfd
modifier|*
name|obfd
parameter_list|)
block|{
name|flagword
name|out_flags
decl_stmt|;
name|flagword
name|in_flags
decl_stmt|;
name|bfd_boolean
name|flags_compatible
init|=
name|TRUE
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
comment|/* Check if we have the same endianess.  */
if|if
condition|(
operator|!
name|_bfd_generic_verify_endian_match
argument_list|(
name|ibfd
argument_list|,
name|obfd
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|ibfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
operator|||
name|bfd_get_flavour
argument_list|(
name|obfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
operator|!
name|elf32_arm_merge_eabi_attributes
argument_list|(
name|ibfd
argument_list|,
name|obfd
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* The input BFD must have had its flags initialised.  */
comment|/* The following seems bogus to me -- The flags are initialized in      the assembler but I don't think an elf_flags_init field is      written into the object.  */
comment|/* BFD_ASSERT (elf_flags_init (ibfd)); */
name|in_flags
operator|=
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
name|out_flags
operator|=
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
if|if
condition|(
operator|!
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
condition|)
block|{
comment|/* If the input is the default architecture and had the default 	 flags then do not bother setting the flags for the output 	 architecture, instead allow future merges to do this.  If no 	 future merges ever set these flags then they will retain their          uninitialised values, which surprise surprise, correspond          to the default values.  */
if|if
condition|(
name|bfd_get_arch_info
argument_list|(
name|ibfd
argument_list|)
operator|->
name|the_default
operator|&&
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
operator|->
name|e_flags
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
operator|=
name|TRUE
expr_stmt|;
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|=
name|in_flags
expr_stmt|;
if|if
condition|(
name|bfd_get_arch
argument_list|(
name|obfd
argument_list|)
operator|==
name|bfd_get_arch
argument_list|(
name|ibfd
argument_list|)
operator|&&
name|bfd_get_arch_info
argument_list|(
name|obfd
argument_list|)
operator|->
name|the_default
condition|)
return|return
name|bfd_set_arch_mach
argument_list|(
name|obfd
argument_list|,
name|bfd_get_arch
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|bfd_get_mach
argument_list|(
name|ibfd
argument_list|)
argument_list|)
return|;
return|return
name|TRUE
return|;
block|}
comment|/* Determine what should happen if the input ARM architecture      does not match the output ARM architecture.  */
if|if
condition|(
operator|!
name|bfd_arm_merge_machines
argument_list|(
name|ibfd
argument_list|,
name|obfd
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Identical flags must be compatible.  */
if|if
condition|(
name|in_flags
operator|==
name|out_flags
condition|)
return|return
name|TRUE
return|;
comment|/* Check to see if the input BFD actually contains any sections.  If      not, its flags may not have been initialised either, but it      cannot actually cause any incompatiblity.  Do not short-circuit      dynamic objects; their section list may be emptied by     elf_link_add_object_symbols.      Also check to see if there are no code sections in the input.     In this case there is no need to check for code specific flags.     XXX - do we need to worry about floating-point format compatability     in data sections ?  */
if|if
condition|(
operator|!
operator|(
name|ibfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
condition|)
block|{
name|bfd_boolean
name|null_input_bfd
init|=
name|TRUE
decl_stmt|;
name|bfd_boolean
name|only_data_sections
init|=
name|TRUE
decl_stmt|;
for|for
control|(
name|sec
operator|=
name|ibfd
operator|->
name|sections
init|;
name|sec
operator|!=
name|NULL
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
block|{
comment|/* Ignore synthetic glue sections.  */
if|if
condition|(
name|strcmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
literal|".glue_7"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
literal|".glue_7t"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|bfd_get_section_flags
argument_list|(
name|ibfd
argument_list|,
name|sec
argument_list|)
operator|&
operator|(
name|SEC_LOAD
operator||
name|SEC_CODE
operator||
name|SEC_HAS_CONTENTS
operator|)
operator|)
operator|==
operator|(
name|SEC_LOAD
operator||
name|SEC_CODE
operator||
name|SEC_HAS_CONTENTS
operator|)
condition|)
name|only_data_sections
operator|=
name|FALSE
expr_stmt|;
name|null_input_bfd
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|null_input_bfd
operator|||
name|only_data_sections
condition|)
return|return
name|TRUE
return|;
block|}
comment|/* Complain about various flag mismatches.  */
if|if
condition|(
operator|!
name|elf32_arm_versions_compatible
argument_list|(
name|EF_ARM_EABI_VERSION
argument_list|(
name|in_flags
argument_list|)
argument_list|,
name|EF_ARM_EABI_VERSION
argument_list|(
name|out_flags
argument_list|)
argument_list|)
condition|)
block|{
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"ERROR: Source object %B has EABI version %d, but target %B has EABI version %d"
argument_list|)
argument_list|,
name|ibfd
argument_list|,
name|obfd
argument_list|,
operator|(
name|in_flags
operator|&
name|EF_ARM_EABIMASK
operator|)
operator|>>
literal|24
argument_list|,
operator|(
name|out_flags
operator|&
name|EF_ARM_EABIMASK
operator|)
operator|>>
literal|24
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Not sure what needs to be checked for EABI versions>= 1.  */
comment|/* VxWorks libraries do not use these flags.  */
if|if
condition|(
name|get_elf_backend_data
argument_list|(
name|obfd
argument_list|)
operator|!=
operator|&
name|elf32_arm_vxworks_bed
operator|&&
name|get_elf_backend_data
argument_list|(
name|ibfd
argument_list|)
operator|!=
operator|&
name|elf32_arm_vxworks_bed
operator|&&
name|EF_ARM_EABI_VERSION
argument_list|(
name|in_flags
argument_list|)
operator|==
name|EF_ARM_EABI_UNKNOWN
condition|)
block|{
if|if
condition|(
operator|(
name|in_flags
operator|&
name|EF_ARM_APCS_26
operator|)
operator|!=
operator|(
name|out_flags
operator|&
name|EF_ARM_APCS_26
operator|)
condition|)
block|{
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"ERROR: %B is compiled for APCS-%d, whereas target %B uses APCS-%d"
argument_list|)
argument_list|,
name|ibfd
argument_list|,
name|obfd
argument_list|,
name|in_flags
operator|&
name|EF_ARM_APCS_26
condition|?
literal|26
else|:
literal|32
argument_list|,
name|out_flags
operator|&
name|EF_ARM_APCS_26
condition|?
literal|26
else|:
literal|32
argument_list|)
expr_stmt|;
name|flags_compatible
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|in_flags
operator|&
name|EF_ARM_APCS_FLOAT
operator|)
operator|!=
operator|(
name|out_flags
operator|&
name|EF_ARM_APCS_FLOAT
operator|)
condition|)
block|{
if|if
condition|(
name|in_flags
operator|&
name|EF_ARM_APCS_FLOAT
condition|)
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"ERROR: %B passes floats in float registers, whereas %B passes them in integer registers"
argument_list|)
argument_list|,
name|ibfd
argument_list|,
name|obfd
argument_list|)
expr_stmt|;
else|else
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"ERROR: %B passes floats in integer registers, whereas %B passes them in float registers"
argument_list|)
argument_list|,
name|ibfd
argument_list|,
name|obfd
argument_list|)
expr_stmt|;
name|flags_compatible
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|in_flags
operator|&
name|EF_ARM_VFP_FLOAT
operator|)
operator|!=
operator|(
name|out_flags
operator|&
name|EF_ARM_VFP_FLOAT
operator|)
condition|)
block|{
if|if
condition|(
name|in_flags
operator|&
name|EF_ARM_VFP_FLOAT
condition|)
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"ERROR: %B uses VFP instructions, whereas %B does not"
argument_list|)
argument_list|,
name|ibfd
argument_list|,
name|obfd
argument_list|)
expr_stmt|;
else|else
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"ERROR: %B uses FPA instructions, whereas %B does not"
argument_list|)
argument_list|,
name|ibfd
argument_list|,
name|obfd
argument_list|)
expr_stmt|;
name|flags_compatible
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|in_flags
operator|&
name|EF_ARM_MAVERICK_FLOAT
operator|)
operator|!=
operator|(
name|out_flags
operator|&
name|EF_ARM_MAVERICK_FLOAT
operator|)
condition|)
block|{
if|if
condition|(
name|in_flags
operator|&
name|EF_ARM_MAVERICK_FLOAT
condition|)
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"ERROR: %B uses Maverick instructions, whereas %B does not"
argument_list|)
argument_list|,
name|ibfd
argument_list|,
name|obfd
argument_list|)
expr_stmt|;
else|else
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"ERROR: %B does not use Maverick instructions, whereas %B does"
argument_list|)
argument_list|,
name|ibfd
argument_list|,
name|obfd
argument_list|)
expr_stmt|;
name|flags_compatible
operator|=
name|FALSE
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|EF_ARM_SOFT_FLOAT
if|if
condition|(
operator|(
name|in_flags
operator|&
name|EF_ARM_SOFT_FLOAT
operator|)
operator|!=
operator|(
name|out_flags
operator|&
name|EF_ARM_SOFT_FLOAT
operator|)
condition|)
block|{
comment|/* We can allow interworking between code that is VFP format 	     layout, and uses either soft float or integer regs for 	     passing floating point arguments and results.  We already 	     know that the APCS_FLOAT flags match; similarly for VFP 	     flags.  */
if|if
condition|(
operator|(
name|in_flags
operator|&
name|EF_ARM_APCS_FLOAT
operator|)
operator|!=
literal|0
operator|||
operator|(
name|in_flags
operator|&
name|EF_ARM_VFP_FLOAT
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|in_flags
operator|&
name|EF_ARM_SOFT_FLOAT
condition|)
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"ERROR: %B uses software FP, whereas %B uses hardware FP"
argument_list|)
argument_list|,
name|ibfd
argument_list|,
name|obfd
argument_list|)
expr_stmt|;
else|else
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"ERROR: %B uses hardware FP, whereas %B uses software FP"
argument_list|)
argument_list|,
name|ibfd
argument_list|,
name|obfd
argument_list|)
expr_stmt|;
name|flags_compatible
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* Interworking mismatch is only a warning.  */
if|if
condition|(
operator|(
name|in_flags
operator|&
name|EF_ARM_INTERWORK
operator|)
operator|!=
operator|(
name|out_flags
operator|&
name|EF_ARM_INTERWORK
operator|)
condition|)
block|{
if|if
condition|(
name|in_flags
operator|&
name|EF_ARM_INTERWORK
condition|)
block|{
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"Warning: %B supports interworking, whereas %B does not"
argument_list|)
argument_list|,
name|ibfd
argument_list|,
name|obfd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"Warning: %B does not support interworking, whereas %B does"
argument_list|)
argument_list|,
name|ibfd
argument_list|,
name|obfd
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|flags_compatible
return|;
block|}
end_function

begin_comment
comment|/* Display the flags field.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_arm_print_private_bfd_data
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|FILE
modifier|*
name|file
init|=
operator|(
name|FILE
operator|*
operator|)
name|ptr
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|abfd
operator|!=
name|NULL
operator|&&
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Print normal ELF private data.  */
name|_bfd_elf_print_private_bfd_data
argument_list|(
name|abfd
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|flags
operator|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
comment|/* Ignore init flag - it may not be set, despite the flags field      containing valid data.  */
comment|/* xgettext:c-format */
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"private flags = %lx:"
argument_list|)
argument_list|,
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|EF_ARM_EABI_VERSION
argument_list|(
name|flags
argument_list|)
condition|)
block|{
case|case
name|EF_ARM_EABI_UNKNOWN
case|:
comment|/* The following flag bits are GNU extensions and not part of the 	 official ARM ELF extended ABI.  Hence they are only decoded if 	 the EABI version is not set.  */
if|if
condition|(
name|flags
operator|&
name|EF_ARM_INTERWORK
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [interworking enabled]"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|EF_ARM_APCS_26
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" [APCS-26]"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" [APCS-32]"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|EF_ARM_VFP_FLOAT
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [VFP float format]"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|EF_ARM_MAVERICK_FLOAT
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [Maverick float format]"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [FPA float format]"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|EF_ARM_APCS_FLOAT
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [floats passed in float registers]"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|EF_ARM_PIC
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [position independent]"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|EF_ARM_NEW_ABI
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [new ABI]"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|EF_ARM_OLD_ABI
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [old ABI]"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|EF_ARM_SOFT_FLOAT
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [software FP]"
argument_list|)
argument_list|)
expr_stmt|;
name|flags
operator|&=
operator|~
operator|(
name|EF_ARM_INTERWORK
operator||
name|EF_ARM_APCS_26
operator||
name|EF_ARM_APCS_FLOAT
operator||
name|EF_ARM_PIC
operator||
name|EF_ARM_NEW_ABI
operator||
name|EF_ARM_OLD_ABI
operator||
name|EF_ARM_SOFT_FLOAT
operator||
name|EF_ARM_VFP_FLOAT
operator||
name|EF_ARM_MAVERICK_FLOAT
operator|)
expr_stmt|;
break|break;
case|case
name|EF_ARM_EABI_VER1
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [Version1 EABI]"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|EF_ARM_SYMSARESORTED
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [sorted symbol table]"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [unsorted symbol table]"
argument_list|)
argument_list|)
expr_stmt|;
name|flags
operator|&=
operator|~
name|EF_ARM_SYMSARESORTED
expr_stmt|;
break|break;
case|case
name|EF_ARM_EABI_VER2
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [Version2 EABI]"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|EF_ARM_SYMSARESORTED
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [sorted symbol table]"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [unsorted symbol table]"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|EF_ARM_DYNSYMSUSESEGIDX
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [dynamic symbols use segment index]"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|EF_ARM_MAPSYMSFIRST
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [mapping symbols precede others]"
argument_list|)
argument_list|)
expr_stmt|;
name|flags
operator|&=
operator|~
operator|(
name|EF_ARM_SYMSARESORTED
operator||
name|EF_ARM_DYNSYMSUSESEGIDX
operator||
name|EF_ARM_MAPSYMSFIRST
operator|)
expr_stmt|;
break|break;
case|case
name|EF_ARM_EABI_VER3
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [Version3 EABI]"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_ARM_EABI_VER4
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [Version4 EABI]"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|eabi
goto|;
case|case
name|EF_ARM_EABI_VER5
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [Version5 EABI]"
argument_list|)
argument_list|)
expr_stmt|;
name|eabi
label|:
if|if
condition|(
name|flags
operator|&
name|EF_ARM_BE8
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [BE8]"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|EF_ARM_LE8
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [LE8]"
argument_list|)
argument_list|)
expr_stmt|;
name|flags
operator|&=
operator|~
operator|(
name|EF_ARM_LE8
operator||
name|EF_ARM_BE8
operator|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"<EABI version unrecognised>"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|flags
operator|&=
operator|~
name|EF_ARM_EABIMASK
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|EF_ARM_RELEXEC
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [relocatable executable]"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|EF_ARM_HASENTRY
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [has entry point]"
argument_list|)
argument_list|)
expr_stmt|;
name|flags
operator|&=
operator|~
operator|(
name|EF_ARM_RELEXEC
operator||
name|EF_ARM_HASENTRY
operator|)
expr_stmt|;
if|if
condition|(
name|flags
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"<Unrecognised flag bits set>"
argument_list|)
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|elf32_arm_get_symbol_type
parameter_list|(
name|Elf_Internal_Sym
modifier|*
name|elf_sym
parameter_list|,
name|int
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|ELF_ST_TYPE
argument_list|(
name|elf_sym
operator|->
name|st_info
argument_list|)
condition|)
block|{
case|case
name|STT_ARM_TFUNC
case|:
return|return
name|ELF_ST_TYPE
argument_list|(
name|elf_sym
operator|->
name|st_info
argument_list|)
return|;
case|case
name|STT_ARM_16BIT
case|:
comment|/* If the symbol is not an object, return the STT_ARM_16BIT flag. 	 This allows us to distinguish between data used by Thumb instructions 	 and non-data (which is probably code) inside Thumb regions of an 	 executable.  */
if|if
condition|(
name|type
operator|!=
name|STT_OBJECT
operator|&&
name|type
operator|!=
name|STT_TLS
condition|)
return|return
name|ELF_ST_TYPE
argument_list|(
name|elf_sym
operator|->
name|st_info
argument_list|)
return|;
break|break;
default|default:
break|break;
block|}
return|return
name|type
return|;
block|}
end_function

begin_function
specifier|static
name|asection
modifier|*
name|elf32_arm_gc_mark_hook
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|rel
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|)
block|{
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
switch|switch
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_ARM_GNU_VTINHERIT
case|:
case|case
name|R_ARM_GNU_VTENTRY
case|:
return|return
name|NULL
return|;
block|}
return|return
name|_bfd_elf_gc_mark_hook
argument_list|(
name|sec
argument_list|,
name|info
argument_list|,
name|rel
argument_list|,
name|h
argument_list|,
name|sym
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Update the got entry reference counts for the section being removed.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_arm_gc_sweep_hook
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|bfd_signed_vma
modifier|*
name|local_got_refcounts
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|,
modifier|*
name|relend
decl_stmt|;
name|struct
name|elf32_arm_link_hash_table
modifier|*
name|globals
decl_stmt|;
name|globals
operator|=
name|elf32_arm_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|local_dynrel
operator|=
name|NULL
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|local_got_refcounts
operator|=
name|elf_local_got_refcounts
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
init|=
name|NULL
decl_stmt|;
name|int
name|r_type
decl_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|>=
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
block|}
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|arm_real_reloc_type
argument_list|(
name|globals
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_ARM_GOT32
case|:
case|case
name|R_ARM_GOT_PREL
case|:
case|case
name|R_ARM_TLS_GD32
case|:
case|case
name|R_ARM_TLS_IE32
case|:
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|refcount
operator|>
literal|0
condition|)
name|h
operator|->
name|got
operator|.
name|refcount
operator|-=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|local_got_refcounts
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|local_got_refcounts
index|[
name|r_symndx
index|]
operator|>
literal|0
condition|)
name|local_got_refcounts
index|[
name|r_symndx
index|]
operator|-=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|R_ARM_TLS_LDM32
case|:
name|elf32_arm_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|tls_ldm_got
operator|.
name|refcount
operator|-=
literal|1
expr_stmt|;
break|break;
case|case
name|R_ARM_ABS32
case|:
case|case
name|R_ARM_ABS32_NOI
case|:
case|case
name|R_ARM_REL32
case|:
case|case
name|R_ARM_REL32_NOI
case|:
case|case
name|R_ARM_PC24
case|:
case|case
name|R_ARM_PLT32
case|:
case|case
name|R_ARM_CALL
case|:
case|case
name|R_ARM_JUMP24
case|:
case|case
name|R_ARM_PREL31
case|:
case|case
name|R_ARM_THM_CALL
case|:
case|case
name|R_ARM_MOVW_ABS_NC
case|:
case|case
name|R_ARM_MOVT_ABS
case|:
case|case
name|R_ARM_MOVW_PREL_NC
case|:
case|case
name|R_ARM_MOVT_PREL
case|:
case|case
name|R_ARM_THM_MOVW_ABS_NC
case|:
case|case
name|R_ARM_THM_MOVT_ABS
case|:
case|case
name|R_ARM_THM_MOVW_PREL_NC
case|:
case|case
name|R_ARM_THM_MOVT_PREL
case|:
comment|/* Should the interworking branches be here also?  */
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|struct
name|elf32_arm_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|struct
name|elf32_arm_relocs_copied
modifier|*
modifier|*
name|pp
decl_stmt|;
name|struct
name|elf32_arm_relocs_copied
modifier|*
name|p
decl_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|elf32_arm_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|refcount
operator|>
literal|0
condition|)
block|{
name|h
operator|->
name|plt
operator|.
name|refcount
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|==
name|R_ARM_THM_CALL
condition|)
name|eh
operator|->
name|plt_thumb_refcount
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|r_type
operator|==
name|R_ARM_ABS32
operator|||
name|r_type
operator|==
name|R_ARM_REL32
operator|||
name|r_type
operator|==
name|R_ARM_ABS32_NOI
operator|||
name|r_type
operator|==
name|R_ARM_REL32_NOI
condition|)
block|{
for|for
control|(
name|pp
operator|=
operator|&
name|eh
operator|->
name|relocs_copied
init|;
operator|(
name|p
operator|=
operator|*
name|pp
operator|)
operator|!=
name|NULL
condition|;
name|pp
operator|=
operator|&
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|section
operator|==
name|sec
condition|)
block|{
name|p
operator|->
name|count
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|==
name|R_ARM_REL32
operator|||
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|==
name|R_ARM_REL32_NOI
condition|)
name|p
operator|->
name|pc_count
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|count
operator|==
literal|0
condition|)
operator|*
name|pp
operator|=
name|p
operator|->
name|next
expr_stmt|;
break|break;
block|}
block|}
block|}
break|break;
default|default:
break|break;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Look through the relocs for a section during the first phase.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_arm_check_relocs
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes_end
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel_end
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|sreloc
decl_stmt|;
name|bfd_vma
modifier|*
name|local_got_offsets
decl_stmt|;
name|struct
name|elf32_arm_link_hash_table
modifier|*
name|htab
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
return|return
name|TRUE
return|;
name|htab
operator|=
name|elf32_arm_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|sreloc
operator|=
name|NULL
expr_stmt|;
comment|/* Create dynamic sections for relocatable executables so that we can      copy relocations.  */
if|if
condition|(
name|htab
operator|->
name|root
operator|.
name|is_relocatable_executable
operator|&&
operator|!
name|htab
operator|->
name|root
operator|.
name|dynamic_sections_created
condition|)
block|{
if|if
condition|(
operator|!
name|_bfd_elf_link_create_dynamic_sections
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|local_got_offsets
operator|=
name|elf_local_got_offsets
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|sym_hashes_end
operator|=
name|sym_hashes
operator|+
name|symtab_hdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf32_External_Sym
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|elf_bad_symtab
argument_list|(
name|abfd
argument_list|)
condition|)
name|sym_hashes_end
operator|-=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|rel_end
operator|=
name|relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|rel_end
condition|;
name|rel
operator|++
control|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|elf32_arm_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|int
name|r_type
decl_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|arm_real_reloc_type
argument_list|(
name|htab
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|>=
name|NUM_SHDR_ENTRIES
argument_list|(
name|symtab_hdr
argument_list|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: bad symbol index: %d"
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|r_symndx
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
name|h
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
block|}
name|eh
operator|=
operator|(
expr|struct
name|elf32_arm_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_ARM_GOT32
case|:
case|case
name|R_ARM_GOT_PREL
case|:
case|case
name|R_ARM_TLS_GD32
case|:
case|case
name|R_ARM_TLS_IE32
case|:
comment|/* This symbol requires a global offset table entry.  */
block|{
name|int
name|tls_type
decl_stmt|,
name|old_tls_type
decl_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_ARM_TLS_GD32
case|:
name|tls_type
operator|=
name|GOT_TLS_GD
expr_stmt|;
break|break;
case|case
name|R_ARM_TLS_IE32
case|:
name|tls_type
operator|=
name|GOT_TLS_IE
expr_stmt|;
break|break;
default|default:
name|tls_type
operator|=
name|GOT_NORMAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|h
operator|->
name|got
operator|.
name|refcount
operator|++
expr_stmt|;
name|old_tls_type
operator|=
name|elf32_arm_hash_entry
argument_list|(
name|h
argument_list|)
operator|->
name|tls_type
expr_stmt|;
block|}
else|else
block|{
name|bfd_signed_vma
modifier|*
name|local_got_refcounts
decl_stmt|;
comment|/* This is a global offset table entry for a local symbol.  */
name|local_got_refcounts
operator|=
name|elf_local_got_refcounts
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_got_refcounts
operator|==
name|NULL
condition|)
block|{
name|bfd_size_type
name|size
decl_stmt|;
name|size
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|size
operator|*=
operator|(
sizeof|sizeof
argument_list|(
name|bfd_signed_vma
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|)
expr_stmt|;
name|local_got_refcounts
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_got_refcounts
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|elf_local_got_refcounts
argument_list|(
name|abfd
argument_list|)
operator|=
name|local_got_refcounts
expr_stmt|;
name|elf32_arm_local_got_tls_type
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|local_got_refcounts
operator|+
name|symtab_hdr
operator|->
name|sh_info
operator|)
expr_stmt|;
block|}
name|local_got_refcounts
index|[
name|r_symndx
index|]
operator|+=
literal|1
expr_stmt|;
name|old_tls_type
operator|=
name|elf32_arm_local_got_tls_type
argument_list|(
name|abfd
argument_list|)
index|[
name|r_symndx
index|]
expr_stmt|;
block|}
comment|/* We will already have issued an error message if there is a 		 TLS / non-TLS mismatch, based on the symbol type.  We don't 		 support any linker relaxations.  So just combine any TLS 		 types needed.  */
if|if
condition|(
name|old_tls_type
operator|!=
name|GOT_UNKNOWN
operator|&&
name|old_tls_type
operator|!=
name|GOT_NORMAL
operator|&&
name|tls_type
operator|!=
name|GOT_NORMAL
condition|)
name|tls_type
operator||=
name|old_tls_type
expr_stmt|;
if|if
condition|(
name|old_tls_type
operator|!=
name|tls_type
condition|)
block|{
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|elf32_arm_hash_entry
argument_list|(
name|h
argument_list|)
operator|->
name|tls_type
operator|=
name|tls_type
expr_stmt|;
else|else
name|elf32_arm_local_got_tls_type
argument_list|(
name|abfd
argument_list|)
index|[
name|r_symndx
index|]
operator|=
name|tls_type
expr_stmt|;
block|}
block|}
comment|/* Fall through */
case|case
name|R_ARM_TLS_LDM32
case|:
if|if
condition|(
name|r_type
operator|==
name|R_ARM_TLS_LDM32
condition|)
name|htab
operator|->
name|tls_ldm_got
operator|.
name|refcount
operator|++
expr_stmt|;
comment|/* Fall through */
case|case
name|R_ARM_GOTOFF32
case|:
case|case
name|R_ARM_GOTPC
case|:
if|if
condition|(
name|htab
operator|->
name|sgot
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|htab
operator|->
name|root
operator|.
name|dynobj
operator|==
name|NULL
condition|)
name|htab
operator|->
name|root
operator|.
name|dynobj
operator|=
name|abfd
expr_stmt|;
if|if
condition|(
operator|!
name|create_got_section
argument_list|(
name|htab
operator|->
name|root
operator|.
name|dynobj
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
break|break;
case|case
name|R_ARM_ABS12
case|:
comment|/* VxWorks uses dynamic R_ARM_ABS12 relocations for 	       ldr __GOTT_INDEX__ offsets.  */
if|if
condition|(
operator|!
name|htab
operator|->
name|vxworks_p
condition|)
break|break;
comment|/* Fall through */
case|case
name|R_ARM_ABS32
case|:
case|case
name|R_ARM_ABS32_NOI
case|:
case|case
name|R_ARM_REL32
case|:
case|case
name|R_ARM_REL32_NOI
case|:
case|case
name|R_ARM_PC24
case|:
case|case
name|R_ARM_PLT32
case|:
case|case
name|R_ARM_CALL
case|:
case|case
name|R_ARM_JUMP24
case|:
case|case
name|R_ARM_PREL31
case|:
case|case
name|R_ARM_THM_CALL
case|:
case|case
name|R_ARM_MOVW_ABS_NC
case|:
case|case
name|R_ARM_MOVT_ABS
case|:
case|case
name|R_ARM_MOVW_PREL_NC
case|:
case|case
name|R_ARM_MOVT_PREL
case|:
case|case
name|R_ARM_THM_MOVW_ABS_NC
case|:
case|case
name|R_ARM_THM_MOVT_ABS
case|:
case|case
name|R_ARM_THM_MOVW_PREL_NC
case|:
case|case
name|R_ARM_THM_MOVT_PREL
case|:
comment|/* Should the interworking branches be listed here?  */
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
comment|/* If this reloc is in a read-only section, we might 		   need a copy reloc.  We can't check reliably at this 		   stage whether the section is read-only, as input 		   sections have not yet been mapped to output sections. 		   Tentatively set the flag for now, and correct in 		   adjust_dynamic_symbol.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
name|h
operator|->
name|non_got_ref
operator|=
literal|1
expr_stmt|;
comment|/* We may need a .plt entry if the function this reloc 		   refers to is in a different object.  We can't tell for 		   sure yet, because something later might force the 		   symbol local.  */
if|if
condition|(
name|r_type
operator|!=
name|R_ARM_ABS32
operator|&&
name|r_type
operator|!=
name|R_ARM_REL32
operator|&&
name|r_type
operator|!=
name|R_ARM_ABS32_NOI
operator|&&
name|r_type
operator|!=
name|R_ARM_REL32_NOI
operator|&&
name|r_type
operator|!=
name|R_ARM_ABS12
condition|)
name|h
operator|->
name|needs_plt
operator|=
literal|1
expr_stmt|;
comment|/* If we create a PLT entry, this relocation will reference 		   it, even if it's an ABS32 relocation.  */
name|h
operator|->
name|plt
operator|.
name|refcount
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_ARM_THM_CALL
condition|)
name|eh
operator|->
name|plt_thumb_refcount
operator|+=
literal|1
expr_stmt|;
block|}
comment|/* If we are creating a shared library or relocatable executable, 	       and this is a reloc against a global symbol, or a non PC 	       relative reloc against a local symbol, then we need to copy 	       the reloc into the shared library.  However, if we are linking 	       with -Bsymbolic, we do not need to copy a reloc against a                global symbol which is defined in an object we are                including in the link (i.e., DEF_REGULAR is set).  At                this point we have not seen all the input files, so it is                possible that DEF_REGULAR is not set now but will be set                later (it is never cleared).  We account for that                possibility below by storing information in the                relocs_copied field of the hash table entry.  */
if|if
condition|(
operator|(
name|info
operator|->
name|shared
operator|||
name|htab
operator|->
name|root
operator|.
name|is_relocatable_executable
operator|)
operator|&&
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|r_type
operator|==
name|R_ARM_ABS32
operator|||
name|r_type
operator|==
name|R_ARM_ABS32_NOI
operator|)
operator|||
operator|(
name|h
operator|!=
name|NULL
operator|&&
operator|!
name|h
operator|->
name|needs_plt
operator|&&
operator|(
operator|!
name|info
operator|->
name|symbolic
operator|||
operator|!
name|h
operator|->
name|def_regular
operator|)
operator|)
operator|)
condition|)
block|{
name|struct
name|elf32_arm_relocs_copied
modifier|*
name|p
decl_stmt|,
modifier|*
modifier|*
name|head
decl_stmt|;
comment|/* When creating a shared object, we must copy these                    reloc types into the output file.  We create a reloc                    section in dynobj and make room for this reloc.  */
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
operator|(
name|bfd_elf_string_from_elf_section
argument_list|(
name|abfd
argument_list|,
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_shstrndx
argument_list|,
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|rel_hdr
operator|.
name|sh_name
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|BFD_ASSERT
argument_list|(
name|reloc_section_p
argument_list|(
name|htab
argument_list|,
name|name
argument_list|,
name|sec
argument_list|)
argument_list|)
expr_stmt|;
name|sreloc
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
block|{
name|flagword
name|flags
decl_stmt|;
name|flags
operator|=
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_READONLY
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
comment|/* BPABI objects never have dynamic 			       relocations mapped.  */
operator|&&
operator|!
name|htab
operator|->
name|symbian_p
condition|)
name|flags
operator||=
name|SEC_ALLOC
operator||
name|SEC_LOAD
expr_stmt|;
name|sreloc
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|dynobj
argument_list|,
name|name
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|sreloc
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|sreloc
operator|=
name|sreloc
expr_stmt|;
block|}
comment|/* If this is a global symbol, we count the number of 		   relocations we need for this symbol.  */
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|head
operator|=
operator|&
operator|(
operator|(
expr|struct
name|elf32_arm_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|relocs_copied
expr_stmt|;
block|}
else|else
block|{
comment|/* Track dynamic relocs needed for local syms too. 		       We really need local syms available to do this 		       easily.  Oh well.  */
name|asection
modifier|*
name|s
decl_stmt|;
name|void
modifier|*
name|vpp
decl_stmt|;
name|s
operator|=
name|bfd_section_from_r_symndx
argument_list|(
name|abfd
argument_list|,
operator|&
name|htab
operator|->
name|sym_sec
argument_list|,
name|sec
argument_list|,
name|r_symndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|vpp
operator|=
operator|&
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|local_dynrel
expr_stmt|;
name|head
operator|=
operator|(
expr|struct
name|elf32_arm_relocs_copied
operator|*
operator|*
operator|)
name|vpp
expr_stmt|;
block|}
name|p
operator|=
operator|*
name|head
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|p
operator|->
name|section
operator|!=
name|sec
condition|)
block|{
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
expr|*
name|p
decl_stmt|;
name|p
operator|=
name|bfd_alloc
argument_list|(
name|htab
operator|->
name|root
operator|.
name|dynobj
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|p
operator|->
name|next
operator|=
operator|*
name|head
expr_stmt|;
operator|*
name|head
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|section
operator|=
name|sec
expr_stmt|;
name|p
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|pc_count
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|r_type
operator|==
name|R_ARM_REL32
operator|||
name|r_type
operator|==
name|R_ARM_REL32_NOI
condition|)
name|p
operator|->
name|pc_count
operator|+=
literal|1
expr_stmt|;
name|p
operator|->
name|count
operator|+=
literal|1
expr_stmt|;
block|}
break|break;
comment|/* This relocation describes the C++ object vtable hierarchy.            Reconstruct it for later use during GC.  */
case|case
name|R_ARM_GNU_VTINHERIT
case|:
if|if
condition|(
operator|!
name|bfd_elf_gc_record_vtinherit
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|h
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
comment|/* This relocation describes which C++ vtable entries are actually            used.  Record for later use during GC.  */
case|case
name|R_ARM_GNU_VTENTRY
case|:
if|if
condition|(
operator|!
name|bfd_elf_gc_record_vtentry
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|h
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Unwinding tables are not referenced directly.  This pass marks them as    required if the corresponding code section is marked.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_arm_gc_mark_extra_sections
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|elf_gc_mark_hook_fn
name|gc_mark_hook
parameter_list|)
block|{
name|bfd
modifier|*
name|sub
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
modifier|*
name|elf_shdrp
decl_stmt|;
name|bfd_boolean
name|again
decl_stmt|;
comment|/* Marking EH data may cause additional code sections to be marked,      requiring multiple passes.  */
name|again
operator|=
name|TRUE
expr_stmt|;
while|while
condition|(
name|again
condition|)
block|{
name|again
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|sub
operator|=
name|info
operator|->
name|input_bfds
init|;
name|sub
operator|!=
name|NULL
condition|;
name|sub
operator|=
name|sub
operator|->
name|link_next
control|)
block|{
name|asection
modifier|*
name|o
decl_stmt|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|sub
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
continue|continue;
name|elf_shdrp
operator|=
name|elf_elfsections
argument_list|(
name|sub
argument_list|)
expr_stmt|;
for|for
control|(
name|o
operator|=
name|sub
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
name|hdr
operator|=
operator|&
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|this_hdr
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|sh_type
operator|==
name|SHT_ARM_EXIDX
operator|&&
name|hdr
operator|->
name|sh_link
operator|&&
operator|!
name|o
operator|->
name|gc_mark
operator|&&
name|elf_shdrp
index|[
name|hdr
operator|->
name|sh_link
index|]
operator|->
name|bfd_section
operator|->
name|gc_mark
condition|)
block|{
name|again
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|_bfd_elf_gc_mark
argument_list|(
name|info
argument_list|,
name|o
argument_list|,
name|gc_mark_hook
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Treat mapping symbols as special target symbols.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_arm_is_target_special_symbol
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asymbol
modifier|*
name|sym
parameter_list|)
block|{
return|return
name|bfd_is_arm_special_symbol_name
argument_list|(
name|sym
operator|->
name|name
argument_list|,
name|BFD_ARM_SPECIAL_SYM_TYPE_ANY
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This is a copy of elf_find_function() from elf.c except that    ARM mapping symbols are ignored when looking for function names    and STT_ARM_TFUNC is considered to a function type.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|arm_elf_find_function
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|,
name|asymbol
modifier|*
modifier|*
name|symbols
parameter_list|,
name|bfd_vma
name|offset
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|filename_ptr
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|functionname_ptr
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|filename
init|=
name|NULL
decl_stmt|;
name|asymbol
modifier|*
name|func
init|=
name|NULL
decl_stmt|;
name|bfd_vma
name|low_func
init|=
literal|0
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|symbols
init|;
operator|*
name|p
operator|!=
name|NULL
condition|;
name|p
operator|++
control|)
block|{
name|elf_symbol_type
modifier|*
name|q
decl_stmt|;
name|q
operator|=
operator|(
name|elf_symbol_type
operator|*
operator|)
operator|*
name|p
expr_stmt|;
switch|switch
condition|(
name|ELF_ST_TYPE
argument_list|(
name|q
operator|->
name|internal_elf_sym
operator|.
name|st_info
argument_list|)
condition|)
block|{
default|default:
break|break;
case|case
name|STT_FILE
case|:
name|filename
operator|=
name|bfd_asymbol_name
argument_list|(
operator|&
name|q
operator|->
name|symbol
argument_list|)
expr_stmt|;
break|break;
case|case
name|STT_FUNC
case|:
case|case
name|STT_ARM_TFUNC
case|:
case|case
name|STT_NOTYPE
case|:
comment|/* Skip mapping symbols.  */
if|if
condition|(
operator|(
name|q
operator|->
name|symbol
operator|.
name|flags
operator|&
name|BSF_LOCAL
operator|)
operator|&&
name|bfd_is_arm_special_symbol_name
argument_list|(
name|q
operator|->
name|symbol
operator|.
name|name
argument_list|,
name|BFD_ARM_SPECIAL_SYM_TYPE_ANY
argument_list|)
condition|)
continue|continue;
comment|/* Fall through.  */
if|if
condition|(
name|bfd_get_section
argument_list|(
operator|&
name|q
operator|->
name|symbol
argument_list|)
operator|==
name|section
operator|&&
name|q
operator|->
name|symbol
operator|.
name|value
operator|>=
name|low_func
operator|&&
name|q
operator|->
name|symbol
operator|.
name|value
operator|<=
name|offset
condition|)
block|{
name|func
operator|=
operator|(
name|asymbol
operator|*
operator|)
name|q
expr_stmt|;
name|low_func
operator|=
name|q
operator|->
name|symbol
operator|.
name|value
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|func
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|filename_ptr
condition|)
operator|*
name|filename_ptr
operator|=
name|filename
expr_stmt|;
if|if
condition|(
name|functionname_ptr
condition|)
operator|*
name|functionname_ptr
operator|=
name|bfd_asymbol_name
argument_list|(
name|func
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Find the nearest line to a particular section and offset, for error    reporting.   This code is a duplicate of the code in elf.c, except    that it uses arm_elf_find_function.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_arm_find_nearest_line
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|,
name|asymbol
modifier|*
modifier|*
name|symbols
parameter_list|,
name|bfd_vma
name|offset
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|filename_ptr
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|functionname_ptr
parameter_list|,
name|unsigned
name|int
modifier|*
name|line_ptr
parameter_list|)
block|{
name|bfd_boolean
name|found
init|=
name|FALSE
decl_stmt|;
comment|/* We skip _bfd_dwarf1_find_nearest_line since no known ARM toolchain uses it.  */
if|if
condition|(
name|_bfd_dwarf2_find_nearest_line
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|symbols
argument_list|,
name|offset
argument_list|,
name|filename_ptr
argument_list|,
name|functionname_ptr
argument_list|,
name|line_ptr
argument_list|,
literal|0
argument_list|,
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|dwarf2_find_line_info
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|functionname_ptr
condition|)
name|arm_elf_find_function
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|symbols
argument_list|,
name|offset
argument_list|,
operator|*
name|filename_ptr
condition|?
name|NULL
else|:
name|filename_ptr
argument_list|,
name|functionname_ptr
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
operator|!
name|_bfd_stab_section_find_nearest_line
argument_list|(
name|abfd
argument_list|,
name|symbols
argument_list|,
name|section
argument_list|,
name|offset
argument_list|,
operator|&
name|found
argument_list|,
name|filename_ptr
argument_list|,
name|functionname_ptr
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|line_info
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|found
operator|&&
operator|(
operator|*
name|functionname_ptr
operator|||
operator|*
name|line_ptr
operator|)
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|symbols
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|arm_elf_find_function
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|symbols
argument_list|,
name|offset
argument_list|,
name|filename_ptr
argument_list|,
name|functionname_ptr
argument_list|)
condition|)
return|return
name|FALSE
return|;
operator|*
name|line_ptr
operator|=
literal|0
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elf32_arm_find_inliner_info
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|filename_ptr
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|functionname_ptr
parameter_list|,
name|unsigned
name|int
modifier|*
name|line_ptr
parameter_list|)
block|{
name|bfd_boolean
name|found
decl_stmt|;
name|found
operator|=
name|_bfd_dwarf2_find_inliner_info
argument_list|(
name|abfd
argument_list|,
name|filename_ptr
argument_list|,
name|functionname_ptr
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|dwarf2_find_line_info
argument_list|)
expr_stmt|;
return|return
name|found
return|;
block|}
end_function

begin_comment
comment|/* Adjust a symbol defined by a dynamic object and referenced by a    regular object.  The current definition is in some section of the    dynamic object, but we're not including those sections.  We have to    change the definition to something the rest of the link can    understand.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_arm_adjust_dynamic_symbol
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|)
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|struct
name|elf32_arm_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|struct
name|elf32_arm_link_hash_table
modifier|*
name|globals
decl_stmt|;
name|globals
operator|=
name|elf32_arm_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
comment|/* Make sure we know what is going on here.  */
name|BFD_ASSERT
argument_list|(
name|dynobj
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|needs_plt
operator|||
name|h
operator|->
name|u
operator|.
name|weakdef
operator|!=
name|NULL
operator|||
operator|(
name|h
operator|->
name|def_dynamic
operator|&&
name|h
operator|->
name|ref_regular
operator|&&
operator|!
name|h
operator|->
name|def_regular
operator|)
operator|)
argument_list|)
expr_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|elf32_arm_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
comment|/* If this is a function, put it in the procedure linkage table.  We      will fill in the contents of the procedure linkage table later,      when we know the address of the .got section.  */
if|if
condition|(
name|h
operator|->
name|type
operator|==
name|STT_FUNC
operator|||
name|h
operator|->
name|type
operator|==
name|STT_ARM_TFUNC
operator|||
name|h
operator|->
name|needs_plt
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|refcount
operator|<=
literal|0
operator|||
name|SYMBOL_CALLS_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
operator|||
operator|(
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|!=
name|STV_DEFAULT
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|)
condition|)
block|{
comment|/* This case can occur if we saw a PLT32 reloc in an input 	     file, but the symbol was never referred to by a dynamic 	     object, or if all references were garbage collected.  In 	     such a case, we don't actually need to build a procedure 	     linkage table, and we can just do a PC24 reloc instead.  */
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
name|eh
operator|->
name|plt_thumb_refcount
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|needs_plt
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
else|else
block|{
comment|/* It's possible that we incorrectly decided a .plt reloc was 	 needed for an R_ARM_PC24 or similar reloc to a non-function sym 	 in check_relocs.  We can't decide accurately between function 	 and non-function syms in check-relocs; Objects loaded later in 	 the link may change h->type.  So fix it now.  */
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
name|eh
operator|->
name|plt_thumb_refcount
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If this is a weak symbol, and there is a real definition, the      processor independent code will have arranged for us to see the      real definition first, and we can just use the same value.  */
if|if
condition|(
name|h
operator|->
name|u
operator|.
name|weakdef
operator|!=
name|NULL
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
argument_list|)
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* If there are no non-GOT references, we do not need a copy      relocation.  */
if|if
condition|(
operator|!
name|h
operator|->
name|non_got_ref
condition|)
return|return
name|TRUE
return|;
comment|/* This is a reference to a symbol defined by a dynamic object which      is not a function.  */
comment|/* If we are creating a shared library, we must presume that the      only references to the symbol are via the global offset table.      For such cases we need not do anything here; the relocations will      be handled correctly by relocate_section.  Relocatable executables      can reference data in shared objects directly, so we don't need to      do anything here.  */
if|if
condition|(
name|info
operator|->
name|shared
operator|||
name|globals
operator|->
name|root
operator|.
name|is_relocatable_executable
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|h
operator|->
name|size
operator|==
literal|0
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"dynamic variable `%s' is zero size"
argument_list|)
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* We must allocate the symbol in our .dynbss section, which will      become part of the .bss section of the executable.  There will be      an entry for this symbol in the .dynsym section.  The dynamic      object will contain position independent code, so all references      from the dynamic object to this symbol will go through the global      offset table.  The dynamic linker will use the .dynsym entry to      determine the address it must put in the global offset table, so      both the dynamic object and the regular object will refer to the      same memory location for the variable.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynbss"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* We must generate a R_ARM_COPY reloc to tell the dynamic linker to      copy the initial value out of the dynamic object and into the      runtime process image.  We need to remember the offset into the      .rel(a).bss section we are going to use.  */
if|if
condition|(
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
name|asection
modifier|*
name|srel
decl_stmt|;
name|srel
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|RELOC_SECTION
argument_list|(
name|globals
argument_list|,
literal|".bss"
argument_list|)
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|srel
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|srel
operator|->
name|size
operator|+=
name|RELOC_SIZE
argument_list|(
name|globals
argument_list|)
expr_stmt|;
name|h
operator|->
name|needs_copy
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|_bfd_elf_adjust_dynamic_copy
argument_list|(
name|h
argument_list|,
name|s
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Allocate space in .plt, .got and associated reloc sections for    dynamic relocs.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|allocate_dynrelocs
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|void
modifier|*
name|inf
parameter_list|)
block|{
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|elf32_arm_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|struct
name|elf32_arm_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|struct
name|elf32_arm_relocs_copied
modifier|*
name|p
decl_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|elf32_arm_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
comment|/* When warning symbols are created, they **replace** the "real"        entry in the hash table, thus we never get to see the real        symbol in a hash traversal.  So look at it now.  */
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|info
operator|=
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|)
name|inf
expr_stmt|;
name|htab
operator|=
name|elf32_arm_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|root
operator|.
name|dynamic_sections_created
operator|&&
name|h
operator|->
name|plt
operator|.
name|refcount
operator|>
literal|0
condition|)
block|{
comment|/* Make sure this symbol is output as a dynamic symbol. 	 Undefined weak syms won't yet be marked as dynamic.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|&&
operator|!
name|h
operator|->
name|forced_local
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|info
operator|->
name|shared
operator|||
name|WILL_CALL_FINISH_DYNAMIC_SYMBOL
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
name|h
argument_list|)
condition|)
block|{
name|asection
modifier|*
name|s
init|=
name|htab
operator|->
name|splt
decl_stmt|;
comment|/* If this is the first .plt entry, make room for the special 	     first entry.  */
if|if
condition|(
name|s
operator|->
name|size
operator|==
literal|0
condition|)
name|s
operator|->
name|size
operator|+=
name|htab
operator|->
name|plt_header_size
expr_stmt|;
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
name|s
operator|->
name|size
expr_stmt|;
comment|/* If we will insert a Thumb trampoline before this PLT, leave room 	     for it.  */
if|if
condition|(
operator|!
name|htab
operator|->
name|use_blx
operator|&&
name|eh
operator|->
name|plt_thumb_refcount
operator|>
literal|0
condition|)
block|{
name|h
operator|->
name|plt
operator|.
name|offset
operator|+=
name|PLT_THUMB_STUB_SIZE
expr_stmt|;
name|s
operator|->
name|size
operator|+=
name|PLT_THUMB_STUB_SIZE
expr_stmt|;
block|}
comment|/* If this symbol is not defined in a regular file, and we are 	     not generating a shared library, then set the symbol to this 	     location in the .plt.  This is required to make function 	     pointers compare as equal between the normal executable and 	     the shared library.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
operator|&&
operator|!
name|h
operator|->
name|def_regular
condition|)
block|{
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|s
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|h
operator|->
name|plt
operator|.
name|offset
expr_stmt|;
comment|/* Make sure the function is not marked as Thumb, in case 		 it is the target of an ABS32 relocation, which will 		 point to the PLT entry.  */
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|h
operator|->
name|type
argument_list|)
operator|==
name|STT_ARM_TFUNC
condition|)
name|h
operator|->
name|type
operator|=
name|ELF_ST_INFO
argument_list|(
name|ELF_ST_BIND
argument_list|(
name|h
operator|->
name|type
argument_list|)
argument_list|,
name|STT_FUNC
argument_list|)
expr_stmt|;
block|}
comment|/* Make room for this entry.  */
name|s
operator|->
name|size
operator|+=
name|htab
operator|->
name|plt_entry_size
expr_stmt|;
if|if
condition|(
operator|!
name|htab
operator|->
name|symbian_p
condition|)
block|{
comment|/* We also need to make an entry in the .got.plt section, which 		 will be placed in the .got section by the linker script.  */
name|eh
operator|->
name|plt_got_offset
operator|=
name|htab
operator|->
name|sgotplt
operator|->
name|size
expr_stmt|;
name|htab
operator|->
name|sgotplt
operator|->
name|size
operator|+=
literal|4
expr_stmt|;
block|}
comment|/* We also need to make an entry in the .rel(a).plt section.  */
name|htab
operator|->
name|srelplt
operator|->
name|size
operator|+=
name|RELOC_SIZE
argument_list|(
name|htab
argument_list|)
expr_stmt|;
comment|/* VxWorks executables have a second set of relocations for 	     each PLT entry.  They go in a separate relocation section, 	     which is processed by the kernel loader.  */
if|if
condition|(
name|htab
operator|->
name|vxworks_p
operator|&&
operator|!
name|info
operator|->
name|shared
condition|)
block|{
comment|/* There is a relocation for the initial PLT entry: 		 an R_ARM_32 relocation for _GLOBAL_OFFSET_TABLE_.  */
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|==
name|htab
operator|->
name|plt_header_size
condition|)
name|htab
operator|->
name|srelplt2
operator|->
name|size
operator|+=
name|RELOC_SIZE
argument_list|(
name|htab
argument_list|)
expr_stmt|;
comment|/* There are two extra relocations for each subsequent 		 PLT entry: an R_ARM_32 relocation for the GOT entry, 		 and an R_ARM_32 relocation for the PLT entry.  */
name|htab
operator|->
name|srelplt2
operator|->
name|size
operator|+=
name|RELOC_SIZE
argument_list|(
name|htab
argument_list|)
operator|*
literal|2
expr_stmt|;
block|}
block|}
else|else
block|{
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
name|h
operator|->
name|needs_plt
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
name|h
operator|->
name|needs_plt
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|refcount
operator|>
literal|0
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_boolean
name|dyn
decl_stmt|;
name|int
name|tls_type
init|=
name|elf32_arm_hash_entry
argument_list|(
name|h
argument_list|)
operator|->
name|tls_type
decl_stmt|;
name|int
name|indx
decl_stmt|;
comment|/* Make sure this symbol is output as a dynamic symbol. 	 Undefined weak syms won't yet be marked as dynamic.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|&&
operator|!
name|h
operator|->
name|forced_local
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|htab
operator|->
name|symbian_p
condition|)
block|{
name|s
operator|=
name|htab
operator|->
name|sgot
expr_stmt|;
name|h
operator|->
name|got
operator|.
name|offset
operator|=
name|s
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|tls_type
operator|==
name|GOT_UNKNOWN
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|tls_type
operator|==
name|GOT_NORMAL
condition|)
comment|/* Non-TLS symbols need one GOT slot.  */
name|s
operator|->
name|size
operator|+=
literal|4
expr_stmt|;
else|else
block|{
if|if
condition|(
name|tls_type
operator|&
name|GOT_TLS_GD
condition|)
comment|/* R_ARM_TLS_GD32 needs 2 consecutive GOT slots.  */
name|s
operator|->
name|size
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
name|tls_type
operator|&
name|GOT_TLS_IE
condition|)
comment|/* R_ARM_TLS_IE32 needs one GOT slot.  */
name|s
operator|->
name|size
operator|+=
literal|4
expr_stmt|;
block|}
name|dyn
operator|=
name|htab
operator|->
name|root
operator|.
name|dynamic_sections_created
expr_stmt|;
name|indx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|WILL_CALL_FINISH_DYNAMIC_SYMBOL
argument_list|(
name|dyn
argument_list|,
name|info
operator|->
name|shared
argument_list|,
name|h
argument_list|)
operator|&&
operator|(
operator|!
name|info
operator|->
name|shared
operator|||
operator|!
name|SYMBOL_REFERENCES_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
operator|)
condition|)
name|indx
operator|=
name|h
operator|->
name|dynindx
expr_stmt|;
if|if
condition|(
name|tls_type
operator|!=
name|GOT_NORMAL
operator|&&
operator|(
name|info
operator|->
name|shared
operator|||
name|indx
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_DEFAULT
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefweak
operator|)
condition|)
block|{
if|if
condition|(
name|tls_type
operator|&
name|GOT_TLS_IE
condition|)
name|htab
operator|->
name|srelgot
operator|->
name|size
operator|+=
name|RELOC_SIZE
argument_list|(
name|htab
argument_list|)
expr_stmt|;
if|if
condition|(
name|tls_type
operator|&
name|GOT_TLS_GD
condition|)
name|htab
operator|->
name|srelgot
operator|->
name|size
operator|+=
name|RELOC_SIZE
argument_list|(
name|htab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tls_type
operator|&
name|GOT_TLS_GD
operator|)
operator|&&
name|indx
operator|!=
literal|0
condition|)
name|htab
operator|->
name|srelgot
operator|->
name|size
operator|+=
name|RELOC_SIZE
argument_list|(
name|htab
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_DEFAULT
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefweak
operator|)
operator|&&
operator|(
name|info
operator|->
name|shared
operator|||
name|WILL_CALL_FINISH_DYNAMIC_SYMBOL
argument_list|(
name|dyn
argument_list|,
literal|0
argument_list|,
name|h
argument_list|)
operator|)
condition|)
name|htab
operator|->
name|srelgot
operator|->
name|size
operator|+=
name|RELOC_SIZE
argument_list|(
name|htab
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|h
operator|->
name|got
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* Allocate stubs for exported Thumb functions on v4t.  */
if|if
condition|(
operator|!
name|htab
operator|->
name|use_blx
operator|&&
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|&&
name|h
operator|->
name|def_regular
operator|&&
name|ELF_ST_TYPE
argument_list|(
name|h
operator|->
name|type
argument_list|)
operator|==
name|STT_ARM_TFUNC
operator|&&
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_DEFAULT
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|th
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|bh
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|myh
decl_stmt|;
name|char
name|name
index|[
literal|1024
index|]
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|bh
operator|=
name|NULL
expr_stmt|;
comment|/* Create a new symbol to regist the real location of the function.  */
name|s
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"__real_%s"
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|s
operator|->
name|owner
argument_list|,
name|name
argument_list|,
name|BSF_GLOBAL
argument_list|,
name|s
argument_list|,
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
argument_list|,
name|NULL
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
operator|&
name|bh
argument_list|)
expr_stmt|;
name|myh
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|bh
expr_stmt|;
name|myh
operator|->
name|type
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_LOCAL
argument_list|,
name|STT_ARM_TFUNC
argument_list|)
expr_stmt|;
name|myh
operator|->
name|forced_local
operator|=
literal|1
expr_stmt|;
name|eh
operator|->
name|export_glue
operator|=
name|myh
expr_stmt|;
name|th
operator|=
name|record_arm_to_thumb_glue
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
expr_stmt|;
comment|/* Point the symbol at the stub.  */
name|h
operator|->
name|type
operator|=
name|ELF_ST_INFO
argument_list|(
name|ELF_ST_BIND
argument_list|(
name|h
operator|->
name|type
argument_list|)
argument_list|,
name|STT_FUNC
argument_list|)
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|th
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|th
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|&
operator|~
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|eh
operator|->
name|relocs_copied
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
comment|/* In the shared -Bsymbolic case, discard space allocated for      dynamic pc-relative relocs against symbols which turn out to be      defined in regular objects.  For the normal shared case, discard      space for pc-relative relocs that have become local due to symbol      visibility changes.  */
if|if
condition|(
name|info
operator|->
name|shared
operator|||
name|htab
operator|->
name|root
operator|.
name|is_relocatable_executable
condition|)
block|{
comment|/* The only relocs that use pc_count are R_ARM_REL32 and          R_ARM_REL32_NOI, which will appear on something like          ".long foo - .".  We want calls to protected symbols to resolve          directly to the function rather than going via the plt.  If people          want function pointer comparisons to work as expected then they          should avoid writing assembly like ".long foo - .".  */
if|if
condition|(
name|SYMBOL_CALLS_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
block|{
name|struct
name|elf32_arm_relocs_copied
modifier|*
modifier|*
name|pp
decl_stmt|;
for|for
control|(
name|pp
operator|=
operator|&
name|eh
operator|->
name|relocs_copied
init|;
operator|(
name|p
operator|=
operator|*
name|pp
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
name|p
operator|->
name|count
operator|-=
name|p
operator|->
name|pc_count
expr_stmt|;
name|p
operator|->
name|pc_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|count
operator|==
literal|0
condition|)
operator|*
name|pp
operator|=
name|p
operator|->
name|next
expr_stmt|;
else|else
name|pp
operator|=
operator|&
name|p
operator|->
name|next
expr_stmt|;
block|}
block|}
comment|/* Also discard relocs on undefined weak syms with non-default          visibility.  */
if|if
condition|(
name|eh
operator|->
name|relocs_copied
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
block|{
if|if
condition|(
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|!=
name|STV_DEFAULT
condition|)
name|eh
operator|->
name|relocs_copied
operator|=
name|NULL
expr_stmt|;
comment|/* Make sure undefined weak symbols are output as a dynamic 	     symbol in PIEs.  */
elseif|else
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|&&
operator|!
name|h
operator|->
name|forced_local
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|htab
operator|->
name|root
operator|.
name|is_relocatable_executable
operator|&&
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_new
condition|)
block|{
comment|/* Output absolute symbols so that we can create relocations 	     against them.  For normal symbols we output a relocation 	     against the section that contains them.  */
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
else|else
block|{
comment|/* For the non-shared case, discard space for relocs against 	 symbols which turn out to need copy relocs or are not 	 dynamic.  */
if|if
condition|(
operator|!
name|h
operator|->
name|non_got_ref
operator|&&
operator|(
operator|(
name|h
operator|->
name|def_dynamic
operator|&&
operator|!
name|h
operator|->
name|def_regular
operator|)
operator|||
operator|(
name|htab
operator|->
name|root
operator|.
name|dynamic_sections_created
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* Make sure this symbol is output as a dynamic symbol. 	     Undefined weak syms won't yet be marked as dynamic.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|&&
operator|!
name|h
operator|->
name|forced_local
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* If that succeeded, we know we'll be keeping all the 	     relocs.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
condition|)
goto|goto
name|keep
goto|;
block|}
name|eh
operator|->
name|relocs_copied
operator|=
name|NULL
expr_stmt|;
name|keep
label|:
empty_stmt|;
block|}
comment|/* Finally, allocate space.  */
for|for
control|(
name|p
operator|=
name|eh
operator|->
name|relocs_copied
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|asection
modifier|*
name|sreloc
init|=
name|elf_section_data
argument_list|(
name|p
operator|->
name|section
argument_list|)
operator|->
name|sreloc
decl_stmt|;
name|sreloc
operator|->
name|size
operator|+=
name|p
operator|->
name|count
operator|*
name|RELOC_SIZE
argument_list|(
name|htab
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Find any dynamic relocs that apply to read-only sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_arm_readonly_dynrelocs
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|PTR
name|inf
parameter_list|)
block|{
name|struct
name|elf32_arm_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|struct
name|elf32_arm_relocs_copied
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|elf32_arm_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
for|for
control|(
name|p
operator|=
name|eh
operator|->
name|relocs_copied
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|asection
modifier|*
name|s
init|=
name|p
operator|->
name|section
decl_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|bfd_link_info
modifier|*
name|info
init|=
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|)
name|inf
decl_stmt|;
name|info
operator|->
name|flags
operator||=
name|DF_TEXTREL
expr_stmt|;
comment|/* Not an error, just cut short the traversal.  */
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|void
name|bfd_elf32_arm_set_byteswap_code
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|int
name|byteswap_code
parameter_list|)
block|{
name|struct
name|elf32_arm_link_hash_table
modifier|*
name|globals
decl_stmt|;
name|globals
operator|=
name|elf32_arm_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|globals
operator|->
name|byteswap_code
operator|=
name|byteswap_code
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the sizes of the dynamic sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_arm_size_dynamic_sections
parameter_list|(
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_boolean
name|plt
decl_stmt|;
name|bfd_boolean
name|relocs
decl_stmt|;
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|struct
name|elf32_arm_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|htab
operator|=
name|elf32_arm_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|dynobj
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|check_use_blx
argument_list|(
name|htab
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
comment|/* Set the contents of the .interp section to the interpreter.  */
if|if
condition|(
name|info
operator|->
name|executable
condition|)
block|{
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".interp"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|size
operator|=
sizeof|sizeof
name|ELF_DYNAMIC_INTERPRETER
expr_stmt|;
name|s
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ELF_DYNAMIC_INTERPRETER
expr_stmt|;
block|}
block|}
comment|/* Set up .got offsets for local syms, and space for local dynamic      relocs.  */
for|for
control|(
name|ibfd
operator|=
name|info
operator|->
name|input_bfds
init|;
name|ibfd
operator|!=
name|NULL
condition|;
name|ibfd
operator|=
name|ibfd
operator|->
name|link_next
control|)
block|{
name|bfd_signed_vma
modifier|*
name|local_got
decl_stmt|;
name|bfd_signed_vma
modifier|*
name|end_local_got
decl_stmt|;
name|char
modifier|*
name|local_tls_type
decl_stmt|;
name|bfd_size_type
name|locsymcount
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|asection
modifier|*
name|srel
decl_stmt|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|ibfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
continue|continue;
for|for
control|(
name|s
operator|=
name|ibfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|struct
name|elf32_arm_relocs_copied
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|local_dynrel
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|bfd_is_abs_section
argument_list|(
name|p
operator|->
name|section
argument_list|)
operator|&&
name|bfd_is_abs_section
argument_list|(
name|p
operator|->
name|section
operator|->
name|output_section
argument_list|)
condition|)
block|{
comment|/* Input section has been discarded, either because 		     it is a copy of a linkonce section or due to 		     linker script /DISCARD/, so we'll be discarding 		     the relocs too.  */
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|count
operator|!=
literal|0
condition|)
block|{
name|srel
operator|=
name|elf_section_data
argument_list|(
name|p
operator|->
name|section
argument_list|)
operator|->
name|sreloc
expr_stmt|;
name|srel
operator|->
name|size
operator|+=
name|p
operator|->
name|count
operator|*
name|RELOC_SIZE
argument_list|(
name|htab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|section
operator|->
name|output_section
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|!=
literal|0
condition|)
name|info
operator|->
name|flags
operator||=
name|DF_TEXTREL
expr_stmt|;
block|}
block|}
block|}
name|local_got
operator|=
name|elf_local_got_refcounts
argument_list|(
name|ibfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|local_got
condition|)
continue|continue;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|locsymcount
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|end_local_got
operator|=
name|local_got
operator|+
name|locsymcount
expr_stmt|;
name|local_tls_type
operator|=
name|elf32_arm_local_got_tls_type
argument_list|(
name|ibfd
argument_list|)
expr_stmt|;
name|s
operator|=
name|htab
operator|->
name|sgot
expr_stmt|;
name|srel
operator|=
name|htab
operator|->
name|srelgot
expr_stmt|;
for|for
control|(
init|;
name|local_got
operator|<
name|end_local_got
condition|;
operator|++
name|local_got
operator|,
operator|++
name|local_tls_type
control|)
block|{
if|if
condition|(
operator|*
name|local_got
operator|>
literal|0
condition|)
block|{
operator|*
name|local_got
operator|=
name|s
operator|->
name|size
expr_stmt|;
if|if
condition|(
operator|*
name|local_tls_type
operator|&
name|GOT_TLS_GD
condition|)
comment|/* TLS_GD relocs need an 8-byte structure in the GOT.  */
name|s
operator|->
name|size
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
operator|*
name|local_tls_type
operator|&
name|GOT_TLS_IE
condition|)
name|s
operator|->
name|size
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
operator|*
name|local_tls_type
operator|==
name|GOT_NORMAL
condition|)
name|s
operator|->
name|size
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
operator|||
operator|*
name|local_tls_type
operator|==
name|GOT_TLS_GD
condition|)
name|srel
operator|->
name|size
operator|+=
name|RELOC_SIZE
argument_list|(
name|htab
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|local_got
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|htab
operator|->
name|tls_ldm_got
operator|.
name|refcount
operator|>
literal|0
condition|)
block|{
comment|/* Allocate two GOT entries and one dynamic relocation (if necessary) 	 for R_ARM_TLS_LDM32 relocations.  */
name|htab
operator|->
name|tls_ldm_got
operator|.
name|offset
operator|=
name|htab
operator|->
name|sgot
operator|->
name|size
expr_stmt|;
name|htab
operator|->
name|sgot
operator|->
name|size
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
name|htab
operator|->
name|srelgot
operator|->
name|size
operator|+=
name|RELOC_SIZE
argument_list|(
name|htab
argument_list|)
expr_stmt|;
block|}
else|else
name|htab
operator|->
name|tls_ldm_got
operator|.
name|offset
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Allocate global sym .plt and .got entries, and space for global      sym dynamic relocs.  */
name|elf_link_hash_traverse
argument_list|(
operator|&
name|htab
operator|->
name|root
argument_list|,
name|allocate_dynrelocs
argument_list|,
name|info
argument_list|)
expr_stmt|;
comment|/* Here we rummage through the found bfds to collect glue information.  */
for|for
control|(
name|ibfd
operator|=
name|info
operator|->
name|input_bfds
init|;
name|ibfd
operator|!=
name|NULL
condition|;
name|ibfd
operator|=
name|ibfd
operator|->
name|link_next
control|)
block|{
comment|/* Initialise mapping tables for code/data.  */
name|bfd_elf32_arm_init_maps
argument_list|(
name|ibfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_elf32_arm_process_before_allocation
argument_list|(
name|ibfd
argument_list|,
name|info
argument_list|)
operator|||
operator|!
name|bfd_elf32_arm_vfp11_erratum_scan
argument_list|(
name|ibfd
argument_list|,
name|info
argument_list|)
condition|)
comment|/* xgettext:c-format */
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"Errors encountered processing file %s"
argument_list|)
argument_list|,
name|ibfd
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
comment|/* The check_relocs and adjust_dynamic_symbol entry points have      determined the sizes of the various dynamic sections.  Allocate      memory for them.  */
name|plt
operator|=
name|FALSE
expr_stmt|;
name|relocs
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|s
operator|=
name|dynobj
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LINKER_CREATED
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* It's OK to base decisions on the section name, because none 	 of the dynobj section names depend upon the input files.  */
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".plt"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Remember whether there is a PLT.  */
name|plt
operator|=
name|s
operator|->
name|size
operator|!=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CONST_STRNEQ
argument_list|(
name|name
argument_list|,
literal|".rel"
argument_list|)
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|size
operator|!=
literal|0
condition|)
block|{
comment|/* Remember whether there are any reloc sections other 		 than .rel(a).plt and .rela.plt.unloaded.  */
if|if
condition|(
name|s
operator|!=
name|htab
operator|->
name|srelplt
operator|&&
name|s
operator|!=
name|htab
operator|->
name|srelplt2
condition|)
name|relocs
operator|=
name|TRUE
expr_stmt|;
comment|/* We use the reloc_count field as a counter if we need 		 to copy relocs into the output file.  */
name|s
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|CONST_STRNEQ
argument_list|(
name|name
argument_list|,
literal|".got"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".dynbss"
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* It's not one of our sections, so don't allocate space.  */
continue|continue;
block|}
if|if
condition|(
name|s
operator|->
name|size
operator|==
literal|0
condition|)
block|{
comment|/* If we don't need this section, strip it from the 	     output file.  This is mostly to handle .rel(a).bss and 	     .rel(a).plt.  We must create both sections in 	     create_dynamic_sections, because they must be created 	     before the linker maps input sections to output 	     sections.  The linker does that before 	     adjust_dynamic_symbol is called, and it is that 	     function which decides whether anything needs to go 	     into these sections.  */
name|s
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* Allocate memory for the section contents.  */
name|s
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|dynobj
argument_list|,
name|s
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
comment|/* Add some entries to the .dynamic section.  We fill in the 	 values later, in elf32_arm_finish_dynamic_sections, but we 	 must add the entries now so that we get the correct size for 	 the .dynamic section.  The DT_DEBUG entry is filled in by the 	 dynamic linker and used by the debugger.  */
define|#
directive|define
name|add_dynamic_entry
parameter_list|(
name|TAG
parameter_list|,
name|VAL
parameter_list|)
define|\
value|_bfd_elf_add_dynamic_entry (info, TAG, VAL)
if|if
condition|(
name|info
operator|->
name|executable
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_DEBUG
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|plt
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PLTGOT
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PLTRELSZ
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PLTREL
argument_list|,
name|htab
operator|->
name|use_rel
condition|?
name|DT_REL
else|:
name|DT_RELA
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_JMPREL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|relocs
condition|)
block|{
if|if
condition|(
name|htab
operator|->
name|use_rel
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_REL
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELSZ
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELENT
argument_list|,
name|RELOC_SIZE
argument_list|(
name|htab
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELA
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELASZ
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELAENT
argument_list|,
name|RELOC_SIZE
argument_list|(
name|htab
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
comment|/* If any dynamic relocs apply to a read-only section, 	 then we need a DT_TEXTREL entry.  */
if|if
condition|(
operator|(
name|info
operator|->
name|flags
operator|&
name|DF_TEXTREL
operator|)
operator|==
literal|0
condition|)
name|elf_link_hash_traverse
argument_list|(
operator|&
name|htab
operator|->
name|root
argument_list|,
name|elf32_arm_readonly_dynrelocs
argument_list|,
operator|(
name|PTR
operator|)
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|info
operator|->
name|flags
operator|&
name|DF_TEXTREL
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_TEXTREL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
undef|#
directive|undef
name|add_dynamic_entry
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Finish up dynamic symbol handling.  We set the contents of various    dynamic sections here.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_arm_finish_dynamic_symbol
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|)
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|struct
name|elf32_arm_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|struct
name|elf32_arm_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|htab
operator|=
name|elf32_arm_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|elf32_arm_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
name|asection
modifier|*
name|splt
decl_stmt|;
name|asection
modifier|*
name|srel
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|bfd_vma
name|plt_index
decl_stmt|;
name|Elf_Internal_Rela
name|rel
decl_stmt|;
comment|/* This symbol has an entry in the procedure linkage table.  Set 	 it up.  */
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|splt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
name|srel
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|RELOC_SECTION
argument_list|(
name|htab
argument_list|,
literal|".plt"
argument_list|)
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|splt
operator|!=
name|NULL
operator|&&
name|srel
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Fill in the entry in the procedure linkage table.  */
if|if
condition|(
name|htab
operator|->
name|symbian_p
condition|)
block|{
name|put_arm_insn
argument_list|(
name|htab
argument_list|,
name|output_bfd
argument_list|,
name|elf32_arm_symbian_plt_entry
index|[
literal|0
index|]
argument_list|,
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|elf32_arm_symbian_plt_entry
index|[
literal|1
index|]
argument_list|,
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
literal|4
argument_list|)
expr_stmt|;
comment|/* Fill in the entry in the .rel.plt section.  */
name|rel
operator|.
name|r_offset
operator|=
operator|(
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|splt
operator|->
name|output_offset
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
literal|4
operator|)
expr_stmt|;
name|rel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_ARM_GLOB_DAT
argument_list|)
expr_stmt|;
comment|/* Get the index in the procedure linkage table which 	     corresponds to this symbol.  This is the index of this symbol 	     in all the symbols for which we are making plt entries.  The 	     first entry in the procedure linkage table is reserved.  */
name|plt_index
operator|=
operator|(
operator|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|-
name|htab
operator|->
name|plt_header_size
operator|)
operator|/
name|htab
operator|->
name|plt_entry_size
operator|)
expr_stmt|;
block|}
else|else
block|{
name|bfd_vma
name|got_offset
decl_stmt|,
name|got_address
decl_stmt|,
name|plt_address
decl_stmt|;
name|bfd_vma
name|got_displacement
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
name|bfd_byte
modifier|*
name|ptr
decl_stmt|;
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got.plt"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Get the offset into the .got.plt table of the entry that 	     corresponds to this function.  */
name|got_offset
operator|=
name|eh
operator|->
name|plt_got_offset
expr_stmt|;
comment|/* Get the index in the procedure linkage table which 	     corresponds to this symbol.  This is the index of this symbol 	     in all the symbols for which we are making plt entries.  The 	     first three entries in .got.plt are reserved; after that 	     symbols appear in the same order as in .plt.  */
name|plt_index
operator|=
operator|(
name|got_offset
operator|-
literal|12
operator|)
operator|/
literal|4
expr_stmt|;
comment|/* Calculate the address of the GOT entry.  */
name|got_address
operator|=
operator|(
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
name|got_offset
operator|)
expr_stmt|;
comment|/* ...and the address of the PLT entry.  */
name|plt_address
operator|=
operator|(
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|splt
operator|->
name|output_offset
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|)
expr_stmt|;
name|ptr
operator|=
name|htab
operator|->
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|vxworks_p
operator|&&
name|info
operator|->
name|shared
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|htab
operator|->
name|plt_entry_size
operator|/
literal|4
condition|;
name|i
operator|++
operator|,
name|ptr
operator|+=
literal|4
control|)
block|{
name|val
operator|=
name|elf32_arm_vxworks_shared_plt_entry
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|2
condition|)
name|val
operator||=
name|got_address
operator|-
name|sgot
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|5
condition|)
name|val
operator||=
name|plt_index
operator|*
name|RELOC_SIZE
argument_list|(
name|htab
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|2
operator|||
name|i
operator|==
literal|5
condition|)
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|val
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
else|else
name|put_arm_insn
argument_list|(
name|htab
argument_list|,
name|output_bfd
argument_list|,
name|val
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|htab
operator|->
name|vxworks_p
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|htab
operator|->
name|plt_entry_size
operator|/
literal|4
condition|;
name|i
operator|++
operator|,
name|ptr
operator|+=
literal|4
control|)
block|{
name|val
operator|=
name|elf32_arm_vxworks_exec_plt_entry
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|2
condition|)
name|val
operator||=
name|got_address
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|4
condition|)
name|val
operator||=
literal|0xffffff
operator|&
operator|-
operator|(
operator|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
name|i
operator|*
literal|4
operator|+
literal|8
operator|)
operator|>>
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|5
condition|)
name|val
operator||=
name|plt_index
operator|*
name|RELOC_SIZE
argument_list|(
name|htab
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|2
operator|||
name|i
operator|==
literal|5
condition|)
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|val
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
else|else
name|put_arm_insn
argument_list|(
name|htab
argument_list|,
name|output_bfd
argument_list|,
name|val
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
name|loc
operator|=
operator|(
name|htab
operator|->
name|srelplt2
operator|->
name|contents
operator|+
operator|(
name|plt_index
operator|*
literal|2
operator|+
literal|1
operator|)
operator|*
name|RELOC_SIZE
argument_list|(
name|htab
argument_list|)
operator|)
expr_stmt|;
comment|/* Create the .rela.plt.unloaded R_ARM_ABS32 relocation 		 referencing the GOT for this PLT entry.  */
name|rel
operator|.
name|r_offset
operator|=
name|plt_address
operator|+
literal|8
expr_stmt|;
name|rel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|htab
operator|->
name|root
operator|.
name|hgot
operator|->
name|indx
argument_list|,
name|R_ARM_ABS32
argument_list|)
expr_stmt|;
name|rel
operator|.
name|r_addend
operator|=
name|got_offset
expr_stmt|;
name|SWAP_RELOC_OUT
argument_list|(
name|htab
argument_list|)
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|loc
operator|+=
name|RELOC_SIZE
argument_list|(
name|htab
argument_list|)
expr_stmt|;
comment|/* Create the R_ARM_ABS32 relocation referencing the 		 beginning of the PLT for this GOT entry.  */
name|rel
operator|.
name|r_offset
operator|=
name|got_address
expr_stmt|;
name|rel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|htab
operator|->
name|root
operator|.
name|hplt
operator|->
name|indx
argument_list|,
name|R_ARM_ABS32
argument_list|)
expr_stmt|;
name|rel
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
name|SWAP_RELOC_OUT
argument_list|(
name|htab
argument_list|)
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Calculate the displacement between the PLT slot and the 		 entry in the GOT.  The eight-byte offset accounts for the 		 value produced by adding to pc in the first instruction 		 of the PLT stub.  */
name|got_displacement
operator|=
name|got_address
operator|-
operator|(
name|plt_address
operator|+
literal|8
operator|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
operator|(
name|got_displacement
operator|&
literal|0xf0000000
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|htab
operator|->
name|use_blx
operator|&&
name|eh
operator|->
name|plt_thumb_refcount
operator|>
literal|0
condition|)
block|{
name|put_thumb_insn
argument_list|(
name|htab
argument_list|,
name|output_bfd
argument_list|,
name|elf32_arm_plt_thumb_stub
index|[
literal|0
index|]
argument_list|,
name|ptr
operator|-
literal|4
argument_list|)
expr_stmt|;
name|put_thumb_insn
argument_list|(
name|htab
argument_list|,
name|output_bfd
argument_list|,
name|elf32_arm_plt_thumb_stub
index|[
literal|1
index|]
argument_list|,
name|ptr
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
name|put_arm_insn
argument_list|(
name|htab
argument_list|,
name|output_bfd
argument_list|,
name|elf32_arm_plt_entry
index|[
literal|0
index|]
operator||
operator|(
operator|(
name|got_displacement
operator|&
literal|0x0ff00000
operator|)
operator|>>
literal|20
operator|)
argument_list|,
name|ptr
operator|+
literal|0
argument_list|)
expr_stmt|;
name|put_arm_insn
argument_list|(
name|htab
argument_list|,
name|output_bfd
argument_list|,
name|elf32_arm_plt_entry
index|[
literal|1
index|]
operator||
operator|(
operator|(
name|got_displacement
operator|&
literal|0x000ff000
operator|)
operator|>>
literal|12
operator|)
argument_list|,
name|ptr
operator|+
literal|4
argument_list|)
expr_stmt|;
name|put_arm_insn
argument_list|(
name|htab
argument_list|,
name|output_bfd
argument_list|,
name|elf32_arm_plt_entry
index|[
literal|2
index|]
operator||
operator|(
name|got_displacement
operator|&
literal|0x00000fff
operator|)
argument_list|,
name|ptr
operator|+
literal|8
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FOUR_WORD_PLT
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|elf32_arm_plt_entry
index|[
literal|3
index|]
argument_list|,
name|ptr
operator|+
literal|12
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Fill in the entry in the global offset table.  */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|splt
operator|->
name|output_offset
operator|)
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|got_offset
argument_list|)
expr_stmt|;
comment|/* Fill in the entry in the .rel(a).plt section.  */
name|rel
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
name|rel
operator|.
name|r_offset
operator|=
name|got_address
expr_stmt|;
name|rel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_ARM_JUMP_SLOT
argument_list|)
expr_stmt|;
block|}
name|loc
operator|=
name|srel
operator|->
name|contents
operator|+
name|plt_index
operator|*
name|RELOC_SIZE
argument_list|(
name|htab
argument_list|)
expr_stmt|;
name|SWAP_RELOC_OUT
argument_list|(
name|htab
argument_list|)
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|h
operator|->
name|def_regular
condition|)
block|{
comment|/* Mark the symbol as undefined, rather than as defined in 	     the .plt section.  Leave the value alone.  */
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_UNDEF
expr_stmt|;
comment|/* If the symbol is weak, we do need to clear the value. 	     Otherwise, the PLT entry would provide a definition for 	     the symbol even if the symbol wasn't defined anywhere, 	     and so the symbol would never be NULL.  */
if|if
condition|(
operator|!
name|h
operator|->
name|ref_regular_nonweak
condition|)
name|sym
operator|->
name|st_value
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|&&
operator|(
name|elf32_arm_hash_entry
argument_list|(
name|h
argument_list|)
operator|->
name|tls_type
operator|&
name|GOT_TLS_GD
operator|)
operator|==
literal|0
operator|&&
operator|(
name|elf32_arm_hash_entry
argument_list|(
name|h
argument_list|)
operator|->
name|tls_type
operator|&
name|GOT_TLS_IE
operator|)
operator|==
literal|0
condition|)
block|{
name|asection
modifier|*
name|sgot
decl_stmt|;
name|asection
modifier|*
name|srel
decl_stmt|;
name|Elf_Internal_Rela
name|rel
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
comment|/* This symbol has an entry in the global offset table.  Set it 	 up.  */
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
name|srel
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|RELOC_SECTION
argument_list|(
name|htab
argument_list|,
literal|".got"
argument_list|)
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
operator|&&
name|srel
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|(
name|h
operator|->
name|got
operator|.
name|offset
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
literal|1
operator|)
expr_stmt|;
name|rel
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
name|rel
operator|.
name|r_offset
operator|=
operator|(
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
name|offset
operator|)
expr_stmt|;
comment|/* If this is a static link, or it is a -Bsymbolic link and the 	 symbol is defined locally or was forced to be local because 	 of a version file, we just want to emit a RELATIVE reloc. 	 The entry in the global offset table will already have been 	 initialized in the relocate_section function.  */
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
name|SYMBOL_REFERENCES_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
block|{
name|BFD_ASSERT
argument_list|(
operator|(
name|h
operator|->
name|got
operator|.
name|offset
operator|&
literal|1
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|rel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_ARM_RELATIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|htab
operator|->
name|use_rel
condition|)
block|{
name|rel
operator|.
name|r_addend
operator|=
name|bfd_get_32
argument_list|(
name|output_bfd
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|offset
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|BFD_ASSERT
argument_list|(
operator|(
name|h
operator|->
name|got
operator|.
name|offset
operator|&
literal|1
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|offset
argument_list|)
expr_stmt|;
name|rel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_ARM_GLOB_DAT
argument_list|)
expr_stmt|;
block|}
name|loc
operator|=
name|srel
operator|->
name|contents
operator|+
name|srel
operator|->
name|reloc_count
operator|++
operator|*
name|RELOC_SIZE
argument_list|(
name|htab
argument_list|)
expr_stmt|;
name|SWAP_RELOC_OUT
argument_list|(
name|htab
argument_list|)
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|->
name|needs_copy
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|Elf_Internal_Rela
name|rel
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
comment|/* This symbol needs a copy reloc.  Set it up.  */
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
argument_list|,
name|RELOC_SECTION
argument_list|(
name|htab
argument_list|,
literal|".bss"
argument_list|)
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|rel
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
name|rel
operator|.
name|r_offset
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|rel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_ARM_COPY
argument_list|)
expr_stmt|;
name|loc
operator|=
name|s
operator|->
name|contents
operator|+
name|s
operator|->
name|reloc_count
operator|++
operator|*
name|RELOC_SIZE
argument_list|(
name|htab
argument_list|)
expr_stmt|;
name|SWAP_RELOC_OUT
argument_list|(
name|htab
argument_list|)
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
comment|/* Mark _DYNAMIC and _GLOBAL_OFFSET_TABLE_ as absolute.  On VxWorks,      the _GLOBAL_OFFSET_TABLE_ symbol is not absolute: it is relative      to the ".got" section.  */
if|if
condition|(
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_DYNAMIC"
argument_list|)
operator|==
literal|0
operator|||
operator|(
operator|!
name|htab
operator|->
name|vxworks_p
operator|&&
name|h
operator|==
name|htab
operator|->
name|root
operator|.
name|hgot
operator|)
condition|)
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_ABS
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Finish up the dynamic sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_arm_finish_dynamic_sections
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
name|asection
modifier|*
name|sdyn
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got.plt"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|elf32_arm_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|symbian_p
operator|||
name|sgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|sdyn
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
name|asection
modifier|*
name|splt
decl_stmt|;
name|Elf32_External_Dyn
modifier|*
name|dyncon
decl_stmt|,
modifier|*
name|dynconend
decl_stmt|;
name|struct
name|elf32_arm_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|htab
operator|=
name|elf32_arm_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|splt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|splt
operator|!=
name|NULL
operator|&&
name|sdyn
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dyncon
operator|=
operator|(
name|Elf32_External_Dyn
operator|*
operator|)
name|sdyn
operator|->
name|contents
expr_stmt|;
name|dynconend
operator|=
operator|(
name|Elf32_External_Dyn
operator|*
operator|)
operator|(
name|sdyn
operator|->
name|contents
operator|+
name|sdyn
operator|->
name|size
operator|)
expr_stmt|;
for|for
control|(
init|;
name|dyncon
operator|<
name|dynconend
condition|;
name|dyncon
operator|++
control|)
block|{
name|Elf_Internal_Dyn
name|dyn
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_elf32_swap_dyn_in
argument_list|(
name|dynobj
argument_list|,
name|dyncon
argument_list|,
operator|&
name|dyn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dyn
operator|.
name|d_tag
condition|)
block|{
name|unsigned
name|int
name|type
decl_stmt|;
default|default:
break|break;
case|case
name|DT_HASH
case|:
name|name
operator|=
literal|".hash"
expr_stmt|;
goto|goto
name|get_vma_if_bpabi
goto|;
case|case
name|DT_STRTAB
case|:
name|name
operator|=
literal|".dynstr"
expr_stmt|;
goto|goto
name|get_vma_if_bpabi
goto|;
case|case
name|DT_SYMTAB
case|:
name|name
operator|=
literal|".dynsym"
expr_stmt|;
goto|goto
name|get_vma_if_bpabi
goto|;
case|case
name|DT_VERSYM
case|:
name|name
operator|=
literal|".gnu.version"
expr_stmt|;
goto|goto
name|get_vma_if_bpabi
goto|;
case|case
name|DT_VERDEF
case|:
name|name
operator|=
literal|".gnu.version_d"
expr_stmt|;
goto|goto
name|get_vma_if_bpabi
goto|;
case|case
name|DT_VERNEED
case|:
name|name
operator|=
literal|".gnu.version_r"
expr_stmt|;
goto|goto
name|get_vma_if_bpabi
goto|;
case|case
name|DT_PLTGOT
case|:
name|name
operator|=
literal|".got"
expr_stmt|;
goto|goto
name|get_vma
goto|;
case|case
name|DT_JMPREL
case|:
name|name
operator|=
name|RELOC_SECTION
argument_list|(
name|htab
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
name|get_vma
label|:
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|htab
operator|->
name|symbian_p
condition|)
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|s
operator|->
name|vma
expr_stmt|;
else|else
comment|/* In the BPABI, tags in the PT_DYNAMIC section point 		   at the file offset, not the memory address, for the 		   convenience of the post linker.  */
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|s
operator|->
name|filepos
expr_stmt|;
name|bfd_elf32_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
break|break;
name|get_vma_if_bpabi
label|:
if|if
condition|(
name|htab
operator|->
name|symbian_p
condition|)
goto|goto
name|get_vma
goto|;
break|break;
case|case
name|DT_PLTRELSZ
case|:
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
name|RELOC_SECTION
argument_list|(
name|htab
argument_list|,
literal|".plt"
argument_list|)
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|s
operator|->
name|size
expr_stmt|;
name|bfd_elf32_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_RELSZ
case|:
case|case
name|DT_RELASZ
case|:
if|if
condition|(
operator|!
name|htab
operator|->
name|symbian_p
condition|)
block|{
comment|/* My reading of the SVR4 ABI indicates that the 		     procedure linkage table relocs (DT_JMPREL) should be 		     included in the overall relocs (DT_REL).  This is 		     what Solaris does.  However, UnixWare can not handle 		     that case.  Therefore, we override the DT_RELSZ entry 		     here to make it not include the JMPREL relocs.  Since 		     the linker script arranges for .rel(a).plt to follow all 		     other relocation sections, we don't have to worry 		     about changing the DT_REL entry.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
name|RELOC_SECTION
argument_list|(
name|htab
argument_list|,
literal|".plt"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|-=
name|s
operator|->
name|size
expr_stmt|;
name|bfd_elf32_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Fall through */
case|case
name|DT_REL
case|:
case|case
name|DT_RELA
case|:
comment|/* In the BPABI, the DT_REL tag must point at the file 		 offset, not the VMA, of the first relocation 		 section.  So, we use code similar to that in 		 elflink.c, but do not check for SHF_ALLOC on the 		 relcoation section, since relocations sections are 		 never allocated under the BPABI.  The comments above 		 about Unixware notwithstanding, we include all of the 		 relocations here.  */
if|if
condition|(
name|htab
operator|->
name|symbian_p
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|type
operator|=
operator|(
operator|(
name|dyn
operator|.
name|d_tag
operator|==
name|DT_REL
operator|||
name|dyn
operator|.
name|d_tag
operator|==
name|DT_RELSZ
operator|)
condition|?
name|SHT_REL
else|:
name|SHT_RELA
operator|)
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|elf_numsections
argument_list|(
name|output_bfd
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|hdr
init|=
name|elf_elfsections
argument_list|(
name|output_bfd
argument_list|)
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|hdr
operator|->
name|sh_type
operator|==
name|type
condition|)
block|{
if|if
condition|(
name|dyn
operator|.
name|d_tag
operator|==
name|DT_RELSZ
operator|||
name|dyn
operator|.
name|d_tag
operator|==
name|DT_RELASZ
condition|)
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|+=
name|hdr
operator|->
name|sh_size
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|ufile_ptr
operator|)
name|hdr
operator|->
name|sh_offset
operator|<=
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|-
literal|1
condition|)
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|hdr
operator|->
name|sh_offset
expr_stmt|;
block|}
block|}
name|bfd_elf32_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* Set the bottom bit of DT_INIT/FINI if the 		 corresponding function is Thumb.  */
case|case
name|DT_INIT
case|:
name|name
operator|=
name|info
operator|->
name|init_function
expr_stmt|;
goto|goto
name|get_sym
goto|;
case|case
name|DT_FINI
case|:
name|name
operator|=
name|info
operator|->
name|fini_function
expr_stmt|;
name|get_sym
label|:
comment|/* If it wasn't set by elf_bfd_final_link 		 then there is nothing to adjust.  */
if|if
condition|(
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|!=
literal|0
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|eh
operator|=
name|elf_link_hash_lookup
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|eh
operator|!=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|NULL
operator|&&
name|ELF_ST_TYPE
argument_list|(
name|eh
operator|->
name|type
argument_list|)
operator|==
name|STT_ARM_TFUNC
condition|)
block|{
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator||=
literal|1
expr_stmt|;
name|bfd_elf32_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
comment|/* Fill in the first entry in the procedure linkage table.  */
if|if
condition|(
name|splt
operator|->
name|size
operator|>
literal|0
operator|&&
name|elf32_arm_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|plt_header_size
condition|)
block|{
specifier|const
name|bfd_vma
modifier|*
name|plt0_entry
decl_stmt|;
name|bfd_vma
name|got_address
decl_stmt|,
name|plt_address
decl_stmt|,
name|got_displacement
decl_stmt|;
comment|/* Calculate the addresses of the GOT and PLT.  */
name|got_address
operator|=
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
expr_stmt|;
name|plt_address
operator|=
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|splt
operator|->
name|output_offset
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|vxworks_p
condition|)
block|{
comment|/* The VxWorks GOT is relocated by the dynamic linker. 		 Therefore, we must emit relocations rather than simply 		 computing the values now.  */
name|Elf_Internal_Rela
name|rel
decl_stmt|;
name|plt0_entry
operator|=
name|elf32_arm_vxworks_exec_plt0_entry
expr_stmt|;
name|put_arm_insn
argument_list|(
name|htab
argument_list|,
name|output_bfd
argument_list|,
name|plt0_entry
index|[
literal|0
index|]
argument_list|,
name|splt
operator|->
name|contents
operator|+
literal|0
argument_list|)
expr_stmt|;
name|put_arm_insn
argument_list|(
name|htab
argument_list|,
name|output_bfd
argument_list|,
name|plt0_entry
index|[
literal|1
index|]
argument_list|,
name|splt
operator|->
name|contents
operator|+
literal|4
argument_list|)
expr_stmt|;
name|put_arm_insn
argument_list|(
name|htab
argument_list|,
name|output_bfd
argument_list|,
name|plt0_entry
index|[
literal|2
index|]
argument_list|,
name|splt
operator|->
name|contents
operator|+
literal|8
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|got_address
argument_list|,
name|splt
operator|->
name|contents
operator|+
literal|12
argument_list|)
expr_stmt|;
comment|/* Generate a relocation for _GLOBAL_OFFSET_TABLE_. */
name|rel
operator|.
name|r_offset
operator|=
name|plt_address
operator|+
literal|12
expr_stmt|;
name|rel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|htab
operator|->
name|root
operator|.
name|hgot
operator|->
name|indx
argument_list|,
name|R_ARM_ABS32
argument_list|)
expr_stmt|;
name|rel
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
name|SWAP_RELOC_OUT
argument_list|(
name|htab
argument_list|)
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rel
argument_list|,
name|htab
operator|->
name|srelplt2
operator|->
name|contents
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|got_displacement
operator|=
name|got_address
operator|-
operator|(
name|plt_address
operator|+
literal|16
operator|)
expr_stmt|;
name|plt0_entry
operator|=
name|elf32_arm_plt0_entry
expr_stmt|;
name|put_arm_insn
argument_list|(
name|htab
argument_list|,
name|output_bfd
argument_list|,
name|plt0_entry
index|[
literal|0
index|]
argument_list|,
name|splt
operator|->
name|contents
operator|+
literal|0
argument_list|)
expr_stmt|;
name|put_arm_insn
argument_list|(
name|htab
argument_list|,
name|output_bfd
argument_list|,
name|plt0_entry
index|[
literal|1
index|]
argument_list|,
name|splt
operator|->
name|contents
operator|+
literal|4
argument_list|)
expr_stmt|;
name|put_arm_insn
argument_list|(
name|htab
argument_list|,
name|output_bfd
argument_list|,
name|plt0_entry
index|[
literal|2
index|]
argument_list|,
name|splt
operator|->
name|contents
operator|+
literal|8
argument_list|)
expr_stmt|;
name|put_arm_insn
argument_list|(
name|htab
argument_list|,
name|output_bfd
argument_list|,
name|plt0_entry
index|[
literal|3
index|]
argument_list|,
name|splt
operator|->
name|contents
operator|+
literal|12
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FOUR_WORD_PLT
comment|/* The displacement value goes in the otherwise-unused 		 last word of the second entry.  */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|got_displacement
argument_list|,
name|splt
operator|->
name|contents
operator|+
literal|28
argument_list|)
expr_stmt|;
else|#
directive|else
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|got_displacement
argument_list|,
name|splt
operator|->
name|contents
operator|+
literal|16
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/* UnixWare sets the entsize of .plt to 4, although that doesn't 	 really seem like the right value.  */
if|if
condition|(
name|splt
operator|->
name|output_section
operator|->
name|owner
operator|==
name|output_bfd
condition|)
name|elf_section_data
argument_list|(
name|splt
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|vxworks_p
operator|&&
operator|!
name|info
operator|->
name|shared
operator|&&
name|htab
operator|->
name|splt
operator|->
name|size
operator|>
literal|0
condition|)
block|{
comment|/* Correct the .rel(a).plt.unloaded relocations.  They will have 	     incorrect symbol indexes.  */
name|int
name|num_plts
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|num_plts
operator|=
operator|(
operator|(
name|htab
operator|->
name|splt
operator|->
name|size
operator|-
name|htab
operator|->
name|plt_header_size
operator|)
operator|/
name|htab
operator|->
name|plt_entry_size
operator|)
expr_stmt|;
name|p
operator|=
name|htab
operator|->
name|srelplt2
operator|->
name|contents
operator|+
name|RELOC_SIZE
argument_list|(
name|htab
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|num_plts
condition|;
name|num_plts
operator|--
control|)
block|{
name|Elf_Internal_Rela
name|rel
decl_stmt|;
name|SWAP_RELOC_IN
argument_list|(
name|htab
argument_list|)
argument_list|(
name|output_bfd
argument_list|,
name|p
argument_list|,
operator|&
name|rel
argument_list|)
expr_stmt|;
name|rel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|htab
operator|->
name|root
operator|.
name|hgot
operator|->
name|indx
argument_list|,
name|R_ARM_ABS32
argument_list|)
expr_stmt|;
name|SWAP_RELOC_OUT
argument_list|(
name|htab
argument_list|)
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rel
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
name|RELOC_SIZE
argument_list|(
name|htab
argument_list|)
expr_stmt|;
name|SWAP_RELOC_IN
argument_list|(
name|htab
argument_list|)
argument_list|(
name|output_bfd
argument_list|,
name|p
argument_list|,
operator|&
name|rel
argument_list|)
expr_stmt|;
name|rel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|htab
operator|->
name|root
operator|.
name|hplt
operator|->
name|indx
argument_list|,
name|R_ARM_ABS32
argument_list|)
expr_stmt|;
name|SWAP_RELOC_OUT
argument_list|(
name|htab
argument_list|)
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rel
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
name|RELOC_SIZE
argument_list|(
name|htab
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Fill in the first three entries in the global offset table.  */
if|if
condition|(
name|sgot
condition|)
block|{
if|if
condition|(
name|sgot
operator|->
name|size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|sdyn
operator|==
name|NULL
condition|)
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|sgot
operator|->
name|contents
argument_list|)
expr_stmt|;
else|else
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|sdyn
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sdyn
operator|->
name|output_offset
argument_list|,
name|sgot
operator|->
name|contents
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|sgot
operator|->
name|contents
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|sgot
operator|->
name|contents
operator|+
literal|8
argument_list|)
expr_stmt|;
block|}
name|elf_section_data
argument_list|(
name|sgot
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
operator|=
literal|4
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|elf32_arm_post_process_headers
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|Elf_Internal_Ehdr
modifier|*
name|i_ehdrp
decl_stmt|;
comment|/* ELF file header, internal form.  */
name|struct
name|elf32_arm_link_hash_table
modifier|*
name|globals
decl_stmt|;
name|i_ehdrp
operator|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|EF_ARM_EABI_VERSION
argument_list|(
name|i_ehdrp
operator|->
name|e_flags
argument_list|)
operator|==
name|EF_ARM_EABI_UNKNOWN
condition|)
name|i_ehdrp
operator|->
name|e_ident
index|[
name|EI_OSABI
index|]
operator|=
name|ARM_ELF_OS_ABI_VERSION
expr_stmt|;
else|else
name|i_ehdrp
operator|->
name|e_ident
index|[
name|EI_OSABI
index|]
operator|=
literal|0
expr_stmt|;
name|i_ehdrp
operator|->
name|e_ident
index|[
name|EI_ABIVERSION
index|]
operator|=
name|ARM_ELF_ABI_VERSION
expr_stmt|;
if|if
condition|(
name|link_info
condition|)
block|{
name|globals
operator|=
name|elf32_arm_hash_table
argument_list|(
name|link_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|globals
operator|->
name|byteswap_code
condition|)
name|i_ehdrp
operator|->
name|e_flags
operator||=
name|EF_ARM_BE8
expr_stmt|;
block|}
comment|/*    * For EABI 5, we have to tag dynamic binaries and execs as either    * soft float or hard float.    */
if|if
condition|(
name|EF_ARM_EABI_VERSION
argument_list|(
name|i_ehdrp
operator|->
name|e_flags
argument_list|)
operator|==
name|EF_ARM_EABI_VER5
operator|&&
operator|(
name|i_ehdrp
operator|->
name|e_type
operator|==
name|ET_DYN
operator|||
name|i_ehdrp
operator|->
name|e_type
operator|==
name|ET_EXEC
operator|)
condition|)
name|i_ehdrp
operator|->
name|e_flags
operator||=
name|bfd_elf_get_obj_attr_int
argument_list|(
name|abfd
argument_list|,
name|OBJ_ATTR_PROC
argument_list|,
name|Tag_ABI_VFP_args
argument_list|)
condition|?
name|EF_ARM_VFP_FLOAT
else|:
name|EF_ARM_SOFT_FLOAT
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|enum
name|elf_reloc_type_class
name|elf32_arm_reloc_type_class
parameter_list|(
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rela
parameter_list|)
block|{
switch|switch
condition|(
operator|(
name|int
operator|)
name|ELF32_R_TYPE
argument_list|(
name|rela
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_ARM_RELATIVE
case|:
return|return
name|reloc_class_relative
return|;
case|case
name|R_ARM_JUMP_SLOT
case|:
return|return
name|reloc_class_plt
return|;
case|case
name|R_ARM_COPY
case|:
return|return
name|reloc_class_copy
return|;
default|default:
return|return
name|reloc_class_normal
return|;
block|}
block|}
end_function

begin_comment
comment|/* Set the right machine number for an Arm ELF file.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_arm_section_flags
parameter_list|(
name|flagword
modifier|*
name|flags
parameter_list|,
specifier|const
name|Elf_Internal_Shdr
modifier|*
name|hdr
parameter_list|)
block|{
if|if
condition|(
name|hdr
operator|->
name|sh_type
operator|==
name|SHT_NOTE
condition|)
operator|*
name|flags
operator||=
name|SEC_LINK_ONCE
operator||
name|SEC_LINK_DUPLICATES_SAME_CONTENTS
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|elf32_arm_final_write_processing
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_boolean
name|linker
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|bfd_arm_update_notes
argument_list|(
name|abfd
argument_list|,
name|ARM_NOTE_SECTION
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return TRUE if this is an unwinding table entry.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|is_arm_elf_unwind_section_name
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
operator|(
name|CONST_STRNEQ
argument_list|(
name|name
argument_list|,
name|ELF_STRING_ARM_unwind
argument_list|)
operator|||
name|CONST_STRNEQ
argument_list|(
name|name
argument_list|,
name|ELF_STRING_ARM_unwind_once
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Set the type and flags for an ARM section.  We do this by    the section name, which is a hack, but ought to work.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_arm_fake_sections
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Shdr
modifier|*
name|hdr
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_arm_elf_unwind_section_name
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_ARM_EXIDX
expr_stmt|;
name|hdr
operator|->
name|sh_flags
operator||=
name|SHF_LINK_ORDER
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Handle an ARM specific section when reading an object file.  This is    called when bfd_section_from_shdr finds a section with an unknown    type.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_arm_section_from_shdr
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Shdr
modifier|*
name|hdr
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|shindex
parameter_list|)
block|{
comment|/* There ought to be a place to keep ELF backend specific flags, but      at the moment there isn't one.  We just keep track of the      sections by their name, instead.  Fortunately, the ABI gives      names for all the ARM specific sections, so we will probably get      away with this.  */
switch|switch
condition|(
name|hdr
operator|->
name|sh_type
condition|)
block|{
case|case
name|SHT_ARM_EXIDX
case|:
case|case
name|SHT_ARM_PREEMPTMAP
case|:
case|case
name|SHT_ARM_ATTRIBUTES
case|:
break|break;
default|default:
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|_bfd_elf_make_section_from_shdr
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|,
name|name
argument_list|,
name|shindex
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* A structure used to record a list of sections, independently    of the next and prev fields in the asection structure.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|section_list
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|section_list
modifier|*
name|next
decl_stmt|;
name|struct
name|section_list
modifier|*
name|prev
decl_stmt|;
block|}
name|section_list
typedef|;
end_typedef

begin_comment
comment|/* Unfortunately we need to keep a list of sections for which    an _arm_elf_section_data structure has been allocated.  This    is because it is possible for functions like elf32_arm_write_section    to be called on a section which has had an elf_data_structure    allocated for it (and so the used_by_bfd field is valid) but    for which the ARM extended version of this structure - the    _arm_elf_section_data structure - has not been allocated.  */
end_comment

begin_decl_stmt
specifier|static
name|section_list
modifier|*
name|sections_with_arm_elf_section_data
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|record_section_with_arm_elf_section_data
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|)
block|{
name|struct
name|section_list
modifier|*
name|entry
decl_stmt|;
name|entry
operator|=
name|bfd_malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
return|return;
name|entry
operator|->
name|sec
operator|=
name|sec
expr_stmt|;
name|entry
operator|->
name|next
operator|=
name|sections_with_arm_elf_section_data
expr_stmt|;
name|entry
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|next
operator|!=
name|NULL
condition|)
name|entry
operator|->
name|next
operator|->
name|prev
operator|=
name|entry
expr_stmt|;
name|sections_with_arm_elf_section_data
operator|=
name|entry
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|section_list
modifier|*
name|find_arm_elf_section_entry
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|)
block|{
name|struct
name|section_list
modifier|*
name|entry
decl_stmt|;
specifier|static
name|struct
name|section_list
modifier|*
name|last_entry
init|=
name|NULL
decl_stmt|;
comment|/* This is a short cut for the typical case where the sections are added      to the sections_with_arm_elf_section_data list in forward order and      then looked up here in backwards order.  This makes a real difference      to the ld-srec/sec64k.exp linker test.  */
name|entry
operator|=
name|sections_with_arm_elf_section_data
expr_stmt|;
if|if
condition|(
name|last_entry
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|last_entry
operator|->
name|sec
operator|==
name|sec
condition|)
name|entry
operator|=
name|last_entry
expr_stmt|;
elseif|else
if|if
condition|(
name|last_entry
operator|->
name|next
operator|!=
name|NULL
operator|&&
name|last_entry
operator|->
name|next
operator|->
name|sec
operator|==
name|sec
condition|)
name|entry
operator|=
name|last_entry
operator|->
name|next
expr_stmt|;
block|}
for|for
control|(
init|;
name|entry
condition|;
name|entry
operator|=
name|entry
operator|->
name|next
control|)
if|if
condition|(
name|entry
operator|->
name|sec
operator|==
name|sec
condition|)
break|break;
if|if
condition|(
name|entry
condition|)
comment|/* Record the entry prior to this one - it is the entry we are most        likely to want to locate next time.  Also this way if we have been        called from unrecord_section_with_arm_elf_section_data() we will not        be caching a pointer that is about to be freed.  */
name|last_entry
operator|=
name|entry
operator|->
name|prev
expr_stmt|;
return|return
name|entry
return|;
block|}
end_function

begin_function
specifier|static
name|_arm_elf_section_data
modifier|*
name|get_arm_elf_section_data
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|)
block|{
name|struct
name|section_list
modifier|*
name|entry
decl_stmt|;
name|entry
operator|=
name|find_arm_elf_section_entry
argument_list|(
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
condition|)
return|return
name|elf32_arm_section_data
argument_list|(
name|entry
operator|->
name|sec
argument_list|)
return|;
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|unrecord_section_with_arm_elf_section_data
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|)
block|{
name|struct
name|section_list
modifier|*
name|entry
decl_stmt|;
name|entry
operator|=
name|find_arm_elf_section_entry
argument_list|(
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
condition|)
block|{
if|if
condition|(
name|entry
operator|->
name|prev
operator|!=
name|NULL
condition|)
name|entry
operator|->
name|prev
operator|->
name|next
operator|=
name|entry
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|next
operator|!=
name|NULL
condition|)
name|entry
operator|->
name|next
operator|->
name|prev
operator|=
name|entry
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|sections_with_arm_elf_section_data
condition|)
name|sections_with_arm_elf_section_data
operator|=
name|entry
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
block|{
name|void
modifier|*
name|finfo
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|int
name|sec_shndx
decl_stmt|;
name|bfd_boolean
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|Elf_Internal_Sym
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
parameter_list|)
function_decl|;
block|}
name|output_arch_syminfo
typedef|;
end_typedef

begin_enum
enum|enum
name|map_symbol_type
block|{
name|ARM_MAP_ARM
block|,
name|ARM_MAP_THUMB
block|,
name|ARM_MAP_DATA
block|}
enum|;
end_enum

begin_comment
comment|/* Output a single PLT mapping symbol.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_arm_ouput_plt_map_sym
parameter_list|(
name|output_arch_syminfo
modifier|*
name|osi
parameter_list|,
name|enum
name|map_symbol_type
name|type
parameter_list|,
name|bfd_vma
name|offset
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|names
index|[
literal|3
index|]
init|=
block|{
literal|"$a"
block|,
literal|"$t"
block|,
literal|"$d"
block|}
decl_stmt|;
name|struct
name|elf32_arm_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|Elf_Internal_Sym
name|sym
decl_stmt|;
name|htab
operator|=
name|elf32_arm_hash_table
argument_list|(
name|osi
operator|->
name|info
argument_list|)
expr_stmt|;
name|sym
operator|.
name|st_value
operator|=
name|osi
operator|->
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|osi
operator|->
name|sec
operator|->
name|output_offset
operator|+
name|offset
expr_stmt|;
name|sym
operator|.
name|st_size
operator|=
literal|0
expr_stmt|;
name|sym
operator|.
name|st_other
operator|=
literal|0
expr_stmt|;
name|sym
operator|.
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_LOCAL
argument_list|,
name|STT_NOTYPE
argument_list|)
expr_stmt|;
name|sym
operator|.
name|st_shndx
operator|=
name|osi
operator|->
name|sec_shndx
expr_stmt|;
if|if
condition|(
operator|!
name|osi
operator|->
name|func
argument_list|(
name|osi
operator|->
name|finfo
argument_list|,
name|names
index|[
name|type
index|]
argument_list|,
operator|&
name|sym
argument_list|,
name|osi
operator|->
name|sec
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Output mapping symbols for PLT entries associated with H.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_arm_output_plt_map
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|void
modifier|*
name|inf
parameter_list|)
block|{
name|output_arch_syminfo
modifier|*
name|osi
init|=
operator|(
name|output_arch_syminfo
operator|*
operator|)
name|inf
decl_stmt|;
name|struct
name|elf32_arm_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|struct
name|elf32_arm_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
name|htab
operator|=
name|elf32_arm_hash_table
argument_list|(
name|osi
operator|->
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
comment|/* When warning symbols are created, they **replace** the "real"        entry in the hash table, thus we never get to see the real        symbol in a hash traversal.  So look at it now.  */
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
return|return
name|TRUE
return|;
name|eh
operator|=
operator|(
expr|struct
name|elf32_arm_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
name|addr
operator|=
name|h
operator|->
name|plt
operator|.
name|offset
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|symbian_p
condition|)
block|{
if|if
condition|(
operator|!
name|elf32_arm_ouput_plt_map_sym
argument_list|(
name|osi
argument_list|,
name|ARM_MAP_ARM
argument_list|,
name|addr
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|elf32_arm_ouput_plt_map_sym
argument_list|(
name|osi
argument_list|,
name|ARM_MAP_DATA
argument_list|,
name|addr
operator|+
literal|4
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
elseif|else
if|if
condition|(
name|htab
operator|->
name|vxworks_p
condition|)
block|{
if|if
condition|(
operator|!
name|elf32_arm_ouput_plt_map_sym
argument_list|(
name|osi
argument_list|,
name|ARM_MAP_ARM
argument_list|,
name|addr
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|elf32_arm_ouput_plt_map_sym
argument_list|(
name|osi
argument_list|,
name|ARM_MAP_DATA
argument_list|,
name|addr
operator|+
literal|8
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|elf32_arm_ouput_plt_map_sym
argument_list|(
name|osi
argument_list|,
name|ARM_MAP_ARM
argument_list|,
name|addr
operator|+
literal|12
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|elf32_arm_ouput_plt_map_sym
argument_list|(
name|osi
argument_list|,
name|ARM_MAP_DATA
argument_list|,
name|addr
operator|+
literal|20
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
else|else
block|{
name|bfd_boolean
name|thumb_stub
decl_stmt|;
name|thumb_stub
operator|=
name|eh
operator|->
name|plt_thumb_refcount
operator|>
literal|0
operator|&&
operator|!
name|htab
operator|->
name|use_blx
expr_stmt|;
if|if
condition|(
name|thumb_stub
condition|)
block|{
if|if
condition|(
operator|!
name|elf32_arm_ouput_plt_map_sym
argument_list|(
name|osi
argument_list|,
name|ARM_MAP_THUMB
argument_list|,
name|addr
operator|-
literal|4
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
ifdef|#
directive|ifdef
name|FOUR_WORD_PLT
if|if
condition|(
operator|!
name|elf32_arm_ouput_plt_map_sym
argument_list|(
name|osi
argument_list|,
name|ARM_MAP_ARM
argument_list|,
name|addr
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|elf32_arm_ouput_plt_map_sym
argument_list|(
name|osi
argument_list|,
name|ARM_MAP_DATA
argument_list|,
name|addr
operator|+
literal|12
argument_list|)
condition|)
return|return
name|FALSE
return|;
else|#
directive|else
comment|/* A three-word PLT with no Thumb thunk contains only Arm code,  	 so only need to output a mapping symbol for the first PLT entry and 	 entries with thumb thunks.  */
if|if
condition|(
name|thumb_stub
operator|||
name|addr
operator|==
literal|20
condition|)
block|{
if|if
condition|(
operator|!
name|elf32_arm_ouput_plt_map_sym
argument_list|(
name|osi
argument_list|,
name|ARM_MAP_ARM
argument_list|,
name|addr
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
endif|#
directive|endif
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Output mapping symbols for linker generated sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_arm_output_arch_local_syms
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|void
modifier|*
name|finfo
parameter_list|,
name|bfd_boolean
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|Elf_Internal_Sym
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
parameter_list|)
parameter_list|)
block|{
name|output_arch_syminfo
name|osi
decl_stmt|;
name|struct
name|elf32_arm_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
name|htab
operator|=
name|elf32_arm_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|check_use_blx
argument_list|(
name|htab
argument_list|)
expr_stmt|;
name|osi
operator|.
name|finfo
operator|=
name|finfo
expr_stmt|;
name|osi
operator|.
name|info
operator|=
name|info
expr_stmt|;
name|osi
operator|.
name|func
operator|=
name|func
expr_stmt|;
comment|/* ARM->Thumb glue.  */
if|if
condition|(
name|htab
operator|->
name|arm_glue_size
operator|>
literal|0
condition|)
block|{
name|osi
operator|.
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|htab
operator|->
name|bfd_of_glue_owner
argument_list|,
name|ARM2THUMB_GLUE_SECTION_NAME
argument_list|)
expr_stmt|;
name|osi
operator|.
name|sec_shndx
operator|=
name|_bfd_elf_section_from_bfd_section
argument_list|(
name|output_bfd
argument_list|,
name|osi
operator|.
name|sec
operator|->
name|output_section
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
operator|||
name|htab
operator|->
name|root
operator|.
name|is_relocatable_executable
operator|||
name|htab
operator|->
name|pic_veneer
condition|)
name|size
operator|=
name|ARM2THUMB_PIC_GLUE_SIZE
expr_stmt|;
elseif|else
if|if
condition|(
name|htab
operator|->
name|use_blx
condition|)
name|size
operator|=
name|ARM2THUMB_V5_STATIC_GLUE_SIZE
expr_stmt|;
else|else
name|size
operator|=
name|ARM2THUMB_STATIC_GLUE_SIZE
expr_stmt|;
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
name|htab
operator|->
name|arm_glue_size
condition|;
name|offset
operator|+=
name|size
control|)
block|{
name|elf32_arm_ouput_plt_map_sym
argument_list|(
operator|&
name|osi
argument_list|,
name|ARM_MAP_ARM
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|elf32_arm_ouput_plt_map_sym
argument_list|(
operator|&
name|osi
argument_list|,
name|ARM_MAP_DATA
argument_list|,
name|offset
operator|+
name|size
operator|-
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Thumb->ARM glue.  */
if|if
condition|(
name|htab
operator|->
name|thumb_glue_size
operator|>
literal|0
condition|)
block|{
name|osi
operator|.
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|htab
operator|->
name|bfd_of_glue_owner
argument_list|,
name|THUMB2ARM_GLUE_SECTION_NAME
argument_list|)
expr_stmt|;
name|osi
operator|.
name|sec_shndx
operator|=
name|_bfd_elf_section_from_bfd_section
argument_list|(
name|output_bfd
argument_list|,
name|osi
operator|.
name|sec
operator|->
name|output_section
argument_list|)
expr_stmt|;
name|size
operator|=
name|THUMB2ARM_GLUE_SIZE
expr_stmt|;
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
name|htab
operator|->
name|thumb_glue_size
condition|;
name|offset
operator|+=
name|size
control|)
block|{
name|elf32_arm_ouput_plt_map_sym
argument_list|(
operator|&
name|osi
argument_list|,
name|ARM_MAP_THUMB
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|elf32_arm_ouput_plt_map_sym
argument_list|(
operator|&
name|osi
argument_list|,
name|ARM_MAP_ARM
argument_list|,
name|offset
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Finally, output mapping symbols for the PLT.  */
if|if
condition|(
operator|!
name|htab
operator|->
name|splt
operator|||
name|htab
operator|->
name|splt
operator|->
name|size
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
name|osi
operator|.
name|sec_shndx
operator|=
name|_bfd_elf_section_from_bfd_section
argument_list|(
name|output_bfd
argument_list|,
name|htab
operator|->
name|splt
operator|->
name|output_section
argument_list|)
expr_stmt|;
name|osi
operator|.
name|sec
operator|=
name|htab
operator|->
name|splt
expr_stmt|;
comment|/* Output mapping symbols for the plt header.  SymbianOS does not have a      plt header.  */
if|if
condition|(
name|htab
operator|->
name|vxworks_p
condition|)
block|{
comment|/* VxWorks shared libraries have no PLT header.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
if|if
condition|(
operator|!
name|elf32_arm_ouput_plt_map_sym
argument_list|(
operator|&
name|osi
argument_list|,
name|ARM_MAP_ARM
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|elf32_arm_ouput_plt_map_sym
argument_list|(
operator|&
name|osi
argument_list|,
name|ARM_MAP_DATA
argument_list|,
literal|12
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|htab
operator|->
name|symbian_p
condition|)
block|{
if|if
condition|(
operator|!
name|elf32_arm_ouput_plt_map_sym
argument_list|(
operator|&
name|osi
argument_list|,
name|ARM_MAP_ARM
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
ifndef|#
directive|ifndef
name|FOUR_WORD_PLT
if|if
condition|(
operator|!
name|elf32_arm_ouput_plt_map_sym
argument_list|(
operator|&
name|osi
argument_list|,
name|ARM_MAP_DATA
argument_list|,
literal|16
argument_list|)
condition|)
return|return
name|FALSE
return|;
endif|#
directive|endif
block|}
name|elf_link_hash_traverse
argument_list|(
operator|&
name|htab
operator|->
name|root
argument_list|,
name|elf32_arm_output_plt_map
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|osi
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Allocate target specific section data.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_arm_new_section_hook
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|)
block|{
if|if
condition|(
operator|!
name|sec
operator|->
name|used_by_bfd
condition|)
block|{
name|_arm_elf_section_data
modifier|*
name|sdata
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
operator|*
name|sdata
argument_list|)
decl_stmt|;
name|sdata
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdata
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|sec
operator|->
name|used_by_bfd
operator|=
name|sdata
expr_stmt|;
block|}
name|record_section_with_arm_elf_section_data
argument_list|(
name|sec
argument_list|)
expr_stmt|;
return|return
name|_bfd_elf_new_section_hook
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Used to order a list of mapping symbols by address.  */
end_comment

begin_function
specifier|static
name|int
name|elf32_arm_compare_mapping
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
return|return
operator|(
operator|(
specifier|const
name|elf32_arm_section_map
operator|*
operator|)
name|a
operator|)
operator|->
name|vma
operator|>
operator|(
operator|(
specifier|const
name|elf32_arm_section_map
operator|*
operator|)
name|b
operator|)
operator|->
name|vma
return|;
block|}
end_function

begin_comment
comment|/* Do code byteswapping.  Return FALSE afterwards so that the section is    written out as normal.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_arm_write_section
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|)
block|{
name|int
name|mapcount
decl_stmt|,
name|errcount
decl_stmt|;
name|_arm_elf_section_data
modifier|*
name|arm_data
decl_stmt|;
name|struct
name|elf32_arm_link_hash_table
modifier|*
name|globals
init|=
name|elf32_arm_hash_table
argument_list|(
name|link_info
argument_list|)
decl_stmt|;
name|elf32_arm_section_map
modifier|*
name|map
decl_stmt|;
name|elf32_vfp11_erratum_list
modifier|*
name|errnode
decl_stmt|;
name|bfd_vma
name|ptr
decl_stmt|;
name|bfd_vma
name|end
decl_stmt|;
name|bfd_vma
name|offset
init|=
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
decl_stmt|;
name|bfd_byte
name|tmp
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* If this section has not been allocated an _arm_elf_section_data      structure then we cannot record anything.  */
name|arm_data
operator|=
name|get_arm_elf_section_data
argument_list|(
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|arm_data
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|mapcount
operator|=
name|arm_data
operator|->
name|mapcount
expr_stmt|;
name|map
operator|=
name|arm_data
operator|->
name|map
expr_stmt|;
name|errcount
operator|=
name|arm_data
operator|->
name|erratumcount
expr_stmt|;
if|if
condition|(
name|errcount
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|int
name|endianflip
init|=
name|bfd_big_endian
argument_list|(
name|output_bfd
argument_list|)
condition|?
literal|3
else|:
literal|0
decl_stmt|;
for|for
control|(
name|errnode
operator|=
name|arm_data
operator|->
name|erratumlist
init|;
name|errnode
operator|!=
literal|0
condition|;
name|errnode
operator|=
name|errnode
operator|->
name|next
control|)
block|{
name|bfd_vma
name|index
init|=
name|errnode
operator|->
name|vma
operator|-
name|offset
decl_stmt|;
switch|switch
condition|(
name|errnode
operator|->
name|type
condition|)
block|{
case|case
name|VFP11_ERRATUM_BRANCH_TO_ARM_VENEER
case|:
block|{
name|bfd_vma
name|branch_to_veneer
decl_stmt|;
comment|/* Original condition code of instruction, plus bit mask for                    ARM B instruction.  */
name|unsigned
name|int
name|insn
init|=
operator|(
name|errnode
operator|->
name|u
operator|.
name|b
operator|.
name|vfp_insn
operator|&
literal|0xf0000000
operator|)
operator||
literal|0x0a000000
decl_stmt|;
comment|/* The instruction is before the label.  */
name|index
operator|-=
literal|4
expr_stmt|;
comment|/* Above offset included in -4 below.  */
name|branch_to_veneer
operator|=
name|errnode
operator|->
name|u
operator|.
name|b
operator|.
name|veneer
operator|->
name|vma
operator|-
name|errnode
operator|->
name|vma
operator|-
literal|4
expr_stmt|;
if|if
condition|(
operator|(
name|signed
operator|)
name|branch_to_veneer
operator|<
operator|-
operator|(
literal|1
operator|<<
literal|25
operator|)
operator|||
operator|(
name|signed
operator|)
name|branch_to_veneer
operator|>=
operator|(
literal|1
operator|<<
literal|25
operator|)
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: error: VFP11 veneer out of "
literal|"range"
argument_list|)
argument_list|,
name|output_bfd
argument_list|)
expr_stmt|;
name|insn
operator||=
operator|(
name|branch_to_veneer
operator|>>
literal|2
operator|)
operator|&
literal|0xffffff
expr_stmt|;
name|contents
index|[
name|endianflip
operator|^
name|index
index|]
operator|=
name|insn
operator|&
literal|0xff
expr_stmt|;
name|contents
index|[
name|endianflip
operator|^
operator|(
name|index
operator|+
literal|1
operator|)
index|]
operator|=
operator|(
name|insn
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|contents
index|[
name|endianflip
operator|^
operator|(
name|index
operator|+
literal|2
operator|)
index|]
operator|=
operator|(
name|insn
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|contents
index|[
name|endianflip
operator|^
operator|(
name|index
operator|+
literal|3
operator|)
index|]
operator|=
operator|(
name|insn
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
block|}
break|break;
case|case
name|VFP11_ERRATUM_ARM_VENEER
case|:
block|{
name|bfd_vma
name|branch_from_veneer
decl_stmt|;
name|unsigned
name|int
name|insn
decl_stmt|;
comment|/* Take size of veneer into account.  */
name|branch_from_veneer
operator|=
name|errnode
operator|->
name|u
operator|.
name|v
operator|.
name|branch
operator|->
name|vma
operator|-
name|errnode
operator|->
name|vma
operator|-
literal|12
expr_stmt|;
if|if
condition|(
operator|(
name|signed
operator|)
name|branch_from_veneer
operator|<
operator|-
operator|(
literal|1
operator|<<
literal|25
operator|)
operator|||
operator|(
name|signed
operator|)
name|branch_from_veneer
operator|>=
operator|(
literal|1
operator|<<
literal|25
operator|)
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: error: VFP11 veneer out of "
literal|"range"
argument_list|)
argument_list|,
name|output_bfd
argument_list|)
expr_stmt|;
comment|/* Original instruction.  */
name|insn
operator|=
name|errnode
operator|->
name|u
operator|.
name|v
operator|.
name|branch
operator|->
name|u
operator|.
name|b
operator|.
name|vfp_insn
expr_stmt|;
name|contents
index|[
name|endianflip
operator|^
name|index
index|]
operator|=
name|insn
operator|&
literal|0xff
expr_stmt|;
name|contents
index|[
name|endianflip
operator|^
operator|(
name|index
operator|+
literal|1
operator|)
index|]
operator|=
operator|(
name|insn
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|contents
index|[
name|endianflip
operator|^
operator|(
name|index
operator|+
literal|2
operator|)
index|]
operator|=
operator|(
name|insn
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|contents
index|[
name|endianflip
operator|^
operator|(
name|index
operator|+
literal|3
operator|)
index|]
operator|=
operator|(
name|insn
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
comment|/* Branch back to insn after original insn.  */
name|insn
operator|=
literal|0xea000000
operator||
operator|(
operator|(
name|branch_from_veneer
operator|>>
literal|2
operator|)
operator|&
literal|0xffffff
operator|)
expr_stmt|;
name|contents
index|[
name|endianflip
operator|^
operator|(
name|index
operator|+
literal|4
operator|)
index|]
operator|=
name|insn
operator|&
literal|0xff
expr_stmt|;
name|contents
index|[
name|endianflip
operator|^
operator|(
name|index
operator|+
literal|5
operator|)
index|]
operator|=
operator|(
name|insn
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|contents
index|[
name|endianflip
operator|^
operator|(
name|index
operator|+
literal|6
operator|)
index|]
operator|=
operator|(
name|insn
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|contents
index|[
name|endianflip
operator|^
operator|(
name|index
operator|+
literal|7
operator|)
index|]
operator|=
operator|(
name|insn
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|mapcount
operator|==
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|globals
operator|->
name|byteswap_code
condition|)
block|{
name|qsort
argument_list|(
name|map
argument_list|,
name|mapcount
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|map
argument_list|)
argument_list|,
name|elf32_arm_compare_mapping
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|map
index|[
literal|0
index|]
operator|.
name|vma
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mapcount
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|mapcount
operator|-
literal|1
condition|)
name|end
operator|=
name|sec
operator|->
name|size
expr_stmt|;
else|else
name|end
operator|=
name|map
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|vma
expr_stmt|;
switch|switch
condition|(
name|map
index|[
name|i
index|]
operator|.
name|type
condition|)
block|{
case|case
literal|'a'
case|:
comment|/* Byte swap code words.  */
while|while
condition|(
name|ptr
operator|+
literal|3
operator|<
name|end
condition|)
block|{
name|tmp
operator|=
name|contents
index|[
name|ptr
index|]
expr_stmt|;
name|contents
index|[
name|ptr
index|]
operator|=
name|contents
index|[
name|ptr
operator|+
literal|3
index|]
expr_stmt|;
name|contents
index|[
name|ptr
operator|+
literal|3
index|]
operator|=
name|tmp
expr_stmt|;
name|tmp
operator|=
name|contents
index|[
name|ptr
operator|+
literal|1
index|]
expr_stmt|;
name|contents
index|[
name|ptr
operator|+
literal|1
index|]
operator|=
name|contents
index|[
name|ptr
operator|+
literal|2
index|]
expr_stmt|;
name|contents
index|[
name|ptr
operator|+
literal|2
index|]
operator|=
name|tmp
expr_stmt|;
name|ptr
operator|+=
literal|4
expr_stmt|;
block|}
break|break;
case|case
literal|'t'
case|:
comment|/* Byte swap code halfwords.  */
while|while
condition|(
name|ptr
operator|+
literal|1
operator|<
name|end
condition|)
block|{
name|tmp
operator|=
name|contents
index|[
name|ptr
index|]
expr_stmt|;
name|contents
index|[
name|ptr
index|]
operator|=
name|contents
index|[
name|ptr
operator|+
literal|1
index|]
expr_stmt|;
name|contents
index|[
name|ptr
operator|+
literal|1
index|]
operator|=
name|tmp
expr_stmt|;
name|ptr
operator|+=
literal|2
expr_stmt|;
block|}
break|break;
case|case
literal|'d'
case|:
comment|/* Leave data alone.  */
break|break;
block|}
name|ptr
operator|=
name|end
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|arm_data
operator|->
name|mapcount
operator|=
literal|0
expr_stmt|;
name|arm_data
operator|->
name|mapsize
operator|=
literal|0
expr_stmt|;
name|arm_data
operator|->
name|map
operator|=
name|NULL
expr_stmt|;
name|unrecord_section_with_arm_elf_section_data
argument_list|(
name|sec
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|unrecord_section_via_map_over_sections
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|void
modifier|*
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|unrecord_section_with_arm_elf_section_data
argument_list|(
name|sec
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elf32_arm_close_and_cleanup
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
if|if
condition|(
name|abfd
operator|->
name|sections
condition|)
name|bfd_map_over_sections
argument_list|(
name|abfd
argument_list|,
name|unrecord_section_via_map_over_sections
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|_bfd_elf_close_and_cleanup
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elf32_arm_bfd_free_cached_info
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
if|if
condition|(
name|abfd
operator|->
name|sections
condition|)
name|bfd_map_over_sections
argument_list|(
name|abfd
argument_list|,
name|unrecord_section_via_map_over_sections
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|_bfd_free_cached_info
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Display STT_ARM_TFUNC symbols as functions.  */
end_comment

begin_function
specifier|static
name|void
name|elf32_arm_symbol_processing
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asymbol
modifier|*
name|asym
parameter_list|)
block|{
name|elf_symbol_type
modifier|*
name|elfsym
init|=
operator|(
name|elf_symbol_type
operator|*
operator|)
name|asym
decl_stmt|;
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|elfsym
operator|->
name|internal_elf_sym
operator|.
name|st_info
argument_list|)
operator|==
name|STT_ARM_TFUNC
condition|)
name|elfsym
operator|->
name|symbol
operator|.
name|flags
operator||=
name|BSF_FUNCTION
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mangle thumb function symbols as we read them in.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_arm_swap_symbol_in
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|void
modifier|*
name|psrc
parameter_list|,
specifier|const
name|void
modifier|*
name|pshn
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|dst
parameter_list|)
block|{
if|if
condition|(
operator|!
name|bfd_elf32_swap_symbol_in
argument_list|(
name|abfd
argument_list|,
name|psrc
argument_list|,
name|pshn
argument_list|,
name|dst
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* New EABI objects mark thumb function symbols by setting the low bit of      the address.  Turn these into STT_ARM_TFUNC.  */
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|dst
operator|->
name|st_info
argument_list|)
operator|==
name|STT_FUNC
operator|&&
operator|(
name|dst
operator|->
name|st_value
operator|&
literal|1
operator|)
condition|)
block|{
name|dst
operator|->
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|ELF_ST_BIND
argument_list|(
name|dst
operator|->
name|st_info
argument_list|)
argument_list|,
name|STT_ARM_TFUNC
argument_list|)
expr_stmt|;
name|dst
operator|->
name|st_value
operator|&=
operator|~
operator|(
name|bfd_vma
operator|)
literal|1
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Mangle thumb function symbols as we write them out.  */
end_comment

begin_function
specifier|static
name|void
name|elf32_arm_swap_symbol_out
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|Elf_Internal_Sym
modifier|*
name|src
parameter_list|,
name|void
modifier|*
name|cdst
parameter_list|,
name|void
modifier|*
name|shndx
parameter_list|)
block|{
name|Elf_Internal_Sym
name|newsym
decl_stmt|;
comment|/* We convert STT_ARM_TFUNC symbols into STT_FUNC with the low bit      of the address set, as per the new EABI.  We do this unconditionally      because objcopy does not set the elf header flags until after      it writes out the symbol table.  */
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|src
operator|->
name|st_info
argument_list|)
operator|==
name|STT_ARM_TFUNC
condition|)
block|{
name|newsym
operator|=
operator|*
name|src
expr_stmt|;
name|newsym
operator|.
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|ELF_ST_BIND
argument_list|(
name|src
operator|->
name|st_info
argument_list|)
argument_list|,
name|STT_FUNC
argument_list|)
expr_stmt|;
if|if
condition|(
name|newsym
operator|.
name|st_shndx
operator|!=
name|SHN_UNDEF
condition|)
block|{
comment|/* Do this only for defined symbols. At link type, the static              linker will simulate the work of dynamic linker of resolving              symbols and will carry over the thumbness of found symbols to              the output symbol table. It's not clear how it happens, but              the thumbness of undefined symbols can well be different at              runtime, and writing '1' for them will be confusing for users              and possibly for dynamic linker itself.           */
name|newsym
operator|.
name|st_value
operator||=
literal|1
expr_stmt|;
block|}
name|src
operator|=
operator|&
name|newsym
expr_stmt|;
block|}
name|bfd_elf32_swap_symbol_out
argument_list|(
name|abfd
argument_list|,
name|src
argument_list|,
name|cdst
argument_list|,
name|shndx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add the PT_ARM_EXIDX program header.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_arm_modify_segment_map
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|struct
name|elf_segment_map
modifier|*
name|m
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".ARM.exidx"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|!=
name|NULL
operator|&&
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* If there is already a PT_ARM_EXIDX header, then we do not 	 want to add another one.  This situation arises when running 	 "strip"; the input binary already has the header.  */
name|m
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_map
expr_stmt|;
while|while
condition|(
name|m
operator|&&
name|m
operator|->
name|p_type
operator|!=
name|PT_ARM_EXIDX
condition|)
name|m
operator|=
name|m
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|m
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|elf_segment_map
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|m
operator|->
name|p_type
operator|=
name|PT_ARM_EXIDX
expr_stmt|;
name|m
operator|->
name|count
operator|=
literal|1
expr_stmt|;
name|m
operator|->
name|sections
index|[
literal|0
index|]
operator|=
name|sec
expr_stmt|;
name|m
operator|->
name|next
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_map
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_map
operator|=
name|m
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* We may add a PT_ARM_EXIDX program header.  */
end_comment

begin_function
specifier|static
name|int
name|elf32_arm_additional_program_headers
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".ARM.exidx"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|!=
name|NULL
operator|&&
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* We have two function types: STT_FUNC and STT_ARM_TFUNC.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_arm_is_function_type
parameter_list|(
name|unsigned
name|int
name|type
parameter_list|)
block|{
return|return
operator|(
name|type
operator|==
name|STT_FUNC
operator|)
operator|||
operator|(
name|type
operator|==
name|STT_ARM_TFUNC
operator|)
return|;
block|}
end_function

begin_comment
comment|/* We use this to override swap_symbol_in and swap_symbol_out.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|elf_size_info
name|elf32_arm_size_info
init|=
block|{
sizeof|sizeof
argument_list|(
name|Elf32_External_Ehdr
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|Elf32_External_Phdr
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|Elf32_External_Shdr
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|Elf32_External_Sym
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|Elf32_External_Dyn
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|Elf_External_Note
argument_list|)
block|,
literal|4
block|,
literal|1
block|,
literal|32
block|,
literal|2
block|,
name|ELFCLASS32
block|,
name|EV_CURRENT
block|,
name|bfd_elf32_write_out_phdrs
block|,
name|bfd_elf32_write_shdrs_and_ehdr
block|,
name|bfd_elf32_write_relocs
block|,
name|elf32_arm_swap_symbol_in
block|,
name|elf32_arm_swap_symbol_out
block|,
name|bfd_elf32_slurp_reloc_table
block|,
name|bfd_elf32_slurp_symbol_table
block|,
name|bfd_elf32_swap_dyn_in
block|,
name|bfd_elf32_swap_dyn_out
block|,
name|bfd_elf32_swap_reloc_in
block|,
name|bfd_elf32_swap_reloc_out
block|,
name|bfd_elf32_swap_reloca_in
block|,
name|bfd_elf32_swap_reloca_out
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ELF_ARCH
value|bfd_arch_arm
end_define

begin_define
define|#
directive|define
name|ELF_MACHINE_CODE
value|EM_ARM
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__QNXTARGET__
end_ifdef

begin_define
define|#
directive|define
name|ELF_MAXPAGESIZE
value|0x1000
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ELF_MAXPAGESIZE
value|0x8000
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ELF_MINPAGESIZE
value|0x1000
end_define

begin_define
define|#
directive|define
name|ELF_COMMONPAGESIZE
value|0x1000
end_define

begin_define
define|#
directive|define
name|bfd_elf32_mkobject
value|elf32_arm_mkobject
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_copy_private_bfd_data
value|elf32_arm_copy_private_bfd_data
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_merge_private_bfd_data
value|elf32_arm_merge_private_bfd_data
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_set_private_flags
value|elf32_arm_set_private_flags
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_print_private_bfd_data
value|elf32_arm_print_private_bfd_data
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_link_hash_table_create
value|elf32_arm_link_hash_table_create
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_reloc_type_lookup
value|elf32_arm_reloc_type_lookup
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_reloc_name_lookup
value|elf32_arm_reloc_name_lookup
end_define

begin_define
define|#
directive|define
name|bfd_elf32_find_nearest_line
value|elf32_arm_find_nearest_line
end_define

begin_define
define|#
directive|define
name|bfd_elf32_find_inliner_info
value|elf32_arm_find_inliner_info
end_define

begin_define
define|#
directive|define
name|bfd_elf32_new_section_hook
value|elf32_arm_new_section_hook
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_is_target_special_symbol
value|elf32_arm_is_target_special_symbol
end_define

begin_define
define|#
directive|define
name|bfd_elf32_close_and_cleanup
value|elf32_arm_close_and_cleanup
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_free_cached_info
value|elf32_arm_bfd_free_cached_info
end_define

begin_define
define|#
directive|define
name|elf_backend_get_symbol_type
value|elf32_arm_get_symbol_type
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_mark_hook
value|elf32_arm_gc_mark_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_mark_extra_sections
value|elf32_arm_gc_mark_extra_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_sweep_hook
value|elf32_arm_gc_sweep_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_check_relocs
value|elf32_arm_check_relocs
end_define

begin_define
define|#
directive|define
name|elf_backend_relocate_section
value|elf32_arm_relocate_section
end_define

begin_define
define|#
directive|define
name|elf_backend_write_section
value|elf32_arm_write_section
end_define

begin_define
define|#
directive|define
name|elf_backend_adjust_dynamic_symbol
value|elf32_arm_adjust_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_create_dynamic_sections
value|elf32_arm_create_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_symbol
value|elf32_arm_finish_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_sections
value|elf32_arm_finish_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_size_dynamic_sections
value|elf32_arm_size_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_init_index_section
value|_bfd_elf_init_2_index_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_post_process_headers
value|elf32_arm_post_process_headers
end_define

begin_define
define|#
directive|define
name|elf_backend_reloc_type_class
value|elf32_arm_reloc_type_class
end_define

begin_define
define|#
directive|define
name|elf_backend_object_p
value|elf32_arm_object_p
end_define

begin_define
define|#
directive|define
name|elf_backend_section_flags
value|elf32_arm_section_flags
end_define

begin_define
define|#
directive|define
name|elf_backend_fake_sections
value|elf32_arm_fake_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_section_from_shdr
value|elf32_arm_section_from_shdr
end_define

begin_define
define|#
directive|define
name|elf_backend_final_write_processing
value|elf32_arm_final_write_processing
end_define

begin_define
define|#
directive|define
name|elf_backend_copy_indirect_symbol
value|elf32_arm_copy_indirect_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_symbol_processing
value|elf32_arm_symbol_processing
end_define

begin_define
define|#
directive|define
name|elf_backend_size_info
value|elf32_arm_size_info
end_define

begin_define
define|#
directive|define
name|elf_backend_modify_segment_map
value|elf32_arm_modify_segment_map
end_define

begin_define
define|#
directive|define
name|elf_backend_additional_program_headers
define|\
value|elf32_arm_additional_program_headers
end_define

begin_define
define|#
directive|define
name|elf_backend_output_arch_local_syms
define|\
value|elf32_arm_output_arch_local_syms
end_define

begin_define
define|#
directive|define
name|elf_backend_begin_write_processing
define|\
value|elf32_arm_begin_write_processing
end_define

begin_define
define|#
directive|define
name|elf_backend_is_function_type
value|elf32_arm_is_function_type
end_define

begin_define
define|#
directive|define
name|elf_backend_can_refcount
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_can_gc_sections
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_plt_readonly
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_want_got_plt
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_want_plt_sym
value|0
end_define

begin_define
define|#
directive|define
name|elf_backend_may_use_rel_p
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_may_use_rela_p
value|0
end_define

begin_define
define|#
directive|define
name|elf_backend_default_use_rela_p
value|0
end_define

begin_define
define|#
directive|define
name|elf_backend_got_header_size
value|12
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_obj_attrs_vendor
end_undef

begin_define
define|#
directive|define
name|elf_backend_obj_attrs_vendor
value|"aeabi"
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_obj_attrs_section
end_undef

begin_define
define|#
directive|define
name|elf_backend_obj_attrs_section
value|".ARM.attributes"
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_obj_attrs_arg_type
end_undef

begin_define
define|#
directive|define
name|elf_backend_obj_attrs_arg_type
value|elf32_arm_obj_attrs_arg_type
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_obj_attrs_section_type
end_undef

begin_define
define|#
directive|define
name|elf_backend_obj_attrs_section_type
value|SHT_ARM_ATTRIBUTES
end_define

begin_include
include|#
directive|include
file|"elf32-target.h"
end_include

begin_comment
comment|/* VxWorks Targets */
end_comment

begin_undef
undef|#
directive|undef
name|TARGET_LITTLE_SYM
end_undef

begin_define
define|#
directive|define
name|TARGET_LITTLE_SYM
value|bfd_elf32_littlearm_vxworks_vec
end_define

begin_undef
undef|#
directive|undef
name|TARGET_LITTLE_NAME
end_undef

begin_define
define|#
directive|define
name|TARGET_LITTLE_NAME
value|"elf32-littlearm-vxworks"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_BIG_SYM
end_undef

begin_define
define|#
directive|define
name|TARGET_BIG_SYM
value|bfd_elf32_bigarm_vxworks_vec
end_define

begin_undef
undef|#
directive|undef
name|TARGET_BIG_NAME
end_undef

begin_define
define|#
directive|define
name|TARGET_BIG_NAME
value|"elf32-bigarm-vxworks"
end_define

begin_comment
comment|/* Like elf32_arm_link_hash_table_create -- but overrides    appropriately for VxWorks.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_link_hash_table
modifier|*
name|elf32_arm_vxworks_link_hash_table_create
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|struct
name|bfd_link_hash_table
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
name|elf32_arm_link_hash_table_create
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|struct
name|elf32_arm_link_hash_table
modifier|*
name|htab
init|=
operator|(
expr|struct
name|elf32_arm_link_hash_table
operator|*
operator|)
name|ret
decl_stmt|;
name|htab
operator|->
name|use_rel
operator|=
literal|0
expr_stmt|;
name|htab
operator|->
name|vxworks_p
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|elf32_arm_vxworks_final_write_processing
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_boolean
name|linker
parameter_list|)
block|{
name|elf32_arm_final_write_processing
argument_list|(
name|abfd
argument_list|,
name|linker
argument_list|)
expr_stmt|;
name|elf_vxworks_final_write_processing
argument_list|(
name|abfd
argument_list|,
name|linker
argument_list|)
expr_stmt|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|elf32_bed
end_undef

begin_define
define|#
directive|define
name|elf32_bed
value|elf32_arm_vxworks_bed
end_define

begin_undef
undef|#
directive|undef
name|bfd_elf32_bfd_link_hash_table_create
end_undef

begin_define
define|#
directive|define
name|bfd_elf32_bfd_link_hash_table_create
define|\
value|elf32_arm_vxworks_link_hash_table_create
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_add_symbol_hook
end_undef

begin_define
define|#
directive|define
name|elf_backend_add_symbol_hook
define|\
value|elf_vxworks_add_symbol_hook
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_final_write_processing
end_undef

begin_define
define|#
directive|define
name|elf_backend_final_write_processing
define|\
value|elf32_arm_vxworks_final_write_processing
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_emit_relocs
end_undef

begin_define
define|#
directive|define
name|elf_backend_emit_relocs
define|\
value|elf_vxworks_emit_relocs
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_may_use_rel_p
end_undef

begin_define
define|#
directive|define
name|elf_backend_may_use_rel_p
value|0
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_may_use_rela_p
end_undef

begin_define
define|#
directive|define
name|elf_backend_may_use_rela_p
value|1
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_default_use_rela_p
end_undef

begin_define
define|#
directive|define
name|elf_backend_default_use_rela_p
value|1
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_want_plt_sym
end_undef

begin_define
define|#
directive|define
name|elf_backend_want_plt_sym
value|1
end_define

begin_undef
undef|#
directive|undef
name|ELF_MAXPAGESIZE
end_undef

begin_define
define|#
directive|define
name|ELF_MAXPAGESIZE
value|0x1000
end_define

begin_include
include|#
directive|include
file|"elf32-target.h"
end_include

begin_comment
comment|/* Symbian OS Targets */
end_comment

begin_undef
undef|#
directive|undef
name|TARGET_LITTLE_SYM
end_undef

begin_define
define|#
directive|define
name|TARGET_LITTLE_SYM
value|bfd_elf32_littlearm_symbian_vec
end_define

begin_undef
undef|#
directive|undef
name|TARGET_LITTLE_NAME
end_undef

begin_define
define|#
directive|define
name|TARGET_LITTLE_NAME
value|"elf32-littlearm-symbian"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_BIG_SYM
end_undef

begin_define
define|#
directive|define
name|TARGET_BIG_SYM
value|bfd_elf32_bigarm_symbian_vec
end_define

begin_undef
undef|#
directive|undef
name|TARGET_BIG_NAME
end_undef

begin_define
define|#
directive|define
name|TARGET_BIG_NAME
value|"elf32-bigarm-symbian"
end_define

begin_comment
comment|/* Like elf32_arm_link_hash_table_create -- but overrides    appropriately for Symbian OS.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_link_hash_table
modifier|*
name|elf32_arm_symbian_link_hash_table_create
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|struct
name|bfd_link_hash_table
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
name|elf32_arm_link_hash_table_create
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|struct
name|elf32_arm_link_hash_table
modifier|*
name|htab
init|=
operator|(
expr|struct
name|elf32_arm_link_hash_table
operator|*
operator|)
name|ret
decl_stmt|;
comment|/* There is no PLT header for Symbian OS.  */
name|htab
operator|->
name|plt_header_size
operator|=
literal|0
expr_stmt|;
comment|/* The PLT entries are each three instructions.  */
name|htab
operator|->
name|plt_entry_size
operator|=
literal|4
operator|*
name|NUM_ELEM
argument_list|(
name|elf32_arm_symbian_plt_entry
argument_list|)
expr_stmt|;
name|htab
operator|->
name|symbian_p
operator|=
literal|1
expr_stmt|;
comment|/* Symbian uses armv5t or above, so use_blx is always true.  */
name|htab
operator|->
name|use_blx
operator|=
literal|1
expr_stmt|;
name|htab
operator|->
name|root
operator|.
name|is_relocatable_executable
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|bfd_elf_special_section
name|elf32_arm_symbian_special_sections
index|[]
init|=
block|{
comment|/* In a BPABI executable, the dynamic linking sections do not go in      the loadable read-only segment.  The post-linker may wish to      refer to these sections, but they are not part of the final      program image.  */
block|{
name|STRING_COMMA_LEN
argument_list|(
literal|".dynamic"
argument_list|)
block|,
literal|0
block|,
name|SHT_DYNAMIC
block|,
literal|0
block|}
block|,
block|{
name|STRING_COMMA_LEN
argument_list|(
literal|".dynstr"
argument_list|)
block|,
literal|0
block|,
name|SHT_STRTAB
block|,
literal|0
block|}
block|,
block|{
name|STRING_COMMA_LEN
argument_list|(
literal|".dynsym"
argument_list|)
block|,
literal|0
block|,
name|SHT_DYNSYM
block|,
literal|0
block|}
block|,
block|{
name|STRING_COMMA_LEN
argument_list|(
literal|".got"
argument_list|)
block|,
literal|0
block|,
name|SHT_PROGBITS
block|,
literal|0
block|}
block|,
block|{
name|STRING_COMMA_LEN
argument_list|(
literal|".hash"
argument_list|)
block|,
literal|0
block|,
name|SHT_HASH
block|,
literal|0
block|}
block|,
comment|/* These sections do not need to be writable as the SymbianOS      postlinker will arrange things so that no dynamic relocation is      required.  */
block|{
name|STRING_COMMA_LEN
argument_list|(
literal|".init_array"
argument_list|)
block|,
literal|0
block|,
name|SHT_INIT_ARRAY
block|,
name|SHF_ALLOC
block|}
block|,
block|{
name|STRING_COMMA_LEN
argument_list|(
literal|".fini_array"
argument_list|)
block|,
literal|0
block|,
name|SHT_FINI_ARRAY
block|,
name|SHF_ALLOC
block|}
block|,
block|{
name|STRING_COMMA_LEN
argument_list|(
literal|".preinit_array"
argument_list|)
block|,
literal|0
block|,
name|SHT_PREINIT_ARRAY
block|,
name|SHF_ALLOC
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|elf32_arm_symbian_begin_write_processing
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
parameter_list|)
block|{
comment|/* BPABI objects are never loaded directly by an OS kernel; they are      processed by a postlinker first, into an OS-specific format.  If      the D_PAGED bit is set on the file, BFD will align segments on      page boundaries, so that an OS can directly map the file.  With      BPABI objects, that just results in wasted space.  In addition,      because we clear the D_PAGED bit, map_sections_to_segments will      recognize that the program headers should not be mapped into any      loadable segment.  */
name|abfd
operator|->
name|flags
operator|&=
operator|~
name|D_PAGED
expr_stmt|;
name|elf32_arm_begin_write_processing
argument_list|(
name|abfd
argument_list|,
name|link_info
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elf32_arm_symbian_modify_segment_map
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|elf_segment_map
modifier|*
name|m
decl_stmt|;
name|asection
modifier|*
name|dynsec
decl_stmt|;
comment|/* BPABI shared libraries and executables should have a PT_DYNAMIC      segment.  However, because the .dynamic section is not marked      with SEC_LOAD, the generic ELF code will not create such a      segment.  */
name|dynsec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynsec
condition|)
block|{
for|for
control|(
name|m
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_map
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
if|if
condition|(
name|m
operator|->
name|p_type
operator|==
name|PT_DYNAMIC
condition|)
break|break;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|m
operator|=
name|_bfd_elf_make_dynamic_segment
argument_list|(
name|abfd
argument_list|,
name|dynsec
argument_list|)
expr_stmt|;
name|m
operator|->
name|next
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_map
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_map
operator|=
name|m
expr_stmt|;
block|}
block|}
comment|/* Also call the generic arm routine.  */
return|return
name|elf32_arm_modify_segment_map
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|elf32_bed
end_undef

begin_define
define|#
directive|define
name|elf32_bed
value|elf32_arm_symbian_bed
end_define

begin_comment
comment|/* The dynamic sections are not allocated on SymbianOS; the postlinker    will process them and then discard them.  */
end_comment

begin_undef
undef|#
directive|undef
name|ELF_DYNAMIC_SEC_FLAGS
end_undef

begin_define
define|#
directive|define
name|ELF_DYNAMIC_SEC_FLAGS
define|\
value|(SEC_HAS_CONTENTS | SEC_IN_MEMORY | SEC_LINKER_CREATED)
end_define

begin_undef
undef|#
directive|undef
name|bfd_elf32_bfd_link_hash_table_create
end_undef

begin_define
define|#
directive|define
name|bfd_elf32_bfd_link_hash_table_create
define|\
value|elf32_arm_symbian_link_hash_table_create
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_add_symbol_hook
end_undef

begin_undef
undef|#
directive|undef
name|elf_backend_special_sections
end_undef

begin_define
define|#
directive|define
name|elf_backend_special_sections
value|elf32_arm_symbian_special_sections
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_begin_write_processing
end_undef

begin_define
define|#
directive|define
name|elf_backend_begin_write_processing
define|\
value|elf32_arm_symbian_begin_write_processing
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_final_write_processing
end_undef

begin_define
define|#
directive|define
name|elf_backend_final_write_processing
define|\
value|elf32_arm_final_write_processing
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_emit_relocs
end_undef

begin_undef
undef|#
directive|undef
name|elf_backend_modify_segment_map
end_undef

begin_define
define|#
directive|define
name|elf_backend_modify_segment_map
value|elf32_arm_symbian_modify_segment_map
end_define

begin_comment
comment|/* There is no .got section for BPABI objects, and hence no header.  */
end_comment

begin_undef
undef|#
directive|undef
name|elf_backend_got_header_size
end_undef

begin_define
define|#
directive|define
name|elf_backend_got_header_size
value|0
end_define

begin_comment
comment|/* Similarly, there is no .got.plt section.  */
end_comment

begin_undef
undef|#
directive|undef
name|elf_backend_want_got_plt
end_undef

begin_define
define|#
directive|define
name|elf_backend_want_got_plt
value|0
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_may_use_rel_p
end_undef

begin_define
define|#
directive|define
name|elf_backend_may_use_rel_p
value|1
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_may_use_rela_p
end_undef

begin_define
define|#
directive|define
name|elf_backend_may_use_rela_p
value|0
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_default_use_rela_p
end_undef

begin_define
define|#
directive|define
name|elf_backend_default_use_rela_p
value|0
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_want_plt_sym
end_undef

begin_define
define|#
directive|define
name|elf_backend_want_plt_sym
value|0
end_define

begin_undef
undef|#
directive|undef
name|ELF_MAXPAGESIZE
end_undef

begin_define
define|#
directive|define
name|ELF_MAXPAGESIZE
value|0x8000
end_define

begin_include
include|#
directive|include
file|"elf32-target.h"
end_include

end_unit

