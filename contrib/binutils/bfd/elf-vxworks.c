begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* VxWorks support for ELF    Copyright 2005, 2007 Free Software Foundation, Inc.     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file provides routines used by all VxWorks targets.  */
end_comment

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf-vxworks.h"
end_include

begin_comment
comment|/* Return true if symbol NAME, as defined by ABFD, is one of the special    __GOTT_BASE__ or __GOTT_INDEX__ symbols.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_vxworks_gott_symbol_p
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|char
name|leading
decl_stmt|;
name|leading
operator|=
name|bfd_get_symbol_leading_char
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|leading
condition|)
block|{
if|if
condition|(
operator|*
name|name
operator|!=
name|leading
condition|)
return|return
name|FALSE
return|;
name|name
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"__GOTT_BASE__"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"__GOTT_INDEX__"
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Tweak magic VxWorks symbols as they are loaded.  */
end_comment

begin_function
name|bfd_boolean
name|elf_vxworks_add_symbol_hook
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|namep
parameter_list|,
name|flagword
modifier|*
name|flagsp
parameter_list|,
name|asection
modifier|*
modifier|*
name|secp
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd_vma
modifier|*
name|valp
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* Ideally these "magic" symbols would be exported by libc.so.1      which would be found via a DT_NEEDED tag, and then handled      specially by the linker at runtime.  Except shared libraries      don't even link to libc.so.1 by default...      If the symbol is imported from, or will be put in a shared library,      give the symbol weak binding to get the desired samantics.      This transformation will be undone in      elf_i386_vxworks_link_output_symbol_hook. */
if|if
condition|(
operator|(
name|info
operator|->
name|shared
operator|||
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|&&
name|elf_vxworks_gott_symbol_p
argument_list|(
name|abfd
argument_list|,
operator|*
name|namep
argument_list|)
condition|)
block|{
name|sym
operator|->
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_WEAK
argument_list|,
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|flagsp
operator||=
name|BSF_WEAK
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Perform VxWorks-specific handling of the create_dynamic_sections hook.    When creating an executable, set *SRELPLT2_OUT to the .rel(a).plt.unloaded    section.  */
end_comment

begin_function
name|bfd_boolean
name|elf_vxworks_create_dynamic_sections
parameter_list|(
name|bfd
modifier|*
name|dynobj
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|asection
modifier|*
modifier|*
name|srelplt2_out
parameter_list|)
block|{
name|struct
name|elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|htab
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|dynobj
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
name|s
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|dynobj
argument_list|,
name|bed
operator|->
name|default_use_rela_p
condition|?
literal|".rela.plt.unloaded"
else|:
literal|".rel.plt.unloaded"
argument_list|,
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_READONLY
operator||
name|SEC_LINKER_CREATED
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|,
name|bed
operator|->
name|s
operator|->
name|log_file_align
argument_list|)
condition|)
return|return
name|FALSE
return|;
operator|*
name|srelplt2_out
operator|=
name|s
expr_stmt|;
block|}
comment|/* Mark the GOT and PLT symbols as having relocations; they might      not, but we won't know for sure until we build the GOT in      finish_dynamic_symbol.  Also make sure that the GOT symbol      is entered into the dynamic symbol table; the loader uses it      to initialize __GOTT_BASE__[__GOTT_INDEX__].  */
if|if
condition|(
name|htab
operator|->
name|hgot
condition|)
block|{
name|htab
operator|->
name|hgot
operator|->
name|indx
operator|=
operator|-
literal|2
expr_stmt|;
name|htab
operator|->
name|hgot
operator|->
name|other
operator|&=
operator|~
name|ELF_ST_VISIBILITY
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|htab
operator|->
name|hgot
operator|->
name|forced_local
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|htab
operator|->
name|hgot
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|htab
operator|->
name|hplt
condition|)
block|{
name|htab
operator|->
name|hplt
operator|->
name|indx
operator|=
operator|-
literal|2
expr_stmt|;
name|htab
operator|->
name|hplt
operator|->
name|type
operator|=
name|STT_FUNC
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Tweak magic VxWorks symbols as they are written to the output file.  */
end_comment

begin_function
name|bfd_boolean
name|elf_vxworks_link_output_symbol_hook
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|,
name|asection
modifier|*
name|input_sec
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|)
block|{
comment|/* Reverse the effects of the hack in elf_vxworks_add_symbol_hook.  */
if|if
condition|(
name|h
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|&&
name|elf_vxworks_gott_symbol_p
argument_list|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|undef
operator|.
name|abfd
argument_list|,
name|name
argument_list|)
condition|)
name|sym
operator|->
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_GLOBAL
argument_list|,
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Copy relocations into the output file.  Fixes up relocations againt PLT    entries, then calls the generic routine.  */
end_comment

begin_function
name|bfd_boolean
name|elf_vxworks_emit_relocs
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|Elf_Internal_Shdr
modifier|*
name|input_rel_hdr
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|rel_hash
parameter_list|)
block|{
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irela
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irelaend
decl_stmt|;
name|int
name|j
decl_stmt|;
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
name|irela
operator|=
name|internal_relocs
expr_stmt|;
name|irelaend
operator|=
name|irela
operator|+
operator|(
name|NUM_SHDR_ENTRIES
argument_list|(
name|input_rel_hdr
argument_list|)
operator|*
name|bed
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
operator|)
expr_stmt|;
while|while
condition|(
name|irela
operator|<
name|irelaend
condition|)
block|{
if|if
condition|(
operator|(
name|output_bfd
operator|->
name|flags
operator|&
operator|(
name|DYNAMIC
operator||
name|EXEC_P
operator|)
operator|)
operator|&&
operator|*
name|rel_hash
operator|&&
operator|(
operator|*
name|rel_hash
operator|)
operator|->
name|def_dynamic
operator|&&
operator|!
operator|(
operator|*
name|rel_hash
operator|)
operator|->
name|def_regular
operator|&&
operator|(
operator|(
operator|*
name|rel_hash
operator|)
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
operator|(
operator|*
name|rel_hash
operator|)
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
operator|(
operator|*
name|rel_hash
operator|)
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|!=
name|NULL
condition|)
block|{
comment|/* This is a relocation from an executable or shared library 	     against a symbol in a different shared library.  We are 	     creating a definition in the output file but it does not come 	     from any of our normal (.o) files. ie. a PLT stub. 	     Normally this would be a relocation against against SHN_UNDEF 	     with the VMA of the PLT stub.  This upsets the VxWorks loader. 	     Convert it to a section-relative relocation. 	     This gets some other symbols (for instance .dynbss), 	     but is conservatively correct.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|bed
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
condition|;
name|j
operator|++
control|)
block|{
name|asection
modifier|*
name|sec
init|=
operator|(
operator|*
name|rel_hash
operator|)
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
decl_stmt|;
name|int
name|this_idx
init|=
name|sec
operator|->
name|output_section
operator|->
name|target_index
decl_stmt|;
name|irela
index|[
name|j
index|]
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|this_idx
argument_list|,
name|ELF32_R_TYPE
argument_list|(
name|irela
index|[
name|j
index|]
operator|.
name|r_info
argument_list|)
argument_list|)
expr_stmt|;
name|irela
index|[
name|j
index|]
operator|.
name|r_addend
operator|+=
operator|(
operator|*
name|rel_hash
operator|)
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
name|irela
index|[
name|j
index|]
operator|.
name|r_addend
operator|+=
name|sec
operator|->
name|output_offset
expr_stmt|;
block|}
comment|/* Stop the generic routine adjusting this entry.  */
operator|*
name|rel_hash
operator|=
name|NULL
expr_stmt|;
block|}
name|irela
operator|+=
name|bed
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
expr_stmt|;
name|rel_hash
operator|++
expr_stmt|;
block|}
return|return
name|_bfd_elf_link_output_relocs
argument_list|(
name|output_bfd
argument_list|,
name|input_section
argument_list|,
name|input_rel_hdr
argument_list|,
name|internal_relocs
argument_list|,
name|rel_hash
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Set the sh_link and sh_info fields on the static plt relocation secton.  */
end_comment

begin_function
name|void
name|elf_vxworks_final_write_processing
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_boolean
name|linker
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|bfd_elf_section_data
modifier|*
name|d
decl_stmt|;
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".rel.plt.unloaded"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sec
condition|)
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".rela.plt.unloaded"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sec
condition|)
return|return;
name|d
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
expr_stmt|;
name|d
operator|->
name|this_hdr
operator|.
name|sh_link
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_section
expr_stmt|;
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
condition|)
name|d
operator|->
name|this_hdr
operator|.
name|sh_info
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_idx
expr_stmt|;
block|}
end_function

end_unit

