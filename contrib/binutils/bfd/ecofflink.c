begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Routines to link ECOFF debugging information.    Copyright 1993, 1994, 1995, 1996, 1997, 1999, 2000, 2001, 2002, 2003,    2004, 2005, 2006, 2007 Free Software Foundation, Inc.    Written by Ian Lance Taylor, Cygnus Support,<ian@cygnus.com>.     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"objalloc.h"
end_include

begin_include
include|#
directive|include
file|"aout/stab_gnu.h"
end_include

begin_include
include|#
directive|include
file|"coff/internal.h"
end_include

begin_include
include|#
directive|include
file|"coff/sym.h"
end_include

begin_include
include|#
directive|include
file|"coff/symconst.h"
end_include

begin_include
include|#
directive|include
file|"coff/ecoff.h"
end_include

begin_include
include|#
directive|include
file|"libcoff.h"
end_include

begin_include
include|#
directive|include
file|"libecoff.h"
end_include

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|bfd_boolean
name|ecoff_add_bytes
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
name|buf
operator|,
name|char
operator|*
operator|*
name|bufend
operator|,
name|size_t
name|need
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|string_hash_newfunc
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|,
expr|struct
name|bfd_hash_table
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ecoff_align_debug
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
expr|struct
name|ecoff_debug_info
operator|*
name|debug
operator|,
specifier|const
expr|struct
name|ecoff_debug_swap
operator|*
name|swap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|ecoff_write_symhdr
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|ecoff_debug_info
operator|*
operator|,
specifier|const
expr|struct
name|ecoff_debug_swap
operator|*
operator|,
name|file_ptr
name|where
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cmp_fdrtab_entry
name|PARAMS
argument_list|(
operator|(
specifier|const
name|PTR
operator|,
specifier|const
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|mk_fdrtab
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|ecoff_debug_info
operator|*
specifier|const
operator|,
specifier|const
expr|struct
name|ecoff_debug_swap
operator|*
specifier|const
operator|,
expr|struct
name|ecoff_find_line
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|fdrtab_lookup
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ecoff_find_line
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|lookup_line
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|ecoff_debug_info
operator|*
specifier|const
operator|,
specifier|const
expr|struct
name|ecoff_debug_swap
operator|*
specifier|const
operator|,
expr|struct
name|ecoff_find_line
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Routines to swap auxiliary information in and out.  I am assuming    that the auxiliary information format is always going to be target    independent.  */
end_comment

begin_comment
comment|/* Swap in a type information record.    BIGEND says whether AUX symbols are big-endian or little-endian; this    info comes from the file header record (fh-fBigendian).  */
end_comment

begin_function
name|void
name|_bfd_ecoff_swap_tir_in
parameter_list|(
name|bigend
parameter_list|,
name|ext_copy
parameter_list|,
name|intern
parameter_list|)
name|int
name|bigend
decl_stmt|;
specifier|const
name|struct
name|tir_ext
modifier|*
name|ext_copy
decl_stmt|;
name|TIR
modifier|*
name|intern
decl_stmt|;
block|{
name|struct
name|tir_ext
name|ext
index|[
literal|1
index|]
decl_stmt|;
operator|*
name|ext
operator|=
operator|*
name|ext_copy
expr_stmt|;
comment|/* Make it reasonable to do in-place.  */
comment|/* now the fun stuff...  */
if|if
condition|(
name|bigend
condition|)
block|{
name|intern
operator|->
name|fBitfield
operator|=
literal|0
operator|!=
operator|(
name|ext
operator|->
name|t_bits1
index|[
literal|0
index|]
operator|&
name|TIR_BITS1_FBITFIELD_BIG
operator|)
expr_stmt|;
name|intern
operator|->
name|continued
operator|=
literal|0
operator|!=
operator|(
name|ext
operator|->
name|t_bits1
index|[
literal|0
index|]
operator|&
name|TIR_BITS1_CONTINUED_BIG
operator|)
expr_stmt|;
name|intern
operator|->
name|bt
operator|=
operator|(
name|ext
operator|->
name|t_bits1
index|[
literal|0
index|]
operator|&
name|TIR_BITS1_BT_BIG
operator|)
operator|>>
name|TIR_BITS1_BT_SH_BIG
expr_stmt|;
name|intern
operator|->
name|tq4
operator|=
operator|(
name|ext
operator|->
name|t_tq45
index|[
literal|0
index|]
operator|&
name|TIR_BITS_TQ4_BIG
operator|)
operator|>>
name|TIR_BITS_TQ4_SH_BIG
expr_stmt|;
name|intern
operator|->
name|tq5
operator|=
operator|(
name|ext
operator|->
name|t_tq45
index|[
literal|0
index|]
operator|&
name|TIR_BITS_TQ5_BIG
operator|)
operator|>>
name|TIR_BITS_TQ5_SH_BIG
expr_stmt|;
name|intern
operator|->
name|tq0
operator|=
operator|(
name|ext
operator|->
name|t_tq01
index|[
literal|0
index|]
operator|&
name|TIR_BITS_TQ0_BIG
operator|)
operator|>>
name|TIR_BITS_TQ0_SH_BIG
expr_stmt|;
name|intern
operator|->
name|tq1
operator|=
operator|(
name|ext
operator|->
name|t_tq01
index|[
literal|0
index|]
operator|&
name|TIR_BITS_TQ1_BIG
operator|)
operator|>>
name|TIR_BITS_TQ1_SH_BIG
expr_stmt|;
name|intern
operator|->
name|tq2
operator|=
operator|(
name|ext
operator|->
name|t_tq23
index|[
literal|0
index|]
operator|&
name|TIR_BITS_TQ2_BIG
operator|)
operator|>>
name|TIR_BITS_TQ2_SH_BIG
expr_stmt|;
name|intern
operator|->
name|tq3
operator|=
operator|(
name|ext
operator|->
name|t_tq23
index|[
literal|0
index|]
operator|&
name|TIR_BITS_TQ3_BIG
operator|)
operator|>>
name|TIR_BITS_TQ3_SH_BIG
expr_stmt|;
block|}
else|else
block|{
name|intern
operator|->
name|fBitfield
operator|=
literal|0
operator|!=
operator|(
name|ext
operator|->
name|t_bits1
index|[
literal|0
index|]
operator|&
name|TIR_BITS1_FBITFIELD_LITTLE
operator|)
expr_stmt|;
name|intern
operator|->
name|continued
operator|=
literal|0
operator|!=
operator|(
name|ext
operator|->
name|t_bits1
index|[
literal|0
index|]
operator|&
name|TIR_BITS1_CONTINUED_LITTLE
operator|)
expr_stmt|;
name|intern
operator|->
name|bt
operator|=
operator|(
name|ext
operator|->
name|t_bits1
index|[
literal|0
index|]
operator|&
name|TIR_BITS1_BT_LITTLE
operator|)
operator|>>
name|TIR_BITS1_BT_SH_LITTLE
expr_stmt|;
name|intern
operator|->
name|tq4
operator|=
operator|(
name|ext
operator|->
name|t_tq45
index|[
literal|0
index|]
operator|&
name|TIR_BITS_TQ4_LITTLE
operator|)
operator|>>
name|TIR_BITS_TQ4_SH_LITTLE
expr_stmt|;
name|intern
operator|->
name|tq5
operator|=
operator|(
name|ext
operator|->
name|t_tq45
index|[
literal|0
index|]
operator|&
name|TIR_BITS_TQ5_LITTLE
operator|)
operator|>>
name|TIR_BITS_TQ5_SH_LITTLE
expr_stmt|;
name|intern
operator|->
name|tq0
operator|=
operator|(
name|ext
operator|->
name|t_tq01
index|[
literal|0
index|]
operator|&
name|TIR_BITS_TQ0_LITTLE
operator|)
operator|>>
name|TIR_BITS_TQ0_SH_LITTLE
expr_stmt|;
name|intern
operator|->
name|tq1
operator|=
operator|(
name|ext
operator|->
name|t_tq01
index|[
literal|0
index|]
operator|&
name|TIR_BITS_TQ1_LITTLE
operator|)
operator|>>
name|TIR_BITS_TQ1_SH_LITTLE
expr_stmt|;
name|intern
operator|->
name|tq2
operator|=
operator|(
name|ext
operator|->
name|t_tq23
index|[
literal|0
index|]
operator|&
name|TIR_BITS_TQ2_LITTLE
operator|)
operator|>>
name|TIR_BITS_TQ2_SH_LITTLE
expr_stmt|;
name|intern
operator|->
name|tq3
operator|=
operator|(
name|ext
operator|->
name|t_tq23
index|[
literal|0
index|]
operator|&
name|TIR_BITS_TQ3_LITTLE
operator|)
operator|>>
name|TIR_BITS_TQ3_SH_LITTLE
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TEST
if|if
condition|(
name|memcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ext
argument_list|,
operator|(
name|char
operator|*
operator|)
name|intern
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|intern
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Swap out a type information record.    BIGEND says whether AUX symbols are big-endian or little-endian; this    info comes from the file header record (fh-fBigendian).  */
end_comment

begin_function
name|void
name|_bfd_ecoff_swap_tir_out
parameter_list|(
name|bigend
parameter_list|,
name|intern_copy
parameter_list|,
name|ext
parameter_list|)
name|int
name|bigend
decl_stmt|;
specifier|const
name|TIR
modifier|*
name|intern_copy
decl_stmt|;
name|struct
name|tir_ext
modifier|*
name|ext
decl_stmt|;
block|{
name|TIR
name|intern
index|[
literal|1
index|]
decl_stmt|;
operator|*
name|intern
operator|=
operator|*
name|intern_copy
expr_stmt|;
comment|/* Make it reasonable to do in-place.  */
comment|/* now the fun stuff...  */
if|if
condition|(
name|bigend
condition|)
block|{
name|ext
operator|->
name|t_bits1
index|[
literal|0
index|]
operator|=
operator|(
operator|(
name|intern
operator|->
name|fBitfield
condition|?
name|TIR_BITS1_FBITFIELD_BIG
else|:
literal|0
operator|)
operator||
operator|(
name|intern
operator|->
name|continued
condition|?
name|TIR_BITS1_CONTINUED_BIG
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|intern
operator|->
name|bt
operator|<<
name|TIR_BITS1_BT_SH_BIG
operator|)
operator|&
name|TIR_BITS1_BT_BIG
operator|)
operator|)
expr_stmt|;
name|ext
operator|->
name|t_tq45
index|[
literal|0
index|]
operator|=
operator|(
operator|(
operator|(
name|intern
operator|->
name|tq4
operator|<<
name|TIR_BITS_TQ4_SH_BIG
operator|)
operator|&
name|TIR_BITS_TQ4_BIG
operator|)
operator||
operator|(
operator|(
name|intern
operator|->
name|tq5
operator|<<
name|TIR_BITS_TQ5_SH_BIG
operator|)
operator|&
name|TIR_BITS_TQ5_BIG
operator|)
operator|)
expr_stmt|;
name|ext
operator|->
name|t_tq01
index|[
literal|0
index|]
operator|=
operator|(
operator|(
operator|(
name|intern
operator|->
name|tq0
operator|<<
name|TIR_BITS_TQ0_SH_BIG
operator|)
operator|&
name|TIR_BITS_TQ0_BIG
operator|)
operator||
operator|(
operator|(
name|intern
operator|->
name|tq1
operator|<<
name|TIR_BITS_TQ1_SH_BIG
operator|)
operator|&
name|TIR_BITS_TQ1_BIG
operator|)
operator|)
expr_stmt|;
name|ext
operator|->
name|t_tq23
index|[
literal|0
index|]
operator|=
operator|(
operator|(
operator|(
name|intern
operator|->
name|tq2
operator|<<
name|TIR_BITS_TQ2_SH_BIG
operator|)
operator|&
name|TIR_BITS_TQ2_BIG
operator|)
operator||
operator|(
operator|(
name|intern
operator|->
name|tq3
operator|<<
name|TIR_BITS_TQ3_SH_BIG
operator|)
operator|&
name|TIR_BITS_TQ3_BIG
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|ext
operator|->
name|t_bits1
index|[
literal|0
index|]
operator|=
operator|(
operator|(
name|intern
operator|->
name|fBitfield
condition|?
name|TIR_BITS1_FBITFIELD_LITTLE
else|:
literal|0
operator|)
operator||
operator|(
name|intern
operator|->
name|continued
condition|?
name|TIR_BITS1_CONTINUED_LITTLE
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|intern
operator|->
name|bt
operator|<<
name|TIR_BITS1_BT_SH_LITTLE
operator|)
operator|&
name|TIR_BITS1_BT_LITTLE
operator|)
operator|)
expr_stmt|;
name|ext
operator|->
name|t_tq45
index|[
literal|0
index|]
operator|=
operator|(
operator|(
operator|(
name|intern
operator|->
name|tq4
operator|<<
name|TIR_BITS_TQ4_SH_LITTLE
operator|)
operator|&
name|TIR_BITS_TQ4_LITTLE
operator|)
operator||
operator|(
operator|(
name|intern
operator|->
name|tq5
operator|<<
name|TIR_BITS_TQ5_SH_LITTLE
operator|)
operator|&
name|TIR_BITS_TQ5_LITTLE
operator|)
operator|)
expr_stmt|;
name|ext
operator|->
name|t_tq01
index|[
literal|0
index|]
operator|=
operator|(
operator|(
operator|(
name|intern
operator|->
name|tq0
operator|<<
name|TIR_BITS_TQ0_SH_LITTLE
operator|)
operator|&
name|TIR_BITS_TQ0_LITTLE
operator|)
operator||
operator|(
operator|(
name|intern
operator|->
name|tq1
operator|<<
name|TIR_BITS_TQ1_SH_LITTLE
operator|)
operator|&
name|TIR_BITS_TQ1_LITTLE
operator|)
operator|)
expr_stmt|;
name|ext
operator|->
name|t_tq23
index|[
literal|0
index|]
operator|=
operator|(
operator|(
operator|(
name|intern
operator|->
name|tq2
operator|<<
name|TIR_BITS_TQ2_SH_LITTLE
operator|)
operator|&
name|TIR_BITS_TQ2_LITTLE
operator|)
operator||
operator|(
operator|(
name|intern
operator|->
name|tq3
operator|<<
name|TIR_BITS_TQ3_SH_LITTLE
operator|)
operator|&
name|TIR_BITS_TQ3_LITTLE
operator|)
operator|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TEST
if|if
condition|(
name|memcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ext
argument_list|,
operator|(
name|char
operator|*
operator|)
name|intern
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|intern
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Swap in a relative symbol record.  BIGEND says whether it is in    big-endian or little-endian format.*/
end_comment

begin_function
name|void
name|_bfd_ecoff_swap_rndx_in
parameter_list|(
name|bigend
parameter_list|,
name|ext_copy
parameter_list|,
name|intern
parameter_list|)
name|int
name|bigend
decl_stmt|;
specifier|const
name|struct
name|rndx_ext
modifier|*
name|ext_copy
decl_stmt|;
name|RNDXR
modifier|*
name|intern
decl_stmt|;
block|{
name|struct
name|rndx_ext
name|ext
index|[
literal|1
index|]
decl_stmt|;
operator|*
name|ext
operator|=
operator|*
name|ext_copy
expr_stmt|;
comment|/* Make it reasonable to do in-place.  */
comment|/* now the fun stuff...  */
if|if
condition|(
name|bigend
condition|)
block|{
name|intern
operator|->
name|rfd
operator|=
operator|(
name|ext
operator|->
name|r_bits
index|[
literal|0
index|]
operator|<<
name|RNDX_BITS0_RFD_SH_LEFT_BIG
operator|)
operator||
operator|(
operator|(
name|ext
operator|->
name|r_bits
index|[
literal|1
index|]
operator|&
name|RNDX_BITS1_RFD_BIG
operator|)
operator|>>
name|RNDX_BITS1_RFD_SH_BIG
operator|)
expr_stmt|;
name|intern
operator|->
name|index
operator|=
operator|(
operator|(
name|ext
operator|->
name|r_bits
index|[
literal|1
index|]
operator|&
name|RNDX_BITS1_INDEX_BIG
operator|)
operator|<<
name|RNDX_BITS1_INDEX_SH_LEFT_BIG
operator|)
operator||
operator|(
name|ext
operator|->
name|r_bits
index|[
literal|2
index|]
operator|<<
name|RNDX_BITS2_INDEX_SH_LEFT_BIG
operator|)
operator||
operator|(
name|ext
operator|->
name|r_bits
index|[
literal|3
index|]
operator|<<
name|RNDX_BITS3_INDEX_SH_LEFT_BIG
operator|)
expr_stmt|;
block|}
else|else
block|{
name|intern
operator|->
name|rfd
operator|=
operator|(
name|ext
operator|->
name|r_bits
index|[
literal|0
index|]
operator|<<
name|RNDX_BITS0_RFD_SH_LEFT_LITTLE
operator|)
operator||
operator|(
operator|(
name|ext
operator|->
name|r_bits
index|[
literal|1
index|]
operator|&
name|RNDX_BITS1_RFD_LITTLE
operator|)
operator|<<
name|RNDX_BITS1_RFD_SH_LEFT_LITTLE
operator|)
expr_stmt|;
name|intern
operator|->
name|index
operator|=
operator|(
operator|(
name|ext
operator|->
name|r_bits
index|[
literal|1
index|]
operator|&
name|RNDX_BITS1_INDEX_LITTLE
operator|)
operator|>>
name|RNDX_BITS1_INDEX_SH_LITTLE
operator|)
operator||
operator|(
name|ext
operator|->
name|r_bits
index|[
literal|2
index|]
operator|<<
name|RNDX_BITS2_INDEX_SH_LEFT_LITTLE
operator|)
operator||
operator|(
operator|(
name|unsigned
name|int
operator|)
name|ext
operator|->
name|r_bits
index|[
literal|3
index|]
operator|<<
name|RNDX_BITS3_INDEX_SH_LEFT_LITTLE
operator|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TEST
if|if
condition|(
name|memcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ext
argument_list|,
operator|(
name|char
operator|*
operator|)
name|intern
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|intern
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Swap out a relative symbol record.  BIGEND says whether it is in    big-endian or little-endian format.*/
end_comment

begin_function
name|void
name|_bfd_ecoff_swap_rndx_out
parameter_list|(
name|bigend
parameter_list|,
name|intern_copy
parameter_list|,
name|ext
parameter_list|)
name|int
name|bigend
decl_stmt|;
specifier|const
name|RNDXR
modifier|*
name|intern_copy
decl_stmt|;
name|struct
name|rndx_ext
modifier|*
name|ext
decl_stmt|;
block|{
name|RNDXR
name|intern
index|[
literal|1
index|]
decl_stmt|;
operator|*
name|intern
operator|=
operator|*
name|intern_copy
expr_stmt|;
comment|/* Make it reasonable to do in-place.  */
comment|/* now the fun stuff...  */
if|if
condition|(
name|bigend
condition|)
block|{
name|ext
operator|->
name|r_bits
index|[
literal|0
index|]
operator|=
name|intern
operator|->
name|rfd
operator|>>
name|RNDX_BITS0_RFD_SH_LEFT_BIG
expr_stmt|;
name|ext
operator|->
name|r_bits
index|[
literal|1
index|]
operator|=
operator|(
operator|(
operator|(
name|intern
operator|->
name|rfd
operator|<<
name|RNDX_BITS1_RFD_SH_BIG
operator|)
operator|&
name|RNDX_BITS1_RFD_BIG
operator|)
operator||
operator|(
operator|(
name|intern
operator|->
name|index
operator|>>
name|RNDX_BITS1_INDEX_SH_LEFT_BIG
operator|)
operator|&
name|RNDX_BITS1_INDEX_BIG
operator|)
operator|)
expr_stmt|;
name|ext
operator|->
name|r_bits
index|[
literal|2
index|]
operator|=
name|intern
operator|->
name|index
operator|>>
name|RNDX_BITS2_INDEX_SH_LEFT_BIG
expr_stmt|;
name|ext
operator|->
name|r_bits
index|[
literal|3
index|]
operator|=
name|intern
operator|->
name|index
operator|>>
name|RNDX_BITS3_INDEX_SH_LEFT_BIG
expr_stmt|;
block|}
else|else
block|{
name|ext
operator|->
name|r_bits
index|[
literal|0
index|]
operator|=
name|intern
operator|->
name|rfd
operator|>>
name|RNDX_BITS0_RFD_SH_LEFT_LITTLE
expr_stmt|;
name|ext
operator|->
name|r_bits
index|[
literal|1
index|]
operator|=
operator|(
operator|(
operator|(
name|intern
operator|->
name|rfd
operator|>>
name|RNDX_BITS1_RFD_SH_LEFT_LITTLE
operator|)
operator|&
name|RNDX_BITS1_RFD_LITTLE
operator|)
operator||
operator|(
operator|(
name|intern
operator|->
name|index
operator|<<
name|RNDX_BITS1_INDEX_SH_LITTLE
operator|)
operator|&
name|RNDX_BITS1_INDEX_LITTLE
operator|)
operator|)
expr_stmt|;
name|ext
operator|->
name|r_bits
index|[
literal|2
index|]
operator|=
name|intern
operator|->
name|index
operator|>>
name|RNDX_BITS2_INDEX_SH_LEFT_LITTLE
expr_stmt|;
name|ext
operator|->
name|r_bits
index|[
literal|3
index|]
operator|=
name|intern
operator|->
name|index
operator|>>
name|RNDX_BITS3_INDEX_SH_LEFT_LITTLE
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TEST
if|if
condition|(
name|memcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ext
argument_list|,
operator|(
name|char
operator|*
operator|)
name|intern
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|intern
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The minimum amount of data to allocate.  */
end_comment

begin_define
define|#
directive|define
name|ALLOC_SIZE
value|(4064)
end_define

begin_comment
comment|/* Add bytes to a buffer.  Return success.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ecoff_add_bytes
parameter_list|(
name|buf
parameter_list|,
name|bufend
parameter_list|,
name|need
parameter_list|)
name|char
modifier|*
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
modifier|*
name|bufend
decl_stmt|;
name|size_t
name|need
decl_stmt|;
block|{
name|size_t
name|have
decl_stmt|;
name|size_t
name|want
decl_stmt|;
name|char
modifier|*
name|newbuf
decl_stmt|;
name|have
operator|=
operator|*
name|bufend
operator|-
operator|*
name|buf
expr_stmt|;
if|if
condition|(
name|have
operator|>
name|need
condition|)
name|want
operator|=
name|ALLOC_SIZE
expr_stmt|;
else|else
block|{
name|want
operator|=
name|need
operator|-
name|have
expr_stmt|;
if|if
condition|(
name|want
operator|<
name|ALLOC_SIZE
condition|)
name|want
operator|=
name|ALLOC_SIZE
expr_stmt|;
block|}
name|newbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_realloc
argument_list|(
operator|*
name|buf
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|have
operator|+
name|want
argument_list|)
expr_stmt|;
if|if
condition|(
name|newbuf
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
operator|*
name|buf
operator|=
name|newbuf
expr_stmt|;
operator|*
name|bufend
operator|=
operator|*
name|buf
operator|+
name|have
operator|+
name|want
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* We keep a hash table which maps strings to numbers.  We use it to    map FDR names to indices in the output file, and to map local    strings when combining stabs debugging information.  */
end_comment

begin_struct
struct|struct
name|string_hash_entry
block|{
name|struct
name|bfd_hash_entry
name|root
decl_stmt|;
comment|/* FDR index or string table offset.  */
name|long
name|val
decl_stmt|;
comment|/* Next entry in string table.  */
name|struct
name|string_hash_entry
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|string_hash_table
block|{
name|struct
name|bfd_hash_table
name|table
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Routine to create an entry in a string hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|string_hash_newfunc
parameter_list|(
name|entry
parameter_list|,
name|table
parameter_list|,
name|string
parameter_list|)
name|struct
name|bfd_hash_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|bfd_hash_table
modifier|*
name|table
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|struct
name|string_hash_entry
modifier|*
name|ret
init|=
operator|(
expr|struct
name|string_hash_entry
operator|*
operator|)
name|entry
decl_stmt|;
comment|/* Allocate the structure if it has not already been allocated by a      subclass.  */
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|string_hash_entry
operator|*
operator|)
name|NULL
condition|)
name|ret
operator|=
operator|(
operator|(
expr|struct
name|string_hash_entry
operator|*
operator|)
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|string_hash_entry
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|string_hash_entry
operator|*
operator|)
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* Call the allocation method of the superclass.  */
name|ret
operator|=
operator|(
operator|(
expr|struct
name|string_hash_entry
operator|*
operator|)
name|bfd_hash_newfunc
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
comment|/* Initialize the local fields.  */
name|ret
operator|->
name|val
operator|=
operator|-
literal|1
expr_stmt|;
name|ret
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Look up an entry in an string hash table.  */
end_comment

begin_define
define|#
directive|define
name|string_hash_lookup
parameter_list|(
name|t
parameter_list|,
name|string
parameter_list|,
name|create
parameter_list|,
name|copy
parameter_list|)
define|\
value|((struct string_hash_entry *) \    bfd_hash_lookup (&(t)->table, (string), (create), (copy)))
end_define

begin_comment
comment|/* We can't afford to read in all the debugging information when we do    a link.  Instead, we build a list of these structures to show how    different parts of the input file map to the output file.  */
end_comment

begin_struct
struct|struct
name|shuffle
block|{
comment|/* The next entry in this linked list.  */
name|struct
name|shuffle
modifier|*
name|next
decl_stmt|;
comment|/* The length of the information.  */
name|unsigned
name|long
name|size
decl_stmt|;
comment|/* Whether this information comes from a file or not.  */
name|bfd_boolean
name|filep
decl_stmt|;
union|union
block|{
struct|struct
block|{
comment|/* The BFD the data comes from.  */
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
comment|/* The offset within input_bfd.  */
name|file_ptr
name|offset
decl_stmt|;
block|}
name|file
struct|;
comment|/* The data to be written out.  */
name|PTR
name|memory
decl_stmt|;
block|}
name|u
union|;
block|}
struct|;
end_struct

begin_comment
comment|/* This structure holds information across calls to    bfd_ecoff_debug_accumulate.  */
end_comment

begin_struct
struct|struct
name|accumulate
block|{
comment|/* The FDR hash table.  */
name|struct
name|string_hash_table
name|fdr_hash
decl_stmt|;
comment|/* The strings hash table.  */
name|struct
name|string_hash_table
name|str_hash
decl_stmt|;
comment|/* Linked lists describing how to shuffle the input debug      information into the output file.  We keep a pointer to both the      head and the tail.  */
name|struct
name|shuffle
modifier|*
name|line
decl_stmt|;
name|struct
name|shuffle
modifier|*
name|line_end
decl_stmt|;
name|struct
name|shuffle
modifier|*
name|pdr
decl_stmt|;
name|struct
name|shuffle
modifier|*
name|pdr_end
decl_stmt|;
name|struct
name|shuffle
modifier|*
name|sym
decl_stmt|;
name|struct
name|shuffle
modifier|*
name|sym_end
decl_stmt|;
name|struct
name|shuffle
modifier|*
name|opt
decl_stmt|;
name|struct
name|shuffle
modifier|*
name|opt_end
decl_stmt|;
name|struct
name|shuffle
modifier|*
name|aux
decl_stmt|;
name|struct
name|shuffle
modifier|*
name|aux_end
decl_stmt|;
name|struct
name|shuffle
modifier|*
name|ss
decl_stmt|;
name|struct
name|shuffle
modifier|*
name|ss_end
decl_stmt|;
name|struct
name|string_hash_entry
modifier|*
name|ss_hash
decl_stmt|;
name|struct
name|string_hash_entry
modifier|*
name|ss_hash_end
decl_stmt|;
name|struct
name|shuffle
modifier|*
name|fdr
decl_stmt|;
name|struct
name|shuffle
modifier|*
name|fdr_end
decl_stmt|;
name|struct
name|shuffle
modifier|*
name|rfd
decl_stmt|;
name|struct
name|shuffle
modifier|*
name|rfd_end
decl_stmt|;
comment|/* The size of the largest file shuffle.  */
name|unsigned
name|long
name|largest_file_shuffle
decl_stmt|;
comment|/* An objalloc for debugging information.  */
name|struct
name|objalloc
modifier|*
name|memory
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Add a file entry to a shuffle list.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_boolean
name|add_file_shuffle
name|PARAMS
argument_list|(
operator|(
expr|struct
name|accumulate
operator|*
operator|,
expr|struct
name|shuffle
operator|*
operator|*
operator|,
expr|struct
name|shuffle
operator|*
operator|*
operator|,
name|bfd
operator|*
operator|,
name|file_ptr
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|bfd_boolean
name|add_file_shuffle
parameter_list|(
name|ainfo
parameter_list|,
name|head
parameter_list|,
name|tail
parameter_list|,
name|input_bfd
parameter_list|,
name|offset
parameter_list|,
name|size
parameter_list|)
name|struct
name|accumulate
modifier|*
name|ainfo
decl_stmt|;
name|struct
name|shuffle
modifier|*
modifier|*
name|head
decl_stmt|;
name|struct
name|shuffle
modifier|*
modifier|*
name|tail
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|file_ptr
name|offset
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|;
block|{
name|struct
name|shuffle
modifier|*
name|n
decl_stmt|;
if|if
condition|(
operator|*
name|tail
operator|!=
operator|(
expr|struct
name|shuffle
operator|*
operator|)
name|NULL
operator|&&
operator|(
operator|*
name|tail
operator|)
operator|->
name|filep
operator|&&
operator|(
operator|*
name|tail
operator|)
operator|->
name|u
operator|.
name|file
operator|.
name|input_bfd
operator|==
name|input_bfd
operator|&&
operator|(
operator|*
name|tail
operator|)
operator|->
name|u
operator|.
name|file
operator|.
name|offset
operator|+
operator|(
operator|*
name|tail
operator|)
operator|->
name|size
operator|==
operator|(
name|unsigned
name|long
operator|)
name|offset
condition|)
block|{
comment|/* Just merge this entry onto the existing one.  */
operator|(
operator|*
name|tail
operator|)
operator|->
name|size
operator|+=
name|size
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|tail
operator|)
operator|->
name|size
operator|>
name|ainfo
operator|->
name|largest_file_shuffle
condition|)
name|ainfo
operator|->
name|largest_file_shuffle
operator|=
operator|(
operator|*
name|tail
operator|)
operator|->
name|size
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|n
operator|=
operator|(
expr|struct
name|shuffle
operator|*
operator|)
name|objalloc_alloc
argument_list|(
name|ainfo
operator|->
name|memory
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|shuffle
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|n
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|n
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|n
operator|->
name|filep
operator|=
name|TRUE
expr_stmt|;
name|n
operator|->
name|u
operator|.
name|file
operator|.
name|input_bfd
operator|=
name|input_bfd
expr_stmt|;
name|n
operator|->
name|u
operator|.
name|file
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
if|if
condition|(
operator|*
name|head
operator|==
operator|(
expr|struct
name|shuffle
operator|*
operator|)
name|NULL
condition|)
operator|*
name|head
operator|=
name|n
expr_stmt|;
if|if
condition|(
operator|*
name|tail
operator|!=
operator|(
expr|struct
name|shuffle
operator|*
operator|)
name|NULL
condition|)
operator|(
operator|*
name|tail
operator|)
operator|->
name|next
operator|=
name|n
expr_stmt|;
operator|*
name|tail
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|ainfo
operator|->
name|largest_file_shuffle
condition|)
name|ainfo
operator|->
name|largest_file_shuffle
operator|=
name|size
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Add a memory entry to a shuffle list.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_boolean
name|add_memory_shuffle
name|PARAMS
argument_list|(
operator|(
expr|struct
name|accumulate
operator|*
operator|,
expr|struct
name|shuffle
operator|*
operator|*
name|head
operator|,
expr|struct
name|shuffle
operator|*
operator|*
name|tail
operator|,
name|bfd_byte
operator|*
name|data
operator|,
name|unsigned
name|long
name|size
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|bfd_boolean
name|add_memory_shuffle
parameter_list|(
name|ainfo
parameter_list|,
name|head
parameter_list|,
name|tail
parameter_list|,
name|data
parameter_list|,
name|size
parameter_list|)
name|struct
name|accumulate
modifier|*
name|ainfo
decl_stmt|;
name|struct
name|shuffle
modifier|*
modifier|*
name|head
decl_stmt|;
name|struct
name|shuffle
modifier|*
modifier|*
name|tail
decl_stmt|;
name|bfd_byte
modifier|*
name|data
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|;
block|{
name|struct
name|shuffle
modifier|*
name|n
decl_stmt|;
name|n
operator|=
operator|(
expr|struct
name|shuffle
operator|*
operator|)
name|objalloc_alloc
argument_list|(
name|ainfo
operator|->
name|memory
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|shuffle
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|n
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|n
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|n
operator|->
name|filep
operator|=
name|FALSE
expr_stmt|;
name|n
operator|->
name|u
operator|.
name|memory
operator|=
operator|(
name|PTR
operator|)
name|data
expr_stmt|;
if|if
condition|(
operator|*
name|head
operator|==
operator|(
expr|struct
name|shuffle
operator|*
operator|)
name|NULL
condition|)
operator|*
name|head
operator|=
name|n
expr_stmt|;
if|if
condition|(
operator|*
name|tail
operator|!=
operator|(
expr|struct
name|shuffle
operator|*
operator|)
name|NULL
condition|)
operator|(
operator|*
name|tail
operator|)
operator|->
name|next
operator|=
name|n
expr_stmt|;
operator|*
name|tail
operator|=
name|n
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Initialize the FDR hash table.  This returns a handle which is then    passed in to bfd_ecoff_debug_accumulate, et. al.  */
end_comment

begin_function
name|PTR
name|bfd_ecoff_debug_init
parameter_list|(
name|output_bfd
parameter_list|,
name|output_debug
parameter_list|,
name|output_swap
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|ecoff_debug_info
modifier|*
name|output_debug
decl_stmt|;
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|output_swap
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|struct
name|accumulate
modifier|*
name|ainfo
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|accumulate
argument_list|)
decl_stmt|;
name|ainfo
operator|=
operator|(
expr|struct
name|accumulate
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ainfo
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|bfd_hash_table_init_n
argument_list|(
operator|&
name|ainfo
operator|->
name|fdr_hash
operator|.
name|table
argument_list|,
name|string_hash_newfunc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|string_hash_entry
argument_list|)
argument_list|,
literal|1021
argument_list|)
condition|)
return|return
name|NULL
return|;
name|ainfo
operator|->
name|line
operator|=
name|NULL
expr_stmt|;
name|ainfo
operator|->
name|line_end
operator|=
name|NULL
expr_stmt|;
name|ainfo
operator|->
name|pdr
operator|=
name|NULL
expr_stmt|;
name|ainfo
operator|->
name|pdr_end
operator|=
name|NULL
expr_stmt|;
name|ainfo
operator|->
name|sym
operator|=
name|NULL
expr_stmt|;
name|ainfo
operator|->
name|sym_end
operator|=
name|NULL
expr_stmt|;
name|ainfo
operator|->
name|opt
operator|=
name|NULL
expr_stmt|;
name|ainfo
operator|->
name|opt_end
operator|=
name|NULL
expr_stmt|;
name|ainfo
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
name|ainfo
operator|->
name|aux_end
operator|=
name|NULL
expr_stmt|;
name|ainfo
operator|->
name|ss
operator|=
name|NULL
expr_stmt|;
name|ainfo
operator|->
name|ss_end
operator|=
name|NULL
expr_stmt|;
name|ainfo
operator|->
name|ss_hash
operator|=
name|NULL
expr_stmt|;
name|ainfo
operator|->
name|ss_hash_end
operator|=
name|NULL
expr_stmt|;
name|ainfo
operator|->
name|fdr
operator|=
name|NULL
expr_stmt|;
name|ainfo
operator|->
name|fdr_end
operator|=
name|NULL
expr_stmt|;
name|ainfo
operator|->
name|rfd
operator|=
name|NULL
expr_stmt|;
name|ainfo
operator|->
name|rfd_end
operator|=
name|NULL
expr_stmt|;
name|ainfo
operator|->
name|largest_file_shuffle
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|relocatable
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_hash_table_init
argument_list|(
operator|&
name|ainfo
operator|->
name|str_hash
operator|.
name|table
argument_list|,
name|string_hash_newfunc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|string_hash_entry
argument_list|)
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* The first entry in the string table is the empty string.  */
name|output_debug
operator|->
name|symbolic_header
operator|.
name|issMax
operator|=
literal|1
expr_stmt|;
block|}
name|ainfo
operator|->
name|memory
operator|=
name|objalloc_create
argument_list|()
expr_stmt|;
if|if
condition|(
name|ainfo
operator|->
name|memory
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
operator|(
name|PTR
operator|)
name|ainfo
return|;
block|}
end_function

begin_comment
comment|/* Free the accumulated debugging information.  */
end_comment

begin_function
name|void
name|bfd_ecoff_debug_free
parameter_list|(
name|handle
parameter_list|,
name|output_bfd
parameter_list|,
name|output_debug
parameter_list|,
name|output_swap
parameter_list|,
name|info
parameter_list|)
name|PTR
name|handle
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|ecoff_debug_info
modifier|*
name|output_debug
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|output_swap
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|struct
name|accumulate
modifier|*
name|ainfo
init|=
operator|(
expr|struct
name|accumulate
operator|*
operator|)
name|handle
decl_stmt|;
name|bfd_hash_table_free
argument_list|(
operator|&
name|ainfo
operator|->
name|fdr_hash
operator|.
name|table
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|relocatable
condition|)
name|bfd_hash_table_free
argument_list|(
operator|&
name|ainfo
operator|->
name|str_hash
operator|.
name|table
argument_list|)
expr_stmt|;
name|objalloc_free
argument_list|(
name|ainfo
operator|->
name|memory
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ainfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Accumulate the debugging information from INPUT_BFD into    OUTPUT_BFD.  The INPUT_DEBUG argument points to some ECOFF    debugging information which we want to link into the information    pointed to by the OUTPUT_DEBUG argument.  OUTPUT_SWAP and    INPUT_SWAP point to the swapping information needed.  INFO is the    linker information structure.  HANDLE is returned by    bfd_ecoff_debug_init.  */
end_comment

begin_function
name|bfd_boolean
name|bfd_ecoff_debug_accumulate
parameter_list|(
name|handle
parameter_list|,
name|output_bfd
parameter_list|,
name|output_debug
parameter_list|,
name|output_swap
parameter_list|,
name|input_bfd
parameter_list|,
name|input_debug
parameter_list|,
name|input_swap
parameter_list|,
name|info
parameter_list|)
name|PTR
name|handle
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|ecoff_debug_info
modifier|*
name|output_debug
decl_stmt|;
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|output_swap
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|struct
name|ecoff_debug_info
modifier|*
name|input_debug
decl_stmt|;
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|input_swap
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|struct
name|accumulate
modifier|*
name|ainfo
init|=
operator|(
expr|struct
name|accumulate
operator|*
operator|)
name|handle
decl_stmt|;
name|void
argument_list|(
argument|* const swap_sym_in
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|SYMR
operator|*
operator|)
argument_list|)
operator|=
name|input_swap
operator|->
name|swap_sym_in
expr_stmt|;
name|void
argument_list|(
argument|* const swap_rfd_in
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|RFDT
operator|*
operator|)
argument_list|)
operator|=
name|input_swap
operator|->
name|swap_rfd_in
expr_stmt|;
name|void
argument_list|(
argument|* const swap_sym_out
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|SYMR
operator|*
operator|,
name|PTR
operator|)
argument_list|)
operator|=
name|output_swap
operator|->
name|swap_sym_out
expr_stmt|;
name|void
argument_list|(
argument|* const swap_fdr_out
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|FDR
operator|*
operator|,
name|PTR
operator|)
argument_list|)
operator|=
name|output_swap
operator|->
name|swap_fdr_out
expr_stmt|;
name|void
argument_list|(
argument|* const swap_rfd_out
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|RFDT
operator|*
operator|,
name|PTR
operator|)
argument_list|)
operator|=
name|output_swap
operator|->
name|swap_rfd_out
expr_stmt|;
name|bfd_size_type
name|external_pdr_size
init|=
name|output_swap
operator|->
name|external_pdr_size
decl_stmt|;
name|bfd_size_type
name|external_sym_size
init|=
name|output_swap
operator|->
name|external_sym_size
decl_stmt|;
name|bfd_size_type
name|external_opt_size
init|=
name|output_swap
operator|->
name|external_opt_size
decl_stmt|;
name|bfd_size_type
name|external_fdr_size
init|=
name|output_swap
operator|->
name|external_fdr_size
decl_stmt|;
name|bfd_size_type
name|external_rfd_size
init|=
name|output_swap
operator|->
name|external_rfd_size
decl_stmt|;
name|HDRR
modifier|*
specifier|const
name|output_symhdr
init|=
operator|&
name|output_debug
operator|->
name|symbolic_header
decl_stmt|;
name|HDRR
modifier|*
specifier|const
name|input_symhdr
init|=
operator|&
name|input_debug
operator|->
name|symbolic_header
decl_stmt|;
name|bfd_vma
name|section_adjust
index|[
name|scMax
index|]
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_byte
modifier|*
name|fdr_start
decl_stmt|;
name|bfd_byte
modifier|*
name|fdr_ptr
decl_stmt|;
name|bfd_byte
modifier|*
name|fdr_end
decl_stmt|;
name|bfd_size_type
name|fdr_add
decl_stmt|;
name|unsigned
name|int
name|copied
decl_stmt|;
name|RFDT
name|i
decl_stmt|;
name|unsigned
name|long
name|sz
decl_stmt|;
name|bfd_byte
modifier|*
name|rfd_out
decl_stmt|;
name|bfd_byte
modifier|*
name|rfd_in
decl_stmt|;
name|bfd_byte
modifier|*
name|rfd_end
decl_stmt|;
name|long
name|newrfdbase
init|=
literal|0
decl_stmt|;
name|long
name|oldrfdbase
init|=
literal|0
decl_stmt|;
name|bfd_byte
modifier|*
name|fdr_out
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
comment|/* Use section_adjust to hold the value to add to a symbol in a      particular section.  */
name|memset
argument_list|(
operator|(
name|PTR
operator|)
name|section_adjust
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|section_adjust
argument_list|)
expr_stmt|;
define|#
directive|define
name|SET
parameter_list|(
name|name
parameter_list|,
name|indx
parameter_list|)
define|\
value|sec = bfd_get_section_by_name (input_bfd, name); \   if (sec != NULL) \     section_adjust[indx] = (sec->output_section->vma \ 			    + sec->output_offset \ 			    - sec->vma);
name|SET
argument_list|(
literal|".text"
argument_list|,
name|scText
argument_list|)
expr_stmt|;
name|SET
argument_list|(
literal|".data"
argument_list|,
name|scData
argument_list|)
expr_stmt|;
name|SET
argument_list|(
literal|".bss"
argument_list|,
name|scBss
argument_list|)
expr_stmt|;
name|SET
argument_list|(
literal|".sdata"
argument_list|,
name|scSData
argument_list|)
expr_stmt|;
name|SET
argument_list|(
literal|".sbss"
argument_list|,
name|scSBss
argument_list|)
expr_stmt|;
comment|/* scRdata section may be either .rdata or .rodata.  */
name|SET
argument_list|(
literal|".rdata"
argument_list|,
name|scRData
argument_list|)
expr_stmt|;
name|SET
argument_list|(
literal|".rodata"
argument_list|,
name|scRData
argument_list|)
expr_stmt|;
name|SET
argument_list|(
literal|".init"
argument_list|,
name|scInit
argument_list|)
expr_stmt|;
name|SET
argument_list|(
literal|".fini"
argument_list|,
name|scFini
argument_list|)
expr_stmt|;
name|SET
argument_list|(
literal|".rconst"
argument_list|,
name|scRConst
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|SET
comment|/* Find all the debugging information based on the FDR's.  We need      to handle them whether they are swapped or not.  */
if|if
condition|(
name|input_debug
operator|->
name|fdr
operator|!=
operator|(
name|FDR
operator|*
operator|)
name|NULL
condition|)
block|{
name|fdr_start
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|input_debug
operator|->
name|fdr
expr_stmt|;
name|fdr_add
operator|=
sizeof|sizeof
argument_list|(
name|FDR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fdr_start
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|input_debug
operator|->
name|external_fdr
expr_stmt|;
name|fdr_add
operator|=
name|input_swap
operator|->
name|external_fdr_size
expr_stmt|;
block|}
name|fdr_end
operator|=
name|fdr_start
operator|+
name|input_symhdr
operator|->
name|ifdMax
operator|*
name|fdr_add
expr_stmt|;
name|amt
operator|=
name|input_symhdr
operator|->
name|ifdMax
expr_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
name|RFDT
argument_list|)
expr_stmt|;
name|input_debug
operator|->
name|ifdmap
operator|=
operator|(
name|RFDT
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|input_bfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
name|sz
operator|=
operator|(
name|input_symhdr
operator|->
name|crfd
operator|+
name|input_symhdr
operator|->
name|ifdMax
operator|)
operator|*
name|external_rfd_size
expr_stmt|;
name|rfd_out
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|objalloc_alloc
argument_list|(
name|ainfo
operator|->
name|memory
argument_list|,
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|input_debug
operator|->
name|ifdmap
operator|||
operator|!
name|rfd_out
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|add_memory_shuffle
argument_list|(
name|ainfo
argument_list|,
operator|&
name|ainfo
operator|->
name|rfd
argument_list|,
operator|&
name|ainfo
operator|->
name|rfd_end
argument_list|,
name|rfd_out
argument_list|,
name|sz
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|copied
operator|=
literal|0
expr_stmt|;
comment|/* Look through the FDR's to see which ones we are going to include      in the final output.  We do not want duplicate FDR information      for header files, because ECOFF debugging is often very large.      When we find an FDR with no line information which can be merged,      we look it up in a hash table to ensure that we only include it      once.  We keep a table mapping FDR numbers to the final number      they get with the BFD, so that we can refer to it when we write      out the external symbols.  */
for|for
control|(
name|fdr_ptr
operator|=
name|fdr_start
operator|,
name|i
operator|=
literal|0
init|;
name|fdr_ptr
operator|<
name|fdr_end
condition|;
name|fdr_ptr
operator|+=
name|fdr_add
operator|,
name|i
operator|++
operator|,
name|rfd_out
operator|+=
name|external_rfd_size
control|)
block|{
name|FDR
name|fdr
decl_stmt|;
if|if
condition|(
name|input_debug
operator|->
name|fdr
operator|!=
operator|(
name|FDR
operator|*
operator|)
name|NULL
condition|)
name|fdr
operator|=
operator|*
operator|(
name|FDR
operator|*
operator|)
name|fdr_ptr
expr_stmt|;
else|else
call|(
modifier|*
name|input_swap
operator|->
name|swap_fdr_in
call|)
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|PTR
operator|)
name|fdr_ptr
argument_list|,
operator|&
name|fdr
argument_list|)
expr_stmt|;
comment|/* See if this FDR can be merged with an existing one.  */
if|if
condition|(
name|fdr
operator|.
name|cbLine
operator|==
literal|0
operator|&&
name|fdr
operator|.
name|rss
operator|!=
operator|-
literal|1
operator|&&
name|fdr
operator|.
name|fMerge
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|lookup
decl_stmt|;
name|struct
name|string_hash_entry
modifier|*
name|fh
decl_stmt|;
comment|/* We look up a string formed from the file name and the 	     number of symbols and aux entries.  Sometimes an include 	     file will conditionally define a typedef or something 	     based on the order of include files.  Using the number of 	     symbols and aux entries as a hash reduces the chance that 	     we will merge symbol information that should not be 	     merged.  */
name|name
operator|=
name|input_debug
operator|->
name|ss
operator|+
name|fdr
operator|.
name|issBase
operator|+
name|fdr
operator|.
name|rss
expr_stmt|;
name|lookup
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_malloc
argument_list|(
operator|(
name|bfd_size_type
operator|)
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|20
argument_list|)
expr_stmt|;
if|if
condition|(
name|lookup
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|sprintf
argument_list|(
name|lookup
argument_list|,
literal|"%s %lx %lx"
argument_list|,
name|name
argument_list|,
name|fdr
operator|.
name|csym
argument_list|,
name|fdr
operator|.
name|caux
argument_list|)
expr_stmt|;
name|fh
operator|=
name|string_hash_lookup
argument_list|(
operator|&
name|ainfo
operator|->
name|fdr_hash
argument_list|,
name|lookup
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lookup
argument_list|)
expr_stmt|;
if|if
condition|(
name|fh
operator|==
operator|(
expr|struct
name|string_hash_entry
operator|*
operator|)
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|fh
operator|->
name|val
operator|!=
operator|-
literal|1
condition|)
block|{
name|input_debug
operator|->
name|ifdmap
index|[
name|i
index|]
operator|=
name|fh
operator|->
name|val
expr_stmt|;
call|(
modifier|*
name|swap_rfd_out
call|)
argument_list|(
name|output_bfd
argument_list|,
name|input_debug
operator|->
name|ifdmap
operator|+
name|i
argument_list|,
operator|(
name|PTR
operator|)
name|rfd_out
argument_list|)
expr_stmt|;
comment|/* Don't copy this FDR.  */
continue|continue;
block|}
name|fh
operator|->
name|val
operator|=
name|output_symhdr
operator|->
name|ifdMax
operator|+
name|copied
expr_stmt|;
block|}
name|input_debug
operator|->
name|ifdmap
index|[
name|i
index|]
operator|=
name|output_symhdr
operator|->
name|ifdMax
operator|+
name|copied
expr_stmt|;
call|(
modifier|*
name|swap_rfd_out
call|)
argument_list|(
name|output_bfd
argument_list|,
name|input_debug
operator|->
name|ifdmap
operator|+
name|i
argument_list|,
operator|(
name|PTR
operator|)
name|rfd_out
argument_list|)
expr_stmt|;
operator|++
name|copied
expr_stmt|;
block|}
name|newrfdbase
operator|=
name|output_symhdr
operator|->
name|crfd
expr_stmt|;
name|output_symhdr
operator|->
name|crfd
operator|+=
name|input_symhdr
operator|->
name|ifdMax
expr_stmt|;
comment|/* Copy over any existing RFD's.  RFD's are only created by the      linker, so this will only happen for input files which are the      result of a partial link.  */
name|rfd_in
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|input_debug
operator|->
name|external_rfd
expr_stmt|;
name|rfd_end
operator|=
name|rfd_in
operator|+
name|input_symhdr
operator|->
name|crfd
operator|*
name|input_swap
operator|->
name|external_rfd_size
expr_stmt|;
for|for
control|(
init|;
name|rfd_in
operator|<
name|rfd_end
condition|;
name|rfd_in
operator|+=
name|input_swap
operator|->
name|external_rfd_size
control|)
block|{
name|RFDT
name|rfd
decl_stmt|;
call|(
modifier|*
name|swap_rfd_in
call|)
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|PTR
operator|)
name|rfd_in
argument_list|,
operator|&
name|rfd
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|rfd
operator|>=
literal|0
operator|&&
name|rfd
operator|<
name|input_symhdr
operator|->
name|ifdMax
argument_list|)
expr_stmt|;
name|rfd
operator|=
name|input_debug
operator|->
name|ifdmap
index|[
name|rfd
index|]
expr_stmt|;
call|(
modifier|*
name|swap_rfd_out
call|)
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rfd
argument_list|,
operator|(
name|PTR
operator|)
name|rfd_out
argument_list|)
expr_stmt|;
name|rfd_out
operator|+=
name|external_rfd_size
expr_stmt|;
block|}
name|oldrfdbase
operator|=
name|output_symhdr
operator|->
name|crfd
expr_stmt|;
name|output_symhdr
operator|->
name|crfd
operator|+=
name|input_symhdr
operator|->
name|crfd
expr_stmt|;
comment|/* Look through the FDR's and copy over all associated debugging      information.  */
name|sz
operator|=
name|copied
operator|*
name|external_fdr_size
expr_stmt|;
name|fdr_out
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|objalloc_alloc
argument_list|(
name|ainfo
operator|->
name|memory
argument_list|,
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fdr_out
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|add_memory_shuffle
argument_list|(
name|ainfo
argument_list|,
operator|&
name|ainfo
operator|->
name|fdr
argument_list|,
operator|&
name|ainfo
operator|->
name|fdr_end
argument_list|,
name|fdr_out
argument_list|,
name|sz
argument_list|)
condition|)
return|return
name|FALSE
return|;
for|for
control|(
name|fdr_ptr
operator|=
name|fdr_start
operator|,
name|i
operator|=
literal|0
init|;
name|fdr_ptr
operator|<
name|fdr_end
condition|;
name|fdr_ptr
operator|+=
name|fdr_add
operator|,
name|i
operator|++
control|)
block|{
name|FDR
name|fdr
decl_stmt|;
name|bfd_byte
modifier|*
name|sym_out
decl_stmt|;
name|bfd_byte
modifier|*
name|lraw_src
decl_stmt|;
name|bfd_byte
modifier|*
name|lraw_end
decl_stmt|;
name|bfd_boolean
name|fgotfilename
decl_stmt|;
if|if
condition|(
name|input_debug
operator|->
name|ifdmap
index|[
name|i
index|]
operator|<
name|output_symhdr
operator|->
name|ifdMax
condition|)
block|{
comment|/* We are not copying this FDR.  */
continue|continue;
block|}
if|if
condition|(
name|input_debug
operator|->
name|fdr
operator|!=
operator|(
name|FDR
operator|*
operator|)
name|NULL
condition|)
name|fdr
operator|=
operator|*
operator|(
name|FDR
operator|*
operator|)
name|fdr_ptr
expr_stmt|;
else|else
call|(
modifier|*
name|input_swap
operator|->
name|swap_fdr_in
call|)
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|PTR
operator|)
name|fdr_ptr
argument_list|,
operator|&
name|fdr
argument_list|)
expr_stmt|;
comment|/* FIXME: It is conceivable that this FDR points to the .init or 	 .fini section, in which case this will not do the right 	 thing.  */
name|fdr
operator|.
name|adr
operator|+=
name|section_adjust
index|[
name|scText
index|]
expr_stmt|;
comment|/* Swap in the local symbols, adjust their values, and swap them 	 out again.  */
name|fgotfilename
operator|=
name|FALSE
expr_stmt|;
name|sz
operator|=
name|fdr
operator|.
name|csym
operator|*
name|external_sym_size
expr_stmt|;
name|sym_out
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|objalloc_alloc
argument_list|(
name|ainfo
operator|->
name|memory
argument_list|,
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sym_out
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|add_memory_shuffle
argument_list|(
name|ainfo
argument_list|,
operator|&
name|ainfo
operator|->
name|sym
argument_list|,
operator|&
name|ainfo
operator|->
name|sym_end
argument_list|,
name|sym_out
argument_list|,
name|sz
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|lraw_src
operator|=
operator|(
operator|(
name|bfd_byte
operator|*
operator|)
name|input_debug
operator|->
name|external_sym
operator|+
name|fdr
operator|.
name|isymBase
operator|*
name|input_swap
operator|->
name|external_sym_size
operator|)
expr_stmt|;
name|lraw_end
operator|=
name|lraw_src
operator|+
name|fdr
operator|.
name|csym
operator|*
name|input_swap
operator|->
name|external_sym_size
expr_stmt|;
for|for
control|(
init|;
name|lraw_src
operator|<
name|lraw_end
condition|;
name|lraw_src
operator|+=
name|input_swap
operator|->
name|external_sym_size
control|)
block|{
name|SYMR
name|internal_sym
decl_stmt|;
call|(
modifier|*
name|swap_sym_in
call|)
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|PTR
operator|)
name|lraw_src
argument_list|,
operator|&
name|internal_sym
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|internal_sym
operator|.
name|sc
operator|!=
name|scCommon
operator|&&
name|internal_sym
operator|.
name|sc
operator|!=
name|scSCommon
argument_list|)
expr_stmt|;
comment|/* Adjust the symbol value if appropriate.  */
switch|switch
condition|(
name|internal_sym
operator|.
name|st
condition|)
block|{
case|case
name|stNil
case|:
if|if
condition|(
name|ECOFF_IS_STAB
argument_list|(
operator|&
name|internal_sym
argument_list|)
condition|)
break|break;
comment|/* Fall through.  */
case|case
name|stGlobal
case|:
case|case
name|stStatic
case|:
case|case
name|stLabel
case|:
case|case
name|stProc
case|:
case|case
name|stStaticProc
case|:
name|internal_sym
operator|.
name|value
operator|+=
name|section_adjust
index|[
name|internal_sym
operator|.
name|sc
index|]
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* If we are doing a final link, we hash all the strings in 	     the local symbol table together.  This reduces the amount 	     of space required by debugging information.  We don't do 	     this when performing a relocatable link because it would 	     prevent us from easily merging different FDR's.  */
if|if
condition|(
operator|!
name|info
operator|->
name|relocatable
condition|)
block|{
name|bfd_boolean
name|ffilename
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
operator|!
name|fgotfilename
operator|&&
name|internal_sym
operator|.
name|iss
operator|==
name|fdr
operator|.
name|rss
condition|)
name|ffilename
operator|=
name|TRUE
expr_stmt|;
else|else
name|ffilename
operator|=
name|FALSE
expr_stmt|;
comment|/* Hash the name into the string table.  */
name|name
operator|=
name|input_debug
operator|->
name|ss
operator|+
name|fdr
operator|.
name|issBase
operator|+
name|internal_sym
operator|.
name|iss
expr_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'\0'
condition|)
name|internal_sym
operator|.
name|iss
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|struct
name|string_hash_entry
modifier|*
name|sh
decl_stmt|;
name|sh
operator|=
name|string_hash_lookup
argument_list|(
operator|&
name|ainfo
operator|->
name|str_hash
argument_list|,
name|name
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sh
operator|==
operator|(
expr|struct
name|string_hash_entry
operator|*
operator|)
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|sh
operator|->
name|val
operator|==
operator|-
literal|1
condition|)
block|{
name|sh
operator|->
name|val
operator|=
name|output_symhdr
operator|->
name|issMax
expr_stmt|;
name|output_symhdr
operator|->
name|issMax
operator|+=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|ainfo
operator|->
name|ss_hash
operator|==
operator|(
expr|struct
name|string_hash_entry
operator|*
operator|)
name|NULL
condition|)
name|ainfo
operator|->
name|ss_hash
operator|=
name|sh
expr_stmt|;
if|if
condition|(
name|ainfo
operator|->
name|ss_hash_end
operator|!=
operator|(
expr|struct
name|string_hash_entry
operator|*
operator|)
name|NULL
condition|)
name|ainfo
operator|->
name|ss_hash_end
operator|->
name|next
operator|=
name|sh
expr_stmt|;
name|ainfo
operator|->
name|ss_hash_end
operator|=
name|sh
expr_stmt|;
block|}
name|internal_sym
operator|.
name|iss
operator|=
name|sh
operator|->
name|val
expr_stmt|;
block|}
if|if
condition|(
name|ffilename
condition|)
block|{
name|fdr
operator|.
name|rss
operator|=
name|internal_sym
operator|.
name|iss
expr_stmt|;
name|fgotfilename
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
call|(
modifier|*
name|swap_sym_out
call|)
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|internal_sym
argument_list|,
name|sym_out
argument_list|)
expr_stmt|;
name|sym_out
operator|+=
name|external_sym_size
expr_stmt|;
block|}
name|fdr
operator|.
name|isymBase
operator|=
name|output_symhdr
operator|->
name|isymMax
expr_stmt|;
name|output_symhdr
operator|->
name|isymMax
operator|+=
name|fdr
operator|.
name|csym
expr_stmt|;
comment|/* Copy the information that does not need swapping.  */
comment|/* FIXME: If we are relaxing, we need to adjust the line 	 numbers.  Frankly, forget it.  Anybody using stabs debugging 	 information will not use this line number information, and 	 stabs are adjusted correctly.  */
if|if
condition|(
name|fdr
operator|.
name|cbLine
operator|>
literal|0
condition|)
block|{
name|file_ptr
name|pos
init|=
name|input_symhdr
operator|->
name|cbLineOffset
operator|+
name|fdr
operator|.
name|cbLineOffset
decl_stmt|;
if|if
condition|(
operator|!
name|add_file_shuffle
argument_list|(
name|ainfo
argument_list|,
operator|&
name|ainfo
operator|->
name|line
argument_list|,
operator|&
name|ainfo
operator|->
name|line_end
argument_list|,
name|input_bfd
argument_list|,
name|pos
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|fdr
operator|.
name|cbLine
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|fdr
operator|.
name|ilineBase
operator|=
name|output_symhdr
operator|->
name|ilineMax
expr_stmt|;
name|fdr
operator|.
name|cbLineOffset
operator|=
name|output_symhdr
operator|->
name|cbLine
expr_stmt|;
name|output_symhdr
operator|->
name|ilineMax
operator|+=
name|fdr
operator|.
name|cline
expr_stmt|;
name|output_symhdr
operator|->
name|cbLine
operator|+=
name|fdr
operator|.
name|cbLine
expr_stmt|;
block|}
if|if
condition|(
name|fdr
operator|.
name|caux
operator|>
literal|0
condition|)
block|{
name|file_ptr
name|pos
init|=
operator|(
name|input_symhdr
operator|->
name|cbAuxOffset
operator|+
name|fdr
operator|.
name|iauxBase
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|aux_ext
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|add_file_shuffle
argument_list|(
name|ainfo
argument_list|,
operator|&
name|ainfo
operator|->
name|aux
argument_list|,
operator|&
name|ainfo
operator|->
name|aux_end
argument_list|,
name|input_bfd
argument_list|,
name|pos
argument_list|,
name|fdr
operator|.
name|caux
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|aux_ext
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|fdr
operator|.
name|iauxBase
operator|=
name|output_symhdr
operator|->
name|iauxMax
expr_stmt|;
name|output_symhdr
operator|->
name|iauxMax
operator|+=
name|fdr
operator|.
name|caux
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|info
operator|->
name|relocatable
condition|)
block|{
comment|/* When are are hashing strings, we lie about the number of 	     strings attached to each FDR.  We need to set cbSs 	     because some versions of dbx apparently use it to decide 	     how much of the string table to read in.  */
name|fdr
operator|.
name|issBase
operator|=
literal|0
expr_stmt|;
name|fdr
operator|.
name|cbSs
operator|=
name|output_symhdr
operator|->
name|issMax
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fdr
operator|.
name|cbSs
operator|>
literal|0
condition|)
block|{
name|file_ptr
name|pos
init|=
name|input_symhdr
operator|->
name|cbSsOffset
operator|+
name|fdr
operator|.
name|issBase
decl_stmt|;
if|if
condition|(
operator|!
name|add_file_shuffle
argument_list|(
name|ainfo
argument_list|,
operator|&
name|ainfo
operator|->
name|ss
argument_list|,
operator|&
name|ainfo
operator|->
name|ss_end
argument_list|,
name|input_bfd
argument_list|,
name|pos
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|fdr
operator|.
name|cbSs
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|fdr
operator|.
name|issBase
operator|=
name|output_symhdr
operator|->
name|issMax
expr_stmt|;
name|output_symhdr
operator|->
name|issMax
operator|+=
name|fdr
operator|.
name|cbSs
expr_stmt|;
block|}
if|if
condition|(
name|output_bfd
operator|->
name|xvec
operator|->
name|header_byteorder
operator|==
name|input_bfd
operator|->
name|xvec
operator|->
name|header_byteorder
condition|)
block|{
comment|/* The two BFD's have the same endianness, and we don't have 	     to adjust the PDR addresses, so simply copying the 	     information will suffice.  */
name|BFD_ASSERT
argument_list|(
name|external_pdr_size
operator|==
name|input_swap
operator|->
name|external_pdr_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdr
operator|.
name|cpd
operator|>
literal|0
condition|)
block|{
name|file_ptr
name|pos
init|=
operator|(
name|input_symhdr
operator|->
name|cbPdOffset
operator|+
name|fdr
operator|.
name|ipdFirst
operator|*
name|external_pdr_size
operator|)
decl_stmt|;
name|unsigned
name|long
name|size
init|=
name|fdr
operator|.
name|cpd
operator|*
name|external_pdr_size
decl_stmt|;
if|if
condition|(
operator|!
name|add_file_shuffle
argument_list|(
name|ainfo
argument_list|,
operator|&
name|ainfo
operator|->
name|pdr
argument_list|,
operator|&
name|ainfo
operator|->
name|pdr_end
argument_list|,
name|input_bfd
argument_list|,
name|pos
argument_list|,
name|size
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
name|BFD_ASSERT
argument_list|(
name|external_opt_size
operator|==
name|input_swap
operator|->
name|external_opt_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdr
operator|.
name|copt
operator|>
literal|0
condition|)
block|{
name|file_ptr
name|pos
init|=
operator|(
name|input_symhdr
operator|->
name|cbOptOffset
operator|+
name|fdr
operator|.
name|ioptBase
operator|*
name|external_opt_size
operator|)
decl_stmt|;
name|unsigned
name|long
name|size
init|=
name|fdr
operator|.
name|copt
operator|*
name|external_opt_size
decl_stmt|;
if|if
condition|(
operator|!
name|add_file_shuffle
argument_list|(
name|ainfo
argument_list|,
operator|&
name|ainfo
operator|->
name|opt
argument_list|,
operator|&
name|ainfo
operator|->
name|opt_end
argument_list|,
name|input_bfd
argument_list|,
name|pos
argument_list|,
name|size
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
else|else
block|{
name|bfd_size_type
name|outsz
decl_stmt|,
name|insz
decl_stmt|;
name|bfd_byte
modifier|*
name|in
decl_stmt|;
name|bfd_byte
modifier|*
name|end
decl_stmt|;
name|bfd_byte
modifier|*
name|out
decl_stmt|;
comment|/* The two BFD's have different endianness, so we must swap 	     everything in and out.  This code would always work, but 	     it would be unnecessarily slow in the normal case.  */
name|outsz
operator|=
name|external_pdr_size
expr_stmt|;
name|insz
operator|=
name|input_swap
operator|->
name|external_pdr_size
expr_stmt|;
name|in
operator|=
operator|(
operator|(
name|bfd_byte
operator|*
operator|)
name|input_debug
operator|->
name|external_pdr
operator|+
name|fdr
operator|.
name|ipdFirst
operator|*
name|insz
operator|)
expr_stmt|;
name|end
operator|=
name|in
operator|+
name|fdr
operator|.
name|cpd
operator|*
name|insz
expr_stmt|;
name|sz
operator|=
name|fdr
operator|.
name|cpd
operator|*
name|outsz
expr_stmt|;
name|out
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|objalloc_alloc
argument_list|(
name|ainfo
operator|->
name|memory
argument_list|,
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|out
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|add_memory_shuffle
argument_list|(
name|ainfo
argument_list|,
operator|&
name|ainfo
operator|->
name|pdr
argument_list|,
operator|&
name|ainfo
operator|->
name|pdr_end
argument_list|,
name|out
argument_list|,
name|sz
argument_list|)
condition|)
return|return
name|FALSE
return|;
for|for
control|(
init|;
name|in
operator|<
name|end
condition|;
name|in
operator|+=
name|insz
operator|,
name|out
operator|+=
name|outsz
control|)
block|{
name|PDR
name|pdr
decl_stmt|;
call|(
modifier|*
name|input_swap
operator|->
name|swap_pdr_in
call|)
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|PTR
operator|)
name|in
argument_list|,
operator|&
name|pdr
argument_list|)
expr_stmt|;
call|(
modifier|*
name|output_swap
operator|->
name|swap_pdr_out
call|)
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|pdr
argument_list|,
operator|(
name|PTR
operator|)
name|out
argument_list|)
expr_stmt|;
block|}
comment|/* Swap over the optimization information.  */
name|outsz
operator|=
name|external_opt_size
expr_stmt|;
name|insz
operator|=
name|input_swap
operator|->
name|external_opt_size
expr_stmt|;
name|in
operator|=
operator|(
operator|(
name|bfd_byte
operator|*
operator|)
name|input_debug
operator|->
name|external_opt
operator|+
name|fdr
operator|.
name|ioptBase
operator|*
name|insz
operator|)
expr_stmt|;
name|end
operator|=
name|in
operator|+
name|fdr
operator|.
name|copt
operator|*
name|insz
expr_stmt|;
name|sz
operator|=
name|fdr
operator|.
name|copt
operator|*
name|outsz
expr_stmt|;
name|out
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|objalloc_alloc
argument_list|(
name|ainfo
operator|->
name|memory
argument_list|,
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|out
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|add_memory_shuffle
argument_list|(
name|ainfo
argument_list|,
operator|&
name|ainfo
operator|->
name|opt
argument_list|,
operator|&
name|ainfo
operator|->
name|opt_end
argument_list|,
name|out
argument_list|,
name|sz
argument_list|)
condition|)
return|return
name|FALSE
return|;
for|for
control|(
init|;
name|in
operator|<
name|end
condition|;
name|in
operator|+=
name|insz
operator|,
name|out
operator|+=
name|outsz
control|)
block|{
name|OPTR
name|opt
decl_stmt|;
call|(
modifier|*
name|input_swap
operator|->
name|swap_opt_in
call|)
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|PTR
operator|)
name|in
argument_list|,
operator|&
name|opt
argument_list|)
expr_stmt|;
call|(
modifier|*
name|output_swap
operator|->
name|swap_opt_out
call|)
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|opt
argument_list|,
operator|(
name|PTR
operator|)
name|out
argument_list|)
expr_stmt|;
block|}
block|}
name|fdr
operator|.
name|ipdFirst
operator|=
name|output_symhdr
operator|->
name|ipdMax
expr_stmt|;
name|output_symhdr
operator|->
name|ipdMax
operator|+=
name|fdr
operator|.
name|cpd
expr_stmt|;
name|fdr
operator|.
name|ioptBase
operator|=
name|output_symhdr
operator|->
name|ioptMax
expr_stmt|;
name|output_symhdr
operator|->
name|ioptMax
operator|+=
name|fdr
operator|.
name|copt
expr_stmt|;
if|if
condition|(
name|fdr
operator|.
name|crfd
operator|<=
literal|0
condition|)
block|{
comment|/* Point this FDR at the table of RFD's we created.  */
name|fdr
operator|.
name|rfdBase
operator|=
name|newrfdbase
expr_stmt|;
name|fdr
operator|.
name|crfd
operator|=
name|input_symhdr
operator|->
name|ifdMax
expr_stmt|;
block|}
else|else
block|{
comment|/* Point this FDR at the remapped RFD's.  */
name|fdr
operator|.
name|rfdBase
operator|+=
name|oldrfdbase
expr_stmt|;
block|}
call|(
modifier|*
name|swap_fdr_out
call|)
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|fdr
argument_list|,
name|fdr_out
argument_list|)
expr_stmt|;
name|fdr_out
operator|+=
name|external_fdr_size
expr_stmt|;
operator|++
name|output_symhdr
operator|->
name|ifdMax
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Add a string to the debugging information we are accumulating.    Return the offset from the fdr string base.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|ecoff_add_string
name|PARAMS
argument_list|(
operator|(
expr|struct
name|accumulate
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|ecoff_debug_info
operator|*
operator|,
name|FDR
operator|*
name|fdr
operator|,
specifier|const
name|char
operator|*
name|string
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|long
name|ecoff_add_string
parameter_list|(
name|ainfo
parameter_list|,
name|info
parameter_list|,
name|debug
parameter_list|,
name|fdr
parameter_list|,
name|string
parameter_list|)
name|struct
name|accumulate
modifier|*
name|ainfo
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|ecoff_debug_info
modifier|*
name|debug
decl_stmt|;
name|FDR
modifier|*
name|fdr
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|HDRR
modifier|*
name|symhdr
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|bfd_size_type
name|ret
decl_stmt|;
name|symhdr
operator|=
operator|&
name|debug
operator|->
name|symbolic_header
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
block|{
if|if
condition|(
operator|!
name|add_memory_shuffle
argument_list|(
name|ainfo
argument_list|,
operator|&
name|ainfo
operator|->
name|ss
argument_list|,
operator|&
name|ainfo
operator|->
name|ss_end
argument_list|,
operator|(
name|PTR
operator|)
name|string
argument_list|,
name|len
operator|+
literal|1
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|ret
operator|=
name|symhdr
operator|->
name|issMax
expr_stmt|;
name|symhdr
operator|->
name|issMax
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
name|fdr
operator|->
name|cbSs
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|struct
name|string_hash_entry
modifier|*
name|sh
decl_stmt|;
name|sh
operator|=
name|string_hash_lookup
argument_list|(
operator|&
name|ainfo
operator|->
name|str_hash
argument_list|,
name|string
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sh
operator|==
operator|(
expr|struct
name|string_hash_entry
operator|*
operator|)
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|sh
operator|->
name|val
operator|==
operator|-
literal|1
condition|)
block|{
name|sh
operator|->
name|val
operator|=
name|symhdr
operator|->
name|issMax
expr_stmt|;
name|symhdr
operator|->
name|issMax
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|ainfo
operator|->
name|ss_hash
operator|==
operator|(
expr|struct
name|string_hash_entry
operator|*
operator|)
name|NULL
condition|)
name|ainfo
operator|->
name|ss_hash
operator|=
name|sh
expr_stmt|;
if|if
condition|(
name|ainfo
operator|->
name|ss_hash_end
operator|!=
operator|(
expr|struct
name|string_hash_entry
operator|*
operator|)
name|NULL
condition|)
name|ainfo
operator|->
name|ss_hash_end
operator|->
name|next
operator|=
name|sh
expr_stmt|;
name|ainfo
operator|->
name|ss_hash_end
operator|=
name|sh
expr_stmt|;
block|}
name|ret
operator|=
name|sh
operator|->
name|val
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Add debugging information from a non-ECOFF file.  */
end_comment

begin_function
name|bfd_boolean
name|bfd_ecoff_debug_accumulate_other
parameter_list|(
name|handle
parameter_list|,
name|output_bfd
parameter_list|,
name|output_debug
parameter_list|,
name|output_swap
parameter_list|,
name|input_bfd
parameter_list|,
name|info
parameter_list|)
name|PTR
name|handle
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|ecoff_debug_info
modifier|*
name|output_debug
decl_stmt|;
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|output_swap
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|struct
name|accumulate
modifier|*
name|ainfo
init|=
operator|(
expr|struct
name|accumulate
operator|*
operator|)
name|handle
decl_stmt|;
name|void
argument_list|(
argument|* const swap_sym_out
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|SYMR
operator|*
operator|,
name|PTR
operator|)
argument_list|)
operator|=
name|output_swap
operator|->
name|swap_sym_out
expr_stmt|;
name|HDRR
modifier|*
name|output_symhdr
init|=
operator|&
name|output_debug
operator|->
name|symbolic_header
decl_stmt|;
name|FDR
name|fdr
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|sym_ptr
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|sym_end
decl_stmt|;
name|long
name|symsize
decl_stmt|;
name|long
name|symcount
decl_stmt|;
name|PTR
name|external_fdr
decl_stmt|;
name|memset
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|fdr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|fdr
argument_list|)
expr_stmt|;
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|input_bfd
argument_list|,
literal|".text"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|!=
name|NULL
condition|)
name|fdr
operator|.
name|adr
operator|=
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
expr_stmt|;
else|else
block|{
comment|/* FIXME: What about .init or .fini?  */
name|fdr
operator|.
name|adr
operator|=
literal|0
expr_stmt|;
block|}
name|fdr
operator|.
name|issBase
operator|=
name|output_symhdr
operator|->
name|issMax
expr_stmt|;
name|fdr
operator|.
name|cbSs
operator|=
literal|0
expr_stmt|;
name|fdr
operator|.
name|rss
operator|=
name|ecoff_add_string
argument_list|(
name|ainfo
argument_list|,
name|info
argument_list|,
name|output_debug
argument_list|,
operator|&
name|fdr
argument_list|,
name|input_bfd
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdr
operator|.
name|rss
operator|==
operator|-
literal|1
condition|)
return|return
name|FALSE
return|;
name|fdr
operator|.
name|isymBase
operator|=
name|output_symhdr
operator|->
name|isymMax
expr_stmt|;
comment|/* Get the local symbols from the input BFD.  */
name|symsize
operator|=
name|bfd_get_symtab_upper_bound
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|symsize
operator|<
literal|0
condition|)
return|return
name|FALSE
return|;
name|symbols
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|symsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbols
operator|==
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|NULL
condition|)
return|return
name|FALSE
return|;
name|symcount
operator|=
name|bfd_canonicalize_symtab
argument_list|(
name|input_bfd
argument_list|,
name|symbols
argument_list|)
expr_stmt|;
if|if
condition|(
name|symcount
operator|<
literal|0
condition|)
return|return
name|FALSE
return|;
name|sym_end
operator|=
name|symbols
operator|+
name|symcount
expr_stmt|;
comment|/* Handle the local symbols.  Any external symbols are handled      separately.  */
name|fdr
operator|.
name|csym
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|sym_ptr
operator|=
name|symbols
init|;
name|sym_ptr
operator|!=
name|sym_end
condition|;
name|sym_ptr
operator|++
control|)
block|{
name|SYMR
name|internal_sym
decl_stmt|;
name|PTR
name|external_sym
decl_stmt|;
if|if
condition|(
operator|(
operator|(
operator|*
name|sym_ptr
operator|)
operator|->
name|flags
operator|&
name|BSF_EXPORT
operator|)
operator|!=
literal|0
condition|)
continue|continue;
name|memset
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|internal_sym
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|internal_sym
argument_list|)
expr_stmt|;
name|internal_sym
operator|.
name|iss
operator|=
name|ecoff_add_string
argument_list|(
name|ainfo
argument_list|,
name|info
argument_list|,
name|output_debug
argument_list|,
operator|&
name|fdr
argument_list|,
operator|(
operator|*
name|sym_ptr
operator|)
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_sym
operator|.
name|iss
operator|==
operator|-
literal|1
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|bfd_is_com_section
argument_list|(
operator|(
operator|*
name|sym_ptr
operator|)
operator|->
name|section
argument_list|)
operator|||
name|bfd_is_und_section
argument_list|(
operator|(
operator|*
name|sym_ptr
operator|)
operator|->
name|section
argument_list|)
condition|)
name|internal_sym
operator|.
name|value
operator|=
operator|(
operator|*
name|sym_ptr
operator|)
operator|->
name|value
expr_stmt|;
else|else
name|internal_sym
operator|.
name|value
operator|=
operator|(
operator|(
operator|*
name|sym_ptr
operator|)
operator|->
name|value
operator|+
operator|(
operator|*
name|sym_ptr
operator|)
operator|->
name|section
operator|->
name|output_offset
operator|+
operator|(
operator|*
name|sym_ptr
operator|)
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
name|internal_sym
operator|.
name|st
operator|=
name|stNil
expr_stmt|;
name|internal_sym
operator|.
name|sc
operator|=
name|scUndefined
expr_stmt|;
name|internal_sym
operator|.
name|index
operator|=
name|indexNil
expr_stmt|;
name|external_sym
operator|=
operator|(
name|PTR
operator|)
name|objalloc_alloc
argument_list|(
name|ainfo
operator|->
name|memory
argument_list|,
name|output_swap
operator|->
name|external_sym_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|external_sym
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
call|(
modifier|*
name|swap_sym_out
call|)
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|internal_sym
argument_list|,
name|external_sym
argument_list|)
expr_stmt|;
name|add_memory_shuffle
argument_list|(
name|ainfo
argument_list|,
operator|&
name|ainfo
operator|->
name|sym
argument_list|,
operator|&
name|ainfo
operator|->
name|sym_end
argument_list|,
name|external_sym
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|output_swap
operator|->
name|external_sym_size
argument_list|)
expr_stmt|;
operator|++
name|fdr
operator|.
name|csym
expr_stmt|;
operator|++
name|output_symhdr
operator|->
name|isymMax
expr_stmt|;
block|}
name|bfd_release
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|PTR
operator|)
name|symbols
argument_list|)
expr_stmt|;
comment|/* Leave everything else in the FDR zeroed out.  This will cause      the lang field to be langC.  The fBigendian field will      indicate little endian format, but it doesn't matter because      it only applies to aux fields and there are none.  */
name|external_fdr
operator|=
operator|(
name|PTR
operator|)
name|objalloc_alloc
argument_list|(
name|ainfo
operator|->
name|memory
argument_list|,
name|output_swap
operator|->
name|external_fdr_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|external_fdr
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
call|(
modifier|*
name|output_swap
operator|->
name|swap_fdr_out
call|)
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|fdr
argument_list|,
name|external_fdr
argument_list|)
expr_stmt|;
name|add_memory_shuffle
argument_list|(
name|ainfo
argument_list|,
operator|&
name|ainfo
operator|->
name|fdr
argument_list|,
operator|&
name|ainfo
operator|->
name|fdr_end
argument_list|,
name|external_fdr
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|output_swap
operator|->
name|external_fdr_size
argument_list|)
expr_stmt|;
operator|++
name|output_symhdr
operator|->
name|ifdMax
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Set up ECOFF debugging information for the external symbols.    FIXME: This is done using a memory buffer, but it should be    probably be changed to use a shuffle structure.  The assembler uses    this interface, so that must be changed to do something else.  */
end_comment

begin_function_decl
name|bfd_boolean
name|bfd_ecoff_debug_externals
parameter_list|(
name|abfd
parameter_list|,
name|debug
parameter_list|,
name|swap
parameter_list|,
name|relocatable
parameter_list|,
name|get_extr
parameter_list|,
name|set_index
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|ecoff_debug_info
modifier|*
name|debug
decl_stmt|;
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|swap
decl_stmt|;
name|bfd_boolean
name|relocatable
decl_stmt|;
function_decl|bfd_boolean
parameter_list|(
function_decl|*get_extr
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|asymbol
operator|*
operator|,
name|EXTR
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|void
argument_list|(
argument|*set_index
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
name|asymbol
operator|*
operator|,
name|bfd_size_type
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|HDRR
modifier|*
specifier|const
name|symhdr
init|=
operator|&
name|debug
operator|->
name|symbolic_header
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|sym_ptr_ptr
decl_stmt|;
name|size_t
name|c
decl_stmt|;
name|sym_ptr_ptr
operator|=
name|bfd_get_outsymbols
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_ptr_ptr
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
for|for
control|(
name|c
operator|=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
init|;
name|c
operator|>
literal|0
condition|;
name|c
operator|--
operator|,
name|sym_ptr_ptr
operator|++
control|)
block|{
name|asymbol
modifier|*
name|sym_ptr
decl_stmt|;
name|EXTR
name|esym
decl_stmt|;
name|sym_ptr
operator|=
operator|*
name|sym_ptr_ptr
expr_stmt|;
comment|/* Get the external symbol information.  */
if|if
condition|(
operator|!
call|(
modifier|*
name|get_extr
call|)
argument_list|(
name|sym_ptr
argument_list|,
operator|&
name|esym
argument_list|)
condition|)
continue|continue;
comment|/* If we're producing an executable, move common symbols into 	 bss.  */
if|if
condition|(
operator|!
name|relocatable
condition|)
block|{
if|if
condition|(
name|esym
operator|.
name|asym
operator|.
name|sc
operator|==
name|scCommon
condition|)
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scBss
expr_stmt|;
elseif|else
if|if
condition|(
name|esym
operator|.
name|asym
operator|.
name|sc
operator|==
name|scSCommon
condition|)
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scSBss
expr_stmt|;
block|}
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|sym_ptr
operator|->
name|section
argument_list|)
operator|||
name|bfd_is_und_section
argument_list|(
name|sym_ptr
operator|->
name|section
argument_list|)
operator|||
name|sym_ptr
operator|->
name|section
operator|->
name|output_section
operator|==
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* FIXME: gas does not keep the value of a small undefined 	     symbol in the symbol itself, because of relocation 	     problems.  */
if|if
condition|(
name|esym
operator|.
name|asym
operator|.
name|sc
operator|!=
name|scSUndefined
operator|||
name|esym
operator|.
name|asym
operator|.
name|value
operator|==
literal|0
operator|||
name|sym_ptr
operator|->
name|value
operator|!=
literal|0
condition|)
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
name|sym_ptr
operator|->
name|value
expr_stmt|;
block|}
else|else
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
operator|(
name|sym_ptr
operator|->
name|value
operator|+
name|sym_ptr
operator|->
name|section
operator|->
name|output_offset
operator|+
name|sym_ptr
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
if|if
condition|(
name|set_index
condition|)
call|(
modifier|*
name|set_index
call|)
argument_list|(
name|sym_ptr
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|symhdr
operator|->
name|iextMax
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_ecoff_debug_one_external
argument_list|(
name|abfd
argument_list|,
name|debug
argument_list|,
name|swap
argument_list|,
name|sym_ptr
operator|->
name|name
argument_list|,
operator|&
name|esym
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_block

begin_comment
comment|/* Add a single external symbol to the debugging information.  */
end_comment

begin_function
name|bfd_boolean
name|bfd_ecoff_debug_one_external
parameter_list|(
name|abfd
parameter_list|,
name|debug
parameter_list|,
name|swap
parameter_list|,
name|name
parameter_list|,
name|esym
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|ecoff_debug_info
modifier|*
name|debug
decl_stmt|;
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|swap
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|EXTR
modifier|*
name|esym
decl_stmt|;
block|{
specifier|const
name|bfd_size_type
name|external_ext_size
init|=
name|swap
operator|->
name|external_ext_size
decl_stmt|;
name|void
argument_list|(
argument|* const swap_ext_out
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|EXTR
operator|*
operator|,
name|PTR
operator|)
argument_list|)
operator|=
name|swap
operator|->
name|swap_ext_out
expr_stmt|;
name|HDRR
modifier|*
specifier|const
name|symhdr
init|=
operator|&
name|debug
operator|->
name|symbolic_header
decl_stmt|;
name|size_t
name|namelen
decl_stmt|;
name|namelen
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
name|size_t
call|)
argument_list|(
name|debug
operator|->
name|ssext_end
operator|-
name|debug
operator|->
name|ssext
argument_list|)
operator|<
name|symhdr
operator|->
name|issExtMax
operator|+
name|namelen
operator|+
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|ecoff_add_bytes
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|debug
operator|->
name|ssext
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|debug
operator|->
name|ssext_end
argument_list|,
name|symhdr
operator|->
name|issExtMax
operator|+
name|namelen
operator|+
literal|1
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
call|(
name|size_t
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|debug
operator|->
name|external_ext_end
operator|-
operator|(
name|char
operator|*
operator|)
name|debug
operator|->
name|external_ext
argument_list|)
operator|<
operator|(
name|symhdr
operator|->
name|iextMax
operator|+
literal|1
operator|)
operator|*
name|external_ext_size
condition|)
block|{
name|char
modifier|*
name|external_ext
init|=
name|debug
operator|->
name|external_ext
decl_stmt|;
name|char
modifier|*
name|external_ext_end
init|=
name|debug
operator|->
name|external_ext_end
decl_stmt|;
if|if
condition|(
operator|!
name|ecoff_add_bytes
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|external_ext
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|external_ext_end
argument_list|,
operator|(
name|symhdr
operator|->
name|iextMax
operator|+
literal|1
operator|)
operator|*
operator|(
name|size_t
operator|)
name|external_ext_size
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|debug
operator|->
name|external_ext
operator|=
name|external_ext
expr_stmt|;
name|debug
operator|->
name|external_ext_end
operator|=
name|external_ext_end
expr_stmt|;
block|}
name|esym
operator|->
name|asym
operator|.
name|iss
operator|=
name|symhdr
operator|->
name|issExtMax
expr_stmt|;
call|(
modifier|*
name|swap_ext_out
call|)
argument_list|(
name|abfd
argument_list|,
name|esym
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|debug
operator|->
name|external_ext
operator|+
name|symhdr
operator|->
name|iextMax
operator|*
name|swap
operator|->
name|external_ext_size
operator|)
argument_list|)
expr_stmt|;
operator|++
name|symhdr
operator|->
name|iextMax
expr_stmt|;
name|strcpy
argument_list|(
name|debug
operator|->
name|ssext
operator|+
name|symhdr
operator|->
name|issExtMax
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|symhdr
operator|->
name|issExtMax
operator|+=
name|namelen
operator|+
literal|1
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Align the ECOFF debugging information.  */
end_comment

begin_function
specifier|static
name|void
name|ecoff_align_debug
parameter_list|(
name|abfd
parameter_list|,
name|debug
parameter_list|,
name|swap
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|ecoff_debug_info
modifier|*
name|debug
decl_stmt|;
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|swap
decl_stmt|;
block|{
name|HDRR
modifier|*
specifier|const
name|symhdr
init|=
operator|&
name|debug
operator|->
name|symbolic_header
decl_stmt|;
name|bfd_size_type
name|debug_align
decl_stmt|,
name|aux_align
decl_stmt|,
name|rfd_align
decl_stmt|;
name|size_t
name|add
decl_stmt|;
comment|/* Adjust the counts so that structures are aligned.  */
name|debug_align
operator|=
name|swap
operator|->
name|debug_align
expr_stmt|;
name|aux_align
operator|=
name|debug_align
operator|/
sizeof|sizeof
argument_list|(
expr|union
name|aux_ext
argument_list|)
expr_stmt|;
name|rfd_align
operator|=
name|debug_align
operator|/
name|swap
operator|->
name|external_rfd_size
expr_stmt|;
name|add
operator|=
name|debug_align
operator|-
operator|(
name|symhdr
operator|->
name|cbLine
operator|&
operator|(
name|debug_align
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|add
operator|!=
name|debug_align
condition|)
block|{
if|if
condition|(
name|debug
operator|->
name|line
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|NULL
condition|)
name|memset
argument_list|(
call|(
name|PTR
call|)
argument_list|(
name|debug
operator|->
name|line
operator|+
name|symhdr
operator|->
name|cbLine
argument_list|)
argument_list|,
literal|0
argument_list|,
name|add
argument_list|)
expr_stmt|;
name|symhdr
operator|->
name|cbLine
operator|+=
name|add
expr_stmt|;
block|}
name|add
operator|=
name|debug_align
operator|-
operator|(
name|symhdr
operator|->
name|issMax
operator|&
operator|(
name|debug_align
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|add
operator|!=
name|debug_align
condition|)
block|{
if|if
condition|(
name|debug
operator|->
name|ss
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|memset
argument_list|(
call|(
name|PTR
call|)
argument_list|(
name|debug
operator|->
name|ss
operator|+
name|symhdr
operator|->
name|issMax
argument_list|)
argument_list|,
literal|0
argument_list|,
name|add
argument_list|)
expr_stmt|;
name|symhdr
operator|->
name|issMax
operator|+=
name|add
expr_stmt|;
block|}
name|add
operator|=
name|debug_align
operator|-
operator|(
name|symhdr
operator|->
name|issExtMax
operator|&
operator|(
name|debug_align
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|add
operator|!=
name|debug_align
condition|)
block|{
if|if
condition|(
name|debug
operator|->
name|ssext
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|memset
argument_list|(
call|(
name|PTR
call|)
argument_list|(
name|debug
operator|->
name|ssext
operator|+
name|symhdr
operator|->
name|issExtMax
argument_list|)
argument_list|,
literal|0
argument_list|,
name|add
argument_list|)
expr_stmt|;
name|symhdr
operator|->
name|issExtMax
operator|+=
name|add
expr_stmt|;
block|}
name|add
operator|=
name|aux_align
operator|-
operator|(
name|symhdr
operator|->
name|iauxMax
operator|&
operator|(
name|aux_align
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|add
operator|!=
name|aux_align
condition|)
block|{
if|if
condition|(
name|debug
operator|->
name|external_aux
operator|!=
operator|(
expr|union
name|aux_ext
operator|*
operator|)
name|NULL
condition|)
name|memset
argument_list|(
call|(
name|PTR
call|)
argument_list|(
name|debug
operator|->
name|external_aux
operator|+
name|symhdr
operator|->
name|iauxMax
argument_list|)
argument_list|,
literal|0
argument_list|,
name|add
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|aux_ext
argument_list|)
argument_list|)
expr_stmt|;
name|symhdr
operator|->
name|iauxMax
operator|+=
name|add
expr_stmt|;
block|}
name|add
operator|=
name|rfd_align
operator|-
operator|(
name|symhdr
operator|->
name|crfd
operator|&
operator|(
name|rfd_align
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|add
operator|!=
name|rfd_align
condition|)
block|{
if|if
condition|(
name|debug
operator|->
name|external_rfd
operator|!=
operator|(
name|PTR
operator|)
name|NULL
condition|)
name|memset
argument_list|(
call|(
name|PTR
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|debug
operator|->
name|external_rfd
operator|+
name|symhdr
operator|->
name|crfd
operator|*
name|swap
operator|->
name|external_rfd_size
argument_list|)
argument_list|,
literal|0
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|add
operator|*
name|swap
operator|->
name|external_rfd_size
argument_list|)
argument_list|)
expr_stmt|;
name|symhdr
operator|->
name|crfd
operator|+=
name|add
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return the size required by the ECOFF debugging information.  */
end_comment

begin_function
name|bfd_size_type
name|bfd_ecoff_debug_size
parameter_list|(
name|abfd
parameter_list|,
name|debug
parameter_list|,
name|swap
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|ecoff_debug_info
modifier|*
name|debug
decl_stmt|;
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|swap
decl_stmt|;
block|{
name|bfd_size_type
name|tot
decl_stmt|;
name|ecoff_align_debug
argument_list|(
name|abfd
argument_list|,
name|debug
argument_list|,
name|swap
argument_list|)
expr_stmt|;
name|tot
operator|=
name|swap
operator|->
name|external_hdr_size
expr_stmt|;
define|#
directive|define
name|ADD
parameter_list|(
name|count
parameter_list|,
name|size
parameter_list|)
define|\
value|tot += debug->symbolic_header.count * size
name|ADD
argument_list|(
name|cbLine
argument_list|,
expr|sizeof
operator|(
name|unsigned
name|char
operator|)
argument_list|)
expr_stmt|;
name|ADD
argument_list|(
name|idnMax
argument_list|,
name|swap
operator|->
name|external_dnr_size
argument_list|)
expr_stmt|;
name|ADD
argument_list|(
name|ipdMax
argument_list|,
name|swap
operator|->
name|external_pdr_size
argument_list|)
expr_stmt|;
name|ADD
argument_list|(
name|isymMax
argument_list|,
name|swap
operator|->
name|external_sym_size
argument_list|)
expr_stmt|;
name|ADD
argument_list|(
name|ioptMax
argument_list|,
name|swap
operator|->
name|external_opt_size
argument_list|)
expr_stmt|;
name|ADD
argument_list|(
name|iauxMax
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|aux_ext
argument_list|)
argument_list|)
expr_stmt|;
name|ADD
argument_list|(
name|issMax
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|ADD
argument_list|(
name|issExtMax
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|ADD
argument_list|(
name|ifdMax
argument_list|,
name|swap
operator|->
name|external_fdr_size
argument_list|)
expr_stmt|;
name|ADD
argument_list|(
name|crfd
argument_list|,
name|swap
operator|->
name|external_rfd_size
argument_list|)
expr_stmt|;
name|ADD
argument_list|(
name|iextMax
argument_list|,
name|swap
operator|->
name|external_ext_size
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|ADD
return|return
name|tot
return|;
block|}
end_function

begin_comment
comment|/* Write out the ECOFF symbolic header, given the file position it is    going to be placed at.  This assumes that the counts are set    correctly.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ecoff_write_symhdr
parameter_list|(
name|abfd
parameter_list|,
name|debug
parameter_list|,
name|swap
parameter_list|,
name|where
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|ecoff_debug_info
modifier|*
name|debug
decl_stmt|;
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|swap
decl_stmt|;
name|file_ptr
name|where
decl_stmt|;
block|{
name|HDRR
modifier|*
specifier|const
name|symhdr
init|=
operator|&
name|debug
operator|->
name|symbolic_header
decl_stmt|;
name|char
modifier|*
name|buff
init|=
name|NULL
decl_stmt|;
name|ecoff_align_debug
argument_list|(
name|abfd
argument_list|,
name|debug
argument_list|,
name|swap
argument_list|)
expr_stmt|;
comment|/* Go to the right location in the file.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|where
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
name|where
operator|+=
name|swap
operator|->
name|external_hdr_size
expr_stmt|;
name|symhdr
operator|->
name|magic
operator|=
name|swap
operator|->
name|sym_magic
expr_stmt|;
comment|/* Fill in the file offsets.  */
define|#
directive|define
name|SET
parameter_list|(
name|offset
parameter_list|,
name|count
parameter_list|,
name|size
parameter_list|)
define|\
value|if (symhdr->count == 0) \     symhdr->offset = 0; \   else \     { \       symhdr->offset = where; \       where += symhdr->count * size; \     }
name|SET
argument_list|(
name|cbLineOffset
argument_list|,
name|cbLine
argument_list|,
expr|sizeof
operator|(
name|unsigned
name|char
operator|)
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|cbDnOffset
argument_list|,
name|idnMax
argument_list|,
name|swap
operator|->
name|external_dnr_size
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|cbPdOffset
argument_list|,
name|ipdMax
argument_list|,
name|swap
operator|->
name|external_pdr_size
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|cbSymOffset
argument_list|,
name|isymMax
argument_list|,
name|swap
operator|->
name|external_sym_size
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|cbOptOffset
argument_list|,
name|ioptMax
argument_list|,
name|swap
operator|->
name|external_opt_size
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|cbAuxOffset
argument_list|,
name|iauxMax
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|aux_ext
argument_list|)
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|cbSsOffset
argument_list|,
name|issMax
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|cbSsExtOffset
argument_list|,
name|issExtMax
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|cbFdOffset
argument_list|,
name|ifdMax
argument_list|,
name|swap
operator|->
name|external_fdr_size
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|cbRfdOffset
argument_list|,
name|crfd
argument_list|,
name|swap
operator|->
name|external_rfd_size
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|cbExtOffset
argument_list|,
name|iextMax
argument_list|,
name|swap
operator|->
name|external_ext_size
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|SET
name|buff
operator|=
operator|(
name|PTR
operator|)
name|bfd_malloc
argument_list|(
name|swap
operator|->
name|external_hdr_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|buff
operator|==
name|NULL
operator|&&
name|swap
operator|->
name|external_hdr_size
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
call|(
modifier|*
name|swap
operator|->
name|swap_hdr_out
call|)
argument_list|(
name|abfd
argument_list|,
name|symhdr
argument_list|,
name|buff
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
name|buff
argument_list|,
name|swap
operator|->
name|external_hdr_size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|swap
operator|->
name|external_hdr_size
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|buff
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|buff
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
name|error_return
label|:
if|if
condition|(
name|buff
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|buff
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Write out the ECOFF debugging information.  This function assumes    that the information (the pointers and counts) in *DEBUG have been    set correctly.  WHERE is the position in the file to write the    information to.  This function fills in the file offsets in the    symbolic header.  */
end_comment

begin_function
name|bfd_boolean
name|bfd_ecoff_write_debug
parameter_list|(
name|abfd
parameter_list|,
name|debug
parameter_list|,
name|swap
parameter_list|,
name|where
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|ecoff_debug_info
modifier|*
name|debug
decl_stmt|;
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|swap
decl_stmt|;
name|file_ptr
name|where
decl_stmt|;
block|{
name|HDRR
modifier|*
specifier|const
name|symhdr
init|=
operator|&
name|debug
operator|->
name|symbolic_header
decl_stmt|;
if|if
condition|(
operator|!
name|ecoff_write_symhdr
argument_list|(
name|abfd
argument_list|,
name|debug
argument_list|,
name|swap
argument_list|,
name|where
argument_list|)
condition|)
return|return
name|FALSE
return|;
define|#
directive|define
name|WRITE
parameter_list|(
name|ptr
parameter_list|,
name|count
parameter_list|,
name|size
parameter_list|,
name|offset
parameter_list|)
define|\
value|BFD_ASSERT (symhdr->offset == 0 \ 	      || (bfd_vma) bfd_tell (abfd) == symhdr->offset); \   if (bfd_bwrite ((PTR) debug->ptr, (bfd_size_type) size * symhdr->count, abfd)\       != size * symhdr->count) \     return FALSE;
name|WRITE
argument_list|(
name|line
argument_list|,
name|cbLine
argument_list|,
expr|sizeof
operator|(
name|unsigned
name|char
operator|)
argument_list|,
name|cbLineOffset
argument_list|)
expr_stmt|;
name|WRITE
argument_list|(
name|external_dnr
argument_list|,
name|idnMax
argument_list|,
name|swap
operator|->
name|external_dnr_size
argument_list|,
name|cbDnOffset
argument_list|)
expr_stmt|;
name|WRITE
argument_list|(
name|external_pdr
argument_list|,
name|ipdMax
argument_list|,
name|swap
operator|->
name|external_pdr_size
argument_list|,
name|cbPdOffset
argument_list|)
expr_stmt|;
name|WRITE
argument_list|(
name|external_sym
argument_list|,
name|isymMax
argument_list|,
name|swap
operator|->
name|external_sym_size
argument_list|,
name|cbSymOffset
argument_list|)
expr_stmt|;
name|WRITE
argument_list|(
name|external_opt
argument_list|,
name|ioptMax
argument_list|,
name|swap
operator|->
name|external_opt_size
argument_list|,
name|cbOptOffset
argument_list|)
expr_stmt|;
name|WRITE
argument_list|(
name|external_aux
argument_list|,
name|iauxMax
argument_list|,
operator|(
name|bfd_size_type
operator|)
sizeof|sizeof
argument_list|(
expr|union
name|aux_ext
argument_list|)
argument_list|,
name|cbAuxOffset
argument_list|)
expr_stmt|;
name|WRITE
argument_list|(
name|ss
argument_list|,
name|issMax
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|cbSsOffset
argument_list|)
expr_stmt|;
name|WRITE
argument_list|(
name|ssext
argument_list|,
name|issExtMax
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|cbSsExtOffset
argument_list|)
expr_stmt|;
name|WRITE
argument_list|(
name|external_fdr
argument_list|,
name|ifdMax
argument_list|,
name|swap
operator|->
name|external_fdr_size
argument_list|,
name|cbFdOffset
argument_list|)
expr_stmt|;
name|WRITE
argument_list|(
name|external_rfd
argument_list|,
name|crfd
argument_list|,
name|swap
operator|->
name|external_rfd_size
argument_list|,
name|cbRfdOffset
argument_list|)
expr_stmt|;
name|WRITE
argument_list|(
name|external_ext
argument_list|,
name|iextMax
argument_list|,
name|swap
operator|->
name|external_ext_size
argument_list|,
name|cbExtOffset
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|WRITE
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Write out a shuffle list.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_boolean
name|ecoff_write_shuffle
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
expr|struct
name|ecoff_debug_swap
operator|*
operator|,
expr|struct
name|shuffle
operator|*
operator|,
name|PTR
name|space
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|bfd_boolean
name|ecoff_write_shuffle
parameter_list|(
name|abfd
parameter_list|,
name|swap
parameter_list|,
name|shuffle
parameter_list|,
name|space
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|swap
decl_stmt|;
name|struct
name|shuffle
modifier|*
name|shuffle
decl_stmt|;
name|PTR
name|space
decl_stmt|;
block|{
specifier|register
name|struct
name|shuffle
modifier|*
name|l
decl_stmt|;
name|unsigned
name|long
name|total
decl_stmt|;
name|total
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|l
operator|=
name|shuffle
init|;
name|l
operator|!=
operator|(
expr|struct
name|shuffle
operator|*
operator|)
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|l
operator|->
name|filep
condition|)
block|{
if|if
condition|(
name|bfd_bwrite
argument_list|(
name|l
operator|->
name|u
operator|.
name|memory
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|l
operator|->
name|size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|l
operator|->
name|size
condition|)
return|return
name|FALSE
return|;
block|}
else|else
block|{
if|if
condition|(
name|bfd_seek
argument_list|(
name|l
operator|->
name|u
operator|.
name|file
operator|.
name|input_bfd
argument_list|,
name|l
operator|->
name|u
operator|.
name|file
operator|.
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bread
argument_list|(
name|space
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|l
operator|->
name|size
argument_list|,
name|l
operator|->
name|u
operator|.
name|file
operator|.
name|input_bfd
argument_list|)
operator|!=
name|l
operator|->
name|size
operator|||
name|bfd_bwrite
argument_list|(
name|space
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|l
operator|->
name|size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|l
operator|->
name|size
condition|)
return|return
name|FALSE
return|;
block|}
name|total
operator|+=
name|l
operator|->
name|size
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|total
operator|&
operator|(
name|swap
operator|->
name|debug_align
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|bfd_byte
modifier|*
name|s
decl_stmt|;
name|i
operator|=
name|swap
operator|->
name|debug_align
operator|-
operator|(
name|total
operator|&
operator|(
name|swap
operator|->
name|debug_align
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|s
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_zmalloc
argument_list|(
operator|(
name|bfd_size_type
operator|)
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|&&
name|i
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
operator|(
name|PTR
operator|)
name|s
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|i
argument_list|,
name|abfd
argument_list|)
operator|!=
name|i
condition|)
block|{
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Write out debugging information using accumulated linker    information.  */
end_comment

begin_function
name|bfd_boolean
name|bfd_ecoff_write_accumulated_debug
parameter_list|(
name|handle
parameter_list|,
name|abfd
parameter_list|,
name|debug
parameter_list|,
name|swap
parameter_list|,
name|info
parameter_list|,
name|where
parameter_list|)
name|PTR
name|handle
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|ecoff_debug_info
modifier|*
name|debug
decl_stmt|;
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|swap
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|file_ptr
name|where
decl_stmt|;
block|{
name|struct
name|accumulate
modifier|*
name|ainfo
init|=
operator|(
expr|struct
name|accumulate
operator|*
operator|)
name|handle
decl_stmt|;
name|PTR
name|space
init|=
name|NULL
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
if|if
condition|(
operator|!
name|ecoff_write_symhdr
argument_list|(
name|abfd
argument_list|,
name|debug
argument_list|,
name|swap
argument_list|,
name|where
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
name|amt
operator|=
name|ainfo
operator|->
name|largest_file_shuffle
expr_stmt|;
name|space
operator|=
operator|(
name|PTR
operator|)
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|space
operator|==
name|NULL
operator|&&
name|ainfo
operator|->
name|largest_file_shuffle
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|ecoff_write_shuffle
argument_list|(
name|abfd
argument_list|,
name|swap
argument_list|,
name|ainfo
operator|->
name|line
argument_list|,
name|space
argument_list|)
operator|||
operator|!
name|ecoff_write_shuffle
argument_list|(
name|abfd
argument_list|,
name|swap
argument_list|,
name|ainfo
operator|->
name|pdr
argument_list|,
name|space
argument_list|)
operator|||
operator|!
name|ecoff_write_shuffle
argument_list|(
name|abfd
argument_list|,
name|swap
argument_list|,
name|ainfo
operator|->
name|sym
argument_list|,
name|space
argument_list|)
operator|||
operator|!
name|ecoff_write_shuffle
argument_list|(
name|abfd
argument_list|,
name|swap
argument_list|,
name|ainfo
operator|->
name|opt
argument_list|,
name|space
argument_list|)
operator|||
operator|!
name|ecoff_write_shuffle
argument_list|(
name|abfd
argument_list|,
name|swap
argument_list|,
name|ainfo
operator|->
name|aux
argument_list|,
name|space
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* The string table is written out from the hash table if this is a      final link.  */
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|ainfo
operator|->
name|ss_hash
operator|==
operator|(
expr|struct
name|string_hash_entry
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ecoff_write_shuffle
argument_list|(
name|abfd
argument_list|,
name|swap
argument_list|,
name|ainfo
operator|->
name|ss
argument_list|,
name|space
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
else|else
block|{
name|unsigned
name|long
name|total
decl_stmt|;
name|bfd_byte
name|null
decl_stmt|;
name|struct
name|string_hash_entry
modifier|*
name|sh
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|ainfo
operator|->
name|ss
operator|==
operator|(
expr|struct
name|shuffle
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|null
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|null
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|1
condition|)
goto|goto
name|error_return
goto|;
name|total
operator|=
literal|1
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|ainfo
operator|->
name|ss_hash
operator|==
name|NULL
operator|||
name|ainfo
operator|->
name|ss_hash
operator|->
name|val
operator|==
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|sh
operator|=
name|ainfo
operator|->
name|ss_hash
init|;
name|sh
operator|!=
operator|(
expr|struct
name|string_hash_entry
operator|*
operator|)
name|NULL
condition|;
name|sh
operator|=
name|sh
operator|->
name|next
control|)
block|{
name|size_t
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|sh
operator|->
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
name|amt
operator|=
name|len
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
operator|(
name|PTR
operator|)
name|sh
operator|->
name|root
operator|.
name|string
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
goto|goto
name|error_return
goto|;
name|total
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|total
operator|&
operator|(
name|swap
operator|->
name|debug_align
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|bfd_byte
modifier|*
name|s
decl_stmt|;
name|i
operator|=
name|swap
operator|->
name|debug_align
operator|-
operator|(
name|total
operator|&
operator|(
name|swap
operator|->
name|debug_align
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|s
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_zmalloc
argument_list|(
operator|(
name|bfd_size_type
operator|)
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|&&
name|i
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
operator|(
name|PTR
operator|)
name|s
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|i
argument_list|,
name|abfd
argument_list|)
operator|!=
name|i
condition|)
block|{
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* The external strings and symbol are not converted over to using      shuffles.  FIXME: They probably should be.  */
name|amt
operator|=
name|debug
operator|->
name|symbolic_header
operator|.
name|issExtMax
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
name|debug
operator|->
name|ssext
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|(
name|debug
operator|->
name|symbolic_header
operator|.
name|issExtMax
operator|&
operator|(
name|swap
operator|->
name|debug_align
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|bfd_byte
modifier|*
name|s
decl_stmt|;
name|i
operator|=
operator|(
name|swap
operator|->
name|debug_align
operator|-
operator|(
name|debug
operator|->
name|symbolic_header
operator|.
name|issExtMax
operator|&
operator|(
name|swap
operator|->
name|debug_align
operator|-
literal|1
operator|)
operator|)
operator|)
expr_stmt|;
name|s
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_zmalloc
argument_list|(
operator|(
name|bfd_size_type
operator|)
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|&&
name|i
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
operator|(
name|PTR
operator|)
name|s
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|i
argument_list|,
name|abfd
argument_list|)
operator|!=
name|i
condition|)
block|{
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ecoff_write_shuffle
argument_list|(
name|abfd
argument_list|,
name|swap
argument_list|,
name|ainfo
operator|->
name|fdr
argument_list|,
name|space
argument_list|)
operator|||
operator|!
name|ecoff_write_shuffle
argument_list|(
name|abfd
argument_list|,
name|swap
argument_list|,
name|ainfo
operator|->
name|rfd
argument_list|,
name|space
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
name|BFD_ASSERT
argument_list|(
name|debug
operator|->
name|symbolic_header
operator|.
name|cbExtOffset
operator|==
literal|0
operator|||
operator|(
name|debug
operator|->
name|symbolic_header
operator|.
name|cbExtOffset
operator|==
operator|(
name|bfd_vma
operator|)
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|amt
operator|=
name|debug
operator|->
name|symbolic_header
operator|.
name|iextMax
operator|*
name|swap
operator|->
name|external_ext_size
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
name|debug
operator|->
name|external_ext
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|space
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|space
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
name|error_return
label|:
if|if
condition|(
name|space
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|space
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Handle the find_nearest_line function for both ECOFF and MIPS ELF    files.  */
end_comment

begin_comment
comment|/* Compare FDR entries.  This is called via qsort.  */
end_comment

begin_function
specifier|static
name|int
name|cmp_fdrtab_entry
parameter_list|(
name|leftp
parameter_list|,
name|rightp
parameter_list|)
specifier|const
name|PTR
name|leftp
decl_stmt|;
specifier|const
name|PTR
name|rightp
decl_stmt|;
block|{
specifier|const
name|struct
name|ecoff_fdrtab_entry
modifier|*
name|lp
init|=
operator|(
specifier|const
expr|struct
name|ecoff_fdrtab_entry
operator|*
operator|)
name|leftp
decl_stmt|;
specifier|const
name|struct
name|ecoff_fdrtab_entry
modifier|*
name|rp
init|=
operator|(
specifier|const
expr|struct
name|ecoff_fdrtab_entry
operator|*
operator|)
name|rightp
decl_stmt|;
if|if
condition|(
name|lp
operator|->
name|base_addr
operator|<
name|rp
operator|->
name|base_addr
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|lp
operator|->
name|base_addr
operator|>
name|rp
operator|->
name|base_addr
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Each file descriptor (FDR) has a memory address, to simplify    looking up an FDR by address, we build a table covering all FDRs    that have a least one procedure descriptor in them.  The final    table will be sorted by address so we can look it up via binary    search.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mk_fdrtab
parameter_list|(
name|abfd
parameter_list|,
name|debug_info
parameter_list|,
name|debug_swap
parameter_list|,
name|line_info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|ecoff_debug_info
modifier|*
specifier|const
name|debug_info
decl_stmt|;
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
specifier|const
name|debug_swap
decl_stmt|;
name|struct
name|ecoff_find_line
modifier|*
name|line_info
decl_stmt|;
block|{
name|struct
name|ecoff_fdrtab_entry
modifier|*
name|tab
decl_stmt|;
name|FDR
modifier|*
name|fdr_ptr
decl_stmt|;
name|FDR
modifier|*
name|fdr_start
decl_stmt|;
name|FDR
modifier|*
name|fdr_end
decl_stmt|;
name|bfd_boolean
name|stabs
decl_stmt|;
name|long
name|len
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|fdr_start
operator|=
name|debug_info
operator|->
name|fdr
expr_stmt|;
name|fdr_end
operator|=
name|fdr_start
operator|+
name|debug_info
operator|->
name|symbolic_header
operator|.
name|ifdMax
expr_stmt|;
comment|/* First, let's see how long the table needs to be.  */
for|for
control|(
name|len
operator|=
literal|0
operator|,
name|fdr_ptr
operator|=
name|fdr_start
init|;
name|fdr_ptr
operator|<
name|fdr_end
condition|;
name|fdr_ptr
operator|++
control|)
block|{
if|if
condition|(
name|fdr_ptr
operator|->
name|cpd
operator|==
literal|0
condition|)
comment|/* Skip FDRs that have no PDRs.  */
continue|continue;
operator|++
name|len
expr_stmt|;
block|}
comment|/* Now, create and fill in the table.  */
name|amt
operator|=
operator|(
name|bfd_size_type
operator|)
name|len
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ecoff_fdrtab_entry
argument_list|)
expr_stmt|;
name|line_info
operator|->
name|fdrtab
operator|=
operator|(
expr|struct
name|ecoff_fdrtab_entry
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|line_info
operator|->
name|fdrtab
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|line_info
operator|->
name|fdrtab_len
operator|=
name|len
expr_stmt|;
name|tab
operator|=
name|line_info
operator|->
name|fdrtab
expr_stmt|;
for|for
control|(
name|fdr_ptr
operator|=
name|fdr_start
init|;
name|fdr_ptr
operator|<
name|fdr_end
condition|;
name|fdr_ptr
operator|++
control|)
block|{
if|if
condition|(
name|fdr_ptr
operator|->
name|cpd
operator|==
literal|0
condition|)
continue|continue;
comment|/* Check whether this file has stabs debugging information.  In 	 a file with stabs debugging information, the second local 	 symbol is named @stabs.  */
name|stabs
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|fdr_ptr
operator|->
name|csym
operator|>=
literal|2
condition|)
block|{
name|char
modifier|*
name|sym_ptr
decl_stmt|;
name|SYMR
name|sym
decl_stmt|;
name|sym_ptr
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|debug_info
operator|->
name|external_sym
operator|+
operator|(
name|fdr_ptr
operator|->
name|isymBase
operator|+
literal|1
operator|)
operator|*
name|debug_swap
operator|->
name|external_sym_size
operator|)
expr_stmt|;
call|(
modifier|*
name|debug_swap
operator|->
name|swap_sym_in
call|)
argument_list|(
name|abfd
argument_list|,
name|sym_ptr
argument_list|,
operator|&
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|debug_info
operator|->
name|ss
operator|+
name|fdr_ptr
operator|->
name|issBase
operator|+
name|sym
operator|.
name|iss
argument_list|,
name|STABS_SYMBOL
argument_list|)
operator|==
literal|0
condition|)
name|stabs
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|stabs
condition|)
block|{
comment|/* eraxxon: There are at least two problems with this computation: 	     1) PDRs do *not* contain offsets but full vma's; and typically the 	     address of the first PDR is the address of the FDR, which will 	     make (most) of the results of the original computation 0! 	     2) Once in a wacky while, the Compaq compiler generated PDR 	     addresses do not equal the FDR vma, but they (the PDR address) 	     are still vma's and not offsets.  Cf. comments in 	     'lookup_line'.  */
comment|/* The address of the first PDR is the offset of that 	     procedure relative to the beginning of file FDR.  */
name|tab
operator|->
name|base_addr
operator|=
name|fdr_ptr
operator|->
name|adr
expr_stmt|;
block|}
else|else
block|{
comment|/* XXX I don't know about stabs, so this is a guess 	     (davidm@cs.arizona.edu).  */
name|tab
operator|->
name|base_addr
operator|=
name|fdr_ptr
operator|->
name|adr
expr_stmt|;
block|}
name|tab
operator|->
name|fdr
operator|=
name|fdr_ptr
expr_stmt|;
operator|++
name|tab
expr_stmt|;
block|}
comment|/* Finally, the table is sorted in increasing memory-address order.      The table is mostly sorted already, but there are cases (e.g.,      static functions in include files), where this does not hold.      Use "odump -PFv" to verify...  */
name|qsort
argument_list|(
operator|(
name|PTR
operator|)
name|line_info
operator|->
name|fdrtab
argument_list|,
operator|(
name|size_t
operator|)
name|len
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ecoff_fdrtab_entry
argument_list|)
argument_list|,
name|cmp_fdrtab_entry
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return index of first FDR that covers to OFFSET.  */
end_comment

begin_function
specifier|static
name|long
name|fdrtab_lookup
parameter_list|(
name|line_info
parameter_list|,
name|offset
parameter_list|)
name|struct
name|ecoff_find_line
modifier|*
name|line_info
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
block|{
name|long
name|low
decl_stmt|,
name|high
decl_stmt|,
name|len
decl_stmt|;
name|long
name|mid
init|=
operator|-
literal|1
decl_stmt|;
name|struct
name|ecoff_fdrtab_entry
modifier|*
name|tab
decl_stmt|;
name|len
operator|=
name|line_info
operator|->
name|fdrtab_len
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|tab
operator|=
name|line_info
operator|->
name|fdrtab
expr_stmt|;
for|for
control|(
name|low
operator|=
literal|0
operator|,
name|high
operator|=
name|len
operator|-
literal|1
init|;
name|low
operator|!=
name|high
condition|;
control|)
block|{
name|mid
operator|=
operator|(
name|high
operator|+
name|low
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|offset
operator|>=
name|tab
index|[
name|mid
index|]
operator|.
name|base_addr
operator|&&
name|offset
operator|<
name|tab
index|[
name|mid
operator|+
literal|1
index|]
operator|.
name|base_addr
condition|)
goto|goto
name|find_min
goto|;
if|if
condition|(
name|tab
index|[
name|mid
index|]
operator|.
name|base_addr
operator|>
name|offset
condition|)
name|high
operator|=
name|mid
expr_stmt|;
else|else
name|low
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
block|}
comment|/* eraxxon: at this point 'offset' is either lower than the lowest entry or      higher than the highest entry. In the former case high = low = mid = 0;      we want to return -1.  In the latter case, low = high and mid = low - 1;      we want to return the index of the highest entry.  Only in former case      will the following 'catch-all' test be true.  */
operator|++
name|mid
expr_stmt|;
comment|/* Last entry is catch-all for all higher addresses.  */
if|if
condition|(
name|offset
operator|<
name|tab
index|[
name|mid
index|]
operator|.
name|base_addr
condition|)
return|return
operator|-
literal|1
return|;
name|find_min
label|:
comment|/* eraxxon: There may be multiple FDRs in the table with the      same base_addr; make sure that we are at the first one.  */
while|while
condition|(
name|mid
operator|>
literal|0
operator|&&
name|tab
index|[
name|mid
operator|-
literal|1
index|]
operator|.
name|base_addr
operator|==
name|tab
index|[
name|mid
index|]
operator|.
name|base_addr
condition|)
operator|--
name|mid
expr_stmt|;
return|return
name|mid
return|;
block|}
end_function

begin_comment
comment|/* Look up a line given an address, storing the information in    LINE_INFO->cache.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|lookup_line
parameter_list|(
name|abfd
parameter_list|,
name|debug_info
parameter_list|,
name|debug_swap
parameter_list|,
name|line_info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|ecoff_debug_info
modifier|*
specifier|const
name|debug_info
decl_stmt|;
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
specifier|const
name|debug_swap
decl_stmt|;
name|struct
name|ecoff_find_line
modifier|*
name|line_info
decl_stmt|;
block|{
name|struct
name|ecoff_fdrtab_entry
modifier|*
name|tab
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
name|bfd_boolean
name|stabs
decl_stmt|;
name|FDR
modifier|*
name|fdr_ptr
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* eraxxon: note that 'offset' is the full vma, not a section offset.  */
name|offset
operator|=
name|line_info
operator|->
name|cache
operator|.
name|start
expr_stmt|;
comment|/* Build FDR table (sorted by object file's base-address) if we      don't have it already.  */
if|if
condition|(
name|line_info
operator|->
name|fdrtab
operator|==
name|NULL
operator|&&
operator|!
name|mk_fdrtab
argument_list|(
name|abfd
argument_list|,
name|debug_info
argument_list|,
name|debug_swap
argument_list|,
name|line_info
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|tab
operator|=
name|line_info
operator|->
name|fdrtab
expr_stmt|;
comment|/* Find first FDR for address OFFSET.  */
name|i
operator|=
name|fdrtab_lookup
argument_list|(
name|line_info
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
return|return
name|FALSE
return|;
comment|/* no FDR, no fun...  */
comment|/* eraxxon: 'fdrtab_lookup' doesn't give what we want, at least for Compaq's      C++ compiler 6.2.  Consider three FDRs with starting addresses of x, y,      and z, respectively, such that x< y< z.  Assume further that      y< 'offset'< z.  It is possible at times that the PDR for 'offset' is      associated with FDR x and *not* with FDR y.  Erg!!       From a binary dump of my C++ test case 'moo' using Compaq's coffobjanl      (output format has been edited for our purposes):       FDR [2]: (main.C): First instruction: 0x12000207c<x>        PDR [5] for File [2]: LoopTest__Xv<0x1200020a0> (a)        PDR [7] for File [2]: foo__Xv<0x120002168>      FDR [1]: (-1):     First instruction: 0x1200020e8<y>        PDR [3] for File [1]:<0x120001ad0> (b)      FDR [6]: (-1):     First instruction: 0x1200026f0<z>       (a) In the case of PDR5, the vma is such that the first few instructions      of the procedure can be found.  But since the size of this procedure is      160b, the vma will soon cross into the 'address space' of FDR1 and no      debugging info will be found.  How repugnant!       (b) It is also possible for a PDR to have a *lower* vma than its associated      FDR; see FDR1 and PDR3.  Gross!       Since the FDRs that are causing so much havok (in this case) 1) do not      describe actual files (fdr.rss == -1), and 2) contain only compiler      generated routines, I thought a simple fix would be to exclude them from      the FDR table in 'mk_fdrtab'.  But, besides not knowing for certain      whether this would be correct, it creates an additional problem.  If we      happen to ask for source file info on a compiler generated (procedure)      symbol -- which is still in the symbol table -- the result can be      information from a real procedure!  This is because compiler generated      procedures with vma's higher than the last FDR in the fdr table will be      associated with a PDR from this FDR, specifically the PDR with the      highest vma.  This wasn't a problem before, because each procedure had a      PDR.  (Yes, this problem could be eliminated if we kept the size of the      last PDR around, but things are already getting ugly).       Probably, a better solution would be to have a sorted PDR table.  Each      PDR would have a pointer to its FDR so file information could still be      obtained.  A FDR table could still be constructed if necessary -- since      it only contains pointers, not much extra memory would be used -- but      the PDR table would be searched to locate debugging info.       There is still at least one remaining issue.  Sometimes a FDR can have a      bogus name, but contain PDRs that should belong to another FDR with a      real name.  E.g:       FDR [3]: 0000000120001b50 (/home/.../Array.H~alt~deccxx_5E5A62AD)        PDR [a] for File [3]: 0000000120001b50        PDR [b] for File [3]: 0000000120001cf0        PDR [c] for File [3]: 0000000120001dc8        PDR [d] for File [3]: 0000000120001e40        PDR [e] for File [3]: 0000000120001eb8        PDR [f] for File [3]: 0000000120001f4c      FDR [4]: 0000000120001b50 (/home/.../Array.H)       Here, FDR4 has the correct name, but should (seemingly) contain PDRa-f.      The symbol table for PDR4 does contain symbols for PDRa-f, but so does      the symbol table for FDR3.  However the former is different; perhaps this      can be detected easily. (I'm not sure at this point.)  This problem only      seems to be associated with files with templates.  I am assuming the idea      is that there is a 'fake' FDR (with PDRs) for each differently typed set      of templates that must be generated.  Currently, FDR4 is completely      excluded from the FDR table in 'mk_fdrtab' because it contains no PDRs.       Since I don't have time to prepare a real fix for this right now, be      prepared for 'A Horrible Hack' to force the inspection of all non-stabs      FDRs.  It's coming...  */
name|fdr_ptr
operator|=
name|tab
index|[
name|i
index|]
operator|.
name|fdr
expr_stmt|;
comment|/* Check whether this file has stabs debugging information.  In a      file with stabs debugging information, the second local symbol is      named @stabs.  */
name|stabs
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|fdr_ptr
operator|->
name|csym
operator|>=
literal|2
condition|)
block|{
name|char
modifier|*
name|sym_ptr
decl_stmt|;
name|SYMR
name|sym
decl_stmt|;
name|sym_ptr
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|debug_info
operator|->
name|external_sym
operator|+
operator|(
name|fdr_ptr
operator|->
name|isymBase
operator|+
literal|1
operator|)
operator|*
name|debug_swap
operator|->
name|external_sym_size
operator|)
expr_stmt|;
call|(
modifier|*
name|debug_swap
operator|->
name|swap_sym_in
call|)
argument_list|(
name|abfd
argument_list|,
name|sym_ptr
argument_list|,
operator|&
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|debug_info
operator|->
name|ss
operator|+
name|fdr_ptr
operator|->
name|issBase
operator|+
name|sym
operator|.
name|iss
argument_list|,
name|STABS_SYMBOL
argument_list|)
operator|==
literal|0
condition|)
name|stabs
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|stabs
condition|)
block|{
name|bfd_size_type
name|external_pdr_size
decl_stmt|;
name|char
modifier|*
name|pdr_ptr
decl_stmt|;
name|char
modifier|*
name|best_pdr
init|=
name|NULL
decl_stmt|;
name|FDR
modifier|*
name|best_fdr
decl_stmt|;
name|bfd_signed_vma
name|best_dist
init|=
operator|-
literal|1
decl_stmt|;
name|PDR
name|pdr
decl_stmt|;
name|unsigned
name|char
modifier|*
name|line_ptr
decl_stmt|;
name|unsigned
name|char
modifier|*
name|line_end
decl_stmt|;
name|int
name|lineno
decl_stmt|;
comment|/* This file uses ECOFF debugging information.  Each FDR has a          list of procedure descriptors (PDR).  The address in the FDR          is the absolute address of the first procedure.  The address          in the first PDR gives the offset of that procedure relative          to the object file's base-address.  The addresses in          subsequent PDRs specify each procedure's address relative to          the object file's base-address.  To make things more juicy,          whenever the PROF bit in the PDR is set, the real entry point          of the procedure may be 16 bytes below what would normally be          the procedure's entry point.  Instead, DEC came up with a          wicked scheme to create profiled libraries "on the fly":          instead of shipping a regular and a profiled version of each          library, they insert 16 bytes of unused space in front of          each procedure and set the "prof" bit in the PDR to indicate          that there is a gap there (this is done automagically by "as"          when option "-pg" is specified).  Thus, normally, you link          against such a library and, except for lots of 16 byte gaps          between functions, things will behave as usual.  However,          when invoking "ld" with option "-pg", it will fill those gaps          with code that calls mcount().  It then moves the function's          entry point down by 16 bytes, and out pops a binary that has          all functions profiled.           NOTE: Neither FDRs nor PDRs are strictly sorted in memory                order.  For example, when including header-files that                define functions, the FDRs follow behind the including                file, even though their code may have been generated at                a lower address.  File coff-alpha.c from libbfd                illustrates this (use "odump -PFv" to look at a file's                FDR/PDR).  Similarly, PDRs are sometimes out of order                as well.  An example of this is OSF/1 v3.0 libc's                malloc.c.  I'm not sure why this happens, but it could                be due to optimizations that reorder a function's                position within an object-file.           Strategy:           On the first call to this function, we build a table of FDRs          that is sorted by the base-address of the object-file the FDR          is referring to.  Notice that each object-file may contain          code from multiple source files (e.g., due to code defined in          include files).  Thus, for any given base-address, there may          be multiple FDRs (but this case is, fortunately, uncommon).          lookup(addr) guarantees to return the first FDR that applies          to address ADDR.  Thus, after invoking lookup(), we have a          list of FDRs that may contain the PDR for ADDR.  Next, we          walk through the PDRs of these FDRs and locate the one that          is closest to ADDR (i.e., for which the difference between          ADDR and the PDR's entry point is positive and minimal).          Once, the right FDR and PDR are located, we simply walk          through the line-number table to lookup the line-number that          best matches ADDR.  Obviously, things could be sped up by          keeping a sorted list of PDRs instead of a sorted list of          FDRs.  However, this would increase space requirements          considerably, which is undesirable.  */
name|external_pdr_size
operator|=
name|debug_swap
operator|->
name|external_pdr_size
expr_stmt|;
comment|/* eraxxon: The Horrible Hack: Because of the problems above, set 'i' 	 to 0 so we look through all FDRs.  	 Because FDR's without any symbols are assumed to be non-stabs, 	 searching through all FDRs may cause the following code to try to 	 read stabs FDRs as ECOFF ones.  However, I don't think this will 	 harm anything.  */
name|i
operator|=
literal|0
expr_stmt|;
comment|/* Search FDR list starting at tab[i] for the PDR that best matches          OFFSET.  Normally, the FDR list is only one entry long.  */
name|best_fdr
operator|=
name|NULL
expr_stmt|;
do|do
block|{
comment|/* eraxxon: 'dist' and 'min_dist' can be negative now              because we iterate over every FDR rather than just ones              with a base address less than or equal to 'offset'.  */
name|bfd_signed_vma
name|dist
init|=
operator|-
literal|1
decl_stmt|,
name|min_dist
init|=
operator|-
literal|1
decl_stmt|;
name|char
modifier|*
name|pdr_hold
decl_stmt|;
name|char
modifier|*
name|pdr_end
decl_stmt|;
name|fdr_ptr
operator|=
name|tab
index|[
name|i
index|]
operator|.
name|fdr
expr_stmt|;
name|pdr_ptr
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|debug_info
operator|->
name|external_pdr
operator|+
name|fdr_ptr
operator|->
name|ipdFirst
operator|*
name|external_pdr_size
operator|)
expr_stmt|;
name|pdr_end
operator|=
name|pdr_ptr
operator|+
name|fdr_ptr
operator|->
name|cpd
operator|*
name|external_pdr_size
expr_stmt|;
call|(
modifier|*
name|debug_swap
operator|->
name|swap_pdr_in
call|)
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|pdr_ptr
argument_list|,
operator|&
name|pdr
argument_list|)
expr_stmt|;
comment|/* Find PDR that is closest to OFFSET.  If pdr.prof is set, 	     the procedure entry-point *may* be 0x10 below pdr.adr.  We 	     simply pretend that pdr.prof *implies* a lower entry-point. 	     This is safe because it just means that may identify 4 NOPs 	     in front of the function as belonging to the function.  */
for|for
control|(
name|pdr_hold
operator|=
name|NULL
init|;
name|pdr_ptr
operator|<
name|pdr_end
condition|;
operator|(
name|pdr_ptr
operator|+=
name|external_pdr_size
operator|,
call|(
modifier|*
name|debug_swap
operator|->
name|swap_pdr_in
call|)
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|pdr_ptr
argument_list|,
operator|&
name|pdr
argument_list|)
operator|)
control|)
block|{
if|if
condition|(
name|offset
operator|>=
operator|(
name|pdr
operator|.
name|adr
operator|-
literal|0x10
operator|*
name|pdr
operator|.
name|prof
operator|)
condition|)
block|{
name|dist
operator|=
name|offset
operator|-
operator|(
name|pdr
operator|.
name|adr
operator|-
literal|0x10
operator|*
name|pdr
operator|.
name|prof
operator|)
expr_stmt|;
comment|/* eraxxon: 'dist' can be negative now.  Note that                      'min_dist' can be negative if 'pdr_hold' below is NULL.  */
if|if
condition|(
operator|!
name|pdr_hold
operator|||
operator|(
name|dist
operator|>=
literal|0
operator|&&
name|dist
operator|<
name|min_dist
operator|)
condition|)
block|{
name|min_dist
operator|=
name|dist
expr_stmt|;
name|pdr_hold
operator|=
name|pdr_ptr
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|best_pdr
operator|||
operator|(
name|min_dist
operator|>=
literal|0
operator|&&
name|min_dist
operator|<
name|best_dist
operator|)
condition|)
block|{
name|best_dist
operator|=
operator|(
name|bfd_vma
operator|)
name|min_dist
expr_stmt|;
name|best_fdr
operator|=
name|fdr_ptr
expr_stmt|;
name|best_pdr
operator|=
name|pdr_hold
expr_stmt|;
block|}
comment|/* Continue looping until base_addr of next entry is different.  */
block|}
comment|/* eraxxon: We want to iterate over all FDRs. 	 See previous comment about 'fdrtab_lookup'.  */
do|while
condition|(
operator|++
name|i
operator|<
name|line_info
operator|->
name|fdrtab_len
condition|)
do|;
if|if
condition|(
operator|!
name|best_fdr
operator|||
operator|!
name|best_pdr
condition|)
return|return
name|FALSE
return|;
comment|/* Shouldn't happen...  */
comment|/* Phew, finally we got something that we can hold onto.  */
name|fdr_ptr
operator|=
name|best_fdr
expr_stmt|;
name|pdr_ptr
operator|=
name|best_pdr
expr_stmt|;
call|(
modifier|*
name|debug_swap
operator|->
name|swap_pdr_in
call|)
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|pdr_ptr
argument_list|,
operator|&
name|pdr
argument_list|)
expr_stmt|;
comment|/* Now we can look for the actual line number.  The line numbers          are stored in a very funky format, which I won't try to          describe.  The search is bounded by the end of the FDRs line          number entries.  */
name|line_end
operator|=
name|debug_info
operator|->
name|line
operator|+
name|fdr_ptr
operator|->
name|cbLineOffset
operator|+
name|fdr_ptr
operator|->
name|cbLine
expr_stmt|;
comment|/* Make offset relative to procedure entry.  */
name|offset
operator|-=
name|pdr
operator|.
name|adr
operator|-
literal|0x10
operator|*
name|pdr
operator|.
name|prof
expr_stmt|;
name|lineno
operator|=
name|pdr
operator|.
name|lnLow
expr_stmt|;
name|line_ptr
operator|=
name|debug_info
operator|->
name|line
operator|+
name|fdr_ptr
operator|->
name|cbLineOffset
operator|+
name|pdr
operator|.
name|cbLineOffset
expr_stmt|;
while|while
condition|(
name|line_ptr
operator|<
name|line_end
condition|)
block|{
name|int
name|delta
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
name|delta
operator|=
operator|*
name|line_ptr
operator|>>
literal|4
expr_stmt|;
if|if
condition|(
name|delta
operator|>=
literal|0x8
condition|)
name|delta
operator|-=
literal|0x10
expr_stmt|;
name|count
operator|=
operator|(
operator|*
name|line_ptr
operator|&
literal|0xf
operator|)
operator|+
literal|1
expr_stmt|;
operator|++
name|line_ptr
expr_stmt|;
if|if
condition|(
name|delta
operator|==
operator|-
literal|8
condition|)
block|{
name|delta
operator|=
operator|(
operator|(
operator|(
name|line_ptr
index|[
literal|0
index|]
operator|)
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
operator|+
operator|(
operator|(
name|line_ptr
index|[
literal|1
index|]
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
if|if
condition|(
name|delta
operator|>=
literal|0x8000
condition|)
name|delta
operator|-=
literal|0x10000
expr_stmt|;
name|line_ptr
operator|+=
literal|2
expr_stmt|;
block|}
name|lineno
operator|+=
name|delta
expr_stmt|;
if|if
condition|(
name|offset
operator|<
name|count
operator|*
literal|4
condition|)
block|{
name|line_info
operator|->
name|cache
operator|.
name|stop
operator|+=
name|count
operator|*
literal|4
operator|-
name|offset
expr_stmt|;
break|break;
block|}
name|offset
operator|-=
name|count
operator|*
literal|4
expr_stmt|;
block|}
comment|/* If fdr_ptr->rss is -1, then this file does not have full          symbols, at least according to gdb/mipsread.c.  */
if|if
condition|(
name|fdr_ptr
operator|->
name|rss
operator|==
operator|-
literal|1
condition|)
block|{
name|line_info
operator|->
name|cache
operator|.
name|filename
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|pdr
operator|.
name|isym
operator|==
operator|-
literal|1
condition|)
name|line_info
operator|->
name|cache
operator|.
name|functionname
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|EXTR
name|proc_ext
decl_stmt|;
call|(
modifier|*
name|debug_swap
operator|->
name|swap_ext_in
call|)
argument_list|(
name|abfd
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|debug_info
operator|->
name|external_ext
operator|+
name|pdr
operator|.
name|isym
operator|*
name|debug_swap
operator|->
name|external_ext_size
operator|)
argument_list|,
operator|&
name|proc_ext
argument_list|)
expr_stmt|;
name|line_info
operator|->
name|cache
operator|.
name|functionname
operator|=
operator|(
name|debug_info
operator|->
name|ssext
operator|+
name|proc_ext
operator|.
name|asym
operator|.
name|iss
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|SYMR
name|proc_sym
decl_stmt|;
name|line_info
operator|->
name|cache
operator|.
name|filename
operator|=
operator|(
name|debug_info
operator|->
name|ss
operator|+
name|fdr_ptr
operator|->
name|issBase
operator|+
name|fdr_ptr
operator|->
name|rss
operator|)
expr_stmt|;
call|(
modifier|*
name|debug_swap
operator|->
name|swap_sym_in
call|)
argument_list|(
name|abfd
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|debug_info
operator|->
name|external_sym
operator|+
operator|(
operator|(
name|fdr_ptr
operator|->
name|isymBase
operator|+
name|pdr
operator|.
name|isym
operator|)
operator|*
name|debug_swap
operator|->
name|external_sym_size
operator|)
operator|)
argument_list|,
operator|&
name|proc_sym
argument_list|)
expr_stmt|;
name|line_info
operator|->
name|cache
operator|.
name|functionname
operator|=
operator|(
name|debug_info
operator|->
name|ss
operator|+
name|fdr_ptr
operator|->
name|issBase
operator|+
name|proc_sym
operator|.
name|iss
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|lineno
operator|==
name|ilineNil
condition|)
name|lineno
operator|=
literal|0
expr_stmt|;
name|line_info
operator|->
name|cache
operator|.
name|line_num
operator|=
name|lineno
expr_stmt|;
block|}
else|else
block|{
name|bfd_size_type
name|external_sym_size
decl_stmt|;
specifier|const
name|char
modifier|*
name|directory_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|main_file_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|current_file_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|function_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|line_file_name
decl_stmt|;
name|bfd_vma
name|low_func_vma
decl_stmt|;
name|bfd_vma
name|low_line_vma
decl_stmt|;
name|bfd_boolean
name|past_line
decl_stmt|;
name|bfd_boolean
name|past_fn
decl_stmt|;
name|char
modifier|*
name|sym_ptr
decl_stmt|,
modifier|*
name|sym_ptr_end
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|funclen
decl_stmt|;
name|char
modifier|*
name|buffer
init|=
name|NULL
decl_stmt|;
comment|/* This file uses stabs debugging information.  When gcc is not 	 optimizing, it will put the line number information before 	 the function name stabs entry.  When gcc is optimizing, it 	 will put the stabs entry for all the function first, followed 	 by the line number information.  (This appears to happen 	 because of the two output files used by the -mgpopt switch, 	 which is implied by -O).  This means that we must keep 	 looking through the symbols until we find both a line number 	 and a function name which are beyond the address we want.  */
name|line_info
operator|->
name|cache
operator|.
name|filename
operator|=
name|NULL
expr_stmt|;
name|line_info
operator|->
name|cache
operator|.
name|functionname
operator|=
name|NULL
expr_stmt|;
name|line_info
operator|->
name|cache
operator|.
name|line_num
operator|=
literal|0
expr_stmt|;
name|directory_name
operator|=
name|NULL
expr_stmt|;
name|main_file_name
operator|=
name|NULL
expr_stmt|;
name|current_file_name
operator|=
name|NULL
expr_stmt|;
name|function_name
operator|=
name|NULL
expr_stmt|;
name|line_file_name
operator|=
name|NULL
expr_stmt|;
name|low_func_vma
operator|=
literal|0
expr_stmt|;
name|low_line_vma
operator|=
literal|0
expr_stmt|;
name|past_line
operator|=
name|FALSE
expr_stmt|;
name|past_fn
operator|=
name|FALSE
expr_stmt|;
name|external_sym_size
operator|=
name|debug_swap
operator|->
name|external_sym_size
expr_stmt|;
name|sym_ptr
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|debug_info
operator|->
name|external_sym
operator|+
operator|(
name|fdr_ptr
operator|->
name|isymBase
operator|+
literal|2
operator|)
operator|*
name|external_sym_size
operator|)
expr_stmt|;
name|sym_ptr_end
operator|=
name|sym_ptr
operator|+
operator|(
name|fdr_ptr
operator|->
name|csym
operator|-
literal|2
operator|)
operator|*
name|external_sym_size
expr_stmt|;
for|for
control|(
init|;
name|sym_ptr
operator|<
name|sym_ptr_end
operator|&&
operator|(
operator|!
name|past_line
operator|||
operator|!
name|past_fn
operator|)
condition|;
name|sym_ptr
operator|+=
name|external_sym_size
control|)
block|{
name|SYMR
name|sym
decl_stmt|;
call|(
modifier|*
name|debug_swap
operator|->
name|swap_sym_in
call|)
argument_list|(
name|abfd
argument_list|,
name|sym_ptr
argument_list|,
operator|&
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|ECOFF_IS_STAB
argument_list|(
operator|&
name|sym
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|ECOFF_UNMARK_STAB
argument_list|(
name|sym
operator|.
name|index
argument_list|)
condition|)
block|{
case|case
name|N_SO
case|:
name|main_file_name
operator|=
name|current_file_name
operator|=
name|debug_info
operator|->
name|ss
operator|+
name|fdr_ptr
operator|->
name|issBase
operator|+
name|sym
operator|.
name|iss
expr_stmt|;
comment|/* Check the next symbol to see if it is also an                      N_SO symbol.  */
if|if
condition|(
name|sym_ptr
operator|+
name|external_sym_size
operator|<
name|sym_ptr_end
condition|)
block|{
name|SYMR
name|nextsym
decl_stmt|;
call|(
modifier|*
name|debug_swap
operator|->
name|swap_sym_in
call|)
argument_list|(
name|abfd
argument_list|,
name|sym_ptr
operator|+
name|external_sym_size
argument_list|,
operator|&
name|nextsym
argument_list|)
expr_stmt|;
if|if
condition|(
name|ECOFF_IS_STAB
argument_list|(
operator|&
name|nextsym
argument_list|)
operator|&&
name|ECOFF_UNMARK_STAB
argument_list|(
name|nextsym
operator|.
name|index
argument_list|)
operator|==
name|N_SO
condition|)
block|{
name|directory_name
operator|=
name|current_file_name
expr_stmt|;
name|main_file_name
operator|=
name|current_file_name
operator|=
name|debug_info
operator|->
name|ss
operator|+
name|fdr_ptr
operator|->
name|issBase
operator|+
name|nextsym
operator|.
name|iss
expr_stmt|;
name|sym_ptr
operator|+=
name|external_sym_size
expr_stmt|;
block|}
block|}
break|break;
case|case
name|N_SOL
case|:
name|current_file_name
operator|=
name|debug_info
operator|->
name|ss
operator|+
name|fdr_ptr
operator|->
name|issBase
operator|+
name|sym
operator|.
name|iss
expr_stmt|;
break|break;
case|case
name|N_FUN
case|:
if|if
condition|(
name|sym
operator|.
name|value
operator|>
name|offset
condition|)
name|past_fn
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|sym
operator|.
name|value
operator|>=
name|low_func_vma
condition|)
block|{
name|low_func_vma
operator|=
name|sym
operator|.
name|value
expr_stmt|;
name|function_name
operator|=
name|debug_info
operator|->
name|ss
operator|+
name|fdr_ptr
operator|->
name|issBase
operator|+
name|sym
operator|.
name|iss
expr_stmt|;
block|}
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|sym
operator|.
name|st
operator|==
name|stLabel
operator|&&
name|sym
operator|.
name|index
operator|!=
name|indexNil
condition|)
block|{
if|if
condition|(
name|sym
operator|.
name|value
operator|>
name|offset
condition|)
name|past_line
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|sym
operator|.
name|value
operator|>=
name|low_line_vma
condition|)
block|{
name|low_line_vma
operator|=
name|sym
operator|.
name|value
expr_stmt|;
name|line_file_name
operator|=
name|current_file_name
expr_stmt|;
name|line_info
operator|->
name|cache
operator|.
name|line_num
operator|=
name|sym
operator|.
name|index
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|line_info
operator|->
name|cache
operator|.
name|line_num
operator|!=
literal|0
condition|)
name|main_file_name
operator|=
name|line_file_name
expr_stmt|;
comment|/* We need to remove the stuff after the colon in the function          name.  We also need to put the directory name and the file          name together.  */
if|if
condition|(
name|function_name
operator|==
name|NULL
condition|)
name|len
operator|=
name|funclen
operator|=
literal|0
expr_stmt|;
else|else
name|len
operator|=
name|funclen
operator|=
name|strlen
argument_list|(
name|function_name
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|main_file_name
operator|!=
name|NULL
operator|&&
name|directory_name
operator|!=
name|NULL
operator|&&
name|main_file_name
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
name|len
operator|+=
name|strlen
argument_list|(
name|directory_name
argument_list|)
operator|+
name|strlen
argument_list|(
name|main_file_name
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|line_info
operator|->
name|find_buffer
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|line_info
operator|->
name|find_buffer
argument_list|)
expr_stmt|;
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_malloc
argument_list|(
operator|(
name|bfd_size_type
operator|)
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|line_info
operator|->
name|find_buffer
operator|=
name|buffer
expr_stmt|;
block|}
if|if
condition|(
name|function_name
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|colon
decl_stmt|;
name|strcpy
argument_list|(
name|buffer
argument_list|,
name|function_name
argument_list|)
expr_stmt|;
name|colon
operator|=
name|strchr
argument_list|(
name|buffer
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|colon
operator|!=
name|NULL
condition|)
operator|*
name|colon
operator|=
literal|'\0'
expr_stmt|;
name|line_info
operator|->
name|cache
operator|.
name|functionname
operator|=
name|buffer
expr_stmt|;
block|}
if|if
condition|(
name|main_file_name
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|directory_name
operator|==
name|NULL
operator|||
name|main_file_name
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|line_info
operator|->
name|cache
operator|.
name|filename
operator|=
name|main_file_name
expr_stmt|;
else|else
block|{
name|sprintf
argument_list|(
name|buffer
operator|+
name|funclen
argument_list|,
literal|"%s%s"
argument_list|,
name|directory_name
argument_list|,
name|main_file_name
argument_list|)
expr_stmt|;
name|line_info
operator|->
name|cache
operator|.
name|filename
operator|=
name|buffer
operator|+
name|funclen
expr_stmt|;
block|}
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Do the work of find_nearest_line.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_ecoff_locate_line
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|offset
parameter_list|,
name|debug_info
parameter_list|,
name|debug_swap
parameter_list|,
name|line_info
parameter_list|,
name|filename_ptr
parameter_list|,
name|functionname_ptr
parameter_list|,
name|retline_ptr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
name|struct
name|ecoff_debug_info
modifier|*
specifier|const
name|debug_info
decl_stmt|;
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
specifier|const
name|debug_swap
decl_stmt|;
name|struct
name|ecoff_find_line
modifier|*
name|line_info
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|filename_ptr
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|functionname_ptr
decl_stmt|;
name|unsigned
name|int
modifier|*
name|retline_ptr
decl_stmt|;
block|{
name|offset
operator|+=
name|section
operator|->
name|vma
expr_stmt|;
if|if
condition|(
name|line_info
operator|->
name|cache
operator|.
name|sect
operator|==
name|NULL
operator|||
name|line_info
operator|->
name|cache
operator|.
name|sect
operator|!=
name|section
operator|||
name|offset
operator|<
name|line_info
operator|->
name|cache
operator|.
name|start
operator|||
name|offset
operator|>=
name|line_info
operator|->
name|cache
operator|.
name|stop
condition|)
block|{
name|line_info
operator|->
name|cache
operator|.
name|sect
operator|=
name|section
expr_stmt|;
name|line_info
operator|->
name|cache
operator|.
name|start
operator|=
name|offset
expr_stmt|;
name|line_info
operator|->
name|cache
operator|.
name|stop
operator|=
name|offset
expr_stmt|;
if|if
condition|(
operator|!
name|lookup_line
argument_list|(
name|abfd
argument_list|,
name|debug_info
argument_list|,
name|debug_swap
argument_list|,
name|line_info
argument_list|)
condition|)
block|{
name|line_info
operator|->
name|cache
operator|.
name|sect
operator|=
name|NULL
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
operator|*
name|filename_ptr
operator|=
name|line_info
operator|->
name|cache
operator|.
name|filename
expr_stmt|;
operator|*
name|functionname_ptr
operator|=
name|line_info
operator|->
name|cache
operator|.
name|functionname
expr_stmt|;
operator|*
name|retline_ptr
operator|=
name|line_info
operator|->
name|cache
operator|.
name|line_num
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* These routines copy symbolic information into a memory buffer.     FIXME: The whole point of the shuffle code is to avoid storing    everything in memory, since the linker is such a memory hog.  This    code makes that effort useless.  It is only called by the MIPS ELF    code when generating a shared library, so it is not that big a    deal, but it should be fixed eventually.  */
end_comment

begin_comment
comment|/* Collect a shuffle into a memory buffer.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_boolean
name|ecoff_collect_shuffle
name|PARAMS
argument_list|(
operator|(
expr|struct
name|shuffle
operator|*
operator|,
name|bfd_byte
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|bfd_boolean
name|ecoff_collect_shuffle
parameter_list|(
name|l
parameter_list|,
name|buff
parameter_list|)
name|struct
name|shuffle
modifier|*
name|l
decl_stmt|;
name|bfd_byte
modifier|*
name|buff
decl_stmt|;
block|{
name|unsigned
name|long
name|total
decl_stmt|;
name|total
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|l
operator|!=
operator|(
expr|struct
name|shuffle
operator|*
operator|)
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|l
operator|->
name|filep
condition|)
name|memcpy
argument_list|(
name|buff
argument_list|,
name|l
operator|->
name|u
operator|.
name|memory
argument_list|,
name|l
operator|->
name|size
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|bfd_seek
argument_list|(
name|l
operator|->
name|u
operator|.
name|file
operator|.
name|input_bfd
argument_list|,
name|l
operator|->
name|u
operator|.
name|file
operator|.
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|bfd_bread
argument_list|(
name|buff
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|l
operator|->
name|size
argument_list|,
name|l
operator|->
name|u
operator|.
name|file
operator|.
name|input_bfd
argument_list|)
operator|!=
name|l
operator|->
name|size
operator|)
condition|)
return|return
name|FALSE
return|;
block|}
name|total
operator|+=
name|l
operator|->
name|size
expr_stmt|;
name|buff
operator|+=
name|l
operator|->
name|size
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Copy PDR information into a memory buffer.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_ecoff_get_accumulated_pdr
parameter_list|(
name|handle
parameter_list|,
name|buff
parameter_list|)
name|PTR
name|handle
decl_stmt|;
name|bfd_byte
modifier|*
name|buff
decl_stmt|;
block|{
name|struct
name|accumulate
modifier|*
name|ainfo
init|=
operator|(
expr|struct
name|accumulate
operator|*
operator|)
name|handle
decl_stmt|;
return|return
name|ecoff_collect_shuffle
argument_list|(
name|ainfo
operator|->
name|pdr
argument_list|,
name|buff
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Copy symbol information into a memory buffer.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_ecoff_get_accumulated_sym
parameter_list|(
name|handle
parameter_list|,
name|buff
parameter_list|)
name|PTR
name|handle
decl_stmt|;
name|bfd_byte
modifier|*
name|buff
decl_stmt|;
block|{
name|struct
name|accumulate
modifier|*
name|ainfo
init|=
operator|(
expr|struct
name|accumulate
operator|*
operator|)
name|handle
decl_stmt|;
return|return
name|ecoff_collect_shuffle
argument_list|(
name|ainfo
operator|->
name|sym
argument_list|,
name|buff
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Copy the string table into a memory buffer.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_ecoff_get_accumulated_ss
parameter_list|(
name|handle
parameter_list|,
name|buff
parameter_list|)
name|PTR
name|handle
decl_stmt|;
name|bfd_byte
modifier|*
name|buff
decl_stmt|;
block|{
name|struct
name|accumulate
modifier|*
name|ainfo
init|=
operator|(
expr|struct
name|accumulate
operator|*
operator|)
name|handle
decl_stmt|;
name|struct
name|string_hash_entry
modifier|*
name|sh
decl_stmt|;
name|unsigned
name|long
name|total
decl_stmt|;
comment|/* The string table is written out from the hash table if this is a      final link.  */
name|BFD_ASSERT
argument_list|(
name|ainfo
operator|->
name|ss
operator|==
operator|(
expr|struct
name|shuffle
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|buff
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|total
operator|=
literal|1
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|ainfo
operator|->
name|ss_hash
operator|==
name|NULL
operator|||
name|ainfo
operator|->
name|ss_hash
operator|->
name|val
operator|==
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|sh
operator|=
name|ainfo
operator|->
name|ss_hash
init|;
name|sh
operator|!=
operator|(
expr|struct
name|string_hash_entry
operator|*
operator|)
name|NULL
condition|;
name|sh
operator|=
name|sh
operator|->
name|next
control|)
block|{
name|size_t
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|sh
operator|->
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buff
argument_list|,
operator|(
name|PTR
operator|)
name|sh
operator|->
name|root
operator|.
name|string
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|total
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
name|buff
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

end_unit

