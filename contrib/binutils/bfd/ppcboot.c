begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD back-end for PPCbug boot records.    Copyright 1996, 1997, 1998, 1999, 2000, 2001    Free Software Foundation, Inc.    Written by Michael Meissner, Cygnus Support,<meissner@cygnus.com>  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This is a BFD backend which may be used to write PowerPCBug boot objects.    It may only be used for output, not input.  The intention is that this may    be used as an output format for objcopy in order to generate raw binary    data.     This is very simple.  The only complication is that the real data    will start at some address X, and in some cases we will not want to    include X zeroes just to get to that point.  Since the start    address is not meaningful for this object file format, we use it    instead to indicate the number of zeroes to skip at the start of    the file.  objcopy cooperates by specially setting the start    address to zero by default.  */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_comment
comment|/* PPCbug location structure */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|ppcboot_location
block|{
name|bfd_byte
name|ind
decl_stmt|;
name|bfd_byte
name|head
decl_stmt|;
name|bfd_byte
name|sector
decl_stmt|;
name|bfd_byte
name|cylinder
decl_stmt|;
block|}
name|ppcboot_location_t
typedef|;
end_typedef

begin_comment
comment|/* PPCbug partition table layout */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|ppcboot_partition
block|{
name|ppcboot_location_t
name|partition_begin
decl_stmt|;
comment|/* partition begin */
name|ppcboot_location_t
name|partition_end
decl_stmt|;
comment|/* partition end */
name|bfd_byte
name|sector_begin
index|[
literal|4
index|]
decl_stmt|;
comment|/* 32-bit start RBA (zero-based), little endian */
name|bfd_byte
name|sector_length
index|[
literal|4
index|]
decl_stmt|;
comment|/* 32-bit RBA count (one-based), little endian */
block|}
name|ppcboot_partition_t
typedef|;
end_typedef

begin_comment
comment|/* PPCbug boot layout.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|ppcboot_hdr
block|{
name|bfd_byte
name|pc_compatibility
index|[
literal|446
index|]
decl_stmt|;
comment|/* x86 instruction field */
name|ppcboot_partition_t
name|partition
index|[
literal|4
index|]
decl_stmt|;
comment|/* partition information */
name|bfd_byte
name|signature
index|[
literal|2
index|]
decl_stmt|;
comment|/* 0x55 and 0xaa */
name|bfd_byte
name|entry_offset
index|[
literal|4
index|]
decl_stmt|;
comment|/* entry point offset, little endian */
name|bfd_byte
name|length
index|[
literal|4
index|]
decl_stmt|;
comment|/* load image length, little endian */
name|bfd_byte
name|flags
decl_stmt|;
comment|/* flag field */
name|bfd_byte
name|os_id
decl_stmt|;
comment|/* OS_ID */
name|char
name|partition_name
index|[
literal|32
index|]
decl_stmt|;
comment|/* partition name */
name|bfd_byte
name|reserved1
index|[
literal|470
index|]
decl_stmt|;
comment|/* reserved */
block|}
ifdef|#
directive|ifdef
name|__GNUC__
name|__attribute__
typedef|((
name|packed
typedef|))
endif|#
directive|endif
name|ppcboot_hdr_t
typedef|;
end_typedef

begin_comment
comment|/* Signature bytes for last 2 bytes of the 512 byte record */
end_comment

begin_define
define|#
directive|define
name|SIGNATURE0
value|0x55
end_define

begin_define
define|#
directive|define
name|SIGNATURE1
value|0xaa
end_define

begin_comment
comment|/* PowerPC boot type */
end_comment

begin_define
define|#
directive|define
name|PPC_IND
value|0x41
end_define

begin_comment
comment|/* Information needed for ppcboot header */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|ppcboot_data
block|{
name|ppcboot_hdr_t
name|header
decl_stmt|;
comment|/* raw header */
name|asection
modifier|*
name|sec
decl_stmt|;
comment|/* single section */
block|}
name|ppcboot_data_t
typedef|;
end_typedef

begin_comment
comment|/* Any bfd we create by reading a ppcboot file has three symbols:    a start symbol, an end symbol, and an absolute length symbol.  */
end_comment

begin_define
define|#
directive|define
name|PPCBOOT_SYMS
value|3
end_define

begin_decl_stmt
specifier|static
name|boolean
name|ppcboot_mkobject
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|bfd_target
modifier|*
name|ppcboot_object_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ppcboot_set_arch_mach
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|enum
name|bfd_architecture
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ppcboot_get_section_contents
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|,
name|file_ptr
operator|,
name|bfd_size_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|ppcboot_get_symtab_upper_bound
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|mangle_name
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|ppcboot_get_symtab
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asymbol
modifier|*
name|ppcboot_make_empty_symbol
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ppcboot_get_symbol_info
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|symbol_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ppcboot_set_section_contents
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|,
name|file_ptr
operator|,
name|bfd_size_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ppcboot_sizeof_headers
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ppcboot_bfd_print_private_bfd_data
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ppcboot_set_tdata
parameter_list|(
name|abfd
parameter_list|,
name|ptr
parameter_list|)
value|((abfd)->tdata.any = (PTR) (ptr))
end_define

begin_define
define|#
directive|define
name|ppcboot_get_tdata
parameter_list|(
name|abfd
parameter_list|)
value|((ppcboot_data_t *) ((abfd)->tdata.any))
end_define

begin_escape
end_escape

begin_comment
comment|/* Create a ppcboot object.  Invoked via bfd_set_format.  */
end_comment

begin_function
specifier|static
name|boolean
name|ppcboot_mkobject
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|ppcboot_get_tdata
argument_list|(
name|abfd
argument_list|)
condition|)
name|ppcboot_set_tdata
argument_list|(
name|abfd
argument_list|,
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|ppcboot_data_t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set the architecture to PowerPC */
end_comment

begin_function
specifier|static
name|boolean
name|ppcboot_set_arch_mach
parameter_list|(
name|abfd
parameter_list|,
name|arch
parameter_list|,
name|machine
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|enum
name|bfd_architecture
name|arch
decl_stmt|;
name|unsigned
name|long
name|machine
decl_stmt|;
block|{
if|if
condition|(
name|arch
operator|==
name|bfd_arch_unknown
condition|)
name|arch
operator|=
name|bfd_arch_powerpc
expr_stmt|;
elseif|else
if|if
condition|(
name|arch
operator|!=
name|bfd_arch_powerpc
condition|)
return|return
name|false
return|;
return|return
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|arch
argument_list|,
name|machine
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Any file may be considered to be a ppcboot file, provided the target    was not defaulted.  That is, it must be explicitly specified as    being ppcboot.  */
end_comment

begin_function
specifier|static
specifier|const
name|bfd_target
modifier|*
name|ppcboot_object_p
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|stat
name|statbuf
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|ppcboot_hdr_t
name|hdr
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|ppcboot_data_t
modifier|*
name|tdata
decl_stmt|;
name|BFD_ASSERT
argument_list|(
sizeof|sizeof
argument_list|(
name|ppcboot_hdr_t
argument_list|)
operator|==
literal|1024
argument_list|)
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|target_defaulted
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Find the file size.  */
if|if
condition|(
name|bfd_stat
argument_list|(
name|abfd
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|(
name|size_t
operator|)
name|statbuf
operator|.
name|st_size
operator|<
sizeof|sizeof
argument_list|(
name|ppcboot_hdr_t
argument_list|)
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_system_call
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Now do some basic checks.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|hdr
operator|.
name|pc_compatibility
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|hdr
operator|.
name|pc_compatibility
index|[
name|i
index|]
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|hdr
operator|.
name|signature
index|[
literal|0
index|]
operator|!=
name|SIGNATURE0
operator|||
name|hdr
operator|.
name|signature
index|[
literal|1
index|]
operator|!=
name|SIGNATURE1
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|hdr
operator|.
name|partition
index|[
literal|0
index|]
operator|.
name|partition_end
operator|.
name|ind
operator|!=
name|PPC_IND
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|abfd
operator|->
name|symcount
operator|=
name|PPCBOOT_SYMS
expr_stmt|;
comment|/* One data section.  */
name|sec
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".data"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|sec
operator|->
name|flags
operator|=
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_DATA
operator||
name|SEC_CODE
operator||
name|SEC_HAS_CONTENTS
expr_stmt|;
name|sec
operator|->
name|vma
operator|=
literal|0
expr_stmt|;
name|sec
operator|->
name|_raw_size
operator|=
name|statbuf
operator|.
name|st_size
operator|-
sizeof|sizeof
argument_list|(
name|ppcboot_hdr_t
argument_list|)
expr_stmt|;
name|sec
operator|->
name|filepos
operator|=
sizeof|sizeof
argument_list|(
name|ppcboot_hdr_t
argument_list|)
expr_stmt|;
name|ppcboot_mkobject
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|tdata
operator|=
name|ppcboot_get_tdata
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|tdata
operator|->
name|sec
operator|=
name|sec
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|tdata
operator|->
name|header
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|ppcboot_hdr_t
argument_list|)
argument_list|)
expr_stmt|;
name|ppcboot_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_powerpc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|abfd
operator|->
name|xvec
return|;
block|}
end_function

begin_define
define|#
directive|define
name|ppcboot_close_and_cleanup
value|_bfd_generic_close_and_cleanup
end_define

begin_define
define|#
directive|define
name|ppcboot_bfd_free_cached_info
value|_bfd_generic_bfd_free_cached_info
end_define

begin_define
define|#
directive|define
name|ppcboot_new_section_hook
value|_bfd_generic_new_section_hook
end_define

begin_escape
end_escape

begin_comment
comment|/* Get contents of the only section.  */
end_comment

begin_function
specifier|static
name|boolean
name|ppcboot_get_section_contents
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|location
parameter_list|,
name|offset
parameter_list|,
name|count
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|PTR
name|location
decl_stmt|;
name|file_ptr
name|offset
decl_stmt|;
name|bfd_size_type
name|count
decl_stmt|;
block|{
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|offset
operator|+
sizeof|sizeof
argument_list|(
name|ppcboot_hdr_t
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_read
argument_list|(
name|location
argument_list|,
literal|1
argument_list|,
name|count
argument_list|,
name|abfd
argument_list|)
operator|!=
name|count
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the amount of memory needed to read the symbol table.  */
end_comment

begin_function
specifier|static
name|long
name|ppcboot_get_symtab_upper_bound
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
name|PPCBOOT_SYMS
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create a symbol name based on the bfd's filename.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|mangle_name
parameter_list|(
name|abfd
parameter_list|,
name|suffix
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|char
modifier|*
name|suffix
decl_stmt|;
block|{
name|int
name|size
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|size
operator|=
operator|(
name|strlen
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
operator|+
name|strlen
argument_list|(
name|suffix
argument_list|)
operator|+
sizeof|sizeof
expr|"_ppcboot__"
operator|)
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
literal|""
return|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"_ppcboot_%s_%s"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
comment|/* Change any non-alphanumeric characters to underscores.  */
for|for
control|(
name|p
operator|=
name|buf
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|!
name|isalnum
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
argument_list|)
condition|)
operator|*
name|p
operator|=
literal|'_'
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the symbol table.  */
end_comment

begin_function
specifier|static
name|long
name|ppcboot_get_symtab
parameter_list|(
name|abfd
parameter_list|,
name|alocation
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|alocation
decl_stmt|;
block|{
name|asection
modifier|*
name|sec
init|=
name|ppcboot_get_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|sec
decl_stmt|;
name|asymbol
modifier|*
name|syms
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|syms
operator|=
operator|(
name|asymbol
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|PPCBOOT_SYMS
operator|*
sizeof|sizeof
argument_list|(
name|asymbol
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|syms
operator|==
name|NULL
condition|)
return|return
name|false
return|;
comment|/* Start symbol.  */
name|syms
index|[
literal|0
index|]
operator|.
name|the_bfd
operator|=
name|abfd
expr_stmt|;
name|syms
index|[
literal|0
index|]
operator|.
name|name
operator|=
name|mangle_name
argument_list|(
name|abfd
argument_list|,
literal|"start"
argument_list|)
expr_stmt|;
name|syms
index|[
literal|0
index|]
operator|.
name|value
operator|=
literal|0
expr_stmt|;
name|syms
index|[
literal|0
index|]
operator|.
name|flags
operator|=
name|BSF_GLOBAL
expr_stmt|;
name|syms
index|[
literal|0
index|]
operator|.
name|section
operator|=
name|sec
expr_stmt|;
name|syms
index|[
literal|0
index|]
operator|.
name|udata
operator|.
name|p
operator|=
name|NULL
expr_stmt|;
comment|/* End symbol.  */
name|syms
index|[
literal|1
index|]
operator|.
name|the_bfd
operator|=
name|abfd
expr_stmt|;
name|syms
index|[
literal|1
index|]
operator|.
name|name
operator|=
name|mangle_name
argument_list|(
name|abfd
argument_list|,
literal|"end"
argument_list|)
expr_stmt|;
name|syms
index|[
literal|1
index|]
operator|.
name|value
operator|=
name|sec
operator|->
name|_raw_size
expr_stmt|;
name|syms
index|[
literal|1
index|]
operator|.
name|flags
operator|=
name|BSF_GLOBAL
expr_stmt|;
name|syms
index|[
literal|1
index|]
operator|.
name|section
operator|=
name|sec
expr_stmt|;
name|syms
index|[
literal|1
index|]
operator|.
name|udata
operator|.
name|p
operator|=
name|NULL
expr_stmt|;
comment|/* Size symbol.  */
name|syms
index|[
literal|2
index|]
operator|.
name|the_bfd
operator|=
name|abfd
expr_stmt|;
name|syms
index|[
literal|2
index|]
operator|.
name|name
operator|=
name|mangle_name
argument_list|(
name|abfd
argument_list|,
literal|"size"
argument_list|)
expr_stmt|;
name|syms
index|[
literal|2
index|]
operator|.
name|value
operator|=
name|sec
operator|->
name|_raw_size
expr_stmt|;
name|syms
index|[
literal|2
index|]
operator|.
name|flags
operator|=
name|BSF_GLOBAL
expr_stmt|;
name|syms
index|[
literal|2
index|]
operator|.
name|section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
name|syms
index|[
literal|2
index|]
operator|.
name|udata
operator|.
name|p
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PPCBOOT_SYMS
condition|;
name|i
operator|++
control|)
operator|*
name|alocation
operator|++
operator|=
name|syms
operator|++
expr_stmt|;
operator|*
name|alocation
operator|=
name|NULL
expr_stmt|;
return|return
name|PPCBOOT_SYMS
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make an empty symbol.  */
end_comment

begin_function
specifier|static
name|asymbol
modifier|*
name|ppcboot_make_empty_symbol
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
return|return
operator|(
name|asymbol
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|asymbol
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|ppcboot_print_symbol
value|_bfd_nosymbols_print_symbol
end_define

begin_comment
comment|/* Get information about a symbol.  */
end_comment

begin_function
specifier|static
name|void
name|ppcboot_get_symbol_info
parameter_list|(
name|ignore_abfd
parameter_list|,
name|symbol
parameter_list|,
name|ret
parameter_list|)
name|bfd
modifier|*
name|ignore_abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|symbol_info
modifier|*
name|ret
decl_stmt|;
block|{
name|bfd_symbol_info
argument_list|(
name|symbol
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|ppcboot_bfd_is_local_label_name
value|bfd_generic_is_local_label_name
end_define

begin_define
define|#
directive|define
name|ppcboot_get_lineno
value|_bfd_nosymbols_get_lineno
end_define

begin_define
define|#
directive|define
name|ppcboot_find_nearest_line
value|_bfd_nosymbols_find_nearest_line
end_define

begin_define
define|#
directive|define
name|ppcboot_bfd_make_debug_symbol
value|_bfd_nosymbols_bfd_make_debug_symbol
end_define

begin_define
define|#
directive|define
name|ppcboot_read_minisymbols
value|_bfd_generic_read_minisymbols
end_define

begin_define
define|#
directive|define
name|ppcboot_minisymbol_to_symbol
value|_bfd_generic_minisymbol_to_symbol
end_define

begin_define
define|#
directive|define
name|ppcboot_get_reloc_upper_bound
define|\
value|((long (*) PARAMS ((bfd *, asection *))) bfd_0l)
end_define

begin_define
define|#
directive|define
name|ppcboot_canonicalize_reloc
define|\
value|((long (*) PARAMS ((bfd *, asection *, arelent **, asymbol **))) bfd_0l)
end_define

begin_define
define|#
directive|define
name|ppcboot_bfd_reloc_type_lookup
value|_bfd_norelocs_bfd_reloc_type_lookup
end_define

begin_escape
end_escape

begin_comment
comment|/* Write section contents of a ppcboot file.  */
end_comment

begin_function
specifier|static
name|boolean
name|ppcboot_set_section_contents
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|data
parameter_list|,
name|offset
parameter_list|,
name|size
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|file_ptr
name|offset
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|abfd
operator|->
name|output_has_begun
condition|)
block|{
name|bfd_vma
name|low
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
comment|/* The lowest section VMA sets the virtual address of the start          of the file.  We use the set the file position of all the          sections.  */
name|low
operator|=
name|abfd
operator|->
name|sections
operator|->
name|vma
expr_stmt|;
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
operator|->
name|next
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
if|if
condition|(
name|s
operator|->
name|vma
operator|<
name|low
condition|)
name|low
operator|=
name|s
operator|->
name|vma
expr_stmt|;
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
name|s
operator|->
name|filepos
operator|=
name|s
operator|->
name|vma
operator|-
name|low
expr_stmt|;
name|abfd
operator|->
name|output_has_begun
operator|=
name|true
expr_stmt|;
block|}
return|return
name|_bfd_generic_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|data
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|int
name|ppcboot_sizeof_headers
parameter_list|(
name|abfd
parameter_list|,
name|exec
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|boolean
name|exec
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
sizeof|sizeof
argument_list|(
name|ppcboot_hdr_t
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print out the program headers.  */
end_comment

begin_function
specifier|static
name|boolean
name|ppcboot_bfd_print_private_bfd_data
parameter_list|(
name|abfd
parameter_list|,
name|farg
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|farg
decl_stmt|;
block|{
name|FILE
modifier|*
name|f
init|=
operator|(
name|FILE
operator|*
operator|)
name|farg
decl_stmt|;
name|ppcboot_data_t
modifier|*
name|tdata
init|=
name|ppcboot_get_tdata
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|long
name|entry_offset
init|=
name|bfd_getl_signed_32
argument_list|(
operator|(
name|PTR
operator|)
name|tdata
operator|->
name|header
operator|.
name|entry_offset
argument_list|)
decl_stmt|;
name|long
name|length
init|=
name|bfd_getl_signed_32
argument_list|(
operator|(
name|PTR
operator|)
name|tdata
operator|->
name|header
operator|.
name|length
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
name|_
argument_list|(
literal|"\nppcboot header:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
name|_
argument_list|(
literal|"Entry offset        = 0x%.8lx (%ld)\n"
argument_list|)
argument_list|,
name|entry_offset
argument_list|,
name|entry_offset
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
name|_
argument_list|(
literal|"Length              = 0x%.8lx (%ld)\n"
argument_list|)
argument_list|,
name|length
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdata
operator|->
name|header
operator|.
name|flags
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
name|_
argument_list|(
literal|"Flag field          = 0x%.2x\n"
argument_list|)
argument_list|,
name|tdata
operator|->
name|header
operator|.
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdata
operator|->
name|header
operator|.
name|os_id
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"OS_ID               = 0x%.2x\n"
argument_list|,
name|tdata
operator|->
name|header
operator|.
name|os_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdata
operator|->
name|header
operator|.
name|partition_name
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
name|_
argument_list|(
literal|"Partition name      = \"%s\"\n"
argument_list|)
argument_list|,
name|tdata
operator|->
name|header
operator|.
name|partition_name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|long
name|sector_begin
init|=
name|bfd_getl_signed_32
argument_list|(
operator|(
name|PTR
operator|)
name|tdata
operator|->
name|header
operator|.
name|partition
index|[
name|i
index|]
operator|.
name|sector_begin
argument_list|)
decl_stmt|;
name|long
name|sector_length
init|=
name|bfd_getl_signed_32
argument_list|(
operator|(
name|PTR
operator|)
name|tdata
operator|->
name|header
operator|.
name|partition
index|[
name|i
index|]
operator|.
name|sector_length
argument_list|)
decl_stmt|;
comment|/* Skip all 0 entries */
if|if
condition|(
operator|!
name|tdata
operator|->
name|header
operator|.
name|partition
index|[
name|i
index|]
operator|.
name|partition_begin
operator|.
name|ind
operator|&&
operator|!
name|tdata
operator|->
name|header
operator|.
name|partition
index|[
name|i
index|]
operator|.
name|partition_begin
operator|.
name|head
operator|&&
operator|!
name|tdata
operator|->
name|header
operator|.
name|partition
index|[
name|i
index|]
operator|.
name|partition_begin
operator|.
name|sector
operator|&&
operator|!
name|tdata
operator|->
name|header
operator|.
name|partition
index|[
name|i
index|]
operator|.
name|partition_begin
operator|.
name|cylinder
operator|&&
operator|!
name|tdata
operator|->
name|header
operator|.
name|partition
index|[
name|i
index|]
operator|.
name|partition_end
operator|.
name|ind
operator|&&
operator|!
name|tdata
operator|->
name|header
operator|.
name|partition
index|[
name|i
index|]
operator|.
name|partition_end
operator|.
name|head
operator|&&
operator|!
name|tdata
operator|->
name|header
operator|.
name|partition
index|[
name|i
index|]
operator|.
name|partition_end
operator|.
name|sector
operator|&&
operator|!
name|tdata
operator|->
name|header
operator|.
name|partition
index|[
name|i
index|]
operator|.
name|partition_end
operator|.
name|cylinder
operator|&&
operator|!
name|sector_begin
operator|&&
operator|!
name|sector_length
condition|)
continue|continue;
name|fprintf
argument_list|(
name|f
argument_list|,
name|_
argument_list|(
literal|"\nPartition[%d] start  = { 0x%.2x, 0x%.2x, 0x%.2x, 0x%.2x }\n"
argument_list|)
argument_list|,
name|i
argument_list|,
name|tdata
operator|->
name|header
operator|.
name|partition
index|[
name|i
index|]
operator|.
name|partition_begin
operator|.
name|ind
argument_list|,
name|tdata
operator|->
name|header
operator|.
name|partition
index|[
name|i
index|]
operator|.
name|partition_begin
operator|.
name|head
argument_list|,
name|tdata
operator|->
name|header
operator|.
name|partition
index|[
name|i
index|]
operator|.
name|partition_begin
operator|.
name|sector
argument_list|,
name|tdata
operator|->
name|header
operator|.
name|partition
index|[
name|i
index|]
operator|.
name|partition_begin
operator|.
name|cylinder
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
name|_
argument_list|(
literal|"Partition[%d] end    = { 0x%.2x, 0x%.2x, 0x%.2x, 0x%.2x }\n"
argument_list|)
argument_list|,
name|i
argument_list|,
name|tdata
operator|->
name|header
operator|.
name|partition
index|[
name|i
index|]
operator|.
name|partition_end
operator|.
name|ind
argument_list|,
name|tdata
operator|->
name|header
operator|.
name|partition
index|[
name|i
index|]
operator|.
name|partition_end
operator|.
name|head
argument_list|,
name|tdata
operator|->
name|header
operator|.
name|partition
index|[
name|i
index|]
operator|.
name|partition_end
operator|.
name|sector
argument_list|,
name|tdata
operator|->
name|header
operator|.
name|partition
index|[
name|i
index|]
operator|.
name|partition_end
operator|.
name|cylinder
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
name|_
argument_list|(
literal|"Partition[%d] sector = 0x%.8lx (%ld)\n"
argument_list|)
argument_list|,
name|i
argument_list|,
name|sector_begin
argument_list|,
name|sector_begin
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
name|_
argument_list|(
literal|"Partition[%d] length = 0x%.8lx (%ld)\n"
argument_list|)
argument_list|,
name|i
argument_list|,
name|sector_length
argument_list|,
name|sector_length
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|ppcboot_bfd_get_relocated_section_contents
define|\
value|bfd_generic_get_relocated_section_contents
end_define

begin_define
define|#
directive|define
name|ppcboot_bfd_relax_section
value|bfd_generic_relax_section
end_define

begin_define
define|#
directive|define
name|ppcboot_bfd_gc_sections
value|bfd_generic_gc_sections
end_define

begin_define
define|#
directive|define
name|ppcboot_bfd_link_hash_table_create
value|_bfd_generic_link_hash_table_create
end_define

begin_define
define|#
directive|define
name|ppcboot_bfd_link_add_symbols
value|_bfd_generic_link_add_symbols
end_define

begin_define
define|#
directive|define
name|ppcboot_bfd_final_link
value|_bfd_generic_final_link
end_define

begin_define
define|#
directive|define
name|ppcboot_bfd_link_split_section
value|_bfd_generic_link_split_section
end_define

begin_define
define|#
directive|define
name|ppcboot_get_section_contents_in_window
define|\
value|_bfd_generic_get_section_contents_in_window
end_define

begin_define
define|#
directive|define
name|ppcboot_bfd_copy_private_bfd_data
value|_bfd_generic_bfd_copy_private_bfd_data
end_define

begin_define
define|#
directive|define
name|ppcboot_bfd_merge_private_bfd_data
value|_bfd_generic_bfd_merge_private_bfd_data
end_define

begin_define
define|#
directive|define
name|ppcboot_bfd_copy_private_section_data
value|_bfd_generic_bfd_copy_private_section_data
end_define

begin_define
define|#
directive|define
name|ppcboot_bfd_copy_private_symbol_data
value|_bfd_generic_bfd_copy_private_symbol_data
end_define

begin_define
define|#
directive|define
name|ppcboot_bfd_set_private_flags
value|_bfd_generic_bfd_set_private_flags
end_define

begin_define
define|#
directive|define
name|ppcboot_bfd_print_private_bfd_dat
value|ppcboot_bfd_print_private_bfd_data
end_define

begin_decl_stmt
specifier|const
name|bfd_target
name|ppcboot_vec
init|=
block|{
literal|"ppcboot"
block|,
comment|/* name */
name|bfd_target_unknown_flavour
block|,
comment|/* flavour */
name|BFD_ENDIAN_BIG
block|,
comment|/* byteorder is big endian for code */
name|BFD_ENDIAN_LITTLE
block|,
comment|/* header_byteorder */
name|EXEC_P
block|,
comment|/* object_flags */
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_READONLY
operator||
name|SEC_CODE
operator||
name|SEC_DATA
operator||
name|SEC_ROM
operator||
name|SEC_HAS_CONTENTS
operator|)
block|,
comment|/* section_flags */
literal|0
block|,
comment|/* symbol_leading_char */
literal|' '
block|,
comment|/* ar_pad_char */
literal|16
block|,
comment|/* ar_max_namelen */
name|bfd_getb64
block|,
name|bfd_getb_signed_64
block|,
name|bfd_putb64
block|,
name|bfd_getb32
block|,
name|bfd_getb_signed_32
block|,
name|bfd_putb32
block|,
name|bfd_getb16
block|,
name|bfd_getb_signed_16
block|,
name|bfd_putb16
block|,
comment|/* data */
name|bfd_getl64
block|,
name|bfd_getl_signed_64
block|,
name|bfd_putl64
block|,
name|bfd_getl32
block|,
name|bfd_getl_signed_32
block|,
name|bfd_putl32
block|,
name|bfd_getl16
block|,
name|bfd_getl_signed_16
block|,
name|bfd_putl16
block|,
comment|/* hdrs */
block|{
comment|/* bfd_check_format */
name|_bfd_dummy_target
block|,
name|ppcboot_object_p
block|,
comment|/* bfd_check_format */
name|_bfd_dummy_target
block|,
name|_bfd_dummy_target
block|,   }
block|,
block|{
comment|/* bfd_set_format */
name|bfd_false
block|,
name|ppcboot_mkobject
block|,
name|bfd_false
block|,
name|bfd_false
block|,   }
block|,
block|{
comment|/* bfd_write_contents */
name|bfd_false
block|,
name|bfd_true
block|,
name|bfd_false
block|,
name|bfd_false
block|,   }
block|,
name|BFD_JUMP_TABLE_GENERIC
argument_list|(
name|ppcboot
argument_list|)
block|,
name|BFD_JUMP_TABLE_COPY
argument_list|(
name|ppcboot
argument_list|)
block|,
name|BFD_JUMP_TABLE_CORE
argument_list|(
name|_bfd_nocore
argument_list|)
block|,
name|BFD_JUMP_TABLE_ARCHIVE
argument_list|(
name|_bfd_noarchive
argument_list|)
block|,
name|BFD_JUMP_TABLE_SYMBOLS
argument_list|(
name|ppcboot
argument_list|)
block|,
name|BFD_JUMP_TABLE_RELOCS
argument_list|(
name|ppcboot
argument_list|)
block|,
name|BFD_JUMP_TABLE_WRITE
argument_list|(
name|ppcboot
argument_list|)
block|,
name|BFD_JUMP_TABLE_LINK
argument_list|(
name|ppcboot
argument_list|)
block|,
name|BFD_JUMP_TABLE_DYNAMIC
argument_list|(
name|_bfd_nodynamic
argument_list|)
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

end_unit

