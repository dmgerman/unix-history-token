begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD back-end for HP/Intel IA-64 COFF files.    Copyright 1999, 2000, 2001, 2002, 2007 Free Software Foundation, Inc.    Contributed by David Mosberger<davidm@hpl.hp.com>  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"coff/ia64.h"
end_include

begin_include
include|#
directive|include
file|"coff/internal.h"
end_include

begin_include
include|#
directive|include
file|"coff/pe.h"
end_include

begin_include
include|#
directive|include
file|"libcoff.h"
end_include

begin_define
define|#
directive|define
name|COFF_DEFAULT_SECTION_ALIGNMENT_POWER
value|(2)
end_define

begin_comment
comment|/* The page size is a guess based on ELF.  */
end_comment

begin_define
define|#
directive|define
name|COFF_PAGE_SIZE
value|0x1000
end_define

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|howto_table
index|[]
init|=
block|{
name|EMPTY_HOWTO
argument_list|(
literal|0
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|BADMAG
parameter_list|(
name|x
parameter_list|)
value|IA64BADMAG(x)
end_define

begin_define
define|#
directive|define
name|IA64
value|1
end_define

begin_comment
comment|/* Customize coffcode.h */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|COFF_WITH_pep
end_ifdef

begin_undef
undef|#
directive|undef
name|AOUTSZ
end_undef

begin_define
define|#
directive|define
name|AOUTSZ
value|PEPAOUTSZ
end_define

begin_define
define|#
directive|define
name|PEAOUTHDR
value|PEPAOUTHDR
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|RTYPE2HOWTO
parameter_list|(
name|cache_ptr
parameter_list|,
name|dst
parameter_list|)
define|\
value|(cache_ptr)->howto = howto_table + (dst)->r_type;
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|COFF_WITH_PE
end_ifdef

begin_comment
comment|/* Return TRUE if this relocation should    appear in the output .reloc section.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_boolean
name|in_reloc_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|reloc_howto_type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|bfd_boolean
name|in_reloc_p
parameter_list|(
name|abfd
parameter_list|,
name|howto
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|FALSE
return|;
comment|/* We don't do relocs for now...  */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"coffcode.h"
end_include

begin_decl_stmt
specifier|static
specifier|const
name|bfd_target
modifier|*
name|ia64coff_object_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|const
name|bfd_target
modifier|*
name|ia64coff_object_p
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|COFF_IMAGE_WITH_PE
block|{
name|struct
name|external_PEI_DOS_hdr
name|dos_hdr
decl_stmt|;
name|struct
name|external_PEI_IMAGE_hdr
name|image_hdr
decl_stmt|;
name|file_ptr
name|offset
decl_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|bfd_bread
argument_list|(
operator|&
name|dos_hdr
argument_list|,
operator|(
name|bfd_size_type
operator|)
sizeof|sizeof
argument_list|(
name|dos_hdr
argument_list|)
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|dos_hdr
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_system_call
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* There are really two magic numbers involved; the magic number        that says this is a NT executable (PEI) and the magic number        that determines the architecture.  The former is DOSMAGIC,        stored in the e_magic field.  The latter is stored in the        f_magic field.  If the NT magic number isn't valid, the        architecture magic number could be mimicked by some other        field (specifically, the number of relocs in section 3).  Since        this routine can only be called correctly for a PEI file, check        the e_magic number here, and, if it doesn't match, clobber the        f_magic number so that we don't get a false match.  */
if|if
condition|(
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|dos_hdr
operator|.
name|e_magic
argument_list|)
operator|!=
name|DOSMAGIC
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|offset
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|dos_hdr
operator|.
name|e_lfanew
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|bfd_bread
argument_list|(
operator|&
name|image_hdr
argument_list|,
operator|(
name|bfd_size_type
operator|)
sizeof|sizeof
argument_list|(
name|image_hdr
argument_list|)
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|image_hdr
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_system_call
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|image_hdr
operator|.
name|nt_signature
argument_list|)
operator|!=
literal|0x4550
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Here is the hack.  coff_object_p wants to read filhsz bytes to        pick up the COFF header for PE, see "struct external_PEI_filehdr"        in include/coff/pe.h.  We adjust so that that will work. */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|offset
operator|-
sizeof|sizeof
argument_list|(
name|dos_hdr
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_system_call
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
endif|#
directive|endif
return|return
name|coff_object_p
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|const
name|bfd_target
ifdef|#
directive|ifdef
name|TARGET_SYM
name|TARGET_SYM
init|=
else|#
directive|else
name|ia64coff_vec
operator|=
endif|#
directive|endif
block|{
ifdef|#
directive|ifdef
name|TARGET_NAME
name|TARGET_NAME
block|,
else|#
directive|else
literal|"coff-ia64"
block|,
comment|/* name */
endif|#
directive|endif
name|bfd_target_coff_flavour
block|,
name|BFD_ENDIAN_LITTLE
block|,
comment|/* data byte order is little */
name|BFD_ENDIAN_LITTLE
block|,
comment|/* header byte order is little */
operator|(
name|HAS_RELOC
operator||
name|EXEC_P
operator||
comment|/* object flags */
name|HAS_LINENO
operator||
name|HAS_DEBUG
operator||
name|HAS_SYMS
operator||
name|HAS_LOCALS
operator||
name|WP_TEXT
operator||
name|D_PAGED
operator|)
block|,
ifndef|#
directive|ifndef
name|COFF_WITH_PE
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
comment|/* section flags */
operator||
name|SEC_CODE
operator||
name|SEC_DATA
operator|)
block|,
else|#
directive|else
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
comment|/* section flags */
operator||
name|SEC_CODE
operator||
name|SEC_DATA
operator||
name|SEC_LINK_ONCE
operator||
name|SEC_LINK_DUPLICATES
operator|)
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TARGET_UNDERSCORE
name|TARGET_UNDERSCORE
block|,
comment|/* leading underscore */
else|#
directive|else
literal|0
block|,
comment|/* leading underscore */
endif|#
directive|endif
literal|'/'
block|,
comment|/* ar_pad_char */
literal|15
block|,
comment|/* ar_max_namelen */
name|bfd_getl64
block|,
name|bfd_getl_signed_64
block|,
name|bfd_putl64
block|,
name|bfd_getl32
block|,
name|bfd_getl_signed_32
block|,
name|bfd_putl32
block|,
name|bfd_getl16
block|,
name|bfd_getl_signed_16
block|,
name|bfd_putl16
block|,
comment|/* data */
name|bfd_getl64
block|,
name|bfd_getl_signed_64
block|,
name|bfd_putl64
block|,
name|bfd_getl32
block|,
name|bfd_getl_signed_32
block|,
name|bfd_putl32
block|,
name|bfd_getl16
block|,
name|bfd_getl_signed_16
block|,
name|bfd_putl16
block|,
comment|/* hdrs */
comment|/* Note that we allow an object file to be treated as a core file as well.  */
block|{
name|_bfd_dummy_target
block|,
name|ia64coff_object_p
block|,
comment|/* bfd_check_format */
name|bfd_generic_archive_p
block|,
name|ia64coff_object_p
block|}
block|,
block|{
name|bfd_false
block|,
name|coff_mkobject
block|,
name|_bfd_generic_mkarchive
block|,
comment|/* bfd_set_format */
name|bfd_false
block|}
block|,
block|{
name|bfd_false
block|,
name|coff_write_object_contents
block|,
comment|/* bfd_write_contents */
name|_bfd_write_archive_contents
block|,
name|bfd_false
block|}
block|,
name|BFD_JUMP_TABLE_GENERIC
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_COPY
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_CORE
argument_list|(
name|_bfd_nocore
argument_list|)
block|,
name|BFD_JUMP_TABLE_ARCHIVE
argument_list|(
name|_bfd_archive_coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_SYMBOLS
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_RELOCS
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_WRITE
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_LINK
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_DYNAMIC
argument_list|(
name|_bfd_nodynamic
argument_list|)
block|,
name|NULL
block|,
name|COFF_SWAP_TABLE
block|}
decl_stmt|;
end_decl_stmt

end_unit

