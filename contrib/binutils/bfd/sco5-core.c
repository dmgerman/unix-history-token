begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD back end for SCO5 core files (U-area and raw sections)    Copyright 1998, 1999, 2000 Free Software Foundation, Inc.    Written by Jouke Numan<jnuman@hiscom.nl>  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"libaout.h"
end_include

begin_comment
comment|/* BFD a.out internal data structures */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_comment
comment|/* After a.out.h  */
end_comment

begin_include
include|#
directive|include
file|<sys/paccess.h>
end_include

begin_include
include|#
directive|include
file|<sys/region.h>
end_include

begin_struct
struct|struct
name|sco5_core_struct
block|{
name|struct
name|user
name|u
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* forward declarations */
end_comment

begin_decl_stmt
specifier|static
name|asection
modifier|*
name|make_bfd_asection
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|flagword
operator|,
name|bfd_size_type
operator|,
name|bfd_vma
operator|,
name|file_ptr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asymbol
modifier|*
name|sco5_core_make_empty_symbol
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|user
modifier|*
name|read_uarea
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|bfd_target
modifier|*
name|sco5_core_file_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|sco5_core_file_failing_command
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sco5_core_file_failing_signal
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|sco5_core_file_matches_executable_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|core_bfd
operator|,
name|bfd
operator|*
name|exec_bfd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|swap_abort
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|asection
modifier|*
name|make_bfd_asection
parameter_list|(
name|abfd
parameter_list|,
name|name
parameter_list|,
name|flags
parameter_list|,
name|_raw_size
parameter_list|,
name|vma
parameter_list|,
name|filepos
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
name|bfd_size_type
name|_raw_size
decl_stmt|;
name|bfd_vma
name|vma
decl_stmt|;
name|file_ptr
name|filepos
decl_stmt|;
block|{
name|asection
modifier|*
name|asect
decl_stmt|;
name|asect
operator|=
name|bfd_make_section_anyway
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|asect
condition|)
return|return
name|NULL
return|;
name|asect
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|asect
operator|->
name|_raw_size
operator|=
name|_raw_size
expr_stmt|;
name|asect
operator|->
name|vma
operator|=
name|vma
expr_stmt|;
name|asect
operator|->
name|filepos
operator|=
name|filepos
expr_stmt|;
name|asect
operator|->
name|alignment_power
operator|=
literal|2
expr_stmt|;
return|return
name|asect
return|;
block|}
end_function

begin_function
specifier|static
name|asymbol
modifier|*
name|sco5_core_make_empty_symbol
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|asymbol
modifier|*
name|new
init|=
operator|(
name|asymbol
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|asymbol
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|new
condition|)
name|new
operator|->
name|the_bfd
operator|=
name|abfd
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|user
modifier|*
name|read_uarea
parameter_list|(
name|abfd
parameter_list|,
name|filepos
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|int
name|filepos
decl_stmt|;
block|{
name|struct
name|sco5_core_struct
modifier|*
name|rawptr
decl_stmt|;
name|rawptr
operator|=
operator|(
operator|(
expr|struct
name|sco5_core_struct
operator|*
operator|)
name|bfd_zmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sco5_core_struct
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|rawptr
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|abfd
operator|->
name|tdata
operator|.
name|sco5_core_data
operator|=
name|rawptr
expr_stmt|;
if|if
condition|(
operator|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|filepos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|bfd_read
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|rawptr
operator|->
name|u
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
name|rawptr
operator|->
name|u
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
name|rawptr
operator|->
name|u
operator|)
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Sanity check perhaps??? */
if|if
condition|(
name|rawptr
operator|->
name|u
operator|.
name|u_dsize
operator|>
literal|0x1000000
condition|)
comment|/* Remember, it's in pages...  */
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|rawptr
operator|->
name|u
operator|.
name|u_ssize
operator|>
literal|0x1000000
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
operator|&
name|rawptr
operator|->
name|u
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|const
name|bfd_target
modifier|*
name|sco5_core_file_p
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|int
name|coffset_siz
decl_stmt|,
name|val
decl_stmt|,
name|nsecs
decl_stmt|,
name|cheadoffs
decl_stmt|;
name|int
name|coresize
decl_stmt|;
name|struct
name|user
modifier|*
name|u
decl_stmt|;
name|struct
name|coreoffsets
name|coffsets
decl_stmt|;
name|struct
name|coresecthead
name|chead
decl_stmt|;
name|char
modifier|*
name|secname
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
comment|/* Read coreoffsets region at end of core (see core(FP)) */
block|{
name|FILE
modifier|*
name|stream
init|=
name|bfd_cache_lookup
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
if|if
condition|(
name|stream
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|stream
argument_list|)
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|coresize
operator|=
name|statbuf
operator|.
name|st_size
expr_stmt|;
block|}
comment|/* Last long in core is sizeof struct coreoffsets, read it */
if|if
condition|(
operator|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|coresize
operator|-
sizeof|sizeof
name|coffset_siz
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|bfd_read
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|coffset_siz
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
name|coffset_siz
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
name|coffset_siz
operator|)
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Use it to seek start of coreoffsets region, read it and determine      validity */
if|if
condition|(
operator|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|coresize
operator|-
name|coffset_siz
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|bfd_read
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|coffsets
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
name|coffsets
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
name|coffsets
operator|)
operator|||
operator|(
operator|(
name|coffsets
operator|.
name|u_info
operator|!=
literal|1
operator|)
operator|&&
operator|(
name|coffsets
operator|.
name|u_info
operator|!=
name|C_VERSION
operator|)
operator|)
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|coffsets
operator|.
name|u_info
operator|==
literal|1
condition|)
block|{
comment|/* Old version, no section heads, read info from user struct */
name|u
operator|=
name|read_uarea
argument_list|(
name|abfd
argument_list|,
name|coffsets
operator|.
name|u_user
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|u
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|make_bfd_asection
argument_list|(
name|abfd
argument_list|,
literal|".reg"
argument_list|,
name|SEC_HAS_CONTENTS
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|coffsets
operator|.
name|u_usize
argument_list|,
literal|0
operator|-
operator|(
name|bfd_vma
operator|)
name|u
operator|->
name|u_ar0
argument_list|,
operator|(
name|file_ptr
operator|)
name|coffsets
operator|.
name|u_user
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|make_bfd_asection
argument_list|(
name|abfd
argument_list|,
literal|".data"
argument_list|,
name|SEC_ALLOC
operator|+
name|SEC_LOAD
operator|+
name|SEC_HAS_CONTENTS
argument_list|,
operator|(
operator|(
name|bfd_size_type
operator|)
name|u
operator|->
name|u_exdata
operator|.
name|ux_dsize
operator|+
name|u
operator|->
name|u_exdata
operator|.
name|ux_bsize
operator|)
argument_list|,
operator|(
name|bfd_vma
operator|)
name|u
operator|->
name|u_exdata
operator|.
name|ux_datorg
argument_list|,
operator|(
name|file_ptr
operator|)
name|coffsets
operator|.
name|u_data
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|make_bfd_asection
argument_list|(
name|abfd
argument_list|,
literal|".stack"
argument_list|,
name|SEC_ALLOC
operator|+
name|SEC_LOAD
operator|+
name|SEC_HAS_CONTENTS
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|u
operator|->
name|u_ssize
operator|*
name|NBPC
argument_list|,
operator|(
name|bfd_vma
operator|)
name|u
operator|->
name|u_sub
argument_list|,
operator|(
name|file_ptr
operator|)
name|coffsets
operator|.
name|u_stack
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|abfd
operator|->
name|xvec
return|;
comment|/* Done for version 1 */
block|}
comment|/* Immediately before coreoffsets region is a long with offset in core      to first coresecthead (CORES_OFFSETS), the long before this is the      number of section heads in the list. Read both longs and read the      coresecthead and check its validity */
if|if
condition|(
operator|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|coresize
operator|-
name|coffset_siz
operator|-
literal|2
operator|*
sizeof|sizeof
name|coffset_siz
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|bfd_read
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|nsecs
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
name|nsecs
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
name|nsecs
operator|)
operator|||
operator|(
name|bfd_read
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|cheadoffs
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
name|cheadoffs
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
name|cheadoffs
operator|)
operator|||
operator|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|cheadoffs
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|bfd_read
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|chead
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
name|chead
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
name|chead
operator|)
operator|||
operator|(
name|chead
operator|.
name|cs_stype
operator|!=
name|CORES_OFFSETS
operator|)
operator|||
operator|(
name|chead
operator|.
name|cs_x
operator|.
name|csx_magic
operator|!=
name|COREMAGIC_NUMBER
operator|)
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* OK, we believe you.  You're a core file (sure, sure).  */
comment|/* Now loop over all regions and map them */
name|nsecs
operator|--
expr_stmt|;
comment|/* We've seen CORES_OFFSETS already */
for|for
control|(
init|;
name|nsecs
condition|;
name|nsecs
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|chead
operator|.
name|cs_hseek
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|)
operator|||
name|bfd_read
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|chead
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
name|chead
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
name|chead
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
switch|switch
condition|(
name|chead
operator|.
name|cs_stype
condition|)
block|{
case|case
name|CORES_MAGIC
case|:
comment|/* Core header, check magic */
if|if
condition|(
name|chead
operator|.
name|cs_x
operator|.
name|csx_magic
operator|!=
name|COREMAGIC_NUMBER
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|secname
operator|=
name|NULL
expr_stmt|;
name|nsecs
operator|++
expr_stmt|;
comment|/* MAGIC not in section cnt!*/
break|break;
case|case
name|CORES_UAREA
case|:
comment|/* U-area, read in tdata */
name|u
operator|=
name|read_uarea
argument_list|(
name|abfd
argument_list|,
name|chead
operator|.
name|cs_sseek
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|u
condition|)
return|return
name|NULL
return|;
comment|/* This is tricky.  As the "register section", we give them 	     the entire upage and stack.  u.u_ar0 points to where 	     "register 0" is stored.  There are two tricks with this, 	     though.  One is that the rest of the registers might be 	     at positive or negative (or both) displacements from 	     *u_ar0.  The other is that u_ar0 is sometimes an absolute 	     address in kernel memory, and on other systems it is an 	     offset from the beginning of the `struct user'.  	     As a practical matter, we don't know where the registers 	     actually are, so we have to pass the whole area to GDB. 	     We encode the value of u_ar0 by setting the .regs section 	     up so that its virtual memory address 0 is at the place 	     pointed to by u_ar0 (by setting the vma of the start of 	     the section to -u_ar0).  GDB uses this info to locate the 	     regs, using minor trickery to get around the 	     offset-or-absolute-addr problem.  */
name|chead
operator|.
name|cs_vaddr
operator|=
literal|0
operator|-
operator|(
name|bfd_vma
operator|)
name|u
operator|->
name|u_ar0
expr_stmt|;
name|secname
operator|=
literal|".reg"
expr_stmt|;
name|flags
operator|=
name|SEC_HAS_CONTENTS
expr_stmt|;
break|break;
case|case
name|CORES_PREGION
case|:
comment|/* A program region, map it */
switch|switch
condition|(
name|chead
operator|.
name|cs_x
operator|.
name|csx_preg
operator|.
name|csxp_rtyp
condition|)
block|{
case|case
name|PT_DATA
case|:
name|secname
operator|=
literal|".data"
expr_stmt|;
comment|/* Data region.          */
break|break;
case|case
name|PT_STACK
case|:
name|secname
operator|=
literal|".stack"
expr_stmt|;
comment|/* Stack region.         */
break|break;
case|case
name|PT_SHMEM
case|:
name|secname
operator|=
literal|".shmem"
expr_stmt|;
comment|/* Shared memory         */
break|break;
case|case
name|PT_LIBDAT
case|:
name|secname
operator|=
literal|".libdat"
expr_stmt|;
comment|/* Shared library data   */
break|break;
case|case
name|PT_V86
case|:
name|secname
operator|=
literal|".virt86"
expr_stmt|;
comment|/* Virtual 8086 mode     */
break|break;
case|case
name|PT_SHFIL
case|:
name|secname
operator|=
literal|".mmfile"
expr_stmt|;
comment|/* Memory mapped file    */
break|break;
case|case
name|PT_XDATA0
case|:
name|secname
operator|=
literal|".Xdat0"
expr_stmt|;
comment|/* XENIX data region, virtual 0 */
break|break;
default|default:
name|secname
operator|=
literal|""
expr_stmt|;
block|}
name|flags
operator|=
name|SEC_ALLOC
operator|+
name|SEC_LOAD
operator|+
name|SEC_HAS_CONTENTS
expr_stmt|;
break|break;
case|case
name|CORES_PROC
case|:
comment|/* struct proc */
case|case
name|CORES_ITIMER
case|:
comment|/* interval timers */
case|case
name|CORES_SCOUTSNAME
case|:
comment|/* struct scoutsname */
name|secname
operator|=
name|NULL
expr_stmt|;
comment|/* Ignore these */
break|break;
default|default:
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"Unhandled SCO core file section type %d\n"
argument_list|,
name|chead
operator|.
name|cs_stype
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|secname
operator|&&
operator|!
name|make_bfd_asection
argument_list|(
name|abfd
argument_list|,
name|secname
argument_list|,
name|flags
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|chead
operator|.
name|cs_vsize
argument_list|,
operator|(
name|bfd_vma
operator|)
name|chead
operator|.
name|cs_vaddr
argument_list|,
operator|(
name|file_ptr
operator|)
name|chead
operator|.
name|cs_sseek
argument_list|)
condition|)
return|return
name|NULL
return|;
block|}
return|return
name|abfd
operator|->
name|xvec
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|sco5_core_file_failing_command
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|char
modifier|*
name|com
init|=
name|abfd
operator|->
name|tdata
operator|.
name|sco5_core_data
operator|->
name|u
operator|.
name|u_comm
decl_stmt|;
if|if
condition|(
operator|*
name|com
condition|)
return|return
name|com
return|;
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|sco5_core_file_failing_signal
parameter_list|(
name|ignore_abfd
parameter_list|)
name|bfd
modifier|*
name|ignore_abfd
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|ignore_abfd
operator|->
name|tdata
operator|.
name|sco5_core_data
operator|->
name|u
operator|.
name|u_sysabort
operator|!=
literal|0
operator|)
condition|?
name|ignore_abfd
operator|->
name|tdata
operator|.
name|sco5_core_data
operator|->
name|u
operator|.
name|u_sysabort
else|:
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|boolean
name|sco5_core_file_matches_executable_p
parameter_list|(
name|core_bfd
parameter_list|,
name|exec_bfd
parameter_list|)
name|bfd
modifier|*
name|core_bfd
decl_stmt|,
decl|*
name|exec_bfd
decl_stmt|;
end_function

begin_block
block|{
return|return
name|true
return|;
comment|/* FIXME, We have no way of telling at this point */
block|}
end_block

begin_define
define|#
directive|define
name|sco5_core_get_symtab_upper_bound
value|_bfd_nosymbols_get_symtab_upper_bound
end_define

begin_define
define|#
directive|define
name|sco5_core_get_symtab
value|_bfd_nosymbols_get_symtab
end_define

begin_define
define|#
directive|define
name|sco5_core_print_symbol
value|_bfd_nosymbols_print_symbol
end_define

begin_define
define|#
directive|define
name|sco5_core_get_symbol_info
value|_bfd_nosymbols_get_symbol_info
end_define

begin_define
define|#
directive|define
name|sco5_core_bfd_is_local_label_name
value|_bfd_nosymbols_bfd_is_local_label_name
end_define

begin_define
define|#
directive|define
name|sco5_core_get_lineno
value|_bfd_nosymbols_get_lineno
end_define

begin_define
define|#
directive|define
name|sco5_core_find_nearest_line
value|_bfd_nosymbols_find_nearest_line
end_define

begin_define
define|#
directive|define
name|sco5_core_bfd_make_debug_symbol
value|_bfd_nosymbols_bfd_make_debug_symbol
end_define

begin_define
define|#
directive|define
name|sco5_core_read_minisymbols
value|_bfd_nosymbols_read_minisymbols
end_define

begin_define
define|#
directive|define
name|sco5_core_minisymbol_to_symbol
value|_bfd_nosymbols_minisymbol_to_symbol
end_define

begin_comment
comment|/* If somebody calls any byte-swapping routines, shoot them.  */
end_comment

begin_function
specifier|static
name|void
name|swap_abort
parameter_list|()
block|{
name|abort
argument_list|()
expr_stmt|;
comment|/* This way doesn't require any declaration for ANSI to fuck up */
block|}
end_function

begin_define
define|#
directive|define
name|NO_GET
value|((bfd_vma (*) PARAMS ((   const bfd_byte *))) swap_abort )
end_define

begin_define
define|#
directive|define
name|NO_PUT
value|((void    (*) PARAMS ((bfd_vma, bfd_byte *))) swap_abort )
end_define

begin_define
define|#
directive|define
name|NO_SIGNED_GET
define|\
value|((bfd_signed_vma (*) PARAMS ((const bfd_byte *))) swap_abort )
end_define

begin_decl_stmt
specifier|const
name|bfd_target
name|sco5_core_vec
init|=
block|{
literal|"sco5-core"
block|,
name|bfd_target_unknown_flavour
block|,
name|BFD_ENDIAN_LITTLE
block|,
comment|/* target byte order */
name|BFD_ENDIAN_LITTLE
block|,
comment|/* target headers byte order */
operator|(
name|HAS_RELOC
operator||
name|EXEC_P
operator||
comment|/* object flags */
name|HAS_LINENO
operator||
name|HAS_DEBUG
operator||
name|HAS_SYMS
operator||
name|HAS_LOCALS
operator||
name|WP_TEXT
operator||
name|D_PAGED
operator|)
block|,
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator|)
block|,
comment|/* section flags */
literal|0
block|,
comment|/* symbol prefix */
literal|' '
block|,
comment|/* ar_pad_char */
literal|16
block|,
comment|/* ar_max_namelen */
name|NO_GET
block|,
name|NO_SIGNED_GET
block|,
name|NO_PUT
block|,
comment|/* 64 bit data */
name|NO_GET
block|,
name|NO_SIGNED_GET
block|,
name|NO_PUT
block|,
comment|/* 32 bit data */
name|NO_GET
block|,
name|NO_SIGNED_GET
block|,
name|NO_PUT
block|,
comment|/* 16 bit data */
name|NO_GET
block|,
name|NO_SIGNED_GET
block|,
name|NO_PUT
block|,
comment|/* 64 bit hdrs */
name|NO_GET
block|,
name|NO_SIGNED_GET
block|,
name|NO_PUT
block|,
comment|/* 32 bit hdrs */
name|NO_GET
block|,
name|NO_SIGNED_GET
block|,
name|NO_PUT
block|,
comment|/* 16 bit hdrs */
block|{
comment|/* bfd_check_format */
name|_bfd_dummy_target
block|,
comment|/* unknown format */
name|_bfd_dummy_target
block|,
comment|/* object file */
name|_bfd_dummy_target
block|,
comment|/* archive */
name|sco5_core_file_p
comment|/* a core file */
block|}
block|,
block|{
comment|/* bfd_set_format */
name|bfd_false
block|,
name|bfd_false
block|,
name|bfd_false
block|,
name|bfd_false
block|}
block|,
block|{
comment|/* bfd_write_contents */
name|bfd_false
block|,
name|bfd_false
block|,
name|bfd_false
block|,
name|bfd_false
block|}
block|,
name|BFD_JUMP_TABLE_GENERIC
argument_list|(
name|_bfd_generic
argument_list|)
block|,
name|BFD_JUMP_TABLE_COPY
argument_list|(
name|_bfd_generic
argument_list|)
block|,
name|BFD_JUMP_TABLE_CORE
argument_list|(
name|sco5
argument_list|)
block|,
name|BFD_JUMP_TABLE_ARCHIVE
argument_list|(
name|_bfd_noarchive
argument_list|)
block|,
name|BFD_JUMP_TABLE_SYMBOLS
argument_list|(
name|sco5_core
argument_list|)
block|,
name|BFD_JUMP_TABLE_RELOCS
argument_list|(
name|_bfd_norelocs
argument_list|)
block|,
name|BFD_JUMP_TABLE_WRITE
argument_list|(
name|_bfd_generic
argument_list|)
block|,
name|BFD_JUMP_TABLE_LINK
argument_list|(
name|_bfd_nolink
argument_list|)
block|,
name|BFD_JUMP_TABLE_DYNAMIC
argument_list|(
name|_bfd_nodynamic
argument_list|)
block|,
name|NULL
block|,
operator|(
name|PTR
operator|)
literal|0
comment|/* backend_data */
block|}
decl_stmt|;
end_decl_stmt

end_unit

