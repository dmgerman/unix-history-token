begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Alpha specific support for 64-bit ELF    Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004    Free Software Foundation, Inc.    Contributed by Richard Henderson<rth@tamu.edu>.     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* We need a published ABI spec for this.  Until one comes out, don't    assume this'll remain unchanged forever.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf/alpha.h"
end_include

begin_define
define|#
directive|define
name|ALPHAECOFF
end_define

begin_define
define|#
directive|define
name|NO_COFF_RELOCS
end_define

begin_define
define|#
directive|define
name|NO_COFF_SYMBOLS
end_define

begin_define
define|#
directive|define
name|NO_COFF_LINENOS
end_define

begin_comment
comment|/* Get the ECOFF swapping routines.  Needed for the debug information.  */
end_comment

begin_include
include|#
directive|include
file|"coff/internal.h"
end_include

begin_include
include|#
directive|include
file|"coff/sym.h"
end_include

begin_include
include|#
directive|include
file|"coff/symconst.h"
end_include

begin_include
include|#
directive|include
file|"coff/ecoff.h"
end_include

begin_include
include|#
directive|include
file|"coff/alpha.h"
end_include

begin_include
include|#
directive|include
file|"aout/ar.h"
end_include

begin_include
include|#
directive|include
file|"libcoff.h"
end_include

begin_include
include|#
directive|include
file|"libecoff.h"
end_include

begin_define
define|#
directive|define
name|ECOFF_64
end_define

begin_include
include|#
directive|include
file|"ecoffswap.h"
end_include

begin_decl_stmt
specifier|static
name|bfd_boolean
name|alpha_elf_dynamic_symbol_p
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|elf64_alpha_link_hash_newfunc
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|,
expr|struct
name|bfd_hash_table
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bfd_link_hash_table
modifier|*
name|elf64_alpha_bfd_link_hash_table_create
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|elf64_alpha_reloc_nil
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|elf64_alpha_reloc_bad
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|elf64_alpha_do_reloc_gpdisp
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd_vma
operator|,
name|bfd_byte
operator|*
operator|,
name|bfd_byte
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|elf64_alpha_reloc_gpdisp
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
modifier|*
name|elf64_alpha_bfd_reloc_type_lookup
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd_reloc_code_real_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|elf64_alpha_info_to_howto
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf64_alpha_mkobject
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf64_alpha_object_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf64_alpha_section_from_shdr
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf_Internal_Shdr
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf64_alpha_section_flags
name|PARAMS
argument_list|(
operator|(
name|flagword
operator|*
operator|,
name|Elf_Internal_Shdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf64_alpha_fake_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf_Internal_Shdr
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf64_alpha_create_got_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf64_alpha_create_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf64_alpha_read_ecoff_info
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
expr|struct
name|ecoff_debug_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf64_alpha_is_local_label_name
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf64_alpha_find_nearest_line
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|asymbol
operator|*
operator|*
operator|,
name|bfd_vma
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|unsigned
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|||
name|defined
argument_list|(
name|ALMOST_STDC
argument_list|)
end_if

begin_struct_decl
struct_decl|struct
name|alpha_elf_link_hash_entry
struct_decl|;
end_struct_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf64_alpha_output_extsym
name|PARAMS
argument_list|(
operator|(
expr|struct
name|alpha_elf_link_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf64_alpha_can_merge_gots
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|elf64_alpha_merge_gots
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf64_alpha_calc_got_offsets_for_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|alpha_elf_link_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|elf64_alpha_calc_got_offsets
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf64_alpha_size_got_sections
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf64_alpha_size_plt_section
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf64_alpha_size_plt_section_1
name|PARAMS
argument_list|(
operator|(
expr|struct
name|alpha_elf_link_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf64_alpha_always_size_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|alpha_dynamic_entries_for_reloc
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf64_alpha_calc_dynrel_sizes
name|PARAMS
argument_list|(
operator|(
expr|struct
name|alpha_elf_link_hash_entry
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf64_alpha_size_rela_got_section
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf64_alpha_size_rela_got_1
name|PARAMS
argument_list|(
operator|(
expr|struct
name|alpha_elf_link_hash_entry
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf64_alpha_add_symbol_hook
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|flagword
operator|*
operator|,
name|asection
operator|*
operator|*
operator|,
name|bfd_vma
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|alpha_elf_got_entry
modifier|*
name|get_got_entry
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|alpha_elf_link_hash_entry
operator|*
operator|,
name|unsigned
name|long
operator|,
name|unsigned
name|long
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf64_alpha_check_relocs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|asection
operator|*
name|sec
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf64_alpha_adjust_dynamic_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf64_alpha_size_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|elf64_alpha_emit_dynrel
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|asection
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_vma
operator|,
name|long
operator|,
name|long
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf64_alpha_relocate_section_r
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|,
name|asection
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf64_alpha_relocate_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|,
name|asection
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf64_alpha_finish_dynamic_symbol
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf64_alpha_finish_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf64_alpha_final_link
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf64_alpha_merge_ind_symbols
name|PARAMS
argument_list|(
operator|(
expr|struct
name|alpha_elf_link_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Elf_Internal_Rela
modifier|*
name|elf64_alpha_find_reloc_at_ofs
name|PARAMS
argument_list|(
operator|(
name|Elf_Internal_Rela
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
name|bfd_vma
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|elf_reloc_type_class
name|elf64_alpha_reloc_type_class
name|PARAMS
argument_list|(
operator|(
specifier|const
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_struct
struct|struct
name|alpha_elf_link_hash_entry
block|{
name|struct
name|elf_link_hash_entry
name|root
decl_stmt|;
comment|/* External symbol information.  */
name|EXTR
name|esym
decl_stmt|;
comment|/* Cumulative flags for all the .got entries.  */
name|int
name|flags
decl_stmt|;
comment|/* Contexts in which a literal was referenced.  */
define|#
directive|define
name|ALPHA_ELF_LINK_HASH_LU_ADDR
value|0x01
define|#
directive|define
name|ALPHA_ELF_LINK_HASH_LU_MEM
value|0x02
define|#
directive|define
name|ALPHA_ELF_LINK_HASH_LU_BYTE
value|0x04
define|#
directive|define
name|ALPHA_ELF_LINK_HASH_LU_JSR
value|0x08
define|#
directive|define
name|ALPHA_ELF_LINK_HASH_LU_TLSGD
value|0x10
define|#
directive|define
name|ALPHA_ELF_LINK_HASH_LU_TLSLDM
value|0x20
define|#
directive|define
name|ALPHA_ELF_LINK_HASH_LU_FUNC
value|0x38
define|#
directive|define
name|ALPHA_ELF_LINK_HASH_TLS_IE
value|0x40
define|#
directive|define
name|ALPHA_ELF_LINK_HASH_PLT_LOC
value|0x80
comment|/* Used to undo the localization of a plt symbol.  */
name|asection
modifier|*
name|plt_old_section
decl_stmt|;
name|bfd_vma
name|plt_old_value
decl_stmt|;
comment|/* Used to implement multiple .got subsections.  */
struct|struct
name|alpha_elf_got_entry
block|{
name|struct
name|alpha_elf_got_entry
modifier|*
name|next
decl_stmt|;
comment|/* Which .got subsection?  */
name|bfd
modifier|*
name|gotobj
decl_stmt|;
comment|/* The addend in effect for this entry.  */
name|bfd_vma
name|addend
decl_stmt|;
comment|/* The .got offset for this entry.  */
name|int
name|got_offset
decl_stmt|;
comment|/* How many references to this entry?  */
name|int
name|use_count
decl_stmt|;
comment|/* The relocation type of this entry.  */
name|unsigned
name|char
name|reloc_type
decl_stmt|;
comment|/* How a LITERAL is used.  */
name|unsigned
name|char
name|flags
decl_stmt|;
comment|/* Have we initialized the dynamic relocation for this entry?  */
name|unsigned
name|char
name|reloc_done
decl_stmt|;
comment|/* Have we adjusted this entry for SEC_MERGE?  */
name|unsigned
name|char
name|reloc_xlated
decl_stmt|;
block|}
modifier|*
name|got_entries
struct|;
comment|/* Used to count non-got, non-plt relocations for delayed sizing      of relocation sections.  */
struct|struct
name|alpha_elf_reloc_entry
block|{
name|struct
name|alpha_elf_reloc_entry
modifier|*
name|next
decl_stmt|;
comment|/* Which .reloc section? */
name|asection
modifier|*
name|srel
decl_stmt|;
comment|/* What kind of relocation? */
name|unsigned
name|int
name|rtype
decl_stmt|;
comment|/* Is this against read-only section? */
name|unsigned
name|int
name|reltext
range|:
literal|1
decl_stmt|;
comment|/* How many did we find?  */
name|unsigned
name|long
name|count
decl_stmt|;
block|}
modifier|*
name|reloc_entries
struct|;
block|}
struct|;
end_struct

begin_comment
comment|/* Alpha ELF linker hash table.  */
end_comment

begin_struct
struct|struct
name|alpha_elf_link_hash_table
block|{
name|struct
name|elf_link_hash_table
name|root
decl_stmt|;
comment|/* The head of a list of .got subsections linked through      alpha_elf_tdata(abfd)->got_link_next.  */
name|bfd
modifier|*
name|got_list
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Look up an entry in a Alpha ELF linker hash table.  */
end_comment

begin_define
define|#
directive|define
name|alpha_elf_link_hash_lookup
parameter_list|(
name|table
parameter_list|,
name|string
parameter_list|,
name|create
parameter_list|,
name|copy
parameter_list|,
name|follow
parameter_list|)
define|\
value|((struct alpha_elf_link_hash_entry *)					\    elf_link_hash_lookup (&(table)->root, (string), (create),		\ 			 (copy), (follow)))
end_define

begin_comment
comment|/* Traverse a Alpha ELF linker hash table.  */
end_comment

begin_define
define|#
directive|define
name|alpha_elf_link_hash_traverse
parameter_list|(
name|table
parameter_list|,
name|func
parameter_list|,
name|info
parameter_list|)
define|\
value|(elf_link_hash_traverse						\    (&(table)->root,							\     (bfd_boolean (*) PARAMS ((struct elf_link_hash_entry *, PTR))) (func), \     (info)))
end_define

begin_comment
comment|/* Get the Alpha ELF linker hash table from a link_info structure.  */
end_comment

begin_define
define|#
directive|define
name|alpha_elf_hash_table
parameter_list|(
name|p
parameter_list|)
define|\
value|((struct alpha_elf_link_hash_table *) ((p)->hash))
end_define

begin_comment
comment|/* Get the object's symbols as our own entry type.  */
end_comment

begin_define
define|#
directive|define
name|alpha_elf_sym_hashes
parameter_list|(
name|abfd
parameter_list|)
define|\
value|((struct alpha_elf_link_hash_entry **)elf_sym_hashes(abfd))
end_define

begin_comment
comment|/* Should we do dynamic things to this symbol?  This differs from the     generic version in that we never need to consider function pointer    equality wrt PLT entries -- we don't create a PLT entry if a symbol's    address is ever taken.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bfd_boolean
name|alpha_elf_dynamic_symbol_p
parameter_list|(
name|h
parameter_list|,
name|info
parameter_list|)
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
return|return
name|_bfd_elf_dynamic_symbol_p
argument_list|(
name|h
argument_list|,
name|info
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Create an entry in a Alpha ELF linker hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|elf64_alpha_link_hash_newfunc
parameter_list|(
name|entry
parameter_list|,
name|table
parameter_list|,
name|string
parameter_list|)
name|struct
name|bfd_hash_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|bfd_hash_table
modifier|*
name|table
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|struct
name|alpha_elf_link_hash_entry
modifier|*
name|ret
init|=
operator|(
expr|struct
name|alpha_elf_link_hash_entry
operator|*
operator|)
name|entry
decl_stmt|;
comment|/* Allocate the structure if it has not already been allocated by a      subclass.  */
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|alpha_elf_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
name|ret
operator|=
operator|(
operator|(
expr|struct
name|alpha_elf_link_hash_entry
operator|*
operator|)
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|alpha_elf_link_hash_entry
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|alpha_elf_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
comment|/* Call the allocation method of the superclass.  */
name|ret
operator|=
operator|(
operator|(
expr|struct
name|alpha_elf_link_hash_entry
operator|*
operator|)
name|_bfd_elf_link_hash_newfunc
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
operator|(
expr|struct
name|alpha_elf_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* Set local fields.  */
name|memset
argument_list|(
operator|&
name|ret
operator|->
name|esym
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|EXTR
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We use -2 as a marker to indicate that the information has 	 not been set.  -1 means there is no associated ifd.  */
name|ret
operator|->
name|esym
operator|.
name|ifd
operator|=
operator|-
literal|2
expr_stmt|;
name|ret
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|got_entries
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|reloc_entries
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Create a Alpha ELF linker hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_link_hash_table
modifier|*
name|elf64_alpha_bfd_link_hash_table_create
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|alpha_elf_link_hash_table
modifier|*
name|ret
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|alpha_elf_link_hash_table
argument_list|)
decl_stmt|;
name|ret
operator|=
operator|(
expr|struct
name|alpha_elf_link_hash_table
operator|*
operator|)
name|bfd_zmalloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|alpha_elf_link_hash_table
operator|*
operator|)
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|_bfd_elf_link_hash_table_init
argument_list|(
operator|&
name|ret
operator|->
name|root
argument_list|,
name|abfd
argument_list|,
name|elf64_alpha_link_hash_newfunc
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
operator|&
name|ret
operator|->
name|root
operator|.
name|root
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* We have some private fields hanging off of the elf_tdata structure.  */
end_comment

begin_struct
struct|struct
name|alpha_elf_obj_tdata
block|{
name|struct
name|elf_obj_tdata
name|root
decl_stmt|;
comment|/* For every input file, these are the got entries for that object's      local symbols.  */
name|struct
name|alpha_elf_got_entry
modifier|*
modifier|*
name|local_got_entries
decl_stmt|;
comment|/* For every input file, this is the object that owns the got that      this input file uses.  */
name|bfd
modifier|*
name|gotobj
decl_stmt|;
comment|/* For every got, this is a linked list through the objects using this got */
name|bfd
modifier|*
name|in_got_link_next
decl_stmt|;
comment|/* For every got, this is a link to the next got subsegment.  */
name|bfd
modifier|*
name|got_link_next
decl_stmt|;
comment|/* For every got, this is the section.  */
name|asection
modifier|*
name|got
decl_stmt|;
comment|/* For every got, this is it's total number of words.  */
name|int
name|total_got_size
decl_stmt|;
comment|/* For every got, this is the sum of the number of words required      to hold all of the member object's local got.  */
name|int
name|local_got_size
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|alpha_elf_tdata
parameter_list|(
name|abfd
parameter_list|)
define|\
value|((struct alpha_elf_obj_tdata *) (abfd)->tdata.any)
end_define

begin_function
specifier|static
name|bfd_boolean
name|elf64_alpha_mkobject
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|alpha_elf_obj_tdata
argument_list|)
decl_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|any
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|tdata
operator|.
name|any
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elf64_alpha_object_p
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
comment|/* Set the right machine number for an Alpha ELF file.  */
return|return
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_alpha
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* In case we're on a 32-bit machine, construct a 64-bit "-1" value    from smaller values.  Start with zero, widen, *then* decrement.  */
end_comment

begin_define
define|#
directive|define
name|MINUS_ONE
value|(((bfd_vma)0) - 1)
end_define

begin_define
define|#
directive|define
name|SKIP_HOWTO
parameter_list|(
name|N
parameter_list|)
define|\
value|HOWTO(N, 0, 0, 0, 0, 0, 0, elf64_alpha_reloc_bad, 0, 0, 0, 0, 0)
end_define

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|elf64_alpha_howto_table
index|[]
init|=
block|{
name|HOWTO
argument_list|(
name|R_ALPHA_NONE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|elf64_alpha_reloc_nil
argument_list|,
comment|/* special_function */
literal|"NONE"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 32 bit reference to a symbol.  */
name|HOWTO
argument_list|(
name|R_ALPHA_REFLONG
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"REFLONG"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 64 bit reference to a symbol.  */
name|HOWTO
argument_list|(
name|R_ALPHA_REFQUAD
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"REFQUAD"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
name|MINUS_ONE
argument_list|,
comment|/* src_mask */
name|MINUS_ONE
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 32 bit GP relative offset.  This is just like REFLONG except      that when the value is used the value of the gp register will be      added in.  */
name|HOWTO
argument_list|(
name|R_ALPHA_GPREL32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"GPREL32"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used for an instruction that refers to memory off the GP register.  */
name|HOWTO
argument_list|(
name|R_ALPHA_LITERAL
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"ELF_LITERAL"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* This reloc only appears immediately following an ELF_LITERAL reloc.      It identifies a use of the literal.  The symbol index is special:      1 means the literal address is in the base register of a memory      format instruction; 2 means the literal address is in the byte      offset register of a byte-manipulation instruction; 3 means the      literal address is in the target register of a jsr instruction.      This does not actually do any relocation.  */
name|HOWTO
argument_list|(
name|R_ALPHA_LITUSE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|elf64_alpha_reloc_nil
argument_list|,
comment|/* special_function */
literal|"LITUSE"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Load the gp register.  This is always used for a ldah instruction      which loads the upper 16 bits of the gp register.  The symbol      index of the GPDISP instruction is an offset in bytes to the lda      instruction that loads the lower 16 bits.  The value to use for      the relocation is the difference between the GP value and the      current location; the load will always be done against a register      holding the current address.       NOTE: Unlike ECOFF, partial in-place relocation is not done.  If      any offset is present in the instructions, it is an offset from      the register to the ldah instruction.  This lets us avoid any      stupid hackery like inventing a gp value to do partial relocation      against.  Also unlike ECOFF, we do the whole relocation off of      the GPDISP rather than a GPDISP_HI16/GPDISP_LO16 pair.  An odd,      space consuming bit, that, since all the information was present      in the GPDISP_HI16 reloc.  */
name|HOWTO
argument_list|(
name|R_ALPHA_GPDISP
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|elf64_alpha_reloc_gpdisp
argument_list|,
comment|/* special_function */
literal|"GPDISP"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 21 bit branch.  */
name|HOWTO
argument_list|(
name|R_ALPHA_BRADDR
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|21
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"BRADDR"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x1fffff
argument_list|,
comment|/* src_mask */
literal|0x1fffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A hint for a jump to a register.  */
name|HOWTO
argument_list|(
name|R_ALPHA_HINT
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|14
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"HINT"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x3fff
argument_list|,
comment|/* src_mask */
literal|0x3fff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16 bit PC relative offset.  */
name|HOWTO
argument_list|(
name|R_ALPHA_SREL16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"SREL16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 32 bit PC relative offset.  */
name|HOWTO
argument_list|(
name|R_ALPHA_SREL32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"SREL32"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 64 bit PC relative offset.  */
name|HOWTO
argument_list|(
name|R_ALPHA_SREL64
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"SREL64"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
name|MINUS_ONE
argument_list|,
comment|/* src_mask */
name|MINUS_ONE
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Skip 12 - 16; deprecated ECOFF relocs.  */
name|SKIP_HOWTO
argument_list|(
literal|12
argument_list|)
block|,
name|SKIP_HOWTO
argument_list|(
literal|13
argument_list|)
block|,
name|SKIP_HOWTO
argument_list|(
literal|14
argument_list|)
block|,
name|SKIP_HOWTO
argument_list|(
literal|15
argument_list|)
block|,
name|SKIP_HOWTO
argument_list|(
literal|16
argument_list|)
block|,
comment|/* The high 16 bits of the displacement from GP to the target.  */
name|HOWTO
argument_list|(
name|R_ALPHA_GPRELHIGH
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"GPRELHIGH"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The low 16 bits of the displacement from GP to the target.  */
name|HOWTO
argument_list|(
name|R_ALPHA_GPRELLOW
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"GPRELLOW"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 16-bit displacement from the GP to the target.  */
name|HOWTO
argument_list|(
name|R_ALPHA_GPREL16
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"GPREL16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Skip 20 - 23; deprecated ECOFF relocs.  */
name|SKIP_HOWTO
argument_list|(
literal|20
argument_list|)
block|,
name|SKIP_HOWTO
argument_list|(
literal|21
argument_list|)
block|,
name|SKIP_HOWTO
argument_list|(
literal|22
argument_list|)
block|,
name|SKIP_HOWTO
argument_list|(
literal|23
argument_list|)
block|,
comment|/* Misc ELF relocations.  */
comment|/* A dynamic relocation to copy the target into our .dynbss section.  */
comment|/* Not generated, as all Alpha objects use PIC, so it is not needed.  It      is present because every other ELF has one, but should not be used      because .dynbss is an ugly thing.  */
name|HOWTO
argument_list|(
name|R_ALPHA_COPY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"COPY"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|)
block|,
comment|/* A dynamic relocation for a .got entry.  */
name|HOWTO
argument_list|(
name|R_ALPHA_GLOB_DAT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"GLOB_DAT"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|)
block|,
comment|/* A dynamic relocation for a .plt entry.  */
name|HOWTO
argument_list|(
name|R_ALPHA_JMP_SLOT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"JMP_SLOT"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|)
block|,
comment|/* A dynamic relocation to add the base of the DSO to a 64-bit field.  */
name|HOWTO
argument_list|(
name|R_ALPHA_RELATIVE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"RELATIVE"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|)
block|,
comment|/* A 21 bit branch that adjusts for gp loads.  */
name|HOWTO
argument_list|(
name|R_ALPHA_BRSGP
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|21
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"BRSGP"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x1fffff
argument_list|,
comment|/* src_mask */
literal|0x1fffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Creates a tls_index for the symbol in the got.  */
name|HOWTO
argument_list|(
name|R_ALPHA_TLSGD
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"TLSGD"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Creates a tls_index for the (current) module in the got.  */
name|HOWTO
argument_list|(
name|R_ALPHA_TLSLDM
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"TLSLDM"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A dynamic relocation for a DTP module entry.  */
name|HOWTO
argument_list|(
name|R_ALPHA_DTPMOD64
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"DTPMOD64"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
name|MINUS_ONE
argument_list|,
comment|/* src_mask */
name|MINUS_ONE
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Creates a 64-bit offset in the got for the displacement      from DTP to the target.  */
name|HOWTO
argument_list|(
name|R_ALPHA_GOTDTPREL
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"GOTDTPREL"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A dynamic relocation for a displacement from DTP to the target.  */
name|HOWTO
argument_list|(
name|R_ALPHA_DTPREL64
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"DTPREL64"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
name|MINUS_ONE
argument_list|,
comment|/* src_mask */
name|MINUS_ONE
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The high 16 bits of the displacement from DTP to the target.  */
name|HOWTO
argument_list|(
name|R_ALPHA_DTPRELHI
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"DTPRELHI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The low 16 bits of the displacement from DTP to the target.  */
name|HOWTO
argument_list|(
name|R_ALPHA_DTPRELLO
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"DTPRELLO"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 16-bit displacement from DTP to the target.  */
name|HOWTO
argument_list|(
name|R_ALPHA_DTPREL16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"DTPREL16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Creates a 64-bit offset in the got for the displacement      from TP to the target.  */
name|HOWTO
argument_list|(
name|R_ALPHA_GOTTPREL
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"GOTTPREL"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A dynamic relocation for a displacement from TP to the target.  */
name|HOWTO
argument_list|(
name|R_ALPHA_TPREL64
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"TPREL64"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
name|MINUS_ONE
argument_list|,
comment|/* src_mask */
name|MINUS_ONE
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The high 16 bits of the displacement from TP to the target.  */
name|HOWTO
argument_list|(
name|R_ALPHA_TPRELHI
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"TPRELHI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The low 16 bits of the displacement from TP to the target.  */
name|HOWTO
argument_list|(
name|R_ALPHA_TPRELLO
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"TPRELLO"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 16-bit displacement from TP to the target.  */
name|HOWTO
argument_list|(
name|R_ALPHA_TPREL16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"TPREL16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A relocation function which doesn't do anything.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|elf64_alpha_reloc_nil
parameter_list|(
name|abfd
parameter_list|,
name|reloc
parameter_list|,
name|sym
parameter_list|,
name|data
parameter_list|,
name|sec
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|arelent
modifier|*
name|reloc
decl_stmt|;
name|asymbol
modifier|*
name|sym
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|PTR
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|output_bfd
condition|)
name|reloc
operator|->
name|address
operator|+=
name|sec
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_comment
comment|/* A relocation function used for an unsupported reloc.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|elf64_alpha_reloc_bad
parameter_list|(
name|abfd
parameter_list|,
name|reloc
parameter_list|,
name|sym
parameter_list|,
name|data
parameter_list|,
name|sec
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|arelent
modifier|*
name|reloc
decl_stmt|;
name|asymbol
modifier|*
name|sym
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|PTR
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|output_bfd
condition|)
name|reloc
operator|->
name|address
operator|+=
name|sec
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_notsupported
return|;
block|}
end_function

begin_comment
comment|/* Do the work of the GPDISP relocation.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|elf64_alpha_do_reloc_gpdisp
parameter_list|(
name|abfd
parameter_list|,
name|gpdisp
parameter_list|,
name|p_ldah
parameter_list|,
name|p_lda
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|bfd_vma
name|gpdisp
decl_stmt|;
name|bfd_byte
modifier|*
name|p_ldah
decl_stmt|;
name|bfd_byte
modifier|*
name|p_lda
decl_stmt|;
block|{
name|bfd_reloc_status_type
name|ret
init|=
name|bfd_reloc_ok
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|;
name|unsigned
name|long
name|i_ldah
decl_stmt|,
name|i_lda
decl_stmt|;
name|i_ldah
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|p_ldah
argument_list|)
expr_stmt|;
name|i_lda
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|p_lda
argument_list|)
expr_stmt|;
comment|/* Complain if the instructions are not correct.  */
if|if
condition|(
operator|(
operator|(
name|i_ldah
operator|>>
literal|26
operator|)
operator|&
literal|0x3f
operator|)
operator|!=
literal|0x09
operator|||
operator|(
operator|(
name|i_lda
operator|>>
literal|26
operator|)
operator|&
literal|0x3f
operator|)
operator|!=
literal|0x08
condition|)
name|ret
operator|=
name|bfd_reloc_dangerous
expr_stmt|;
comment|/* Extract the user-supplied offset, mirroring the sign extensions      that the instructions perform.  */
name|addend
operator|=
operator|(
operator|(
name|i_ldah
operator|&
literal|0xffff
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
name|i_lda
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|addend
operator|=
operator|(
name|addend
operator|^
literal|0x80008000
operator|)
operator|-
literal|0x80008000
expr_stmt|;
name|gpdisp
operator|+=
name|addend
expr_stmt|;
if|if
condition|(
operator|(
name|bfd_signed_vma
operator|)
name|gpdisp
operator|<
operator|-
operator|(
name|bfd_signed_vma
operator|)
literal|0x80000000
operator|||
operator|(
name|bfd_signed_vma
operator|)
name|gpdisp
operator|>=
operator|(
name|bfd_signed_vma
operator|)
literal|0x7fff8000
condition|)
name|ret
operator|=
name|bfd_reloc_overflow
expr_stmt|;
comment|/* compensate for the sign extension again.  */
name|i_ldah
operator|=
operator|(
operator|(
name|i_ldah
operator|&
literal|0xffff0000
operator|)
operator||
operator|(
operator|(
operator|(
name|gpdisp
operator|>>
literal|16
operator|)
operator|+
operator|(
operator|(
name|gpdisp
operator|>>
literal|15
operator|)
operator|&
literal|1
operator|)
operator|)
operator|&
literal|0xffff
operator|)
operator|)
expr_stmt|;
name|i_lda
operator|=
operator|(
name|i_lda
operator|&
literal|0xffff0000
operator|)
operator||
operator|(
name|gpdisp
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|i_ldah
argument_list|,
name|p_ldah
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|i_lda
argument_list|,
name|p_lda
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* The special function for the GPDISP reloc.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|elf64_alpha_reloc_gpdisp
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|sym
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|err_msg
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|sym
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|err_msg
decl_stmt|;
block|{
name|bfd_reloc_status_type
name|ret
decl_stmt|;
name|bfd_vma
name|gp
decl_stmt|,
name|relocation
decl_stmt|;
name|bfd_byte
modifier|*
name|p_ldah
decl_stmt|,
modifier|*
name|p_lda
decl_stmt|;
comment|/* Don't do anything if we're not doing a final link.  */
if|if
condition|(
name|output_bfd
condition|)
block|{
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
if|if
condition|(
name|reloc_entry
operator|->
name|address
operator|>
name|input_section
operator|->
name|_cooked_size
operator|||
name|reloc_entry
operator|->
name|address
operator|+
name|reloc_entry
operator|->
name|addend
operator|>
name|input_section
operator|->
name|_cooked_size
condition|)
return|return
name|bfd_reloc_outofrange
return|;
comment|/* The gp used in the portion of the output object to which this      input object belongs is cached on the input bfd.  */
name|gp
operator|=
name|_bfd_get_gp_value
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|relocation
operator|=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|reloc_entry
operator|->
name|address
operator|)
expr_stmt|;
name|p_ldah
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
expr_stmt|;
name|p_lda
operator|=
name|p_ldah
operator|+
name|reloc_entry
operator|->
name|addend
expr_stmt|;
name|ret
operator|=
name|elf64_alpha_do_reloc_gpdisp
argument_list|(
name|abfd
argument_list|,
name|gp
operator|-
name|relocation
argument_list|,
name|p_ldah
argument_list|,
name|p_lda
argument_list|)
expr_stmt|;
comment|/* Complain if the instructions are not correct.  */
if|if
condition|(
name|ret
operator|==
name|bfd_reloc_dangerous
condition|)
operator|*
name|err_msg
operator|=
name|_
argument_list|(
literal|"GPDISP relocation did not find ldah and lda instructions"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* A mapping from BFD reloc types to Alpha ELF reloc types.  */
end_comment

begin_struct
struct|struct
name|elf_reloc_map
block|{
name|bfd_reloc_code_real_type
name|bfd_reloc_val
decl_stmt|;
name|int
name|elf_reloc_val
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|elf_reloc_map
name|elf64_alpha_reloc_map
index|[]
init|=
block|{
block|{
name|BFD_RELOC_NONE
block|,
name|R_ALPHA_NONE
block|}
block|,
block|{
name|BFD_RELOC_32
block|,
name|R_ALPHA_REFLONG
block|}
block|,
block|{
name|BFD_RELOC_64
block|,
name|R_ALPHA_REFQUAD
block|}
block|,
block|{
name|BFD_RELOC_CTOR
block|,
name|R_ALPHA_REFQUAD
block|}
block|,
block|{
name|BFD_RELOC_GPREL32
block|,
name|R_ALPHA_GPREL32
block|}
block|,
block|{
name|BFD_RELOC_ALPHA_ELF_LITERAL
block|,
name|R_ALPHA_LITERAL
block|}
block|,
block|{
name|BFD_RELOC_ALPHA_LITUSE
block|,
name|R_ALPHA_LITUSE
block|}
block|,
block|{
name|BFD_RELOC_ALPHA_GPDISP
block|,
name|R_ALPHA_GPDISP
block|}
block|,
block|{
name|BFD_RELOC_23_PCREL_S2
block|,
name|R_ALPHA_BRADDR
block|}
block|,
block|{
name|BFD_RELOC_ALPHA_HINT
block|,
name|R_ALPHA_HINT
block|}
block|,
block|{
name|BFD_RELOC_16_PCREL
block|,
name|R_ALPHA_SREL16
block|}
block|,
block|{
name|BFD_RELOC_32_PCREL
block|,
name|R_ALPHA_SREL32
block|}
block|,
block|{
name|BFD_RELOC_64_PCREL
block|,
name|R_ALPHA_SREL64
block|}
block|,
block|{
name|BFD_RELOC_ALPHA_GPREL_HI16
block|,
name|R_ALPHA_GPRELHIGH
block|}
block|,
block|{
name|BFD_RELOC_ALPHA_GPREL_LO16
block|,
name|R_ALPHA_GPRELLOW
block|}
block|,
block|{
name|BFD_RELOC_GPREL16
block|,
name|R_ALPHA_GPREL16
block|}
block|,
block|{
name|BFD_RELOC_ALPHA_BRSGP
block|,
name|R_ALPHA_BRSGP
block|}
block|,
block|{
name|BFD_RELOC_ALPHA_TLSGD
block|,
name|R_ALPHA_TLSGD
block|}
block|,
block|{
name|BFD_RELOC_ALPHA_TLSLDM
block|,
name|R_ALPHA_TLSLDM
block|}
block|,
block|{
name|BFD_RELOC_ALPHA_DTPMOD64
block|,
name|R_ALPHA_DTPMOD64
block|}
block|,
block|{
name|BFD_RELOC_ALPHA_GOTDTPREL16
block|,
name|R_ALPHA_GOTDTPREL
block|}
block|,
block|{
name|BFD_RELOC_ALPHA_DTPREL64
block|,
name|R_ALPHA_DTPREL64
block|}
block|,
block|{
name|BFD_RELOC_ALPHA_DTPREL_HI16
block|,
name|R_ALPHA_DTPRELHI
block|}
block|,
block|{
name|BFD_RELOC_ALPHA_DTPREL_LO16
block|,
name|R_ALPHA_DTPRELLO
block|}
block|,
block|{
name|BFD_RELOC_ALPHA_DTPREL16
block|,
name|R_ALPHA_DTPREL16
block|}
block|,
block|{
name|BFD_RELOC_ALPHA_GOTTPREL16
block|,
name|R_ALPHA_GOTTPREL
block|}
block|,
block|{
name|BFD_RELOC_ALPHA_TPREL64
block|,
name|R_ALPHA_TPREL64
block|}
block|,
block|{
name|BFD_RELOC_ALPHA_TPREL_HI16
block|,
name|R_ALPHA_TPRELHI
block|}
block|,
block|{
name|BFD_RELOC_ALPHA_TPREL_LO16
block|,
name|R_ALPHA_TPRELLO
block|}
block|,
block|{
name|BFD_RELOC_ALPHA_TPREL16
block|,
name|R_ALPHA_TPREL16
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Given a BFD reloc type, return a HOWTO structure.  */
end_comment

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|elf64_alpha_bfd_reloc_type_lookup
parameter_list|(
name|abfd
parameter_list|,
name|code
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
block|{
specifier|const
name|struct
name|elf_reloc_map
modifier|*
name|i
decl_stmt|,
modifier|*
name|e
decl_stmt|;
name|i
operator|=
name|e
operator|=
name|elf64_alpha_reloc_map
expr_stmt|;
name|e
operator|+=
sizeof|sizeof
argument_list|(
name|elf64_alpha_reloc_map
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|elf_reloc_map
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|->
name|bfd_reloc_val
operator|==
name|code
condition|)
return|return
operator|&
name|elf64_alpha_howto_table
index|[
name|i
operator|->
name|elf_reloc_val
index|]
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Given an Alpha ELF reloc type, fill in an arelent structure.  */
end_comment

begin_function
specifier|static
name|void
name|elf64_alpha_info_to_howto
parameter_list|(
name|abfd
parameter_list|,
name|cache_ptr
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|arelent
modifier|*
name|cache_ptr
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|dst
decl_stmt|;
block|{
name|unsigned
name|r_type
decl_stmt|;
name|r_type
operator|=
name|ELF64_R_TYPE
argument_list|(
name|dst
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|r_type
operator|<
operator|(
name|unsigned
name|int
operator|)
name|R_ALPHA_max
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|howto
operator|=
operator|&
name|elf64_alpha_howto_table
index|[
name|r_type
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* These two relocations create a two-word entry in the got.  */
end_comment

begin_define
define|#
directive|define
name|alpha_got_entry_size
parameter_list|(
name|r_type
parameter_list|)
define|\
value|(r_type == R_ALPHA_TLSGD || r_type == R_ALPHA_TLSLDM ? 16 : 8)
end_define

begin_comment
comment|/* This is PT_TLS segment p_vaddr.  */
end_comment

begin_define
define|#
directive|define
name|alpha_get_dtprel_base
parameter_list|(
name|info
parameter_list|)
define|\
value|(elf_hash_table (info)->tls_sec->vma)
end_define

begin_comment
comment|/* Main program TLS (whose template starts at PT_TLS p_vaddr)    is assigned offset round(16, PT_TLS p_align).  */
end_comment

begin_define
define|#
directive|define
name|alpha_get_tprel_base
parameter_list|(
name|info
parameter_list|)
define|\
value|(elf_hash_table (info)->tls_sec->vma					\    - align_power ((bfd_vma) 16,						\ 		  elf_hash_table (info)->tls_sec->alignment_power))
end_define

begin_escape
end_escape

begin_comment
comment|/* These functions do relaxation for Alpha ELF.     Currently I'm only handling what I can do with existing compiler    and assembler support, which means no instructions are removed,    though some may be nopped.  At this time GCC does not emit enough    information to do all of the relaxing that is possible.  It will    take some not small amount of work for that to happen.     There are a couple of interesting papers that I once read on this    subject, that I cannot find references to at the moment, that    related to Alpha in particular.  They are by David Wall, then of    DEC WRL.  */
end_comment

begin_define
define|#
directive|define
name|OP_LDA
value|0x08
end_define

begin_define
define|#
directive|define
name|OP_LDAH
value|0x09
end_define

begin_define
define|#
directive|define
name|INSN_JSR
value|0x68004000
end_define

begin_define
define|#
directive|define
name|INSN_JSR_MASK
value|0xfc00c000
end_define

begin_define
define|#
directive|define
name|OP_LDQ
value|0x29
end_define

begin_define
define|#
directive|define
name|OP_BR
value|0x30
end_define

begin_define
define|#
directive|define
name|OP_BSR
value|0x34
end_define

begin_define
define|#
directive|define
name|INSN_UNOP
value|0x2ffe0000
end_define

begin_define
define|#
directive|define
name|INSN_ADDQ
value|0x40000400
end_define

begin_define
define|#
directive|define
name|INSN_RDUNIQ
value|0x0000009e
end_define

begin_struct
struct|struct
name|alpha_relax_info
block|{
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|,
modifier|*
name|relend
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|link_info
decl_stmt|;
name|bfd_vma
name|gp
decl_stmt|;
name|bfd
modifier|*
name|gotobj
decl_stmt|;
name|asection
modifier|*
name|tsec
decl_stmt|;
name|struct
name|alpha_elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|alpha_elf_got_entry
modifier|*
modifier|*
name|first_gotent
decl_stmt|;
name|struct
name|alpha_elf_got_entry
modifier|*
name|gotent
decl_stmt|;
name|bfd_boolean
name|changed_contents
decl_stmt|;
name|bfd_boolean
name|changed_relocs
decl_stmt|;
name|unsigned
name|char
name|other
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf64_alpha_relax_with_lituse
name|PARAMS
argument_list|(
operator|(
expr|struct
name|alpha_relax_info
operator|*
name|info
operator|,
name|bfd_vma
name|symval
operator|,
name|Elf_Internal_Rela
operator|*
name|irel
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|elf64_alpha_relax_opt_call
name|PARAMS
argument_list|(
operator|(
expr|struct
name|alpha_relax_info
operator|*
name|info
operator|,
name|bfd_vma
name|symval
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf64_alpha_relax_got_load
name|PARAMS
argument_list|(
operator|(
expr|struct
name|alpha_relax_info
operator|*
name|info
operator|,
name|bfd_vma
name|symval
operator|,
name|Elf_Internal_Rela
operator|*
name|irel
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf64_alpha_relax_gprelhilo
name|PARAMS
argument_list|(
operator|(
expr|struct
name|alpha_relax_info
operator|*
name|info
operator|,
name|bfd_vma
name|symval
operator|,
name|Elf_Internal_Rela
operator|*
name|irel
operator|,
name|bfd_boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf64_alpha_relax_tls_get_addr
name|PARAMS
argument_list|(
operator|(
expr|struct
name|alpha_relax_info
operator|*
name|info
operator|,
name|bfd_vma
name|symval
operator|,
name|Elf_Internal_Rela
operator|*
name|irel
operator|,
name|bfd_boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf64_alpha_relax_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|asection
operator|*
name|sec
operator|,
expr|struct
name|bfd_link_info
operator|*
name|link_info
operator|,
name|bfd_boolean
operator|*
name|again
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Elf_Internal_Rela
modifier|*
name|elf64_alpha_find_reloc_at_ofs
parameter_list|(
name|rel
parameter_list|,
name|relend
parameter_list|,
name|offset
parameter_list|,
name|type
parameter_list|)
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|,
decl|*
name|relend
decl_stmt|;
end_function

begin_decl_stmt
name|bfd_vma
name|offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
name|rel
operator|<
name|relend
condition|)
block|{
if|if
condition|(
name|rel
operator|->
name|r_offset
operator|==
name|offset
operator|&&
name|ELF64_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|unsigned
name|int
operator|)
name|type
condition|)
return|return
name|rel
return|;
operator|++
name|rel
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_block

begin_function
specifier|static
name|bfd_boolean
name|elf64_alpha_relax_with_lituse
parameter_list|(
name|info
parameter_list|,
name|symval
parameter_list|,
name|irel
parameter_list|)
name|struct
name|alpha_relax_info
modifier|*
name|info
decl_stmt|;
name|bfd_vma
name|symval
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|;
block|{
name|Elf_Internal_Rela
modifier|*
name|urel
decl_stmt|,
modifier|*
name|irelend
init|=
name|info
operator|->
name|relend
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|count
decl_stmt|,
name|i
decl_stmt|;
name|bfd_signed_vma
name|disp
decl_stmt|;
name|bfd_boolean
name|fits16
decl_stmt|;
name|bfd_boolean
name|fits32
decl_stmt|;
name|bfd_boolean
name|lit_reused
init|=
name|FALSE
decl_stmt|;
name|bfd_boolean
name|all_optimized
init|=
name|TRUE
decl_stmt|;
name|unsigned
name|int
name|lit_insn
decl_stmt|;
name|lit_insn
operator|=
name|bfd_get_32
argument_list|(
name|info
operator|->
name|abfd
argument_list|,
name|info
operator|->
name|contents
operator|+
name|irel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|lit_insn
operator|>>
literal|26
operator|!=
name|OP_LDQ
condition|)
block|{
operator|(
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"%s: %s+0x%lx: warning: LITERAL relocation against unexpected insn"
argument_list|,
name|bfd_archive_filename
argument_list|(
name|info
operator|->
name|abfd
argument_list|)
argument_list|,
name|info
operator|->
name|sec
operator|->
name|name
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|irel
operator|->
name|r_offset
argument_list|)
operator|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* Can't relax dynamic symbols.  */
if|if
condition|(
name|alpha_elf_dynamic_symbol_p
argument_list|(
operator|&
name|info
operator|->
name|h
operator|->
name|root
argument_list|,
name|info
operator|->
name|link_info
argument_list|)
condition|)
return|return
name|TRUE
return|;
comment|/* Summarize how this particular LITERAL is used.  */
for|for
control|(
name|urel
operator|=
name|irel
operator|+
literal|1
operator|,
name|flags
operator|=
name|count
operator|=
literal|0
init|;
name|urel
operator|<
name|irelend
condition|;
operator|++
name|urel
operator|,
operator|++
name|count
control|)
block|{
if|if
condition|(
name|ELF64_R_TYPE
argument_list|(
name|urel
operator|->
name|r_info
argument_list|)
operator|!=
name|R_ALPHA_LITUSE
condition|)
break|break;
if|if
condition|(
name|urel
operator|->
name|r_addend
operator|<=
literal|3
condition|)
name|flags
operator||=
literal|1
operator|<<
name|urel
operator|->
name|r_addend
expr_stmt|;
block|}
comment|/* A little preparation for the loop...  */
name|disp
operator|=
name|symval
operator|-
name|info
operator|->
name|gp
expr_stmt|;
for|for
control|(
name|urel
operator|=
name|irel
operator|+
literal|1
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
operator|,
operator|++
name|urel
control|)
block|{
name|unsigned
name|int
name|insn
decl_stmt|;
name|int
name|insn_disp
decl_stmt|;
name|bfd_signed_vma
name|xdisp
decl_stmt|;
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|info
operator|->
name|abfd
argument_list|,
name|info
operator|->
name|contents
operator|+
name|urel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|urel
operator|->
name|r_addend
condition|)
block|{
case|case
name|LITUSE_ALPHA_ADDR
case|:
default|default:
comment|/* This type is really just a placeholder to note that all 	     uses cannot be optimized, but to still allow some.  */
name|all_optimized
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|LITUSE_ALPHA_BASE
case|:
comment|/* We can always optimize 16-bit displacements.  */
comment|/* Extract the displacement from the instruction, sign-extending 	     it if necessary, then test whether it is within 16 or 32 bits 	     displacement from GP.  */
name|insn_disp
operator|=
name|insn
operator|&
literal|0x0000ffff
expr_stmt|;
if|if
condition|(
name|insn_disp
operator|&
literal|0x8000
condition|)
name|insn_disp
operator||=
operator|~
literal|0xffff
expr_stmt|;
comment|/* Negative: sign-extend.  */
name|xdisp
operator|=
name|disp
operator|+
name|insn_disp
expr_stmt|;
name|fits16
operator|=
operator|(
name|xdisp
operator|>=
operator|-
operator|(
name|bfd_signed_vma
operator|)
literal|0x8000
operator|&&
name|xdisp
operator|<
literal|0x8000
operator|)
expr_stmt|;
name|fits32
operator|=
operator|(
name|xdisp
operator|>=
operator|-
operator|(
name|bfd_signed_vma
operator|)
literal|0x80000000
operator|&&
name|xdisp
operator|<
literal|0x7fff8000
operator|)
expr_stmt|;
if|if
condition|(
name|fits16
condition|)
block|{
comment|/* Take the op code and dest from this insn, take the base 		 register from the literal insn.  Leave the offset alone.  */
name|insn
operator|=
operator|(
name|insn
operator|&
literal|0xffe0ffff
operator|)
operator||
operator|(
name|lit_insn
operator|&
literal|0x001f0000
operator|)
expr_stmt|;
name|urel
operator|->
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|ELF64_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
name|R_ALPHA_GPREL16
argument_list|)
expr_stmt|;
name|urel
operator|->
name|r_addend
operator|=
name|irel
operator|->
name|r_addend
expr_stmt|;
name|info
operator|->
name|changed_relocs
operator|=
name|TRUE
expr_stmt|;
name|bfd_put_32
argument_list|(
name|info
operator|->
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|insn
argument_list|,
name|info
operator|->
name|contents
operator|+
name|urel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|info
operator|->
name|changed_contents
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* If all mem+byte, we can optimize 32-bit mem displacements.  */
elseif|else
if|if
condition|(
name|fits32
operator|&&
operator|!
operator|(
name|flags
operator|&
operator|~
literal|6
operator|)
condition|)
block|{
comment|/* FIXME: sanity check that lit insn Ra is mem insn Rb.  */
name|irel
operator|->
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|ELF64_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
name|R_ALPHA_GPRELHIGH
argument_list|)
expr_stmt|;
name|lit_insn
operator|=
operator|(
name|OP_LDAH
operator|<<
literal|26
operator|)
operator||
operator|(
name|lit_insn
operator|&
literal|0x03ff0000
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|info
operator|->
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|lit_insn
argument_list|,
name|info
operator|->
name|contents
operator|+
name|irel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|lit_reused
operator|=
name|TRUE
expr_stmt|;
name|info
operator|->
name|changed_contents
operator|=
name|TRUE
expr_stmt|;
name|urel
operator|->
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|ELF64_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
name|R_ALPHA_GPRELLOW
argument_list|)
expr_stmt|;
name|urel
operator|->
name|r_addend
operator|=
name|irel
operator|->
name|r_addend
expr_stmt|;
name|info
operator|->
name|changed_relocs
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|all_optimized
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|LITUSE_ALPHA_BYTOFF
case|:
comment|/* We can always optimize byte instructions.  */
comment|/* FIXME: sanity check the insn for byte op.  Check that the 	     literal dest reg is indeed Rb in the byte insn.  */
name|insn
operator|&=
operator|~
operator|(
name|unsigned
operator|)
literal|0x001ff000
expr_stmt|;
name|insn
operator||=
operator|(
operator|(
name|symval
operator|&
literal|7
operator|)
operator|<<
literal|13
operator|)
operator||
literal|0x1000
expr_stmt|;
name|urel
operator|->
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_ALPHA_NONE
argument_list|)
expr_stmt|;
name|urel
operator|->
name|r_addend
operator|=
literal|0
expr_stmt|;
name|info
operator|->
name|changed_relocs
operator|=
name|TRUE
expr_stmt|;
name|bfd_put_32
argument_list|(
name|info
operator|->
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|insn
argument_list|,
name|info
operator|->
name|contents
operator|+
name|urel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|info
operator|->
name|changed_contents
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|LITUSE_ALPHA_JSR
case|:
case|case
name|LITUSE_ALPHA_TLSGD
case|:
case|case
name|LITUSE_ALPHA_TLSLDM
case|:
block|{
name|bfd_vma
name|optdest
decl_stmt|,
name|org
decl_stmt|;
name|bfd_signed_vma
name|odisp
decl_stmt|;
comment|/* If not zero, place to jump without needing pv.  */
name|optdest
operator|=
name|elf64_alpha_relax_opt_call
argument_list|(
name|info
argument_list|,
name|symval
argument_list|)
expr_stmt|;
name|org
operator|=
operator|(
name|info
operator|->
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|info
operator|->
name|sec
operator|->
name|output_offset
operator|+
name|urel
operator|->
name|r_offset
operator|+
literal|4
operator|)
expr_stmt|;
name|odisp
operator|=
operator|(
name|optdest
condition|?
name|optdest
else|:
name|symval
operator|)
operator|-
name|org
expr_stmt|;
if|if
condition|(
name|odisp
operator|>=
operator|-
literal|0x400000
operator|&&
name|odisp
operator|<
literal|0x400000
condition|)
block|{
name|Elf_Internal_Rela
modifier|*
name|xrel
decl_stmt|;
comment|/* Preserve branch prediction call stack when possible.  */
if|if
condition|(
operator|(
name|insn
operator|&
name|INSN_JSR_MASK
operator|)
operator|==
name|INSN_JSR
condition|)
name|insn
operator|=
operator|(
name|OP_BSR
operator|<<
literal|26
operator|)
operator||
operator|(
name|insn
operator|&
literal|0x03e00000
operator|)
expr_stmt|;
else|else
name|insn
operator|=
operator|(
name|OP_BR
operator|<<
literal|26
operator|)
operator||
operator|(
name|insn
operator|&
literal|0x03e00000
operator|)
expr_stmt|;
name|urel
operator|->
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|ELF64_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
name|R_ALPHA_BRADDR
argument_list|)
expr_stmt|;
name|urel
operator|->
name|r_addend
operator|=
name|irel
operator|->
name|r_addend
expr_stmt|;
if|if
condition|(
name|optdest
condition|)
name|urel
operator|->
name|r_addend
operator|+=
name|optdest
operator|-
name|symval
expr_stmt|;
else|else
name|all_optimized
operator|=
name|FALSE
expr_stmt|;
name|bfd_put_32
argument_list|(
name|info
operator|->
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|insn
argument_list|,
name|info
operator|->
name|contents
operator|+
name|urel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
comment|/* Kill any HINT reloc that might exist for this insn.  */
name|xrel
operator|=
operator|(
name|elf64_alpha_find_reloc_at_ofs
argument_list|(
name|info
operator|->
name|relocs
argument_list|,
name|info
operator|->
name|relend
argument_list|,
name|urel
operator|->
name|r_offset
argument_list|,
name|R_ALPHA_HINT
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|xrel
condition|)
name|xrel
operator|->
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_ALPHA_NONE
argument_list|)
expr_stmt|;
name|info
operator|->
name|changed_contents
operator|=
name|TRUE
expr_stmt|;
name|info
operator|->
name|changed_relocs
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|all_optimized
operator|=
name|FALSE
expr_stmt|;
comment|/* Even if the target is not in range for a direct branch, 	       if we share a GP, we can eliminate the gp reload.  */
if|if
condition|(
name|optdest
condition|)
block|{
name|Elf_Internal_Rela
modifier|*
name|gpdisp
init|=
operator|(
name|elf64_alpha_find_reloc_at_ofs
argument_list|(
name|info
operator|->
name|relocs
argument_list|,
name|irelend
argument_list|,
name|urel
operator|->
name|r_offset
operator|+
literal|4
argument_list|,
name|R_ALPHA_GPDISP
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|gpdisp
condition|)
block|{
name|bfd_byte
modifier|*
name|p_ldah
init|=
name|info
operator|->
name|contents
operator|+
name|gpdisp
operator|->
name|r_offset
decl_stmt|;
name|bfd_byte
modifier|*
name|p_lda
init|=
name|p_ldah
operator|+
name|gpdisp
operator|->
name|r_addend
decl_stmt|;
name|unsigned
name|int
name|ldah
init|=
name|bfd_get_32
argument_list|(
name|info
operator|->
name|abfd
argument_list|,
name|p_ldah
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|lda
init|=
name|bfd_get_32
argument_list|(
name|info
operator|->
name|abfd
argument_list|,
name|p_lda
argument_list|)
decl_stmt|;
comment|/* Verify that the instruction is "ldah $29,0($26)". 		       Consider a function that ends in a noreturn call, 		       and that the next function begins with an ldgp, 		       and that by accident there is no padding between. 		       In that case the insn would use $27 as the base.  */
if|if
condition|(
name|ldah
operator|==
literal|0x27ba0000
operator|&&
name|lda
operator|==
literal|0x23bd0000
condition|)
block|{
name|bfd_put_32
argument_list|(
name|info
operator|->
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|INSN_UNOP
argument_list|,
name|p_ldah
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|info
operator|->
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|INSN_UNOP
argument_list|,
name|p_lda
argument_list|)
expr_stmt|;
name|gpdisp
operator|->
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_ALPHA_NONE
argument_list|)
expr_stmt|;
name|info
operator|->
name|changed_contents
operator|=
name|TRUE
expr_stmt|;
name|info
operator|->
name|changed_relocs
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
block|}
break|break;
block|}
block|}
comment|/* If all cases were optimized, we can reduce the use count on this      got entry by one, possibly eliminating it.  */
if|if
condition|(
name|all_optimized
condition|)
block|{
if|if
condition|(
operator|--
name|info
operator|->
name|gotent
operator|->
name|use_count
operator|==
literal|0
condition|)
block|{
name|int
name|sz
init|=
name|alpha_got_entry_size
argument_list|(
name|R_ALPHA_LITERAL
argument_list|)
decl_stmt|;
name|alpha_elf_tdata
argument_list|(
name|info
operator|->
name|gotobj
argument_list|)
operator|->
name|total_got_size
operator|-=
name|sz
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|h
condition|)
name|alpha_elf_tdata
argument_list|(
name|info
operator|->
name|gotobj
argument_list|)
operator|->
name|local_got_size
operator|-=
name|sz
expr_stmt|;
block|}
comment|/* If the literal instruction is no longer needed (it may have been 	 reused.  We can eliminate it.  */
comment|/* ??? For now, I don't want to deal with compacting the section, 	 so just nop it out.  */
if|if
condition|(
operator|!
name|lit_reused
condition|)
block|{
name|irel
operator|->
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_ALPHA_NONE
argument_list|)
expr_stmt|;
name|info
operator|->
name|changed_relocs
operator|=
name|TRUE
expr_stmt|;
name|bfd_put_32
argument_list|(
name|info
operator|->
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|INSN_UNOP
argument_list|,
name|info
operator|->
name|contents
operator|+
name|irel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|info
operator|->
name|changed_contents
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_vma
name|elf64_alpha_relax_opt_call
parameter_list|(
name|info
parameter_list|,
name|symval
parameter_list|)
name|struct
name|alpha_relax_info
modifier|*
name|info
decl_stmt|;
name|bfd_vma
name|symval
decl_stmt|;
block|{
comment|/* If the function has the same gp, and we can identify that the      function does not use its function pointer, we can eliminate the      address load.  */
comment|/* If the symbol is marked NOPV, we are being told the function never      needs its procedure value.  */
if|if
condition|(
operator|(
name|info
operator|->
name|other
operator|&
name|STO_ALPHA_STD_GPLOAD
operator|)
operator|==
name|STO_ALPHA_NOPV
condition|)
return|return
name|symval
return|;
comment|/* If the symbol is marked STD_GP, we are being told the function does      a normal ldgp in the first two words.  */
elseif|else
if|if
condition|(
operator|(
name|info
operator|->
name|other
operator|&
name|STO_ALPHA_STD_GPLOAD
operator|)
operator|==
name|STO_ALPHA_STD_GPLOAD
condition|)
empty_stmt|;
comment|/* Otherwise, we may be able to identify a GP load in the first two      words, which we can then skip.  */
else|else
block|{
name|Elf_Internal_Rela
modifier|*
name|tsec_relocs
decl_stmt|,
modifier|*
name|tsec_relend
decl_stmt|,
modifier|*
name|tsec_free
decl_stmt|,
modifier|*
name|gpdisp
decl_stmt|;
name|bfd_vma
name|ofs
decl_stmt|;
comment|/* Load the relocations from the section that the target symbol is in.  */
if|if
condition|(
name|info
operator|->
name|sec
operator|==
name|info
operator|->
name|tsec
condition|)
block|{
name|tsec_relocs
operator|=
name|info
operator|->
name|relocs
expr_stmt|;
name|tsec_relend
operator|=
name|info
operator|->
name|relend
expr_stmt|;
name|tsec_free
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|tsec_relocs
operator|=
operator|(
name|_bfd_elf_link_read_relocs
argument_list|(
name|info
operator|->
name|abfd
argument_list|,
name|info
operator|->
name|tsec
argument_list|,
operator|(
name|PTR
operator|)
name|NULL
argument_list|,
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
name|NULL
argument_list|,
name|info
operator|->
name|link_info
operator|->
name|keep_memory
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|tsec_relocs
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|tsec_relend
operator|=
name|tsec_relocs
operator|+
name|info
operator|->
name|tsec
operator|->
name|reloc_count
expr_stmt|;
name|tsec_free
operator|=
operator|(
name|info
operator|->
name|link_info
operator|->
name|keep_memory
condition|?
name|NULL
else|:
name|tsec_relocs
operator|)
expr_stmt|;
block|}
comment|/* Recover the symbol's offset within the section.  */
name|ofs
operator|=
operator|(
name|symval
operator|-
name|info
operator|->
name|tsec
operator|->
name|output_section
operator|->
name|vma
operator|-
name|info
operator|->
name|tsec
operator|->
name|output_offset
operator|)
expr_stmt|;
comment|/* Look for a GPDISP reloc.  */
name|gpdisp
operator|=
operator|(
name|elf64_alpha_find_reloc_at_ofs
argument_list|(
name|tsec_relocs
argument_list|,
name|tsec_relend
argument_list|,
name|ofs
argument_list|,
name|R_ALPHA_GPDISP
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|gpdisp
operator|||
name|gpdisp
operator|->
name|r_addend
operator|!=
literal|4
condition|)
block|{
if|if
condition|(
name|tsec_free
condition|)
name|free
argument_list|(
name|tsec_free
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|tsec_free
condition|)
name|free
argument_list|(
name|tsec_free
argument_list|)
expr_stmt|;
block|}
comment|/* We've now determined that we can skip an initial gp load.  Verify      that the call and the target use the same gp.   */
if|if
condition|(
name|info
operator|->
name|link_info
operator|->
name|hash
operator|->
name|creator
operator|!=
name|info
operator|->
name|tsec
operator|->
name|owner
operator|->
name|xvec
operator|||
name|info
operator|->
name|gotobj
operator|!=
name|alpha_elf_tdata
argument_list|(
name|info
operator|->
name|tsec
operator|->
name|owner
argument_list|)
operator|->
name|gotobj
condition|)
return|return
literal|0
return|;
return|return
name|symval
operator|+
literal|8
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elf64_alpha_relax_got_load
parameter_list|(
name|info
parameter_list|,
name|symval
parameter_list|,
name|irel
parameter_list|,
name|r_type
parameter_list|)
name|struct
name|alpha_relax_info
modifier|*
name|info
decl_stmt|;
name|bfd_vma
name|symval
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|;
name|unsigned
name|long
name|r_type
decl_stmt|;
block|{
name|unsigned
name|int
name|insn
decl_stmt|;
name|bfd_signed_vma
name|disp
decl_stmt|;
comment|/* Get the instruction.  */
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|info
operator|->
name|abfd
argument_list|,
name|info
operator|->
name|contents
operator|+
name|irel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|>>
literal|26
operator|!=
name|OP_LDQ
condition|)
block|{
name|reloc_howto_type
modifier|*
name|howto
init|=
name|elf64_alpha_howto_table
operator|+
name|r_type
decl_stmt|;
operator|(
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"%s: %s+0x%lx: warning: %s relocation against unexpected insn"
argument_list|,
name|bfd_archive_filename
argument_list|(
name|info
operator|->
name|abfd
argument_list|)
argument_list|,
name|info
operator|->
name|sec
operator|->
name|name
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|irel
operator|->
name|r_offset
argument_list|,
name|howto
operator|->
name|name
argument_list|)
operator|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* Can't relax dynamic symbols.  */
if|if
condition|(
name|alpha_elf_dynamic_symbol_p
argument_list|(
operator|&
name|info
operator|->
name|h
operator|->
name|root
argument_list|,
name|info
operator|->
name|link_info
argument_list|)
condition|)
return|return
name|TRUE
return|;
comment|/* Can't use local-exec relocations in shared libraries.  */
if|if
condition|(
name|r_type
operator|==
name|R_ALPHA_GOTTPREL
operator|&&
name|info
operator|->
name|link_info
operator|->
name|shared
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|r_type
operator|==
name|R_ALPHA_LITERAL
condition|)
name|disp
operator|=
name|symval
operator|-
name|info
operator|->
name|gp
expr_stmt|;
else|else
block|{
name|bfd_vma
name|dtp_base
decl_stmt|,
name|tp_base
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|elf_hash_table
argument_list|(
name|info
operator|->
name|link_info
argument_list|)
operator|->
name|tls_sec
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dtp_base
operator|=
name|alpha_get_dtprel_base
argument_list|(
name|info
operator|->
name|link_info
argument_list|)
expr_stmt|;
name|tp_base
operator|=
name|alpha_get_tprel_base
argument_list|(
name|info
operator|->
name|link_info
argument_list|)
expr_stmt|;
name|disp
operator|=
name|symval
operator|-
operator|(
name|r_type
operator|==
name|R_ALPHA_GOTDTPREL
condition|?
name|dtp_base
else|:
name|tp_base
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|disp
operator|<
operator|-
literal|0x8000
operator|||
name|disp
operator|>=
literal|0x8000
condition|)
return|return
name|TRUE
return|;
comment|/* Exchange LDQ for LDA.  In the case of the TLS relocs, we're loading      a constant, so force the base register to be $31.  */
if|if
condition|(
name|r_type
operator|==
name|R_ALPHA_LITERAL
condition|)
name|insn
operator|=
operator|(
name|OP_LDA
operator|<<
literal|26
operator|)
operator||
operator|(
name|insn
operator|&
literal|0x03ff0000
operator|)
expr_stmt|;
else|else
name|insn
operator|=
operator|(
name|OP_LDA
operator|<<
literal|26
operator|)
operator||
operator|(
name|insn
operator|&
operator|(
literal|31
operator|<<
literal|21
operator|)
operator|)
operator||
operator|(
literal|31
operator|<<
literal|16
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|info
operator|->
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|insn
argument_list|,
name|info
operator|->
name|contents
operator|+
name|irel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|info
operator|->
name|changed_contents
operator|=
name|TRUE
expr_stmt|;
comment|/* Reduce the use count on this got entry by one, possibly      eliminating it.  */
if|if
condition|(
operator|--
name|info
operator|->
name|gotent
operator|->
name|use_count
operator|==
literal|0
condition|)
block|{
name|int
name|sz
init|=
name|alpha_got_entry_size
argument_list|(
name|r_type
argument_list|)
decl_stmt|;
name|alpha_elf_tdata
argument_list|(
name|info
operator|->
name|gotobj
argument_list|)
operator|->
name|total_got_size
operator|-=
name|sz
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|h
condition|)
name|alpha_elf_tdata
argument_list|(
name|info
operator|->
name|gotobj
argument_list|)
operator|->
name|local_got_size
operator|-=
name|sz
expr_stmt|;
block|}
comment|/* Smash the existing GOT relocation for its 16-bit immediate pair.  */
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_ALPHA_LITERAL
case|:
name|r_type
operator|=
name|R_ALPHA_GPREL16
expr_stmt|;
break|break;
case|case
name|R_ALPHA_GOTDTPREL
case|:
name|r_type
operator|=
name|R_ALPHA_DTPREL16
expr_stmt|;
break|break;
case|case
name|R_ALPHA_GOTTPREL
case|:
name|r_type
operator|=
name|R_ALPHA_TPREL16
expr_stmt|;
break|break;
default|default:
name|BFD_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|irel
operator|->
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|ELF64_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
name|info
operator|->
name|changed_relocs
operator|=
name|TRUE
expr_stmt|;
comment|/* ??? Search forward through this basic block looking for insns      that use the target register.  Stop after an insn modifying the      register is seen, or after a branch or call.       Any such memory load insn may be substituted by a load directly      off the GP.  This allows the memory load insn to be issued before      the calculated GP register would otherwise be ready.       Any such jsr insn can be replaced by a bsr if it is in range.       This would mean that we'd have to _add_ relocations, the pain of      which gives one pause.  */
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elf64_alpha_relax_gprelhilo
parameter_list|(
name|info
parameter_list|,
name|symval
parameter_list|,
name|irel
parameter_list|,
name|hi
parameter_list|)
name|struct
name|alpha_relax_info
modifier|*
name|info
decl_stmt|;
name|bfd_vma
name|symval
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|;
name|bfd_boolean
name|hi
decl_stmt|;
block|{
name|unsigned
name|int
name|insn
decl_stmt|;
name|bfd_signed_vma
name|disp
decl_stmt|;
name|bfd_byte
modifier|*
name|pos
init|=
name|info
operator|->
name|contents
operator|+
name|irel
operator|->
name|r_offset
decl_stmt|;
comment|/* ??? This assumes that the compiler doesn't render  	array[i]      as 	ldah	t, array(gp)	!gprelhigh 	s8addl	i, t, t 	ldq	r, array(t)	!gprellow       which would indeed be the most efficient way to implement this.  */
return|return
name|TRUE
return|;
name|disp
operator|=
name|symval
operator|-
name|info
operator|->
name|gp
expr_stmt|;
if|if
condition|(
name|disp
operator|<
operator|-
literal|0x8000
operator|||
name|disp
operator|>=
literal|0x8000
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|hi
condition|)
block|{
comment|/* Nop out the high instruction.  */
name|bfd_put_32
argument_list|(
name|info
operator|->
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|INSN_UNOP
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|info
operator|->
name|changed_contents
operator|=
name|TRUE
expr_stmt|;
name|irel
operator|->
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_ALPHA_NONE
argument_list|)
expr_stmt|;
name|irel
operator|->
name|r_addend
operator|=
literal|0
expr_stmt|;
name|info
operator|->
name|changed_relocs
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* Adjust the low instruction to reference GP directly.  */
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|info
operator|->
name|abfd
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|insn
operator|=
operator|(
name|insn
operator|&
literal|0xffe00000
operator|)
operator||
operator|(
literal|29
operator|<<
literal|16
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|info
operator|->
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|insn
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|info
operator|->
name|changed_contents
operator|=
name|TRUE
expr_stmt|;
name|irel
operator|->
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|ELF64_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
name|R_ALPHA_GPREL16
argument_list|)
expr_stmt|;
name|info
operator|->
name|changed_relocs
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elf64_alpha_relax_tls_get_addr
parameter_list|(
name|info
parameter_list|,
name|symval
parameter_list|,
name|irel
parameter_list|,
name|is_gd
parameter_list|)
name|struct
name|alpha_relax_info
modifier|*
name|info
decl_stmt|;
name|bfd_vma
name|symval
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|;
name|bfd_boolean
name|is_gd
decl_stmt|;
block|{
name|bfd_byte
modifier|*
name|pos
index|[
literal|5
index|]
decl_stmt|;
name|unsigned
name|int
name|insn
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|gpdisp
decl_stmt|,
modifier|*
name|hint
decl_stmt|;
name|bfd_boolean
name|dynamic
decl_stmt|,
name|use_gottprel
decl_stmt|,
name|pos1_unusable
decl_stmt|;
name|unsigned
name|long
name|new_symndx
decl_stmt|;
name|dynamic
operator|=
name|alpha_elf_dynamic_symbol_p
argument_list|(
operator|&
name|info
operator|->
name|h
operator|->
name|root
argument_list|,
name|info
operator|->
name|link_info
argument_list|)
expr_stmt|;
comment|/* If a TLS symbol is accessed using IE at least once, there is no point      to use dynamic model for it.  */
if|if
condition|(
name|is_gd
operator|&&
name|info
operator|->
name|h
operator|&&
operator|(
name|info
operator|->
name|h
operator|->
name|flags
operator|&
name|ALPHA_ELF_LINK_HASH_TLS_IE
operator|)
condition|)
empty_stmt|;
comment|/* If the symbol is local, and we've already committed to DF_STATIC_TLS,      then we might as well relax to IE.  */
elseif|else
if|if
condition|(
name|info
operator|->
name|link_info
operator|->
name|shared
operator|&&
operator|!
name|dynamic
operator|&&
operator|(
name|info
operator|->
name|link_info
operator|->
name|flags
operator|&
name|DF_STATIC_TLS
operator|)
condition|)
empty_stmt|;
comment|/* Otherwise we must be building an executable to do anything.  */
elseif|else
if|if
condition|(
name|info
operator|->
name|link_info
operator|->
name|shared
condition|)
return|return
name|TRUE
return|;
comment|/* The TLSGD/TLSLDM relocation must be followed by a LITERAL and      the matching LITUSE_TLS relocations.  */
if|if
condition|(
name|irel
operator|+
literal|2
operator|>=
name|info
operator|->
name|relend
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|ELF64_R_TYPE
argument_list|(
name|irel
index|[
literal|1
index|]
operator|.
name|r_info
argument_list|)
operator|!=
name|R_ALPHA_LITERAL
operator|||
name|ELF64_R_TYPE
argument_list|(
name|irel
index|[
literal|2
index|]
operator|.
name|r_info
argument_list|)
operator|!=
name|R_ALPHA_LITUSE
operator|||
name|irel
index|[
literal|2
index|]
operator|.
name|r_addend
operator|!=
operator|(
name|is_gd
condition|?
name|LITUSE_ALPHA_TLSGD
else|:
name|LITUSE_ALPHA_TLSLDM
operator|)
condition|)
return|return
name|TRUE
return|;
comment|/* There must be a GPDISP relocation positioned immediately after the      LITUSE relocation.  */
name|gpdisp
operator|=
name|elf64_alpha_find_reloc_at_ofs
argument_list|(
name|info
operator|->
name|relocs
argument_list|,
name|info
operator|->
name|relend
argument_list|,
name|irel
index|[
literal|2
index|]
operator|.
name|r_offset
operator|+
literal|4
argument_list|,
name|R_ALPHA_GPDISP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gpdisp
condition|)
return|return
name|TRUE
return|;
name|pos
index|[
literal|0
index|]
operator|=
name|info
operator|->
name|contents
operator|+
name|irel
index|[
literal|0
index|]
operator|.
name|r_offset
expr_stmt|;
name|pos
index|[
literal|1
index|]
operator|=
name|info
operator|->
name|contents
operator|+
name|irel
index|[
literal|1
index|]
operator|.
name|r_offset
expr_stmt|;
name|pos
index|[
literal|2
index|]
operator|=
name|info
operator|->
name|contents
operator|+
name|irel
index|[
literal|2
index|]
operator|.
name|r_offset
expr_stmt|;
name|pos
index|[
literal|3
index|]
operator|=
name|info
operator|->
name|contents
operator|+
name|gpdisp
operator|->
name|r_offset
expr_stmt|;
name|pos
index|[
literal|4
index|]
operator|=
name|pos
index|[
literal|3
index|]
operator|+
name|gpdisp
operator|->
name|r_addend
expr_stmt|;
name|pos1_unusable
operator|=
name|FALSE
expr_stmt|;
comment|/* Generally, the positions are not allowed to be out of order, lest the      modified insn sequence have different register lifetimes.  We can make      an exception when pos 1 is adjacent to pos 0.  */
if|if
condition|(
name|pos
index|[
literal|1
index|]
operator|+
literal|4
operator|==
name|pos
index|[
literal|0
index|]
condition|)
block|{
name|bfd_byte
modifier|*
name|tmp
init|=
name|pos
index|[
literal|0
index|]
decl_stmt|;
name|pos
index|[
literal|0
index|]
operator|=
name|pos
index|[
literal|1
index|]
expr_stmt|;
name|pos
index|[
literal|1
index|]
operator|=
name|tmp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pos
index|[
literal|1
index|]
operator|<
name|pos
index|[
literal|0
index|]
condition|)
name|pos1_unusable
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|pos
index|[
literal|1
index|]
operator|>=
name|pos
index|[
literal|2
index|]
operator|||
name|pos
index|[
literal|2
index|]
operator|>=
name|pos
index|[
literal|3
index|]
condition|)
return|return
name|TRUE
return|;
comment|/* Reduce the use count on the LITERAL relocation.  Do this before we      smash the symndx when we adjust the relocations below.  */
block|{
name|struct
name|alpha_elf_got_entry
modifier|*
name|lit_gotent
decl_stmt|;
name|struct
name|alpha_elf_link_hash_entry
modifier|*
name|lit_h
decl_stmt|;
name|unsigned
name|long
name|indx
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|ELF64_R_SYM
argument_list|(
name|irel
index|[
literal|1
index|]
operator|.
name|r_info
argument_list|)
operator|>=
name|info
operator|->
name|symtab_hdr
operator|->
name|sh_info
argument_list|)
expr_stmt|;
name|indx
operator|=
name|ELF64_R_SYM
argument_list|(
name|irel
index|[
literal|1
index|]
operator|.
name|r_info
argument_list|)
operator|-
name|info
operator|->
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|lit_h
operator|=
name|alpha_elf_sym_hashes
argument_list|(
name|info
operator|->
name|abfd
argument_list|)
index|[
name|indx
index|]
expr_stmt|;
while|while
condition|(
name|lit_h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|lit_h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|lit_h
operator|=
operator|(
expr|struct
name|alpha_elf_link_hash_entry
operator|*
operator|)
name|lit_h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
for|for
control|(
name|lit_gotent
operator|=
name|lit_h
operator|->
name|got_entries
init|;
name|lit_gotent
condition|;
name|lit_gotent
operator|=
name|lit_gotent
operator|->
name|next
control|)
if|if
condition|(
name|lit_gotent
operator|->
name|gotobj
operator|==
name|info
operator|->
name|gotobj
operator|&&
name|lit_gotent
operator|->
name|reloc_type
operator|==
name|R_ALPHA_LITERAL
operator|&&
name|lit_gotent
operator|->
name|addend
operator|==
name|irel
index|[
literal|1
index|]
operator|.
name|r_addend
condition|)
break|break;
name|BFD_ASSERT
argument_list|(
name|lit_gotent
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|lit_gotent
operator|->
name|use_count
operator|==
literal|0
condition|)
block|{
name|int
name|sz
init|=
name|alpha_got_entry_size
argument_list|(
name|R_ALPHA_LITERAL
argument_list|)
decl_stmt|;
name|alpha_elf_tdata
argument_list|(
name|info
operator|->
name|gotobj
argument_list|)
operator|->
name|total_got_size
operator|-=
name|sz
expr_stmt|;
block|}
block|}
comment|/* Change  	lda	$16,x($gp)		!tlsgd!1 	ldq	$27,__tls_get_addr($gp)	!literal!1 	jsr	$26,($27)__tls_get_addr	!lituse_tlsgd!1 	ldah	$29,0($26)		!gpdisp!2 	lda	$29,0($29)		!gpdisp!2      to 	ldq	$16,x($gp)		!gottprel 	unop 	call_pal rduniq 	addq	$16,$0,$0 	unop      or the first pair to 	lda	$16,x($gp)		!tprel 	unop      or 	ldah	$16,x($gp)		!tprelhi 	lda	$16,x($16)		!tprello       as appropriate.  */
name|use_gottprel
operator|=
name|FALSE
expr_stmt|;
name|new_symndx
operator|=
name|is_gd
condition|?
name|ELF64_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
else|:
literal|0
expr_stmt|;
switch|switch
condition|(
operator|!
name|dynamic
operator|&&
operator|!
name|info
operator|->
name|link_info
operator|->
name|shared
condition|)
block|{
case|case
literal|1
case|:
block|{
name|bfd_vma
name|tp_base
decl_stmt|;
name|bfd_signed_vma
name|disp
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|elf_hash_table
argument_list|(
name|info
operator|->
name|link_info
argument_list|)
operator|->
name|tls_sec
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|tp_base
operator|=
name|alpha_get_tprel_base
argument_list|(
name|info
operator|->
name|link_info
argument_list|)
expr_stmt|;
name|disp
operator|=
name|symval
operator|-
name|tp_base
expr_stmt|;
if|if
condition|(
name|disp
operator|>=
operator|-
literal|0x8000
operator|&&
name|disp
operator|<
literal|0x8000
condition|)
block|{
name|insn
operator|=
operator|(
name|OP_LDA
operator|<<
literal|26
operator|)
operator||
operator|(
literal|16
operator|<<
literal|21
operator|)
operator||
operator|(
literal|31
operator|<<
literal|16
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|info
operator|->
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|insn
argument_list|,
name|pos
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|info
operator|->
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|INSN_UNOP
argument_list|,
name|pos
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|irel
index|[
literal|0
index|]
operator|.
name|r_offset
operator|=
name|pos
index|[
literal|0
index|]
operator|-
name|info
operator|->
name|contents
expr_stmt|;
name|irel
index|[
literal|0
index|]
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|new_symndx
argument_list|,
name|R_ALPHA_TPREL16
argument_list|)
expr_stmt|;
name|irel
index|[
literal|1
index|]
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_ALPHA_NONE
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|disp
operator|>=
operator|-
operator|(
name|bfd_signed_vma
operator|)
literal|0x80000000
operator|&&
name|disp
operator|<
operator|(
name|bfd_signed_vma
operator|)
literal|0x7fff8000
operator|&&
operator|!
name|pos1_unusable
condition|)
block|{
name|insn
operator|=
operator|(
name|OP_LDAH
operator|<<
literal|26
operator|)
operator||
operator|(
literal|16
operator|<<
literal|21
operator|)
operator||
operator|(
literal|31
operator|<<
literal|16
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|info
operator|->
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|insn
argument_list|,
name|pos
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|insn
operator|=
operator|(
name|OP_LDA
operator|<<
literal|26
operator|)
operator||
operator|(
literal|16
operator|<<
literal|21
operator|)
operator||
operator|(
literal|16
operator|<<
literal|16
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|info
operator|->
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|insn
argument_list|,
name|pos
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|irel
index|[
literal|0
index|]
operator|.
name|r_offset
operator|=
name|pos
index|[
literal|0
index|]
operator|-
name|info
operator|->
name|contents
expr_stmt|;
name|irel
index|[
literal|0
index|]
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|new_symndx
argument_list|,
name|R_ALPHA_TPRELHI
argument_list|)
expr_stmt|;
name|irel
index|[
literal|1
index|]
operator|.
name|r_offset
operator|=
name|pos
index|[
literal|1
index|]
operator|-
name|info
operator|->
name|contents
expr_stmt|;
name|irel
index|[
literal|1
index|]
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|new_symndx
argument_list|,
name|R_ALPHA_TPRELLO
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* FALLTHRU */
default|default:
name|use_gottprel
operator|=
name|TRUE
expr_stmt|;
name|insn
operator|=
operator|(
name|OP_LDQ
operator|<<
literal|26
operator|)
operator||
operator|(
literal|16
operator|<<
literal|21
operator|)
operator||
operator|(
literal|29
operator|<<
literal|16
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|info
operator|->
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|insn
argument_list|,
name|pos
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|info
operator|->
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|INSN_UNOP
argument_list|,
name|pos
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|irel
index|[
literal|0
index|]
operator|.
name|r_offset
operator|=
name|pos
index|[
literal|0
index|]
operator|-
name|info
operator|->
name|contents
expr_stmt|;
name|irel
index|[
literal|0
index|]
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|new_symndx
argument_list|,
name|R_ALPHA_GOTTPREL
argument_list|)
expr_stmt|;
name|irel
index|[
literal|1
index|]
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_ALPHA_NONE
argument_list|)
expr_stmt|;
break|break;
block|}
name|bfd_put_32
argument_list|(
name|info
operator|->
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|INSN_RDUNIQ
argument_list|,
name|pos
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|insn
operator|=
name|INSN_ADDQ
operator||
operator|(
literal|16
operator|<<
literal|21
operator|)
operator||
operator|(
literal|0
operator|<<
literal|16
operator|)
operator||
operator|(
literal|0
operator|<<
literal|0
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|info
operator|->
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|insn
argument_list|,
name|pos
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|info
operator|->
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|INSN_UNOP
argument_list|,
name|pos
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|irel
index|[
literal|2
index|]
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_ALPHA_NONE
argument_list|)
expr_stmt|;
name|gpdisp
operator|->
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_ALPHA_NONE
argument_list|)
expr_stmt|;
name|hint
operator|=
name|elf64_alpha_find_reloc_at_ofs
argument_list|(
name|info
operator|->
name|relocs
argument_list|,
name|info
operator|->
name|relend
argument_list|,
name|irel
index|[
literal|2
index|]
operator|.
name|r_offset
argument_list|,
name|R_ALPHA_HINT
argument_list|)
expr_stmt|;
if|if
condition|(
name|hint
condition|)
name|hint
operator|->
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_ALPHA_NONE
argument_list|)
expr_stmt|;
name|info
operator|->
name|changed_contents
operator|=
name|TRUE
expr_stmt|;
name|info
operator|->
name|changed_relocs
operator|=
name|TRUE
expr_stmt|;
comment|/* Reduce the use count on the TLSGD/TLSLDM relocation.  */
if|if
condition|(
operator|--
name|info
operator|->
name|gotent
operator|->
name|use_count
operator|==
literal|0
condition|)
block|{
name|int
name|sz
init|=
name|alpha_got_entry_size
argument_list|(
name|info
operator|->
name|gotent
operator|->
name|reloc_type
argument_list|)
decl_stmt|;
name|alpha_elf_tdata
argument_list|(
name|info
operator|->
name|gotobj
argument_list|)
operator|->
name|total_got_size
operator|-=
name|sz
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|h
condition|)
name|alpha_elf_tdata
argument_list|(
name|info
operator|->
name|gotobj
argument_list|)
operator|->
name|local_got_size
operator|-=
name|sz
expr_stmt|;
block|}
comment|/* If we've switched to a GOTTPREL relocation, increment the reference      count on that got entry.  */
if|if
condition|(
name|use_gottprel
condition|)
block|{
name|struct
name|alpha_elf_got_entry
modifier|*
name|tprel_gotent
decl_stmt|;
for|for
control|(
name|tprel_gotent
operator|=
operator|*
name|info
operator|->
name|first_gotent
init|;
name|tprel_gotent
condition|;
name|tprel_gotent
operator|=
name|tprel_gotent
operator|->
name|next
control|)
if|if
condition|(
name|tprel_gotent
operator|->
name|gotobj
operator|==
name|info
operator|->
name|gotobj
operator|&&
name|tprel_gotent
operator|->
name|reloc_type
operator|==
name|R_ALPHA_GOTTPREL
operator|&&
name|tprel_gotent
operator|->
name|addend
operator|==
name|irel
operator|->
name|r_addend
condition|)
break|break;
if|if
condition|(
name|tprel_gotent
condition|)
name|tprel_gotent
operator|->
name|use_count
operator|++
expr_stmt|;
else|else
block|{
if|if
condition|(
name|info
operator|->
name|gotent
operator|->
name|use_count
operator|==
literal|0
condition|)
name|tprel_gotent
operator|=
name|info
operator|->
name|gotent
expr_stmt|;
else|else
block|{
name|tprel_gotent
operator|=
operator|(
expr|struct
name|alpha_elf_got_entry
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|info
operator|->
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|alpha_elf_got_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tprel_gotent
condition|)
return|return
name|FALSE
return|;
name|tprel_gotent
operator|->
name|next
operator|=
operator|*
name|info
operator|->
name|first_gotent
expr_stmt|;
operator|*
name|info
operator|->
name|first_gotent
operator|=
name|tprel_gotent
expr_stmt|;
name|tprel_gotent
operator|->
name|gotobj
operator|=
name|info
operator|->
name|gotobj
expr_stmt|;
name|tprel_gotent
operator|->
name|addend
operator|=
name|irel
operator|->
name|r_addend
expr_stmt|;
name|tprel_gotent
operator|->
name|got_offset
operator|=
operator|-
literal|1
expr_stmt|;
name|tprel_gotent
operator|->
name|reloc_done
operator|=
literal|0
expr_stmt|;
name|tprel_gotent
operator|->
name|reloc_xlated
operator|=
literal|0
expr_stmt|;
block|}
name|tprel_gotent
operator|->
name|use_count
operator|=
literal|1
expr_stmt|;
name|tprel_gotent
operator|->
name|reloc_type
operator|=
name|R_ALPHA_GOTTPREL
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elf64_alpha_relax_section
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|link_info
parameter_list|,
name|again
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|link_info
decl_stmt|;
name|bfd_boolean
modifier|*
name|again
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|,
modifier|*
name|irelend
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymbuf
init|=
name|NULL
decl_stmt|;
name|struct
name|alpha_elf_got_entry
modifier|*
modifier|*
name|local_got_entries
decl_stmt|;
name|struct
name|alpha_relax_info
name|info
decl_stmt|;
comment|/* We are not currently changing any sizes, so only one pass.  */
operator|*
name|again
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|link_info
operator|->
name|relocatable
operator|||
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
operator|||
name|sec
operator|->
name|reloc_count
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
comment|/* If this is the first time we have been called for this section,      initialize the cooked size.  */
if|if
condition|(
name|sec
operator|->
name|_cooked_size
operator|==
literal|0
condition|)
name|sec
operator|->
name|_cooked_size
operator|=
name|sec
operator|->
name|_raw_size
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|local_got_entries
operator|=
name|alpha_elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|local_got_entries
expr_stmt|;
comment|/* Load the relocations for this section.  */
name|internal_relocs
operator|=
operator|(
name|_bfd_elf_link_read_relocs
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
operator|(
name|PTR
operator|)
name|NULL
argument_list|,
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
name|NULL
argument_list|,
name|link_info
operator|->
name|keep_memory
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|memset
argument_list|(
operator|&
name|info
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|.
name|abfd
operator|=
name|abfd
expr_stmt|;
name|info
operator|.
name|sec
operator|=
name|sec
expr_stmt|;
name|info
operator|.
name|link_info
operator|=
name|link_info
expr_stmt|;
name|info
operator|.
name|symtab_hdr
operator|=
name|symtab_hdr
expr_stmt|;
name|info
operator|.
name|relocs
operator|=
name|internal_relocs
expr_stmt|;
name|info
operator|.
name|relend
operator|=
name|irelend
operator|=
name|internal_relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
comment|/* Find the GP for this object.  Do not store the result back via      _bfd_set_gp_value, since this could change again before final.  */
name|info
operator|.
name|gotobj
operator|=
name|alpha_elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|gotobj
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|gotobj
condition|)
block|{
name|asection
modifier|*
name|sgot
init|=
name|alpha_elf_tdata
argument_list|(
name|info
operator|.
name|gotobj
argument_list|)
operator|->
name|got
decl_stmt|;
name|info
operator|.
name|gp
operator|=
operator|(
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
literal|0x8000
operator|)
expr_stmt|;
block|}
comment|/* Get the section contents.  */
if|if
condition|(
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|NULL
condition|)
name|info
operator|.
name|contents
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
expr_stmt|;
else|else
block|{
name|info
operator|.
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|sec
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|contents
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|info
operator|.
name|contents
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|sec
operator|->
name|_raw_size
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
for|for
control|(
name|irel
operator|=
name|internal_relocs
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
control|)
block|{
name|bfd_vma
name|symval
decl_stmt|;
name|struct
name|alpha_elf_got_entry
modifier|*
name|gotent
decl_stmt|;
name|unsigned
name|long
name|r_type
init|=
name|ELF64_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|r_symndx
init|=
name|ELF64_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
decl_stmt|;
comment|/* Early exit for unhandled or unrelaxable relocations.  */
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_ALPHA_LITERAL
case|:
case|case
name|R_ALPHA_GPRELHIGH
case|:
case|case
name|R_ALPHA_GPRELLOW
case|:
case|case
name|R_ALPHA_GOTDTPREL
case|:
case|case
name|R_ALPHA_GOTTPREL
case|:
case|case
name|R_ALPHA_TLSGD
case|:
break|break;
case|case
name|R_ALPHA_TLSLDM
case|:
comment|/* The symbol for a TLSLDM reloc is ignored.  Collapse the              reloc to the 0 symbol so that they all match.  */
name|r_symndx
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
continue|continue;
block|}
comment|/* Get the value of the symbol referred to by the reloc.  */
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
comment|/* A local symbol.  */
name|Elf_Internal_Sym
modifier|*
name|isym
decl_stmt|;
comment|/* Read this BFD's local symbols.  */
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
block|{
name|isymbuf
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
name|isymbuf
operator|=
name|bfd_elf_get_elf_syms
argument_list|(
name|abfd
argument_list|,
name|symtab_hdr
argument_list|,
name|symtab_hdr
operator|->
name|sh_info
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
block|}
name|isym
operator|=
name|isymbuf
operator|+
name|r_symndx
expr_stmt|;
comment|/* Given the symbol for a TLSLDM reloc is ignored, this also 	     means forcing the symbol value to the tp base.  */
if|if
condition|(
name|r_type
operator|==
name|R_ALPHA_TLSLDM
condition|)
block|{
name|info
operator|.
name|tsec
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
name|symval
operator|=
name|alpha_get_tprel_base
argument_list|(
name|info
operator|.
name|link_info
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|symval
operator|=
name|isym
operator|->
name|st_value
expr_stmt|;
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_UNDEF
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_ABS
condition|)
name|info
operator|.
name|tsec
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_COMMON
condition|)
name|info
operator|.
name|tsec
operator|=
name|bfd_com_section_ptr
expr_stmt|;
else|else
name|info
operator|.
name|tsec
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|abfd
argument_list|,
name|isym
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
block|}
name|info
operator|.
name|h
operator|=
name|NULL
expr_stmt|;
name|info
operator|.
name|other
operator|=
name|isym
operator|->
name|st_other
expr_stmt|;
if|if
condition|(
name|local_got_entries
condition|)
name|info
operator|.
name|first_gotent
operator|=
operator|&
name|local_got_entries
index|[
name|r_symndx
index|]
expr_stmt|;
else|else
block|{
name|info
operator|.
name|first_gotent
operator|=
operator|&
name|info
operator|.
name|gotent
expr_stmt|;
name|info
operator|.
name|gotent
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
name|unsigned
name|long
name|indx
decl_stmt|;
name|struct
name|alpha_elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|indx
operator|=
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|h
operator|=
name|alpha_elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
index|[
name|indx
index|]
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|h
operator|!=
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|alpha_elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
comment|/* If the symbol is undefined, we can't do anything with it.  */
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|||
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
condition|)
continue|continue;
comment|/* If the symbol isn't defined in the current module, again 	     we can't do anything.  */
if|if
condition|(
operator|!
operator|(
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
condition|)
block|{
comment|/* Except for TLSGD relocs, which can sometimes be 		 relaxed to GOTTPREL relocs.  */
if|if
condition|(
name|r_type
operator|!=
name|R_ALPHA_TLSGD
condition|)
continue|continue;
name|info
operator|.
name|tsec
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
name|symval
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|info
operator|.
name|tsec
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|symval
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
block|}
name|info
operator|.
name|h
operator|=
name|h
expr_stmt|;
name|info
operator|.
name|other
operator|=
name|h
operator|->
name|root
operator|.
name|other
expr_stmt|;
name|info
operator|.
name|first_gotent
operator|=
operator|&
name|h
operator|->
name|got_entries
expr_stmt|;
block|}
comment|/* Search for the got entry to be used by this relocation.  */
for|for
control|(
name|gotent
operator|=
operator|*
name|info
operator|.
name|first_gotent
init|;
name|gotent
condition|;
name|gotent
operator|=
name|gotent
operator|->
name|next
control|)
if|if
condition|(
name|gotent
operator|->
name|gotobj
operator|==
name|info
operator|.
name|gotobj
operator|&&
name|gotent
operator|->
name|reloc_type
operator|==
name|r_type
operator|&&
name|gotent
operator|->
name|addend
operator|==
name|irel
operator|->
name|r_addend
condition|)
break|break;
name|info
operator|.
name|gotent
operator|=
name|gotent
expr_stmt|;
name|symval
operator|+=
name|info
operator|.
name|tsec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|info
operator|.
name|tsec
operator|->
name|output_offset
expr_stmt|;
name|symval
operator|+=
name|irel
operator|->
name|r_addend
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_ALPHA_LITERAL
case|:
name|BFD_ASSERT
argument_list|(
name|info
operator|.
name|gotent
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* If there exist LITUSE relocations immediately following, this 	     opens up all sorts of interesting optimizations, because we 	     now know every location that this address load is used.  */
if|if
condition|(
name|irel
operator|+
literal|1
operator|<
name|irelend
operator|&&
name|ELF64_R_TYPE
argument_list|(
name|irel
index|[
literal|1
index|]
operator|.
name|r_info
argument_list|)
operator|==
name|R_ALPHA_LITUSE
condition|)
block|{
if|if
condition|(
operator|!
name|elf64_alpha_relax_with_lituse
argument_list|(
operator|&
name|info
argument_list|,
name|symval
argument_list|,
name|irel
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|elf64_alpha_relax_got_load
argument_list|(
operator|&
name|info
argument_list|,
name|symval
argument_list|,
name|irel
argument_list|,
name|r_type
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
break|break;
case|case
name|R_ALPHA_GPRELHIGH
case|:
case|case
name|R_ALPHA_GPRELLOW
case|:
if|if
condition|(
operator|!
name|elf64_alpha_relax_gprelhilo
argument_list|(
operator|&
name|info
argument_list|,
name|symval
argument_list|,
name|irel
argument_list|,
name|r_type
operator|==
name|R_ALPHA_GPRELHIGH
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
break|break;
case|case
name|R_ALPHA_GOTDTPREL
case|:
case|case
name|R_ALPHA_GOTTPREL
case|:
name|BFD_ASSERT
argument_list|(
name|info
operator|.
name|gotent
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|elf64_alpha_relax_got_load
argument_list|(
operator|&
name|info
argument_list|,
name|symval
argument_list|,
name|irel
argument_list|,
name|r_type
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
break|break;
case|case
name|R_ALPHA_TLSGD
case|:
case|case
name|R_ALPHA_TLSLDM
case|:
name|BFD_ASSERT
argument_list|(
name|info
operator|.
name|gotent
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|elf64_alpha_relax_tls_get_addr
argument_list|(
operator|&
name|info
argument_list|,
name|symval
argument_list|,
name|irel
argument_list|,
name|r_type
operator|==
name|R_ALPHA_TLSGD
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|elf64_alpha_size_plt_section
argument_list|(
name|link_info
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|elf64_alpha_size_got_sections
argument_list|(
name|link_info
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|elf64_alpha_size_rela_got_section
argument_list|(
name|link_info
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|isymbuf
operator|!=
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
condition|)
block|{
if|if
condition|(
operator|!
name|link_info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|isymbuf
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Cache the symbols for elf_link_input_bfd.  */
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
expr_stmt|;
block|}
block|}
if|if
condition|(
name|info
operator|.
name|contents
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|info
operator|.
name|contents
condition|)
block|{
if|if
condition|(
operator|!
name|info
operator|.
name|changed_contents
operator|&&
operator|!
name|link_info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|info
operator|.
name|contents
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Cache the section contents for elf_link_input_bfd.  */
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|info
operator|.
name|contents
expr_stmt|;
block|}
block|}
if|if
condition|(
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|!=
name|internal_relocs
condition|)
block|{
if|if
condition|(
operator|!
name|info
operator|.
name|changed_relocs
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
else|else
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|=
name|internal_relocs
expr_stmt|;
block|}
operator|*
name|again
operator|=
name|info
operator|.
name|changed_contents
operator|||
name|info
operator|.
name|changed_relocs
expr_stmt|;
return|return
name|TRUE
return|;
name|error_return
label|:
if|if
condition|(
name|isymbuf
operator|!=
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
condition|)
name|free
argument_list|(
name|isymbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|contents
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|info
operator|.
name|contents
condition|)
name|free
argument_list|(
name|info
operator|.
name|contents
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|!=
name|internal_relocs
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* PLT/GOT Stuff */
end_comment

begin_define
define|#
directive|define
name|PLT_HEADER_SIZE
value|32
end_define

begin_define
define|#
directive|define
name|PLT_HEADER_WORD1
value|(bfd_vma) 0xc3600000
end_define

begin_comment
comment|/* br   $27,.+4     */
end_comment

begin_define
define|#
directive|define
name|PLT_HEADER_WORD2
value|(bfd_vma) 0xa77b000c
end_define

begin_comment
comment|/* ldq  $27,12($27) */
end_comment

begin_define
define|#
directive|define
name|PLT_HEADER_WORD3
value|(bfd_vma) 0x47ff041f
end_define

begin_comment
comment|/* nop              */
end_comment

begin_define
define|#
directive|define
name|PLT_HEADER_WORD4
value|(bfd_vma) 0x6b7b0000
end_define

begin_comment
comment|/* jmp  $27,($27)   */
end_comment

begin_define
define|#
directive|define
name|PLT_ENTRY_SIZE
value|12
end_define

begin_define
define|#
directive|define
name|PLT_ENTRY_WORD1
value|0xc3800000
end_define

begin_comment
comment|/* br   $28, plt0   */
end_comment

begin_define
define|#
directive|define
name|PLT_ENTRY_WORD2
value|0
end_define

begin_define
define|#
directive|define
name|PLT_ENTRY_WORD3
value|0
end_define

begin_define
define|#
directive|define
name|MAX_GOT_SIZE
value|(64*1024)
end_define

begin_define
define|#
directive|define
name|ELF_DYNAMIC_INTERPRETER
value|"/usr/lib/ld.so"
end_define

begin_escape
end_escape

begin_comment
comment|/* Handle an Alpha specific section when reading an object file.  This    is called when elfcode.h finds a section with an unknown type.    FIXME: We need to handle the SHF_ALPHA_GPREL flag, but I'm not sure    how to.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf64_alpha_section_from_shdr
parameter_list|(
name|abfd
parameter_list|,
name|hdr
parameter_list|,
name|name
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|asection
modifier|*
name|newsect
decl_stmt|;
comment|/* There ought to be a place to keep ELF backend specific flags, but      at the moment there isn't one.  We just keep track of the      sections by their name, instead.  Fortunately, the ABI gives      suggested names for all the MIPS specific sections, so we will      probably get away with this.  */
switch|switch
condition|(
name|hdr
operator|->
name|sh_type
condition|)
block|{
case|case
name|SHT_ALPHA_DEBUG
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".mdebug"
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
break|break;
default|default:
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|_bfd_elf_make_section_from_shdr
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|newsect
operator|=
name|hdr
operator|->
name|bfd_section
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|sh_type
operator|==
name|SHT_ALPHA_DEBUG
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|newsect
argument_list|,
operator|(
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|newsect
argument_list|)
operator||
name|SEC_DEBUGGING
operator|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Convert Alpha specific section flags to bfd internal section flags.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf64_alpha_section_flags
parameter_list|(
name|flags
parameter_list|,
name|hdr
parameter_list|)
name|flagword
modifier|*
name|flags
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
block|{
if|if
condition|(
name|hdr
operator|->
name|sh_flags
operator|&
name|SHF_ALPHA_GPREL
condition|)
operator|*
name|flags
operator||=
name|SEC_SMALL_DATA
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Set the correct type for an Alpha ELF section.  We do this by the    section name, which is a hack, but ought to work.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf64_alpha_fake_sections
parameter_list|(
name|abfd
parameter_list|,
name|hdr
parameter_list|,
name|sec
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
block|{
specifier|register
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".mdebug"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_ALPHA_DEBUG
expr_stmt|;
comment|/* In a shared object on Irix 5.3, the .mdebug section has an          entsize of 0.  FIXME: Does this matter?  */
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
condition|)
name|hdr
operator|->
name|sh_entsize
operator|=
literal|0
expr_stmt|;
else|else
name|hdr
operator|->
name|sh_entsize
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_SMALL_DATA
operator|)
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sdata"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sbss"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".lit4"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".lit8"
argument_list|)
operator|==
literal|0
condition|)
name|hdr
operator|->
name|sh_flags
operator||=
name|SHF_ALPHA_GPREL
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Hook called by the linker routine which adds symbols from an object    file.  We use it to put .comm items in .sbss, and not .bss.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf64_alpha_add_symbol_hook
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|sym
parameter_list|,
name|namep
parameter_list|,
name|flagsp
parameter_list|,
name|secp
parameter_list|,
name|valp
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|namep
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|flagword
modifier|*
name|flagsp
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
modifier|*
name|secp
decl_stmt|;
name|bfd_vma
modifier|*
name|valp
decl_stmt|;
block|{
if|if
condition|(
name|sym
operator|->
name|st_shndx
operator|==
name|SHN_COMMON
operator|&&
operator|!
name|info
operator|->
name|relocatable
operator|&&
name|sym
operator|->
name|st_size
operator|<=
name|elf_gp_size
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
comment|/* Common symbols less than or equal to -G nn bytes are 	 automatically put into .sbss.  */
name|asection
modifier|*
name|scomm
init|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".scommon"
argument_list|)
decl_stmt|;
if|if
condition|(
name|scomm
operator|==
name|NULL
condition|)
block|{
name|scomm
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".scommon"
argument_list|)
expr_stmt|;
if|if
condition|(
name|scomm
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|scomm
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_IS_COMMON
operator||
name|SEC_LINKER_CREATED
operator|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
operator|*
name|secp
operator|=
name|scomm
expr_stmt|;
operator|*
name|valp
operator|=
name|sym
operator|->
name|st_size
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Create the .got section.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf64_alpha_create_got_section
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|asection
modifier|*
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".got"
argument_list|)
operator|)
condition|)
block|{
comment|/* Check for a non-linker created .got?  */
if|if
condition|(
name|alpha_elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|got
operator|==
name|NULL
condition|)
name|alpha_elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|got
operator|=
name|s
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator|)
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
literal|3
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|alpha_elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|got
operator|=
name|s
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Create all the dynamic sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf64_alpha_create_dynamic_sections
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|bh
decl_stmt|;
comment|/* We need to create .plt, .rela.plt, .got, and .rela.got sections.  */
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_CODE
operator|)
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
literal|3
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Define the symbol _PROCEDURE_LINKAGE_TABLE_ at the start of the      .plt section.  */
name|bh
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
literal|"_PROCEDURE_LINKAGE_TABLE_"
argument_list|,
name|BSF_GLOBAL
argument_list|,
name|s
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|collect
argument_list|,
operator|&
name|bh
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|bh
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_DEF_REGULAR
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|STT_OBJECT
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".rela.plt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_READONLY
operator|)
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
literal|3
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* We may or may not have created a .got section for this object, but      we definitely havn't done the rest of the work.  */
if|if
condition|(
operator|!
name|elf64_alpha_create_got_section
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_READONLY
operator|)
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
literal|3
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Define the symbol _GLOBAL_OFFSET_TABLE_ at the start of the      dynobj's .got section.  We don't do this in the linker script      because we don't want to define the symbol if we are not creating      a global offset table.  */
name|bh
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|,
name|BSF_GLOBAL
argument_list|,
name|alpha_elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|got
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|collect
argument_list|,
operator|&
name|bh
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|bh
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_DEF_REGULAR
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|STT_OBJECT
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|hgot
operator|=
name|h
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read ECOFF debugging information from a .mdebug section into a    ecoff_debug_info structure.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf64_alpha_read_ecoff_info
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|debug
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|struct
name|ecoff_debug_info
modifier|*
name|debug
decl_stmt|;
block|{
name|HDRR
modifier|*
name|symhdr
decl_stmt|;
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|swap
decl_stmt|;
name|char
modifier|*
name|ext_hdr
init|=
name|NULL
decl_stmt|;
name|swap
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_backend_ecoff_debug_swap
expr_stmt|;
name|memset
argument_list|(
name|debug
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|debug
argument_list|)
argument_list|)
expr_stmt|;
name|ext_hdr
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|swap
operator|->
name|external_hdr_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ext_hdr
operator|==
name|NULL
operator|&&
name|swap
operator|->
name|external_hdr_size
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|ext_hdr
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|swap
operator|->
name|external_hdr_size
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
name|symhdr
operator|=
operator|&
name|debug
operator|->
name|symbolic_header
expr_stmt|;
call|(
modifier|*
name|swap
operator|->
name|swap_hdr_in
call|)
argument_list|(
name|abfd
argument_list|,
name|ext_hdr
argument_list|,
name|symhdr
argument_list|)
expr_stmt|;
comment|/* The symbolic header contains absolute file offsets and sizes to      read.  */
define|#
directive|define
name|READ
parameter_list|(
name|ptr
parameter_list|,
name|offset
parameter_list|,
name|count
parameter_list|,
name|size
parameter_list|,
name|type
parameter_list|)
define|\
value|if (symhdr->count == 0)						\     debug->ptr = NULL;							\   else									\     {									\       bfd_size_type amt = (bfd_size_type) size * symhdr->count;		\       debug->ptr = (type) bfd_malloc (amt);				\       if (debug->ptr == NULL)						\ 	goto error_return;						\       if (bfd_seek (abfd, (file_ptr) symhdr->offset, SEEK_SET) != 0	\ 	  || bfd_bread (debug->ptr, amt, abfd) != amt)			\ 	goto error_return;						\     }
name|READ
argument_list|(
argument|line
argument_list|,
argument|cbLineOffset
argument_list|,
argument|cbLine
argument_list|,
argument|sizeof (unsigned char)
argument_list|,
argument|unsigned char *
argument_list|)
empty_stmt|;
name|READ
argument_list|(
name|external_dnr
argument_list|,
name|cbDnOffset
argument_list|,
name|idnMax
argument_list|,
name|swap
operator|->
name|external_dnr_size
argument_list|,
name|PTR
argument_list|)
expr_stmt|;
name|READ
argument_list|(
name|external_pdr
argument_list|,
name|cbPdOffset
argument_list|,
name|ipdMax
argument_list|,
name|swap
operator|->
name|external_pdr_size
argument_list|,
name|PTR
argument_list|)
expr_stmt|;
name|READ
argument_list|(
name|external_sym
argument_list|,
name|cbSymOffset
argument_list|,
name|isymMax
argument_list|,
name|swap
operator|->
name|external_sym_size
argument_list|,
name|PTR
argument_list|)
expr_stmt|;
name|READ
argument_list|(
name|external_opt
argument_list|,
name|cbOptOffset
argument_list|,
name|ioptMax
argument_list|,
name|swap
operator|->
name|external_opt_size
argument_list|,
name|PTR
argument_list|)
expr_stmt|;
name|READ
argument_list|(
name|external_aux
argument_list|,
name|cbAuxOffset
argument_list|,
name|iauxMax
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|aux_ext
argument_list|)
argument_list|,
expr|union
name|aux_ext
operator|*
argument_list|)
expr_stmt|;
name|READ
argument_list|(
name|ss
argument_list|,
name|cbSsOffset
argument_list|,
name|issMax
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|READ
argument_list|(
name|ssext
argument_list|,
name|cbSsExtOffset
argument_list|,
name|issExtMax
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|READ
argument_list|(
name|external_fdr
argument_list|,
name|cbFdOffset
argument_list|,
name|ifdMax
argument_list|,
name|swap
operator|->
name|external_fdr_size
argument_list|,
name|PTR
argument_list|)
expr_stmt|;
name|READ
argument_list|(
name|external_rfd
argument_list|,
name|cbRfdOffset
argument_list|,
name|crfd
argument_list|,
name|swap
operator|->
name|external_rfd_size
argument_list|,
name|PTR
argument_list|)
expr_stmt|;
name|READ
argument_list|(
name|external_ext
argument_list|,
name|cbExtOffset
argument_list|,
name|iextMax
argument_list|,
name|swap
operator|->
name|external_ext_size
argument_list|,
name|PTR
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|READ
name|debug
operator|->
name|fdr
operator|=
name|NULL
expr_stmt|;
name|debug
operator|->
name|adjust
operator|=
name|NULL
expr_stmt|;
return|return
name|TRUE
return|;
name|error_return
label|:
if|if
condition|(
name|ext_hdr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ext_hdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|line
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|external_dnr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|external_dnr
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|external_pdr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|external_pdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|external_sym
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|external_sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|external_opt
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|external_opt
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|external_aux
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|external_aux
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|ss
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|ss
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|ssext
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|ssext
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|external_fdr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|external_fdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|external_rfd
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|external_rfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|external_ext
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|external_ext
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Alpha ELF local labels start with '$'.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf64_alpha_is_local_label_name
parameter_list|(
name|abfd
parameter_list|,
name|name
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
return|return
name|name
index|[
literal|0
index|]
operator|==
literal|'$'
return|;
block|}
end_function

begin_comment
comment|/* Alpha ELF follows MIPS ELF in using a special find_nearest_line    routine in order to handle the ECOFF debugging information.  We    still call this mips_elf_find_line because of the slot    find_line_info in elf_obj_tdata is declared that way.  */
end_comment

begin_struct
struct|struct
name|mips_elf_find_line
block|{
name|struct
name|ecoff_debug_info
name|d
decl_stmt|;
name|struct
name|ecoff_find_line
name|i
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|bfd_boolean
name|elf64_alpha_find_nearest_line
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|symbols
parameter_list|,
name|offset
parameter_list|,
name|filename_ptr
parameter_list|,
name|functionname_ptr
parameter_list|,
name|line_ptr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|filename_ptr
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|functionname_ptr
decl_stmt|;
name|unsigned
name|int
modifier|*
name|line_ptr
decl_stmt|;
block|{
name|asection
modifier|*
name|msec
decl_stmt|;
if|if
condition|(
name|_bfd_dwarf2_find_nearest_line
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|symbols
argument_list|,
name|offset
argument_list|,
name|filename_ptr
argument_list|,
name|functionname_ptr
argument_list|,
name|line_ptr
argument_list|,
literal|0
argument_list|,
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|dwarf2_find_line_info
argument_list|)
condition|)
return|return
name|TRUE
return|;
name|msec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".mdebug"
argument_list|)
expr_stmt|;
if|if
condition|(
name|msec
operator|!=
name|NULL
condition|)
block|{
name|flagword
name|origflags
decl_stmt|;
name|struct
name|mips_elf_find_line
modifier|*
name|fi
decl_stmt|;
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
specifier|const
name|swap
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_backend_ecoff_debug_swap
decl_stmt|;
comment|/* If we are called during a link, alpha_elf_final_link may have 	 cleared the SEC_HAS_CONTENTS field.  We force it back on here 	 if appropriate (which it normally will be).  */
name|origflags
operator|=
name|msec
operator|->
name|flags
expr_stmt|;
if|if
condition|(
name|elf_section_data
argument_list|(
name|msec
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_type
operator|!=
name|SHT_NOBITS
condition|)
name|msec
operator|->
name|flags
operator||=
name|SEC_HAS_CONTENTS
expr_stmt|;
name|fi
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|find_line_info
expr_stmt|;
if|if
condition|(
name|fi
operator|==
name|NULL
condition|)
block|{
name|bfd_size_type
name|external_fdr_size
decl_stmt|;
name|char
modifier|*
name|fraw_src
decl_stmt|;
name|char
modifier|*
name|fraw_end
decl_stmt|;
name|struct
name|fdr
modifier|*
name|fdr_ptr
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|mips_elf_find_line
argument_list|)
decl_stmt|;
name|fi
operator|=
operator|(
expr|struct
name|mips_elf_find_line
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|==
name|NULL
condition|)
block|{
name|msec
operator|->
name|flags
operator|=
name|origflags
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|elf64_alpha_read_ecoff_info
argument_list|(
name|abfd
argument_list|,
name|msec
argument_list|,
operator|&
name|fi
operator|->
name|d
argument_list|)
condition|)
block|{
name|msec
operator|->
name|flags
operator|=
name|origflags
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Swap in the FDR information.  */
name|amt
operator|=
name|fi
operator|->
name|d
operator|.
name|symbolic_header
operator|.
name|ifdMax
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|fdr
argument_list|)
expr_stmt|;
name|fi
operator|->
name|d
operator|.
name|fdr
operator|=
operator|(
expr|struct
name|fdr
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|->
name|d
operator|.
name|fdr
operator|==
name|NULL
condition|)
block|{
name|msec
operator|->
name|flags
operator|=
name|origflags
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|external_fdr_size
operator|=
name|swap
operator|->
name|external_fdr_size
expr_stmt|;
name|fdr_ptr
operator|=
name|fi
operator|->
name|d
operator|.
name|fdr
expr_stmt|;
name|fraw_src
operator|=
operator|(
name|char
operator|*
operator|)
name|fi
operator|->
name|d
operator|.
name|external_fdr
expr_stmt|;
name|fraw_end
operator|=
operator|(
name|fraw_src
operator|+
name|fi
operator|->
name|d
operator|.
name|symbolic_header
operator|.
name|ifdMax
operator|*
name|external_fdr_size
operator|)
expr_stmt|;
for|for
control|(
init|;
name|fraw_src
operator|<
name|fraw_end
condition|;
name|fraw_src
operator|+=
name|external_fdr_size
operator|,
name|fdr_ptr
operator|++
control|)
call|(
modifier|*
name|swap
operator|->
name|swap_fdr_in
call|)
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|fraw_src
argument_list|,
name|fdr_ptr
argument_list|)
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|find_line_info
operator|=
name|fi
expr_stmt|;
comment|/* Note that we don't bother to ever free this information.              find_nearest_line is either called all the time, as in              objdump -l, so the information should be saved, or it is              rarely called, as in ld error messages, so the memory              wasted is unimportant.  Still, it would probably be a              good idea for free_cached_info to throw it away.  */
block|}
if|if
condition|(
name|_bfd_ecoff_locate_line
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|offset
argument_list|,
operator|&
name|fi
operator|->
name|d
argument_list|,
name|swap
argument_list|,
operator|&
name|fi
operator|->
name|i
argument_list|,
name|filename_ptr
argument_list|,
name|functionname_ptr
argument_list|,
name|line_ptr
argument_list|)
condition|)
block|{
name|msec
operator|->
name|flags
operator|=
name|origflags
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|msec
operator|->
name|flags
operator|=
name|origflags
expr_stmt|;
block|}
comment|/* Fall back on the generic ELF find_nearest_line routine.  */
return|return
name|_bfd_elf_find_nearest_line
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|symbols
argument_list|,
name|offset
argument_list|,
name|filename_ptr
argument_list|,
name|functionname_ptr
argument_list|,
name|line_ptr
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Structure used to pass information to alpha_elf_output_extsym.  */
end_comment

begin_struct
struct|struct
name|extsym_info
block|{
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|ecoff_debug_info
modifier|*
name|debug
decl_stmt|;
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|swap
decl_stmt|;
name|bfd_boolean
name|failed
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|bfd_boolean
name|elf64_alpha_output_extsym
parameter_list|(
name|h
parameter_list|,
name|data
parameter_list|)
name|struct
name|alpha_elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
name|struct
name|extsym_info
modifier|*
name|einfo
init|=
operator|(
expr|struct
name|extsym_info
operator|*
operator|)
name|data
decl_stmt|;
name|bfd_boolean
name|strip
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|,
modifier|*
name|output_section
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|alpha_elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|indx
operator|==
operator|-
literal|2
condition|)
name|strip
operator|=
name|FALSE
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|(
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|||
operator|(
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_REF_DYNAMIC
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_REF_REGULAR
operator|)
operator|==
literal|0
condition|)
name|strip
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|einfo
operator|->
name|info
operator|->
name|strip
operator|==
name|strip_all
operator|||
operator|(
name|einfo
operator|->
name|info
operator|->
name|strip
operator|==
name|strip_some
operator|&&
name|bfd_hash_lookup
argument_list|(
name|einfo
operator|->
name|info
operator|->
name|keep_hash
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
operator|==
name|NULL
operator|)
condition|)
name|strip
operator|=
name|TRUE
expr_stmt|;
else|else
name|strip
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|strip
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|h
operator|->
name|esym
operator|.
name|ifd
operator|==
operator|-
literal|2
condition|)
block|{
name|h
operator|->
name|esym
operator|.
name|jmptbl
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|cobol_main
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|weakext
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|reserved
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|ifd
operator|=
name|ifdNil
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|st
operator|=
name|stGlobal
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defined
operator|&&
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scAbs
expr_stmt|;
else|else
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|sec
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|output_section
operator|=
name|sec
operator|->
name|output_section
expr_stmt|;
comment|/* When making a shared library and symbol h is the one from 	     the another shared library, OUTPUT_SECTION may be null.  */
if|if
condition|(
name|output_section
operator|==
name|NULL
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scUndefined
expr_stmt|;
else|else
block|{
name|name
operator|=
name|bfd_section_name
argument_list|(
name|output_section
operator|->
name|owner
argument_list|,
name|output_section
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".text"
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scText
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".data"
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scData
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sdata"
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scSData
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".rodata"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".rdata"
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scRData
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".bss"
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scBss
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sbss"
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scSBss
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".init"
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scInit
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".fini"
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scFini
expr_stmt|;
else|else
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scAbs
expr_stmt|;
block|}
block|}
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|reserved
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|index
operator|=
name|indexNil
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_common
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|size
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|==
name|scCommon
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scBss
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|==
name|scSCommon
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scSBss
expr_stmt|;
name|sec
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|output_section
operator|=
name|sec
operator|->
name|output_section
expr_stmt|;
if|if
condition|(
name|output_section
operator|!=
name|NULL
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
else|else
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_NEEDS_PLT
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Set type and value for a symbol with a function stub.  */
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|st
operator|=
name|stProc
expr_stmt|;
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|einfo
operator|->
name|abfd
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|output_section
operator|=
name|sec
operator|->
name|output_section
expr_stmt|;
if|if
condition|(
name|output_section
operator|!=
name|NULL
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|plt
operator|.
name|offset
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
else|else
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|bfd_ecoff_debug_one_external
argument_list|(
name|einfo
operator|->
name|abfd
argument_list|,
name|einfo
operator|->
name|debug
argument_list|,
name|einfo
operator|->
name|swap
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
operator|&
name|h
operator|->
name|esym
argument_list|)
condition|)
block|{
name|einfo
operator|->
name|failed
operator|=
name|TRUE
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Search for and possibly create a got entry.  */
end_comment

begin_function
specifier|static
name|struct
name|alpha_elf_got_entry
modifier|*
name|get_got_entry
parameter_list|(
name|abfd
parameter_list|,
name|h
parameter_list|,
name|r_type
parameter_list|,
name|r_symndx
parameter_list|,
name|r_addend
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|alpha_elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|unsigned
name|long
name|r_type
decl_stmt|,
name|r_symndx
decl_stmt|;
name|bfd_vma
name|r_addend
decl_stmt|;
block|{
name|struct
name|alpha_elf_got_entry
modifier|*
name|gotent
decl_stmt|;
name|struct
name|alpha_elf_got_entry
modifier|*
modifier|*
name|slot
decl_stmt|;
if|if
condition|(
name|h
condition|)
name|slot
operator|=
operator|&
name|h
operator|->
name|got_entries
expr_stmt|;
else|else
block|{
comment|/* This is a local .got entry -- record for merge.  */
name|struct
name|alpha_elf_got_entry
modifier|*
modifier|*
name|local_got_entries
decl_stmt|;
name|local_got_entries
operator|=
name|alpha_elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|local_got_entries
expr_stmt|;
if|if
condition|(
operator|!
name|local_got_entries
condition|)
block|{
name|bfd_size_type
name|size
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|size
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|size
operator|*=
sizeof|sizeof
argument_list|(
expr|struct
name|alpha_elf_got_entry
operator|*
argument_list|)
expr_stmt|;
name|local_got_entries
operator|=
operator|(
expr|struct
name|alpha_elf_got_entry
operator|*
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|local_got_entries
condition|)
return|return
name|NULL
return|;
name|alpha_elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|local_got_entries
operator|=
name|local_got_entries
expr_stmt|;
block|}
name|slot
operator|=
operator|&
name|local_got_entries
index|[
name|r_symndx
index|]
expr_stmt|;
block|}
for|for
control|(
name|gotent
operator|=
operator|*
name|slot
init|;
name|gotent
condition|;
name|gotent
operator|=
name|gotent
operator|->
name|next
control|)
if|if
condition|(
name|gotent
operator|->
name|gotobj
operator|==
name|abfd
operator|&&
name|gotent
operator|->
name|reloc_type
operator|==
name|r_type
operator|&&
name|gotent
operator|->
name|addend
operator|==
name|r_addend
condition|)
break|break;
if|if
condition|(
operator|!
name|gotent
condition|)
block|{
name|int
name|entry_size
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|alpha_elf_got_entry
argument_list|)
expr_stmt|;
name|gotent
operator|=
operator|(
expr|struct
name|alpha_elf_got_entry
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gotent
condition|)
return|return
name|NULL
return|;
name|gotent
operator|->
name|gotobj
operator|=
name|abfd
expr_stmt|;
name|gotent
operator|->
name|addend
operator|=
name|r_addend
expr_stmt|;
name|gotent
operator|->
name|got_offset
operator|=
operator|-
literal|1
expr_stmt|;
name|gotent
operator|->
name|use_count
operator|=
literal|1
expr_stmt|;
name|gotent
operator|->
name|reloc_type
operator|=
name|r_type
expr_stmt|;
name|gotent
operator|->
name|reloc_done
operator|=
literal|0
expr_stmt|;
name|gotent
operator|->
name|reloc_xlated
operator|=
literal|0
expr_stmt|;
name|gotent
operator|->
name|next
operator|=
operator|*
name|slot
expr_stmt|;
operator|*
name|slot
operator|=
name|gotent
expr_stmt|;
name|entry_size
operator|=
name|alpha_got_entry_size
argument_list|(
name|r_type
argument_list|)
expr_stmt|;
name|alpha_elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|total_got_size
operator|+=
name|entry_size
expr_stmt|;
if|if
condition|(
operator|!
name|h
condition|)
name|alpha_elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|local_got_size
operator|+=
name|entry_size
expr_stmt|;
block|}
else|else
name|gotent
operator|->
name|use_count
operator|+=
literal|1
expr_stmt|;
return|return
name|gotent
return|;
block|}
end_function

begin_comment
comment|/* Handle dynamic relocations when doing an Alpha ELF link.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf64_alpha_check_relocs
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|sec
parameter_list|,
name|relocs
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|;
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|sreloc
decl_stmt|;
specifier|const
name|char
modifier|*
name|rel_sec_name
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|alpha_elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|,
modifier|*
name|relend
decl_stmt|;
name|bfd_boolean
name|got_created
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
return|return
name|TRUE
return|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
if|if
condition|(
name|dynobj
operator|==
name|NULL
condition|)
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
operator|=
name|dynobj
operator|=
name|abfd
expr_stmt|;
name|sreloc
operator|=
name|NULL
expr_stmt|;
name|rel_sec_name
operator|=
name|NULL
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|alpha_elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|got_created
operator|=
name|FALSE
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|relend
condition|;
operator|++
name|rel
control|)
block|{
enum|enum
block|{
name|NEED_GOT
init|=
literal|1
block|,
name|NEED_GOT_ENTRY
init|=
literal|2
block|,
name|NEED_DYNREL
init|=
literal|4
block|}
enum|;
name|unsigned
name|long
name|r_symndx
decl_stmt|,
name|r_type
decl_stmt|;
name|struct
name|alpha_elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|unsigned
name|int
name|gotent_flags
decl_stmt|;
name|bfd_boolean
name|maybe_dynamic
decl_stmt|;
name|unsigned
name|int
name|need
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|;
name|r_symndx
operator|=
name|ELF64_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
name|h
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|alpha_elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_REF_REGULAR
expr_stmt|;
block|}
comment|/* We can only get preliminary data on whether a symbol is          locally or externally defined, as not all of the input files          have yet been processed.  Do something with what we know, as          this may help reduce memory usage and processing time later.  */
name|maybe_dynamic
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|h
operator|&&
operator|(
operator|(
name|info
operator|->
name|shared
operator|&&
operator|(
operator|!
name|info
operator|->
name|symbolic
operator|||
name|info
operator|->
name|unresolved_syms_in_shared_libs
operator|==
name|RM_IGNORE
operator|)
operator|)
operator|||
operator|!
operator|(
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|||
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
condition|)
name|maybe_dynamic
operator|=
name|TRUE
expr_stmt|;
name|need
operator|=
literal|0
expr_stmt|;
name|gotent_flags
operator|=
literal|0
expr_stmt|;
name|r_type
operator|=
name|ELF64_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|addend
operator|=
name|rel
operator|->
name|r_addend
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_ALPHA_LITERAL
case|:
name|need
operator|=
name|NEED_GOT
operator||
name|NEED_GOT_ENTRY
expr_stmt|;
comment|/* Remember how this literal is used from its LITUSEs. 	     This will be important when it comes to decide if we can 	     create a .plt entry for a function symbol.  */
while|while
condition|(
operator|++
name|rel
operator|<
name|relend
operator|&&
name|ELF64_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|==
name|R_ALPHA_LITUSE
condition|)
if|if
condition|(
name|rel
operator|->
name|r_addend
operator|>=
literal|1
operator|&&
name|rel
operator|->
name|r_addend
operator|<=
literal|5
condition|)
name|gotent_flags
operator||=
literal|1
operator|<<
name|rel
operator|->
name|r_addend
expr_stmt|;
operator|--
name|rel
expr_stmt|;
comment|/* No LITUSEs -- presumably the address is used somehow.  */
if|if
condition|(
name|gotent_flags
operator|==
literal|0
condition|)
name|gotent_flags
operator|=
name|ALPHA_ELF_LINK_HASH_LU_ADDR
expr_stmt|;
break|break;
case|case
name|R_ALPHA_GPDISP
case|:
case|case
name|R_ALPHA_GPREL16
case|:
case|case
name|R_ALPHA_GPREL32
case|:
case|case
name|R_ALPHA_GPRELHIGH
case|:
case|case
name|R_ALPHA_GPRELLOW
case|:
case|case
name|R_ALPHA_BRSGP
case|:
name|need
operator|=
name|NEED_GOT
expr_stmt|;
break|break;
case|case
name|R_ALPHA_REFLONG
case|:
case|case
name|R_ALPHA_REFQUAD
case|:
if|if
condition|(
operator|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|)
operator|||
name|maybe_dynamic
condition|)
name|need
operator|=
name|NEED_DYNREL
expr_stmt|;
break|break;
case|case
name|R_ALPHA_TLSLDM
case|:
comment|/* The symbol for a TLSLDM reloc is ignored.  Collapse the 	     reloc to the 0 symbol so that they all match.  */
name|r_symndx
operator|=
literal|0
expr_stmt|;
name|h
operator|=
literal|0
expr_stmt|;
name|maybe_dynamic
operator|=
name|FALSE
expr_stmt|;
comment|/* FALLTHRU */
case|case
name|R_ALPHA_TLSGD
case|:
case|case
name|R_ALPHA_GOTDTPREL
case|:
name|need
operator|=
name|NEED_GOT
operator||
name|NEED_GOT_ENTRY
expr_stmt|;
break|break;
case|case
name|R_ALPHA_GOTTPREL
case|:
name|need
operator|=
name|NEED_GOT
operator||
name|NEED_GOT_ENTRY
expr_stmt|;
name|gotent_flags
operator|=
name|ALPHA_ELF_LINK_HASH_TLS_IE
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
name|info
operator|->
name|flags
operator||=
name|DF_STATIC_TLS
expr_stmt|;
break|break;
case|case
name|R_ALPHA_TPREL64
case|:
if|if
condition|(
name|info
operator|->
name|shared
operator|||
name|maybe_dynamic
condition|)
name|need
operator|=
name|NEED_DYNREL
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
name|info
operator|->
name|flags
operator||=
name|DF_STATIC_TLS
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|need
operator|&
name|NEED_GOT
condition|)
block|{
if|if
condition|(
operator|!
name|got_created
condition|)
block|{
if|if
condition|(
operator|!
name|elf64_alpha_create_got_section
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Make sure the object's gotobj is set to itself so 		 that we default to every object with its own .got. 		 We'll merge .gots later once we've collected each 		 object's info.  */
name|alpha_elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|gotobj
operator|=
name|abfd
expr_stmt|;
name|got_created
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|need
operator|&
name|NEED_GOT_ENTRY
condition|)
block|{
name|struct
name|alpha_elf_got_entry
modifier|*
name|gotent
decl_stmt|;
name|gotent
operator|=
name|get_got_entry
argument_list|(
name|abfd
argument_list|,
name|h
argument_list|,
name|r_type
argument_list|,
name|r_symndx
argument_list|,
name|addend
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gotent
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|gotent_flags
condition|)
block|{
name|gotent
operator|->
name|flags
operator||=
name|gotent_flags
expr_stmt|;
if|if
condition|(
name|h
condition|)
block|{
name|gotent_flags
operator||=
name|h
operator|->
name|flags
expr_stmt|;
name|h
operator|->
name|flags
operator|=
name|gotent_flags
expr_stmt|;
comment|/* Make a guess as to whether a .plt entry is needed.  */
if|if
condition|(
operator|(
name|gotent_flags
operator|&
name|ALPHA_ELF_LINK_HASH_LU_FUNC
operator|)
operator|&&
operator|!
operator|(
name|gotent_flags
operator|&
operator|~
name|ALPHA_ELF_LINK_HASH_LU_FUNC
operator|)
condition|)
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_NEEDS_PLT
expr_stmt|;
else|else
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_HASH_NEEDS_PLT
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|need
operator|&
name|NEED_DYNREL
condition|)
block|{
if|if
condition|(
name|rel_sec_name
operator|==
name|NULL
condition|)
block|{
name|rel_sec_name
operator|=
operator|(
name|bfd_elf_string_from_elf_section
argument_list|(
name|abfd
argument_list|,
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_shstrndx
argument_list|,
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|rel_hdr
operator|.
name|sh_name
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|rel_sec_name
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|BFD_ASSERT
argument_list|(
name|strncmp
argument_list|(
name|rel_sec_name
argument_list|,
literal|".rela"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|,
name|rel_sec_name
operator|+
literal|5
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* We need to create the section here now whether we eventually 	     use it or not so that it gets mapped to an output section by 	     the linker.  If not used, we'll kill it in 	     size_dynamic_sections.  */
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
block|{
name|sreloc
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|rel_sec_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
block|{
name|flagword
name|flags
decl_stmt|;
name|sreloc
operator|=
name|bfd_make_section
argument_list|(
name|dynobj
argument_list|,
name|rel_sec_name
argument_list|)
expr_stmt|;
name|flags
operator|=
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_READONLY
operator|)
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
condition|)
name|flags
operator||=
name|SEC_ALLOC
operator||
name|SEC_LOAD
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|dynobj
argument_list|,
name|sreloc
argument_list|,
name|flags
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|sreloc
argument_list|,
literal|3
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
if|if
condition|(
name|h
condition|)
block|{
comment|/* Since we havn't seen all of the input symbols yet, we 		 don't know whether we'll actually need a dynamic relocation 		 entry for this reloc.  So make a record of it.  Once we 		 find out if this thing needs dynamic relocation we'll 		 expand the relocation sections by the appropriate amount.  */
name|struct
name|alpha_elf_reloc_entry
modifier|*
name|rent
decl_stmt|;
for|for
control|(
name|rent
operator|=
name|h
operator|->
name|reloc_entries
init|;
name|rent
condition|;
name|rent
operator|=
name|rent
operator|->
name|next
control|)
if|if
condition|(
name|rent
operator|->
name|rtype
operator|==
name|r_type
operator|&&
name|rent
operator|->
name|srel
operator|==
name|sreloc
condition|)
break|break;
if|if
condition|(
operator|!
name|rent
condition|)
block|{
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|alpha_elf_reloc_entry
argument_list|)
expr_stmt|;
name|rent
operator|=
operator|(
expr|struct
name|alpha_elf_reloc_entry
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rent
condition|)
return|return
name|FALSE
return|;
name|rent
operator|->
name|srel
operator|=
name|sreloc
expr_stmt|;
name|rent
operator|->
name|rtype
operator|=
name|r_type
expr_stmt|;
name|rent
operator|->
name|count
operator|=
literal|1
expr_stmt|;
name|rent
operator|->
name|reltext
operator|=
operator|(
operator|(
name|sec
operator|->
name|flags
operator|&
operator|(
name|SEC_READONLY
operator||
name|SEC_ALLOC
operator|)
operator|)
operator|==
operator|(
name|SEC_READONLY
operator||
name|SEC_ALLOC
operator|)
operator|)
expr_stmt|;
name|rent
operator|->
name|next
operator|=
name|h
operator|->
name|reloc_entries
expr_stmt|;
name|h
operator|->
name|reloc_entries
operator|=
name|rent
expr_stmt|;
block|}
else|else
name|rent
operator|->
name|count
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
comment|/* If this is a shared library, and the section is to be 		 loaded into memory, we need a RELATIVE reloc.  */
name|sreloc
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
operator|(
name|SEC_READONLY
operator||
name|SEC_ALLOC
operator|)
operator|)
operator|==
operator|(
name|SEC_READONLY
operator||
name|SEC_ALLOC
operator|)
condition|)
name|info
operator|->
name|flags
operator||=
name|DF_TEXTREL
expr_stmt|;
block|}
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Adjust a symbol defined by a dynamic object and referenced by a    regular object.  The current definition is in some section of the    dynamic object, but we're not including those sections.  We have to    change the definition to something the rest of the link can    understand.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf64_alpha_adjust_dynamic_symbol
parameter_list|(
name|info
parameter_list|,
name|h
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|struct
name|alpha_elf_link_hash_entry
modifier|*
name|ah
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|ah
operator|=
operator|(
expr|struct
name|alpha_elf_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
comment|/* Now that we've seen all of the input symbols, finalize our decision      about whether this symbol should get a .plt entry.  */
if|if
condition|(
name|alpha_elf_dynamic_symbol_p
argument_list|(
name|h
argument_list|,
name|info
argument_list|)
operator|&&
operator|(
operator|(
name|h
operator|->
name|type
operator|==
name|STT_FUNC
operator|&&
operator|!
operator|(
name|ah
operator|->
name|flags
operator|&
name|ALPHA_ELF_LINK_HASH_LU_ADDR
operator|)
operator|)
operator|||
operator|(
name|h
operator|->
name|type
operator|==
name|STT_NOTYPE
operator|&&
operator|(
name|ah
operator|->
name|flags
operator|&
name|ALPHA_ELF_LINK_HASH_LU_FUNC
operator|)
operator|&&
operator|!
operator|(
name|ah
operator|->
name|flags
operator|&
operator|~
name|ALPHA_ELF_LINK_HASH_LU_FUNC
operator|)
operator|)
operator|)
comment|/* Don't prevent otherwise valid programs from linking by attempting 	 to create a new .got entry somewhere.  A Correct Solution would be 	 to add a new .got section to a new object file and let it be merged 	 somewhere later.  But for now don't bother.  */
operator|&&
name|ah
operator|->
name|got_entries
condition|)
block|{
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_NEEDS_PLT
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
operator|&&
operator|!
name|elf64_alpha_create_dynamic_sections
argument_list|(
name|dynobj
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* The first bit of the .plt is reserved.  */
if|if
condition|(
name|s
operator|->
name|_raw_size
operator|==
literal|0
condition|)
name|s
operator|->
name|_raw_size
operator|=
name|PLT_HEADER_SIZE
expr_stmt|;
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|+=
name|PLT_ENTRY_SIZE
expr_stmt|;
comment|/* If this symbol is not defined in a regular file, and we are not 	 generating a shared library, then set the symbol to the location 	 in the .plt.  This is required to make function pointers compare 	 equal between the normal executable and the shared library.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
condition|)
block|{
name|ah
operator|->
name|plt_old_section
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|ah
operator|->
name|plt_old_value
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
name|ah
operator|->
name|flags
operator||=
name|ALPHA_ELF_LINK_HASH_PLT_LOC
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|s
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|h
operator|->
name|plt
operator|.
name|offset
expr_stmt|;
block|}
comment|/* We also need a JMP_SLOT entry in the .rela.plt section.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.plt"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
else|else
name|h
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_HASH_NEEDS_PLT
expr_stmt|;
comment|/* If this is a weak symbol, and there is a real definition, the      processor independent code will have arranged for us to see the      real definition first, and we can just use the same value.  */
if|if
condition|(
name|h
operator|->
name|weakdef
operator|!=
name|NULL
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
argument_list|)
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* This is a reference to a symbol defined by a dynamic object which      is not a function.  The Alpha, since it uses .got entries for all      symbols even in regular objects, does not need the hackery of a      .dynbss section and COPY dynamic relocations.  */
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Symbol versioning can create new symbols, and make our old symbols    indirect to the new ones.  Consolidate the got and reloc information    in these situations.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf64_alpha_merge_ind_symbols
parameter_list|(
name|hi
parameter_list|,
name|dummy
parameter_list|)
name|struct
name|alpha_elf_link_hash_entry
modifier|*
name|hi
decl_stmt|;
name|PTR
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|struct
name|alpha_elf_link_hash_entry
modifier|*
name|hs
decl_stmt|;
if|if
condition|(
name|hi
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_indirect
condition|)
return|return
name|TRUE
return|;
name|hs
operator|=
name|hi
expr_stmt|;
do|do
block|{
name|hs
operator|=
operator|(
expr|struct
name|alpha_elf_link_hash_entry
operator|*
operator|)
name|hs
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
block|}
do|while
condition|(
name|hs
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
condition|)
do|;
comment|/* Merge the flags.  Whee.  */
name|hs
operator|->
name|flags
operator||=
name|hi
operator|->
name|flags
expr_stmt|;
comment|/* Merge the .got entries.  Cannibalize the old symbol's list in      doing so, since we don't need it anymore.  */
if|if
condition|(
name|hs
operator|->
name|got_entries
operator|==
name|NULL
condition|)
name|hs
operator|->
name|got_entries
operator|=
name|hi
operator|->
name|got_entries
expr_stmt|;
else|else
block|{
name|struct
name|alpha_elf_got_entry
modifier|*
name|gi
decl_stmt|,
modifier|*
name|gs
decl_stmt|,
modifier|*
name|gin
decl_stmt|,
modifier|*
name|gsh
decl_stmt|;
name|gsh
operator|=
name|hs
operator|->
name|got_entries
expr_stmt|;
for|for
control|(
name|gi
operator|=
name|hi
operator|->
name|got_entries
init|;
name|gi
condition|;
name|gi
operator|=
name|gin
control|)
block|{
name|gin
operator|=
name|gi
operator|->
name|next
expr_stmt|;
for|for
control|(
name|gs
operator|=
name|gsh
init|;
name|gs
condition|;
name|gs
operator|=
name|gs
operator|->
name|next
control|)
if|if
condition|(
name|gi
operator|->
name|gotobj
operator|==
name|gs
operator|->
name|gotobj
operator|&&
name|gi
operator|->
name|reloc_type
operator|==
name|gs
operator|->
name|reloc_type
operator|&&
name|gi
operator|->
name|addend
operator|==
name|gs
operator|->
name|addend
condition|)
block|{
name|gi
operator|->
name|use_count
operator|+=
name|gs
operator|->
name|use_count
expr_stmt|;
goto|goto
name|got_found
goto|;
block|}
name|gi
operator|->
name|next
operator|=
name|hs
operator|->
name|got_entries
expr_stmt|;
name|hs
operator|->
name|got_entries
operator|=
name|gi
expr_stmt|;
name|got_found
label|:
empty_stmt|;
block|}
block|}
name|hi
operator|->
name|got_entries
operator|=
name|NULL
expr_stmt|;
comment|/* And similar for the reloc entries.  */
if|if
condition|(
name|hs
operator|->
name|reloc_entries
operator|==
name|NULL
condition|)
name|hs
operator|->
name|reloc_entries
operator|=
name|hi
operator|->
name|reloc_entries
expr_stmt|;
else|else
block|{
name|struct
name|alpha_elf_reloc_entry
modifier|*
name|ri
decl_stmt|,
modifier|*
name|rs
decl_stmt|,
modifier|*
name|rin
decl_stmt|,
modifier|*
name|rsh
decl_stmt|;
name|rsh
operator|=
name|hs
operator|->
name|reloc_entries
expr_stmt|;
for|for
control|(
name|ri
operator|=
name|hi
operator|->
name|reloc_entries
init|;
name|ri
condition|;
name|ri
operator|=
name|rin
control|)
block|{
name|rin
operator|=
name|ri
operator|->
name|next
expr_stmt|;
for|for
control|(
name|rs
operator|=
name|rsh
init|;
name|rs
condition|;
name|rs
operator|=
name|rs
operator|->
name|next
control|)
if|if
condition|(
name|ri
operator|->
name|rtype
operator|==
name|rs
operator|->
name|rtype
operator|&&
name|ri
operator|->
name|srel
operator|==
name|rs
operator|->
name|srel
condition|)
block|{
name|rs
operator|->
name|count
operator|+=
name|ri
operator|->
name|count
expr_stmt|;
goto|goto
name|found_reloc
goto|;
block|}
name|ri
operator|->
name|next
operator|=
name|hs
operator|->
name|reloc_entries
expr_stmt|;
name|hs
operator|->
name|reloc_entries
operator|=
name|ri
expr_stmt|;
name|found_reloc
label|:
empty_stmt|;
block|}
block|}
name|hi
operator|->
name|reloc_entries
operator|=
name|NULL
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Is it possible to merge two object file's .got tables?  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf64_alpha_can_merge_gots
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|bfd
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|;
end_function

begin_block
block|{
name|int
name|total
init|=
name|alpha_elf_tdata
argument_list|(
name|a
argument_list|)
operator|->
name|total_got_size
decl_stmt|;
name|bfd
modifier|*
name|bsub
decl_stmt|;
comment|/* Trivial quick fallout test.  */
if|if
condition|(
name|total
operator|+
name|alpha_elf_tdata
argument_list|(
name|b
argument_list|)
operator|->
name|total_got_size
operator|<=
name|MAX_GOT_SIZE
condition|)
return|return
name|TRUE
return|;
comment|/* By their nature, local .got entries cannot be merged.  */
if|if
condition|(
operator|(
name|total
operator|+=
name|alpha_elf_tdata
argument_list|(
name|b
argument_list|)
operator|->
name|local_got_size
operator|)
operator|>
name|MAX_GOT_SIZE
condition|)
return|return
name|FALSE
return|;
comment|/* Failing the common trivial comparison, we must effectively      perform the merge.  Not actually performing the merge means that      we don't have to store undo information in case we fail.  */
for|for
control|(
name|bsub
operator|=
name|b
init|;
name|bsub
condition|;
name|bsub
operator|=
name|alpha_elf_tdata
argument_list|(
name|bsub
argument_list|)
operator|->
name|in_got_link_next
control|)
block|{
name|struct
name|alpha_elf_link_hash_entry
modifier|*
modifier|*
name|hashes
init|=
name|alpha_elf_sym_hashes
argument_list|(
name|bsub
argument_list|)
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
init|=
operator|&
name|elf_tdata
argument_list|(
name|bsub
argument_list|)
operator|->
name|symtab_hdr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|n
operator|=
name|NUM_SHDR_ENTRIES
argument_list|(
name|symtab_hdr
argument_list|)
operator|-
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|alpha_elf_got_entry
modifier|*
name|ae
decl_stmt|,
modifier|*
name|be
decl_stmt|;
name|struct
name|alpha_elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
name|hashes
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|alpha_elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
for|for
control|(
name|be
operator|=
name|h
operator|->
name|got_entries
init|;
name|be
condition|;
name|be
operator|=
name|be
operator|->
name|next
control|)
block|{
if|if
condition|(
name|be
operator|->
name|use_count
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|be
operator|->
name|gotobj
operator|!=
name|b
condition|)
continue|continue;
for|for
control|(
name|ae
operator|=
name|h
operator|->
name|got_entries
init|;
name|ae
condition|;
name|ae
operator|=
name|ae
operator|->
name|next
control|)
if|if
condition|(
name|ae
operator|->
name|gotobj
operator|==
name|a
operator|&&
name|ae
operator|->
name|reloc_type
operator|==
name|be
operator|->
name|reloc_type
operator|&&
name|ae
operator|->
name|addend
operator|==
name|be
operator|->
name|addend
condition|)
goto|goto
name|global_found
goto|;
name|total
operator|+=
name|alpha_got_entry_size
argument_list|(
name|be
operator|->
name|reloc_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|total
operator|>
name|MAX_GOT_SIZE
condition|)
return|return
name|FALSE
return|;
name|global_found
label|:
empty_stmt|;
block|}
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_block

begin_comment
comment|/* Actually merge two .got tables.  */
end_comment

begin_function
specifier|static
name|void
name|elf64_alpha_merge_gots
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|bfd
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|;
end_function

begin_block
block|{
name|int
name|total
init|=
name|alpha_elf_tdata
argument_list|(
name|a
argument_list|)
operator|->
name|total_got_size
decl_stmt|;
name|bfd
modifier|*
name|bsub
decl_stmt|;
comment|/* Remember local expansion.  */
block|{
name|int
name|e
init|=
name|alpha_elf_tdata
argument_list|(
name|b
argument_list|)
operator|->
name|local_got_size
decl_stmt|;
name|total
operator|+=
name|e
expr_stmt|;
name|alpha_elf_tdata
argument_list|(
name|a
argument_list|)
operator|->
name|local_got_size
operator|+=
name|e
expr_stmt|;
block|}
for|for
control|(
name|bsub
operator|=
name|b
init|;
name|bsub
condition|;
name|bsub
operator|=
name|alpha_elf_tdata
argument_list|(
name|bsub
argument_list|)
operator|->
name|in_got_link_next
control|)
block|{
name|struct
name|alpha_elf_got_entry
modifier|*
modifier|*
name|local_got_entries
decl_stmt|;
name|struct
name|alpha_elf_link_hash_entry
modifier|*
modifier|*
name|hashes
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
comment|/* Let the local .got entries know they are part of a new subsegment.  */
name|local_got_entries
operator|=
name|alpha_elf_tdata
argument_list|(
name|bsub
argument_list|)
operator|->
name|local_got_entries
expr_stmt|;
if|if
condition|(
name|local_got_entries
condition|)
block|{
name|n
operator|=
name|elf_tdata
argument_list|(
name|bsub
argument_list|)
operator|->
name|symtab_hdr
operator|.
name|sh_info
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|alpha_elf_got_entry
modifier|*
name|ent
decl_stmt|;
for|for
control|(
name|ent
operator|=
name|local_got_entries
index|[
name|i
index|]
init|;
name|ent
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
name|ent
operator|->
name|gotobj
operator|=
name|a
expr_stmt|;
block|}
block|}
comment|/* Merge the global .got entries.  */
name|hashes
operator|=
name|alpha_elf_sym_hashes
argument_list|(
name|bsub
argument_list|)
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|bsub
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|n
operator|=
name|NUM_SHDR_ENTRIES
argument_list|(
name|symtab_hdr
argument_list|)
operator|-
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|alpha_elf_got_entry
modifier|*
name|ae
decl_stmt|,
modifier|*
name|be
decl_stmt|,
modifier|*
modifier|*
name|pbe
decl_stmt|,
modifier|*
modifier|*
name|start
decl_stmt|;
name|struct
name|alpha_elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
name|hashes
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|alpha_elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|start
operator|=
operator|&
name|h
operator|->
name|got_entries
expr_stmt|;
for|for
control|(
name|pbe
operator|=
name|start
operator|,
name|be
operator|=
operator|*
name|start
init|;
name|be
condition|;
name|pbe
operator|=
operator|&
name|be
operator|->
name|next
operator|,
name|be
operator|=
name|be
operator|->
name|next
control|)
block|{
if|if
condition|(
name|be
operator|->
name|use_count
operator|==
literal|0
condition|)
block|{
operator|*
name|pbe
operator|=
name|be
operator|->
name|next
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|be
operator|->
name|gotobj
operator|!=
name|b
condition|)
continue|continue;
for|for
control|(
name|ae
operator|=
operator|*
name|start
init|;
name|ae
condition|;
name|ae
operator|=
name|ae
operator|->
name|next
control|)
if|if
condition|(
name|ae
operator|->
name|gotobj
operator|==
name|a
operator|&&
name|ae
operator|->
name|reloc_type
operator|==
name|be
operator|->
name|reloc_type
operator|&&
name|ae
operator|->
name|addend
operator|==
name|be
operator|->
name|addend
condition|)
block|{
name|ae
operator|->
name|flags
operator||=
name|be
operator|->
name|flags
expr_stmt|;
name|ae
operator|->
name|use_count
operator|+=
name|be
operator|->
name|use_count
expr_stmt|;
operator|*
name|pbe
operator|=
name|be
operator|->
name|next
expr_stmt|;
goto|goto
name|global_found
goto|;
block|}
name|be
operator|->
name|gotobj
operator|=
name|a
expr_stmt|;
name|total
operator|+=
name|alpha_got_entry_size
argument_list|(
name|be
operator|->
name|reloc_type
argument_list|)
expr_stmt|;
name|global_found
label|:
empty_stmt|;
block|}
block|}
name|alpha_elf_tdata
argument_list|(
name|bsub
argument_list|)
operator|->
name|gotobj
operator|=
name|a
expr_stmt|;
block|}
name|alpha_elf_tdata
argument_list|(
name|a
argument_list|)
operator|->
name|total_got_size
operator|=
name|total
expr_stmt|;
comment|/* Merge the two in_got chains.  */
block|{
name|bfd
modifier|*
name|next
decl_stmt|;
name|bsub
operator|=
name|a
expr_stmt|;
while|while
condition|(
operator|(
name|next
operator|=
name|alpha_elf_tdata
argument_list|(
name|bsub
argument_list|)
operator|->
name|in_got_link_next
operator|)
operator|!=
name|NULL
condition|)
name|bsub
operator|=
name|next
expr_stmt|;
name|alpha_elf_tdata
argument_list|(
name|bsub
argument_list|)
operator|->
name|in_got_link_next
operator|=
name|b
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Calculate the offsets for the got entries.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf64_alpha_calc_got_offsets_for_symbol
parameter_list|(
name|h
parameter_list|,
name|arg
parameter_list|)
name|struct
name|alpha_elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|PTR
name|arg
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|bfd_boolean
name|result
init|=
name|TRUE
decl_stmt|;
name|struct
name|alpha_elf_got_entry
modifier|*
name|gotent
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|alpha_elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
for|for
control|(
name|gotent
operator|=
name|h
operator|->
name|got_entries
init|;
name|gotent
condition|;
name|gotent
operator|=
name|gotent
operator|->
name|next
control|)
if|if
condition|(
name|gotent
operator|->
name|use_count
operator|>
literal|0
condition|)
block|{
name|struct
name|alpha_elf_obj_tdata
modifier|*
name|td
decl_stmt|;
name|bfd_size_type
modifier|*
name|plge
decl_stmt|;
name|td
operator|=
name|alpha_elf_tdata
argument_list|(
name|gotent
operator|->
name|gotobj
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|==
name|NULL
condition|)
block|{
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"Symbol %s has no GOT subsection for offset 0x%x"
argument_list|)
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|gotent
operator|->
name|got_offset
argument_list|)
expr_stmt|;
name|result
operator|=
name|FALSE
expr_stmt|;
continue|continue;
block|}
name|plge
operator|=
operator|&
name|td
operator|->
name|got
operator|->
name|_raw_size
expr_stmt|;
name|gotent
operator|->
name|got_offset
operator|=
operator|*
name|plge
expr_stmt|;
operator|*
name|plge
operator|+=
name|alpha_got_entry_size
argument_list|(
name|gotent
operator|->
name|reloc_type
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|elf64_alpha_calc_got_offsets
parameter_list|(
name|info
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|bfd
modifier|*
name|i
decl_stmt|,
modifier|*
name|got_list
init|=
name|alpha_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|got_list
decl_stmt|;
comment|/* First, zero out the .got sizes, as we may be recalculating the      .got after optimizing it.  */
for|for
control|(
name|i
operator|=
name|got_list
init|;
name|i
condition|;
name|i
operator|=
name|alpha_elf_tdata
argument_list|(
name|i
argument_list|)
operator|->
name|got_link_next
control|)
name|alpha_elf_tdata
argument_list|(
name|i
argument_list|)
operator|->
name|got
operator|->
name|_raw_size
operator|=
literal|0
expr_stmt|;
comment|/* Next, fill in the offsets for all the global entries.  */
name|alpha_elf_link_hash_traverse
argument_list|(
name|alpha_elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|elf64_alpha_calc_got_offsets_for_symbol
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Finally, fill in the offsets for the local entries.  */
for|for
control|(
name|i
operator|=
name|got_list
init|;
name|i
condition|;
name|i
operator|=
name|alpha_elf_tdata
argument_list|(
name|i
argument_list|)
operator|->
name|got_link_next
control|)
block|{
name|bfd_size_type
name|got_offset
init|=
name|alpha_elf_tdata
argument_list|(
name|i
argument_list|)
operator|->
name|got
operator|->
name|_raw_size
decl_stmt|;
name|bfd
modifier|*
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
condition|;
name|j
operator|=
name|alpha_elf_tdata
argument_list|(
name|j
argument_list|)
operator|->
name|in_got_link_next
control|)
block|{
name|struct
name|alpha_elf_got_entry
modifier|*
modifier|*
name|local_got_entries
decl_stmt|,
modifier|*
name|gotent
decl_stmt|;
name|int
name|k
decl_stmt|,
name|n
decl_stmt|;
name|local_got_entries
operator|=
name|alpha_elf_tdata
argument_list|(
name|j
argument_list|)
operator|->
name|local_got_entries
expr_stmt|;
if|if
condition|(
operator|!
name|local_got_entries
condition|)
continue|continue;
for|for
control|(
name|k
operator|=
literal|0
operator|,
name|n
operator|=
name|elf_tdata
argument_list|(
name|j
argument_list|)
operator|->
name|symtab_hdr
operator|.
name|sh_info
init|;
name|k
operator|<
name|n
condition|;
operator|++
name|k
control|)
for|for
control|(
name|gotent
operator|=
name|local_got_entries
index|[
name|k
index|]
init|;
name|gotent
condition|;
name|gotent
operator|=
name|gotent
operator|->
name|next
control|)
if|if
condition|(
name|gotent
operator|->
name|use_count
operator|>
literal|0
condition|)
block|{
name|gotent
operator|->
name|got_offset
operator|=
name|got_offset
expr_stmt|;
name|got_offset
operator|+=
name|alpha_got_entry_size
argument_list|(
name|gotent
operator|->
name|reloc_type
argument_list|)
expr_stmt|;
block|}
block|}
name|alpha_elf_tdata
argument_list|(
name|i
argument_list|)
operator|->
name|got
operator|->
name|_raw_size
operator|=
name|got_offset
expr_stmt|;
name|alpha_elf_tdata
argument_list|(
name|i
argument_list|)
operator|->
name|got
operator|->
name|_cooked_size
operator|=
name|got_offset
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Constructs the gots.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf64_alpha_size_got_sections
parameter_list|(
name|info
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|bfd
modifier|*
name|i
decl_stmt|,
modifier|*
name|got_list
decl_stmt|,
modifier|*
name|cur_got_obj
init|=
name|NULL
decl_stmt|;
name|int
name|something_changed
init|=
literal|0
decl_stmt|;
name|got_list
operator|=
name|alpha_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|got_list
expr_stmt|;
comment|/* On the first time through, pretend we have an existing got list      consisting of all of the input files.  */
if|if
condition|(
name|got_list
operator|==
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
name|info
operator|->
name|input_bfds
init|;
name|i
condition|;
name|i
operator|=
name|i
operator|->
name|link_next
control|)
block|{
name|bfd
modifier|*
name|this_got
init|=
name|alpha_elf_tdata
argument_list|(
name|i
argument_list|)
operator|->
name|gotobj
decl_stmt|;
if|if
condition|(
name|this_got
operator|==
name|NULL
condition|)
continue|continue;
comment|/* We are assuming no merging has yet occurred.  */
name|BFD_ASSERT
argument_list|(
name|this_got
operator|==
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|alpha_elf_tdata
argument_list|(
name|this_got
argument_list|)
operator|->
name|total_got_size
operator|>
name|MAX_GOT_SIZE
condition|)
block|{
comment|/* Yikes! A single object file has too many entries.  */
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: .got subsegment exceeds 64K (size %d)"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|i
argument_list|)
argument_list|,
name|alpha_elf_tdata
argument_list|(
name|this_got
argument_list|)
operator|->
name|total_got_size
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|got_list
operator|==
name|NULL
condition|)
name|got_list
operator|=
name|this_got
expr_stmt|;
else|else
name|alpha_elf_tdata
argument_list|(
name|cur_got_obj
argument_list|)
operator|->
name|got_link_next
operator|=
name|this_got
expr_stmt|;
name|cur_got_obj
operator|=
name|this_got
expr_stmt|;
block|}
comment|/* Strange degenerate case of no got references.  */
if|if
condition|(
name|got_list
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
name|alpha_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|got_list
operator|=
name|got_list
expr_stmt|;
comment|/* Force got offsets to be recalculated.  */
name|something_changed
operator|=
literal|1
expr_stmt|;
block|}
name|cur_got_obj
operator|=
name|got_list
expr_stmt|;
name|i
operator|=
name|alpha_elf_tdata
argument_list|(
name|cur_got_obj
argument_list|)
operator|->
name|got_link_next
expr_stmt|;
while|while
condition|(
name|i
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|elf64_alpha_can_merge_gots
argument_list|(
name|cur_got_obj
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|elf64_alpha_merge_gots
argument_list|(
name|cur_got_obj
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|i
operator|=
name|alpha_elf_tdata
argument_list|(
name|i
argument_list|)
operator|->
name|got_link_next
expr_stmt|;
name|alpha_elf_tdata
argument_list|(
name|cur_got_obj
argument_list|)
operator|->
name|got_link_next
operator|=
name|i
expr_stmt|;
name|something_changed
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|cur_got_obj
operator|=
name|i
expr_stmt|;
name|i
operator|=
name|alpha_elf_tdata
argument_list|(
name|i
argument_list|)
operator|->
name|got_link_next
expr_stmt|;
block|}
block|}
comment|/* Once the gots have been merged, fill in the got offsets for      everything therein.  */
if|if
condition|(
literal|1
operator|||
name|something_changed
condition|)
name|elf64_alpha_calc_got_offsets
argument_list|(
name|info
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Called from relax_section to rebuild the PLT in light of    potential changes in the function's status.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf64_alpha_size_plt_section
parameter_list|(
name|info
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|asection
modifier|*
name|splt
decl_stmt|,
modifier|*
name|spltrel
decl_stmt|;
name|unsigned
name|long
name|entries
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|splt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|splt
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
name|splt
operator|->
name|_raw_size
operator|=
literal|0
expr_stmt|;
name|alpha_elf_link_hash_traverse
argument_list|(
name|alpha_elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|elf64_alpha_size_plt_section_1
argument_list|,
name|splt
argument_list|)
expr_stmt|;
name|splt
operator|->
name|_cooked_size
operator|=
name|splt
operator|->
name|_raw_size
expr_stmt|;
comment|/* Every plt entry requires a JMP_SLOT relocation.  */
name|spltrel
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.plt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|splt
operator|->
name|_raw_size
condition|)
name|entries
operator|=
operator|(
name|splt
operator|->
name|_raw_size
operator|-
name|PLT_HEADER_SIZE
operator|)
operator|/
name|PLT_ENTRY_SIZE
expr_stmt|;
else|else
name|entries
operator|=
literal|0
expr_stmt|;
name|spltrel
operator|->
name|_raw_size
operator|=
name|entries
operator|*
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
name|spltrel
operator|->
name|_cooked_size
operator|=
name|spltrel
operator|->
name|_raw_size
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elf64_alpha_size_plt_section_1
parameter_list|(
name|h
parameter_list|,
name|data
parameter_list|)
name|struct
name|alpha_elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
name|asection
modifier|*
name|splt
init|=
operator|(
name|asection
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|alpha_elf_got_entry
modifier|*
name|gotent
decl_stmt|;
comment|/* If we didn't need an entry before, we still don't.  */
if|if
condition|(
operator|!
operator|(
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_NEEDS_PLT
operator|)
condition|)
return|return
name|TRUE
return|;
comment|/* There must still be a LITERAL got entry for the function.  */
for|for
control|(
name|gotent
operator|=
name|h
operator|->
name|got_entries
init|;
name|gotent
condition|;
name|gotent
operator|=
name|gotent
operator|->
name|next
control|)
if|if
condition|(
name|gotent
operator|->
name|reloc_type
operator|==
name|R_ALPHA_LITERAL
operator|&&
name|gotent
operator|->
name|use_count
operator|>
literal|0
condition|)
break|break;
comment|/* If there is, reset the PLT offset.  If not, there's no longer      a need for the PLT entry.  */
if|if
condition|(
name|gotent
condition|)
block|{
if|if
condition|(
name|splt
operator|->
name|_raw_size
operator|==
literal|0
condition|)
name|splt
operator|->
name|_raw_size
operator|=
name|PLT_HEADER_SIZE
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|plt
operator|.
name|offset
operator|=
name|splt
operator|->
name|_raw_size
expr_stmt|;
name|splt
operator|->
name|_raw_size
operator|+=
name|PLT_ENTRY_SIZE
expr_stmt|;
block|}
else|else
block|{
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_HASH_NEEDS_PLT
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|plt
operator|.
name|offset
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Undo the definition frobbing begun in adjust_dynamic_symbol.  */
if|if
condition|(
name|h
operator|->
name|flags
operator|&
name|ALPHA_ELF_LINK_HASH_PLT_LOC
condition|)
block|{
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|h
operator|->
name|plt_old_section
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|h
operator|->
name|plt_old_value
expr_stmt|;
name|h
operator|->
name|flags
operator|&=
operator|~
name|ALPHA_ELF_LINK_HASH_PLT_LOC
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elf64_alpha_always_size_sections
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|bfd
modifier|*
name|i
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
return|return
name|TRUE
return|;
comment|/* First, take care of the indirect symbols created by versioning.  */
name|alpha_elf_link_hash_traverse
argument_list|(
name|alpha_elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|elf64_alpha_merge_ind_symbols
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|elf64_alpha_size_got_sections
argument_list|(
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Allocate space for all of the .got subsections.  */
name|i
operator|=
name|alpha_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|got_list
expr_stmt|;
for|for
control|(
init|;
name|i
condition|;
name|i
operator|=
name|alpha_elf_tdata
argument_list|(
name|i
argument_list|)
operator|->
name|got_link_next
control|)
block|{
name|asection
modifier|*
name|s
init|=
name|alpha_elf_tdata
argument_list|(
name|i
argument_list|)
operator|->
name|got
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|_raw_size
operator|>
literal|0
condition|)
block|{
name|s
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|i
argument_list|,
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* The number of dynamic relocations required by a static relocation.  */
end_comment

begin_function
specifier|static
name|int
name|alpha_dynamic_entries_for_reloc
parameter_list|(
name|r_type
parameter_list|,
name|dynamic
parameter_list|,
name|shared
parameter_list|)
name|int
name|r_type
decl_stmt|,
name|dynamic
decl_stmt|,
name|shared
decl_stmt|;
block|{
switch|switch
condition|(
name|r_type
condition|)
block|{
comment|/* May appear in GOT entries.  */
case|case
name|R_ALPHA_TLSGD
case|:
return|return
operator|(
name|dynamic
condition|?
literal|2
else|:
name|shared
condition|?
literal|1
else|:
literal|0
operator|)
return|;
case|case
name|R_ALPHA_TLSLDM
case|:
return|return
name|shared
return|;
case|case
name|R_ALPHA_LITERAL
case|:
case|case
name|R_ALPHA_GOTTPREL
case|:
return|return
name|dynamic
operator|||
name|shared
return|;
case|case
name|R_ALPHA_GOTDTPREL
case|:
return|return
name|dynamic
return|;
comment|/* May appear in data sections.  */
case|case
name|R_ALPHA_REFLONG
case|:
case|case
name|R_ALPHA_REFQUAD
case|:
case|case
name|R_ALPHA_TPREL64
case|:
return|return
name|dynamic
operator|||
name|shared
return|;
comment|/* Everything else is illegal.  We'll issue an error during        relocate_section.  */
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Work out the sizes of the dynamic relocation entries.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf64_alpha_calc_dynrel_sizes
parameter_list|(
name|h
parameter_list|,
name|info
parameter_list|)
name|struct
name|alpha_elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|bfd_boolean
name|dynamic
decl_stmt|;
name|struct
name|alpha_elf_reloc_entry
modifier|*
name|relent
decl_stmt|;
name|unsigned
name|long
name|entries
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|alpha_elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
comment|/* If the symbol was defined as a common symbol in a regular object      file, and there was no definition in any dynamic object, then the      linker will have allocated space for the symbol in a common      section but the ELF_LINK_HASH_DEF_REGULAR flag will not have been      set.  This is done for dynamic symbols in      elf_adjust_dynamic_symbol but this is not done for non-dynamic      symbols, somehow.  */
if|if
condition|(
operator|(
operator|(
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator|&
operator|(
name|ELF_LINK_HASH_DEF_REGULAR
operator||
name|ELF_LINK_HASH_REF_REGULAR
operator||
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|)
operator|==
name|ELF_LINK_HASH_REF_REGULAR
operator|)
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
operator|!
operator|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
condition|)
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_DEF_REGULAR
expr_stmt|;
comment|/* If the symbol is dynamic, we'll need all the relocations in their      natural form.  If this is a shared object, and it has been forced      local, we'll need the same number of RELATIVE relocations.  */
name|dynamic
operator|=
name|alpha_elf_dynamic_symbol_p
argument_list|(
operator|&
name|h
operator|->
name|root
argument_list|,
name|info
argument_list|)
expr_stmt|;
for|for
control|(
name|relent
operator|=
name|h
operator|->
name|reloc_entries
init|;
name|relent
condition|;
name|relent
operator|=
name|relent
operator|->
name|next
control|)
block|{
name|entries
operator|=
name|alpha_dynamic_entries_for_reloc
argument_list|(
name|relent
operator|->
name|rtype
argument_list|,
name|dynamic
argument_list|,
name|info
operator|->
name|shared
argument_list|)
expr_stmt|;
if|if
condition|(
name|entries
condition|)
block|{
name|relent
operator|->
name|srel
operator|->
name|_raw_size
operator|+=
name|entries
operator|*
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
operator|*
name|relent
operator|->
name|count
expr_stmt|;
if|if
condition|(
name|relent
operator|->
name|reltext
condition|)
name|info
operator|->
name|flags
operator||=
name|DT_TEXTREL
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Set the sizes of the dynamic relocation sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf64_alpha_size_rela_got_section
parameter_list|(
name|info
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|unsigned
name|long
name|entries
decl_stmt|;
name|bfd
modifier|*
name|i
decl_stmt|,
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|srel
decl_stmt|;
comment|/* Shared libraries often require RELATIVE relocs, and some relocs      require attention for the main application as well.  */
name|entries
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|alpha_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|got_list
init|;
name|i
condition|;
name|i
operator|=
name|alpha_elf_tdata
argument_list|(
name|i
argument_list|)
operator|->
name|got_link_next
control|)
block|{
name|bfd
modifier|*
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
condition|;
name|j
operator|=
name|alpha_elf_tdata
argument_list|(
name|j
argument_list|)
operator|->
name|in_got_link_next
control|)
block|{
name|struct
name|alpha_elf_got_entry
modifier|*
modifier|*
name|local_got_entries
decl_stmt|,
modifier|*
name|gotent
decl_stmt|;
name|int
name|k
decl_stmt|,
name|n
decl_stmt|;
name|local_got_entries
operator|=
name|alpha_elf_tdata
argument_list|(
name|j
argument_list|)
operator|->
name|local_got_entries
expr_stmt|;
if|if
condition|(
operator|!
name|local_got_entries
condition|)
continue|continue;
for|for
control|(
name|k
operator|=
literal|0
operator|,
name|n
operator|=
name|elf_tdata
argument_list|(
name|j
argument_list|)
operator|->
name|symtab_hdr
operator|.
name|sh_info
init|;
name|k
operator|<
name|n
condition|;
operator|++
name|k
control|)
for|for
control|(
name|gotent
operator|=
name|local_got_entries
index|[
name|k
index|]
init|;
name|gotent
condition|;
name|gotent
operator|=
name|gotent
operator|->
name|next
control|)
if|if
condition|(
name|gotent
operator|->
name|use_count
operator|>
literal|0
condition|)
name|entries
operator|+=
operator|(
name|alpha_dynamic_entries_for_reloc
argument_list|(
name|gotent
operator|->
name|reloc_type
argument_list|,
literal|0
argument_list|,
name|info
operator|->
name|shared
argument_list|)
operator|)
expr_stmt|;
block|}
block|}
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|srel
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|srel
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|entries
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|srel
operator|->
name|_raw_size
operator|=
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
operator|*
name|entries
expr_stmt|;
comment|/* Now do the non-local symbols.  */
name|alpha_elf_link_hash_traverse
argument_list|(
name|alpha_elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|elf64_alpha_size_rela_got_1
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|srel
operator|->
name|_cooked_size
operator|=
name|srel
operator|->
name|_raw_size
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of elf64_alpha_size_rela_got_section for doing the    global symbols.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf64_alpha_size_rela_got_1
parameter_list|(
name|h
parameter_list|,
name|info
parameter_list|)
name|struct
name|alpha_elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|bfd_boolean
name|dynamic
decl_stmt|;
name|struct
name|alpha_elf_got_entry
modifier|*
name|gotent
decl_stmt|;
name|unsigned
name|long
name|entries
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|alpha_elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
comment|/* If the symbol is dynamic, we'll need all the relocations in their      natural form.  If this is a shared object, and it has been forced      local, we'll need the same number of RELATIVE relocations.  */
name|dynamic
operator|=
name|alpha_elf_dynamic_symbol_p
argument_list|(
operator|&
name|h
operator|->
name|root
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|entries
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|gotent
operator|=
name|h
operator|->
name|got_entries
init|;
name|gotent
condition|;
name|gotent
operator|=
name|gotent
operator|->
name|next
control|)
if|if
condition|(
name|gotent
operator|->
name|use_count
operator|>
literal|0
condition|)
name|entries
operator|+=
name|alpha_dynamic_entries_for_reloc
argument_list|(
name|gotent
operator|->
name|reloc_type
argument_list|,
name|dynamic
argument_list|,
name|info
operator|->
name|shared
argument_list|)
expr_stmt|;
comment|/* If we are using a .plt entry, subtract one, as the first      reference uses a .rela.plt entry instead.  */
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|plt
operator|.
name|offset
operator|!=
name|MINUS_ONE
condition|)
name|entries
operator|--
expr_stmt|;
if|if
condition|(
name|entries
operator|>
literal|0
condition|)
block|{
name|bfd
modifier|*
name|dynobj
init|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|srel
init|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|)
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|srel
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|srel
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
operator|*
name|entries
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Set the sizes of the dynamic sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf64_alpha_size_dynamic_sections
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_boolean
name|relplt
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|dynobj
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
comment|/* Set the contents of the .interp section to the interpreter.  */
if|if
condition|(
name|info
operator|->
name|executable
condition|)
block|{
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".interp"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|=
sizeof|sizeof
name|ELF_DYNAMIC_INTERPRETER
expr_stmt|;
name|s
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ELF_DYNAMIC_INTERPRETER
expr_stmt|;
block|}
comment|/* Now that we've seen all of the input files, we can decide which 	 symbols need dynamic relocation entries and which don't.  We've 	 collected information in check_relocs that we can now apply to 	 size the dynamic relocation sections.  */
name|alpha_elf_link_hash_traverse
argument_list|(
name|alpha_elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|elf64_alpha_calc_dynrel_sizes
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|elf64_alpha_size_rela_got_section
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
comment|/* else we're not dynamic and by definition we don't need such things.  */
comment|/* The check_relocs and adjust_dynamic_symbol entry points have      determined the sizes of the various dynamic sections.  Allocate      memory for them.  */
name|relplt
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|s
operator|=
name|dynobj
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bfd_boolean
name|strip
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LINKER_CREATED
operator|)
condition|)
continue|continue;
comment|/* It's OK to base decisions on the section name, because none 	 of the dynobj section names depend upon the input files.  */
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* If we don't need this section, strip it from the output file. 	 This is to handle .rela.bss and .rela.plt.  We must create it 	 in create_dynamic_sections, because it must be created before 	 the linker maps input sections to output sections.  The 	 linker does that before adjust_dynamic_symbol is called, and 	 it is that function which decides whether anything needs to 	 go into these sections.  */
name|strip
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".rela"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|strip
operator|=
operator|(
name|s
operator|->
name|_raw_size
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|strip
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".rela.plt"
argument_list|)
operator|==
literal|0
condition|)
name|relplt
operator|=
name|TRUE
expr_stmt|;
comment|/* We use the reloc_count field as a counter if we need 		 to copy relocs into the output file.  */
name|s
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".plt"
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* It's not one of our dynamic sections, so don't allocate space.  */
continue|continue;
block|}
if|if
condition|(
name|strip
condition|)
name|_bfd_strip_section_from_output
argument_list|(
name|info
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Allocate memory for the section contents.  */
name|s
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|dynobj
argument_list|,
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|contents
operator|==
name|NULL
operator|&&
name|s
operator|->
name|_raw_size
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
block|}
block|}
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
comment|/* Add some entries to the .dynamic section.  We fill in the 	 values later, in elf64_alpha_finish_dynamic_sections, but we 	 must add the entries now so that we get the correct size for 	 the .dynamic section.  The DT_DEBUG entry is filled in by the 	 dynamic linker and used by the debugger.  */
define|#
directive|define
name|add_dynamic_entry
parameter_list|(
name|TAG
parameter_list|,
name|VAL
parameter_list|)
define|\
value|_bfd_elf_add_dynamic_entry (info, TAG, VAL)
if|if
condition|(
name|info
operator|->
name|executable
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_DEBUG
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|relplt
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PLTGOT
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PLTRELSZ
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PLTREL
argument_list|,
name|DT_RELA
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_JMPREL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELA
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELASZ
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELAENT
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|info
operator|->
name|flags
operator|&
name|DF_TEXTREL
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_TEXTREL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
undef|#
directive|undef
name|add_dynamic_entry
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Emit a dynamic relocation for (DYNINDX, RTYPE, ADDEND) at (SEC, OFFSET)    into the next available slot in SREL.  */
end_comment

begin_function
specifier|static
name|void
name|elf64_alpha_emit_dynrel
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|sec
parameter_list|,
name|srel
parameter_list|,
name|offset
parameter_list|,
name|dynindx
parameter_list|,
name|rtype
parameter_list|,
name|addend
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|,
decl|*
name|srel
decl_stmt|;
end_function

begin_decl_stmt
name|bfd_vma
name|offset
decl_stmt|,
name|addend
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|dynindx
decl_stmt|,
name|rtype
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Elf_Internal_Rela
name|outrel
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|srel
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|dynindx
argument_list|,
name|rtype
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
name|addend
expr_stmt|;
name|offset
operator|=
name|_bfd_elf_section_offset
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|sec
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|offset
operator||
literal|1
operator|)
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
name|outrel
operator|.
name|r_offset
operator|=
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|offset
expr_stmt|;
else|else
name|memset
argument_list|(
operator|&
name|outrel
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|outrel
argument_list|)
argument_list|)
expr_stmt|;
name|loc
operator|=
name|srel
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
name|srel
operator|->
name|reloc_count
operator|++
operator|*
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
name|bfd_elf64_swap_reloca_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|outrel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
operator|*
name|srel
operator|->
name|reloc_count
operator|<=
name|srel
operator|->
name|_cooked_size
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Relocate an Alpha ELF section for a relocatable link.     We don't have to change anything unless the reloc is against a section    symbol, in which case we have to adjust according to where the section    symbol winds up in the output section.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf64_alpha_relocate_section_r
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|contents
parameter_list|,
name|relocs
parameter_list|,
name|local_syms
parameter_list|,
name|local_sections
parameter_list|)
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|local_syms
decl_stmt|;
name|asection
modifier|*
modifier|*
name|local_sections
decl_stmt|;
block|{
name|unsigned
name|long
name|symtab_hdr_sh_info
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relend
decl_stmt|;
name|bfd_boolean
name|ret_val
init|=
name|TRUE
decl_stmt|;
name|symtab_hdr_sh_info
operator|=
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
operator|.
name|sh_info
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|input_section
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|unsigned
name|long
name|r_type
decl_stmt|;
name|r_type
operator|=
name|ELF64_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|>=
name|R_ALPHA_max
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: unknown relocation type %d"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|r_type
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|FALSE
expr_stmt|;
continue|continue;
block|}
name|r_symndx
operator|=
name|ELF64_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
comment|/* The symbol associated with GPDISP and LITUSE is 	 immaterial.  Only the addend is significant.  */
if|if
condition|(
name|r_type
operator|==
name|R_ALPHA_GPDISP
operator|||
name|r_type
operator|==
name|R_ALPHA_LITUSE
condition|)
continue|continue;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr_sh_info
condition|)
block|{
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_SECTION
condition|)
block|{
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|rel
operator|->
name|r_addend
operator|+=
name|sec
operator|->
name|output_offset
operator|+
name|sym
operator|->
name|st_value
expr_stmt|;
block|}
block|}
block|}
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/* Relocate an Alpha ELF section.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf64_alpha_relocate_section
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|contents
parameter_list|,
name|relocs
parameter_list|,
name|local_syms
parameter_list|,
name|local_sections
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|local_syms
decl_stmt|;
name|asection
modifier|*
modifier|*
name|local_sections
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relend
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|,
modifier|*
name|srel
decl_stmt|,
modifier|*
name|srelgot
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|,
modifier|*
name|gotobj
decl_stmt|;
name|bfd_vma
name|gp
decl_stmt|,
name|tp_base
decl_stmt|,
name|dtp_base
decl_stmt|;
name|struct
name|alpha_elf_got_entry
modifier|*
modifier|*
name|local_got_entries
decl_stmt|;
name|bfd_boolean
name|ret_val
decl_stmt|;
specifier|const
name|char
modifier|*
name|section_name
decl_stmt|;
comment|/* Handle relocatable links with a smaller loop.  */
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
return|return
name|elf64_alpha_relocate_section_r
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|relocs
argument_list|,
name|local_syms
argument_list|,
name|local_sections
argument_list|)
return|;
comment|/* This is a final link.  */
name|ret_val
operator|=
name|TRUE
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
if|if
condition|(
name|dynobj
condition|)
name|srelgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
else|else
name|srelgot
operator|=
name|NULL
expr_stmt|;
name|section_name
operator|=
operator|(
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|elf_elfheader
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|e_shstrndx
argument_list|,
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|rel_hdr
operator|.
name|sh_name
argument_list|)
operator|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|section_name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|srel
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|section_name
argument_list|)
expr_stmt|;
comment|/* Find the gp value for this input bfd.  */
name|gotobj
operator|=
name|alpha_elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|gotobj
expr_stmt|;
if|if
condition|(
name|gotobj
condition|)
block|{
name|sgot
operator|=
name|alpha_elf_tdata
argument_list|(
name|gotobj
argument_list|)
operator|->
name|got
expr_stmt|;
name|gp
operator|=
name|_bfd_get_gp_value
argument_list|(
name|gotobj
argument_list|)
expr_stmt|;
if|if
condition|(
name|gp
operator|==
literal|0
condition|)
block|{
name|gp
operator|=
operator|(
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
literal|0x8000
operator|)
expr_stmt|;
name|_bfd_set_gp_value
argument_list|(
name|gotobj
argument_list|,
name|gp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|sgot
operator|=
name|NULL
expr_stmt|;
name|gp
operator|=
literal|0
expr_stmt|;
block|}
name|local_got_entries
operator|=
name|alpha_elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|local_got_entries
expr_stmt|;
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|tls_sec
operator|!=
name|NULL
condition|)
block|{
name|dtp_base
operator|=
name|alpha_get_dtprel_base
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|tp_base
operator|=
name|alpha_get_tprel_base
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
else|else
name|dtp_base
operator|=
name|tp_base
operator|=
literal|0
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|input_section
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|struct
name|alpha_elf_link_hash_entry
modifier|*
name|h
init|=
name|NULL
decl_stmt|;
name|struct
name|alpha_elf_got_entry
modifier|*
name|gotent
decl_stmt|;
name|bfd_reloc_status_type
name|r
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
init|=
name|NULL
decl_stmt|;
name|asection
modifier|*
name|sec
init|=
name|NULL
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|;
name|bfd_boolean
name|dynamic_symbol_p
decl_stmt|;
name|bfd_boolean
name|undef_weak_ref
init|=
name|FALSE
decl_stmt|;
name|unsigned
name|long
name|r_type
decl_stmt|;
name|r_type
operator|=
name|ELF64_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|>=
name|R_ALPHA_max
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: unknown relocation type %d"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|r_type
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|FALSE
expr_stmt|;
continue|continue;
block|}
name|howto
operator|=
name|elf64_alpha_howto_table
operator|+
name|r_type
expr_stmt|;
name|r_symndx
operator|=
name|ELF64_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
comment|/* The symbol for a TLSLDM reloc is ignored.  Collapse the 	 reloc to the 0 symbol so that they all match.  */
if|if
condition|(
name|r_type
operator|==
name|R_ALPHA_TLSLDM
condition|)
name|r_symndx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|asection
modifier|*
name|msec
decl_stmt|;
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|msec
operator|=
name|sec
expr_stmt|;
name|value
operator|=
name|_bfd_elf_rela_local_sym
argument_list|(
name|output_bfd
argument_list|,
name|sym
argument_list|,
operator|&
name|msec
argument_list|,
name|rel
argument_list|)
expr_stmt|;
comment|/* If this is a tp-relative relocation against sym 0, 	     this is hackery from relax_section.  Force the value to 	     be the tls base.  */
if|if
condition|(
name|r_symndx
operator|==
literal|0
operator|&&
operator|(
name|r_type
operator|==
name|R_ALPHA_TLSLDM
operator|||
name|r_type
operator|==
name|R_ALPHA_GOTTPREL
operator|||
name|r_type
operator|==
name|R_ALPHA_TPREL64
operator|||
name|r_type
operator|==
name|R_ALPHA_TPRELHI
operator|||
name|r_type
operator|==
name|R_ALPHA_TPRELLO
operator|||
name|r_type
operator|==
name|R_ALPHA_TPREL16
operator|)
condition|)
name|value
operator|=
name|tp_base
expr_stmt|;
if|if
condition|(
name|local_got_entries
condition|)
name|gotent
operator|=
name|local_got_entries
index|[
name|r_symndx
index|]
expr_stmt|;
else|else
name|gotent
operator|=
name|NULL
expr_stmt|;
comment|/* Need to adjust local GOT entries' addends for SEC_MERGE 	     unless it has been done already.  */
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_MERGE
operator|)
operator|&&
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_SECTION
operator|&&
name|sec
operator|->
name|sec_info_type
operator|==
name|ELF_INFO_TYPE_MERGE
operator|&&
name|gotent
operator|&&
operator|!
name|gotent
operator|->
name|reloc_xlated
condition|)
block|{
name|struct
name|alpha_elf_got_entry
modifier|*
name|ent
decl_stmt|;
for|for
control|(
name|ent
operator|=
name|gotent
init|;
name|ent
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
block|{
name|ent
operator|->
name|reloc_xlated
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ent
operator|->
name|use_count
operator|==
literal|0
condition|)
continue|continue;
name|msec
operator|=
name|sec
expr_stmt|;
name|ent
operator|->
name|addend
operator|=
name|_bfd_merged_section_offset
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|msec
argument_list|,
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|sec_info
argument_list|,
name|sym
operator|->
name|st_value
operator|+
name|ent
operator|->
name|addend
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
expr_stmt|;
name|ent
operator|->
name|addend
operator|-=
name|sym
operator|->
name|st_value
expr_stmt|;
name|ent
operator|->
name|addend
operator|+=
name|msec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|msec
operator|->
name|output_offset
operator|-
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|-
name|sec
operator|->
name|output_offset
expr_stmt|;
block|}
block|}
name|dynamic_symbol_p
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|bfd_boolean
name|warned
decl_stmt|;
name|bfd_boolean
name|unresolved_reloc
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|hh
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
init|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
decl_stmt|;
name|RELOC_FOR_GLOBAL_SYMBOL
argument_list|(
name|info
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
argument_list|,
name|r_symndx
argument_list|,
name|symtab_hdr
argument_list|,
name|sym_hashes
argument_list|,
name|hh
argument_list|,
name|sec
argument_list|,
name|value
argument_list|,
name|unresolved_reloc
argument_list|,
name|warned
argument_list|)
expr_stmt|;
if|if
condition|(
name|warned
condition|)
continue|continue;
if|if
condition|(
name|value
operator|==
literal|0
operator|&&
operator|!
name|unresolved_reloc
operator|&&
name|hh
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
name|undef_weak_ref
operator|=
name|TRUE
expr_stmt|;
name|h
operator|=
operator|(
expr|struct
name|alpha_elf_link_hash_entry
operator|*
operator|)
name|hh
expr_stmt|;
name|dynamic_symbol_p
operator|=
name|alpha_elf_dynamic_symbol_p
argument_list|(
operator|&
name|h
operator|->
name|root
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|gotent
operator|=
name|h
operator|->
name|got_entries
expr_stmt|;
block|}
name|addend
operator|=
name|rel
operator|->
name|r_addend
expr_stmt|;
name|value
operator|+=
name|addend
expr_stmt|;
comment|/* Search for the proper got entry.  */
for|for
control|(
init|;
name|gotent
condition|;
name|gotent
operator|=
name|gotent
operator|->
name|next
control|)
if|if
condition|(
name|gotent
operator|->
name|gotobj
operator|==
name|gotobj
operator|&&
name|gotent
operator|->
name|reloc_type
operator|==
name|r_type
operator|&&
name|gotent
operator|->
name|addend
operator|==
name|addend
condition|)
break|break;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_ALPHA_GPDISP
case|:
block|{
name|bfd_byte
modifier|*
name|p_ldah
decl_stmt|,
modifier|*
name|p_lda
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|gp
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|value
operator|=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|rel
operator|->
name|r_offset
operator|)
expr_stmt|;
name|p_ldah
operator|=
name|contents
operator|+
name|rel
operator|->
name|r_offset
expr_stmt|;
name|p_lda
operator|=
name|p_ldah
operator|+
name|rel
operator|->
name|r_addend
expr_stmt|;
name|r
operator|=
name|elf64_alpha_do_reloc_gpdisp
argument_list|(
name|input_bfd
argument_list|,
name|gp
operator|-
name|value
argument_list|,
name|p_ldah
argument_list|,
name|p_lda
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|R_ALPHA_LITERAL
case|:
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|gp
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|gotent
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|gotent
operator|->
name|use_count
operator|>=
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gotent
operator|->
name|reloc_done
condition|)
block|{
name|gotent
operator|->
name|reloc_done
operator|=
literal|1
expr_stmt|;
name|bfd_put_64
argument_list|(
name|output_bfd
argument_list|,
name|value
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|gotent
operator|->
name|got_offset
argument_list|)
expr_stmt|;
comment|/* If the symbol has been forced local, output a 		 RELATIVE reloc, otherwise it will be handled in 		 finish_dynamic_symbol.  */
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
operator|!
name|dynamic_symbol_p
condition|)
name|elf64_alpha_emit_dynrel
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|sgot
argument_list|,
name|srelgot
argument_list|,
name|gotent
operator|->
name|got_offset
argument_list|,
literal|0
argument_list|,
name|R_ALPHA_RELATIVE
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
name|value
operator|=
operator|(
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
name|gotent
operator|->
name|got_offset
operator|)
expr_stmt|;
name|value
operator|-=
name|gp
expr_stmt|;
goto|goto
name|default_reloc
goto|;
case|case
name|R_ALPHA_GPREL32
case|:
comment|/* If the target section was a removed linkonce section, 	     r_symndx will be zero.  In this case, assume that the 	     switch will not be used, so don't fill it in.  If we 	     do nothing here, we'll get relocation truncated messages, 	     due to the placement of the application above 4GB.  */
if|if
condition|(
name|r_symndx
operator|==
literal|0
condition|)
block|{
name|r
operator|=
name|bfd_reloc_ok
expr_stmt|;
break|break;
block|}
comment|/* FALLTHRU */
case|case
name|R_ALPHA_GPREL16
case|:
case|case
name|R_ALPHA_GPRELLOW
case|:
if|if
condition|(
name|dynamic_symbol_p
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: gp-relative relocation against dynamic symbol %s"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|FALSE
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
name|gp
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|value
operator|-=
name|gp
expr_stmt|;
goto|goto
name|default_reloc
goto|;
case|case
name|R_ALPHA_GPRELHIGH
case|:
if|if
condition|(
name|dynamic_symbol_p
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: gp-relative relocation against dynamic symbol %s"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|FALSE
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
name|gp
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|value
operator|-=
name|gp
expr_stmt|;
name|value
operator|=
operator|(
operator|(
name|bfd_signed_vma
operator|)
name|value
operator|>>
literal|16
operator|)
operator|+
operator|(
operator|(
name|value
operator|>>
literal|15
operator|)
operator|&
literal|1
operator|)
expr_stmt|;
goto|goto
name|default_reloc
goto|;
case|case
name|R_ALPHA_HINT
case|:
comment|/* A call to a dynamic symbol is definitely out of range of 	     the 16-bit displacement.  Don't bother writing anything.  */
if|if
condition|(
name|dynamic_symbol_p
condition|)
block|{
name|r
operator|=
name|bfd_reloc_ok
expr_stmt|;
break|break;
block|}
comment|/* The regular PC-relative stuff measures from the start of 	     the instruction rather than the end.  */
name|value
operator|-=
literal|4
expr_stmt|;
goto|goto
name|default_reloc
goto|;
case|case
name|R_ALPHA_BRADDR
case|:
if|if
condition|(
name|dynamic_symbol_p
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: pc-relative relocation against dynamic symbol %s"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* The regular PC-relative stuff measures from the start of 	     the instruction rather than the end.  */
name|value
operator|-=
literal|4
expr_stmt|;
goto|goto
name|default_reloc
goto|;
case|case
name|R_ALPHA_BRSGP
case|:
block|{
name|int
name|other
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* The regular PC-relative stuff measures from the start of 	       the instruction rather than the end.  */
name|value
operator|-=
literal|4
expr_stmt|;
comment|/* The source and destination gp must be the same.  Note that 	       the source will always have an assigned gp, since we forced 	       one in check_relocs, but that the destination may not, as 	       it might not have had any relocations at all.  Also take 	       care not to crash if H is an undefined symbol.  */
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|sec
operator|!=
name|NULL
operator|&&
name|alpha_elf_tdata
argument_list|(
name|sec
operator|->
name|owner
argument_list|)
operator|->
name|gotobj
operator|&&
name|gotobj
operator|!=
name|alpha_elf_tdata
argument_list|(
name|sec
operator|->
name|owner
argument_list|)
operator|->
name|gotobj
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: change in gp: BRSGP %s"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* The symbol should be marked either NOPV or STD_GPLOAD.  */
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|other
operator|=
name|h
operator|->
name|root
operator|.
name|other
expr_stmt|;
else|else
name|other
operator|=
name|sym
operator|->
name|st_other
expr_stmt|;
switch|switch
condition|(
name|other
operator|&
name|STO_ALPHA_STD_GPLOAD
condition|)
block|{
case|case
name|STO_ALPHA_NOPV
case|:
break|break;
case|case
name|STO_ALPHA_STD_GPLOAD
case|:
name|value
operator|+=
literal|8
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
else|else
block|{
name|name
operator|=
operator|(
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_link
argument_list|,
name|sym
operator|->
name|st_name
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|name
operator|=
name|_
argument_list|(
literal|"<unknown>"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|name
operator|=
name|bfd_section_name
argument_list|(
name|input_bfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
block|}
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: !samegp reloc against symbol without .prologue: %s"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
goto|goto
name|default_reloc
goto|;
block|}
case|case
name|R_ALPHA_REFLONG
case|:
case|case
name|R_ALPHA_REFQUAD
case|:
case|case
name|R_ALPHA_DTPREL64
case|:
case|case
name|R_ALPHA_TPREL64
case|:
block|{
name|long
name|dynindx
decl_stmt|,
name|dyntype
init|=
name|r_type
decl_stmt|;
name|bfd_vma
name|dynaddend
decl_stmt|;
comment|/* Careful here to remember RELATIVE relocations for global 	       variables for symbolic shared objects.  */
if|if
condition|(
name|dynamic_symbol_p
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|root
operator|.
name|dynindx
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|dynindx
operator|=
name|h
operator|->
name|root
operator|.
name|dynindx
expr_stmt|;
name|dynaddend
operator|=
name|addend
expr_stmt|;
name|addend
operator|=
literal|0
operator|,
name|value
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r_type
operator|==
name|R_ALPHA_DTPREL64
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|tls_sec
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|value
operator|-=
name|dtp_base
expr_stmt|;
goto|goto
name|default_reloc
goto|;
block|}
elseif|else
if|if
condition|(
name|r_type
operator|==
name|R_ALPHA_TPREL64
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|tls_sec
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
name|value
operator|-=
name|tp_base
expr_stmt|;
goto|goto
name|default_reloc
goto|;
block|}
name|dynindx
operator|=
literal|0
expr_stmt|;
name|dynaddend
operator|=
name|value
operator|-
name|dtp_base
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
name|r_symndx
operator|!=
literal|0
operator|&&
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
condition|)
block|{
if|if
condition|(
name|r_type
operator|==
name|R_ALPHA_REFLONG
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: unhandled dynamic relocation against %s"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|FALSE
expr_stmt|;
block|}
name|dynindx
operator|=
literal|0
expr_stmt|;
name|dyntype
operator|=
name|R_ALPHA_RELATIVE
expr_stmt|;
name|dynaddend
operator|=
name|value
expr_stmt|;
block|}
else|else
goto|goto
name|default_reloc
goto|;
name|elf64_alpha_emit_dynrel
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|input_section
argument_list|,
name|srel
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|dynindx
argument_list|,
name|dyntype
argument_list|,
name|dynaddend
argument_list|)
expr_stmt|;
block|}
goto|goto
name|default_reloc
goto|;
case|case
name|R_ALPHA_SREL16
case|:
case|case
name|R_ALPHA_SREL32
case|:
case|case
name|R_ALPHA_SREL64
case|:
if|if
condition|(
name|dynamic_symbol_p
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: pc-relative relocation against dynamic symbol %s"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* ??? .eh_frame references to discarded sections will be smashed 	     to relocations against SHN_UNDEF.  The .eh_frame format allows 	     NULL to be encoded as 0 in any format, so this works here.  */
if|if
condition|(
name|r_symndx
operator|==
literal|0
condition|)
name|howto
operator|=
operator|(
name|elf64_alpha_howto_table
operator|+
operator|(
name|r_type
operator|-
name|R_ALPHA_SREL32
operator|+
name|R_ALPHA_REFLONG
operator|)
operator|)
expr_stmt|;
goto|goto
name|default_reloc
goto|;
case|case
name|R_ALPHA_TLSLDM
case|:
comment|/* Ignore the symbol for the relocation.  The result is always 	     the current module.  */
name|dynamic_symbol_p
operator|=
literal|0
expr_stmt|;
comment|/* FALLTHRU */
case|case
name|R_ALPHA_TLSGD
case|:
if|if
condition|(
operator|!
name|gotent
operator|->
name|reloc_done
condition|)
block|{
name|gotent
operator|->
name|reloc_done
operator|=
literal|1
expr_stmt|;
comment|/* Note that the module index for the main program is 1.  */
name|bfd_put_64
argument_list|(
name|output_bfd
argument_list|,
operator|!
name|info
operator|->
name|shared
operator|&&
operator|!
name|dynamic_symbol_p
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|gotent
operator|->
name|got_offset
argument_list|)
expr_stmt|;
comment|/* If the symbol has been forced local, output a 		 DTPMOD64 reloc, otherwise it will be handled in 		 finish_dynamic_symbol.  */
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
operator|!
name|dynamic_symbol_p
condition|)
name|elf64_alpha_emit_dynrel
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|sgot
argument_list|,
name|srelgot
argument_list|,
name|gotent
operator|->
name|got_offset
argument_list|,
literal|0
argument_list|,
name|R_ALPHA_DTPMOD64
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynamic_symbol_p
operator|||
name|r_type
operator|==
name|R_ALPHA_TLSLDM
condition|)
name|value
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|BFD_ASSERT
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|tls_sec
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|value
operator|-=
name|dtp_base
expr_stmt|;
block|}
name|bfd_put_64
argument_list|(
name|output_bfd
argument_list|,
name|value
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|gotent
operator|->
name|got_offset
operator|+
literal|8
argument_list|)
expr_stmt|;
block|}
name|value
operator|=
operator|(
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
name|gotent
operator|->
name|got_offset
operator|)
expr_stmt|;
name|value
operator|-=
name|gp
expr_stmt|;
goto|goto
name|default_reloc
goto|;
case|case
name|R_ALPHA_DTPRELHI
case|:
case|case
name|R_ALPHA_DTPRELLO
case|:
case|case
name|R_ALPHA_DTPREL16
case|:
if|if
condition|(
name|dynamic_symbol_p
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: dtp-relative relocation against dynamic symbol %s"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|FALSE
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|tls_sec
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|value
operator|-=
name|dtp_base
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_ALPHA_DTPRELHI
condition|)
name|value
operator|=
operator|(
operator|(
name|bfd_signed_vma
operator|)
name|value
operator|>>
literal|16
operator|)
operator|+
operator|(
operator|(
name|value
operator|>>
literal|15
operator|)
operator|&
literal|1
operator|)
expr_stmt|;
goto|goto
name|default_reloc
goto|;
case|case
name|R_ALPHA_TPRELHI
case|:
case|case
name|R_ALPHA_TPRELLO
case|:
case|case
name|R_ALPHA_TPREL16
case|:
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: TLS local exec code cannot be linked into shared objects"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dynamic_symbol_p
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: tp-relative relocation against dynamic symbol %s"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|FALSE
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|tls_sec
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|value
operator|-=
name|tp_base
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_ALPHA_TPRELHI
condition|)
name|value
operator|=
operator|(
operator|(
name|bfd_signed_vma
operator|)
name|value
operator|>>
literal|16
operator|)
operator|+
operator|(
operator|(
name|value
operator|>>
literal|15
operator|)
operator|&
literal|1
operator|)
expr_stmt|;
goto|goto
name|default_reloc
goto|;
case|case
name|R_ALPHA_GOTDTPREL
case|:
case|case
name|R_ALPHA_GOTTPREL
case|:
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|gp
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|gotent
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|gotent
operator|->
name|use_count
operator|>=
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gotent
operator|->
name|reloc_done
condition|)
block|{
name|gotent
operator|->
name|reloc_done
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|dynamic_symbol_p
condition|)
name|value
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|BFD_ASSERT
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|tls_sec
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_ALPHA_GOTDTPREL
condition|)
name|value
operator|-=
name|dtp_base
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
name|value
operator|-=
name|tp_base
expr_stmt|;
else|else
block|{
name|elf64_alpha_emit_dynrel
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|sgot
argument_list|,
name|srelgot
argument_list|,
name|gotent
operator|->
name|got_offset
argument_list|,
literal|0
argument_list|,
name|R_ALPHA_TPREL64
argument_list|,
name|value
operator|-
name|dtp_base
argument_list|)
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|bfd_put_64
argument_list|(
name|output_bfd
argument_list|,
name|value
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|gotent
operator|->
name|got_offset
argument_list|)
expr_stmt|;
block|}
name|value
operator|=
operator|(
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
name|gotent
operator|->
name|got_offset
operator|)
expr_stmt|;
name|value
operator|-=
name|gp
expr_stmt|;
goto|goto
name|default_reloc
goto|;
default|default:
name|default_reloc
label|:
name|r
operator|=
name|_bfd_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|bfd_reloc_ok
case|:
break|break;
case|case
name|bfd_reloc_overflow
case|:
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Don't warn if the overflow is due to pc relative reloc 	       against discarded section.  Section optimization code should 	       handle it.  */
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
operator|&&
name|sec
operator|!=
name|NULL
operator|&&
name|howto
operator|->
name|pc_relative
operator|&&
name|elf_discarded_section
argument_list|(
name|sec
argument_list|)
condition|)
break|break;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
else|else
block|{
name|name
operator|=
operator|(
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_link
argument_list|,
name|sym
operator|->
name|st_name
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'\0'
condition|)
name|name
operator|=
name|bfd_section_name
argument_list|(
name|input_bfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|info
argument_list|,
name|name
argument_list|,
name|howto
operator|->
name|name
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
condition|)
name|ret_val
operator|=
name|FALSE
expr_stmt|;
block|}
break|break;
default|default:
case|case
name|bfd_reloc_outofrange
case|:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/* Finish up dynamic symbol handling.  We set the contents of various    dynamic sections here.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf64_alpha_finish_dynamic_symbol
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|h
parameter_list|,
name|sym
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
block|{
name|bfd
modifier|*
name|dynobj
init|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|!=
name|MINUS_ONE
condition|)
block|{
comment|/* Fill in the .plt entry for this symbol.  */
name|asection
modifier|*
name|splt
decl_stmt|,
modifier|*
name|sgot
decl_stmt|,
modifier|*
name|srel
decl_stmt|;
name|Elf_Internal_Rela
name|outrel
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|bfd_vma
name|got_addr
decl_stmt|,
name|plt_addr
decl_stmt|;
name|bfd_vma
name|plt_index
decl_stmt|;
name|struct
name|alpha_elf_got_entry
modifier|*
name|gotent
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* The first .got entry will be updated by the .plt with the 	 address of the target function.  */
name|gotent
operator|=
operator|(
operator|(
expr|struct
name|alpha_elf_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|got_entries
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|gotent
operator|&&
name|gotent
operator|->
name|addend
operator|==
literal|0
argument_list|)
expr_stmt|;
name|splt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|splt
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|srel
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.plt"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|srel
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|sgot
operator|=
name|alpha_elf_tdata
argument_list|(
name|gotent
operator|->
name|gotobj
argument_list|)
operator|->
name|got
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|got_addr
operator|=
operator|(
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
name|gotent
operator|->
name|got_offset
operator|)
expr_stmt|;
name|plt_addr
operator|=
operator|(
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|splt
operator|->
name|output_offset
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|)
expr_stmt|;
name|plt_index
operator|=
operator|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|-
name|PLT_HEADER_SIZE
operator|)
operator|/
name|PLT_ENTRY_SIZE
expr_stmt|;
comment|/* Fill in the entry in the procedure linkage table.  */
block|{
name|bfd_vma
name|insn1
decl_stmt|,
name|insn2
decl_stmt|,
name|insn3
decl_stmt|;
name|insn1
operator|=
name|PLT_ENTRY_WORD1
operator||
operator|(
operator|(
operator|-
operator|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
literal|4
operator|)
operator|>>
literal|2
operator|)
operator|&
literal|0x1fffff
operator|)
expr_stmt|;
name|insn2
operator|=
name|PLT_ENTRY_WORD2
expr_stmt|;
name|insn3
operator|=
name|PLT_ENTRY_WORD3
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|insn1
argument_list|,
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|insn2
argument_list|,
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|insn3
argument_list|,
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
literal|8
argument_list|)
expr_stmt|;
block|}
comment|/* Fill in the entry in the .rela.plt section.  */
name|outrel
operator|.
name|r_offset
operator|=
name|got_addr
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_ALPHA_JMP_SLOT
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
name|loc
operator|=
name|srel
operator|->
name|contents
operator|+
name|plt_index
operator|*
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
name|bfd_elf64_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
condition|)
block|{
comment|/* Mark the symbol as undefined, rather than as defined in the 	     .plt section.  Leave the value alone.  */
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_UNDEF
expr_stmt|;
block|}
comment|/* Fill in the entries in the .got.  */
name|bfd_put_64
argument_list|(
name|output_bfd
argument_list|,
name|plt_addr
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|gotent
operator|->
name|got_offset
argument_list|)
expr_stmt|;
comment|/* Subsequent .got entries will continue to bounce through the .plt.  */
if|if
condition|(
name|gotent
operator|->
name|next
condition|)
block|{
name|srel
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
operator|!
name|info
operator|->
name|shared
operator|||
name|srel
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|gotent
operator|=
name|gotent
operator|->
name|next
expr_stmt|;
do|do
block|{
name|sgot
operator|=
name|alpha_elf_tdata
argument_list|(
name|gotent
operator|->
name|gotobj
argument_list|)
operator|->
name|got
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|gotent
operator|->
name|addend
operator|==
literal|0
argument_list|)
expr_stmt|;
name|bfd_put_64
argument_list|(
name|output_bfd
argument_list|,
name|plt_addr
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|gotent
operator|->
name|got_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
name|elf64_alpha_emit_dynrel
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|sgot
argument_list|,
name|srel
argument_list|,
name|gotent
operator|->
name|got_offset
argument_list|,
literal|0
argument_list|,
name|R_ALPHA_RELATIVE
argument_list|,
name|plt_addr
argument_list|)
expr_stmt|;
name|gotent
operator|=
name|gotent
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|gotent
operator|!=
name|NULL
condition|)
do|;
block|}
block|}
elseif|else
if|if
condition|(
name|alpha_elf_dynamic_symbol_p
argument_list|(
name|h
argument_list|,
name|info
argument_list|)
condition|)
block|{
comment|/* Fill in the dynamic relocations for this symbol's .got entries.  */
name|asection
modifier|*
name|srel
decl_stmt|;
name|struct
name|alpha_elf_got_entry
modifier|*
name|gotent
decl_stmt|;
name|srel
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|srel
operator|!=
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|gotent
operator|=
operator|(
operator|(
expr|struct
name|alpha_elf_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|got_entries
init|;
name|gotent
operator|!=
name|NULL
condition|;
name|gotent
operator|=
name|gotent
operator|->
name|next
control|)
block|{
name|asection
modifier|*
name|sgot
decl_stmt|;
name|long
name|r_type
decl_stmt|;
if|if
condition|(
name|gotent
operator|->
name|use_count
operator|==
literal|0
condition|)
continue|continue;
name|sgot
operator|=
name|alpha_elf_tdata
argument_list|(
name|gotent
operator|->
name|gotobj
argument_list|)
operator|->
name|got
expr_stmt|;
name|r_type
operator|=
name|gotent
operator|->
name|reloc_type
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_ALPHA_LITERAL
case|:
name|r_type
operator|=
name|R_ALPHA_GLOB_DAT
expr_stmt|;
break|break;
case|case
name|R_ALPHA_TLSGD
case|:
name|r_type
operator|=
name|R_ALPHA_DTPMOD64
expr_stmt|;
break|break;
case|case
name|R_ALPHA_GOTDTPREL
case|:
name|r_type
operator|=
name|R_ALPHA_DTPREL64
expr_stmt|;
break|break;
case|case
name|R_ALPHA_GOTTPREL
case|:
name|r_type
operator|=
name|R_ALPHA_TPREL64
expr_stmt|;
break|break;
case|case
name|R_ALPHA_TLSLDM
case|:
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|elf64_alpha_emit_dynrel
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|sgot
argument_list|,
name|srel
argument_list|,
name|gotent
operator|->
name|got_offset
argument_list|,
name|h
operator|->
name|dynindx
argument_list|,
name|r_type
argument_list|,
name|gotent
operator|->
name|addend
argument_list|)
expr_stmt|;
if|if
condition|(
name|gotent
operator|->
name|reloc_type
operator|==
name|R_ALPHA_TLSGD
condition|)
name|elf64_alpha_emit_dynrel
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|sgot
argument_list|,
name|srel
argument_list|,
name|gotent
operator|->
name|got_offset
operator|+
literal|8
argument_list|,
name|h
operator|->
name|dynindx
argument_list|,
name|R_ALPHA_DTPREL64
argument_list|,
name|gotent
operator|->
name|addend
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Mark some specially defined symbols as absolute.  */
if|if
condition|(
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_DYNAMIC"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_PROCEDURE_LINKAGE_TABLE_"
argument_list|)
operator|==
literal|0
condition|)
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_ABS
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Finish up the dynamic sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf64_alpha_finish_dynamic_sections
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|sdyn
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|sdyn
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
name|asection
modifier|*
name|splt
decl_stmt|;
name|Elf64_External_Dyn
modifier|*
name|dyncon
decl_stmt|,
modifier|*
name|dynconend
decl_stmt|;
name|splt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|splt
operator|!=
name|NULL
operator|&&
name|sdyn
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dyncon
operator|=
operator|(
name|Elf64_External_Dyn
operator|*
operator|)
name|sdyn
operator|->
name|contents
expr_stmt|;
name|dynconend
operator|=
operator|(
name|Elf64_External_Dyn
operator|*
operator|)
operator|(
name|sdyn
operator|->
name|contents
operator|+
name|sdyn
operator|->
name|_raw_size
operator|)
expr_stmt|;
for|for
control|(
init|;
name|dyncon
operator|<
name|dynconend
condition|;
name|dyncon
operator|++
control|)
block|{
name|Elf_Internal_Dyn
name|dyn
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_elf64_swap_dyn_in
argument_list|(
name|dynobj
argument_list|,
name|dyncon
argument_list|,
operator|&
name|dyn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dyn
operator|.
name|d_tag
condition|)
block|{
case|case
name|DT_PLTGOT
case|:
name|name
operator|=
literal|".plt"
expr_stmt|;
goto|goto
name|get_vma
goto|;
case|case
name|DT_PLTRELSZ
case|:
name|name
operator|=
literal|".rela.plt"
expr_stmt|;
goto|goto
name|get_size
goto|;
case|case
name|DT_JMPREL
case|:
name|name
operator|=
literal|".rela.plt"
expr_stmt|;
goto|goto
name|get_vma
goto|;
case|case
name|DT_RELASZ
case|:
comment|/* My interpretation of the TIS v1.1 ELF document indicates 		 that RELASZ should not include JMPREL.  This is not what 		 the rest of the BFD does.  It is, however, what the 		 glibc ld.so wants.  Do this fixup here until we found 		 out who is right.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
literal|".rela.plt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|-=
operator|(
name|s
operator|->
name|_cooked_size
condition|?
name|s
operator|->
name|_cooked_size
else|:
name|s
operator|->
name|_raw_size
operator|)
expr_stmt|;
block|}
break|break;
name|get_vma
label|:
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
operator|(
name|s
condition|?
name|s
operator|->
name|vma
else|:
literal|0
operator|)
expr_stmt|;
break|break;
name|get_size
label|:
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
operator|(
name|s
operator|->
name|_cooked_size
condition|?
name|s
operator|->
name|_cooked_size
else|:
name|s
operator|->
name|_raw_size
operator|)
expr_stmt|;
break|break;
block|}
name|bfd_elf64_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize the PLT0 entry.  */
if|if
condition|(
name|splt
operator|->
name|_raw_size
operator|>
literal|0
condition|)
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|PLT_HEADER_WORD1
argument_list|,
name|splt
operator|->
name|contents
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|PLT_HEADER_WORD2
argument_list|,
name|splt
operator|->
name|contents
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|PLT_HEADER_WORD3
argument_list|,
name|splt
operator|->
name|contents
operator|+
literal|8
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|PLT_HEADER_WORD4
argument_list|,
name|splt
operator|->
name|contents
operator|+
literal|12
argument_list|)
expr_stmt|;
comment|/* The next two words will be filled in by ld.so */
name|bfd_put_64
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|splt
operator|->
name|contents
operator|+
literal|16
argument_list|)
expr_stmt|;
name|bfd_put_64
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|splt
operator|->
name|contents
operator|+
literal|24
argument_list|)
expr_stmt|;
name|elf_section_data
argument_list|(
name|splt
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* We need to use a special link routine to handle the .mdebug section.    We need to merge all instances of these sections together, not write    them all out sequentially.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf64_alpha_final_link
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|asection
modifier|*
name|o
decl_stmt|;
name|struct
name|bfd_link_order
modifier|*
name|p
decl_stmt|;
name|asection
modifier|*
name|mdebug_sec
decl_stmt|;
name|struct
name|ecoff_debug_info
name|debug
decl_stmt|;
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|swap
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_backend_ecoff_debug_swap
decl_stmt|;
name|HDRR
modifier|*
name|symhdr
init|=
operator|&
name|debug
operator|.
name|symbolic_header
decl_stmt|;
name|PTR
name|mdebug_handle
init|=
name|NULL
decl_stmt|;
comment|/* Go through the sections and collect the mdebug information.  */
name|mdebug_sec
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|o
operator|->
name|name
argument_list|,
literal|".mdebug"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|struct
name|extsym_info
name|einfo
decl_stmt|;
comment|/* We have found the .mdebug section in the output file. 	     Look through all the link_orders comprising it and merge 	     the information together.  */
name|symhdr
operator|->
name|magic
operator|=
name|swap
operator|->
name|sym_magic
expr_stmt|;
comment|/* FIXME: What should the version stamp be?  */
name|symhdr
operator|->
name|vstamp
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|ilineMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|cbLine
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|idnMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|ipdMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|isymMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|ioptMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|iauxMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|issMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|issExtMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|ifdMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|crfd
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|iextMax
operator|=
literal|0
expr_stmt|;
comment|/* We accumulate the debugging information itself in the 	     debug_info structure.  */
name|debug
operator|.
name|line
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|external_dnr
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|external_pdr
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|external_sym
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|external_opt
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|external_aux
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|ss
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|ssext
operator|=
name|debug
operator|.
name|ssext_end
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|external_fdr
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|external_rfd
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|external_ext
operator|=
name|debug
operator|.
name|external_ext_end
operator|=
name|NULL
expr_stmt|;
name|mdebug_handle
operator|=
name|bfd_ecoff_debug_init
argument_list|(
name|abfd
argument_list|,
operator|&
name|debug
argument_list|,
name|swap
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|mdebug_handle
operator|==
operator|(
name|PTR
operator|)
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
literal|1
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|EXTR
name|esym
decl_stmt|;
name|bfd_vma
name|last
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|name
index|[]
init|=
block|{
literal|".text"
block|,
literal|".init"
block|,
literal|".fini"
block|,
literal|".data"
block|,
literal|".rodata"
block|,
literal|".sdata"
block|,
literal|".sbss"
block|,
literal|".bss"
block|}
decl_stmt|;
specifier|static
specifier|const
name|int
name|sc
index|[]
init|=
block|{
name|scText
block|,
name|scInit
block|,
name|scFini
block|,
name|scData
block|,
name|scRData
block|,
name|scSData
block|,
name|scSBss
block|,
name|scBss
block|}
decl_stmt|;
name|esym
operator|.
name|jmptbl
operator|=
literal|0
expr_stmt|;
name|esym
operator|.
name|cobol_main
operator|=
literal|0
expr_stmt|;
name|esym
operator|.
name|weakext
operator|=
literal|0
expr_stmt|;
name|esym
operator|.
name|reserved
operator|=
literal|0
expr_stmt|;
name|esym
operator|.
name|ifd
operator|=
name|ifdNil
expr_stmt|;
name|esym
operator|.
name|asym
operator|.
name|iss
operator|=
name|issNil
expr_stmt|;
name|esym
operator|.
name|asym
operator|.
name|st
operator|=
name|stLocal
expr_stmt|;
name|esym
operator|.
name|asym
operator|.
name|reserved
operator|=
literal|0
expr_stmt|;
name|esym
operator|.
name|asym
operator|.
name|index
operator|=
name|indexNil
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|sc
index|[
name|i
index|]
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|name
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
name|s
operator|->
name|vma
expr_stmt|;
name|last
operator|=
name|s
operator|->
name|vma
operator|+
name|s
operator|->
name|_raw_size
expr_stmt|;
block|}
else|else
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
name|last
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_ecoff_debug_one_external
argument_list|(
name|abfd
argument_list|,
operator|&
name|debug
argument_list|,
name|swap
argument_list|,
name|name
index|[
name|i
index|]
argument_list|,
operator|&
name|esym
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
for|for
control|(
name|p
operator|=
name|o
operator|->
name|link_order_head
init|;
name|p
operator|!=
operator|(
expr|struct
name|bfd_link_order
operator|*
operator|)
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|input_swap
decl_stmt|;
name|struct
name|ecoff_debug_info
name|input_debug
decl_stmt|;
name|char
modifier|*
name|eraw_src
decl_stmt|;
name|char
modifier|*
name|eraw_end
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|type
operator|!=
name|bfd_indirect_link_order
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_data_link_order
condition|)
continue|continue;
name|abort
argument_list|()
expr_stmt|;
block|}
name|input_section
operator|=
name|p
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
expr_stmt|;
name|input_bfd
operator|=
name|input_section
operator|->
name|owner
expr_stmt|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|input_bfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
operator|||
operator|(
name|get_elf_backend_data
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|elf_backend_ecoff_debug_swap
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* I don't know what a non ALPHA ELF bfd would be 		     doing with a .mdebug section, but I don't really 		     want to deal with it.  */
continue|continue;
block|}
name|input_swap
operator|=
operator|(
name|get_elf_backend_data
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|elf_backend_ecoff_debug_swap
operator|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|p
operator|->
name|size
operator|==
name|input_section
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
comment|/* The ECOFF linking code expects that we have already 		 read in the debugging information and set up an 		 ecoff_debug_info structure, so we do that now.  */
if|if
condition|(
operator|!
name|elf64_alpha_read_ecoff_info
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|&
name|input_debug
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
operator|(
name|bfd_ecoff_debug_accumulate
argument_list|(
name|mdebug_handle
argument_list|,
name|abfd
argument_list|,
operator|&
name|debug
argument_list|,
name|swap
argument_list|,
name|input_bfd
argument_list|,
operator|&
name|input_debug
argument_list|,
name|input_swap
argument_list|,
name|info
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
comment|/* Loop through the external symbols.  For each one with 		 interesting information, try to find the symbol in 		 the linker global hash table and save the information 		 for the output external symbols.  */
name|eraw_src
operator|=
name|input_debug
operator|.
name|external_ext
expr_stmt|;
name|eraw_end
operator|=
operator|(
name|eraw_src
operator|+
operator|(
name|input_debug
operator|.
name|symbolic_header
operator|.
name|iextMax
operator|*
name|input_swap
operator|->
name|external_ext_size
operator|)
operator|)
expr_stmt|;
for|for
control|(
init|;
name|eraw_src
operator|<
name|eraw_end
condition|;
name|eraw_src
operator|+=
name|input_swap
operator|->
name|external_ext_size
control|)
block|{
name|EXTR
name|ext
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|alpha_elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
call|(
modifier|*
name|input_swap
operator|->
name|swap_ext_in
call|)
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|PTR
operator|)
name|eraw_src
argument_list|,
operator|&
name|ext
argument_list|)
expr_stmt|;
if|if
condition|(
name|ext
operator|.
name|asym
operator|.
name|sc
operator|==
name|scNil
operator|||
name|ext
operator|.
name|asym
operator|.
name|sc
operator|==
name|scUndefined
operator|||
name|ext
operator|.
name|asym
operator|.
name|sc
operator|==
name|scSUndefined
condition|)
continue|continue;
name|name
operator|=
name|input_debug
operator|.
name|ssext
operator|+
name|ext
operator|.
name|asym
operator|.
name|iss
expr_stmt|;
name|h
operator|=
name|alpha_elf_link_hash_lookup
argument_list|(
name|alpha_elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
name|h
operator|->
name|esym
operator|.
name|ifd
operator|!=
operator|-
literal|2
condition|)
continue|continue;
if|if
condition|(
name|ext
operator|.
name|ifd
operator|!=
operator|-
literal|1
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|ext
operator|.
name|ifd
operator|<
name|input_debug
operator|.
name|symbolic_header
operator|.
name|ifdMax
argument_list|)
expr_stmt|;
name|ext
operator|.
name|ifd
operator|=
name|input_debug
operator|.
name|ifdmap
index|[
name|ext
operator|.
name|ifd
index|]
expr_stmt|;
block|}
name|h
operator|->
name|esym
operator|=
name|ext
expr_stmt|;
block|}
comment|/* Free up the information we just read.  */
name|free
argument_list|(
name|input_debug
operator|.
name|line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|external_dnr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|external_pdr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|external_sym
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|external_opt
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|external_aux
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|ss
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|ssext
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|external_fdr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|external_rfd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|external_ext
argument_list|)
expr_stmt|;
comment|/* Hack: reset the SEC_HAS_CONTENTS flag so that 		 elf_link_input_bfd ignores this section.  */
name|input_section
operator|->
name|flags
operator|&=
operator|~
name|SEC_HAS_CONTENTS
expr_stmt|;
block|}
comment|/* Build the external symbol information.  */
name|einfo
operator|.
name|abfd
operator|=
name|abfd
expr_stmt|;
name|einfo
operator|.
name|info
operator|=
name|info
expr_stmt|;
name|einfo
operator|.
name|debug
operator|=
operator|&
name|debug
expr_stmt|;
name|einfo
operator|.
name|swap
operator|=
name|swap
expr_stmt|;
name|einfo
operator|.
name|failed
operator|=
name|FALSE
expr_stmt|;
name|elf_link_hash_traverse
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|elf64_alpha_output_extsym
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|einfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|einfo
operator|.
name|failed
condition|)
return|return
name|FALSE
return|;
comment|/* Set the size of the .mdebug section.  */
name|o
operator|->
name|_raw_size
operator|=
name|bfd_ecoff_debug_size
argument_list|(
name|abfd
argument_list|,
operator|&
name|debug
argument_list|,
name|swap
argument_list|)
expr_stmt|;
comment|/* Skip this section later on (I don't think this currently 	     matters, but someday it might).  */
name|o
operator|->
name|link_order_head
operator|=
operator|(
expr|struct
name|bfd_link_order
operator|*
operator|)
name|NULL
expr_stmt|;
name|mdebug_sec
operator|=
name|o
expr_stmt|;
block|}
block|}
comment|/* Invoke the regular ELF backend linker to do all the work.  */
if|if
condition|(
operator|!
name|bfd_elf_final_link
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Now write out the computed sections.  */
comment|/* The .got subsections...  */
block|{
name|bfd
modifier|*
name|i
decl_stmt|,
modifier|*
name|dynobj
init|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
decl_stmt|;
for|for
control|(
name|i
operator|=
name|alpha_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|got_list
init|;
name|i
operator|!=
name|NULL
condition|;
name|i
operator|=
name|alpha_elf_tdata
argument_list|(
name|i
argument_list|)
operator|->
name|got_link_next
control|)
block|{
name|asection
modifier|*
name|sgot
decl_stmt|;
comment|/* elf_bfd_final_link already did everything in dynobj.  */
if|if
condition|(
name|i
operator|==
name|dynobj
condition|)
continue|continue;
name|sgot
operator|=
name|alpha_elf_tdata
argument_list|(
name|i
argument_list|)
operator|->
name|got
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|sgot
operator|->
name|output_section
argument_list|,
name|sgot
operator|->
name|contents
argument_list|,
operator|(
name|file_ptr
operator|)
name|sgot
operator|->
name|output_offset
argument_list|,
name|sgot
operator|->
name|_raw_size
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
if|if
condition|(
name|mdebug_sec
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|abfd
operator|->
name|output_has_begun
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_ecoff_write_accumulated_debug
argument_list|(
name|mdebug_handle
argument_list|,
name|abfd
argument_list|,
operator|&
name|debug
argument_list|,
name|swap
argument_list|,
name|info
argument_list|,
name|mdebug_sec
operator|->
name|filepos
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|bfd_ecoff_debug_free
argument_list|(
name|mdebug_handle
argument_list|,
name|abfd
argument_list|,
operator|&
name|debug
argument_list|,
name|swap
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|elf_reloc_type_class
name|elf64_alpha_reloc_type_class
parameter_list|(
name|rela
parameter_list|)
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rela
decl_stmt|;
block|{
switch|switch
condition|(
operator|(
name|int
operator|)
name|ELF64_R_TYPE
argument_list|(
name|rela
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_ALPHA_RELATIVE
case|:
return|return
name|reloc_class_relative
return|;
case|case
name|R_ALPHA_JMP_SLOT
case|:
return|return
name|reloc_class_plt
return|;
case|case
name|R_ALPHA_COPY
case|:
return|return
name|reloc_class_copy
return|;
default|default:
return|return
name|reloc_class_normal
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|struct
name|bfd_elf_special_section
specifier|const
name|elf64_alpha_special_sections
index|[]
init|=
block|{
block|{
literal|".sdata"
block|,
literal|6
block|,
operator|-
literal|2
block|,
name|SHT_PROGBITS
block|,
name|SHF_ALLOC
operator|+
name|SHF_WRITE
operator|+
name|SHF_ALPHA_GPREL
block|}
block|,
block|{
literal|".sbss"
block|,
literal|5
block|,
operator|-
literal|2
block|,
name|SHT_NOBITS
block|,
name|SHF_ALLOC
operator|+
name|SHF_WRITE
operator|+
name|SHF_ALPHA_GPREL
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ECOFF swapping routines.  These are used when dealing with the    .mdebug section, which is in the ECOFF debugging format.  Copied    from elf32-mips.c.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ecoff_debug_swap
name|elf64_alpha_ecoff_debug_swap
init|=
block|{
comment|/* Symbol table magic number.  */
name|magicSym2
block|,
comment|/* Alignment of debugging information.  E.g., 4.  */
literal|8
block|,
comment|/* Sizes of external symbolic information.  */
sizeof|sizeof
argument_list|(
expr|struct
name|hdr_ext
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|dnr_ext
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|pdr_ext
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|sym_ext
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|opt_ext
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|fdr_ext
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|rfd_ext
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ext_ext
argument_list|)
block|,
comment|/* Functions to swap in external symbolic data.  */
name|ecoff_swap_hdr_in
block|,
name|ecoff_swap_dnr_in
block|,
name|ecoff_swap_pdr_in
block|,
name|ecoff_swap_sym_in
block|,
name|ecoff_swap_opt_in
block|,
name|ecoff_swap_fdr_in
block|,
name|ecoff_swap_rfd_in
block|,
name|ecoff_swap_ext_in
block|,
name|_bfd_ecoff_swap_tir_in
block|,
name|_bfd_ecoff_swap_rndx_in
block|,
comment|/* Functions to swap out external symbolic data.  */
name|ecoff_swap_hdr_out
block|,
name|ecoff_swap_dnr_out
block|,
name|ecoff_swap_pdr_out
block|,
name|ecoff_swap_sym_out
block|,
name|ecoff_swap_opt_out
block|,
name|ecoff_swap_fdr_out
block|,
name|ecoff_swap_rfd_out
block|,
name|ecoff_swap_ext_out
block|,
name|_bfd_ecoff_swap_tir_out
block|,
name|_bfd_ecoff_swap_rndx_out
block|,
comment|/* Function to read in symbolic data.  */
name|elf64_alpha_read_ecoff_info
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Use a non-standard hash bucket size of 8.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|elf_size_info
name|alpha_elf_size_info
init|=
block|{
sizeof|sizeof
argument_list|(
name|Elf64_External_Ehdr
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|Elf64_External_Phdr
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|Elf64_External_Shdr
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|Elf64_External_Rel
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|Elf64_External_Sym
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|Elf64_External_Dyn
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|Elf_External_Note
argument_list|)
block|,
literal|8
block|,
literal|1
block|,
literal|64
block|,
literal|3
block|,
name|ELFCLASS64
block|,
name|EV_CURRENT
block|,
name|bfd_elf64_write_out_phdrs
block|,
name|bfd_elf64_write_shdrs_and_ehdr
block|,
name|bfd_elf64_write_relocs
block|,
name|bfd_elf64_swap_symbol_in
block|,
name|bfd_elf64_swap_symbol_out
block|,
name|bfd_elf64_slurp_reloc_table
block|,
name|bfd_elf64_slurp_symbol_table
block|,
name|bfd_elf64_swap_dyn_in
block|,
name|bfd_elf64_swap_dyn_out
block|,
name|bfd_elf64_swap_reloc_in
block|,
name|bfd_elf64_swap_reloc_out
block|,
name|bfd_elf64_swap_reloca_in
block|,
name|bfd_elf64_swap_reloca_out
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TARGET_LITTLE_SYM
value|bfd_elf64_alpha_vec
end_define

begin_define
define|#
directive|define
name|TARGET_LITTLE_NAME
value|"elf64-alpha"
end_define

begin_define
define|#
directive|define
name|ELF_ARCH
value|bfd_arch_alpha
end_define

begin_define
define|#
directive|define
name|ELF_MACHINE_CODE
value|EM_ALPHA
end_define

begin_define
define|#
directive|define
name|ELF_MAXPAGESIZE
value|0x10000
end_define

begin_define
define|#
directive|define
name|bfd_elf64_bfd_link_hash_table_create
define|\
value|elf64_alpha_bfd_link_hash_table_create
end_define

begin_define
define|#
directive|define
name|bfd_elf64_bfd_reloc_type_lookup
define|\
value|elf64_alpha_bfd_reloc_type_lookup
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto
define|\
value|elf64_alpha_info_to_howto
end_define

begin_define
define|#
directive|define
name|bfd_elf64_mkobject
define|\
value|elf64_alpha_mkobject
end_define

begin_define
define|#
directive|define
name|elf_backend_object_p
define|\
value|elf64_alpha_object_p
end_define

begin_define
define|#
directive|define
name|elf_backend_section_from_shdr
define|\
value|elf64_alpha_section_from_shdr
end_define

begin_define
define|#
directive|define
name|elf_backend_section_flags
define|\
value|elf64_alpha_section_flags
end_define

begin_define
define|#
directive|define
name|elf_backend_fake_sections
define|\
value|elf64_alpha_fake_sections
end_define

begin_define
define|#
directive|define
name|bfd_elf64_bfd_is_local_label_name
define|\
value|elf64_alpha_is_local_label_name
end_define

begin_define
define|#
directive|define
name|bfd_elf64_find_nearest_line
define|\
value|elf64_alpha_find_nearest_line
end_define

begin_define
define|#
directive|define
name|bfd_elf64_bfd_relax_section
define|\
value|elf64_alpha_relax_section
end_define

begin_define
define|#
directive|define
name|elf_backend_add_symbol_hook
define|\
value|elf64_alpha_add_symbol_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_check_relocs
define|\
value|elf64_alpha_check_relocs
end_define

begin_define
define|#
directive|define
name|elf_backend_create_dynamic_sections
define|\
value|elf64_alpha_create_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_adjust_dynamic_symbol
define|\
value|elf64_alpha_adjust_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_always_size_sections
define|\
value|elf64_alpha_always_size_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_size_dynamic_sections
define|\
value|elf64_alpha_size_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_relocate_section
define|\
value|elf64_alpha_relocate_section
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_symbol
define|\
value|elf64_alpha_finish_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_sections
define|\
value|elf64_alpha_finish_dynamic_sections
end_define

begin_define
define|#
directive|define
name|bfd_elf64_bfd_final_link
define|\
value|elf64_alpha_final_link
end_define

begin_define
define|#
directive|define
name|elf_backend_reloc_type_class
define|\
value|elf64_alpha_reloc_type_class
end_define

begin_define
define|#
directive|define
name|elf_backend_ecoff_debug_swap
define|\
value|&elf64_alpha_ecoff_debug_swap
end_define

begin_define
define|#
directive|define
name|elf_backend_size_info
define|\
value|alpha_elf_size_info
end_define

begin_define
define|#
directive|define
name|elf_backend_special_sections
define|\
value|elf64_alpha_special_sections
end_define

begin_comment
comment|/* A few constants that determine how the .plt section is set up.  */
end_comment

begin_define
define|#
directive|define
name|elf_backend_want_got_plt
value|0
end_define

begin_define
define|#
directive|define
name|elf_backend_plt_readonly
value|0
end_define

begin_define
define|#
directive|define
name|elf_backend_want_plt_sym
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_got_header_size
value|0
end_define

begin_include
include|#
directive|include
file|"elf64-target.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* FreeBSD support.  */
end_comment

begin_undef
undef|#
directive|undef
name|TARGET_LITTLE_SYM
end_undef

begin_define
define|#
directive|define
name|TARGET_LITTLE_SYM
value|bfd_elf64_alpha_freebsd_vec
end_define

begin_undef
undef|#
directive|undef
name|TARGET_LITTLE_NAME
end_undef

begin_define
define|#
directive|define
name|TARGET_LITTLE_NAME
value|"elf64-alpha-freebsd"
end_define

begin_comment
comment|/* The kernel recognizes executables as valid only if they carry a    "FreeBSD" label in the ELF header.  So we put this label on all    executables and (for simplicity) also all other object files.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|elf64_alpha_fbsd_post_process_headers
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|elf64_alpha_fbsd_post_process_headers
parameter_list|(
name|abfd
parameter_list|,
name|link_info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|link_info
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|Elf_Internal_Ehdr
modifier|*
name|i_ehdrp
decl_stmt|;
comment|/* ELF file header, internal form.  */
name|i_ehdrp
operator|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* Put an ABI label supported by FreeBSD>= 4.1.  */
name|i_ehdrp
operator|->
name|e_ident
index|[
name|EI_OSABI
index|]
operator|=
name|ELFOSABI_FREEBSD
expr_stmt|;
ifdef|#
directive|ifdef
name|OLD_FREEBSD_ABI_LABEL
comment|/* The ABI label supported by FreeBSD<= 4.0 is quite nonstandard.  */
name|memcpy
argument_list|(
operator|&
name|i_ehdrp
operator|->
name|e_ident
index|[
name|EI_ABIVERSION
index|]
argument_list|,
literal|"FreeBSD"
argument_list|,
literal|8
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_undef
undef|#
directive|undef
name|elf_backend_post_process_headers
end_undef

begin_define
define|#
directive|define
name|elf_backend_post_process_headers
define|\
value|elf64_alpha_fbsd_post_process_headers
end_define

begin_undef
undef|#
directive|undef
name|elf64_bed
end_undef

begin_define
define|#
directive|define
name|elf64_bed
value|elf64_alpha_fbsd_bed
end_define

begin_include
include|#
directive|include
file|"elf64-target.h"
end_include

end_unit

