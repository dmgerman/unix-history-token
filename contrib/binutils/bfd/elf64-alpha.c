begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Alpha specific support for 64-bit ELF    Copyright 1996, 1997, 1998, 1999, 2000, 2001    Free Software Foundation, Inc.    Contributed by Richard Henderson<rth@tamu.edu>.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* We need a published ABI spec for this.  Until one comes out, don't    assume this'll remain unchanged forever.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf/alpha.h"
end_include

begin_define
define|#
directive|define
name|ALPHAECOFF
end_define

begin_define
define|#
directive|define
name|NO_COFF_RELOCS
end_define

begin_define
define|#
directive|define
name|NO_COFF_SYMBOLS
end_define

begin_define
define|#
directive|define
name|NO_COFF_LINENOS
end_define

begin_comment
comment|/* Get the ECOFF swapping routines.  Needed for the debug information.  */
end_comment

begin_include
include|#
directive|include
file|"coff/internal.h"
end_include

begin_include
include|#
directive|include
file|"coff/sym.h"
end_include

begin_include
include|#
directive|include
file|"coff/symconst.h"
end_include

begin_include
include|#
directive|include
file|"coff/ecoff.h"
end_include

begin_include
include|#
directive|include
file|"coff/alpha.h"
end_include

begin_include
include|#
directive|include
file|"aout/ar.h"
end_include

begin_include
include|#
directive|include
file|"libcoff.h"
end_include

begin_include
include|#
directive|include
file|"libecoff.h"
end_include

begin_define
define|#
directive|define
name|ECOFF_64
end_define

begin_include
include|#
directive|include
file|"ecoffswap.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|alpha_elf_dynamic_symbol_p
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|elf64_alpha_link_hash_newfunc
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|,
expr|struct
name|bfd_hash_table
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bfd_link_hash_table
modifier|*
name|elf64_alpha_bfd_link_hash_table_create
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|elf64_alpha_reloc_nil
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|elf64_alpha_reloc_bad
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|elf64_alpha_do_reloc_gpdisp
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd_vma
operator|,
name|bfd_byte
operator|*
operator|,
name|bfd_byte
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|elf64_alpha_reloc_gpdisp
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
modifier|*
name|elf64_alpha_bfd_reloc_type_lookup
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd_reloc_code_real_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|elf64_alpha_info_to_howto
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|Elf64_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf64_alpha_mkobject
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf64_alpha_object_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf64_alpha_section_from_shdr
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf64_Internal_Shdr
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf64_alpha_fake_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf64_Internal_Shdr
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf64_alpha_create_got_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf64_alpha_create_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf64_alpha_read_ecoff_info
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
expr|struct
name|ecoff_debug_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf64_alpha_is_local_label_name
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf64_alpha_find_nearest_line
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|asymbol
operator|*
operator|*
operator|,
name|bfd_vma
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|unsigned
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|||
name|defined
argument_list|(
name|ALMOST_STDC
argument_list|)
end_if

begin_struct_decl
struct_decl|struct
name|alpha_elf_link_hash_entry
struct_decl|;
end_struct_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|boolean
name|elf64_alpha_output_extsym
name|PARAMS
argument_list|(
operator|(
expr|struct
name|alpha_elf_link_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf64_alpha_can_merge_gots
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|elf64_alpha_merge_gots
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf64_alpha_calc_got_offsets_for_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|alpha_elf_link_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|elf64_alpha_calc_got_offsets
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf64_alpha_size_got_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf64_alpha_always_size_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf64_alpha_calc_dynrel_sizes
name|PARAMS
argument_list|(
operator|(
expr|struct
name|alpha_elf_link_hash_entry
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf64_alpha_add_symbol_hook
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
specifier|const
name|Elf_Internal_Sym
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|flagword
operator|*
operator|,
name|asection
operator|*
operator|*
operator|,
name|bfd_vma
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf64_alpha_check_relocs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|asection
operator|*
name|sec
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf64_alpha_adjust_dynamic_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf64_alpha_size_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf64_alpha_relocate_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|,
name|asection
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf64_alpha_finish_dynamic_symbol
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf64_alpha_finish_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf64_alpha_final_link
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf64_alpha_merge_ind_symbols
name|PARAMS
argument_list|(
operator|(
expr|struct
name|alpha_elf_link_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Elf_Internal_Rela
modifier|*
name|elf64_alpha_find_reloc_at_ofs
name|PARAMS
argument_list|(
operator|(
name|Elf_Internal_Rela
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
name|bfd_vma
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_struct
struct|struct
name|alpha_elf_link_hash_entry
block|{
name|struct
name|elf_link_hash_entry
name|root
decl_stmt|;
comment|/* External symbol information.  */
name|EXTR
name|esym
decl_stmt|;
comment|/* Cumulative flags for all the .got entries.  */
name|int
name|flags
decl_stmt|;
comment|/* Contexts (LITUSE) in which a literal was referenced.  */
define|#
directive|define
name|ALPHA_ELF_LINK_HASH_LU_ADDR
value|0x01
define|#
directive|define
name|ALPHA_ELF_LINK_HASH_LU_MEM
value|0x02
define|#
directive|define
name|ALPHA_ELF_LINK_HASH_LU_BYTE
value|0x04
define|#
directive|define
name|ALPHA_ELF_LINK_HASH_LU_FUNC
value|0x08
comment|/* Used to implement multiple .got subsections.  */
struct|struct
name|alpha_elf_got_entry
block|{
name|struct
name|alpha_elf_got_entry
modifier|*
name|next
decl_stmt|;
comment|/* which .got subsection?  */
name|bfd
modifier|*
name|gotobj
decl_stmt|;
comment|/* the addend in effect for this entry.  */
name|bfd_vma
name|addend
decl_stmt|;
comment|/* the .got offset for this entry.  */
name|int
name|got_offset
decl_stmt|;
name|int
name|flags
decl_stmt|;
comment|/* An additional flag.  */
define|#
directive|define
name|ALPHA_ELF_GOT_ENTRY_RELOCS_DONE
value|0x10
name|int
name|use_count
decl_stmt|;
block|}
modifier|*
name|got_entries
struct|;
comment|/* used to count non-got, non-plt relocations for delayed sizing      of relocation sections.  */
struct|struct
name|alpha_elf_reloc_entry
block|{
name|struct
name|alpha_elf_reloc_entry
modifier|*
name|next
decl_stmt|;
comment|/* which .reloc section? */
name|asection
modifier|*
name|srel
decl_stmt|;
comment|/* what kind of relocation? */
name|unsigned
name|long
name|rtype
decl_stmt|;
comment|/* how many did we find?  */
name|unsigned
name|long
name|count
decl_stmt|;
block|}
modifier|*
name|reloc_entries
struct|;
block|}
struct|;
end_struct

begin_comment
comment|/* Alpha ELF linker hash table.  */
end_comment

begin_struct
struct|struct
name|alpha_elf_link_hash_table
block|{
name|struct
name|elf_link_hash_table
name|root
decl_stmt|;
comment|/* The head of a list of .got subsections linked through      alpha_elf_tdata(abfd)->got_link_next.  */
name|bfd
modifier|*
name|got_list
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Look up an entry in a Alpha ELF linker hash table.  */
end_comment

begin_define
define|#
directive|define
name|alpha_elf_link_hash_lookup
parameter_list|(
name|table
parameter_list|,
name|string
parameter_list|,
name|create
parameter_list|,
name|copy
parameter_list|,
name|follow
parameter_list|)
define|\
value|((struct alpha_elf_link_hash_entry *)					\    elf_link_hash_lookup (&(table)->root, (string), (create),		\ 			 (copy), (follow)))
end_define

begin_comment
comment|/* Traverse a Alpha ELF linker hash table.  */
end_comment

begin_define
define|#
directive|define
name|alpha_elf_link_hash_traverse
parameter_list|(
name|table
parameter_list|,
name|func
parameter_list|,
name|info
parameter_list|)
define|\
value|(elf_link_hash_traverse						\    (&(table)->root,							\     (boolean (*) PARAMS ((struct elf_link_hash_entry *, PTR))) (func),	\     (info)))
end_define

begin_comment
comment|/* Get the Alpha ELF linker hash table from a link_info structure.  */
end_comment

begin_define
define|#
directive|define
name|alpha_elf_hash_table
parameter_list|(
name|p
parameter_list|)
define|\
value|((struct alpha_elf_link_hash_table *) ((p)->hash))
end_define

begin_comment
comment|/* Get the object's symbols as our own entry type.  */
end_comment

begin_define
define|#
directive|define
name|alpha_elf_sym_hashes
parameter_list|(
name|abfd
parameter_list|)
define|\
value|((struct alpha_elf_link_hash_entry **)elf_sym_hashes(abfd))
end_define

begin_comment
comment|/* Should we do dynamic things to this symbol?  */
end_comment

begin_function
specifier|static
name|int
name|alpha_elf_dynamic_symbol_p
parameter_list|(
name|h
parameter_list|,
name|info
parameter_list|)
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
return|return
name|false
return|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
return|return
name|false
return|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
return|return
name|true
return|;
switch|switch
condition|(
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
condition|)
block|{
case|case
name|STV_DEFAULT
case|:
break|break;
case|case
name|STV_HIDDEN
case|:
case|case
name|STV_INTERNAL
case|:
return|return
name|false
return|;
case|case
name|STV_PROTECTED
case|:
if|if
condition|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
condition|)
return|return
name|false
return|;
break|break;
block|}
if|if
condition|(
operator|(
name|info
operator|->
name|shared
operator|&&
operator|!
name|info
operator|->
name|symbolic
operator|)
operator|||
operator|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
operator|(
name|ELF_LINK_HASH_DEF_DYNAMIC
operator||
name|ELF_LINK_HASH_REF_REGULAR
operator|)
operator|)
operator|==
operator|(
name|ELF_LINK_HASH_DEF_DYNAMIC
operator||
name|ELF_LINK_HASH_REF_REGULAR
operator|)
operator|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Create an entry in a Alpha ELF linker hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|elf64_alpha_link_hash_newfunc
parameter_list|(
name|entry
parameter_list|,
name|table
parameter_list|,
name|string
parameter_list|)
name|struct
name|bfd_hash_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|bfd_hash_table
modifier|*
name|table
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|struct
name|alpha_elf_link_hash_entry
modifier|*
name|ret
init|=
operator|(
expr|struct
name|alpha_elf_link_hash_entry
operator|*
operator|)
name|entry
decl_stmt|;
comment|/* Allocate the structure if it has not already been allocated by a      subclass.  */
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|alpha_elf_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
name|ret
operator|=
operator|(
operator|(
expr|struct
name|alpha_elf_link_hash_entry
operator|*
operator|)
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|alpha_elf_link_hash_entry
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|alpha_elf_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
comment|/* Call the allocation method of the superclass.  */
name|ret
operator|=
operator|(
operator|(
expr|struct
name|alpha_elf_link_hash_entry
operator|*
operator|)
name|_bfd_elf_link_hash_newfunc
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
operator|(
expr|struct
name|alpha_elf_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* Set local fields.  */
name|memset
argument_list|(
operator|&
name|ret
operator|->
name|esym
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|EXTR
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We use -2 as a marker to indicate that the information has 	 not been set.  -1 means there is no associated ifd.  */
name|ret
operator|->
name|esym
operator|.
name|ifd
operator|=
operator|-
literal|2
expr_stmt|;
name|ret
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|got_entries
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|reloc_entries
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Create a Alpha ELF linker hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_link_hash_table
modifier|*
name|elf64_alpha_bfd_link_hash_table_create
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|alpha_elf_link_hash_table
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
operator|(
operator|(
expr|struct
name|alpha_elf_link_hash_table
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|alpha_elf_link_hash_table
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|alpha_elf_link_hash_table
operator|*
operator|)
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|_bfd_elf_link_hash_table_init
argument_list|(
operator|&
name|ret
operator|->
name|root
argument_list|,
name|abfd
argument_list|,
name|elf64_alpha_link_hash_newfunc
argument_list|)
condition|)
block|{
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
operator|&
name|ret
operator|->
name|root
operator|.
name|root
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* We have some private fields hanging off of the elf_tdata structure.  */
end_comment

begin_struct
struct|struct
name|alpha_elf_obj_tdata
block|{
name|struct
name|elf_obj_tdata
name|root
decl_stmt|;
comment|/* For every input file, these are the got entries for that object's      local symbols.  */
name|struct
name|alpha_elf_got_entry
modifier|*
modifier|*
name|local_got_entries
decl_stmt|;
comment|/* For every input file, this is the object that owns the got that      this input file uses.  */
name|bfd
modifier|*
name|gotobj
decl_stmt|;
comment|/* For every got, this is a linked list through the objects using this got */
name|bfd
modifier|*
name|in_got_link_next
decl_stmt|;
comment|/* For every got, this is a link to the next got subsegment.  */
name|bfd
modifier|*
name|got_link_next
decl_stmt|;
comment|/* For every got, this is the section.  */
name|asection
modifier|*
name|got
decl_stmt|;
comment|/* For every got, this is it's total number of *entries*.  */
name|int
name|total_got_entries
decl_stmt|;
comment|/* For every got, this is the sum of the number of *entries* required      to hold all of the member object's local got.  */
name|int
name|n_local_got_entries
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|alpha_elf_tdata
parameter_list|(
name|abfd
parameter_list|)
define|\
value|((struct alpha_elf_obj_tdata *) (abfd)->tdata.any)
end_define

begin_function
specifier|static
name|boolean
name|elf64_alpha_mkobject
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|abfd
operator|->
name|tdata
operator|.
name|any
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|alpha_elf_obj_tdata
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|tdata
operator|.
name|any
operator|==
name|NULL
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|elf64_alpha_object_p
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
comment|/* Allocate our special target data.  */
name|struct
name|alpha_elf_obj_tdata
modifier|*
name|new_tdata
decl_stmt|;
name|new_tdata
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|alpha_elf_obj_tdata
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_tdata
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|new_tdata
operator|->
name|root
operator|=
operator|*
name|abfd
operator|->
name|tdata
operator|.
name|elf_obj_data
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|any
operator|=
name|new_tdata
expr_stmt|;
comment|/* Set the right machine number for an Alpha ELF file.  */
return|return
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_alpha
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* In case we're on a 32-bit machine, construct a 64-bit "-1" value    from smaller values.  Start with zero, widen, *then* decrement.  */
end_comment

begin_define
define|#
directive|define
name|MINUS_ONE
value|(((bfd_vma)0) - 1)
end_define

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|elf64_alpha_howto_table
index|[]
init|=
block|{
name|HOWTO
argument_list|(
name|R_ALPHA_NONE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|elf64_alpha_reloc_nil
argument_list|,
comment|/* special_function */
literal|"NONE"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 32 bit reference to a symbol.  */
name|HOWTO
argument_list|(
name|R_ALPHA_REFLONG
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"REFLONG"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 64 bit reference to a symbol.  */
name|HOWTO
argument_list|(
name|R_ALPHA_REFQUAD
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"REFQUAD"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
name|MINUS_ONE
argument_list|,
comment|/* src_mask */
name|MINUS_ONE
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 32 bit GP relative offset.  This is just like REFLONG except      that when the value is used the value of the gp register will be      added in.  */
name|HOWTO
argument_list|(
name|R_ALPHA_GPREL32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"GPREL32"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used for an instruction that refers to memory off the GP register.  */
name|HOWTO
argument_list|(
name|R_ALPHA_LITERAL
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"ELF_LITERAL"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* This reloc only appears immediately following an ELF_LITERAL reloc.      It identifies a use of the literal.  The symbol index is special:      1 means the literal address is in the base register of a memory      format instruction; 2 means the literal address is in the byte      offset register of a byte-manipulation instruction; 3 means the      literal address is in the target register of a jsr instruction.      This does not actually do any relocation.  */
name|HOWTO
argument_list|(
name|R_ALPHA_LITUSE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|elf64_alpha_reloc_nil
argument_list|,
comment|/* special_function */
literal|"LITUSE"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Load the gp register.  This is always used for a ldah instruction      which loads the upper 16 bits of the gp register.  The symbol      index of the GPDISP instruction is an offset in bytes to the lda      instruction that loads the lower 16 bits.  The value to use for      the relocation is the difference between the GP value and the      current location; the load will always be done against a register      holding the current address.       NOTE: Unlike ECOFF, partial in-place relocation is not done.  If      any offset is present in the instructions, it is an offset from      the register to the ldah instruction.  This lets us avoid any      stupid hackery like inventing a gp value to do partial relocation      against.  Also unlike ECOFF, we do the whole relocation off of      the GPDISP rather than a GPDISP_HI16/GPDISP_LO16 pair.  An odd,      space consuming bit, that, since all the information was present      in the GPDISP_HI16 reloc.  */
name|HOWTO
argument_list|(
name|R_ALPHA_GPDISP
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|elf64_alpha_reloc_gpdisp
argument_list|,
comment|/* special_function */
literal|"GPDISP"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 21 bit branch.  */
name|HOWTO
argument_list|(
name|R_ALPHA_BRADDR
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|21
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"BRADDR"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0x1fffff
argument_list|,
comment|/* src_mask */
literal|0x1fffff
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A hint for a jump to a register.  */
name|HOWTO
argument_list|(
name|R_ALPHA_HINT
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|14
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"HINT"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0x3fff
argument_list|,
comment|/* src_mask */
literal|0x3fff
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16 bit PC relative offset.  */
name|HOWTO
argument_list|(
name|R_ALPHA_SREL16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"SREL16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 32 bit PC relative offset.  */
name|HOWTO
argument_list|(
name|R_ALPHA_SREL32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"SREL32"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 64 bit PC relative offset.  */
name|HOWTO
argument_list|(
name|R_ALPHA_SREL64
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"SREL64"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
name|MINUS_ONE
argument_list|,
comment|/* src_mask */
name|MINUS_ONE
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Push a value on the reloc evaluation stack.  */
comment|/* Not implemented -- it's dumb.  */
name|HOWTO
argument_list|(
name|R_ALPHA_OP_PUSH
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|elf64_alpha_reloc_bad
argument_list|,
comment|/* special_function */
literal|"OP_PUSH"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Store the value from the stack at the given address.  Store it in      a bitfield of size r_size starting at bit position r_offset.  */
comment|/* Not implemented -- it's dumb.  */
name|HOWTO
argument_list|(
name|R_ALPHA_OP_STORE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|elf64_alpha_reloc_bad
argument_list|,
comment|/* special_function */
literal|"OP_STORE"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
name|MINUS_ONE
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Subtract the reloc address from the value on the top of the      relocation stack.  */
comment|/* Not implemented -- it's dumb.  */
name|HOWTO
argument_list|(
name|R_ALPHA_OP_PSUB
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|elf64_alpha_reloc_bad
argument_list|,
comment|/* special_function */
literal|"OP_PSUB"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Shift the value on the top of the relocation stack right by the      given value.  */
comment|/* Not implemented -- it's dumb.  */
name|HOWTO
argument_list|(
name|R_ALPHA_OP_PRSHIFT
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|elf64_alpha_reloc_bad
argument_list|,
comment|/* special_function */
literal|"OP_PRSHIFT"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Change the value of GP used by +r_addend until the next GPVALUE or the      end of the input bfd.  */
comment|/* Not implemented -- it's dumb.  */
name|HOWTO
argument_list|(
name|R_ALPHA_GPVALUE
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|elf64_alpha_reloc_bad
argument_list|,
comment|/* special_function */
literal|"GPVALUE"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The high 16 bits of the displacement from GP to the target.  */
name|HOWTO
argument_list|(
name|R_ALPHA_GPRELHIGH
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|elf64_alpha_reloc_bad
argument_list|,
comment|/* special_function */
literal|"GPRELHIGH"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The low 16 bits of the displacement from GP to the target.  */
name|HOWTO
argument_list|(
name|R_ALPHA_GPRELLOW
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|elf64_alpha_reloc_bad
argument_list|,
comment|/* special_function */
literal|"GPRELLOW"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 16-bit displacement from the GP to the target.  */
comment|/* XXX: Not implemented.  */
name|HOWTO
argument_list|(
name|R_ALPHA_IMMED_GP_16
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"IMMED_GP_16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The high bits of a 32-bit displacement from the GP to the target; the      low bits are supplied in the subsequent R_ALPHA_IMMED_LO32 relocs.  */
comment|/* XXX: Not implemented.  */
name|HOWTO
argument_list|(
name|R_ALPHA_IMMED_GP_HI32
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|elf64_alpha_reloc_bad
argument_list|,
comment|/* special_function */
literal|"IMMED_GP_HI32"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The high bits of a 32-bit displacement to the starting address of the      current section (the relocation target is ignored); the low bits are      supplied in the subsequent R_ALPHA_IMMED_LO32 relocs.  */
comment|/* XXX: Not implemented.  */
name|HOWTO
argument_list|(
name|R_ALPHA_IMMED_SCN_HI32
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|elf64_alpha_reloc_bad
argument_list|,
comment|/* special_function */
literal|"IMMED_SCN_HI32"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The high bits of a 32-bit displacement from the previous br, bsr, jsr      or jmp insn (as tagged by a BRADDR or HINT reloc) to the target; the      low bits are supplied by subsequent R_ALPHA_IMMED_LO32 relocs.  */
comment|/* XXX: Not implemented.  */
name|HOWTO
argument_list|(
name|R_ALPHA_IMMED_BR_HI32
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|elf64_alpha_reloc_bad
argument_list|,
comment|/* special_function */
literal|"IMMED_BR_HI32"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The low 16 bits of a displacement calculated in a previous HI32 reloc.  */
comment|/* XXX: Not implemented.  */
name|HOWTO
argument_list|(
name|R_ALPHA_IMMED_LO32
argument_list|,
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|elf64_alpha_reloc_bad
argument_list|,
comment|/* special_function */
literal|"IMMED_LO32"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Misc ELF relocations.  */
comment|/* A dynamic relocation to copy the target into our .dynbss section.  */
comment|/* Not generated, as all Alpha objects use PIC, so it is not needed.  It      is present because every other ELF has one, but should not be used      because .dynbss is an ugly thing.  */
name|HOWTO
argument_list|(
name|R_ALPHA_COPY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"COPY"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|true
argument_list|)
block|,
comment|/* A dynamic relocation for a .got entry.  */
name|HOWTO
argument_list|(
name|R_ALPHA_GLOB_DAT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"GLOB_DAT"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|true
argument_list|)
block|,
comment|/* A dynamic relocation for a .plt entry.  */
name|HOWTO
argument_list|(
name|R_ALPHA_JMP_SLOT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"JMP_SLOT"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|true
argument_list|)
block|,
comment|/* A dynamic relocation to add the base of the DSO to a 64-bit field.  */
name|HOWTO
argument_list|(
argument|R_ALPHA_RELATIVE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
argument|false
argument_list|,
literal|0
argument_list|,
argument|complain_overflow_dont
argument_list|,
argument|bfd_elf_generic_reloc
argument_list|,
literal|"RELATIVE"
argument_list|,
argument|false
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
argument|true
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A relocation function which doesn't do anything.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|elf64_alpha_reloc_nil
parameter_list|(
name|abfd
parameter_list|,
name|reloc
parameter_list|,
name|sym
parameter_list|,
name|data
parameter_list|,
name|sec
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|arelent
modifier|*
name|reloc
decl_stmt|;
name|asymbol
modifier|*
name|sym
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|PTR
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|output_bfd
condition|)
name|reloc
operator|->
name|address
operator|+=
name|sec
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_comment
comment|/* A relocation function used for an unsupported reloc.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|elf64_alpha_reloc_bad
parameter_list|(
name|abfd
parameter_list|,
name|reloc
parameter_list|,
name|sym
parameter_list|,
name|data
parameter_list|,
name|sec
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|arelent
modifier|*
name|reloc
decl_stmt|;
name|asymbol
modifier|*
name|sym
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|PTR
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|output_bfd
condition|)
name|reloc
operator|->
name|address
operator|+=
name|sec
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_notsupported
return|;
block|}
end_function

begin_comment
comment|/* Do the work of the GPDISP relocation.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|elf64_alpha_do_reloc_gpdisp
parameter_list|(
name|abfd
parameter_list|,
name|gpdisp
parameter_list|,
name|p_ldah
parameter_list|,
name|p_lda
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|bfd_vma
name|gpdisp
decl_stmt|;
name|bfd_byte
modifier|*
name|p_ldah
decl_stmt|;
name|bfd_byte
modifier|*
name|p_lda
decl_stmt|;
block|{
name|bfd_reloc_status_type
name|ret
init|=
name|bfd_reloc_ok
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|;
name|unsigned
name|long
name|i_ldah
decl_stmt|,
name|i_lda
decl_stmt|;
name|i_ldah
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|p_ldah
argument_list|)
expr_stmt|;
name|i_lda
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|p_lda
argument_list|)
expr_stmt|;
comment|/* Complain if the instructions are not correct.  */
if|if
condition|(
operator|(
operator|(
name|i_ldah
operator|>>
literal|26
operator|)
operator|&
literal|0x3f
operator|)
operator|!=
literal|0x09
operator|||
operator|(
operator|(
name|i_lda
operator|>>
literal|26
operator|)
operator|&
literal|0x3f
operator|)
operator|!=
literal|0x08
condition|)
name|ret
operator|=
name|bfd_reloc_dangerous
expr_stmt|;
comment|/* Extract the user-supplied offset, mirroring the sign extensions      that the instructions perform.  */
name|addend
operator|=
operator|(
operator|(
name|i_ldah
operator|&
literal|0xffff
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
name|i_lda
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|addend
operator|=
operator|(
name|addend
operator|^
literal|0x80008000
operator|)
operator|-
literal|0x80008000
expr_stmt|;
name|gpdisp
operator|+=
name|addend
expr_stmt|;
if|if
condition|(
operator|(
name|bfd_signed_vma
operator|)
name|gpdisp
operator|<
operator|-
operator|(
name|bfd_signed_vma
operator|)
literal|0x80000000
operator|||
operator|(
name|bfd_signed_vma
operator|)
name|gpdisp
operator|>=
operator|(
name|bfd_signed_vma
operator|)
literal|0x7fff8000
condition|)
name|ret
operator|=
name|bfd_reloc_overflow
expr_stmt|;
comment|/* compensate for the sign extension again.  */
name|i_ldah
operator|=
operator|(
operator|(
name|i_ldah
operator|&
literal|0xffff0000
operator|)
operator||
operator|(
operator|(
operator|(
name|gpdisp
operator|>>
literal|16
operator|)
operator|+
operator|(
operator|(
name|gpdisp
operator|>>
literal|15
operator|)
operator|&
literal|1
operator|)
operator|)
operator|&
literal|0xffff
operator|)
operator|)
expr_stmt|;
name|i_lda
operator|=
operator|(
name|i_lda
operator|&
literal|0xffff0000
operator|)
operator||
operator|(
name|gpdisp
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|i_ldah
argument_list|,
name|p_ldah
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|i_lda
argument_list|,
name|p_lda
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* The special function for the GPDISP reloc.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|elf64_alpha_reloc_gpdisp
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|sym
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|err_msg
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|sym
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|err_msg
decl_stmt|;
block|{
name|bfd_reloc_status_type
name|ret
decl_stmt|;
name|bfd_vma
name|gp
decl_stmt|,
name|relocation
decl_stmt|;
name|bfd_byte
modifier|*
name|p_ldah
decl_stmt|,
modifier|*
name|p_lda
decl_stmt|;
comment|/* Don't do anything if we're not doing a final link.  */
if|if
condition|(
name|output_bfd
condition|)
block|{
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
if|if
condition|(
name|reloc_entry
operator|->
name|address
operator|>
name|input_section
operator|->
name|_cooked_size
operator|||
name|reloc_entry
operator|->
name|address
operator|+
name|reloc_entry
operator|->
name|addend
operator|>
name|input_section
operator|->
name|_cooked_size
condition|)
return|return
name|bfd_reloc_outofrange
return|;
comment|/* The gp used in the portion of the output object to which this      input object belongs is cached on the input bfd.  */
name|gp
operator|=
name|_bfd_get_gp_value
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|relocation
operator|=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|reloc_entry
operator|->
name|address
operator|)
expr_stmt|;
name|p_ldah
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
expr_stmt|;
name|p_lda
operator|=
name|p_ldah
operator|+
name|reloc_entry
operator|->
name|addend
expr_stmt|;
name|ret
operator|=
name|elf64_alpha_do_reloc_gpdisp
argument_list|(
name|abfd
argument_list|,
name|gp
operator|-
name|relocation
argument_list|,
name|p_ldah
argument_list|,
name|p_lda
argument_list|)
expr_stmt|;
comment|/* Complain if the instructions are not correct.  */
if|if
condition|(
name|ret
operator|==
name|bfd_reloc_dangerous
condition|)
operator|*
name|err_msg
operator|=
name|_
argument_list|(
literal|"GPDISP relocation did not find ldah and lda instructions"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* A mapping from BFD reloc types to Alpha ELF reloc types.  */
end_comment

begin_struct
struct|struct
name|elf_reloc_map
block|{
name|bfd_reloc_code_real_type
name|bfd_reloc_val
decl_stmt|;
name|int
name|elf_reloc_val
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|elf_reloc_map
name|elf64_alpha_reloc_map
index|[]
init|=
block|{
block|{
name|BFD_RELOC_NONE
block|,
name|R_ALPHA_NONE
block|}
block|,
block|{
name|BFD_RELOC_32
block|,
name|R_ALPHA_REFLONG
block|}
block|,
block|{
name|BFD_RELOC_64
block|,
name|R_ALPHA_REFQUAD
block|}
block|,
block|{
name|BFD_RELOC_CTOR
block|,
name|R_ALPHA_REFQUAD
block|}
block|,
block|{
name|BFD_RELOC_GPREL32
block|,
name|R_ALPHA_GPREL32
block|}
block|,
block|{
name|BFD_RELOC_ALPHA_ELF_LITERAL
block|,
name|R_ALPHA_LITERAL
block|}
block|,
block|{
name|BFD_RELOC_ALPHA_LITUSE
block|,
name|R_ALPHA_LITUSE
block|}
block|,
block|{
name|BFD_RELOC_ALPHA_GPDISP
block|,
name|R_ALPHA_GPDISP
block|}
block|,
block|{
name|BFD_RELOC_23_PCREL_S2
block|,
name|R_ALPHA_BRADDR
block|}
block|,
block|{
name|BFD_RELOC_ALPHA_HINT
block|,
name|R_ALPHA_HINT
block|}
block|,
block|{
name|BFD_RELOC_16_PCREL
block|,
name|R_ALPHA_SREL16
block|}
block|,
block|{
name|BFD_RELOC_32_PCREL
block|,
name|R_ALPHA_SREL32
block|}
block|,
block|{
name|BFD_RELOC_64_PCREL
block|,
name|R_ALPHA_SREL64
block|}
block|,
comment|/* The BFD_RELOC_ALPHA_USER_* relocations are used by the assembler to process    the explicit !<reloc>!sequence relocations, and are mapped into the normal    relocations at the end of processing.  */
block|{
name|BFD_RELOC_ALPHA_USER_LITERAL
block|,
name|R_ALPHA_LITERAL
block|}
block|,
block|{
name|BFD_RELOC_ALPHA_USER_LITUSE_BASE
block|,
name|R_ALPHA_LITUSE
block|}
block|,
block|{
name|BFD_RELOC_ALPHA_USER_LITUSE_BYTOFF
block|,
name|R_ALPHA_LITUSE
block|}
block|,
block|{
name|BFD_RELOC_ALPHA_USER_LITUSE_JSR
block|,
name|R_ALPHA_LITUSE
block|}
block|,
block|{
name|BFD_RELOC_ALPHA_USER_GPDISP
block|,
name|R_ALPHA_GPDISP
block|}
block|,
block|{
name|BFD_RELOC_ALPHA_USER_GPRELHIGH
block|,
name|R_ALPHA_GPRELHIGH
block|}
block|,
block|{
name|BFD_RELOC_ALPHA_USER_GPRELLOW
block|,
name|R_ALPHA_GPRELLOW
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Given a BFD reloc type, return a HOWTO structure.  */
end_comment

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|elf64_alpha_bfd_reloc_type_lookup
parameter_list|(
name|abfd
parameter_list|,
name|code
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
block|{
specifier|const
name|struct
name|elf_reloc_map
modifier|*
name|i
decl_stmt|,
modifier|*
name|e
decl_stmt|;
name|i
operator|=
name|e
operator|=
name|elf64_alpha_reloc_map
expr_stmt|;
name|e
operator|+=
sizeof|sizeof
argument_list|(
name|elf64_alpha_reloc_map
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|elf_reloc_map
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|->
name|bfd_reloc_val
operator|==
name|code
condition|)
return|return
operator|&
name|elf64_alpha_howto_table
index|[
name|i
operator|->
name|elf_reloc_val
index|]
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Given an Alpha ELF reloc type, fill in an arelent structure.  */
end_comment

begin_function
specifier|static
name|void
name|elf64_alpha_info_to_howto
parameter_list|(
name|abfd
parameter_list|,
name|cache_ptr
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|arelent
modifier|*
name|cache_ptr
decl_stmt|;
name|Elf64_Internal_Rela
modifier|*
name|dst
decl_stmt|;
block|{
name|unsigned
name|r_type
decl_stmt|;
name|r_type
operator|=
name|ELF64_R_TYPE
argument_list|(
name|dst
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|r_type
operator|<
operator|(
name|unsigned
name|int
operator|)
name|R_ALPHA_max
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|howto
operator|=
operator|&
name|elf64_alpha_howto_table
index|[
name|r_type
index|]
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* These functions do relaxation for Alpha ELF.     Currently I'm only handling what I can do with existing compiler    and assembler support, which means no instructions are removed,    though some may be nopped.  At this time GCC does not emit enough    information to do all of the relaxing that is possible.  It will    take some not small amount of work for that to happen.     There are a couple of interesting papers that I once read on this    subject, that I cannot find references to at the moment, that    related to Alpha in particular.  They are by David Wall, then of    DEC WRL.  */
end_comment

begin_define
define|#
directive|define
name|OP_LDA
value|0x08
end_define

begin_define
define|#
directive|define
name|OP_LDAH
value|0x09
end_define

begin_define
define|#
directive|define
name|INSN_JSR
value|0x68004000
end_define

begin_define
define|#
directive|define
name|INSN_JSR_MASK
value|0xfc00c000
end_define

begin_define
define|#
directive|define
name|OP_LDQ
value|0x29
end_define

begin_define
define|#
directive|define
name|OP_BR
value|0x30
end_define

begin_define
define|#
directive|define
name|OP_BSR
value|0x34
end_define

begin_define
define|#
directive|define
name|INSN_UNOP
value|0x2fe00000
end_define

begin_struct
struct|struct
name|alpha_relax_info
block|{
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|,
modifier|*
name|relend
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|link_info
decl_stmt|;
name|boolean
name|changed_contents
decl_stmt|;
name|boolean
name|changed_relocs
decl_stmt|;
name|bfd_vma
name|gp
decl_stmt|;
name|bfd
modifier|*
name|gotobj
decl_stmt|;
name|asection
modifier|*
name|tsec
decl_stmt|;
name|struct
name|alpha_elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|alpha_elf_got_entry
modifier|*
name|gotent
decl_stmt|;
name|unsigned
name|char
name|other
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|Elf_Internal_Rela
modifier|*
name|elf64_alpha_relax_with_lituse
name|PARAMS
argument_list|(
operator|(
expr|struct
name|alpha_relax_info
operator|*
name|info
operator|,
name|bfd_vma
name|symval
operator|,
name|Elf_Internal_Rela
operator|*
name|irel
operator|,
name|Elf_Internal_Rela
operator|*
name|irelend
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf64_alpha_relax_without_lituse
name|PARAMS
argument_list|(
operator|(
expr|struct
name|alpha_relax_info
operator|*
name|info
operator|,
name|bfd_vma
name|symval
operator|,
name|Elf_Internal_Rela
operator|*
name|irel
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|elf64_alpha_relax_opt_call
name|PARAMS
argument_list|(
operator|(
expr|struct
name|alpha_relax_info
operator|*
name|info
operator|,
name|bfd_vma
name|symval
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf64_alpha_relax_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|asection
operator|*
name|sec
operator|,
expr|struct
name|bfd_link_info
operator|*
name|link_info
operator|,
name|boolean
operator|*
name|again
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Elf_Internal_Rela
modifier|*
name|elf64_alpha_find_reloc_at_ofs
parameter_list|(
name|rel
parameter_list|,
name|relend
parameter_list|,
name|offset
parameter_list|,
name|type
parameter_list|)
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|,
decl|*
name|relend
decl_stmt|;
end_function

begin_decl_stmt
name|bfd_vma
name|offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
name|rel
operator|<
name|relend
condition|)
block|{
if|if
condition|(
name|rel
operator|->
name|r_offset
operator|==
name|offset
operator|&&
name|ELF64_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|==
name|type
condition|)
return|return
name|rel
return|;
operator|++
name|rel
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_block

begin_function
specifier|static
name|Elf_Internal_Rela
modifier|*
name|elf64_alpha_relax_with_lituse
parameter_list|(
name|info
parameter_list|,
name|symval
parameter_list|,
name|irel
parameter_list|,
name|irelend
parameter_list|)
name|struct
name|alpha_relax_info
modifier|*
name|info
decl_stmt|;
name|bfd_vma
name|symval
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|,
decl|*
name|irelend
decl_stmt|;
end_function

begin_block
block|{
name|Elf_Internal_Rela
modifier|*
name|urel
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|count
decl_stmt|,
name|i
decl_stmt|;
name|bfd_signed_vma
name|disp
decl_stmt|;
name|boolean
name|fits16
decl_stmt|;
name|boolean
name|fits32
decl_stmt|;
name|boolean
name|lit_reused
init|=
name|false
decl_stmt|;
name|boolean
name|all_optimized
init|=
name|true
decl_stmt|;
name|unsigned
name|int
name|lit_insn
decl_stmt|;
name|lit_insn
operator|=
name|bfd_get_32
argument_list|(
name|info
operator|->
name|abfd
argument_list|,
name|info
operator|->
name|contents
operator|+
name|irel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|lit_insn
operator|>>
literal|26
operator|!=
name|OP_LDQ
condition|)
block|{
operator|(
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"%s: %s+0x%lx: warning: LITERAL relocation against unexpected insn"
argument_list|,
name|bfd_get_filename
argument_list|(
name|info
operator|->
name|abfd
argument_list|)
argument_list|,
name|info
operator|->
name|sec
operator|->
name|name
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|irel
operator|->
name|r_offset
argument_list|)
operator|)
expr_stmt|;
return|return
name|irel
return|;
block|}
comment|/* Summarize how this particular LITERAL is used.  */
for|for
control|(
name|urel
operator|=
name|irel
operator|+
literal|1
operator|,
name|flags
operator|=
name|count
operator|=
literal|0
init|;
name|urel
operator|<
name|irelend
condition|;
operator|++
name|urel
operator|,
operator|++
name|count
control|)
block|{
if|if
condition|(
name|ELF64_R_TYPE
argument_list|(
name|urel
operator|->
name|r_info
argument_list|)
operator|!=
name|R_ALPHA_LITUSE
condition|)
break|break;
if|if
condition|(
name|urel
operator|->
name|r_addend
operator|>=
literal|0
operator|&&
name|urel
operator|->
name|r_addend
operator|<=
literal|3
condition|)
name|flags
operator||=
literal|1
operator|<<
name|urel
operator|->
name|r_addend
expr_stmt|;
block|}
comment|/* A little preparation for the loop...  */
name|disp
operator|=
name|symval
operator|-
name|info
operator|->
name|gp
expr_stmt|;
for|for
control|(
name|urel
operator|=
name|irel
operator|+
literal|1
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
operator|,
operator|++
name|urel
control|)
block|{
name|unsigned
name|int
name|insn
decl_stmt|;
name|int
name|insn_disp
decl_stmt|;
name|bfd_signed_vma
name|xdisp
decl_stmt|;
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|info
operator|->
name|abfd
argument_list|,
name|info
operator|->
name|contents
operator|+
name|urel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|urel
operator|->
name|r_addend
condition|)
block|{
default|default:
comment|/* 0 = ADDRESS FORMAT */
comment|/* This type is really just a placeholder to note that all 	     uses cannot be optimized, but to still allow some.  */
name|all_optimized
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* MEM FORMAT */
comment|/* We can always optimize 16-bit displacements.  */
comment|/* Extract the displacement from the instruction, sign-extending 	     it if necessary, then test whether it is within 16 or 32 bits 	     displacement from GP.  */
name|insn_disp
operator|=
name|insn
operator|&
literal|0x0000ffff
expr_stmt|;
if|if
condition|(
name|insn_disp
operator|&
literal|0x00008000
condition|)
name|insn_disp
operator||=
literal|0xffff0000
expr_stmt|;
comment|/* Negative: sign-extend.  */
name|xdisp
operator|=
name|disp
operator|+
name|insn_disp
expr_stmt|;
name|fits16
operator|=
operator|(
name|xdisp
operator|>=
operator|-
operator|(
name|bfd_signed_vma
operator|)
literal|0x00008000
operator|&&
name|xdisp
operator|<
literal|0x00008000
operator|)
expr_stmt|;
name|fits32
operator|=
operator|(
name|xdisp
operator|>=
operator|-
operator|(
name|bfd_signed_vma
operator|)
literal|0x80000000
operator|&&
name|xdisp
operator|<
literal|0x7fff8000
operator|)
expr_stmt|;
if|if
condition|(
name|fits16
condition|)
block|{
comment|/* Take the op code and dest from this insn, take the base 		 register from the literal insn.  Leave the offset alone.  */
name|insn
operator|=
operator|(
name|insn
operator|&
literal|0xffe0ffff
operator|)
operator||
operator|(
name|lit_insn
operator|&
literal|0x001f0000
operator|)
expr_stmt|;
name|urel
operator|->
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|ELF64_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
name|R_ALPHA_GPRELLOW
argument_list|)
expr_stmt|;
name|urel
operator|->
name|r_addend
operator|=
name|irel
operator|->
name|r_addend
expr_stmt|;
name|info
operator|->
name|changed_relocs
operator|=
name|true
expr_stmt|;
name|bfd_put_32
argument_list|(
name|info
operator|->
name|abfd
argument_list|,
name|insn
argument_list|,
name|info
operator|->
name|contents
operator|+
name|urel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|info
operator|->
name|changed_contents
operator|=
name|true
expr_stmt|;
block|}
comment|/* If all mem+byte, we can optimize 32-bit mem displacements.  */
elseif|else
if|if
condition|(
name|fits32
operator|&&
operator|!
operator|(
name|flags
operator|&
operator|~
literal|6
operator|)
condition|)
block|{
comment|/* FIXME: sanity check that lit insn Ra is mem insn Rb.  */
name|irel
operator|->
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|ELF64_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
name|R_ALPHA_GPRELHIGH
argument_list|)
expr_stmt|;
name|lit_insn
operator|=
operator|(
name|OP_LDAH
operator|<<
literal|26
operator|)
operator||
operator|(
name|lit_insn
operator|&
literal|0x03ff0000
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|info
operator|->
name|abfd
argument_list|,
name|lit_insn
argument_list|,
name|info
operator|->
name|contents
operator|+
name|irel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|lit_reused
operator|=
name|true
expr_stmt|;
name|info
operator|->
name|changed_contents
operator|=
name|true
expr_stmt|;
name|urel
operator|->
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|ELF64_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
name|R_ALPHA_GPRELLOW
argument_list|)
expr_stmt|;
name|urel
operator|->
name|r_addend
operator|=
name|irel
operator|->
name|r_addend
expr_stmt|;
name|info
operator|->
name|changed_relocs
operator|=
name|true
expr_stmt|;
block|}
else|else
name|all_optimized
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* BYTE OFFSET FORMAT */
comment|/* We can always optimize byte instructions.  */
comment|/* FIXME: sanity check the insn for byte op.  Check that the 	     literal dest reg is indeed Rb in the byte insn.  */
name|insn
operator|=
operator|(
name|insn
operator|&
operator|~
literal|0x001ff000
operator|)
operator||
operator|(
operator|(
name|symval
operator|&
literal|7
operator|)
operator|<<
literal|13
operator|)
operator||
literal|0x1000
expr_stmt|;
name|urel
operator|->
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_ALPHA_NONE
argument_list|)
expr_stmt|;
name|urel
operator|->
name|r_addend
operator|=
literal|0
expr_stmt|;
name|info
operator|->
name|changed_relocs
operator|=
name|true
expr_stmt|;
name|bfd_put_32
argument_list|(
name|info
operator|->
name|abfd
argument_list|,
name|insn
argument_list|,
name|info
operator|->
name|contents
operator|+
name|urel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|info
operator|->
name|changed_contents
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* CALL FORMAT */
block|{
comment|/* If not zero, place to jump without needing pv.  */
name|bfd_vma
name|optdest
init|=
name|elf64_alpha_relax_opt_call
argument_list|(
name|info
argument_list|,
name|symval
argument_list|)
decl_stmt|;
name|bfd_vma
name|org
init|=
operator|(
name|info
operator|->
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|info
operator|->
name|sec
operator|->
name|output_offset
operator|+
name|urel
operator|->
name|r_offset
operator|+
literal|4
operator|)
decl_stmt|;
name|bfd_signed_vma
name|odisp
decl_stmt|;
name|odisp
operator|=
operator|(
name|optdest
condition|?
name|optdest
else|:
name|symval
operator|)
operator|-
name|org
expr_stmt|;
if|if
condition|(
name|odisp
operator|>=
operator|-
literal|0x400000
operator|&&
name|odisp
operator|<
literal|0x400000
condition|)
block|{
name|Elf_Internal_Rela
modifier|*
name|xrel
decl_stmt|;
comment|/* Preserve branch prediction call stack when possible.  */
if|if
condition|(
operator|(
name|insn
operator|&
name|INSN_JSR_MASK
operator|)
operator|==
name|INSN_JSR
condition|)
name|insn
operator|=
operator|(
name|OP_BSR
operator|<<
literal|26
operator|)
operator||
operator|(
name|insn
operator|&
literal|0x03e00000
operator|)
expr_stmt|;
else|else
name|insn
operator|=
operator|(
name|OP_BR
operator|<<
literal|26
operator|)
operator||
operator|(
name|insn
operator|&
literal|0x03e00000
operator|)
expr_stmt|;
name|urel
operator|->
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|ELF64_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
name|R_ALPHA_BRADDR
argument_list|)
expr_stmt|;
name|urel
operator|->
name|r_addend
operator|=
name|irel
operator|->
name|r_addend
expr_stmt|;
if|if
condition|(
name|optdest
condition|)
name|urel
operator|->
name|r_addend
operator|+=
name|optdest
operator|-
name|symval
expr_stmt|;
else|else
name|all_optimized
operator|=
name|false
expr_stmt|;
name|bfd_put_32
argument_list|(
name|info
operator|->
name|abfd
argument_list|,
name|insn
argument_list|,
name|info
operator|->
name|contents
operator|+
name|urel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
comment|/* Kill any HINT reloc that might exist for this insn.  */
name|xrel
operator|=
operator|(
name|elf64_alpha_find_reloc_at_ofs
argument_list|(
name|info
operator|->
name|relocs
argument_list|,
name|info
operator|->
name|relend
argument_list|,
name|urel
operator|->
name|r_offset
argument_list|,
name|R_ALPHA_HINT
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|xrel
condition|)
name|xrel
operator|->
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_ALPHA_NONE
argument_list|)
expr_stmt|;
name|info
operator|->
name|changed_contents
operator|=
name|true
expr_stmt|;
name|info
operator|->
name|changed_relocs
operator|=
name|true
expr_stmt|;
block|}
else|else
name|all_optimized
operator|=
name|false
expr_stmt|;
comment|/* ??? If target gp == current gp we can eliminate the gp reload. 	       This does depend on every place a gp could be reloaded will 	       be, which currently happens for all code produced by gcc, but 	       not necessarily by hand-coded assembly, or if sibling calls 	       are enabled in gcc.  	       Perhaps conditionalize this on a flag being set in the target 	       object file's header, and have gcc set it?  */
block|}
break|break;
block|}
block|}
comment|/* If all cases were optimized, we can reduce the use count on this      got entry by one, possibly eliminating it.  */
if|if
condition|(
name|all_optimized
condition|)
block|{
name|info
operator|->
name|gotent
operator|->
name|use_count
operator|-=
literal|1
expr_stmt|;
name|alpha_elf_tdata
argument_list|(
name|info
operator|->
name|gotent
operator|->
name|gotobj
argument_list|)
operator|->
name|total_got_entries
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|h
condition|)
name|alpha_elf_tdata
argument_list|(
name|info
operator|->
name|gotent
operator|->
name|gotobj
argument_list|)
operator|->
name|n_local_got_entries
operator|-=
literal|1
expr_stmt|;
comment|/* If the literal instruction is no longer needed (it may have been 	 reused.  We can eliminate it. 	 ??? For now, I don't want to deal with compacting the section, 	 so just nop it out.  */
if|if
condition|(
operator|!
name|lit_reused
condition|)
block|{
name|irel
operator|->
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_ALPHA_NONE
argument_list|)
expr_stmt|;
name|info
operator|->
name|changed_relocs
operator|=
name|true
expr_stmt|;
name|bfd_put_32
argument_list|(
name|info
operator|->
name|abfd
argument_list|,
name|INSN_UNOP
argument_list|,
name|info
operator|->
name|contents
operator|+
name|irel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|info
operator|->
name|changed_contents
operator|=
name|true
expr_stmt|;
block|}
block|}
return|return
name|irel
operator|+
name|count
return|;
block|}
end_block

begin_function
specifier|static
name|bfd_vma
name|elf64_alpha_relax_opt_call
parameter_list|(
name|info
parameter_list|,
name|symval
parameter_list|)
name|struct
name|alpha_relax_info
modifier|*
name|info
decl_stmt|;
name|bfd_vma
name|symval
decl_stmt|;
block|{
comment|/* If the function has the same gp, and we can identify that the      function does not use its function pointer, we can eliminate the      address load.  */
comment|/* If the symbol is marked NOPV, we are being told the function never      needs its procedure value.  */
if|if
condition|(
operator|(
name|info
operator|->
name|other
operator|&
name|STO_ALPHA_STD_GPLOAD
operator|)
operator|==
name|STO_ALPHA_NOPV
condition|)
return|return
name|symval
return|;
comment|/* If the symbol is marked STD_GP, we are being told the function does      a normal ldgp in the first two words.  */
elseif|else
if|if
condition|(
operator|(
name|info
operator|->
name|other
operator|&
name|STO_ALPHA_STD_GPLOAD
operator|)
operator|==
name|STO_ALPHA_STD_GPLOAD
condition|)
empty_stmt|;
comment|/* Otherwise, we may be able to identify a GP load in the first two      words, which we can then skip.  */
else|else
block|{
name|Elf_Internal_Rela
modifier|*
name|tsec_relocs
decl_stmt|,
modifier|*
name|tsec_relend
decl_stmt|,
modifier|*
name|tsec_free
decl_stmt|,
modifier|*
name|gpdisp
decl_stmt|;
name|bfd_vma
name|ofs
decl_stmt|;
comment|/* Load the relocations from the section that the target symbol is in.  */
if|if
condition|(
name|info
operator|->
name|sec
operator|==
name|info
operator|->
name|tsec
condition|)
block|{
name|tsec_relocs
operator|=
name|info
operator|->
name|relocs
expr_stmt|;
name|tsec_relend
operator|=
name|info
operator|->
name|relend
expr_stmt|;
name|tsec_free
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|tsec_relocs
operator|=
operator|(
name|_bfd_elf64_link_read_relocs
argument_list|(
name|info
operator|->
name|abfd
argument_list|,
name|info
operator|->
name|tsec
argument_list|,
operator|(
name|PTR
operator|)
name|NULL
argument_list|,
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
name|NULL
argument_list|,
name|info
operator|->
name|link_info
operator|->
name|keep_memory
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|tsec_relocs
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|tsec_relend
operator|=
name|tsec_relocs
operator|+
name|info
operator|->
name|tsec
operator|->
name|reloc_count
expr_stmt|;
name|tsec_free
operator|=
operator|(
name|info
operator|->
name|link_info
operator|->
name|keep_memory
condition|?
name|NULL
else|:
name|tsec_relocs
operator|)
expr_stmt|;
block|}
comment|/* Recover the symbol's offset within the section.  */
name|ofs
operator|=
operator|(
name|symval
operator|-
name|info
operator|->
name|tsec
operator|->
name|output_section
operator|->
name|vma
operator|-
name|info
operator|->
name|tsec
operator|->
name|output_offset
operator|)
expr_stmt|;
comment|/* Look for a GPDISP reloc.  */
name|gpdisp
operator|=
operator|(
name|elf64_alpha_find_reloc_at_ofs
argument_list|(
name|tsec_relocs
argument_list|,
name|tsec_relend
argument_list|,
name|ofs
argument_list|,
name|R_ALPHA_GPDISP
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|gpdisp
operator|||
name|gpdisp
operator|->
name|r_addend
operator|!=
literal|4
condition|)
block|{
if|if
condition|(
name|tsec_free
condition|)
name|free
argument_list|(
name|tsec_free
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|tsec_free
condition|)
name|free
argument_list|(
name|tsec_free
argument_list|)
expr_stmt|;
block|}
comment|/* We've now determined that we can skip an initial gp load.  Verify      that the call and the target use the same gp.   */
if|if
condition|(
name|info
operator|->
name|link_info
operator|->
name|hash
operator|->
name|creator
operator|!=
name|info
operator|->
name|tsec
operator|->
name|owner
operator|->
name|xvec
operator|||
name|info
operator|->
name|gotobj
operator|!=
name|alpha_elf_tdata
argument_list|(
name|info
operator|->
name|tsec
operator|->
name|owner
argument_list|)
operator|->
name|gotobj
condition|)
return|return
literal|0
return|;
return|return
name|symval
operator|+
literal|8
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|elf64_alpha_relax_without_lituse
parameter_list|(
name|info
parameter_list|,
name|symval
parameter_list|,
name|irel
parameter_list|)
name|struct
name|alpha_relax_info
modifier|*
name|info
decl_stmt|;
name|bfd_vma
name|symval
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|;
block|{
name|unsigned
name|int
name|insn
decl_stmt|;
name|bfd_signed_vma
name|disp
decl_stmt|;
comment|/* Get the instruction.  */
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|info
operator|->
name|abfd
argument_list|,
name|info
operator|->
name|contents
operator|+
name|irel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|>>
literal|26
operator|!=
name|OP_LDQ
condition|)
block|{
operator|(
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"%s: %s+0x%lx: warning: LITERAL relocation against unexpected insn"
argument_list|,
name|bfd_get_filename
argument_list|(
name|info
operator|->
name|abfd
argument_list|)
argument_list|,
name|info
operator|->
name|sec
operator|->
name|name
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|irel
operator|->
name|r_offset
argument_list|)
operator|)
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* So we aren't told much.  Do what we can with the address load and      fake the rest.  All of the optimizations here require that the      offset from the GP fit in 16 bits.  */
name|disp
operator|=
name|symval
operator|-
name|info
operator|->
name|gp
expr_stmt|;
if|if
condition|(
name|disp
operator|<
operator|-
literal|0x8000
operator|||
name|disp
operator|>=
literal|0x8000
condition|)
return|return
name|true
return|;
comment|/* On the LITERAL instruction itself, consider exchanging      `ldq R,X(gp)' for `lda R,Y(gp)'.  */
name|insn
operator|=
operator|(
name|OP_LDA
operator|<<
literal|26
operator|)
operator||
operator|(
name|insn
operator|&
literal|0x03ff0000
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|info
operator|->
name|abfd
argument_list|,
name|insn
argument_list|,
name|info
operator|->
name|contents
operator|+
name|irel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|info
operator|->
name|changed_contents
operator|=
name|true
expr_stmt|;
name|irel
operator|->
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|ELF64_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
name|R_ALPHA_GPRELLOW
argument_list|)
expr_stmt|;
name|info
operator|->
name|changed_relocs
operator|=
name|true
expr_stmt|;
comment|/* Reduce the use count on this got entry by one, possibly      eliminating it.  */
name|info
operator|->
name|gotent
operator|->
name|use_count
operator|-=
literal|1
expr_stmt|;
name|alpha_elf_tdata
argument_list|(
name|info
operator|->
name|gotent
operator|->
name|gotobj
argument_list|)
operator|->
name|total_got_entries
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|h
condition|)
name|alpha_elf_tdata
argument_list|(
name|info
operator|->
name|gotent
operator|->
name|gotobj
argument_list|)
operator|->
name|n_local_got_entries
operator|-=
literal|1
expr_stmt|;
comment|/* ??? Search forward through this basic block looking for insns      that use the target register.  Stop after an insn modifying the      register is seen, or after a branch or call.       Any such memory load insn may be substituted by a load directly      off the GP.  This allows the memory load insn to be issued before      the calculated GP register would otherwise be ready.       Any such jsr insn can be replaced by a bsr if it is in range.       This would mean that we'd have to _add_ relocations, the pain of      which gives one pause.  */
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|elf64_alpha_relax_section
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|link_info
parameter_list|,
name|again
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|link_info
decl_stmt|;
name|boolean
modifier|*
name|again
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|free_relocs
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|,
modifier|*
name|irelend
decl_stmt|;
name|bfd_byte
modifier|*
name|free_contents
init|=
name|NULL
decl_stmt|;
name|Elf64_External_Sym
modifier|*
name|extsyms
init|=
name|NULL
decl_stmt|;
name|Elf64_External_Sym
modifier|*
name|free_extsyms
init|=
name|NULL
decl_stmt|;
name|struct
name|alpha_elf_got_entry
modifier|*
modifier|*
name|local_got_entries
decl_stmt|;
name|struct
name|alpha_relax_info
name|info
decl_stmt|;
comment|/* We are not currently changing any sizes, so only one pass.  */
operator|*
name|again
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|link_info
operator|->
name|relocateable
operator|||
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
operator|||
name|sec
operator|->
name|reloc_count
operator|==
literal|0
condition|)
return|return
name|true
return|;
comment|/* If this is the first time we have been called for this section,      initialize the cooked size.  */
if|if
condition|(
name|sec
operator|->
name|_cooked_size
operator|==
literal|0
condition|)
name|sec
operator|->
name|_cooked_size
operator|=
name|sec
operator|->
name|_raw_size
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|local_got_entries
operator|=
name|alpha_elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|local_got_entries
expr_stmt|;
comment|/* Load the relocations for this section.  */
name|internal_relocs
operator|=
operator|(
name|_bfd_elf64_link_read_relocs
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
operator|(
name|PTR
operator|)
name|NULL
argument_list|,
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
name|NULL
argument_list|,
name|link_info
operator|->
name|keep_memory
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|link_info
operator|->
name|keep_memory
condition|)
name|free_relocs
operator|=
name|internal_relocs
expr_stmt|;
name|memset
argument_list|(
operator|&
name|info
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|.
name|abfd
operator|=
name|abfd
expr_stmt|;
name|info
operator|.
name|sec
operator|=
name|sec
expr_stmt|;
name|info
operator|.
name|link_info
operator|=
name|link_info
expr_stmt|;
name|info
operator|.
name|relocs
operator|=
name|internal_relocs
expr_stmt|;
name|info
operator|.
name|relend
operator|=
name|irelend
operator|=
name|internal_relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
comment|/* Find the GP for this object.  */
name|info
operator|.
name|gotobj
operator|=
name|alpha_elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|gotobj
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|gotobj
condition|)
block|{
name|asection
modifier|*
name|sgot
init|=
name|alpha_elf_tdata
argument_list|(
name|info
operator|.
name|gotobj
argument_list|)
operator|->
name|got
decl_stmt|;
name|info
operator|.
name|gp
operator|=
name|_bfd_get_gp_value
argument_list|(
name|info
operator|.
name|gotobj
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|gp
operator|==
literal|0
condition|)
block|{
name|info
operator|.
name|gp
operator|=
operator|(
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
literal|0x8000
operator|)
expr_stmt|;
name|_bfd_set_gp_value
argument_list|(
name|info
operator|.
name|gotobj
argument_list|,
name|info
operator|.
name|gp
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|irel
operator|=
name|internal_relocs
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
control|)
block|{
name|bfd_vma
name|symval
decl_stmt|;
name|Elf_Internal_Sym
name|isym
decl_stmt|;
name|struct
name|alpha_elf_got_entry
modifier|*
name|gotent
decl_stmt|;
if|if
condition|(
name|ELF64_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|R_ALPHA_LITERAL
condition|)
continue|continue;
comment|/* Get the section contents.  */
if|if
condition|(
name|info
operator|.
name|contents
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|NULL
condition|)
name|info
operator|.
name|contents
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
expr_stmt|;
else|else
block|{
name|info
operator|.
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|sec
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|contents
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|free_contents
operator|=
name|info
operator|.
name|contents
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|info
operator|.
name|contents
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|sec
operator|->
name|_raw_size
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
block|}
comment|/* Read this BFD's symbols if we haven't done so already.  */
if|if
condition|(
name|extsyms
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|symtab_hdr
operator|->
name|contents
operator|!=
name|NULL
condition|)
name|extsyms
operator|=
operator|(
name|Elf64_External_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
else|else
block|{
name|extsyms
operator|=
operator|(
operator|(
name|Elf64_External_Sym
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|symtab_hdr
operator|->
name|sh_size
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|extsyms
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|free_extsyms
operator|=
name|extsyms
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|bfd_read
argument_list|(
name|extsyms
argument_list|,
literal|1
argument_list|,
name|symtab_hdr
operator|->
name|sh_size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|symtab_hdr
operator|->
name|sh_size
operator|)
condition|)
goto|goto
name|error_return
goto|;
block|}
block|}
comment|/* Get the value of the symbol referred to by the reloc.  */
if|if
condition|(
name|ELF64_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
comment|/* A local symbol.  */
name|bfd_elf64_swap_symbol_in
argument_list|(
name|abfd
argument_list|,
name|extsyms
operator|+
name|ELF64_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
operator|&
name|isym
argument_list|)
expr_stmt|;
if|if
condition|(
name|isym
operator|.
name|st_shndx
operator|==
name|SHN_UNDEF
condition|)
name|info
operator|.
name|tsec
operator|=
name|bfd_und_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|isym
operator|.
name|st_shndx
operator|>
literal|0
operator|&&
name|isym
operator|.
name|st_shndx
operator|<
name|SHN_LORESERVE
condition|)
name|info
operator|.
name|tsec
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|abfd
argument_list|,
name|isym
operator|.
name|st_shndx
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|isym
operator|.
name|st_shndx
operator|==
name|SHN_ABS
condition|)
name|info
operator|.
name|tsec
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|isym
operator|.
name|st_shndx
operator|==
name|SHN_COMMON
condition|)
name|info
operator|.
name|tsec
operator|=
name|bfd_com_section_ptr
expr_stmt|;
else|else
continue|continue;
comment|/* who knows.  */
name|info
operator|.
name|h
operator|=
name|NULL
expr_stmt|;
name|info
operator|.
name|other
operator|=
name|isym
operator|.
name|st_other
expr_stmt|;
name|gotent
operator|=
name|local_got_entries
index|[
name|ELF64_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
index|]
expr_stmt|;
name|symval
operator|=
name|isym
operator|.
name|st_value
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|long
name|indx
decl_stmt|;
name|struct
name|alpha_elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|indx
operator|=
name|ELF64_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|-
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|h
operator|=
name|alpha_elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
index|[
name|indx
index|]
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|h
operator|!=
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|alpha_elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
comment|/* We can't do anthing with undefined or dynamic symbols.  */
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
operator|||
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|||
name|alpha_elf_dynamic_symbol_p
argument_list|(
operator|&
name|h
operator|->
name|root
argument_list|,
name|link_info
argument_list|)
condition|)
continue|continue;
name|info
operator|.
name|h
operator|=
name|h
expr_stmt|;
name|info
operator|.
name|gotent
operator|=
name|gotent
expr_stmt|;
name|info
operator|.
name|tsec
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|info
operator|.
name|other
operator|=
name|h
operator|->
name|root
operator|.
name|other
expr_stmt|;
name|gotent
operator|=
name|h
operator|->
name|got_entries
expr_stmt|;
name|symval
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
block|}
comment|/* Search for the got entry to be used by this relocation.  */
while|while
condition|(
name|gotent
operator|->
name|gotobj
operator|!=
name|info
operator|.
name|gotobj
operator|||
name|gotent
operator|->
name|addend
operator|!=
name|irel
operator|->
name|r_addend
condition|)
name|gotent
operator|=
name|gotent
operator|->
name|next
expr_stmt|;
name|info
operator|.
name|gotent
operator|=
name|gotent
expr_stmt|;
name|symval
operator|+=
name|info
operator|.
name|tsec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|info
operator|.
name|tsec
operator|->
name|output_offset
expr_stmt|;
name|symval
operator|+=
name|irel
operator|->
name|r_addend
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|info
operator|.
name|gotent
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* If there exist LITUSE relocations immediately following, this 	 opens up all sorts of interesting optimizations, because we 	 now know every location that this address load is used.  */
if|if
condition|(
name|irel
operator|+
literal|1
operator|<
name|irelend
operator|&&
name|ELF64_R_TYPE
argument_list|(
name|irel
index|[
literal|1
index|]
operator|.
name|r_info
argument_list|)
operator|==
name|R_ALPHA_LITUSE
condition|)
block|{
name|irel
operator|=
name|elf64_alpha_relax_with_lituse
argument_list|(
operator|&
name|info
argument_list|,
name|symval
argument_list|,
name|irel
argument_list|,
name|irelend
argument_list|)
expr_stmt|;
if|if
condition|(
name|irel
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|elf64_alpha_relax_without_lituse
argument_list|(
operator|&
name|info
argument_list|,
name|symval
argument_list|,
name|irel
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
block|}
if|if
condition|(
operator|!
name|elf64_alpha_size_got_sections
argument_list|(
name|abfd
argument_list|,
name|link_info
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|info
operator|.
name|changed_relocs
condition|)
block|{
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|=
name|internal_relocs
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|free_relocs
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|free_relocs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|.
name|changed_contents
condition|)
block|{
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|info
operator|.
name|contents
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|free_contents
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|link_info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|free_contents
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Cache the section contents for elf_link_input_bfd.  */
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|info
operator|.
name|contents
expr_stmt|;
block|}
block|}
if|if
condition|(
name|free_extsyms
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|link_info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|free_extsyms
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Cache the symbols for elf_link_input_bfd.  */
name|symtab_hdr
operator|->
name|contents
operator|=
name|extsyms
expr_stmt|;
block|}
block|}
operator|*
name|again
operator|=
name|info
operator|.
name|changed_contents
operator|||
name|info
operator|.
name|changed_relocs
expr_stmt|;
return|return
name|true
return|;
name|error_return
label|:
if|if
condition|(
name|free_relocs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|free_relocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_contents
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|free_contents
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_extsyms
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|free_extsyms
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* PLT/GOT Stuff */
end_comment

begin_define
define|#
directive|define
name|PLT_HEADER_SIZE
value|32
end_define

begin_define
define|#
directive|define
name|PLT_HEADER_WORD1
value|0xc3600000
end_define

begin_comment
comment|/* br   $27,.+4     */
end_comment

begin_define
define|#
directive|define
name|PLT_HEADER_WORD2
value|0xa77b000c
end_define

begin_comment
comment|/* ldq  $27,12($27) */
end_comment

begin_define
define|#
directive|define
name|PLT_HEADER_WORD3
value|0x47ff041f
end_define

begin_comment
comment|/* nop              */
end_comment

begin_define
define|#
directive|define
name|PLT_HEADER_WORD4
value|0x6b7b0000
end_define

begin_comment
comment|/* jmp  $27,($27)   */
end_comment

begin_define
define|#
directive|define
name|PLT_ENTRY_SIZE
value|12
end_define

begin_define
define|#
directive|define
name|PLT_ENTRY_WORD1
value|0xc3800000
end_define

begin_comment
comment|/* br   $28, plt0   */
end_comment

begin_define
define|#
directive|define
name|PLT_ENTRY_WORD2
value|0
end_define

begin_define
define|#
directive|define
name|PLT_ENTRY_WORD3
value|0
end_define

begin_define
define|#
directive|define
name|MAX_GOT_ENTRIES
value|(64*1024 / 8)
end_define

begin_define
define|#
directive|define
name|ELF_DYNAMIC_INTERPRETER
value|"/usr/lib/ld.so"
end_define

begin_escape
end_escape

begin_comment
comment|/* Handle an Alpha specific section when reading an object file.  This    is called when elfcode.h finds a section with an unknown type.    FIXME: We need to handle the SHF_ALPHA_GPREL flag, but I'm not sure    how to.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf64_alpha_section_from_shdr
parameter_list|(
name|abfd
parameter_list|,
name|hdr
parameter_list|,
name|name
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|Elf64_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|asection
modifier|*
name|newsect
decl_stmt|;
comment|/* There ought to be a place to keep ELF backend specific flags, but      at the moment there isn't one.  We just keep track of the      sections by their name, instead.  Fortunately, the ABI gives      suggested names for all the MIPS specific sections, so we will      probably get away with this.  */
switch|switch
condition|(
name|hdr
operator|->
name|sh_type
condition|)
block|{
case|case
name|SHT_ALPHA_DEBUG
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".mdebug"
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
break|break;
ifdef|#
directive|ifdef
name|ERIC_neverdef
case|case
name|SHT_ALPHA_REGINFO
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".reginfo"
argument_list|)
operator|!=
literal|0
operator|||
name|hdr
operator|->
name|sh_size
operator|!=
sizeof|sizeof
argument_list|(
name|Elf64_External_RegInfo
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
endif|#
directive|endif
default|default:
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|_bfd_elf_make_section_from_shdr
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|false
return|;
name|newsect
operator|=
name|hdr
operator|->
name|bfd_section
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|sh_type
operator|==
name|SHT_ALPHA_DEBUG
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|newsect
argument_list|,
operator|(
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|newsect
argument_list|)
operator||
name|SEC_DEBUGGING
operator|)
argument_list|)
condition|)
return|return
name|false
return|;
block|}
ifdef|#
directive|ifdef
name|ERIC_neverdef
comment|/* For a .reginfo section, set the gp value in the tdata information      from the contents of this section.  We need the gp value while      processing relocs, so we just get it now.  */
if|if
condition|(
name|hdr
operator|->
name|sh_type
operator|==
name|SHT_ALPHA_REGINFO
condition|)
block|{
name|Elf64_External_RegInfo
name|ext
decl_stmt|;
name|Elf64_RegInfo
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|newsect
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|ext
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
sizeof|sizeof
name|ext
argument_list|)
condition|)
return|return
name|false
return|;
name|bfd_alpha_elf64_swap_reginfo_in
argument_list|(
name|abfd
argument_list|,
operator|&
name|ext
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|elf_gp
argument_list|(
name|abfd
argument_list|)
operator|=
name|s
operator|.
name|ri_gp_value
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Set the correct type for an Alpha ELF section.  We do this by the    section name, which is a hack, but ought to work.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf64_alpha_fake_sections
parameter_list|(
name|abfd
parameter_list|,
name|hdr
parameter_list|,
name|sec
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|Elf64_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
block|{
specifier|register
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".mdebug"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_ALPHA_DEBUG
expr_stmt|;
comment|/* In a shared object on Irix 5.3, the .mdebug section has an          entsize of 0.  FIXME: Does this matter?  */
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
condition|)
name|hdr
operator|->
name|sh_entsize
operator|=
literal|0
expr_stmt|;
else|else
name|hdr
operator|->
name|sh_entsize
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ERIC_neverdef
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".reginfo"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_ALPHA_REGINFO
expr_stmt|;
comment|/* In a shared object on Irix 5.3, the .reginfo section has an          entsize of 0x18.  FIXME: Does this matter?  */
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
condition|)
name|hdr
operator|->
name|sh_entsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf64_External_RegInfo
argument_list|)
expr_stmt|;
else|else
name|hdr
operator|->
name|sh_entsize
operator|=
literal|1
expr_stmt|;
comment|/* Force the section size to the correct value, even if the 	 linker thinks it is larger.  The link routine below will only 	 write out this much data for .reginfo.  */
name|hdr
operator|->
name|sh_size
operator|=
name|sec
operator|->
name|_raw_size
operator|=
sizeof|sizeof
argument_list|(
name|Elf64_External_RegInfo
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".hash"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".dynamic"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".dynstr"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hdr
operator|->
name|sh_entsize
operator|=
literal|0
expr_stmt|;
name|hdr
operator|->
name|sh_info
operator|=
name|SIZEOF_ALPHA_DYNSYM_SECNAMES
expr_stmt|;
block|}
endif|#
directive|endif
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sdata"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sbss"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".lit4"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".lit8"
argument_list|)
operator|==
literal|0
condition|)
name|hdr
operator|->
name|sh_flags
operator||=
name|SHF_ALPHA_GPREL
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Hook called by the linker routine which adds symbols from an object    file.  We use it to put .comm items in .sbss, and not .bss.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf64_alpha_add_symbol_hook
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|sym
parameter_list|,
name|namep
parameter_list|,
name|flagsp
parameter_list|,
name|secp
parameter_list|,
name|valp
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
specifier|const
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|namep
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|flagword
modifier|*
name|flagsp
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
modifier|*
name|secp
decl_stmt|;
name|bfd_vma
modifier|*
name|valp
decl_stmt|;
block|{
if|if
condition|(
name|sym
operator|->
name|st_shndx
operator|==
name|SHN_COMMON
operator|&&
operator|!
name|info
operator|->
name|relocateable
operator|&&
name|sym
operator|->
name|st_size
operator|<=
name|bfd_get_gp_size
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
comment|/* Common symbols less than or equal to -G nn bytes are 	 automatically put into .sbss.  */
name|asection
modifier|*
name|scomm
init|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".scommon"
argument_list|)
decl_stmt|;
if|if
condition|(
name|scomm
operator|==
name|NULL
condition|)
block|{
name|scomm
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".scommon"
argument_list|)
expr_stmt|;
if|if
condition|(
name|scomm
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|scomm
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_IS_COMMON
operator||
name|SEC_LINKER_CREATED
operator|)
argument_list|)
condition|)
return|return
name|false
return|;
block|}
operator|*
name|secp
operator|=
name|scomm
expr_stmt|;
operator|*
name|valp
operator|=
name|sym
operator|->
name|st_size
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Create the .got section.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf64_alpha_create_got_section
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|asection
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".got"
argument_list|)
condition|)
return|return
name|true
return|;
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator|)
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
literal|3
argument_list|)
condition|)
return|return
name|false
return|;
name|alpha_elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|got
operator|=
name|s
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Create all the dynamic sections.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf64_alpha_create_dynamic_sections
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
comment|/* We need to create .plt, .rela.plt, .got, and .rela.got sections.  */
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_CODE
operator|)
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
literal|3
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Define the symbol _PROCEDURE_LINKAGE_TABLE_ at the start of the      .plt section.  */
name|h
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
literal|"_PROCEDURE_LINKAGE_TABLE_"
argument_list|,
name|BSF_GLOBAL
argument_list|,
name|s
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|false
argument_list|,
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|collect
argument_list|,
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|*
operator|)
operator|&
name|h
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_DEF_REGULAR
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|STT_OBJECT
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
operator|!
name|_bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|false
return|;
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".rela.plt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_READONLY
operator|)
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
literal|3
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* We may or may not have created a .got section for this object, but      we definitely havn't done the rest of the work.  */
if|if
condition|(
operator|!
name|elf64_alpha_create_got_section
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|false
return|;
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_READONLY
operator|)
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
literal|3
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Define the symbol _GLOBAL_OFFSET_TABLE_ at the start of the      dynobj's .got section.  We don't do this in the linker script      because we don't want to define the symbol if we are not creating      a global offset table.  */
name|h
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|,
name|BSF_GLOBAL
argument_list|,
name|alpha_elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|got
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|false
argument_list|,
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|collect
argument_list|,
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|*
operator|)
operator|&
name|h
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_DEF_REGULAR
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|STT_OBJECT
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
operator|!
name|_bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|false
return|;
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|hgot
operator|=
name|h
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read ECOFF debugging information from a .mdebug section into a    ecoff_debug_info structure.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf64_alpha_read_ecoff_info
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|debug
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|struct
name|ecoff_debug_info
modifier|*
name|debug
decl_stmt|;
block|{
name|HDRR
modifier|*
name|symhdr
decl_stmt|;
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|swap
decl_stmt|;
name|char
modifier|*
name|ext_hdr
init|=
name|NULL
decl_stmt|;
name|swap
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_backend_ecoff_debug_swap
expr_stmt|;
name|memset
argument_list|(
name|debug
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|debug
argument_list|)
argument_list|)
expr_stmt|;
name|ext_hdr
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_malloc
argument_list|(
operator|(
name|size_t
operator|)
name|swap
operator|->
name|external_hdr_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ext_hdr
operator|==
name|NULL
operator|&&
name|swap
operator|->
name|external_hdr_size
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|ext_hdr
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|swap
operator|->
name|external_hdr_size
argument_list|)
operator|==
name|false
condition|)
goto|goto
name|error_return
goto|;
name|symhdr
operator|=
operator|&
name|debug
operator|->
name|symbolic_header
expr_stmt|;
call|(
modifier|*
name|swap
operator|->
name|swap_hdr_in
call|)
argument_list|(
name|abfd
argument_list|,
name|ext_hdr
argument_list|,
name|symhdr
argument_list|)
expr_stmt|;
comment|/* The symbolic header contains absolute file offsets and sizes to      read.  */
define|#
directive|define
name|READ
parameter_list|(
name|ptr
parameter_list|,
name|offset
parameter_list|,
name|count
parameter_list|,
name|size
parameter_list|,
name|type
parameter_list|)
define|\
value|if (symhdr->count == 0)						\     debug->ptr = NULL;							\   else									\     {									\       debug->ptr = (type) bfd_malloc ((size_t) (size * symhdr->count));	\       if (debug->ptr == NULL)						\ 	goto error_return;						\       if (bfd_seek (abfd, (file_ptr) symhdr->offset, SEEK_SET) != 0	\ 	  || (bfd_read (debug->ptr, size, symhdr->count,		\ 			abfd) != size * symhdr->count))			\ 	goto error_return;						\     }
name|READ
argument_list|(
argument|line
argument_list|,
argument|cbLineOffset
argument_list|,
argument|cbLine
argument_list|,
argument|sizeof (unsigned char)
argument_list|,
argument|unsigned char *
argument_list|)
empty_stmt|;
name|READ
argument_list|(
name|external_dnr
argument_list|,
name|cbDnOffset
argument_list|,
name|idnMax
argument_list|,
name|swap
operator|->
name|external_dnr_size
argument_list|,
name|PTR
argument_list|)
expr_stmt|;
name|READ
argument_list|(
name|external_pdr
argument_list|,
name|cbPdOffset
argument_list|,
name|ipdMax
argument_list|,
name|swap
operator|->
name|external_pdr_size
argument_list|,
name|PTR
argument_list|)
expr_stmt|;
name|READ
argument_list|(
name|external_sym
argument_list|,
name|cbSymOffset
argument_list|,
name|isymMax
argument_list|,
name|swap
operator|->
name|external_sym_size
argument_list|,
name|PTR
argument_list|)
expr_stmt|;
name|READ
argument_list|(
name|external_opt
argument_list|,
name|cbOptOffset
argument_list|,
name|ioptMax
argument_list|,
name|swap
operator|->
name|external_opt_size
argument_list|,
name|PTR
argument_list|)
expr_stmt|;
name|READ
argument_list|(
name|external_aux
argument_list|,
name|cbAuxOffset
argument_list|,
name|iauxMax
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|aux_ext
argument_list|)
argument_list|,
expr|union
name|aux_ext
operator|*
argument_list|)
expr_stmt|;
name|READ
argument_list|(
name|ss
argument_list|,
name|cbSsOffset
argument_list|,
name|issMax
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|READ
argument_list|(
name|ssext
argument_list|,
name|cbSsExtOffset
argument_list|,
name|issExtMax
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|READ
argument_list|(
name|external_fdr
argument_list|,
name|cbFdOffset
argument_list|,
name|ifdMax
argument_list|,
name|swap
operator|->
name|external_fdr_size
argument_list|,
name|PTR
argument_list|)
expr_stmt|;
name|READ
argument_list|(
name|external_rfd
argument_list|,
name|cbRfdOffset
argument_list|,
name|crfd
argument_list|,
name|swap
operator|->
name|external_rfd_size
argument_list|,
name|PTR
argument_list|)
expr_stmt|;
name|READ
argument_list|(
name|external_ext
argument_list|,
name|cbExtOffset
argument_list|,
name|iextMax
argument_list|,
name|swap
operator|->
name|external_ext_size
argument_list|,
name|PTR
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|READ
name|debug
operator|->
name|fdr
operator|=
name|NULL
expr_stmt|;
name|debug
operator|->
name|adjust
operator|=
name|NULL
expr_stmt|;
return|return
name|true
return|;
name|error_return
label|:
if|if
condition|(
name|ext_hdr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ext_hdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|line
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|external_dnr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|external_dnr
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|external_pdr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|external_pdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|external_sym
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|external_sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|external_opt
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|external_opt
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|external_aux
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|external_aux
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|ss
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|ss
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|ssext
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|ssext
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|external_fdr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|external_fdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|external_rfd
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|external_rfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|external_ext
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|external_ext
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Alpha ELF local labels start with '$'.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf64_alpha_is_local_label_name
parameter_list|(
name|abfd
parameter_list|,
name|name
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
return|return
name|name
index|[
literal|0
index|]
operator|==
literal|'$'
return|;
block|}
end_function

begin_comment
comment|/* Alpha ELF follows MIPS ELF in using a special find_nearest_line    routine in order to handle the ECOFF debugging information.  We    still call this mips_elf_find_line because of the slot    find_line_info in elf_obj_tdata is declared that way.  */
end_comment

begin_struct
struct|struct
name|mips_elf_find_line
block|{
name|struct
name|ecoff_debug_info
name|d
decl_stmt|;
name|struct
name|ecoff_find_line
name|i
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|boolean
name|elf64_alpha_find_nearest_line
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|symbols
parameter_list|,
name|offset
parameter_list|,
name|filename_ptr
parameter_list|,
name|functionname_ptr
parameter_list|,
name|line_ptr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|filename_ptr
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|functionname_ptr
decl_stmt|;
name|unsigned
name|int
modifier|*
name|line_ptr
decl_stmt|;
block|{
name|asection
modifier|*
name|msec
decl_stmt|;
if|if
condition|(
name|_bfd_dwarf2_find_nearest_line
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|symbols
argument_list|,
name|offset
argument_list|,
name|filename_ptr
argument_list|,
name|functionname_ptr
argument_list|,
name|line_ptr
argument_list|,
literal|0
argument_list|,
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|dwarf2_find_line_info
argument_list|)
condition|)
return|return
name|true
return|;
name|msec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".mdebug"
argument_list|)
expr_stmt|;
if|if
condition|(
name|msec
operator|!=
name|NULL
condition|)
block|{
name|flagword
name|origflags
decl_stmt|;
name|struct
name|mips_elf_find_line
modifier|*
name|fi
decl_stmt|;
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
specifier|const
name|swap
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_backend_ecoff_debug_swap
decl_stmt|;
comment|/* If we are called during a link, alpha_elf_final_link may have 	 cleared the SEC_HAS_CONTENTS field.  We force it back on here 	 if appropriate (which it normally will be).  */
name|origflags
operator|=
name|msec
operator|->
name|flags
expr_stmt|;
if|if
condition|(
name|elf_section_data
argument_list|(
name|msec
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_type
operator|!=
name|SHT_NOBITS
condition|)
name|msec
operator|->
name|flags
operator||=
name|SEC_HAS_CONTENTS
expr_stmt|;
name|fi
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|find_line_info
expr_stmt|;
if|if
condition|(
name|fi
operator|==
name|NULL
condition|)
block|{
name|bfd_size_type
name|external_fdr_size
decl_stmt|;
name|char
modifier|*
name|fraw_src
decl_stmt|;
name|char
modifier|*
name|fraw_end
decl_stmt|;
name|struct
name|fdr
modifier|*
name|fdr_ptr
decl_stmt|;
name|fi
operator|=
operator|(
operator|(
expr|struct
name|mips_elf_find_line
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mips_elf_find_line
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|fi
operator|==
name|NULL
condition|)
block|{
name|msec
operator|->
name|flags
operator|=
name|origflags
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|elf64_alpha_read_ecoff_info
argument_list|(
name|abfd
argument_list|,
name|msec
argument_list|,
operator|&
name|fi
operator|->
name|d
argument_list|)
condition|)
block|{
name|msec
operator|->
name|flags
operator|=
name|origflags
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Swap in the FDR information.  */
name|fi
operator|->
name|d
operator|.
name|fdr
operator|=
operator|(
operator|(
expr|struct
name|fdr
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
operator|(
name|fi
operator|->
name|d
operator|.
name|symbolic_header
operator|.
name|ifdMax
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|fdr
argument_list|)
operator|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|fi
operator|->
name|d
operator|.
name|fdr
operator|==
name|NULL
condition|)
block|{
name|msec
operator|->
name|flags
operator|=
name|origflags
expr_stmt|;
return|return
name|false
return|;
block|}
name|external_fdr_size
operator|=
name|swap
operator|->
name|external_fdr_size
expr_stmt|;
name|fdr_ptr
operator|=
name|fi
operator|->
name|d
operator|.
name|fdr
expr_stmt|;
name|fraw_src
operator|=
operator|(
name|char
operator|*
operator|)
name|fi
operator|->
name|d
operator|.
name|external_fdr
expr_stmt|;
name|fraw_end
operator|=
operator|(
name|fraw_src
operator|+
name|fi
operator|->
name|d
operator|.
name|symbolic_header
operator|.
name|ifdMax
operator|*
name|external_fdr_size
operator|)
expr_stmt|;
for|for
control|(
init|;
name|fraw_src
operator|<
name|fraw_end
condition|;
name|fraw_src
operator|+=
name|external_fdr_size
operator|,
name|fdr_ptr
operator|++
control|)
call|(
modifier|*
name|swap
operator|->
name|swap_fdr_in
call|)
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|fraw_src
argument_list|,
name|fdr_ptr
argument_list|)
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|find_line_info
operator|=
name|fi
expr_stmt|;
comment|/* Note that we don't bother to ever free this information.              find_nearest_line is either called all the time, as in              objdump -l, so the information should be saved, or it is              rarely called, as in ld error messages, so the memory              wasted is unimportant.  Still, it would probably be a              good idea for free_cached_info to throw it away.  */
block|}
if|if
condition|(
name|_bfd_ecoff_locate_line
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|offset
argument_list|,
operator|&
name|fi
operator|->
name|d
argument_list|,
name|swap
argument_list|,
operator|&
name|fi
operator|->
name|i
argument_list|,
name|filename_ptr
argument_list|,
name|functionname_ptr
argument_list|,
name|line_ptr
argument_list|)
condition|)
block|{
name|msec
operator|->
name|flags
operator|=
name|origflags
expr_stmt|;
return|return
name|true
return|;
block|}
name|msec
operator|->
name|flags
operator|=
name|origflags
expr_stmt|;
block|}
comment|/* Fall back on the generic ELF find_nearest_line routine.  */
return|return
name|_bfd_elf_find_nearest_line
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|symbols
argument_list|,
name|offset
argument_list|,
name|filename_ptr
argument_list|,
name|functionname_ptr
argument_list|,
name|line_ptr
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Structure used to pass information to alpha_elf_output_extsym.  */
end_comment

begin_struct
struct|struct
name|extsym_info
block|{
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|ecoff_debug_info
modifier|*
name|debug
decl_stmt|;
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|swap
decl_stmt|;
name|boolean
name|failed
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|boolean
name|elf64_alpha_output_extsym
parameter_list|(
name|h
parameter_list|,
name|data
parameter_list|)
name|struct
name|alpha_elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
name|struct
name|extsym_info
modifier|*
name|einfo
init|=
operator|(
expr|struct
name|extsym_info
operator|*
operator|)
name|data
decl_stmt|;
name|boolean
name|strip
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|,
modifier|*
name|output_section
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|indx
operator|==
operator|-
literal|2
condition|)
name|strip
operator|=
name|false
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|(
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|||
operator|(
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_REF_DYNAMIC
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_REF_REGULAR
operator|)
operator|==
literal|0
condition|)
name|strip
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|einfo
operator|->
name|info
operator|->
name|strip
operator|==
name|strip_all
operator|||
operator|(
name|einfo
operator|->
name|info
operator|->
name|strip
operator|==
name|strip_some
operator|&&
name|bfd_hash_lookup
argument_list|(
name|einfo
operator|->
name|info
operator|->
name|keep_hash
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
operator|==
name|NULL
operator|)
condition|)
name|strip
operator|=
name|true
expr_stmt|;
else|else
name|strip
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|strip
condition|)
return|return
name|true
return|;
if|if
condition|(
name|h
operator|->
name|esym
operator|.
name|ifd
operator|==
operator|-
literal|2
condition|)
block|{
name|h
operator|->
name|esym
operator|.
name|jmptbl
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|cobol_main
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|weakext
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|reserved
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|ifd
operator|=
name|ifdNil
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|st
operator|=
name|stGlobal
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defined
operator|&&
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scAbs
expr_stmt|;
else|else
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|sec
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|output_section
operator|=
name|sec
operator|->
name|output_section
expr_stmt|;
comment|/* When making a shared library and symbol h is the one from             the another shared library, OUTPUT_SECTION may be null.  */
if|if
condition|(
name|output_section
operator|==
name|NULL
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scUndefined
expr_stmt|;
else|else
block|{
name|name
operator|=
name|bfd_section_name
argument_list|(
name|output_section
operator|->
name|owner
argument_list|,
name|output_section
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".text"
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scText
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".data"
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scData
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sdata"
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scSData
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".rodata"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".rdata"
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scRData
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".bss"
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scBss
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sbss"
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scSBss
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".init"
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scInit
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".fini"
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scFini
expr_stmt|;
else|else
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scAbs
expr_stmt|;
block|}
block|}
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|reserved
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|index
operator|=
name|indexNil
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_common
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|size
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|==
name|scCommon
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scBss
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|==
name|scSCommon
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scSBss
expr_stmt|;
name|sec
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|output_section
operator|=
name|sec
operator|->
name|output_section
expr_stmt|;
if|if
condition|(
name|output_section
operator|!=
name|NULL
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
else|else
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_NEEDS_PLT
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Set type and value for a symbol with a function stub.  */
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|st
operator|=
name|stProc
expr_stmt|;
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|einfo
operator|->
name|abfd
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|output_section
operator|=
name|sec
operator|->
name|output_section
expr_stmt|;
if|if
condition|(
name|output_section
operator|!=
name|NULL
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|plt
operator|.
name|offset
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
else|else
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
literal|0
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* FIXME?  */
block|h->esym.ifd = 0;
endif|#
directive|endif
block|}
if|if
condition|(
operator|!
name|bfd_ecoff_debug_one_external
argument_list|(
name|einfo
operator|->
name|abfd
argument_list|,
name|einfo
operator|->
name|debug
argument_list|,
name|einfo
operator|->
name|swap
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
operator|&
name|h
operator|->
name|esym
argument_list|)
condition|)
block|{
name|einfo
operator|->
name|failed
operator|=
name|true
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* FIXME:  Create a runtime procedure table from the .mdebug section.  static boolean mips_elf_create_procedure_table (handle, abfd, info, s, debug)      PTR handle;      bfd *abfd;      struct bfd_link_info *info;      asection *s;      struct ecoff_debug_info *debug; */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Handle dynamic relocations when doing an Alpha ELF link.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf64_alpha_check_relocs
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|sec
parameter_list|,
name|relocs
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|;
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|sreloc
decl_stmt|;
specifier|const
name|char
modifier|*
name|rel_sec_name
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|alpha_elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|struct
name|alpha_elf_got_entry
modifier|*
modifier|*
name|local_got_entries
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|,
modifier|*
name|relend
decl_stmt|;
name|int
name|got_created
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocateable
condition|)
return|return
name|true
return|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
if|if
condition|(
name|dynobj
operator|==
name|NULL
condition|)
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
operator|=
name|dynobj
operator|=
name|abfd
expr_stmt|;
name|sreloc
operator|=
name|NULL
expr_stmt|;
name|rel_sec_name
operator|=
name|NULL
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|alpha_elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|local_got_entries
operator|=
name|alpha_elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|local_got_entries
expr_stmt|;
name|got_created
operator|=
literal|0
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|relend
condition|;
operator|++
name|rel
control|)
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|,
name|r_type
decl_stmt|;
name|struct
name|alpha_elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|r_symndx
operator|=
name|ELF64_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
name|h
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|alpha_elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_REF_REGULAR
expr_stmt|;
block|}
name|r_type
operator|=
name|ELF64_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_ALPHA_LITERAL
case|:
block|{
name|struct
name|alpha_elf_got_entry
modifier|*
name|gotent
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|h
condition|)
block|{
comment|/* Search for and possibly create a got entry.  */
for|for
control|(
name|gotent
operator|=
name|h
operator|->
name|got_entries
init|;
name|gotent
condition|;
name|gotent
operator|=
name|gotent
operator|->
name|next
control|)
if|if
condition|(
name|gotent
operator|->
name|gotobj
operator|==
name|abfd
operator|&&
name|gotent
operator|->
name|addend
operator|==
name|rel
operator|->
name|r_addend
condition|)
break|break;
if|if
condition|(
operator|!
name|gotent
condition|)
block|{
name|gotent
operator|=
operator|(
operator|(
expr|struct
name|alpha_elf_got_entry
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|alpha_elf_got_entry
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|gotent
condition|)
return|return
name|false
return|;
name|gotent
operator|->
name|gotobj
operator|=
name|abfd
expr_stmt|;
name|gotent
operator|->
name|addend
operator|=
name|rel
operator|->
name|r_addend
expr_stmt|;
name|gotent
operator|->
name|got_offset
operator|=
operator|-
literal|1
expr_stmt|;
name|gotent
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|gotent
operator|->
name|use_count
operator|=
literal|1
expr_stmt|;
name|gotent
operator|->
name|next
operator|=
name|h
operator|->
name|got_entries
expr_stmt|;
name|h
operator|->
name|got_entries
operator|=
name|gotent
expr_stmt|;
name|alpha_elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|total_got_entries
operator|++
expr_stmt|;
block|}
else|else
name|gotent
operator|->
name|use_count
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* This is a local .got entry -- record for merge.  */
if|if
condition|(
operator|!
name|local_got_entries
condition|)
block|{
name|size_t
name|size
decl_stmt|;
name|size
operator|=
operator|(
name|symtab_hdr
operator|->
name|sh_info
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|alpha_elf_got_entry
operator|*
argument_list|)
operator|)
expr_stmt|;
name|local_got_entries
operator|=
operator|(
operator|(
expr|struct
name|alpha_elf_got_entry
operator|*
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|local_got_entries
condition|)
return|return
name|false
return|;
name|memset
argument_list|(
name|local_got_entries
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|alpha_elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|local_got_entries
operator|=
name|local_got_entries
expr_stmt|;
block|}
for|for
control|(
name|gotent
operator|=
name|local_got_entries
index|[
name|ELF64_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
index|]
init|;
name|gotent
operator|!=
name|NULL
operator|&&
name|gotent
operator|->
name|addend
operator|!=
name|rel
operator|->
name|r_addend
condition|;
name|gotent
operator|=
name|gotent
operator|->
name|next
control|)
continue|continue;
if|if
condition|(
operator|!
name|gotent
condition|)
block|{
name|gotent
operator|=
operator|(
operator|(
expr|struct
name|alpha_elf_got_entry
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|alpha_elf_got_entry
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|gotent
condition|)
return|return
name|false
return|;
name|gotent
operator|->
name|gotobj
operator|=
name|abfd
expr_stmt|;
name|gotent
operator|->
name|addend
operator|=
name|rel
operator|->
name|r_addend
expr_stmt|;
name|gotent
operator|->
name|got_offset
operator|=
operator|-
literal|1
expr_stmt|;
name|gotent
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|gotent
operator|->
name|use_count
operator|=
literal|1
expr_stmt|;
name|gotent
operator|->
name|next
operator|=
name|local_got_entries
index|[
name|ELF64_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
index|]
expr_stmt|;
name|local_got_entries
index|[
name|ELF64_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
index|]
operator|=
name|gotent
expr_stmt|;
name|alpha_elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|total_got_entries
operator|++
expr_stmt|;
name|alpha_elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|n_local_got_entries
operator|++
expr_stmt|;
block|}
else|else
name|gotent
operator|->
name|use_count
operator|+=
literal|1
expr_stmt|;
block|}
comment|/* Remember how this literal is used from its LITUSEs. 	       This will be important when it comes to decide if we can 	       create a .plt entry for a function symbol.  */
if|if
condition|(
name|rel
operator|+
literal|1
operator|<
name|relend
operator|&&
name|ELF64_R_TYPE
argument_list|(
name|rel
index|[
literal|1
index|]
operator|.
name|r_info
argument_list|)
operator|==
name|R_ALPHA_LITUSE
condition|)
block|{
do|do
block|{
operator|++
name|rel
expr_stmt|;
if|if
condition|(
name|rel
operator|->
name|r_addend
operator|>=
literal|1
operator|&&
name|rel
operator|->
name|r_addend
operator|<=
literal|3
condition|)
name|flags
operator||=
literal|1
operator|<<
name|rel
operator|->
name|r_addend
expr_stmt|;
block|}
do|while
condition|(
name|rel
operator|+
literal|1
operator|<
name|relend
operator|&&
name|ELF64_R_TYPE
argument_list|(
name|rel
index|[
literal|1
index|]
operator|.
name|r_info
argument_list|)
operator|==
name|R_ALPHA_LITUSE
condition|)
do|;
block|}
else|else
block|{
comment|/* No LITUSEs -- presumably the address is not being 		   loaded for nothing.  */
name|flags
operator|=
name|ALPHA_ELF_LINK_HASH_LU_ADDR
expr_stmt|;
block|}
name|gotent
operator|->
name|flags
operator||=
name|flags
expr_stmt|;
if|if
condition|(
name|h
condition|)
block|{
comment|/* Make a guess as to whether a .plt entry will be needed.  */
if|if
condition|(
operator|(
name|h
operator|->
name|flags
operator||=
name|flags
operator|)
operator|==
name|ALPHA_ELF_LINK_HASH_LU_FUNC
condition|)
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_NEEDS_PLT
expr_stmt|;
else|else
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_HASH_NEEDS_PLT
expr_stmt|;
block|}
block|}
comment|/* FALLTHRU */
case|case
name|R_ALPHA_GPDISP
case|:
case|case
name|R_ALPHA_GPREL32
case|:
case|case
name|R_ALPHA_GPRELHIGH
case|:
case|case
name|R_ALPHA_GPRELLOW
case|:
comment|/* We don't actually use the .got here, but the sections must 	     be created before the linker maps input sections to output 	     sections.  */
if|if
condition|(
operator|!
name|got_created
condition|)
block|{
if|if
condition|(
operator|!
name|elf64_alpha_create_got_section
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Make sure the object's gotobj is set to itself so 		 that we default to every object with its own .got. 		 We'll merge .gots later once we've collected each 		 object's info.  */
name|alpha_elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|gotobj
operator|=
name|abfd
expr_stmt|;
name|got_created
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|R_ALPHA_SREL16
case|:
case|case
name|R_ALPHA_SREL32
case|:
case|case
name|R_ALPHA_SREL64
case|:
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
break|break;
comment|/* FALLTHRU */
case|case
name|R_ALPHA_REFLONG
case|:
case|case
name|R_ALPHA_REFQUAD
case|:
if|if
condition|(
name|rel_sec_name
operator|==
name|NULL
condition|)
block|{
name|rel_sec_name
operator|=
operator|(
name|bfd_elf_string_from_elf_section
argument_list|(
name|abfd
argument_list|,
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_shstrndx
argument_list|,
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|rel_hdr
operator|.
name|sh_name
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|rel_sec_name
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|BFD_ASSERT
argument_list|(
name|strncmp
argument_list|(
name|rel_sec_name
argument_list|,
literal|".rela"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|,
name|rel_sec_name
operator|+
literal|5
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* We need to create the section here now whether we eventually 	     use it or not so that it gets mapped to an output section by 	     the linker.  If not used, we'll kill it in 	     size_dynamic_sections.  */
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
block|{
name|sreloc
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|rel_sec_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
block|{
name|sreloc
operator|=
name|bfd_make_section
argument_list|(
name|dynobj
argument_list|,
name|rel_sec_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|dynobj
argument_list|,
name|sreloc
argument_list|,
operator|(
operator|(
name|sec
operator|->
name|flags
operator|&
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator|)
operator|)
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_READONLY
operator|)
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|sreloc
argument_list|,
literal|3
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
if|if
condition|(
name|h
condition|)
block|{
comment|/* Since we havn't seen all of the input symbols yet, we 		 don't know whether we'll actually need a dynamic relocation 		 entry for this reloc.  So make a record of it.  Once we 		 find out if this thing needs dynamic relocation we'll 		 expand the relocation sections by the appropriate amount.  */
name|struct
name|alpha_elf_reloc_entry
modifier|*
name|rent
decl_stmt|;
for|for
control|(
name|rent
operator|=
name|h
operator|->
name|reloc_entries
init|;
name|rent
condition|;
name|rent
operator|=
name|rent
operator|->
name|next
control|)
if|if
condition|(
name|rent
operator|->
name|rtype
operator|==
name|r_type
operator|&&
name|rent
operator|->
name|srel
operator|==
name|sreloc
condition|)
break|break;
if|if
condition|(
operator|!
name|rent
condition|)
block|{
name|rent
operator|=
operator|(
operator|(
expr|struct
name|alpha_elf_reloc_entry
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|alpha_elf_reloc_entry
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|rent
condition|)
return|return
name|false
return|;
name|rent
operator|->
name|srel
operator|=
name|sreloc
expr_stmt|;
name|rent
operator|->
name|rtype
operator|=
name|r_type
expr_stmt|;
name|rent
operator|->
name|count
operator|=
literal|1
expr_stmt|;
name|rent
operator|->
name|next
operator|=
name|h
operator|->
name|reloc_entries
expr_stmt|;
name|h
operator|->
name|reloc_entries
operator|=
name|rent
expr_stmt|;
block|}
else|else
name|rent
operator|->
name|count
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
condition|)
block|{
comment|/* If this is a shared library, and the section is to be 		 loaded into memory, we need a RELATIVE reloc.  */
name|sreloc
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Adjust a symbol defined by a dynamic object and referenced by a    regular object.  The current definition is in some section of the    dynamic object, but we're not including those sections.  We have to    change the definition to something the rest of the link can    understand.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf64_alpha_adjust_dynamic_symbol
parameter_list|(
name|info
parameter_list|,
name|h
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|struct
name|alpha_elf_link_hash_entry
modifier|*
name|ah
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|ah
operator|=
operator|(
expr|struct
name|alpha_elf_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
comment|/* Now that we've seen all of the input symbols, finalize our decision      about whether this symbol should get a .plt entry.  */
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefweak
operator|&&
name|alpha_elf_dynamic_symbol_p
argument_list|(
name|h
argument_list|,
name|info
argument_list|)
operator|&&
operator|(
operator|(
name|h
operator|->
name|type
operator|==
name|STT_FUNC
operator|&&
operator|!
operator|(
name|ah
operator|->
name|flags
operator|&
name|ALPHA_ELF_LINK_HASH_LU_ADDR
operator|)
operator|)
operator|||
operator|(
name|h
operator|->
name|type
operator|==
name|STT_NOTYPE
operator|&&
name|ah
operator|->
name|flags
operator|==
name|ALPHA_ELF_LINK_HASH_LU_FUNC
operator|)
operator|)
comment|/* Don't prevent otherwise valid programs from linking by attempting 	 to create a new .got entry somewhere.  A Correct Solution would be 	 to add a new .got section to a new object file and let it be merged 	 somewhere later.  But for now don't bother.  */
operator|&&
name|ah
operator|->
name|got_entries
condition|)
block|{
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_NEEDS_PLT
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
operator|&&
operator|!
name|elf64_alpha_create_dynamic_sections
argument_list|(
name|dynobj
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* The first bit of the .plt is reserved.  */
if|if
condition|(
name|s
operator|->
name|_raw_size
operator|==
literal|0
condition|)
name|s
operator|->
name|_raw_size
operator|=
name|PLT_HEADER_SIZE
expr_stmt|;
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|+=
name|PLT_ENTRY_SIZE
expr_stmt|;
comment|/* If this symbol is not defined in a regular file, and we are not 	 generating a shared library, then set the symbol to the location 	 in the .plt.  This is required to make function pointers compare 	 equal between the normal executable and the shared library.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
condition|)
block|{
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|s
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|h
operator|->
name|plt
operator|.
name|offset
expr_stmt|;
block|}
comment|/* We also need a JMP_SLOT entry in the .rela.plt section.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.plt"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
else|else
name|h
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_HASH_NEEDS_PLT
expr_stmt|;
comment|/* If this is a weak symbol, and there is a real definition, the      processor independent code will have arranged for us to see the      real definition first, and we can just use the same value.  */
if|if
condition|(
name|h
operator|->
name|weakdef
operator|!=
name|NULL
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
argument_list|)
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* This is a reference to a symbol defined by a dynamic object which      is not a function.  The Alpha, since it uses .got entries for all      symbols even in regular objects, does not need the hackery of a      .dynbss section and COPY dynamic relocations.  */
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Symbol versioning can create new symbols, and make our old symbols    indirect to the new ones.  Consolidate the got and reloc information    in these situations.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf64_alpha_merge_ind_symbols
parameter_list|(
name|hi
parameter_list|,
name|dummy
parameter_list|)
name|struct
name|alpha_elf_link_hash_entry
modifier|*
name|hi
decl_stmt|;
name|PTR
name|dummy
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|struct
name|alpha_elf_link_hash_entry
modifier|*
name|hs
decl_stmt|;
if|if
condition|(
name|hi
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_indirect
condition|)
return|return
name|true
return|;
name|hs
operator|=
name|hi
expr_stmt|;
do|do
block|{
name|hs
operator|=
operator|(
expr|struct
name|alpha_elf_link_hash_entry
operator|*
operator|)
name|hs
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
block|}
do|while
condition|(
name|hs
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
condition|)
do|;
comment|/* Merge the flags.  Whee.  */
name|hs
operator|->
name|flags
operator||=
name|hi
operator|->
name|flags
expr_stmt|;
comment|/* Merge the .got entries.  Cannibalize the old symbol's list in      doing so, since we don't need it anymore.  */
if|if
condition|(
name|hs
operator|->
name|got_entries
operator|==
name|NULL
condition|)
name|hs
operator|->
name|got_entries
operator|=
name|hi
operator|->
name|got_entries
expr_stmt|;
else|else
block|{
name|struct
name|alpha_elf_got_entry
modifier|*
name|gi
decl_stmt|,
modifier|*
name|gs
decl_stmt|,
modifier|*
name|gin
decl_stmt|,
modifier|*
name|gsh
decl_stmt|;
name|gsh
operator|=
name|hs
operator|->
name|got_entries
expr_stmt|;
for|for
control|(
name|gi
operator|=
name|hi
operator|->
name|got_entries
init|;
name|gi
condition|;
name|gi
operator|=
name|gin
control|)
block|{
name|gin
operator|=
name|gi
operator|->
name|next
expr_stmt|;
for|for
control|(
name|gs
operator|=
name|gsh
init|;
name|gs
condition|;
name|gs
operator|=
name|gs
operator|->
name|next
control|)
if|if
condition|(
name|gi
operator|->
name|gotobj
operator|==
name|gs
operator|->
name|gotobj
operator|&&
name|gi
operator|->
name|addend
operator|==
name|gs
operator|->
name|addend
condition|)
goto|goto
name|got_found
goto|;
name|gi
operator|->
name|next
operator|=
name|hs
operator|->
name|got_entries
expr_stmt|;
name|hs
operator|->
name|got_entries
operator|=
name|gi
expr_stmt|;
name|got_found
label|:
empty_stmt|;
block|}
block|}
name|hi
operator|->
name|got_entries
operator|=
name|NULL
expr_stmt|;
comment|/* And similar for the reloc entries.  */
if|if
condition|(
name|hs
operator|->
name|reloc_entries
operator|==
name|NULL
condition|)
name|hs
operator|->
name|reloc_entries
operator|=
name|hi
operator|->
name|reloc_entries
expr_stmt|;
else|else
block|{
name|struct
name|alpha_elf_reloc_entry
modifier|*
name|ri
decl_stmt|,
modifier|*
name|rs
decl_stmt|,
modifier|*
name|rin
decl_stmt|,
modifier|*
name|rsh
decl_stmt|;
name|rsh
operator|=
name|hs
operator|->
name|reloc_entries
expr_stmt|;
for|for
control|(
name|ri
operator|=
name|hi
operator|->
name|reloc_entries
init|;
name|ri
condition|;
name|ri
operator|=
name|rin
control|)
block|{
name|rin
operator|=
name|ri
operator|->
name|next
expr_stmt|;
for|for
control|(
name|rs
operator|=
name|rsh
init|;
name|rs
condition|;
name|rs
operator|=
name|rs
operator|->
name|next
control|)
if|if
condition|(
name|ri
operator|->
name|rtype
operator|==
name|rs
operator|->
name|rtype
condition|)
block|{
name|rs
operator|->
name|count
operator|+=
name|ri
operator|->
name|count
expr_stmt|;
goto|goto
name|found_reloc
goto|;
block|}
name|ri
operator|->
name|next
operator|=
name|hs
operator|->
name|reloc_entries
expr_stmt|;
name|hs
operator|->
name|reloc_entries
operator|=
name|ri
expr_stmt|;
name|found_reloc
label|:
empty_stmt|;
block|}
block|}
name|hi
operator|->
name|reloc_entries
operator|=
name|NULL
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Is it possible to merge two object file's .got tables?  */
end_comment

begin_function
specifier|static
name|boolean
name|elf64_alpha_can_merge_gots
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|bfd
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|;
end_function

begin_block
block|{
name|int
name|total
init|=
name|alpha_elf_tdata
argument_list|(
name|a
argument_list|)
operator|->
name|total_got_entries
decl_stmt|;
name|bfd
modifier|*
name|bsub
decl_stmt|;
comment|/* Trivial quick fallout test.  */
if|if
condition|(
name|total
operator|+
name|alpha_elf_tdata
argument_list|(
name|b
argument_list|)
operator|->
name|total_got_entries
operator|<=
name|MAX_GOT_ENTRIES
condition|)
return|return
name|true
return|;
comment|/* By their nature, local .got entries cannot be merged.  */
if|if
condition|(
operator|(
name|total
operator|+=
name|alpha_elf_tdata
argument_list|(
name|b
argument_list|)
operator|->
name|n_local_got_entries
operator|)
operator|>
name|MAX_GOT_ENTRIES
condition|)
return|return
name|false
return|;
comment|/* Failing the common trivial comparison, we must effectively      perform the merge.  Not actually performing the merge means that      we don't have to store undo information in case we fail.  */
for|for
control|(
name|bsub
operator|=
name|b
init|;
name|bsub
condition|;
name|bsub
operator|=
name|alpha_elf_tdata
argument_list|(
name|bsub
argument_list|)
operator|->
name|in_got_link_next
control|)
block|{
name|struct
name|alpha_elf_link_hash_entry
modifier|*
modifier|*
name|hashes
init|=
name|alpha_elf_sym_hashes
argument_list|(
name|bsub
argument_list|)
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
init|=
operator|&
name|elf_tdata
argument_list|(
name|bsub
argument_list|)
operator|->
name|symtab_hdr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|n
operator|=
name|NUM_SHDR_ENTRIES
argument_list|(
name|symtab_hdr
argument_list|)
operator|-
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|alpha_elf_got_entry
modifier|*
name|ae
decl_stmt|,
modifier|*
name|be
decl_stmt|;
name|struct
name|alpha_elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
name|hashes
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|alpha_elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
for|for
control|(
name|be
operator|=
name|h
operator|->
name|got_entries
init|;
name|be
condition|;
name|be
operator|=
name|be
operator|->
name|next
control|)
block|{
if|if
condition|(
name|be
operator|->
name|use_count
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|be
operator|->
name|gotobj
operator|!=
name|b
condition|)
continue|continue;
for|for
control|(
name|ae
operator|=
name|h
operator|->
name|got_entries
init|;
name|ae
condition|;
name|ae
operator|=
name|ae
operator|->
name|next
control|)
if|if
condition|(
name|ae
operator|->
name|gotobj
operator|==
name|a
operator|&&
name|ae
operator|->
name|addend
operator|==
name|be
operator|->
name|addend
condition|)
goto|goto
name|global_found
goto|;
if|if
condition|(
operator|++
name|total
operator|>
name|MAX_GOT_ENTRIES
condition|)
return|return
name|false
return|;
name|global_found
label|:
empty_stmt|;
block|}
block|}
block|}
return|return
name|true
return|;
block|}
end_block

begin_comment
comment|/* Actually merge two .got tables.  */
end_comment

begin_function
specifier|static
name|void
name|elf64_alpha_merge_gots
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|bfd
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|;
end_function

begin_block
block|{
name|int
name|total
init|=
name|alpha_elf_tdata
argument_list|(
name|a
argument_list|)
operator|->
name|total_got_entries
decl_stmt|;
name|bfd
modifier|*
name|bsub
decl_stmt|;
comment|/* Remember local expansion.  */
block|{
name|int
name|e
init|=
name|alpha_elf_tdata
argument_list|(
name|b
argument_list|)
operator|->
name|n_local_got_entries
decl_stmt|;
name|total
operator|+=
name|e
expr_stmt|;
name|alpha_elf_tdata
argument_list|(
name|a
argument_list|)
operator|->
name|n_local_got_entries
operator|+=
name|e
expr_stmt|;
block|}
for|for
control|(
name|bsub
operator|=
name|b
init|;
name|bsub
condition|;
name|bsub
operator|=
name|alpha_elf_tdata
argument_list|(
name|bsub
argument_list|)
operator|->
name|in_got_link_next
control|)
block|{
name|struct
name|alpha_elf_got_entry
modifier|*
modifier|*
name|local_got_entries
decl_stmt|;
name|struct
name|alpha_elf_link_hash_entry
modifier|*
modifier|*
name|hashes
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
comment|/* Let the local .got entries know they are part of a new subsegment.  */
name|local_got_entries
operator|=
name|alpha_elf_tdata
argument_list|(
name|bsub
argument_list|)
operator|->
name|local_got_entries
expr_stmt|;
if|if
condition|(
name|local_got_entries
condition|)
block|{
name|n
operator|=
name|elf_tdata
argument_list|(
name|bsub
argument_list|)
operator|->
name|symtab_hdr
operator|.
name|sh_info
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|alpha_elf_got_entry
modifier|*
name|ent
decl_stmt|;
for|for
control|(
name|ent
operator|=
name|local_got_entries
index|[
name|i
index|]
init|;
name|ent
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
name|ent
operator|->
name|gotobj
operator|=
name|a
expr_stmt|;
block|}
block|}
comment|/* Merge the global .got entries.  */
name|hashes
operator|=
name|alpha_elf_sym_hashes
argument_list|(
name|bsub
argument_list|)
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|bsub
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|n
operator|=
name|NUM_SHDR_ENTRIES
argument_list|(
name|symtab_hdr
argument_list|)
operator|-
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|alpha_elf_got_entry
modifier|*
name|ae
decl_stmt|,
modifier|*
name|be
decl_stmt|,
modifier|*
modifier|*
name|pbe
decl_stmt|,
modifier|*
modifier|*
name|start
decl_stmt|;
name|struct
name|alpha_elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
name|hashes
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|alpha_elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|start
operator|=
operator|&
name|h
operator|->
name|got_entries
expr_stmt|;
for|for
control|(
name|pbe
operator|=
name|start
operator|,
name|be
operator|=
operator|*
name|start
init|;
name|be
condition|;
name|pbe
operator|=
operator|&
name|be
operator|->
name|next
operator|,
name|be
operator|=
name|be
operator|->
name|next
control|)
block|{
if|if
condition|(
name|be
operator|->
name|use_count
operator|==
literal|0
condition|)
block|{
operator|*
name|pbe
operator|=
name|be
operator|->
name|next
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|be
operator|->
name|gotobj
operator|!=
name|b
condition|)
continue|continue;
for|for
control|(
name|ae
operator|=
operator|*
name|start
init|;
name|ae
condition|;
name|ae
operator|=
name|ae
operator|->
name|next
control|)
if|if
condition|(
name|ae
operator|->
name|gotobj
operator|==
name|a
operator|&&
name|ae
operator|->
name|addend
operator|==
name|be
operator|->
name|addend
condition|)
block|{
name|ae
operator|->
name|flags
operator||=
name|be
operator|->
name|flags
expr_stmt|;
name|ae
operator|->
name|use_count
operator|+=
name|be
operator|->
name|use_count
expr_stmt|;
operator|*
name|pbe
operator|=
name|be
operator|->
name|next
expr_stmt|;
goto|goto
name|global_found
goto|;
block|}
name|be
operator|->
name|gotobj
operator|=
name|a
expr_stmt|;
name|total
operator|+=
literal|1
expr_stmt|;
name|global_found
label|:
empty_stmt|;
block|}
block|}
name|alpha_elf_tdata
argument_list|(
name|bsub
argument_list|)
operator|->
name|gotobj
operator|=
name|a
expr_stmt|;
block|}
name|alpha_elf_tdata
argument_list|(
name|a
argument_list|)
operator|->
name|total_got_entries
operator|=
name|total
expr_stmt|;
comment|/* Merge the two in_got chains.  */
block|{
name|bfd
modifier|*
name|next
decl_stmt|;
name|bsub
operator|=
name|a
expr_stmt|;
while|while
condition|(
operator|(
name|next
operator|=
name|alpha_elf_tdata
argument_list|(
name|bsub
argument_list|)
operator|->
name|in_got_link_next
operator|)
operator|!=
name|NULL
condition|)
name|bsub
operator|=
name|next
expr_stmt|;
name|alpha_elf_tdata
argument_list|(
name|bsub
argument_list|)
operator|->
name|in_got_link_next
operator|=
name|b
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Calculate the offsets for the got entries.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf64_alpha_calc_got_offsets_for_symbol
parameter_list|(
name|h
parameter_list|,
name|arg
parameter_list|)
name|struct
name|alpha_elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|PTR
name|arg
decl_stmt|;
block|{
name|struct
name|alpha_elf_got_entry
modifier|*
name|gotent
decl_stmt|;
for|for
control|(
name|gotent
operator|=
name|h
operator|->
name|got_entries
init|;
name|gotent
condition|;
name|gotent
operator|=
name|gotent
operator|->
name|next
control|)
if|if
condition|(
name|gotent
operator|->
name|use_count
operator|>
literal|0
condition|)
block|{
name|bfd_size_type
modifier|*
name|plge
init|=
operator|&
name|alpha_elf_tdata
argument_list|(
name|gotent
operator|->
name|gotobj
argument_list|)
operator|->
name|got
operator|->
name|_raw_size
decl_stmt|;
name|gotent
operator|->
name|got_offset
operator|=
operator|*
name|plge
expr_stmt|;
operator|*
name|plge
operator|+=
literal|8
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|elf64_alpha_calc_got_offsets
parameter_list|(
name|info
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|bfd
modifier|*
name|i
decl_stmt|,
modifier|*
name|got_list
init|=
name|alpha_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|got_list
decl_stmt|;
comment|/* First, zero out the .got sizes, as we may be recalculating the      .got after optimizing it.  */
for|for
control|(
name|i
operator|=
name|got_list
init|;
name|i
condition|;
name|i
operator|=
name|alpha_elf_tdata
argument_list|(
name|i
argument_list|)
operator|->
name|got_link_next
control|)
name|alpha_elf_tdata
argument_list|(
name|i
argument_list|)
operator|->
name|got
operator|->
name|_raw_size
operator|=
literal|0
expr_stmt|;
comment|/* Next, fill in the offsets for all the global entries.  */
name|alpha_elf_link_hash_traverse
argument_list|(
name|alpha_elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|elf64_alpha_calc_got_offsets_for_symbol
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Finally, fill in the offsets for the local entries.  */
for|for
control|(
name|i
operator|=
name|got_list
init|;
name|i
condition|;
name|i
operator|=
name|alpha_elf_tdata
argument_list|(
name|i
argument_list|)
operator|->
name|got_link_next
control|)
block|{
name|bfd_size_type
name|got_offset
init|=
name|alpha_elf_tdata
argument_list|(
name|i
argument_list|)
operator|->
name|got
operator|->
name|_raw_size
decl_stmt|;
name|bfd
modifier|*
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
condition|;
name|j
operator|=
name|alpha_elf_tdata
argument_list|(
name|j
argument_list|)
operator|->
name|in_got_link_next
control|)
block|{
name|struct
name|alpha_elf_got_entry
modifier|*
modifier|*
name|local_got_entries
decl_stmt|,
modifier|*
name|gotent
decl_stmt|;
name|int
name|k
decl_stmt|,
name|n
decl_stmt|;
name|local_got_entries
operator|=
name|alpha_elf_tdata
argument_list|(
name|j
argument_list|)
operator|->
name|local_got_entries
expr_stmt|;
if|if
condition|(
operator|!
name|local_got_entries
condition|)
continue|continue;
for|for
control|(
name|k
operator|=
literal|0
operator|,
name|n
operator|=
name|elf_tdata
argument_list|(
name|j
argument_list|)
operator|->
name|symtab_hdr
operator|.
name|sh_info
init|;
name|k
operator|<
name|n
condition|;
operator|++
name|k
control|)
for|for
control|(
name|gotent
operator|=
name|local_got_entries
index|[
name|k
index|]
init|;
name|gotent
condition|;
name|gotent
operator|=
name|gotent
operator|->
name|next
control|)
if|if
condition|(
name|gotent
operator|->
name|use_count
operator|>
literal|0
condition|)
block|{
name|gotent
operator|->
name|got_offset
operator|=
name|got_offset
expr_stmt|;
name|got_offset
operator|+=
literal|8
expr_stmt|;
block|}
block|}
name|alpha_elf_tdata
argument_list|(
name|i
argument_list|)
operator|->
name|got
operator|->
name|_raw_size
operator|=
name|got_offset
expr_stmt|;
name|alpha_elf_tdata
argument_list|(
name|i
argument_list|)
operator|->
name|got
operator|->
name|_cooked_size
operator|=
name|got_offset
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Constructs the gots.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf64_alpha_size_got_sections
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|bfd
modifier|*
name|i
decl_stmt|,
modifier|*
name|got_list
decl_stmt|,
modifier|*
name|cur_got_obj
decl_stmt|;
name|int
name|something_changed
init|=
literal|0
decl_stmt|;
name|got_list
operator|=
name|alpha_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|got_list
expr_stmt|;
comment|/* On the first time through, pretend we have an existing got list      consisting of all of the input files.  */
if|if
condition|(
name|got_list
operator|==
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
name|info
operator|->
name|input_bfds
init|;
name|i
condition|;
name|i
operator|=
name|i
operator|->
name|link_next
control|)
block|{
name|bfd
modifier|*
name|this_got
init|=
name|alpha_elf_tdata
argument_list|(
name|i
argument_list|)
operator|->
name|gotobj
decl_stmt|;
if|if
condition|(
name|this_got
operator|==
name|NULL
condition|)
continue|continue;
comment|/* We are assuming no merging has yet ocurred.  */
name|BFD_ASSERT
argument_list|(
name|this_got
operator|==
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|alpha_elf_tdata
argument_list|(
name|this_got
argument_list|)
operator|->
name|total_got_entries
operator|>
name|MAX_GOT_ENTRIES
condition|)
block|{
comment|/* Yikes! A single object file has too many entries.  */
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: .got subsegment exceeds 64K (size %d)"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|i
argument_list|)
argument_list|,
name|alpha_elf_tdata
argument_list|(
name|this_got
argument_list|)
operator|->
name|total_got_entries
operator|*
literal|8
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|got_list
operator|==
name|NULL
condition|)
name|got_list
operator|=
name|this_got
expr_stmt|;
else|else
name|alpha_elf_tdata
argument_list|(
name|cur_got_obj
argument_list|)
operator|->
name|got_link_next
operator|=
name|this_got
expr_stmt|;
name|cur_got_obj
operator|=
name|this_got
expr_stmt|;
block|}
comment|/* Strange degenerate case of no got references.  */
if|if
condition|(
name|got_list
operator|==
name|NULL
condition|)
return|return
name|true
return|;
name|alpha_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|got_list
operator|=
name|got_list
expr_stmt|;
comment|/* Force got offsets to be recalculated.  */
name|something_changed
operator|=
literal|1
expr_stmt|;
block|}
name|cur_got_obj
operator|=
name|got_list
expr_stmt|;
name|i
operator|=
name|alpha_elf_tdata
argument_list|(
name|cur_got_obj
argument_list|)
operator|->
name|got_link_next
expr_stmt|;
while|while
condition|(
name|i
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|elf64_alpha_can_merge_gots
argument_list|(
name|cur_got_obj
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|elf64_alpha_merge_gots
argument_list|(
name|cur_got_obj
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|i
operator|=
name|alpha_elf_tdata
argument_list|(
name|i
argument_list|)
operator|->
name|got_link_next
expr_stmt|;
name|alpha_elf_tdata
argument_list|(
name|cur_got_obj
argument_list|)
operator|->
name|got_link_next
operator|=
name|i
expr_stmt|;
name|something_changed
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|cur_got_obj
operator|=
name|i
expr_stmt|;
name|i
operator|=
name|alpha_elf_tdata
argument_list|(
name|i
argument_list|)
operator|->
name|got_link_next
expr_stmt|;
block|}
block|}
comment|/* Once the gots have been merged, fill in the got offsets for      everything therein.  */
if|if
condition|(
literal|1
operator|||
name|something_changed
condition|)
name|elf64_alpha_calc_got_offsets
argument_list|(
name|info
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|elf64_alpha_always_size_sections
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|bfd
modifier|*
name|i
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocateable
condition|)
return|return
name|true
return|;
comment|/* First, take care of the indirect symbols created by versioning.  */
name|alpha_elf_link_hash_traverse
argument_list|(
name|alpha_elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|elf64_alpha_merge_ind_symbols
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|elf64_alpha_size_got_sections
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Allocate space for all of the .got subsections.  */
name|i
operator|=
name|alpha_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|got_list
expr_stmt|;
for|for
control|(
init|;
name|i
condition|;
name|i
operator|=
name|alpha_elf_tdata
argument_list|(
name|i
argument_list|)
operator|->
name|got_link_next
control|)
block|{
name|asection
modifier|*
name|s
init|=
name|alpha_elf_tdata
argument_list|(
name|i
argument_list|)
operator|->
name|got
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|_raw_size
operator|>
literal|0
condition|)
block|{
name|s
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|i
argument_list|,
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|false
return|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Work out the sizes of the dynamic relocation entries.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf64_alpha_calc_dynrel_sizes
parameter_list|(
name|h
parameter_list|,
name|info
parameter_list|)
name|struct
name|alpha_elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
comment|/* If the symbol was defined as a common symbol in a regular object      file, and there was no definition in any dynamic object, then the      linker will have allocated space for the symbol in a common      section but the ELF_LINK_HASH_DEF_REGULAR flag will not have been      set.  This is done for dynamic symbols in      elf_adjust_dynamic_symbol but this is not done for non-dynamic      symbols, somehow.  */
if|if
condition|(
operator|(
operator|(
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator|&
operator|(
name|ELF_LINK_HASH_DEF_REGULAR
operator||
name|ELF_LINK_HASH_REF_REGULAR
operator||
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|)
operator|==
name|ELF_LINK_HASH_REF_REGULAR
operator|)
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
operator|!
operator|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
condition|)
block|{
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_DEF_REGULAR
expr_stmt|;
block|}
comment|/* If the symbol is dynamic, we'll need all the relocations in their      natural form.  If this is a shared object, and it has been forced      local, we'll need the same number of RELATIVE relocations.  */
if|if
condition|(
name|alpha_elf_dynamic_symbol_p
argument_list|(
operator|&
name|h
operator|->
name|root
argument_list|,
name|info
argument_list|)
operator|||
name|info
operator|->
name|shared
condition|)
block|{
name|struct
name|alpha_elf_reloc_entry
modifier|*
name|relent
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|struct
name|alpha_elf_got_entry
modifier|*
name|gotent
decl_stmt|;
name|bfd_size_type
name|count
decl_stmt|;
name|asection
modifier|*
name|srel
decl_stmt|;
for|for
control|(
name|relent
operator|=
name|h
operator|->
name|reloc_entries
init|;
name|relent
condition|;
name|relent
operator|=
name|relent
operator|->
name|next
control|)
if|if
condition|(
name|relent
operator|->
name|rtype
operator|==
name|R_ALPHA_REFLONG
operator|||
name|relent
operator|->
name|rtype
operator|==
name|R_ALPHA_REFQUAD
condition|)
block|{
name|relent
operator|->
name|srel
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
operator|*
name|relent
operator|->
name|count
expr_stmt|;
block|}
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|gotent
operator|=
name|h
operator|->
name|got_entries
init|;
name|gotent
condition|;
name|gotent
operator|=
name|gotent
operator|->
name|next
control|)
name|count
operator|++
expr_stmt|;
comment|/* If we are using a .plt entry, subtract one, as the first 	 reference uses a .rela.plt entry instead.  */
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|plt
operator|.
name|offset
operator|!=
name|MINUS_ONE
condition|)
name|count
operator|--
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|srel
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|srel
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|srel
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
operator|*
name|count
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Set the sizes of the dynamic sections.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf64_alpha_size_dynamic_sections
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|boolean
name|reltext
decl_stmt|;
name|boolean
name|relplt
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|dynobj
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
comment|/* Set the contents of the .interp section to the interpreter.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".interp"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|=
sizeof|sizeof
name|ELF_DYNAMIC_INTERPRETER
expr_stmt|;
name|s
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ELF_DYNAMIC_INTERPRETER
expr_stmt|;
block|}
comment|/* Now that we've seen all of the input files, we can decide which 	 symbols need dynamic relocation entries and which don't.  We've 	 collected information in check_relocs that we can now apply to 	 size the dynamic relocation sections.  */
name|alpha_elf_link_hash_traverse
argument_list|(
name|alpha_elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|elf64_alpha_calc_dynrel_sizes
argument_list|,
name|info
argument_list|)
expr_stmt|;
comment|/* When building shared libraries, each local .got entry needs a 	 RELATIVE reloc.  */
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
name|bfd
modifier|*
name|i
decl_stmt|;
name|asection
modifier|*
name|srel
decl_stmt|;
name|bfd_size_type
name|count
decl_stmt|;
name|srel
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|srel
operator|!=
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|alpha_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|got_list
operator|,
name|count
operator|=
literal|0
init|;
name|i
operator|!=
name|NULL
condition|;
name|i
operator|=
name|alpha_elf_tdata
argument_list|(
name|i
argument_list|)
operator|->
name|got_link_next
control|)
name|count
operator|+=
name|alpha_elf_tdata
argument_list|(
name|i
argument_list|)
operator|->
name|n_local_got_entries
expr_stmt|;
name|srel
operator|->
name|_raw_size
operator|+=
name|count
operator|*
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* else we're not dynamic and by definition we don't need such things.  */
comment|/* The check_relocs and adjust_dynamic_symbol entry points have      determined the sizes of the various dynamic sections.  Allocate      memory for them.  */
name|reltext
operator|=
name|false
expr_stmt|;
name|relplt
operator|=
name|false
expr_stmt|;
for|for
control|(
name|s
operator|=
name|dynobj
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|boolean
name|strip
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LINKER_CREATED
operator|)
condition|)
continue|continue;
comment|/* It's OK to base decisions on the section name, because none 	 of the dynobj section names depend upon the input files.  */
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* If we don't need this section, strip it from the output file. 	 This is to handle .rela.bss and .rela.plt.  We must create it 	 in create_dynamic_sections, because it must be created before 	 the linker maps input sections to output sections.  The 	 linker does that before adjust_dynamic_symbol is called, and 	 it is that function which decides whether anything needs to 	 go into these sections.  */
name|strip
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".rela"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|strip
operator|=
operator|(
name|s
operator|->
name|_raw_size
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|strip
condition|)
block|{
specifier|const
name|char
modifier|*
name|outname
decl_stmt|;
name|asection
modifier|*
name|target
decl_stmt|;
comment|/* If this relocation section applies to a read only 		 section, then we probably need a DT_TEXTREL entry.  */
name|outname
operator|=
name|bfd_get_section_name
argument_list|(
name|output_bfd
argument_list|,
name|s
operator|->
name|output_section
argument_list|)
expr_stmt|;
name|target
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
name|outname
operator|+
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|!=
name|NULL
operator|&&
operator|(
name|target
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|target
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
name|reltext
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".rela.plt"
argument_list|)
operator|==
literal|0
condition|)
name|relplt
operator|=
name|true
expr_stmt|;
comment|/* We use the reloc_count field as a counter if we need 		 to copy relocs into the output file.  */
name|s
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".plt"
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* It's not one of our dynamic sections, so don't allocate space.  */
continue|continue;
block|}
if|if
condition|(
name|strip
condition|)
name|_bfd_strip_section_from_output
argument_list|(
name|info
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Allocate memory for the section contents.  */
name|s
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|dynobj
argument_list|,
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|contents
operator|==
name|NULL
operator|&&
name|s
operator|->
name|_raw_size
operator|!=
literal|0
condition|)
return|return
name|false
return|;
block|}
block|}
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
comment|/* Add some entries to the .dynamic section.  We fill in the 	 values later, in elf64_alpha_finish_dynamic_sections, but we 	 must add the entries now so that we get the correct size for 	 the .dynamic section.  The DT_DEBUG entry is filled in by the 	 dynamic linker and used by the debugger.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf64_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_DEBUG
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|bfd_elf64_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_PLTGOT
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|relplt
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf64_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_PLTRELSZ
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|bfd_elf64_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_PLTREL
argument_list|,
name|DT_RELA
argument_list|)
operator|||
operator|!
name|bfd_elf64_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_JMPREL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|bfd_elf64_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_RELA
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|bfd_elf64_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_RELASZ
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|bfd_elf64_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_RELAENT
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|reltext
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf64_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_TEXTREL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
name|info
operator|->
name|flags
operator||=
name|DF_TEXTREL
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Relocate an Alpha ELF section.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf64_alpha_relocate_section
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|contents
parameter_list|,
name|relocs
parameter_list|,
name|local_syms
parameter_list|,
name|local_sections
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|local_syms
decl_stmt|;
name|asection
modifier|*
modifier|*
name|local_sections
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relend
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|,
modifier|*
name|sgot
decl_stmt|,
modifier|*
name|srel
decl_stmt|,
modifier|*
name|srelgot
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|,
modifier|*
name|gotobj
decl_stmt|;
name|bfd_vma
name|gp
decl_stmt|;
name|srelgot
operator|=
name|srel
operator|=
name|NULL
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
if|if
condition|(
name|dynobj
condition|)
block|{
name|srelgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
block|}
comment|/* Find the gp value for this input bfd.  */
name|sgot
operator|=
name|NULL
expr_stmt|;
name|gp
operator|=
literal|0
expr_stmt|;
name|gotobj
operator|=
name|alpha_elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|gotobj
expr_stmt|;
if|if
condition|(
name|gotobj
condition|)
block|{
name|sgot
operator|=
name|alpha_elf_tdata
argument_list|(
name|gotobj
argument_list|)
operator|->
name|got
expr_stmt|;
name|gp
operator|=
name|_bfd_get_gp_value
argument_list|(
name|gotobj
argument_list|)
expr_stmt|;
if|if
condition|(
name|gp
operator|==
literal|0
condition|)
block|{
name|gp
operator|=
operator|(
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
literal|0x8000
operator|)
expr_stmt|;
name|_bfd_set_gp_value
argument_list|(
name|gotobj
argument_list|,
name|gp
argument_list|)
expr_stmt|;
block|}
block|}
name|rel
operator|=
name|relocs
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|input_section
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|int
name|r_type
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|struct
name|alpha_elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|;
name|bfd_reloc_status_type
name|r
decl_stmt|;
name|r_type
operator|=
name|ELF64_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|<
literal|0
operator|||
name|r_type
operator|>=
operator|(
name|int
operator|)
name|R_ALPHA_max
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|howto
operator|=
name|elf64_alpha_howto_table
operator|+
name|r_type
expr_stmt|;
name|r_symndx
operator|=
name|ELF64_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|relocateable
condition|)
block|{
comment|/* This is a relocateable link.  We don't have to change 	     anything, unless the reloc is against a section symbol, 	     in which case we have to adjust according to where the 	     section symbol winds up in the output section.  */
comment|/* The symbol associated with GPDISP and LITUSE is 	     immaterial.  Only the addend is significant.  */
if|if
condition|(
name|r_type
operator|==
name|R_ALPHA_GPDISP
operator|||
name|r_type
operator|==
name|R_ALPHA_LITUSE
condition|)
continue|continue;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_SECTION
condition|)
block|{
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|rel
operator|->
name|r_addend
operator|+=
name|sec
operator|->
name|output_offset
operator|+
name|sym
operator|->
name|st_value
expr_stmt|;
block|}
block|}
continue|continue;
block|}
comment|/* This is a final link.  */
name|h
operator|=
name|NULL
expr_stmt|;
name|sym
operator|=
name|NULL
expr_stmt|;
name|sec
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|relocation
operator|=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|sym
operator|->
name|st_value
operator|)
expr_stmt|;
block|}
else|else
block|{
name|h
operator|=
name|alpha_elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|alpha_elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
block|{
name|sec
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
if|#
directive|if
name|rth_notdef
if|if
condition|(
operator|(
name|r_type
operator|==
name|R_ALPHA_LITERAL
operator|&&
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
operator|&&
operator|(
operator|!
name|info
operator|->
name|shared
operator|||
operator|!
name|info
operator|->
name|symbolic
operator|||
operator|!
operator|(
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|)
operator|)
operator|||
operator|(
name|info
operator|->
name|shared
operator|&&
operator|(
operator|!
name|info
operator|->
name|symbolic
operator|||
operator|!
operator|(
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|)
operator|&&
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|&&
operator|(
name|r_type
operator|==
name|R_ALPHA_REFLONG
operator|||
name|r_type
operator|==
name|R_ALPHA_REFQUAD
operator|||
name|r_type
operator|==
name|R_ALPHA_LITERAL
operator|)
operator|)
condition|)
block|{
comment|/* In these cases, we don't need the relocation value. 		     We check specially because in some obscure cases 		     sec->output_section will be NULL.  */
name|relocation
operator|=
literal|0
expr_stmt|;
block|}
else|#
directive|else
comment|/* FIXME: Are not these obscure cases simply bugs?  Let's 		 get something working and come back to this.  */
if|if
condition|(
name|sec
operator|->
name|output_section
operator|==
name|NULL
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* rth_notdef */
else|else
block|{
name|relocation
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
operator|!
name|info
operator|->
name|symbolic
operator|&&
operator|!
name|info
operator|->
name|no_undefined
operator|&&
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|root
operator|.
name|other
argument_list|)
operator|==
name|STV_DEFAULT
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
operator|(
operator|!
name|info
operator|->
name|shared
operator|||
name|info
operator|->
name|no_undefined
operator|||
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|root
operator|.
name|other
argument_list|)
operator|)
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
name|relocation
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|addend
operator|=
name|rel
operator|->
name|r_addend
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_ALPHA_GPDISP
case|:
block|{
name|bfd_byte
modifier|*
name|p_ldah
decl_stmt|,
modifier|*
name|p_lda
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|gp
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|relocation
operator|=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|rel
operator|->
name|r_offset
operator|)
expr_stmt|;
name|p_ldah
operator|=
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|-
name|input_section
operator|->
name|vma
expr_stmt|;
name|p_lda
operator|=
name|p_ldah
operator|+
name|rel
operator|->
name|r_addend
expr_stmt|;
name|r
operator|=
name|elf64_alpha_do_reloc_gpdisp
argument_list|(
name|input_bfd
argument_list|,
name|gp
operator|-
name|relocation
argument_list|,
name|p_ldah
argument_list|,
name|p_lda
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|R_ALPHA_OP_PUSH
case|:
case|case
name|R_ALPHA_OP_STORE
case|:
case|case
name|R_ALPHA_OP_PSUB
case|:
case|case
name|R_ALPHA_OP_PRSHIFT
case|:
comment|/* We hate these silly beasts.  */
name|abort
argument_list|()
expr_stmt|;
case|case
name|R_ALPHA_LITERAL
case|:
block|{
name|struct
name|alpha_elf_got_entry
modifier|*
name|gotent
decl_stmt|;
name|boolean
name|dynamic_symbol
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|gp
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|gotent
operator|=
name|h
operator|->
name|got_entries
expr_stmt|;
name|dynamic_symbol
operator|=
name|alpha_elf_dynamic_symbol_p
argument_list|(
operator|&
name|h
operator|->
name|root
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gotent
operator|=
operator|(
name|alpha_elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|local_got_entries
index|[
name|r_symndx
index|]
operator|)
expr_stmt|;
name|dynamic_symbol
operator|=
name|false
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
name|gotent
operator|!=
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
name|gotent
operator|->
name|gotobj
operator|!=
name|gotobj
operator|||
name|gotent
operator|->
name|addend
operator|!=
name|addend
condition|)
name|gotent
operator|=
name|gotent
operator|->
name|next
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|gotent
operator|->
name|use_count
operator|>=
literal|1
argument_list|)
expr_stmt|;
comment|/* Initialize the .got entry's value.  */
if|if
condition|(
operator|!
operator|(
name|gotent
operator|->
name|flags
operator|&
name|ALPHA_ELF_GOT_ENTRY_RELOCS_DONE
operator|)
condition|)
block|{
name|bfd_put_64
argument_list|(
name|output_bfd
argument_list|,
name|relocation
operator|+
name|addend
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|gotent
operator|->
name|got_offset
argument_list|)
expr_stmt|;
comment|/* If the symbol has been forced local, output a 		   RELATIVE reloc, otherwise it will be handled in 		   finish_dynamic_symbol.  */
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
operator|!
name|dynamic_symbol
condition|)
block|{
name|Elf_Internal_Rela
name|outrel
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|srelgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|=
operator|(
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
name|gotent
operator|->
name|got_offset
operator|)
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_ALPHA_RELATIVE
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
name|bfd_elf64_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
operator|(
operator|(
name|Elf64_External_Rela
operator|*
operator|)
name|srelgot
operator|->
name|contents
operator|)
operator|+
name|srelgot
operator|->
name|reloc_count
operator|++
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
operator|*
name|srelgot
operator|->
name|reloc_count
operator|<=
name|srelgot
operator|->
name|_cooked_size
argument_list|)
expr_stmt|;
block|}
name|gotent
operator|->
name|flags
operator||=
name|ALPHA_ELF_GOT_ENTRY_RELOCS_DONE
expr_stmt|;
block|}
comment|/* Figure the gprel relocation.  */
name|addend
operator|=
literal|0
expr_stmt|;
name|relocation
operator|=
operator|(
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
name|gotent
operator|->
name|got_offset
operator|)
expr_stmt|;
name|relocation
operator|-=
name|gp
expr_stmt|;
block|}
comment|/* overflow handled by _bfd_final_link_relocate */
goto|goto
name|default_reloc
goto|;
case|case
name|R_ALPHA_GPREL32
case|:
case|case
name|R_ALPHA_GPRELLOW
case|:
name|BFD_ASSERT
argument_list|(
name|gp
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|relocation
operator|-=
name|gp
expr_stmt|;
goto|goto
name|default_reloc
goto|;
case|case
name|R_ALPHA_GPRELHIGH
case|:
name|BFD_ASSERT
argument_list|(
name|gp
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|relocation
operator|-=
name|gp
expr_stmt|;
name|relocation
operator|+=
name|addend
expr_stmt|;
name|addend
operator|=
literal|0
expr_stmt|;
name|relocation
operator|=
operator|(
operator|(
operator|(
name|bfd_signed_vma
operator|)
name|relocation
operator|>>
literal|16
operator|)
operator|+
operator|(
operator|(
name|relocation
operator|>>
literal|15
operator|)
operator|&
literal|1
operator|)
operator|)
expr_stmt|;
goto|goto
name|default_reloc
goto|;
case|case
name|R_ALPHA_BRADDR
case|:
case|case
name|R_ALPHA_HINT
case|:
comment|/* The regular PC-relative stuff measures from the start of 	     the instruction rather than the end.  */
name|addend
operator|-=
literal|4
expr_stmt|;
goto|goto
name|default_reloc
goto|;
case|case
name|R_ALPHA_REFLONG
case|:
case|case
name|R_ALPHA_REFQUAD
case|:
block|{
name|Elf_Internal_Rela
name|outrel
decl_stmt|;
name|boolean
name|skip
decl_stmt|;
comment|/* Careful here to remember RELATIVE relocations for global 	       variables for symbolic shared objects.  */
if|if
condition|(
name|h
operator|&&
name|alpha_elf_dynamic_symbol_p
argument_list|(
operator|&
name|h
operator|->
name|root
argument_list|,
name|info
argument_list|)
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|root
operator|.
name|dynindx
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|h
operator|->
name|root
operator|.
name|dynindx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
name|addend
expr_stmt|;
name|addend
operator|=
literal|0
operator|,
name|relocation
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
condition|)
block|{
name|outrel
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_ALPHA_RELATIVE
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
block|}
else|else
goto|goto
name|default_reloc
goto|;
if|if
condition|(
operator|!
name|srel
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
operator|(
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|elf_elfheader
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|e_shstrndx
argument_list|,
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|rel_hdr
operator|.
name|sh_name
argument_list|)
operator|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|srel
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|srel
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
name|skip
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|stab_info
operator|==
name|NULL
condition|)
name|outrel
operator|.
name|r_offset
operator|=
name|rel
operator|->
name|r_offset
expr_stmt|;
else|else
block|{
name|bfd_vma
name|off
decl_stmt|;
name|off
operator|=
operator|(
name|_bfd_stab_section_offset
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|stab_info
argument_list|,
name|input_section
argument_list|,
operator|&
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|stab_info
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|off
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
name|skip
operator|=
name|true
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|=
name|off
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|skip
condition|)
name|outrel
operator|.
name|r_offset
operator|+=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
else|else
name|memset
argument_list|(
operator|&
name|outrel
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|outrel
argument_list|)
expr_stmt|;
name|bfd_elf64_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
operator|(
operator|(
name|Elf64_External_Rela
operator|*
operator|)
name|srel
operator|->
name|contents
operator|)
operator|+
name|srel
operator|->
name|reloc_count
operator|++
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
operator|*
name|srel
operator|->
name|reloc_count
operator|<=
name|srel
operator|->
name|_cooked_size
argument_list|)
expr_stmt|;
block|}
goto|goto
name|default_reloc
goto|;
default|default:
name|default_reloc
label|:
name|r
operator|=
name|_bfd_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|relocation
argument_list|,
name|addend
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|bfd_reloc_ok
case|:
break|break;
case|case
name|bfd_reloc_overflow
case|:
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
else|else
block|{
name|name
operator|=
operator|(
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_link
argument_list|,
name|sym
operator|->
name|st_name
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'\0'
condition|)
name|name
operator|=
name|bfd_section_name
argument_list|(
name|input_bfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|info
argument_list|,
name|name
argument_list|,
name|howto
operator|->
name|name
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
block|}
break|break;
default|default:
case|case
name|bfd_reloc_outofrange
case|:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Finish up dynamic symbol handling.  We set the contents of various    dynamic sections here.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf64_alpha_finish_dynamic_symbol
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|h
parameter_list|,
name|sym
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
block|{
name|bfd
modifier|*
name|dynobj
init|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|!=
name|MINUS_ONE
condition|)
block|{
comment|/* Fill in the .plt entry for this symbol.  */
name|asection
modifier|*
name|splt
decl_stmt|,
modifier|*
name|sgot
decl_stmt|,
modifier|*
name|srel
decl_stmt|;
name|Elf_Internal_Rela
name|outrel
decl_stmt|;
name|bfd_vma
name|got_addr
decl_stmt|,
name|plt_addr
decl_stmt|;
name|bfd_vma
name|plt_index
decl_stmt|;
name|struct
name|alpha_elf_got_entry
modifier|*
name|gotent
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* The first .got entry will be updated by the .plt with the 	 address of the target function.  */
name|gotent
operator|=
operator|(
operator|(
expr|struct
name|alpha_elf_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|got_entries
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|gotent
operator|&&
name|gotent
operator|->
name|addend
operator|==
literal|0
argument_list|)
expr_stmt|;
name|splt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|splt
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|srel
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.plt"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|srel
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|sgot
operator|=
name|alpha_elf_tdata
argument_list|(
name|gotent
operator|->
name|gotobj
argument_list|)
operator|->
name|got
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|got_addr
operator|=
operator|(
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
name|gotent
operator|->
name|got_offset
operator|)
expr_stmt|;
name|plt_addr
operator|=
operator|(
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|splt
operator|->
name|output_offset
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|)
expr_stmt|;
name|plt_index
operator|=
operator|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|-
name|PLT_HEADER_SIZE
operator|)
operator|/
name|PLT_ENTRY_SIZE
expr_stmt|;
comment|/* Fill in the entry in the procedure linkage table.  */
block|{
name|unsigned
name|insn1
decl_stmt|,
name|insn2
decl_stmt|,
name|insn3
decl_stmt|;
name|insn1
operator|=
name|PLT_ENTRY_WORD1
operator||
operator|(
operator|(
operator|-
operator|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
literal|4
operator|)
operator|>>
literal|2
operator|)
operator|&
literal|0x1fffff
operator|)
expr_stmt|;
name|insn2
operator|=
name|PLT_ENTRY_WORD2
expr_stmt|;
name|insn3
operator|=
name|PLT_ENTRY_WORD3
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|insn1
argument_list|,
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|insn2
argument_list|,
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|insn3
argument_list|,
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
literal|8
argument_list|)
expr_stmt|;
block|}
comment|/* Fill in the entry in the .rela.plt section.  */
name|outrel
operator|.
name|r_offset
operator|=
name|got_addr
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_ALPHA_JMP_SLOT
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
name|bfd_elf64_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
operator|(
operator|(
name|Elf64_External_Rela
operator|*
operator|)
name|srel
operator|->
name|contents
operator|+
name|plt_index
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
condition|)
block|{
comment|/* Mark the symbol as undefined, rather than as defined in the 	     .plt section.  Leave the value alone.  */
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_UNDEF
expr_stmt|;
block|}
comment|/* Fill in the entries in the .got.  */
name|bfd_put_64
argument_list|(
name|output_bfd
argument_list|,
name|plt_addr
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|gotent
operator|->
name|got_offset
argument_list|)
expr_stmt|;
comment|/* Subsequent .got entries will continue to bounce through the .plt.  */
if|if
condition|(
name|gotent
operator|->
name|next
condition|)
block|{
name|srel
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
operator|!
name|info
operator|->
name|shared
operator|||
name|srel
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|gotent
operator|=
name|gotent
operator|->
name|next
expr_stmt|;
do|do
block|{
name|sgot
operator|=
name|alpha_elf_tdata
argument_list|(
name|gotent
operator|->
name|gotobj
argument_list|)
operator|->
name|got
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|gotent
operator|->
name|addend
operator|==
literal|0
argument_list|)
expr_stmt|;
name|bfd_put_64
argument_list|(
name|output_bfd
argument_list|,
name|plt_addr
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|gotent
operator|->
name|got_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
name|outrel
operator|.
name|r_offset
operator|=
operator|(
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
name|gotent
operator|->
name|got_offset
operator|)
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_ALPHA_RELATIVE
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
name|bfd_elf64_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
operator|(
operator|(
name|Elf64_External_Rela
operator|*
operator|)
name|srel
operator|->
name|contents
operator|)
operator|+
name|srel
operator|->
name|reloc_count
operator|++
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
operator|*
name|srel
operator|->
name|reloc_count
operator|<=
name|srel
operator|->
name|_cooked_size
argument_list|)
expr_stmt|;
block|}
name|gotent
operator|=
name|gotent
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|gotent
operator|!=
name|NULL
condition|)
do|;
block|}
block|}
elseif|else
if|if
condition|(
name|alpha_elf_dynamic_symbol_p
argument_list|(
name|h
argument_list|,
name|info
argument_list|)
condition|)
block|{
comment|/* Fill in the dynamic relocations for this symbol's .got entries.  */
name|asection
modifier|*
name|srel
decl_stmt|;
name|Elf_Internal_Rela
name|outrel
decl_stmt|;
name|struct
name|alpha_elf_got_entry
modifier|*
name|gotent
decl_stmt|;
name|srel
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|srel
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_ALPHA_GLOB_DAT
argument_list|)
expr_stmt|;
for|for
control|(
name|gotent
operator|=
operator|(
operator|(
expr|struct
name|alpha_elf_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|got_entries
init|;
name|gotent
operator|!=
name|NULL
condition|;
name|gotent
operator|=
name|gotent
operator|->
name|next
control|)
block|{
name|asection
modifier|*
name|sgot
init|=
name|alpha_elf_tdata
argument_list|(
name|gotent
operator|->
name|gotobj
argument_list|)
operator|->
name|got
decl_stmt|;
name|outrel
operator|.
name|r_offset
operator|=
operator|(
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
name|gotent
operator|->
name|got_offset
operator|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
name|gotent
operator|->
name|addend
expr_stmt|;
name|bfd_elf64_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
operator|(
operator|(
name|Elf64_External_Rela
operator|*
operator|)
name|srel
operator|->
name|contents
operator|+
name|srel
operator|->
name|reloc_count
operator|++
operator|)
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
operator|*
name|srel
operator|->
name|reloc_count
operator|<=
name|srel
operator|->
name|_cooked_size
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Mark some specially defined symbols as absolute.  */
if|if
condition|(
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_DYNAMIC"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_PROCEDURE_LINKAGE_TABLE_"
argument_list|)
operator|==
literal|0
condition|)
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_ABS
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Finish up the dynamic sections.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf64_alpha_finish_dynamic_sections
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|sdyn
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|sdyn
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
name|asection
modifier|*
name|splt
decl_stmt|;
name|Elf64_External_Dyn
modifier|*
name|dyncon
decl_stmt|,
modifier|*
name|dynconend
decl_stmt|;
name|splt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|splt
operator|!=
name|NULL
operator|&&
name|sdyn
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dyncon
operator|=
operator|(
name|Elf64_External_Dyn
operator|*
operator|)
name|sdyn
operator|->
name|contents
expr_stmt|;
name|dynconend
operator|=
operator|(
name|Elf64_External_Dyn
operator|*
operator|)
operator|(
name|sdyn
operator|->
name|contents
operator|+
name|sdyn
operator|->
name|_raw_size
operator|)
expr_stmt|;
for|for
control|(
init|;
name|dyncon
operator|<
name|dynconend
condition|;
name|dyncon
operator|++
control|)
block|{
name|Elf_Internal_Dyn
name|dyn
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_elf64_swap_dyn_in
argument_list|(
name|dynobj
argument_list|,
name|dyncon
argument_list|,
operator|&
name|dyn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dyn
operator|.
name|d_tag
condition|)
block|{
case|case
name|DT_PLTGOT
case|:
name|name
operator|=
literal|".plt"
expr_stmt|;
goto|goto
name|get_vma
goto|;
case|case
name|DT_PLTRELSZ
case|:
name|name
operator|=
literal|".rela.plt"
expr_stmt|;
goto|goto
name|get_size
goto|;
case|case
name|DT_JMPREL
case|:
name|name
operator|=
literal|".rela.plt"
expr_stmt|;
goto|goto
name|get_vma
goto|;
case|case
name|DT_RELASZ
case|:
comment|/* My interpretation of the TIS v1.1 ELF document indicates 		 that RELASZ should not include JMPREL.  This is not what 		 the rest of the BFD does.  It is, however, what the 		 glibc ld.so wants.  Do this fixup here until we found 		 out who is right.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
literal|".rela.plt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|-=
operator|(
name|s
operator|->
name|_cooked_size
condition|?
name|s
operator|->
name|_cooked_size
else|:
name|s
operator|->
name|_raw_size
operator|)
expr_stmt|;
block|}
break|break;
name|get_vma
label|:
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
operator|(
name|s
condition|?
name|s
operator|->
name|vma
else|:
literal|0
operator|)
expr_stmt|;
break|break;
name|get_size
label|:
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
operator|(
name|s
operator|->
name|_cooked_size
condition|?
name|s
operator|->
name|_cooked_size
else|:
name|s
operator|->
name|_raw_size
operator|)
expr_stmt|;
break|break;
block|}
name|bfd_elf64_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize the PLT0 entry */
if|if
condition|(
name|splt
operator|->
name|_raw_size
operator|>
literal|0
condition|)
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|PLT_HEADER_WORD1
argument_list|,
name|splt
operator|->
name|contents
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|PLT_HEADER_WORD2
argument_list|,
name|splt
operator|->
name|contents
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|PLT_HEADER_WORD3
argument_list|,
name|splt
operator|->
name|contents
operator|+
literal|8
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|PLT_HEADER_WORD4
argument_list|,
name|splt
operator|->
name|contents
operator|+
literal|12
argument_list|)
expr_stmt|;
comment|/* The next two words will be filled in by ld.so */
name|bfd_put_64
argument_list|(
name|output_bfd
argument_list|,
literal|0
argument_list|,
name|splt
operator|->
name|contents
operator|+
literal|16
argument_list|)
expr_stmt|;
name|bfd_put_64
argument_list|(
name|output_bfd
argument_list|,
literal|0
argument_list|,
name|splt
operator|->
name|contents
operator|+
literal|24
argument_list|)
expr_stmt|;
name|elf_section_data
argument_list|(
name|splt
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
operator|=
name|PLT_HEADER_SIZE
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* We need to use a special link routine to handle the .reginfo and    the .mdebug sections.  We need to merge all instances of these    sections together, not write them all out sequentially.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf64_alpha_final_link
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|asection
modifier|*
name|o
decl_stmt|;
name|struct
name|bfd_link_order
modifier|*
name|p
decl_stmt|;
name|asection
modifier|*
name|reginfo_sec
decl_stmt|,
modifier|*
name|mdebug_sec
decl_stmt|,
modifier|*
name|gptab_data_sec
decl_stmt|,
modifier|*
name|gptab_bss_sec
decl_stmt|;
name|struct
name|ecoff_debug_info
name|debug
decl_stmt|;
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|swap
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_backend_ecoff_debug_swap
decl_stmt|;
name|HDRR
modifier|*
name|symhdr
init|=
operator|&
name|debug
operator|.
name|symbolic_header
decl_stmt|;
name|PTR
name|mdebug_handle
init|=
name|NULL
decl_stmt|;
if|#
directive|if
literal|0
block|if (++ngots == 2) 		{ 		  (*info->callbacks->warning) 		    (info, _("using multiple gp values"), (char *) NULL, 		     output_bfd, (asection *) NULL, (bfd_vma) 0); 		}
endif|#
directive|endif
comment|/* Go through the sections and collect the .reginfo and .mdebug      information.  */
name|reginfo_sec
operator|=
name|NULL
expr_stmt|;
name|mdebug_sec
operator|=
name|NULL
expr_stmt|;
name|gptab_data_sec
operator|=
name|NULL
expr_stmt|;
name|gptab_bss_sec
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
ifdef|#
directive|ifdef
name|ERIC_neverdef
if|if
condition|(
name|strcmp
argument_list|(
name|o
operator|->
name|name
argument_list|,
literal|".reginfo"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|memset
argument_list|(
operator|&
name|reginfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|reginfo
argument_list|)
expr_stmt|;
comment|/* We have found the .reginfo section in the output file. 	     Look through all the link_orders comprising it and merge 	     the information together.  */
for|for
control|(
name|p
operator|=
name|o
operator|->
name|link_order_head
init|;
name|p
operator|!=
operator|(
expr|struct
name|bfd_link_order
operator|*
operator|)
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|Elf64_External_RegInfo
name|ext
decl_stmt|;
name|Elf64_RegInfo
name|sub
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|type
operator|!=
name|bfd_indirect_link_order
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_fill_link_order
condition|)
continue|continue;
name|abort
argument_list|()
expr_stmt|;
block|}
name|input_section
operator|=
name|p
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
expr_stmt|;
name|input_bfd
operator|=
name|input_section
operator|->
name|owner
expr_stmt|;
comment|/* The linker emulation code has probably clobbered the                  size to be zero bytes.  */
if|if
condition|(
name|input_section
operator|->
name|_raw_size
operator|==
literal|0
condition|)
name|input_section
operator|->
name|_raw_size
operator|=
sizeof|sizeof
argument_list|(
name|Elf64_External_RegInfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|ext
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
sizeof|sizeof
name|ext
argument_list|)
condition|)
return|return
name|false
return|;
name|bfd_alpha_elf64_swap_reginfo_in
argument_list|(
name|input_bfd
argument_list|,
operator|&
name|ext
argument_list|,
operator|&
name|sub
argument_list|)
expr_stmt|;
name|reginfo
operator|.
name|ri_gprmask
operator||=
name|sub
operator|.
name|ri_gprmask
expr_stmt|;
name|reginfo
operator|.
name|ri_cprmask
index|[
literal|0
index|]
operator||=
name|sub
operator|.
name|ri_cprmask
index|[
literal|0
index|]
expr_stmt|;
name|reginfo
operator|.
name|ri_cprmask
index|[
literal|1
index|]
operator||=
name|sub
operator|.
name|ri_cprmask
index|[
literal|1
index|]
expr_stmt|;
name|reginfo
operator|.
name|ri_cprmask
index|[
literal|2
index|]
operator||=
name|sub
operator|.
name|ri_cprmask
index|[
literal|2
index|]
expr_stmt|;
name|reginfo
operator|.
name|ri_cprmask
index|[
literal|3
index|]
operator||=
name|sub
operator|.
name|ri_cprmask
index|[
literal|3
index|]
expr_stmt|;
comment|/* ri_gp_value is set by the function 		 alpha_elf_section_processing when the section is 		 finally written out.  */
comment|/* Hack: reset the SEC_HAS_CONTENTS flag so that 		 elf_link_input_bfd ignores this section.  */
name|input_section
operator|->
name|flags
operator|&=
operator|~
name|SEC_HAS_CONTENTS
expr_stmt|;
block|}
comment|/* Force the section size to the value we want.  */
name|o
operator|->
name|_raw_size
operator|=
sizeof|sizeof
argument_list|(
name|Elf64_External_RegInfo
argument_list|)
expr_stmt|;
comment|/* Skip this section later on (I don't think this currently 	     matters, but someday it might).  */
name|o
operator|->
name|link_order_head
operator|=
operator|(
expr|struct
name|bfd_link_order
operator|*
operator|)
name|NULL
expr_stmt|;
name|reginfo_sec
operator|=
name|o
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|strcmp
argument_list|(
name|o
operator|->
name|name
argument_list|,
literal|".mdebug"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|struct
name|extsym_info
name|einfo
decl_stmt|;
comment|/* We have found the .mdebug section in the output file. 	     Look through all the link_orders comprising it and merge 	     the information together.  */
name|symhdr
operator|->
name|magic
operator|=
name|swap
operator|->
name|sym_magic
expr_stmt|;
comment|/* FIXME: What should the version stamp be?  */
name|symhdr
operator|->
name|vstamp
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|ilineMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|cbLine
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|idnMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|ipdMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|isymMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|ioptMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|iauxMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|issMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|issExtMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|ifdMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|crfd
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|iextMax
operator|=
literal|0
expr_stmt|;
comment|/* We accumulate the debugging information itself in the 	     debug_info structure.  */
name|debug
operator|.
name|line
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|external_dnr
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|external_pdr
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|external_sym
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|external_opt
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|external_aux
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|ss
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|ssext
operator|=
name|debug
operator|.
name|ssext_end
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|external_fdr
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|external_rfd
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|external_ext
operator|=
name|debug
operator|.
name|external_ext_end
operator|=
name|NULL
expr_stmt|;
name|mdebug_handle
operator|=
name|bfd_ecoff_debug_init
argument_list|(
name|abfd
argument_list|,
operator|&
name|debug
argument_list|,
name|swap
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|mdebug_handle
operator|==
operator|(
name|PTR
operator|)
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
literal|1
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|EXTR
name|esym
decl_stmt|;
name|bfd_vma
name|last
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|name
index|[]
init|=
block|{
literal|".text"
block|,
literal|".init"
block|,
literal|".fini"
block|,
literal|".data"
block|,
literal|".rodata"
block|,
literal|".sdata"
block|,
literal|".sbss"
block|,
literal|".bss"
block|}
decl_stmt|;
specifier|static
specifier|const
name|int
name|sc
index|[]
init|=
block|{
name|scText
block|,
name|scInit
block|,
name|scFini
block|,
name|scData
block|,
name|scRData
block|,
name|scSData
block|,
name|scSBss
block|,
name|scBss
block|}
decl_stmt|;
name|esym
operator|.
name|jmptbl
operator|=
literal|0
expr_stmt|;
name|esym
operator|.
name|cobol_main
operator|=
literal|0
expr_stmt|;
name|esym
operator|.
name|weakext
operator|=
literal|0
expr_stmt|;
name|esym
operator|.
name|reserved
operator|=
literal|0
expr_stmt|;
name|esym
operator|.
name|ifd
operator|=
name|ifdNil
expr_stmt|;
name|esym
operator|.
name|asym
operator|.
name|iss
operator|=
name|issNil
expr_stmt|;
name|esym
operator|.
name|asym
operator|.
name|st
operator|=
name|stLocal
expr_stmt|;
name|esym
operator|.
name|asym
operator|.
name|reserved
operator|=
literal|0
expr_stmt|;
name|esym
operator|.
name|asym
operator|.
name|index
operator|=
name|indexNil
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|sc
index|[
name|i
index|]
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|name
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
name|s
operator|->
name|vma
expr_stmt|;
name|last
operator|=
name|s
operator|->
name|vma
operator|+
name|s
operator|->
name|_raw_size
expr_stmt|;
block|}
else|else
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
name|last
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_ecoff_debug_one_external
argument_list|(
name|abfd
argument_list|,
operator|&
name|debug
argument_list|,
name|swap
argument_list|,
name|name
index|[
name|i
index|]
argument_list|,
operator|&
name|esym
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
for|for
control|(
name|p
operator|=
name|o
operator|->
name|link_order_head
init|;
name|p
operator|!=
operator|(
expr|struct
name|bfd_link_order
operator|*
operator|)
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|input_swap
decl_stmt|;
name|struct
name|ecoff_debug_info
name|input_debug
decl_stmt|;
name|char
modifier|*
name|eraw_src
decl_stmt|;
name|char
modifier|*
name|eraw_end
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|type
operator|!=
name|bfd_indirect_link_order
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_fill_link_order
condition|)
continue|continue;
name|abort
argument_list|()
expr_stmt|;
block|}
name|input_section
operator|=
name|p
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
expr_stmt|;
name|input_bfd
operator|=
name|input_section
operator|->
name|owner
expr_stmt|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|input_bfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
operator|||
operator|(
name|get_elf_backend_data
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|elf_backend_ecoff_debug_swap
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* I don't know what a non ALPHA ELF bfd would be 		     doing with a .mdebug section, but I don't really 		     want to deal with it.  */
continue|continue;
block|}
name|input_swap
operator|=
operator|(
name|get_elf_backend_data
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|elf_backend_ecoff_debug_swap
operator|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|p
operator|->
name|size
operator|==
name|input_section
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
comment|/* The ECOFF linking code expects that we have already 		 read in the debugging information and set up an 		 ecoff_debug_info structure, so we do that now.  */
if|if
condition|(
operator|!
name|elf64_alpha_read_ecoff_info
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|&
name|input_debug
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
operator|(
name|bfd_ecoff_debug_accumulate
argument_list|(
name|mdebug_handle
argument_list|,
name|abfd
argument_list|,
operator|&
name|debug
argument_list|,
name|swap
argument_list|,
name|input_bfd
argument_list|,
operator|&
name|input_debug
argument_list|,
name|input_swap
argument_list|,
name|info
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
comment|/* Loop through the external symbols.  For each one with 		 interesting information, try to find the symbol in 		 the linker global hash table and save the information 		 for the output external symbols.  */
name|eraw_src
operator|=
name|input_debug
operator|.
name|external_ext
expr_stmt|;
name|eraw_end
operator|=
operator|(
name|eraw_src
operator|+
operator|(
name|input_debug
operator|.
name|symbolic_header
operator|.
name|iextMax
operator|*
name|input_swap
operator|->
name|external_ext_size
operator|)
operator|)
expr_stmt|;
for|for
control|(
init|;
name|eraw_src
operator|<
name|eraw_end
condition|;
name|eraw_src
operator|+=
name|input_swap
operator|->
name|external_ext_size
control|)
block|{
name|EXTR
name|ext
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|alpha_elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
call|(
modifier|*
name|input_swap
operator|->
name|swap_ext_in
call|)
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|PTR
operator|)
name|eraw_src
argument_list|,
operator|&
name|ext
argument_list|)
expr_stmt|;
if|if
condition|(
name|ext
operator|.
name|asym
operator|.
name|sc
operator|==
name|scNil
operator|||
name|ext
operator|.
name|asym
operator|.
name|sc
operator|==
name|scUndefined
operator|||
name|ext
operator|.
name|asym
operator|.
name|sc
operator|==
name|scSUndefined
condition|)
continue|continue;
name|name
operator|=
name|input_debug
operator|.
name|ssext
operator|+
name|ext
operator|.
name|asym
operator|.
name|iss
expr_stmt|;
name|h
operator|=
name|alpha_elf_link_hash_lookup
argument_list|(
name|alpha_elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|name
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
name|h
operator|->
name|esym
operator|.
name|ifd
operator|!=
operator|-
literal|2
condition|)
continue|continue;
if|if
condition|(
name|ext
operator|.
name|ifd
operator|!=
operator|-
literal|1
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|ext
operator|.
name|ifd
operator|<
name|input_debug
operator|.
name|symbolic_header
operator|.
name|ifdMax
argument_list|)
expr_stmt|;
name|ext
operator|.
name|ifd
operator|=
name|input_debug
operator|.
name|ifdmap
index|[
name|ext
operator|.
name|ifd
index|]
expr_stmt|;
block|}
name|h
operator|->
name|esym
operator|=
name|ext
expr_stmt|;
block|}
comment|/* Free up the information we just read.  */
name|free
argument_list|(
name|input_debug
operator|.
name|line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|external_dnr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|external_pdr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|external_sym
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|external_opt
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|external_aux
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|ss
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|ssext
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|external_fdr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|external_rfd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|external_ext
argument_list|)
expr_stmt|;
comment|/* Hack: reset the SEC_HAS_CONTENTS flag so that 		 elf_link_input_bfd ignores this section.  */
name|input_section
operator|->
name|flags
operator|&=
operator|~
name|SEC_HAS_CONTENTS
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ERIC_neverdef
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
comment|/* Create .rtproc section.  */
name|rtproc_sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".rtproc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtproc_sec
operator|==
name|NULL
condition|)
block|{
name|flagword
name|flags
init|=
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_READONLY
operator|)
decl_stmt|;
name|rtproc_sec
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".rtproc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtproc_sec
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|rtproc_sec
argument_list|,
name|flags
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|rtproc_sec
argument_list|,
literal|12
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|alpha_elf_create_procedure_table
argument_list|(
name|mdebug_handle
argument_list|,
name|abfd
argument_list|,
name|info
argument_list|,
name|rtproc_sec
argument_list|,
operator|&
name|debug
argument_list|)
condition|)
return|return
name|false
return|;
block|}
endif|#
directive|endif
comment|/* Build the external symbol information.  */
name|einfo
operator|.
name|abfd
operator|=
name|abfd
expr_stmt|;
name|einfo
operator|.
name|info
operator|=
name|info
expr_stmt|;
name|einfo
operator|.
name|debug
operator|=
operator|&
name|debug
expr_stmt|;
name|einfo
operator|.
name|swap
operator|=
name|swap
expr_stmt|;
name|einfo
operator|.
name|failed
operator|=
name|false
expr_stmt|;
name|elf_link_hash_traverse
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|elf64_alpha_output_extsym
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|einfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|einfo
operator|.
name|failed
condition|)
return|return
name|false
return|;
comment|/* Set the size of the .mdebug section.  */
name|o
operator|->
name|_raw_size
operator|=
name|bfd_ecoff_debug_size
argument_list|(
name|abfd
argument_list|,
operator|&
name|debug
argument_list|,
name|swap
argument_list|)
expr_stmt|;
comment|/* Skip this section later on (I don't think this currently 	     matters, but someday it might).  */
name|o
operator|->
name|link_order_head
operator|=
operator|(
expr|struct
name|bfd_link_order
operator|*
operator|)
name|NULL
expr_stmt|;
name|mdebug_sec
operator|=
name|o
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ERIC_neverdef
if|if
condition|(
name|strncmp
argument_list|(
name|o
operator|->
name|name
argument_list|,
literal|".gptab."
argument_list|,
sizeof|sizeof
expr|".gptab."
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|subname
decl_stmt|;
name|unsigned
name|int
name|c
decl_stmt|;
name|Elf64_gptab
modifier|*
name|tab
decl_stmt|;
name|Elf64_External_gptab
modifier|*
name|ext_tab
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* The .gptab.sdata and .gptab.sbss sections hold 	     information describing how the small data area would 	     change depending upon the -G switch.  These sections 	     not used in executables files.  */
if|if
condition|(
operator|!
name|info
operator|->
name|relocateable
condition|)
block|{
name|asection
modifier|*
modifier|*
name|secpp
decl_stmt|;
for|for
control|(
name|p
operator|=
name|o
operator|->
name|link_order_head
init|;
name|p
operator|!=
operator|(
expr|struct
name|bfd_link_order
operator|*
operator|)
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|asection
modifier|*
name|input_section
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|type
operator|!=
name|bfd_indirect_link_order
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_fill_link_order
condition|)
continue|continue;
name|abort
argument_list|()
expr_stmt|;
block|}
name|input_section
operator|=
name|p
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
expr_stmt|;
comment|/* Hack: reset the SEC_HAS_CONTENTS flag so that 		     elf_link_input_bfd ignores this section.  */
name|input_section
operator|->
name|flags
operator|&=
operator|~
name|SEC_HAS_CONTENTS
expr_stmt|;
block|}
comment|/* Skip this section later on (I don't think this 		 currently matters, but someday it might).  */
name|o
operator|->
name|link_order_head
operator|=
operator|(
expr|struct
name|bfd_link_order
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* Really remove the section.  */
for|for
control|(
name|secpp
operator|=
operator|&
name|abfd
operator|->
name|sections
init|;
operator|*
name|secpp
operator|!=
name|o
condition|;
name|secpp
operator|=
operator|&
operator|(
operator|*
name|secpp
operator|)
operator|->
name|next
control|)
empty_stmt|;
operator|*
name|secpp
operator|=
operator|(
operator|*
name|secpp
operator|)
operator|->
name|next
expr_stmt|;
operator|--
name|abfd
operator|->
name|section_count
expr_stmt|;
continue|continue;
block|}
comment|/* There is one gptab for initialized data, and one for 	     uninitialized data.  */
if|if
condition|(
name|strcmp
argument_list|(
name|o
operator|->
name|name
argument_list|,
literal|".gptab.sdata"
argument_list|)
operator|==
literal|0
condition|)
name|gptab_data_sec
operator|=
name|o
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|o
operator|->
name|name
argument_list|,
literal|".gptab.sbss"
argument_list|)
operator|==
literal|0
condition|)
name|gptab_bss_sec
operator|=
name|o
expr_stmt|;
else|else
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: illegal section name `%s'"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|o
operator|->
name|name
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_nonrepresentable_section
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* The linker script always combines .gptab.data and 	     .gptab.sdata into .gptab.sdata, and likewise for 	     .gptab.bss and .gptab.sbss.  It is possible that there is 	     no .sdata or .sbss section in the output file, in which 	     case we must change the name of the output section.  */
name|subname
operator|=
name|o
operator|->
name|name
operator|+
sizeof|sizeof
expr|".gptab"
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|subname
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|o
operator|==
name|gptab_data_sec
condition|)
name|o
operator|->
name|name
operator|=
literal|".gptab.data"
expr_stmt|;
else|else
name|o
operator|->
name|name
operator|=
literal|".gptab.bss"
expr_stmt|;
name|subname
operator|=
name|o
operator|->
name|name
operator|+
sizeof|sizeof
expr|".gptab"
operator|-
literal|1
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|subname
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Set up the first entry.  */
name|c
operator|=
literal|1
expr_stmt|;
name|tab
operator|=
operator|(
name|Elf64_gptab
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|c
operator|*
sizeof|sizeof
argument_list|(
name|Elf64_gptab
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tab
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|tab
index|[
literal|0
index|]
operator|.
name|gt_header
operator|.
name|gt_current_g_value
operator|=
name|elf_gp_size
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|tab
index|[
literal|0
index|]
operator|.
name|gt_header
operator|.
name|gt_unused
operator|=
literal|0
expr_stmt|;
comment|/* Combine the input sections.  */
for|for
control|(
name|p
operator|=
name|o
operator|->
name|link_order_head
init|;
name|p
operator|!=
operator|(
expr|struct
name|bfd_link_order
operator|*
operator|)
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
name|unsigned
name|long
name|last
decl_stmt|;
name|bfd_size_type
name|gpentry
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|type
operator|!=
name|bfd_indirect_link_order
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_fill_link_order
condition|)
continue|continue;
name|abort
argument_list|()
expr_stmt|;
block|}
name|input_section
operator|=
name|p
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
expr_stmt|;
name|input_bfd
operator|=
name|input_section
operator|->
name|owner
expr_stmt|;
comment|/* Combine the gptab entries for this input section one 		 by one.  We know that the input gptab entries are 		 sorted by ascending -G value.  */
name|size
operator|=
name|bfd_section_size
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
expr_stmt|;
name|last
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|gpentry
operator|=
sizeof|sizeof
argument_list|(
name|Elf64_External_gptab
argument_list|)
init|;
name|gpentry
operator|<
name|size
condition|;
name|gpentry
operator|+=
sizeof|sizeof
argument_list|(
name|Elf64_External_gptab
argument_list|)
control|)
block|{
name|Elf64_External_gptab
name|ext_gptab
decl_stmt|;
name|Elf64_gptab
name|int_gptab
decl_stmt|;
name|unsigned
name|long
name|val
decl_stmt|;
name|unsigned
name|long
name|add
decl_stmt|;
name|boolean
name|exact
decl_stmt|;
name|unsigned
name|int
name|look
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|bfd_get_section_contents
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|ext_gptab
argument_list|,
name|gpentry
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf64_External_gptab
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|free
argument_list|(
name|tab
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|bfd_alpha_elf64_swap_gptab_in
argument_list|(
name|input_bfd
argument_list|,
operator|&
name|ext_gptab
argument_list|,
operator|&
name|int_gptab
argument_list|)
expr_stmt|;
name|val
operator|=
name|int_gptab
operator|.
name|gt_entry
operator|.
name|gt_g_value
expr_stmt|;
name|add
operator|=
name|int_gptab
operator|.
name|gt_entry
operator|.
name|gt_bytes
operator|-
name|last
expr_stmt|;
name|exact
operator|=
name|false
expr_stmt|;
for|for
control|(
name|look
operator|=
literal|1
init|;
name|look
operator|<
name|c
condition|;
name|look
operator|++
control|)
block|{
if|if
condition|(
name|tab
index|[
name|look
index|]
operator|.
name|gt_entry
operator|.
name|gt_g_value
operator|>=
name|val
condition|)
name|tab
index|[
name|look
index|]
operator|.
name|gt_entry
operator|.
name|gt_bytes
operator|+=
name|add
expr_stmt|;
if|if
condition|(
name|tab
index|[
name|look
index|]
operator|.
name|gt_entry
operator|.
name|gt_g_value
operator|==
name|val
condition|)
name|exact
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|exact
condition|)
block|{
name|Elf64_gptab
modifier|*
name|new_tab
decl_stmt|;
name|unsigned
name|int
name|max
decl_stmt|;
comment|/* We need a new table entry.  */
name|new_tab
operator|=
operator|(
operator|(
name|Elf64_gptab
operator|*
operator|)
name|bfd_realloc
argument_list|(
operator|(
name|PTR
operator|)
name|tab
argument_list|,
operator|(
name|c
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|Elf64_gptab
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|new_tab
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|tab
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|tab
operator|=
name|new_tab
expr_stmt|;
name|tab
index|[
name|c
index|]
operator|.
name|gt_entry
operator|.
name|gt_g_value
operator|=
name|val
expr_stmt|;
name|tab
index|[
name|c
index|]
operator|.
name|gt_entry
operator|.
name|gt_bytes
operator|=
name|add
expr_stmt|;
comment|/* Merge in the size for the next smallest -G 			 value, since that will be implied by this new 			 value.  */
name|max
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|look
operator|=
literal|1
init|;
name|look
operator|<
name|c
condition|;
name|look
operator|++
control|)
block|{
if|if
condition|(
name|tab
index|[
name|look
index|]
operator|.
name|gt_entry
operator|.
name|gt_g_value
operator|<
name|val
operator|&&
operator|(
name|max
operator|==
literal|0
operator|||
operator|(
name|tab
index|[
name|look
index|]
operator|.
name|gt_entry
operator|.
name|gt_g_value
operator|>
name|tab
index|[
name|max
index|]
operator|.
name|gt_entry
operator|.
name|gt_g_value
operator|)
operator|)
condition|)
name|max
operator|=
name|look
expr_stmt|;
block|}
if|if
condition|(
name|max
operator|!=
literal|0
condition|)
name|tab
index|[
name|c
index|]
operator|.
name|gt_entry
operator|.
name|gt_bytes
operator|+=
name|tab
index|[
name|max
index|]
operator|.
name|gt_entry
operator|.
name|gt_bytes
expr_stmt|;
operator|++
name|c
expr_stmt|;
block|}
name|last
operator|=
name|int_gptab
operator|.
name|gt_entry
operator|.
name|gt_bytes
expr_stmt|;
block|}
comment|/* Hack: reset the SEC_HAS_CONTENTS flag so that 		 elf_link_input_bfd ignores this section.  */
name|input_section
operator|->
name|flags
operator|&=
operator|~
name|SEC_HAS_CONTENTS
expr_stmt|;
block|}
comment|/* The table must be sorted by -G value.  */
if|if
condition|(
name|c
operator|>
literal|2
condition|)
name|qsort
argument_list|(
name|tab
operator|+
literal|1
argument_list|,
name|c
operator|-
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|tab
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|gptab_compare
argument_list|)
expr_stmt|;
comment|/* Swap out the table.  */
name|ext_tab
operator|=
operator|(
operator|(
name|Elf64_External_gptab
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|c
operator|*
sizeof|sizeof
argument_list|(
name|Elf64_External_gptab
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ext_tab
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|tab
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|c
condition|;
name|i
operator|++
control|)
name|bfd_alpha_elf64_swap_gptab_out
argument_list|(
name|abfd
argument_list|,
name|tab
operator|+
name|i
argument_list|,
name|ext_tab
operator|+
name|i
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tab
argument_list|)
expr_stmt|;
name|o
operator|->
name|_raw_size
operator|=
name|c
operator|*
sizeof|sizeof
argument_list|(
name|Elf64_External_gptab
argument_list|)
expr_stmt|;
name|o
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|ext_tab
expr_stmt|;
comment|/* Skip this section later on (I don't think this currently 	     matters, but someday it might).  */
name|o
operator|->
name|link_order_head
operator|=
operator|(
expr|struct
name|bfd_link_order
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
block|}
comment|/* Invoke the regular ELF backend linker to do all the work.  */
if|if
condition|(
operator|!
name|bfd_elf64_bfd_final_link
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Now write out the computed sections.  */
comment|/* The .got subsections...  */
block|{
name|bfd
modifier|*
name|i
decl_stmt|,
modifier|*
name|dynobj
init|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
decl_stmt|;
for|for
control|(
name|i
operator|=
name|alpha_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|got_list
init|;
name|i
operator|!=
name|NULL
condition|;
name|i
operator|=
name|alpha_elf_tdata
argument_list|(
name|i
argument_list|)
operator|->
name|got_link_next
control|)
block|{
name|asection
modifier|*
name|sgot
decl_stmt|;
comment|/* elf_bfd_final_link already did everything in dynobj.  */
if|if
condition|(
name|i
operator|==
name|dynobj
condition|)
continue|continue;
name|sgot
operator|=
name|alpha_elf_tdata
argument_list|(
name|i
argument_list|)
operator|->
name|got
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|sgot
operator|->
name|output_section
argument_list|,
name|sgot
operator|->
name|contents
argument_list|,
name|sgot
operator|->
name|output_offset
argument_list|,
name|sgot
operator|->
name|_raw_size
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
ifdef|#
directive|ifdef
name|ERIC_neverdef
if|if
condition|(
name|reginfo_sec
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
block|{
name|Elf64_External_RegInfo
name|ext
decl_stmt|;
name|bfd_alpha_elf64_swap_reginfo_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|reginfo
argument_list|,
operator|&
name|ext
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|reginfo_sec
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|ext
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
sizeof|sizeof
name|ext
argument_list|)
condition|)
return|return
name|false
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|mdebug_sec
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|abfd
operator|->
name|output_has_begun
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_ecoff_write_accumulated_debug
argument_list|(
name|mdebug_handle
argument_list|,
name|abfd
argument_list|,
operator|&
name|debug
argument_list|,
name|swap
argument_list|,
name|info
argument_list|,
name|mdebug_sec
operator|->
name|filepos
argument_list|)
condition|)
return|return
name|false
return|;
name|bfd_ecoff_debug_free
argument_list|(
name|mdebug_handle
argument_list|,
name|abfd
argument_list|,
operator|&
name|debug
argument_list|,
name|swap
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gptab_data_sec
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|gptab_data_sec
argument_list|,
name|gptab_data_sec
operator|->
name|contents
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|gptab_data_sec
operator|->
name|_raw_size
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|gptab_bss_sec
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|gptab_bss_sec
argument_list|,
name|gptab_bss_sec
operator|->
name|contents
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|gptab_bss_sec
operator|->
name|_raw_size
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ECOFF swapping routines.  These are used when dealing with the    .mdebug section, which is in the ECOFF debugging format.  Copied    from elf32-mips.c.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ecoff_debug_swap
name|elf64_alpha_ecoff_debug_swap
init|=
block|{
comment|/* Symbol table magic number.  */
name|magicSym2
block|,
comment|/* Alignment of debugging information.  E.g., 4.  */
literal|8
block|,
comment|/* Sizes of external symbolic information.  */
sizeof|sizeof
argument_list|(
expr|struct
name|hdr_ext
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|dnr_ext
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|pdr_ext
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|sym_ext
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|opt_ext
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|fdr_ext
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|rfd_ext
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ext_ext
argument_list|)
block|,
comment|/* Functions to swap in external symbolic data.  */
name|ecoff_swap_hdr_in
block|,
name|ecoff_swap_dnr_in
block|,
name|ecoff_swap_pdr_in
block|,
name|ecoff_swap_sym_in
block|,
name|ecoff_swap_opt_in
block|,
name|ecoff_swap_fdr_in
block|,
name|ecoff_swap_rfd_in
block|,
name|ecoff_swap_ext_in
block|,
name|_bfd_ecoff_swap_tir_in
block|,
name|_bfd_ecoff_swap_rndx_in
block|,
comment|/* Functions to swap out external symbolic data.  */
name|ecoff_swap_hdr_out
block|,
name|ecoff_swap_dnr_out
block|,
name|ecoff_swap_pdr_out
block|,
name|ecoff_swap_sym_out
block|,
name|ecoff_swap_opt_out
block|,
name|ecoff_swap_fdr_out
block|,
name|ecoff_swap_rfd_out
block|,
name|ecoff_swap_ext_out
block|,
name|_bfd_ecoff_swap_tir_out
block|,
name|_bfd_ecoff_swap_rndx_out
block|,
comment|/* Function to read in symbolic data.  */
name|elf64_alpha_read_ecoff_info
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Use a non-standard hash bucket size of 8.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|elf_size_info
name|alpha_elf_size_info
init|=
block|{
sizeof|sizeof
argument_list|(
name|Elf64_External_Ehdr
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|Elf64_External_Phdr
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|Elf64_External_Shdr
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|Elf64_External_Rel
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|Elf64_External_Sym
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|Elf64_External_Dyn
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|Elf_External_Note
argument_list|)
block|,
literal|8
block|,
literal|1
block|,
literal|64
block|,
literal|8
block|,
name|ELFCLASS64
block|,
name|EV_CURRENT
block|,
name|bfd_elf64_write_out_phdrs
block|,
name|bfd_elf64_write_shdrs_and_ehdr
block|,
name|bfd_elf64_write_relocs
block|,
name|bfd_elf64_swap_symbol_out
block|,
name|bfd_elf64_slurp_reloc_table
block|,
name|bfd_elf64_slurp_symbol_table
block|,
name|bfd_elf64_swap_dyn_in
block|,
name|bfd_elf64_swap_dyn_out
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TARGET_LITTLE_SYM
value|bfd_elf64_alpha_vec
end_define

begin_define
define|#
directive|define
name|TARGET_LITTLE_NAME
value|"elf64-alpha"
end_define

begin_define
define|#
directive|define
name|ELF_ARCH
value|bfd_arch_alpha
end_define

begin_define
define|#
directive|define
name|ELF_MACHINE_CODE
value|EM_ALPHA
end_define

begin_define
define|#
directive|define
name|ELF_MAXPAGESIZE
value|0x10000
end_define

begin_define
define|#
directive|define
name|bfd_elf64_bfd_link_hash_table_create
define|\
value|elf64_alpha_bfd_link_hash_table_create
end_define

begin_define
define|#
directive|define
name|bfd_elf64_bfd_reloc_type_lookup
define|\
value|elf64_alpha_bfd_reloc_type_lookup
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto
define|\
value|elf64_alpha_info_to_howto
end_define

begin_define
define|#
directive|define
name|bfd_elf64_mkobject
define|\
value|elf64_alpha_mkobject
end_define

begin_define
define|#
directive|define
name|elf_backend_object_p
define|\
value|elf64_alpha_object_p
end_define

begin_define
define|#
directive|define
name|elf_backend_section_from_shdr
define|\
value|elf64_alpha_section_from_shdr
end_define

begin_define
define|#
directive|define
name|elf_backend_fake_sections
define|\
value|elf64_alpha_fake_sections
end_define

begin_define
define|#
directive|define
name|bfd_elf64_bfd_is_local_label_name
define|\
value|elf64_alpha_is_local_label_name
end_define

begin_define
define|#
directive|define
name|bfd_elf64_find_nearest_line
define|\
value|elf64_alpha_find_nearest_line
end_define

begin_define
define|#
directive|define
name|bfd_elf64_bfd_relax_section
define|\
value|elf64_alpha_relax_section
end_define

begin_define
define|#
directive|define
name|elf_backend_add_symbol_hook
define|\
value|elf64_alpha_add_symbol_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_check_relocs
define|\
value|elf64_alpha_check_relocs
end_define

begin_define
define|#
directive|define
name|elf_backend_create_dynamic_sections
define|\
value|elf64_alpha_create_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_adjust_dynamic_symbol
define|\
value|elf64_alpha_adjust_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_always_size_sections
define|\
value|elf64_alpha_always_size_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_size_dynamic_sections
define|\
value|elf64_alpha_size_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_relocate_section
define|\
value|elf64_alpha_relocate_section
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_symbol
define|\
value|elf64_alpha_finish_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_sections
define|\
value|elf64_alpha_finish_dynamic_sections
end_define

begin_define
define|#
directive|define
name|bfd_elf64_bfd_final_link
define|\
value|elf64_alpha_final_link
end_define

begin_define
define|#
directive|define
name|elf_backend_ecoff_debug_swap
define|\
value|&elf64_alpha_ecoff_debug_swap
end_define

begin_define
define|#
directive|define
name|elf_backend_size_info
define|\
value|alpha_elf_size_info
end_define

begin_comment
comment|/* A few constants that determine how the .plt section is set up.  */
end_comment

begin_define
define|#
directive|define
name|elf_backend_want_got_plt
value|0
end_define

begin_define
define|#
directive|define
name|elf_backend_plt_readonly
value|0
end_define

begin_define
define|#
directive|define
name|elf_backend_want_plt_sym
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_got_header_size
value|0
end_define

begin_define
define|#
directive|define
name|elf_backend_plt_header_size
value|PLT_HEADER_SIZE
end_define

begin_include
include|#
directive|include
file|"elf64-target.h"
end_include

end_unit

