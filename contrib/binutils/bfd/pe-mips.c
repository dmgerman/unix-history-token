begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD back-end for MIPS PE COFF files.    Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,    2000, 2001 Free Software Foundation, Inc.    Modified from coff-i386.c by DJ Delorie, dj@cygnus.com  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_define
define|#
directive|define
name|COFF_WITH_PE
end_define

begin_define
define|#
directive|define
name|COFF_LONG_SECTION_NAMES
end_define

begin_define
define|#
directive|define
name|PCRELOFFSET
value|true
end_define

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"coff/mipspe.h"
end_include

begin_include
include|#
directive|include
file|"coff/internal.h"
end_include

begin_include
include|#
directive|include
file|"coff/pe.h"
end_include

begin_include
include|#
directive|include
file|"libcoff.h"
end_include

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|coff_mips_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
modifier|*
name|coff_mips_rtype_to_howto
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
expr|struct
name|internal_reloc
operator|*
operator|,
expr|struct
name|coff_link_hash_entry
operator|*
operator|,
expr|struct
name|internal_syment
operator|*
operator|,
name|bfd_vma
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void mips_ecoff_swap_reloc_in PARAMS ((bfd *, PTR, 					      struct internal_reloc *)); static void mips_ecoff_swap_reloc_out PARAMS ((bfd *, 					       const struct internal_reloc *, 					       PTR)); static void mips_adjust_reloc_in PARAMS ((bfd *, 					  const struct internal_reloc *, 					  arelent *)); static void mips_adjust_reloc_out PARAMS ((bfd *, const arelent *, 					   struct internal_reloc *));
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|boolean
name|in_reloc_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|reloc_howto_type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
modifier|*
name|coff_mips_reloc_type_lookup
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd_reloc_code_real_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mips_swap_reloc_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|mips_swap_reloc_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|coff_pe_mips_relocate_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
expr|struct
name|internal_reloc
operator|*
operator|,
expr|struct
name|internal_syment
operator|*
operator|,
name|asection
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|COFF_DEFAULT_SECTION_ALIGNMENT_POWER
value|(2)
end_define

begin_comment
comment|/* The page size is a guess based on ELF.  */
end_comment

begin_define
define|#
directive|define
name|COFF_PAGE_SIZE
value|0x1000
end_define

begin_comment
comment|/* For some reason when using mips COFF the value stored in the .text    section for a reference to a common symbol is the value itself plus    any desired offset.  Ian Taylor, Cygnus Support.  */
end_comment

begin_comment
comment|/* If we are producing relocateable output, we need to do some    adjustments to the object file that are not done by the    bfd_perform_relocation function.  This function is called by every    reloc type to make any required adjustments.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|coff_mips_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|symvalue
name|diff
decl_stmt|;
if|if
condition|(
name|output_bfd
operator|==
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
return|return
name|bfd_reloc_continue
return|;
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|COFF_WITH_PE
comment|/* We are relocating a common symbol.  The current value in the 	 object file is ORIG + OFFSET, where ORIG is the value of the 	 common symbol as seen by the object file when it was compiled 	 (this may be zero if the symbol was undefined) and OFFSET is 	 the offset into the common symbol (normally zero, but may be 	 non-zero when referring to a field in a common structure). 	 ORIG is the negative of reloc_entry->addend, which is set by 	 the CALC_ADDEND macro below.  We want to replace the value in 	 the object file with NEW + OFFSET, where NEW is the value of 	 the common symbol which we are going to put in the final 	 object file.  NEW is symbol->value.  */
name|diff
operator|=
name|symbol
operator|->
name|value
operator|+
name|reloc_entry
operator|->
name|addend
expr_stmt|;
else|#
directive|else
comment|/* In PE mode, we do not offset the common symbol.  */
name|diff
operator|=
name|reloc_entry
operator|->
name|addend
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* For some reason bfd_perform_relocation always effectively 	 ignores the addend for a COFF target when producing 	 relocateable output.  This seems to be always wrong for 386 	 COFF, so we handle the addend here instead.  */
name|diff
operator|=
name|reloc_entry
operator|->
name|addend
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|COFF_WITH_PE
if|#
directive|if
literal|0
comment|/* dj - handle it like any other reloc? */
comment|/* FIXME: How should this case be handled?  */
block|if (reloc_entry->howto->type == MIPS_R_RVA&& diff != 0)     abort ();
endif|#
directive|endif
endif|#
directive|endif
define|#
directive|define
name|DOIT
parameter_list|(
name|x
parameter_list|)
define|\
value|x = ((x& ~howto->dst_mask) | (((x& howto->src_mask) + (diff>> howto->rightshift))& howto->dst_mask))
if|if
condition|(
name|diff
operator|!=
literal|0
condition|)
block|{
name|reloc_howto_type
modifier|*
name|howto
init|=
name|reloc_entry
operator|->
name|howto
decl_stmt|;
name|unsigned
name|char
modifier|*
name|addr
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
decl_stmt|;
switch|switch
condition|(
name|howto
operator|->
name|size
condition|)
block|{
case|case
literal|0
case|:
block|{
name|char
name|x
init|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|addr
argument_list|)
decl_stmt|;
name|DOIT
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|x
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|1
case|:
block|{
name|short
name|x
init|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|addr
argument_list|)
decl_stmt|;
name|DOIT
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|x
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
block|{
name|long
name|x
init|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|addr
argument_list|)
decl_stmt|;
name|DOIT
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|x
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Now let bfd_perform_relocation finish everything up.  */
return|return
name|bfd_reloc_continue
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|COFF_WITH_PE
end_ifdef

begin_comment
comment|/* Return true if this relocation should    appear in the output .reloc section.  */
end_comment

begin_function
specifier|static
name|boolean
name|in_reloc_p
parameter_list|(
name|abfd
parameter_list|,
name|howto
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
block|{
return|return
operator|!
name|howto
operator|->
name|pc_relative
operator|&&
name|howto
operator|->
name|type
operator|!=
name|MIPS_R_RVA
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PCRELOFFSET
end_ifndef

begin_define
define|#
directive|define
name|PCRELOFFSET
value|false
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|howto_table
index|[]
init|=
block|{
comment|/* Reloc type 0 is ignored.  The reloc reading code ensures that      this is a reference to the .abs section, which will cause      bfd_perform_relocation to do nothing.  */
name|HOWTO
argument_list|(
name|MIPS_R_ABSOLUTE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
literal|0
argument_list|,
comment|/* special_function */
literal|"IGNORE"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 16 bit reference to a symbol, normally from a data section.  */
name|HOWTO
argument_list|(
name|MIPS_R_REFHALF
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|coff_mips_reloc
argument_list|,
comment|/* special_function */
literal|"REFHALF"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 32 bit reference to a symbol, normally from a data section.  */
name|HOWTO
argument_list|(
name|MIPS_R_REFWORD
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|coff_mips_reloc
argument_list|,
comment|/* special_function */
literal|"REFWORD"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 26 bit absolute jump address.  */
name|HOWTO
argument_list|(
name|MIPS_R_JMPADDR
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|26
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
comment|/* This needs complex overflow 				   detection, because the upper four 				   bits must match the PC.  */
name|coff_mips_reloc
argument_list|,
comment|/* special_function */
literal|"JMPADDR"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0x3ffffff
argument_list|,
comment|/* src_mask */
literal|0x3ffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The high 16 bits of a symbol value.  Handled by the function      mips_refhi_reloc.  */
name|HOWTO
argument_list|(
name|MIPS_R_REFHI
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|coff_mips_reloc
argument_list|,
comment|/* special_function */
literal|"REFHI"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The low 16 bits of a symbol value.  */
name|HOWTO
argument_list|(
name|MIPS_R_REFLO
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|coff_mips_reloc
argument_list|,
comment|/* special_function */
literal|"REFLO"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A reference to an offset from the gp register.  Handled by the      function mips_gprel_reloc.  */
name|HOWTO
argument_list|(
name|MIPS_R_GPREL
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|coff_mips_reloc
argument_list|,
comment|/* special_function */
literal|"GPREL"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A reference to a literal using an offset from the gp register.      Handled by the function mips_gprel_reloc.  */
name|HOWTO
argument_list|(
name|MIPS_R_LITERAL
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|coff_mips_reloc
argument_list|,
comment|/* special_function */
literal|"LITERAL"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
name|EMPTY_HOWTO
argument_list|(
literal|8
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|9
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|10
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|11
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|12
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|13
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|14
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|15
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|16
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|17
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|18
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|19
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|20
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|21
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|22
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|23
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|24
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|25
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|26
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|27
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|28
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|29
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|30
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|31
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|32
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|33
argument_list|)
block|,
name|HOWTO
argument_list|(
name|MIPS_R_RVA
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|coff_mips_reloc
argument_list|,
comment|/* special_function */
literal|"rva32"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
name|EMPTY_HOWTO
argument_list|(
literal|35
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|36
argument_list|)
block|,
name|HOWTO
argument_list|(
name|MIPS_R_PAIR
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|coff_mips_reloc
argument_list|,
comment|/* special_function */
literal|"PAIR"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Turn a howto into a reloc  nunmber */
end_comment

begin_define
define|#
directive|define
name|SELECT_RELOC
parameter_list|(
name|x
parameter_list|,
name|howto
parameter_list|)
value|{ x.r_type = howto->type; }
end_define

begin_define
define|#
directive|define
name|BADMAG
parameter_list|(
name|x
parameter_list|)
value|MIPSBADMAG(x)
end_define

begin_define
define|#
directive|define
name|MIPS
value|1
end_define

begin_comment
comment|/* Customize coffcode.h */
end_comment

begin_define
define|#
directive|define
name|RTYPE2HOWTO
parameter_list|(
name|cache_ptr
parameter_list|,
name|dst
parameter_list|)
define|\
value|(cache_ptr)->howto = howto_table + (dst)->r_type;
end_define

begin_comment
comment|/* Compute the addend of a reloc.  If the reloc is to a common symbol,    the object file contains the value of the common symbol.  By the    time this is called, the linker may be using a different symbol    from a different object file with a different value.  Therefore, we    hack wildly to locate the original symbol from this file so that we    can make the correct adjustment.  This macro sets coffsym to the    symbol from the original file, and uses it to set the addend value    correctly.  If this is not a common symbol, the usual addend    calculation is done, except that an additional tweak is needed for    PC relative relocs.    FIXME: This macro refers to symbols and asect; these are from the    calling function, not the macro arguments.  */
end_comment

begin_define
define|#
directive|define
name|CALC_ADDEND
parameter_list|(
name|abfd
parameter_list|,
name|ptr
parameter_list|,
name|reloc
parameter_list|,
name|cache_ptr
parameter_list|)
define|\
value|{								\     coff_symbol_type *coffsym = (coff_symbol_type *) NULL;	\     if (ptr&& bfd_asymbol_bfd (ptr) != abfd)			\       coffsym = (obj_symbols (abfd)				\ 	         + (cache_ptr->sym_ptr_ptr - symbols));		\     else if (ptr)						\       coffsym = coff_symbol_from (abfd, ptr);			\     if (coffsym != (coff_symbol_type *) NULL			\&& coffsym->native->u.syment.n_scnum == 0)		\       cache_ptr->addend = - coffsym->native->u.syment.n_value;	\     else if (ptr&& bfd_asymbol_bfd (ptr) == abfd		\&& ptr->section != (asection *) NULL)		\       cache_ptr->addend = - (ptr->section->vma + ptr->value);	\     else							\       cache_ptr->addend = 0;					\     if (ptr&& howto_table[reloc.r_type].pc_relative)		\       cache_ptr->addend += asect->vma;				\   }
end_define

begin_comment
comment|/* Convert an rtype to howto for the COFF backend linker.  */
end_comment

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|coff_mips_rtype_to_howto
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|rel
parameter_list|,
name|h
parameter_list|,
name|sym
parameter_list|,
name|addendp
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|rel
decl_stmt|;
name|struct
name|coff_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|internal_syment
modifier|*
name|sym
decl_stmt|;
name|bfd_vma
modifier|*
name|addendp
decl_stmt|;
block|{
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|howto
operator|=
name|howto_table
operator|+
name|rel
operator|->
name|r_type
expr_stmt|;
ifdef|#
directive|ifdef
name|COFF_WITH_PE
operator|*
name|addendp
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|howto
operator|->
name|pc_relative
condition|)
operator|*
name|addendp
operator|+=
name|sec
operator|->
name|vma
expr_stmt|;
if|if
condition|(
name|sym
operator|!=
name|NULL
operator|&&
name|sym
operator|->
name|n_scnum
operator|==
literal|0
operator|&&
name|sym
operator|->
name|n_value
operator|!=
literal|0
condition|)
block|{
comment|/* This is a common symbol.  The section contents include the 	 size (sym->n_value) as an addend.  The relocate_section 	 function will be adding in the final value of the symbol.  We 	 need to subtract out the current size in order to get the 	 correct result.  */
name|BFD_ASSERT
argument_list|(
name|h
operator|!=
name|NULL
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|COFF_WITH_PE
comment|/* I think we *do* want to bypass this.  If we don't, I have 	 seen some data parameters get the wrong relocation address. 	 If I link two versions with and without this section bypassed 	 and then do a binary comparison, the addresses which are 	 different can be looked up in the map.  The case in which 	 this section has been bypassed has addresses which correspond 	 to values I can find in the map.  */
operator|*
name|addendp
operator|-=
name|sym
operator|->
name|n_value
expr_stmt|;
endif|#
directive|endif
block|}
ifndef|#
directive|ifndef
name|COFF_WITH_PE
comment|/* If the output symbol is common (in which case this must be a      relocateable link), we need to add in the final size of the      common symbol.  */
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_common
condition|)
operator|*
name|addendp
operator|+=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|size
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|COFF_WITH_PE
if|if
condition|(
name|howto
operator|->
name|pc_relative
condition|)
block|{
operator|*
name|addendp
operator|-=
literal|4
expr_stmt|;
comment|/* If the symbol is defined, then the generic code is going to          add back the symbol value in order to cancel out an          adjustment it made to the addend.  However, we set the addend          to 0 at the start of this function.  We need to adjust here,          to avoid the adjustment the generic code will make.  FIXME:          This is getting a bit hackish.  */
if|if
condition|(
name|sym
operator|!=
name|NULL
operator|&&
name|sym
operator|->
name|n_scnum
operator|!=
literal|0
condition|)
operator|*
name|addendp
operator|-=
name|sym
operator|->
name|n_value
expr_stmt|;
block|}
if|if
condition|(
name|rel
operator|->
name|r_type
operator|==
name|MIPS_R_RVA
condition|)
block|{
operator|*
name|addendp
operator|-=
name|pe_data
argument_list|(
name|sec
operator|->
name|output_section
operator|->
name|owner
argument_list|)
operator|->
name|pe_opthdr
operator|.
name|ImageBase
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|howto
return|;
block|}
end_function

begin_define
define|#
directive|define
name|coff_rtype_to_howto
value|coff_mips_rtype_to_howto
end_define

begin_define
define|#
directive|define
name|coff_bfd_reloc_type_lookup
value|coff_mips_reloc_type_lookup
end_define

begin_comment
comment|/* Get the howto structure for a generic reloc type.  */
end_comment

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|coff_mips_reloc_type_lookup
parameter_list|(
name|abfd
parameter_list|,
name|code
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
block|{
name|int
name|mips_type
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|BFD_RELOC_16
case|:
name|mips_type
operator|=
name|MIPS_R_REFHALF
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32
case|:
case|case
name|BFD_RELOC_CTOR
case|:
name|mips_type
operator|=
name|MIPS_R_REFWORD
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_MIPS_JMP
case|:
name|mips_type
operator|=
name|MIPS_R_JMPADDR
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_HI16_S
case|:
name|mips_type
operator|=
name|MIPS_R_REFHI
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_LO16
case|:
name|mips_type
operator|=
name|MIPS_R_REFLO
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_GPREL16
case|:
name|mips_type
operator|=
name|MIPS_R_GPREL
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_MIPS_LITERAL
case|:
name|mips_type
operator|=
name|MIPS_R_LITERAL
expr_stmt|;
break|break;
comment|/* FIXME?     case BFD_RELOC_16_PCREL_S2:       mips_type = MIPS_R_PCREL16;       break;     case BFD_RELOC_PCREL_HI16_S:       mips_type = MIPS_R_RELHI;       break;     case BFD_RELOC_PCREL_LO16:       mips_type = MIPS_R_RELLO;       break;     case BFD_RELOC_GPREL32:       mips_type = MIPS_R_SWITCH;       break; */
case|case
name|BFD_RELOC_RVA
case|:
name|mips_type
operator|=
name|MIPS_R_RVA
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|reloc_howto_type
operator|*
operator|)
name|NULL
return|;
block|}
return|return
operator|&
name|howto_table
index|[
name|mips_type
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mips_swap_reloc_in
parameter_list|(
name|abfd
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|src
decl_stmt|;
name|PTR
name|dst
decl_stmt|;
block|{
specifier|static
name|struct
name|internal_reloc
name|pair_prev
decl_stmt|;
name|RELOC
modifier|*
name|reloc_src
init|=
operator|(
name|RELOC
operator|*
operator|)
name|src
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|reloc_dst
init|=
operator|(
expr|struct
name|internal_reloc
operator|*
operator|)
name|dst
decl_stmt|;
name|reloc_dst
operator|->
name|r_vaddr
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|reloc_src
operator|->
name|r_vaddr
argument_list|)
expr_stmt|;
name|reloc_dst
operator|->
name|r_symndx
operator|=
name|H_GET_S32
argument_list|(
name|abfd
argument_list|,
name|reloc_src
operator|->
name|r_symndx
argument_list|)
expr_stmt|;
name|reloc_dst
operator|->
name|r_type
operator|=
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|reloc_src
operator|->
name|r_type
argument_list|)
expr_stmt|;
name|reloc_dst
operator|->
name|r_size
operator|=
literal|0
expr_stmt|;
name|reloc_dst
operator|->
name|r_extern
operator|=
literal|0
expr_stmt|;
name|reloc_dst
operator|->
name|r_offset
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|reloc_dst
operator|->
name|r_type
condition|)
block|{
case|case
name|MIPS_R_REFHI
case|:
name|pair_prev
operator|=
operator|*
name|reloc_dst
expr_stmt|;
break|break;
case|case
name|MIPS_R_PAIR
case|:
name|reloc_dst
operator|->
name|r_offset
operator|=
name|reloc_dst
operator|->
name|r_symndx
expr_stmt|;
if|if
condition|(
name|reloc_dst
operator|->
name|r_offset
operator|&
literal|0x8000
condition|)
name|reloc_dst
operator|->
name|r_offset
operator|-=
literal|0x10000
expr_stmt|;
comment|/*printf ("dj: pair offset is %08x\n", reloc_dst->r_offset);*/
name|reloc_dst
operator|->
name|r_symndx
operator|=
name|pair_prev
operator|.
name|r_symndx
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|mips_swap_reloc_out
parameter_list|(
name|abfd
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|src
decl_stmt|;
name|PTR
name|dst
decl_stmt|;
block|{
specifier|static
name|int
name|prev_offset
init|=
literal|1
decl_stmt|;
specifier|static
name|bfd_vma
name|prev_addr
init|=
literal|0
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|reloc_src
init|=
operator|(
expr|struct
name|internal_reloc
operator|*
operator|)
name|src
decl_stmt|;
name|struct
name|external_reloc
modifier|*
name|reloc_dst
init|=
operator|(
expr|struct
name|external_reloc
operator|*
operator|)
name|dst
decl_stmt|;
switch|switch
condition|(
name|reloc_src
operator|->
name|r_type
condition|)
block|{
case|case
name|MIPS_R_REFHI
case|:
name|prev_addr
operator|=
name|reloc_src
operator|->
name|r_vaddr
expr_stmt|;
name|prev_offset
operator|=
name|reloc_src
operator|->
name|r_offset
expr_stmt|;
break|break;
case|case
name|MIPS_R_REFLO
case|:
if|if
condition|(
name|reloc_src
operator|->
name|r_vaddr
operator|==
name|prev_addr
condition|)
block|{
comment|/* FIXME: only slightly hackish.  If we see a REFLO pointing to 	     the same address as a REFHI, we assume this is the matching 	     PAIR reloc and output it accordingly.  The symndx is really 	     the low 16 bits of the addend */
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|reloc_src
operator|->
name|r_vaddr
argument_list|,
name|reloc_dst
operator|->
name|r_vaddr
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|reloc_src
operator|->
name|r_symndx
argument_list|,
name|reloc_dst
operator|->
name|r_symndx
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|MIPS_R_PAIR
argument_list|,
name|reloc_dst
operator|->
name|r_type
argument_list|)
expr_stmt|;
return|return
name|RELSZ
return|;
block|}
break|break;
block|}
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|reloc_src
operator|->
name|r_vaddr
argument_list|,
name|reloc_dst
operator|->
name|r_vaddr
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|reloc_src
operator|->
name|r_symndx
argument_list|,
name|reloc_dst
operator|->
name|r_symndx
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|reloc_src
operator|->
name|r_type
argument_list|,
name|reloc_dst
operator|->
name|r_type
argument_list|)
expr_stmt|;
return|return
name|RELSZ
return|;
block|}
end_function

begin_define
define|#
directive|define
name|coff_swap_reloc_in
value|mips_swap_reloc_in
end_define

begin_define
define|#
directive|define
name|coff_swap_reloc_out
value|mips_swap_reloc_out
end_define

begin_define
define|#
directive|define
name|NO_COFF_RELOCS
end_define

begin_function
specifier|static
name|boolean
name|coff_pe_mips_relocate_section
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|contents
parameter_list|,
name|relocs
parameter_list|,
name|syms
parameter_list|,
name|sections
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|relocs
decl_stmt|;
name|struct
name|internal_syment
modifier|*
name|syms
decl_stmt|;
name|asection
modifier|*
modifier|*
name|sections
decl_stmt|;
block|{
name|bfd_vma
name|gp
decl_stmt|;
name|boolean
name|gp_undefined
decl_stmt|;
name|size_t
name|adjust
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|rel
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|rel_end
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|boolean
name|got_lo
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocateable
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"\ %s: `ld -r' not supported with PE MIPS objects\n"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|BFD_ASSERT
argument_list|(
name|input_bfd
operator|->
name|xvec
operator|->
name|byteorder
operator|==
name|output_bfd
operator|->
name|xvec
operator|->
name|byteorder
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|printf ("dj: relocate %s(%s) %08x\n", 	 input_bfd->filename, input_section->name, 	 input_section->output_section->vma + input_section->output_offset);
endif|#
directive|endif
name|gp
operator|=
name|_bfd_get_gp_value
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|gp
operator|==
literal|0
condition|)
name|gp_undefined
operator|=
name|true
expr_stmt|;
else|else
name|gp_undefined
operator|=
name|false
expr_stmt|;
name|got_lo
operator|=
name|false
expr_stmt|;
name|adjust
operator|=
literal|0
expr_stmt|;
name|rel
operator|=
name|relocs
expr_stmt|;
name|rel_end
operator|=
name|rel
operator|+
name|input_section
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|rel
operator|<
name|rel_end
condition|;
name|rel
operator|++
operator|,
name|i
operator|++
control|)
block|{
name|long
name|symndx
decl_stmt|;
name|struct
name|coff_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|internal_syment
modifier|*
name|sym
decl_stmt|;
name|bfd_vma
name|addend
init|=
literal|0
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|,
name|tmp
decl_stmt|,
name|targ
decl_stmt|,
name|src
decl_stmt|,
name|low
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|unsigned
name|char
modifier|*
name|mem
init|=
name|contents
operator|+
name|rel
operator|->
name|r_vaddr
decl_stmt|;
name|symndx
operator|=
name|rel
operator|->
name|r_symndx
expr_stmt|;
if|if
condition|(
name|symndx
operator|==
operator|-
literal|1
condition|)
block|{
name|h
operator|=
name|NULL
expr_stmt|;
name|sym
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|h
operator|=
name|obj_coff_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
index|[
name|symndx
index|]
expr_stmt|;
name|sym
operator|=
name|syms
operator|+
name|symndx
expr_stmt|;
block|}
comment|/* COFF treats common symbols in one of two ways.  Either the          size of the symbol is included in the section contents, or it          is not.  We assume that the size is not included, and force          the rtype_to_howto function to adjust the addend as needed.  */
if|if
condition|(
name|sym
operator|!=
name|NULL
operator|&&
name|sym
operator|->
name|n_scnum
operator|!=
literal|0
condition|)
name|addend
operator|=
operator|-
name|sym
operator|->
name|n_value
expr_stmt|;
else|else
name|addend
operator|=
literal|0
expr_stmt|;
name|howto
operator|=
name|bfd_coff_rtype_to_howto
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
argument_list|,
name|h
argument_list|,
name|sym
argument_list|,
operator|&
name|addend
argument_list|)
expr_stmt|;
if|if
condition|(
name|howto
operator|==
name|NULL
condition|)
return|return
name|false
return|;
comment|/* If we are doing a relocateable link, then we can just ignore          a PC relative reloc that is pcrel_offset.  It will already          have the correct value.  If this is not a relocateable link,          then we should ignore the symbol value.  */
if|if
condition|(
name|howto
operator|->
name|pc_relative
operator|&&
name|howto
operator|->
name|pcrel_offset
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|relocateable
condition|)
continue|continue;
if|if
condition|(
name|sym
operator|!=
name|NULL
operator|&&
name|sym
operator|->
name|n_scnum
operator|!=
literal|0
condition|)
name|addend
operator|+=
name|sym
operator|->
name|n_value
expr_stmt|;
block|}
name|val
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
if|if
condition|(
name|symndx
operator|==
operator|-
literal|1
condition|)
block|{
name|sec
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|sec
operator|=
name|sections
index|[
name|symndx
index|]
expr_stmt|;
name|val
operator|=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|sym
operator|->
name|n_value
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|obj_pe
argument_list|(
name|input_bfd
argument_list|)
condition|)
name|val
operator|-=
name|sec
operator|->
name|vma
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|sec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|val
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|info
operator|->
name|relocateable
condition|)
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
argument_list|,
name|true
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
block|}
block|}
name|src
operator|=
name|rel
operator|->
name|r_vaddr
operator|+
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
expr_stmt|;
if|#
directive|if
literal|0
block|printf ("dj: reloc %02x %-8s a=%08x/%08x(%08x) v=%08x+%08x %s\n", 	     rel->r_type, howto_table[rel->r_type].name, 	     src, rel->r_vaddr, *(unsigned long *)mem, val, rel->r_offset, 	     h?h->root.root.string:"(none)");
endif|#
directive|endif
comment|/* OK, at this point the following variables are set up: 	   src = VMA of the memory we're fixing up 	   mem = pointer to memory we're fixing up 	   val = VMA of what we need to refer to       */
define|#
directive|define
name|UI
parameter_list|(
name|x
parameter_list|)
value|(*_bfd_error_handler) (_("%s: unimplemented %s\n"), \ 				     bfd_archive_filename (input_bfd), x); \ 	      bfd_set_error (bfd_error_bad_value);
switch|switch
condition|(
name|rel
operator|->
name|r_type
condition|)
block|{
case|case
name|MIPS_R_ABSOLUTE
case|:
comment|/* ignore these */
break|break;
case|case
name|MIPS_R_REFHALF
case|:
name|UI
argument_list|(
literal|"refhalf"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MIPS_R_REFWORD
case|:
name|tmp
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|mem
argument_list|)
expr_stmt|;
comment|/* printf ("refword: src=%08x targ=%08x+%08x\n", src, tmp, val); */
name|tmp
operator|+=
name|val
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|tmp
argument_list|,
name|mem
argument_list|)
expr_stmt|;
break|break;
case|case
name|MIPS_R_JMPADDR
case|:
name|tmp
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|mem
argument_list|)
expr_stmt|;
name|targ
operator|=
name|val
operator|+
operator|(
name|tmp
operator|&
literal|0x03ffffff
operator|)
operator|*
literal|4
expr_stmt|;
if|if
condition|(
operator|(
name|src
operator|&
literal|0xf0000000
operator|)
operator|!=
operator|(
name|targ
operator|&
literal|0xf0000000
operator|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: jump too far away\n"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|tmp
operator|&=
literal|0xfc000000
expr_stmt|;
name|tmp
operator||=
operator|(
name|targ
operator|/
literal|4
operator|)
operator|&
literal|0x3ffffff
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|tmp
argument_list|,
name|mem
argument_list|)
expr_stmt|;
break|break;
case|case
name|MIPS_R_REFHI
case|:
name|tmp
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|mem
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rel
index|[
literal|1
index|]
operator|.
name|r_type
condition|)
block|{
case|case
name|MIPS_R_PAIR
case|:
comment|/* MS PE object */
name|targ
operator|=
name|val
operator|+
name|rel
index|[
literal|1
index|]
operator|.
name|r_offset
operator|+
operator|(
operator|(
name|tmp
operator|&
literal|0xffff
operator|)
operator|<<
literal|16
operator|)
expr_stmt|;
break|break;
case|case
name|MIPS_R_REFLO
case|:
comment|/* GNU COFF object */
name|low
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
index|[
literal|1
index|]
operator|.
name|r_vaddr
argument_list|)
expr_stmt|;
name|low
operator|&=
literal|0xffff
expr_stmt|;
if|if
condition|(
name|low
operator|&
literal|0x8000
condition|)
name|low
operator|-=
literal|0x10000
expr_stmt|;
name|targ
operator|=
name|val
operator|+
name|low
operator|+
operator|(
operator|(
name|tmp
operator|&
literal|0xffff
operator|)
operator|<<
literal|16
operator|)
expr_stmt|;
break|break;
default|default:
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: bad pair/reflo after refhi\n"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|tmp
operator|&=
literal|0xffff0000
expr_stmt|;
name|tmp
operator||=
operator|(
name|targ
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|tmp
argument_list|,
name|mem
argument_list|)
expr_stmt|;
break|break;
case|case
name|MIPS_R_REFLO
case|:
name|tmp
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|mem
argument_list|)
expr_stmt|;
name|targ
operator|=
name|val
operator|+
operator|(
name|tmp
operator|&
literal|0xffff
operator|)
expr_stmt|;
comment|/* printf ("refword: src=%08x targ=%08x\n", src, targ); */
name|tmp
operator|&=
literal|0xffff0000
expr_stmt|;
name|tmp
operator||=
name|targ
operator|&
literal|0xffff
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|tmp
argument_list|,
name|mem
argument_list|)
expr_stmt|;
break|break;
case|case
name|MIPS_R_GPREL
case|:
case|case
name|MIPS_R_LITERAL
case|:
name|UI
argument_list|(
literal|"gprel"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MIPS_R_SECTION
case|:
name|UI
argument_list|(
literal|"section"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MIPS_R_SECREL
case|:
name|UI
argument_list|(
literal|"secrel"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MIPS_R_SECRELLO
case|:
name|UI
argument_list|(
literal|"secrello"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MIPS_R_SECRELHI
case|:
name|UI
argument_list|(
literal|"secrelhi"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MIPS_R_RVA
case|:
name|tmp
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|mem
argument_list|)
expr_stmt|;
comment|/* printf ("rva: src=%08x targ=%08x+%08x\n", src, tmp, val); */
name|tmp
operator|+=
name|val
operator|-
name|pe_data
argument_list|(
name|input_section
operator|->
name|output_section
operator|->
name|owner
argument_list|)
operator|->
name|pe_opthdr
operator|.
name|ImageBase
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|tmp
argument_list|,
name|mem
argument_list|)
expr_stmt|;
break|break;
case|case
name|MIPS_R_PAIR
case|:
comment|/* ignore these */
break|break;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_define
define|#
directive|define
name|coff_relocate_section
value|coff_pe_mips_relocate_section
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|TARGET_UNDERSCORE
end_ifdef

begin_comment
comment|/* If mips gcc uses underscores for symbol names, then it does not use    a leading dot for local labels, so if TARGET_UNDERSCORE is defined    we treat all symbols starting with L as local.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|coff_mips_is_local_label_name
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|boolean
name|coff_mips_is_local_label_name
parameter_list|(
name|abfd
parameter_list|,
name|name
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'L'
condition|)
return|return
name|true
return|;
return|return
name|_bfd_coff_is_local_label_name
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|coff_bfd_is_local_label_name
value|coff_mips_is_local_label_name
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TARGET_UNDERSCORE */
end_comment

begin_define
define|#
directive|define
name|COFF_NO_HACK_SCNHDR_SIZE
end_define

begin_include
include|#
directive|include
file|"coffcode.h"
end_include

begin_decl_stmt
specifier|const
name|bfd_target
ifdef|#
directive|ifdef
name|TARGET_SYM
name|TARGET_SYM
init|=
else|#
directive|else
name|mipslpe_vec
operator|=
endif|#
directive|endif
block|{
ifdef|#
directive|ifdef
name|TARGET_NAME
name|TARGET_NAME
block|,
else|#
directive|else
literal|"pe-mips"
block|,
comment|/* name */
endif|#
directive|endif
name|bfd_target_coff_flavour
block|,
name|BFD_ENDIAN_LITTLE
block|,
comment|/* data byte order is little */
name|BFD_ENDIAN_LITTLE
block|,
comment|/* header byte order is little */
operator|(
name|HAS_RELOC
operator||
name|EXEC_P
operator||
comment|/* object flags */
name|HAS_LINENO
operator||
name|HAS_DEBUG
operator||
name|HAS_SYMS
operator||
name|HAS_LOCALS
operator||
name|WP_TEXT
operator||
name|D_PAGED
operator|)
block|,
ifndef|#
directive|ifndef
name|COFF_WITH_PE
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
comment|/* section flags */
operator||
name|SEC_CODE
operator||
name|SEC_DATA
operator|)
block|,
else|#
directive|else
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
comment|/* section flags */
operator||
name|SEC_CODE
operator||
name|SEC_DATA
operator||
name|SEC_LINK_ONCE
operator||
name|SEC_LINK_DUPLICATES
operator|)
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TARGET_UNDERSCORE
name|TARGET_UNDERSCORE
block|,
comment|/* leading underscore */
else|#
directive|else
literal|0
block|,
comment|/* leading underscore */
endif|#
directive|endif
literal|'/'
block|,
comment|/* ar_pad_char */
literal|15
block|,
comment|/* ar_max_namelen */
name|bfd_getl64
block|,
name|bfd_getl_signed_64
block|,
name|bfd_putl64
block|,
name|bfd_getl32
block|,
name|bfd_getl_signed_32
block|,
name|bfd_putl32
block|,
name|bfd_getl16
block|,
name|bfd_getl_signed_16
block|,
name|bfd_putl16
block|,
comment|/* data */
name|bfd_getl64
block|,
name|bfd_getl_signed_64
block|,
name|bfd_putl64
block|,
name|bfd_getl32
block|,
name|bfd_getl_signed_32
block|,
name|bfd_putl32
block|,
name|bfd_getl16
block|,
name|bfd_getl_signed_16
block|,
name|bfd_putl16
block|,
comment|/* hdrs */
comment|/* Note that we allow an object file to be treated as a core file as well.  */
block|{
name|_bfd_dummy_target
block|,
name|coff_object_p
block|,
comment|/* bfd_check_format */
name|bfd_generic_archive_p
block|,
name|coff_object_p
block|}
block|,
block|{
name|bfd_false
block|,
name|coff_mkobject
block|,
name|_bfd_generic_mkarchive
block|,
comment|/* bfd_set_format */
name|bfd_false
block|}
block|,
block|{
name|bfd_false
block|,
name|coff_write_object_contents
block|,
comment|/* bfd_write_contents */
name|_bfd_write_archive_contents
block|,
name|bfd_false
block|}
block|,
name|BFD_JUMP_TABLE_GENERIC
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_COPY
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_CORE
argument_list|(
name|_bfd_nocore
argument_list|)
block|,
name|BFD_JUMP_TABLE_ARCHIVE
argument_list|(
name|_bfd_archive_coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_SYMBOLS
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_RELOCS
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_WRITE
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_LINK
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_DYNAMIC
argument_list|(
name|_bfd_nodynamic
argument_list|)
block|,
name|NULL
block|,
name|COFF_SWAP_TABLE
block|}
decl_stmt|;
end_decl_stmt

end_unit

