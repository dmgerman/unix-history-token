begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD support for handling relocation entries.    Copyright (C) 1990, 91, 92, 93, 94, 95, 96, 1997    Free Software Foundation, Inc.    Written by Cygnus Support.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* SECTION 	Relocations  	BFD maintains relocations in much the same way it maintains 	symbols: they are left alone until required, then read in 	en-mass and translated into an internal form.  A common 	routine<<bfd_perform_relocation>> acts upon the 	canonical form to do the fixup.  	Relocations are maintained on a per section basis, 	while symbols are maintained on a per BFD basis.  	All that a back end has to do to fit the BFD interface is to create 	a<<struct reloc_cache_entry>> for each relocation 	in a particular section, and fill in the right bits of the structures.  @menu @* typedef arelent:: @* howto manager:: @end menu  */
end_comment

begin_comment
comment|/* DO compile in the reloc_code name table from libbfd.h.  */
end_comment

begin_define
define|#
directive|define
name|_BFD_MAKE_TABLE_bfd_reloc_code_real
end_define

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_comment
comment|/* DOCDD INODE 	typedef arelent, howto manager, Relocations, Relocations  SUBSECTION 	typedef arelent  	This is the structure of a relocation entry:  CODE_FRAGMENT . .typedef enum bfd_reloc_status .{ .       {* No errors detected *} .  bfd_reloc_ok, . .       {* The relocation was performed, but there was an overflow. *} .  bfd_reloc_overflow, . .       {* The address to relocate was not within the section supplied. *} .  bfd_reloc_outofrange, . .       {* Used by special functions *} .  bfd_reloc_continue, . .       {* Unsupported relocation size requested. *} .  bfd_reloc_notsupported, . .       {* Unused *} .  bfd_reloc_other, . .       {* The symbol to relocate against was undefined. *} .  bfd_reloc_undefined, . .       {* The relocation was performed, but may not be ok - presently .          generated only when linking i960 coff files with i960 b.out .          symbols.  If this type is returned, the error_message argument .          to bfd_perform_relocation will be set.  *} .  bfd_reloc_dangerous . } . bfd_reloc_status_type; . . .typedef struct reloc_cache_entry .{ .       {* A pointer into the canonical table of pointers  *} .  struct symbol_cache_entry **sym_ptr_ptr; . .       {* offset in section *} .  bfd_size_type address; . .       {* addend for relocation value *} .  bfd_vma addend; . .       {* Pointer to how to perform the required relocation *} .  reloc_howto_type *howto; . .} arelent;  */
end_comment

begin_comment
comment|/* DESCRIPTION          Here is a description of each of the fields within an<<arelent>>:          o<<sym_ptr_ptr>>          The symbol table pointer points to a pointer to the symbol         associated with the relocation request.  It is         the pointer into the table returned by the back end's<<get_symtab>> action. @xref{Symbols}. The symbol is referenced         through a pointer to a pointer so that tools like the linker         can fix up all the symbols of the same name by modifying only         one pointer. The relocation routine looks in the symbol and         uses the base of the section the symbol is attached to and the         value of the symbol as the initial relocation offset. If the         symbol pointer is zero, then the section provided is looked up.          o<<address>>          The<<address>> field gives the offset in bytes from the base of         the section data which owns the relocation record to the first         byte of relocatable information. The actual data relocated         will be relative to this point; for example, a relocation         type which modifies the bottom two bytes of a four byte word         would not touch the first byte pointed to in a big endian         world.  	o<<addend>>  	The<<addend>> is a value provided by the back end to be added (!) 	to the relocation offset. Its interpretation is dependent upon 	the howto. For example, on the 68k the code:   |        char foo[]; |        main() |                { |                return foo[0x12345678]; |                }          Could be compiled into:  |        linkw fp,#-4 |        moveb @@#12345678,d0 |        extbl d0 |        unlk fp |        rts           This could create a reloc pointing to<<foo>>, but leave the         offset in the data, something like:   |RELOCATION RECORDS FOR [.text]: |offset   type      value |00000006 32        _foo | |00000000 4e56 fffc          ; linkw fp,#-4 |00000004 1039 1234 5678     ; moveb @@#12345678,d0 |0000000a 49c0               ; extbl d0 |0000000c 4e5e               ; unlk fp |0000000e 4e75               ; rts           Using coff and an 88k, some instructions don't have enough         space in them to represent the full address range, and         pointers have to be loaded in two parts. So you'd get something like:   |        or.u     r13,r0,hi16(_foo+0x12345678) |        ld.b     r2,r13,lo16(_foo+0x12345678) |        jmp      r1           This should create two relocs, both pointing to<<_foo>>, and with         0x12340000 in their addend field. The data would consist of:   |RELOCATION RECORDS FOR [.text]: |offset   type      value |00000002 HVRT16    _foo+0x12340000 |00000006 LVRT16    _foo+0x12340000 | |00000000 5da05678           ; or.u r13,r0,0x5678 |00000004 1c4d5678           ; ld.b r2,r13,0x5678 |00000008 f400c001           ; jmp r1           The relocation routine digs out the value from the data, adds         it to the addend to get the original offset, and then adds the         value of<<_foo>>. Note that all 32 bits have to be kept around         somewhere, to cope with carry from bit 15 to bit 16.          One further example is the sparc and the a.out format. The         sparc has a similar problem to the 88k, in that some         instructions don't have room for an entire offset, but on the         sparc the parts are created in odd sized lumps. The designers of         the a.out format chose to not use the data within the section         for storing part of the offset; all the offset is kept within         the reloc. Anything in the data should be ignored.  |        save %sp,-112,%sp |        sethi %hi(_foo+0x12345678),%g2 |        ldsb [%g2+%lo(_foo+0x12345678)],%i0 |        ret |        restore          Both relocs contain a pointer to<<foo>>, and the offsets         contain junk.   |RELOCATION RECORDS FOR [.text]: |offset   type      value |00000004 HI22      _foo+0x12345678 |00000008 LO10      _foo+0x12345678 | |00000000 9de3bf90     ; save %sp,-112,%sp |00000004 05000000     ; sethi %hi(_foo+0),%g2 |00000008 f048a000     ; ldsb [%g2+%lo(_foo+0)],%i0 |0000000c 81c7e008     ; ret |00000010 81e80000     ; restore           o<<howto>>          The<<howto>> field can be imagined as a         relocation instruction. It is a pointer to a structure which         contains information on what to do with all of the other         information in the reloc record and data section. A back end         would normally have a relocation instruction set and turn         relocations into pointers to the correct structure on input -         but it would be possible to create each howto field on demand.  */
end_comment

begin_comment
comment|/* SUBSUBSECTION<<enum complain_overflow>>  	Indicates what sort of overflow checking should be done when 	performing a relocation.  CODE_FRAGMENT . .enum complain_overflow .{ .	{* Do not complain on overflow. *} .  complain_overflow_dont, . .	{* Complain if the bitfield overflows, whether it is considered .	   as signed or unsigned. *} .  complain_overflow_bitfield, . .	{* Complain if the value overflows when considered as signed .	   number. *} .  complain_overflow_signed, . .	{* Complain if the value overflows when considered as an .	   unsigned number. *} .  complain_overflow_unsigned .};  */
end_comment

begin_comment
comment|/* SUBSUBSECTION<<reloc_howto_type>>          The<<reloc_howto_type>> is a structure which contains all the         information that libbfd needs to know to tie up a back end's data.  CODE_FRAGMENT .struct symbol_cache_entry;		{* Forward declaration *} . .struct reloc_howto_struct .{ .       {*  The type field has mainly a documentary use - the back end can .           do what it wants with it, though normally the back end's .           external idea of what a reloc number is stored .           in this field. For example, a PC relative word relocation .           in a coff environment has the type 023 - because that's .           what the outside world calls a R_PCRWORD reloc. *} .  unsigned int type; . .       {*  The value the final relocation is shifted right by. This drops .           unwanted data from the relocation.  *} .  unsigned int rightshift; . .	{*  The size of the item to be relocated.  This is *not* a .	    power-of-two measure.  To get the number of bytes operated .	    on by a type of relocation, use bfd_get_reloc_size.  *} .  int size; . .       {*  The number of bits in the item to be relocated.  This is used .	    when doing overflow checking.  *} .  unsigned int bitsize; . .       {*  Notes that the relocation is relative to the location in the .           data section of the addend. The relocation function will .           subtract from the relocation value the address of the location .           being relocated. *} .  boolean pc_relative; . .	{*  The bit position of the reloc value in the destination. .	    The relocated value is left shifted by this amount. *} .  unsigned int bitpos; . .	{* What type of overflow error should be checked for when .	   relocating. *} .  enum complain_overflow complain_on_overflow; . .       {* If this field is non null, then the supplied function is .          called rather than the normal function. This allows really .          strange relocation methods to be accomodated (e.g., i960 callj .          instructions). *} .  bfd_reloc_status_type (*special_function) .				    PARAMS ((bfd *abfd, .					     arelent *reloc_entry, .                                            struct symbol_cache_entry *symbol, .                                            PTR data, .                                            asection *input_section, .                                            bfd *output_bfd, .                                            char **error_message)); . .       {* The textual name of the relocation type. *} .  char *name; . .       {* When performing a partial link, some formats must modify the .          relocations rather than the data - this flag signals this.*} .  boolean partial_inplace; . .       {* The src_mask selects which parts of the read in data .          are to be used in the relocation sum.  E.g., if this was an 8 bit .          bit of data which we read and relocated, this would be .          0x000000ff. When we have relocs which have an addend, such as .          sun4 extended relocs, the value in the offset part of a .          relocating field is garbage so we never use it. In this case .          the mask would be 0x00000000. *} .  bfd_vma src_mask; . .       {* The dst_mask selects which parts of the instruction are replaced .          into the instruction. In most cases src_mask == dst_mask, .          except in the above special case, where dst_mask would be .          0x000000ff, and src_mask would be 0x00000000.   *} .  bfd_vma dst_mask; . .       {* When some formats create PC relative instructions, they leave .          the value of the pc of the place being relocated in the offset .          slot of the instruction, so that a PC relative relocation can .          be made just by adding in an ordinary offset (e.g., sun3 a.out). .          Some formats leave the displacement part of an instruction .          empty (e.g., m88k bcs); this flag signals the fact.*} .  boolean pcrel_offset; . .};  */
end_comment

begin_comment
comment|/* FUNCTION 	The HOWTO Macro  DESCRIPTION 	The HOWTO define is horrible and will go away.   .#define HOWTO(C, R,S,B, P, BI, O, SF, NAME, INPLACE, MASKSRC, MASKDST, PC) \ .  {(unsigned)C,R,S,B, P, BI, O,SF,NAME,INPLACE,MASKSRC,MASKDST,PC}  DESCRIPTION 	And will be replaced with the totally magic way. But for the 	moment, we are compatible, so do it this way.   .#define NEWHOWTO( FUNCTION, NAME,SIZE,REL,IN) HOWTO(0,0,SIZE,0,REL,0,complain_overflow_dont,FUNCTION, NAME,false,0,0,IN) . DESCRIPTION 	Helper routine to turn a symbol into a relocation value.  .#define HOWTO_PREPARE(relocation, symbol)      \ .  {                                            \ .  if (symbol != (asymbol *)NULL) {             \ .    if (bfd_is_com_section (symbol->section)) { \ .      relocation = 0;                          \ .    }                                          \ .    else {                                     \ .      relocation = symbol->value;              \ .    }                                          \ .  }                                            \ .}  */
end_comment

begin_comment
comment|/* FUNCTION 	bfd_get_reloc_size  SYNOPSIS 	int bfd_get_reloc_size (reloc_howto_type *);  DESCRIPTION 	For a reloc_howto_type that operates on a fixed number of bytes, 	this returns the number of bytes operated on.  */
end_comment

begin_function
name|int
name|bfd_get_reloc_size
parameter_list|(
name|howto
parameter_list|)
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
block|{
switch|switch
condition|(
name|howto
operator|->
name|size
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|1
return|;
case|case
literal|1
case|:
return|return
literal|2
return|;
case|case
literal|2
case|:
return|return
literal|4
return|;
case|case
literal|3
case|:
return|return
literal|0
return|;
case|case
literal|4
case|:
return|return
literal|8
return|;
case|case
literal|8
case|:
return|return
literal|16
return|;
case|case
operator|-
literal|2
case|:
return|return
literal|4
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* TYPEDEF 	arelent_chain  DESCRIPTION  	How relocs are tied together in an<<asection>>:  .typedef struct relent_chain { .  arelent relent; .  struct   relent_chain *next; .} arelent_chain;  */
end_comment

begin_comment
comment|/* FUNCTION 	bfd_perform_relocation  SYNOPSIS 	bfd_reloc_status_type                 bfd_perform_relocation                         (bfd *abfd,                          arelent *reloc_entry,                          PTR data,                          asection *input_section,                          bfd *output_bfd, 			 char **error_message);  DESCRIPTION 	If @var{output_bfd} is supplied to this function, the 	generated image will be relocatable; the relocations are 	copied to the output file after they have been changed to 	reflect the new state of the world. There are two ways of 	reflecting the results of partial linkage in an output file: 	by modifying the output data in place, and by modifying the 	relocation record.  Some native formats (e.g., basic a.out and 	basic coff) have no way of specifying an addend in the 	relocation type, so the addend has to go in the output data. 	This is no big deal since in these formats the output data 	slot will always be big enough for the addend. Complex reloc 	types with addends were invented to solve just this problem. 	The @var{error_message} argument is set to an error message if 	this return @code{bfd_reloc_dangerous}.  */
end_comment

begin_function
name|bfd_reloc_status_type
name|bfd_perform_relocation
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
block|{
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_reloc_status_type
name|flag
init|=
name|bfd_reloc_ok
decl_stmt|;
name|bfd_size_type
name|addr
init|=
name|reloc_entry
operator|->
name|address
decl_stmt|;
name|bfd_vma
name|output_base
init|=
literal|0
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
init|=
name|reloc_entry
operator|->
name|howto
decl_stmt|;
name|asection
modifier|*
name|reloc_target_output_section
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|symbol
operator|=
operator|*
operator|(
name|reloc_entry
operator|->
name|sym_ptr_ptr
operator|)
expr_stmt|;
if|if
condition|(
name|bfd_is_abs_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
operator|&&
name|output_bfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
block|{
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
comment|/* If we are not producing relocateable output, return an error if      the symbol is not defined.  An undefined weak symbol is      considered to have a value of zero (SVR4 ABI, p. 4-27).  */
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
operator|&&
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_WEAK
operator|)
operator|==
literal|0
operator|&&
name|output_bfd
operator|==
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
name|flag
operator|=
name|bfd_reloc_undefined
expr_stmt|;
comment|/* If there is a function supplied to handle this relocation type,      call it.  It'll return `bfd_reloc_continue' if further processing      can be done.  */
if|if
condition|(
name|howto
operator|->
name|special_function
condition|)
block|{
name|bfd_reloc_status_type
name|cont
decl_stmt|;
name|cont
operator|=
name|howto
operator|->
name|special_function
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
argument_list|,
name|symbol
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
name|error_message
argument_list|)
expr_stmt|;
if|if
condition|(
name|cont
operator|!=
name|bfd_reloc_continue
condition|)
return|return
name|cont
return|;
block|}
comment|/* Is the address of the relocation really within the section?  */
if|if
condition|(
name|reloc_entry
operator|->
name|address
operator|>
name|input_section
operator|->
name|_cooked_size
condition|)
return|return
name|bfd_reloc_outofrange
return|;
comment|/* Work out which section the relocation is targetted at and the      initial relocation command value.  */
comment|/* Get symbol value.  (Common symbols are special.)  */
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
else|else
name|relocation
operator|=
name|symbol
operator|->
name|value
expr_stmt|;
name|reloc_target_output_section
operator|=
name|symbol
operator|->
name|section
operator|->
name|output_section
expr_stmt|;
comment|/* Convert input-section-relative symbol value to absolute.  */
if|if
condition|(
name|output_bfd
operator|&&
name|howto
operator|->
name|partial_inplace
operator|==
name|false
condition|)
name|output_base
operator|=
literal|0
expr_stmt|;
else|else
name|output_base
operator|=
name|reloc_target_output_section
operator|->
name|vma
expr_stmt|;
name|relocation
operator|+=
name|output_base
operator|+
name|symbol
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
comment|/* Add in supplied addend.  */
name|relocation
operator|+=
name|reloc_entry
operator|->
name|addend
expr_stmt|;
comment|/* Here the variable relocation holds the final address of the      symbol we are relocating against, plus any addend.  */
if|if
condition|(
name|howto
operator|->
name|pc_relative
operator|==
name|true
condition|)
block|{
comment|/* This is a PC relative relocation.  We want to set RELOCATION 	 to the distance between the address of the symbol and the 	 location.  RELOCATION is already the address of the symbol.  	 We start by subtracting the address of the section containing 	 the location.  	 If pcrel_offset is set, we must further subtract the position 	 of the location within the section.  Some targets arrange for 	 the addend to be the negative of the position of the location 	 within the section; for example, i386-aout does this.  For 	 i386-aout, pcrel_offset is false.  Some other targets do not 	 include the position of the location; for example, m88kbcs, 	 or ELF.  For those targets, pcrel_offset is true.  	 If we are producing relocateable output, then we must ensure 	 that this reloc will be correctly computed when the final 	 relocation is done.  If pcrel_offset is false we want to wind 	 up with the negative of the location within the section, 	 which means we must adjust the existing addend by the change 	 in the location within the section.  If pcrel_offset is true 	 we do not want to adjust the existing addend at all.  	 FIXME: This seems logical to me, but for the case of 	 producing relocateable output it is not what the code 	 actually does.  I don't want to change it, because it seems 	 far too likely that something will break.  */
name|relocation
operator|-=
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
expr_stmt|;
if|if
condition|(
name|howto
operator|->
name|pcrel_offset
operator|==
name|true
condition|)
name|relocation
operator|-=
name|reloc_entry
operator|->
name|address
expr_stmt|;
block|}
if|if
condition|(
name|output_bfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|howto
operator|->
name|partial_inplace
operator|==
name|false
condition|)
block|{
comment|/* This is a partial relocation, and we want to apply the relocation 	     to the reloc entry rather than the raw data. Modify the reloc 	     inplace to reflect what we now know.  */
name|reloc_entry
operator|->
name|addend
operator|=
name|relocation
expr_stmt|;
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|flag
return|;
block|}
else|else
block|{
comment|/* This is a partial relocation, but inplace, so modify the 	     reloc record a bit.  	     If we've relocated with a symbol with a section, change 	     into a ref to the section belonging to the symbol.  */
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
comment|/* WTF?? */
if|if
condition|(
name|abfd
operator|->
name|xvec
operator|->
name|flavour
operator|==
name|bfd_target_coff_flavour
operator|&&
name|strcmp
argument_list|(
name|abfd
operator|->
name|xvec
operator|->
name|name
argument_list|,
literal|"aixcoff-rs6000"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|abfd
operator|->
name|xvec
operator|->
name|name
argument_list|,
literal|"xcoff-powermac"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|abfd
operator|->
name|xvec
operator|->
name|name
argument_list|,
literal|"coff-Intel-little"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|abfd
operator|->
name|xvec
operator|->
name|name
argument_list|,
literal|"coff-Intel-big"
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|#
directive|if
literal|1
comment|/* For m68k-coff, the addend was being subtracted twice during 		 relocation with -r.  Removing the line below this comment 		 fixes that problem; see PR 2953.  However, Ian wrote the following, regarding removing the line below, which explains why it is still enabled:  --djm  If you put a patch like that into BFD you need to check all the COFF linkers.  I am fairly certain that patch will break coff-i386 (e.g., SCO); see coff_i386_reloc in coff-i386.c where I worked around the problem in a different way.  There may very well be a reason that the code works as it does.  Hmmm.  The first obvious point is that bfd_perform_relocation should not have any tests that depend upon the flavour.  It's seem like entirely the wrong place for such a thing.  The second obvious point is that the current code ignores the reloc addend when producing relocateable output for COFF.  That's peculiar.  In fact, I really have no idea what the point of the line you want to remove is.  A typical COFF reloc subtracts the old value of the symbol and adds in the new value to the location in the object file (if it's a pc relative reloc it adds the difference between the symbol value and the location).  When relocating we need to preserve that property.  BFD handles this by setting the addend to the negative of the old value of the symbol.  Unfortunately it handles common symbols in a non-standard way (it doesn't subtract the old value) but that's a different story (we can't change it without losing backward compatibility with old object files) (coff-i386 does subtract the old value, to be compatible with existing coff-i386 targets, like SCO).  So everything works fine when not producing relocateable output.  When we are producing relocateable output, logically we should do exactly what we do when not producing relocateable output.  Therefore, your patch is correct.  In fact, it should probably always just set reloc_entry->addend to 0 for all cases, since it is, in fact, going to add the value into the object file.  This won't hurt the COFF code, which doesn't use the addend; I'm not sure what it will do to other formats (the thing to check for would be whether any formats both use the addend and set partial_inplace).  When I wanted to make coff-i386 produce relocateable output, I ran into the problem that you are running into: I wanted to remove that line.  Rather than risk it, I made the coff-i386 relocs use a special function; it's coff_i386_reloc in coff-i386.c.  The function specifically adds the addend field into the object file, knowing that bfd_perform_relocation is not going to.  If you remove that line, then coff-i386.c will wind up adding the addend field in twice.  It's trivial to fix; it just needs to be done.  The problem with removing the line is just that it may break some working code.  With BFD it's hard to be sure of anything.  The right way to deal with this is simply to build and test at least all the supported COFF targets.  It should be straightforward if time and disk space consuming.  For each target:     1) build the linker     2) generate some executable, and link it using -r (I would        probably use paranoia.o and link against newlib/libc.a, which        for all the supported targets would be available in        /usr/cygnus/progressive/H-host/target/lib/libc.a).     3) make the change to reloc.c     4) rebuild the linker     5) repeat step 2     6) if the resulting object files are the same, you have at least        made it no worse     7) if they are different you have to figure out which version is        right */
name|relocation
operator|-=
name|reloc_entry
operator|->
name|addend
expr_stmt|;
endif|#
directive|endif
name|reloc_entry
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|reloc_entry
operator|->
name|addend
operator|=
name|relocation
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|reloc_entry
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
block|}
comment|/* FIXME: This overflow checking is incomplete, because the value      might have overflowed before we get here.  For a correct check we      need to compute the value in a size larger than bitsize, but we      can't reasonably do that for a reloc the same size as a host      machine word.      FIXME: We should also do overflow checking on the result after      adding in the value contained in the object file.  */
if|if
condition|(
name|howto
operator|->
name|complain_on_overflow
operator|!=
name|complain_overflow_dont
operator|&&
name|flag
operator|==
name|bfd_reloc_ok
condition|)
block|{
name|bfd_vma
name|check
decl_stmt|;
comment|/* Get the value that will be used for the relocation, but 	 starting at bit position zero.  */
name|check
operator|=
name|relocation
operator|>>
name|howto
operator|->
name|rightshift
expr_stmt|;
switch|switch
condition|(
name|howto
operator|->
name|complain_on_overflow
condition|)
block|{
case|case
name|complain_overflow_signed
case|:
block|{
comment|/* Assumes two's complement.  */
name|bfd_signed_vma
name|reloc_signed_max
init|=
operator|(
literal|1
operator|<<
operator|(
name|howto
operator|->
name|bitsize
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
decl_stmt|;
name|bfd_signed_vma
name|reloc_signed_min
init|=
operator|~
name|reloc_signed_max
decl_stmt|;
comment|/* The above right shift is incorrect for a signed value. 	       Fix it up by forcing on the upper bits.  */
if|if
condition|(
name|howto
operator|->
name|rightshift
operator|>
literal|0
operator|&&
operator|(
name|bfd_signed_vma
operator|)
name|relocation
operator|<
literal|0
condition|)
name|check
operator||=
operator|(
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|&
operator|~
operator|(
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|>>
name|howto
operator|->
name|rightshift
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|bfd_signed_vma
operator|)
name|check
operator|>
name|reloc_signed_max
operator|||
operator|(
name|bfd_signed_vma
operator|)
name|check
operator|<
name|reloc_signed_min
condition|)
name|flag
operator|=
name|bfd_reloc_overflow
expr_stmt|;
block|}
break|break;
case|case
name|complain_overflow_unsigned
case|:
block|{
comment|/* Assumes two's complement.  This expression avoids 	       overflow if howto->bitsize is the number of bits in 	       bfd_vma.  */
name|bfd_vma
name|reloc_unsigned_max
init|=
operator|(
operator|(
operator|(
literal|1
operator|<<
operator|(
name|howto
operator|->
name|bitsize
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
operator|<<
literal|1
operator|)
operator||
literal|1
decl_stmt|;
if|if
condition|(
operator|(
name|bfd_vma
operator|)
name|check
operator|>
name|reloc_unsigned_max
condition|)
name|flag
operator|=
name|bfd_reloc_overflow
expr_stmt|;
block|}
break|break;
case|case
name|complain_overflow_bitfield
case|:
block|{
comment|/* Assumes two's complement.  This expression avoids 	       overflow if howto->bitsize is the number of bits in 	       bfd_vma.  */
name|bfd_vma
name|reloc_bits
init|=
operator|(
operator|(
operator|(
literal|1
operator|<<
operator|(
name|howto
operator|->
name|bitsize
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
operator|<<
literal|1
operator|)
operator||
literal|1
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|bfd_vma
operator|)
name|check
operator|&
operator|~
name|reloc_bits
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|bfd_vma
operator|)
name|check
operator|&
operator|~
name|reloc_bits
operator|)
operator|!=
operator|(
operator|-
literal|1
operator|&
operator|~
name|reloc_bits
operator|)
condition|)
block|{
comment|/* The above right shift is incorrect for a signed 		   value.  See if turning on the upper bits fixes the 		   overflow.  */
if|if
condition|(
name|howto
operator|->
name|rightshift
operator|>
literal|0
operator|&&
operator|(
name|bfd_signed_vma
operator|)
name|relocation
operator|<
literal|0
condition|)
block|{
name|check
operator||=
operator|(
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|&
operator|~
operator|(
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|>>
name|howto
operator|->
name|rightshift
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|bfd_vma
operator|)
name|check
operator|&
operator|~
name|reloc_bits
operator|)
operator|!=
operator|(
operator|-
literal|1
operator|&
operator|~
name|reloc_bits
operator|)
condition|)
name|flag
operator|=
name|bfd_reloc_overflow
expr_stmt|;
block|}
else|else
name|flag
operator|=
name|bfd_reloc_overflow
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/*     Either we are relocating all the way, or we don't want to apply     the relocation to the reloc entry (probably because there isn't     any room in the output format to describe addends to relocs)     */
comment|/* The cast to bfd_vma avoids a bug in the Alpha OSF/1 C compiler      (OSF version 1.3, compiler version 3.11).  It miscompiles the      following program:       struct str      {        unsigned int i0;      } s = { 0 };       int      main ()      {        unsigned long x;         x = 0x100000000;        x<<= (unsigned long) s.i0;        if (x == 0) 	 printf ("failed\n");        else 	 printf ("succeeded (%lx)\n", x);      }      */
name|relocation
operator|>>=
operator|(
name|bfd_vma
operator|)
name|howto
operator|->
name|rightshift
expr_stmt|;
comment|/* Shift everything up to where it's going to be used */
name|relocation
operator|<<=
operator|(
name|bfd_vma
operator|)
name|howto
operator|->
name|bitpos
expr_stmt|;
comment|/* Wait for the day when all have the mask in them */
comment|/* What we do:      i instruction to be left alone      o offset within instruction      r relocation offset to apply      S src mask      D dst mask      N ~dst mask      A part 1      B part 2      R result       Do this:      i i i i i o o o o o        from bfd_get<size>      and           S S S S S    to get the size offset we want      +   r r r r r r r r r r  to get the final value to place      and           D D D D D  to chop to right size      -----------------------      A A A A A      And this:      ...   i i i i i o o o o o  from bfd_get<size>      and   N N N N N            get instruction      -----------------------      ...   B B B B B       And then:      B B B B B      or              A A A A A      -----------------------      R R R R R R R R R R        put into bfd_put<size>      */
define|#
directive|define
name|DOIT
parameter_list|(
name|x
parameter_list|)
define|\
value|x = ( (x& ~howto->dst_mask) | (((x& howto->src_mask) +  relocation)& howto->dst_mask))
switch|switch
condition|(
name|howto
operator|->
name|size
condition|)
block|{
case|case
literal|0
case|:
block|{
name|char
name|x
init|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|data
operator|+
name|addr
argument_list|)
decl_stmt|;
name|DOIT
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|x
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|data
operator|+
name|addr
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|1
case|:
block|{
name|short
name|x
init|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|addr
argument_list|)
decl_stmt|;
name|DOIT
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|x
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|data
operator|+
name|addr
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
block|{
name|long
name|x
init|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|addr
argument_list|)
decl_stmt|;
name|DOIT
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|x
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|addr
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
operator|-
literal|2
case|:
block|{
name|long
name|x
init|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|addr
argument_list|)
decl_stmt|;
name|relocation
operator|=
operator|-
name|relocation
expr_stmt|;
name|DOIT
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|x
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|addr
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
operator|-
literal|1
case|:
block|{
name|long
name|x
init|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|addr
argument_list|)
decl_stmt|;
name|relocation
operator|=
operator|-
name|relocation
expr_stmt|;
name|DOIT
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|x
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|addr
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|3
case|:
comment|/* Do nothing */
break|break;
case|case
literal|4
case|:
ifdef|#
directive|ifdef
name|BFD64
block|{
name|bfd_vma
name|x
init|=
name|bfd_get_64
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|addr
argument_list|)
decl_stmt|;
name|DOIT
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|bfd_put_64
argument_list|(
name|abfd
argument_list|,
name|x
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|addr
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
break|break;
default|default:
return|return
name|bfd_reloc_other
return|;
block|}
return|return
name|flag
return|;
block|}
end_function

begin_comment
comment|/* FUNCTION 	bfd_install_relocation  SYNOPSIS 	bfd_reloc_status_type                 bfd_install_relocation                         (bfd *abfd,                          arelent *reloc_entry,                          PTR data, bfd_vma data_start,                          asection *input_section, 			 char **error_message);  DESCRIPTION 	This looks remarkably like<<bfd_perform_relocation>>, except it 	does not expect that the section contents have been filled in. 	I.e., it's suitable for use when creating, rather than applying 	a relocation.  	For now, this function should be considered reserved for the 	assembler.  */
end_comment

begin_function
name|bfd_reloc_status_type
name|bfd_install_relocation
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|data_start
parameter_list|,
name|data_start_offset
parameter_list|,
name|input_section
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|PTR
name|data_start
decl_stmt|;
name|bfd_vma
name|data_start_offset
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
block|{
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_reloc_status_type
name|flag
init|=
name|bfd_reloc_ok
decl_stmt|;
name|bfd_size_type
name|addr
init|=
name|reloc_entry
operator|->
name|address
decl_stmt|;
name|bfd_vma
name|output_base
init|=
literal|0
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
init|=
name|reloc_entry
operator|->
name|howto
decl_stmt|;
name|asection
modifier|*
name|reloc_target_output_section
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|bfd_byte
modifier|*
name|data
decl_stmt|;
name|symbol
operator|=
operator|*
operator|(
name|reloc_entry
operator|->
name|sym_ptr_ptr
operator|)
expr_stmt|;
if|if
condition|(
name|bfd_is_abs_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
block|{
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
comment|/* If there is a function supplied to handle this relocation type,      call it.  It'll return `bfd_reloc_continue' if further processing      can be done.  */
if|if
condition|(
name|howto
operator|->
name|special_function
condition|)
block|{
name|bfd_reloc_status_type
name|cont
decl_stmt|;
comment|/* XXX - The special_function calls haven't been fixed up to deal 	 with creating new relocations and section contents.  */
name|cont
operator|=
name|howto
operator|->
name|special_function
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
argument_list|,
name|symbol
argument_list|,
comment|/* XXX - Non-portable! */
operator|(
operator|(
name|bfd_byte
operator|*
operator|)
name|data_start
operator|-
name|data_start_offset
operator|)
argument_list|,
name|input_section
argument_list|,
name|abfd
argument_list|,
name|error_message
argument_list|)
expr_stmt|;
if|if
condition|(
name|cont
operator|!=
name|bfd_reloc_continue
condition|)
return|return
name|cont
return|;
block|}
comment|/* Is the address of the relocation really within the section?  */
if|if
condition|(
name|reloc_entry
operator|->
name|address
operator|>
name|input_section
operator|->
name|_cooked_size
condition|)
return|return
name|bfd_reloc_outofrange
return|;
comment|/* Work out which section the relocation is targetted at and the      initial relocation command value.  */
comment|/* Get symbol value.  (Common symbols are special.)  */
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
else|else
name|relocation
operator|=
name|symbol
operator|->
name|value
expr_stmt|;
name|reloc_target_output_section
operator|=
name|symbol
operator|->
name|section
operator|->
name|output_section
expr_stmt|;
comment|/* Convert input-section-relative symbol value to absolute.  */
if|if
condition|(
name|howto
operator|->
name|partial_inplace
operator|==
name|false
condition|)
name|output_base
operator|=
literal|0
expr_stmt|;
else|else
name|output_base
operator|=
name|reloc_target_output_section
operator|->
name|vma
expr_stmt|;
name|relocation
operator|+=
name|output_base
operator|+
name|symbol
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
comment|/* Add in supplied addend.  */
name|relocation
operator|+=
name|reloc_entry
operator|->
name|addend
expr_stmt|;
comment|/* Here the variable relocation holds the final address of the      symbol we are relocating against, plus any addend.  */
if|if
condition|(
name|howto
operator|->
name|pc_relative
operator|==
name|true
condition|)
block|{
comment|/* This is a PC relative relocation.  We want to set RELOCATION 	 to the distance between the address of the symbol and the 	 location.  RELOCATION is already the address of the symbol.  	 We start by subtracting the address of the section containing 	 the location.  	 If pcrel_offset is set, we must further subtract the position 	 of the location within the section.  Some targets arrange for 	 the addend to be the negative of the position of the location 	 within the section; for example, i386-aout does this.  For 	 i386-aout, pcrel_offset is false.  Some other targets do not 	 include the position of the location; for example, m88kbcs, 	 or ELF.  For those targets, pcrel_offset is true.  	 If we are producing relocateable output, then we must ensure 	 that this reloc will be correctly computed when the final 	 relocation is done.  If pcrel_offset is false we want to wind 	 up with the negative of the location within the section, 	 which means we must adjust the existing addend by the change 	 in the location within the section.  If pcrel_offset is true 	 we do not want to adjust the existing addend at all.  	 FIXME: This seems logical to me, but for the case of 	 producing relocateable output it is not what the code 	 actually does.  I don't want to change it, because it seems 	 far too likely that something will break.  */
name|relocation
operator|-=
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
expr_stmt|;
if|if
condition|(
name|howto
operator|->
name|pcrel_offset
operator|==
name|true
operator|&&
name|howto
operator|->
name|partial_inplace
operator|==
name|true
condition|)
name|relocation
operator|-=
name|reloc_entry
operator|->
name|address
expr_stmt|;
block|}
if|if
condition|(
name|howto
operator|->
name|partial_inplace
operator|==
name|false
condition|)
block|{
comment|/* This is a partial relocation, and we want to apply the relocation 	 to the reloc entry rather than the raw data. Modify the reloc 	 inplace to reflect what we now know.  */
name|reloc_entry
operator|->
name|addend
operator|=
name|relocation
expr_stmt|;
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|flag
return|;
block|}
else|else
block|{
comment|/* This is a partial relocation, but inplace, so modify the 	 reloc record a bit.  	 If we've relocated with a symbol with a section, change 	 into a ref to the section belonging to the symbol.  */
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
comment|/* WTF?? */
if|if
condition|(
name|abfd
operator|->
name|xvec
operator|->
name|flavour
operator|==
name|bfd_target_coff_flavour
operator|&&
name|strcmp
argument_list|(
name|abfd
operator|->
name|xvec
operator|->
name|name
argument_list|,
literal|"aixcoff-rs6000"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|abfd
operator|->
name|xvec
operator|->
name|name
argument_list|,
literal|"xcoff-powermac"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|abfd
operator|->
name|xvec
operator|->
name|name
argument_list|,
literal|"coff-Intel-little"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|abfd
operator|->
name|xvec
operator|->
name|name
argument_list|,
literal|"coff-Intel-big"
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|#
directive|if
literal|1
comment|/* For m68k-coff, the addend was being subtracted twice during    relocation with -r.  Removing the line below this comment    fixes that problem; see PR 2953.  However, Ian wrote the following, regarding removing the line below, which explains why it is still enabled:  --djm  If you put a patch like that into BFD you need to check all the COFF linkers.  I am fairly certain that patch will break coff-i386 (e.g., SCO); see coff_i386_reloc in coff-i386.c where I worked around the problem in a different way.  There may very well be a reason that the code works as it does.  Hmmm.  The first obvious point is that bfd_install_relocation should not have any tests that depend upon the flavour.  It's seem like entirely the wrong place for such a thing.  The second obvious point is that the current code ignores the reloc addend when producing relocateable output for COFF.  That's peculiar.  In fact, I really have no idea what the point of the line you want to remove is.  A typical COFF reloc subtracts the old value of the symbol and adds in the new value to the location in the object file (if it's a pc relative reloc it adds the difference between the symbol value and the location).  When relocating we need to preserve that property.  BFD handles this by setting the addend to the negative of the old value of the symbol.  Unfortunately it handles common symbols in a non-standard way (it doesn't subtract the old value) but that's a different story (we can't change it without losing backward compatibility with old object files) (coff-i386 does subtract the old value, to be compatible with existing coff-i386 targets, like SCO).  So everything works fine when not producing relocateable output.  When we are producing relocateable output, logically we should do exactly what we do when not producing relocateable output.  Therefore, your patch is correct.  In fact, it should probably always just set reloc_entry->addend to 0 for all cases, since it is, in fact, going to add the value into the object file.  This won't hurt the COFF code, which doesn't use the addend; I'm not sure what it will do to other formats (the thing to check for would be whether any formats both use the addend and set partial_inplace).  When I wanted to make coff-i386 produce relocateable output, I ran into the problem that you are running into: I wanted to remove that line.  Rather than risk it, I made the coff-i386 relocs use a special function; it's coff_i386_reloc in coff-i386.c.  The function specifically adds the addend field into the object file, knowing that bfd_install_relocation is not going to.  If you remove that line, then coff-i386.c will wind up adding the addend field in twice.  It's trivial to fix; it just needs to be done.  The problem with removing the line is just that it may break some working code.  With BFD it's hard to be sure of anything.  The right way to deal with this is simply to build and test at least all the supported COFF targets.  It should be straightforward if time and disk space consuming.  For each target:     1) build the linker     2) generate some executable, and link it using -r (I would        probably use paranoia.o and link against newlib/libc.a, which        for all the supported targets would be available in        /usr/cygnus/progressive/H-host/target/lib/libc.a).     3) make the change to reloc.c     4) rebuild the linker     5) repeat step 2     6) if the resulting object files are the same, you have at least        made it no worse     7) if they are different you have to figure out which version is        right */
name|relocation
operator|-=
name|reloc_entry
operator|->
name|addend
expr_stmt|;
endif|#
directive|endif
name|reloc_entry
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|reloc_entry
operator|->
name|addend
operator|=
name|relocation
expr_stmt|;
block|}
block|}
comment|/* FIXME: This overflow checking is incomplete, because the value      might have overflowed before we get here.  For a correct check we      need to compute the value in a size larger than bitsize, but we      can't reasonably do that for a reloc the same size as a host      machine word.       FIXME: We should also do overflow checking on the result after      adding in the value contained in the object file.  */
if|if
condition|(
name|howto
operator|->
name|complain_on_overflow
operator|!=
name|complain_overflow_dont
condition|)
block|{
name|bfd_vma
name|check
decl_stmt|;
comment|/* Get the value that will be used for the relocation, but 	 starting at bit position zero.  */
name|check
operator|=
name|relocation
operator|>>
name|howto
operator|->
name|rightshift
expr_stmt|;
switch|switch
condition|(
name|howto
operator|->
name|complain_on_overflow
condition|)
block|{
case|case
name|complain_overflow_signed
case|:
block|{
comment|/* Assumes two's complement.  */
name|bfd_signed_vma
name|reloc_signed_max
init|=
operator|(
literal|1
operator|<<
operator|(
name|howto
operator|->
name|bitsize
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
decl_stmt|;
name|bfd_signed_vma
name|reloc_signed_min
init|=
operator|~
name|reloc_signed_max
decl_stmt|;
comment|/* The above right shift is incorrect for a signed value. 	       Fix it up by forcing on the upper bits.  */
if|if
condition|(
name|howto
operator|->
name|rightshift
operator|>
literal|0
operator|&&
operator|(
name|bfd_signed_vma
operator|)
name|relocation
operator|<
literal|0
condition|)
name|check
operator||=
operator|(
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|&
operator|~
operator|(
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|>>
name|howto
operator|->
name|rightshift
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|bfd_signed_vma
operator|)
name|check
operator|>
name|reloc_signed_max
operator|||
operator|(
name|bfd_signed_vma
operator|)
name|check
operator|<
name|reloc_signed_min
condition|)
name|flag
operator|=
name|bfd_reloc_overflow
expr_stmt|;
block|}
break|break;
case|case
name|complain_overflow_unsigned
case|:
block|{
comment|/* Assumes two's complement.  This expression avoids 	       overflow if howto->bitsize is the number of bits in 	       bfd_vma.  */
name|bfd_vma
name|reloc_unsigned_max
init|=
operator|(
operator|(
operator|(
literal|1
operator|<<
operator|(
name|howto
operator|->
name|bitsize
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
operator|<<
literal|1
operator|)
operator||
literal|1
decl_stmt|;
if|if
condition|(
operator|(
name|bfd_vma
operator|)
name|check
operator|>
name|reloc_unsigned_max
condition|)
name|flag
operator|=
name|bfd_reloc_overflow
expr_stmt|;
block|}
break|break;
case|case
name|complain_overflow_bitfield
case|:
block|{
comment|/* Assumes two's complement.  This expression avoids 	       overflow if howto->bitsize is the number of bits in 	       bfd_vma.  */
name|bfd_vma
name|reloc_bits
init|=
operator|(
operator|(
operator|(
literal|1
operator|<<
operator|(
name|howto
operator|->
name|bitsize
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
operator|<<
literal|1
operator|)
operator||
literal|1
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|bfd_vma
operator|)
name|check
operator|&
operator|~
name|reloc_bits
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|bfd_vma
operator|)
name|check
operator|&
operator|~
name|reloc_bits
operator|)
operator|!=
operator|(
operator|-
literal|1
operator|&
operator|~
name|reloc_bits
operator|)
condition|)
block|{
comment|/* The above right shift is incorrect for a signed 		   value.  See if turning on the upper bits fixes the 		   overflow.  */
if|if
condition|(
name|howto
operator|->
name|rightshift
operator|>
literal|0
operator|&&
operator|(
name|bfd_signed_vma
operator|)
name|relocation
operator|<
literal|0
condition|)
block|{
name|check
operator||=
operator|(
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|&
operator|~
operator|(
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|>>
name|howto
operator|->
name|rightshift
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|bfd_vma
operator|)
name|check
operator|&
operator|~
name|reloc_bits
operator|)
operator|!=
operator|(
operator|-
literal|1
operator|&
operator|~
name|reloc_bits
operator|)
condition|)
name|flag
operator|=
name|bfd_reloc_overflow
expr_stmt|;
block|}
else|else
name|flag
operator|=
name|bfd_reloc_overflow
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/*     Either we are relocating all the way, or we don't want to apply     the relocation to the reloc entry (probably because there isn't     any room in the output format to describe addends to relocs)     */
comment|/* The cast to bfd_vma avoids a bug in the Alpha OSF/1 C compiler      (OSF version 1.3, compiler version 3.11).  It miscompiles the      following program:       struct str      {        unsigned int i0;      } s = { 0 };       int      main ()      {        unsigned long x;         x = 0x100000000;        x<<= (unsigned long) s.i0;        if (x == 0) 	 printf ("failed\n");        else 	 printf ("succeeded (%lx)\n", x);      }      */
name|relocation
operator|>>=
operator|(
name|bfd_vma
operator|)
name|howto
operator|->
name|rightshift
expr_stmt|;
comment|/* Shift everything up to where it's going to be used */
name|relocation
operator|<<=
operator|(
name|bfd_vma
operator|)
name|howto
operator|->
name|bitpos
expr_stmt|;
comment|/* Wait for the day when all have the mask in them */
comment|/* What we do:      i instruction to be left alone      o offset within instruction      r relocation offset to apply      S src mask      D dst mask      N ~dst mask      A part 1      B part 2      R result       Do this:      i i i i i o o o o o        from bfd_get<size>      and           S S S S S    to get the size offset we want      +   r r r r r r r r r r  to get the final value to place      and           D D D D D  to chop to right size      -----------------------      A A A A A      And this:      ...   i i i i i o o o o o  from bfd_get<size>      and   N N N N N            get instruction      -----------------------      ...   B B B B B       And then:      B B B B B      or              A A A A A      -----------------------      R R R R R R R R R R        put into bfd_put<size>      */
define|#
directive|define
name|DOIT
parameter_list|(
name|x
parameter_list|)
define|\
value|x = ( (x& ~howto->dst_mask) | (((x& howto->src_mask) +  relocation)& howto->dst_mask))
name|data
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|data_start
operator|+
operator|(
name|addr
operator|-
name|data_start_offset
operator|)
expr_stmt|;
switch|switch
condition|(
name|howto
operator|->
name|size
condition|)
block|{
case|case
literal|0
case|:
block|{
name|char
name|x
init|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
decl_stmt|;
name|DOIT
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|x
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|1
case|:
block|{
name|short
name|x
init|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
argument_list|)
decl_stmt|;
name|DOIT
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|x
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
block|{
name|long
name|x
init|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
argument_list|)
decl_stmt|;
name|DOIT
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|x
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
operator|-
literal|2
case|:
block|{
name|long
name|x
init|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
argument_list|)
decl_stmt|;
name|relocation
operator|=
operator|-
name|relocation
expr_stmt|;
name|DOIT
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|x
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|3
case|:
comment|/* Do nothing */
break|break;
case|case
literal|4
case|:
block|{
name|bfd_vma
name|x
init|=
name|bfd_get_64
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
argument_list|)
decl_stmt|;
name|DOIT
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|bfd_put_64
argument_list|(
name|abfd
argument_list|,
name|x
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
return|return
name|bfd_reloc_other
return|;
block|}
return|return
name|flag
return|;
block|}
end_function

begin_comment
comment|/* This relocation routine is used by some of the backend linkers.    They do not construct asymbol or arelent structures, so there is no    reason for them to use bfd_perform_relocation.  Also,    bfd_perform_relocation is so hacked up it is easier to write a new    function than to try to deal with it.     This routine does a final relocation.  It should not be used when    generating relocateable output.     FIXME: This routine ignores any special_function in the HOWTO,    since the existing special_function values have been written for    bfd_perform_relocation.     HOWTO is the reloc howto information.    INPUT_BFD is the BFD which the reloc applies to.    INPUT_SECTION is the section which the reloc applies to.    CONTENTS is the contents of the section.    ADDRESS is the address of the reloc within INPUT_SECTION.    VALUE is the value of the symbol the reloc refers to.    ADDEND is the addend of the reloc.  */
end_comment

begin_function
name|bfd_reloc_status_type
name|_bfd_final_link_relocate
parameter_list|(
name|howto
parameter_list|,
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|contents
parameter_list|,
name|address
parameter_list|,
name|value
parameter_list|,
name|addend
parameter_list|)
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|bfd_vma
name|address
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|;
block|{
name|bfd_vma
name|relocation
decl_stmt|;
comment|/* Sanity check the address.  */
if|if
condition|(
name|address
operator|>
name|input_section
operator|->
name|_raw_size
condition|)
return|return
name|bfd_reloc_outofrange
return|;
comment|/* This function assumes that we are dealing with a basic relocation      against a symbol.  We want to compute the value of the symbol to      relocate to.  This is just VALUE, the value of the symbol, plus      ADDEND, any addend associated with the reloc.  */
name|relocation
operator|=
name|value
operator|+
name|addend
expr_stmt|;
comment|/* If the relocation is PC relative, we want to set RELOCATION to      the distance between the symbol (currently in RELOCATION) and the      location we are relocating.  Some targets (e.g., i386-aout)      arrange for the contents of the section to be the negative of the      offset of the location within the section; for such targets      pcrel_offset is false.  Other targets (e.g., m88kbcs or ELF)      simply leave the contents of the section as zero; for such      targets pcrel_offset is true.  If pcrel_offset is false we do not      need to subtract out the offset of the location within the      section (which is just ADDRESS).  */
if|if
condition|(
name|howto
operator|->
name|pc_relative
condition|)
block|{
name|relocation
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
if|if
condition|(
name|howto
operator|->
name|pcrel_offset
condition|)
name|relocation
operator|-=
name|address
expr_stmt|;
block|}
return|return
name|_bfd_relocate_contents
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|relocation
argument_list|,
name|contents
operator|+
name|address
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Relocate a given location using a given value and howto.  */
end_comment

begin_function
name|bfd_reloc_status_type
name|_bfd_relocate_contents
parameter_list|(
name|howto
parameter_list|,
name|input_bfd
parameter_list|,
name|relocation
parameter_list|,
name|location
parameter_list|)
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_byte
modifier|*
name|location
decl_stmt|;
block|{
name|int
name|size
decl_stmt|;
name|bfd_vma
name|x
decl_stmt|;
name|boolean
name|overflow
decl_stmt|;
comment|/* If the size is negative, negate RELOCATION.  This isn't very      general.  */
if|if
condition|(
name|howto
operator|->
name|size
operator|<
literal|0
condition|)
name|relocation
operator|=
operator|-
name|relocation
expr_stmt|;
comment|/* Get the value we are going to relocate.  */
name|size
operator|=
name|bfd_get_reloc_size
argument_list|(
name|howto
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
default|default:
case|case
literal|0
case|:
name|abort
argument_list|()
expr_stmt|;
case|case
literal|1
case|:
name|x
operator|=
name|bfd_get_8
argument_list|(
name|input_bfd
argument_list|,
name|location
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|x
operator|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|location
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|x
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|location
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
ifdef|#
directive|ifdef
name|BFD64
name|x
operator|=
name|bfd_get_64
argument_list|(
name|input_bfd
argument_list|,
name|location
argument_list|)
expr_stmt|;
else|#
directive|else
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
comment|/* Check for overflow.  FIXME: We may drop bits during the addition      which we don't check for.  We must either check at every single      operation, which would be tedious, or we must do the computations      in a type larger than bfd_vma, which would be inefficient.  */
name|overflow
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|howto
operator|->
name|complain_on_overflow
operator|!=
name|complain_overflow_dont
condition|)
block|{
name|bfd_vma
name|check
decl_stmt|;
name|bfd_signed_vma
name|signed_check
decl_stmt|;
name|bfd_vma
name|add
decl_stmt|;
name|bfd_signed_vma
name|signed_add
decl_stmt|;
if|if
condition|(
name|howto
operator|->
name|rightshift
operator|==
literal|0
condition|)
block|{
name|check
operator|=
name|relocation
expr_stmt|;
name|signed_check
operator|=
operator|(
name|bfd_signed_vma
operator|)
name|relocation
expr_stmt|;
block|}
else|else
block|{
comment|/* Drop unwanted bits from the value we are relocating to.  */
name|check
operator|=
name|relocation
operator|>>
name|howto
operator|->
name|rightshift
expr_stmt|;
comment|/* If this is a signed value, the rightshift just dropped 	     leading 1 bits (assuming twos complement).  */
if|if
condition|(
operator|(
name|bfd_signed_vma
operator|)
name|relocation
operator|>=
literal|0
condition|)
name|signed_check
operator|=
name|check
expr_stmt|;
else|else
name|signed_check
operator|=
operator|(
name|check
operator||
operator|(
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|&
operator|~
operator|(
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|>>
name|howto
operator|->
name|rightshift
operator|)
operator|)
operator|)
expr_stmt|;
block|}
comment|/* Get the value from the object file.  */
name|add
operator|=
name|x
operator|&
name|howto
operator|->
name|src_mask
expr_stmt|;
comment|/* Get the value from the object file with an appropriate sign. 	 The expression involving howto->src_mask isolates the upper 	 bit of src_mask.  If that bit is set in the value we are 	 adding, it is negative, and we subtract out that number times 	 two.  If src_mask includes the highest possible bit, then we 	 can not get the upper bit, but that does not matter since 	 signed_add needs no adjustment to become negative in that 	 case.  */
name|signed_add
operator|=
name|add
expr_stmt|;
if|if
condition|(
operator|(
name|add
operator|&
operator|(
operator|(
operator|(
operator|~
name|howto
operator|->
name|src_mask
operator|)
operator|>>
literal|1
operator|)
operator|&
name|howto
operator|->
name|src_mask
operator|)
operator|)
operator|!=
literal|0
condition|)
name|signed_add
operator|-=
operator|(
operator|(
operator|(
operator|~
name|howto
operator|->
name|src_mask
operator|)
operator|>>
literal|1
operator|)
operator|&
name|howto
operator|->
name|src_mask
operator|)
operator|<<
literal|1
expr_stmt|;
comment|/* Add the value from the object file, shifted so that it is a 	 straight number.  */
if|if
condition|(
name|howto
operator|->
name|bitpos
operator|==
literal|0
condition|)
block|{
name|check
operator|+=
name|add
expr_stmt|;
name|signed_check
operator|+=
name|signed_add
expr_stmt|;
block|}
else|else
block|{
name|check
operator|+=
name|add
operator|>>
name|howto
operator|->
name|bitpos
expr_stmt|;
comment|/* For the signed case we use ADD, rather than SIGNED_ADD, 	     to avoid warnings from SVR4 cc.  This is OK since we 	     explictly handle the sign bits.  */
if|if
condition|(
name|signed_add
operator|>=
literal|0
condition|)
name|signed_check
operator|+=
name|add
operator|>>
name|howto
operator|->
name|bitpos
expr_stmt|;
else|else
name|signed_check
operator|+=
operator|(
operator|(
name|add
operator|>>
name|howto
operator|->
name|bitpos
operator|)
operator||
operator|(
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|&
operator|~
operator|(
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|>>
name|howto
operator|->
name|bitpos
operator|)
operator|)
operator|)
expr_stmt|;
block|}
switch|switch
condition|(
name|howto
operator|->
name|complain_on_overflow
condition|)
block|{
case|case
name|complain_overflow_signed
case|:
block|{
comment|/* Assumes two's complement.  */
name|bfd_signed_vma
name|reloc_signed_max
init|=
operator|(
literal|1
operator|<<
operator|(
name|howto
operator|->
name|bitsize
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
decl_stmt|;
name|bfd_signed_vma
name|reloc_signed_min
init|=
operator|~
name|reloc_signed_max
decl_stmt|;
if|if
condition|(
name|signed_check
operator|>
name|reloc_signed_max
operator|||
name|signed_check
operator|<
name|reloc_signed_min
condition|)
name|overflow
operator|=
name|true
expr_stmt|;
block|}
break|break;
case|case
name|complain_overflow_unsigned
case|:
block|{
comment|/* Assumes two's complement.  This expression avoids 	       overflow if howto->bitsize is the number of bits in 	       bfd_vma.  */
name|bfd_vma
name|reloc_unsigned_max
init|=
operator|(
operator|(
operator|(
literal|1
operator|<<
operator|(
name|howto
operator|->
name|bitsize
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
operator|<<
literal|1
operator|)
operator||
literal|1
decl_stmt|;
if|if
condition|(
name|check
operator|>
name|reloc_unsigned_max
condition|)
name|overflow
operator|=
name|true
expr_stmt|;
block|}
break|break;
case|case
name|complain_overflow_bitfield
case|:
block|{
comment|/* Assumes two's complement.  This expression avoids 	       overflow if howto->bitsize is the number of bits in 	       bfd_vma.  */
name|bfd_vma
name|reloc_bits
init|=
operator|(
operator|(
operator|(
literal|1
operator|<<
operator|(
name|howto
operator|->
name|bitsize
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
operator|<<
literal|1
operator|)
operator||
literal|1
decl_stmt|;
if|if
condition|(
operator|(
name|check
operator|&
operator|~
name|reloc_bits
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
operator|(
name|bfd_vma
operator|)
name|signed_check
operator|&
operator|~
name|reloc_bits
operator|)
operator|!=
operator|(
operator|-
literal|1
operator|&
operator|~
name|reloc_bits
operator|)
operator|)
condition|)
name|overflow
operator|=
name|true
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Put RELOCATION in the right bits.  */
name|relocation
operator|>>=
operator|(
name|bfd_vma
operator|)
name|howto
operator|->
name|rightshift
expr_stmt|;
name|relocation
operator|<<=
operator|(
name|bfd_vma
operator|)
name|howto
operator|->
name|bitpos
expr_stmt|;
comment|/* Add RELOCATION to the right bits of X.  */
name|x
operator|=
operator|(
operator|(
name|x
operator|&
operator|~
name|howto
operator|->
name|dst_mask
operator|)
operator||
operator|(
operator|(
operator|(
name|x
operator|&
name|howto
operator|->
name|src_mask
operator|)
operator|+
name|relocation
operator|)
operator|&
name|howto
operator|->
name|dst_mask
operator|)
operator|)
expr_stmt|;
comment|/* Put the relocated value back in the object file.  */
switch|switch
condition|(
name|size
condition|)
block|{
default|default:
case|case
literal|0
case|:
name|abort
argument_list|()
expr_stmt|;
case|case
literal|1
case|:
name|bfd_put_8
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|location
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|location
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|location
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
ifdef|#
directive|ifdef
name|BFD64
name|bfd_put_64
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|location
argument_list|)
expr_stmt|;
else|#
directive|else
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
return|return
name|overflow
condition|?
name|bfd_reloc_overflow
else|:
name|bfd_reloc_ok
return|;
block|}
end_function

begin_comment
comment|/* DOCDD INODE 	howto manager,  , typedef arelent, Relocations  SECTION 	The howto manager  	When an application wants to create a relocation, but doesn't 	know what the target machine might call it, it can find out by 	using this bit of code.  */
end_comment

begin_comment
comment|/* TYPEDEF 	bfd_reloc_code_type  DESCRIPTION 	The insides of a reloc code.  The idea is that, eventually, there 	will be one enumerator for every type of relocation we ever do. 	Pass one of these values to<<bfd_reloc_type_lookup>>, and it'll 	return a howto pointer.  	This does mean that the application must determine the correct 	enumerator value; you can't get a howto pointer from a random set 	of attributes.  SENUM    bfd_reloc_code_real  ENUM   BFD_RELOC_64 ENUMX   BFD_RELOC_32 ENUMX   BFD_RELOC_26 ENUMX   BFD_RELOC_24 ENUMX   BFD_RELOC_16 ENUMX   BFD_RELOC_14 ENUMX   BFD_RELOC_8 ENUMDOC   Basic absolute relocations of N bits.  ENUM   BFD_RELOC_64_PCREL ENUMX   BFD_RELOC_32_PCREL ENUMX   BFD_RELOC_24_PCREL ENUMX   BFD_RELOC_16_PCREL ENUMX   BFD_RELOC_12_PCREL ENUMX   BFD_RELOC_8_PCREL ENUMDOC   PC-relative relocations.  Sometimes these are relative to the address of the relocation itself; sometimes they are relative to the start of the section containing the relocation.  It depends on the specific target.  The 24-bit relocation is used in some Intel 960 configurations.  ENUM   BFD_RELOC_32_GOT_PCREL ENUMX   BFD_RELOC_16_GOT_PCREL ENUMX   BFD_RELOC_8_GOT_PCREL ENUMX   BFD_RELOC_32_GOTOFF ENUMX   BFD_RELOC_16_GOTOFF ENUMX   BFD_RELOC_LO16_GOTOFF ENUMX   BFD_RELOC_HI16_GOTOFF ENUMX   BFD_RELOC_HI16_S_GOTOFF ENUMX   BFD_RELOC_8_GOTOFF ENUMX   BFD_RELOC_32_PLT_PCREL ENUMX   BFD_RELOC_24_PLT_PCREL ENUMX   BFD_RELOC_16_PLT_PCREL ENUMX   BFD_RELOC_8_PLT_PCREL ENUMX   BFD_RELOC_32_PLTOFF ENUMX   BFD_RELOC_16_PLTOFF ENUMX   BFD_RELOC_LO16_PLTOFF ENUMX   BFD_RELOC_HI16_PLTOFF ENUMX   BFD_RELOC_HI16_S_PLTOFF ENUMX   BFD_RELOC_8_PLTOFF ENUMDOC   For ELF.  ENUM   BFD_RELOC_68K_GLOB_DAT ENUMX   BFD_RELOC_68K_JMP_SLOT ENUMX   BFD_RELOC_68K_RELATIVE ENUMDOC   Relocations used by 68K ELF.  ENUM   BFD_RELOC_32_BASEREL ENUMX   BFD_RELOC_16_BASEREL ENUMX   BFD_RELOC_LO16_BASEREL ENUMX   BFD_RELOC_HI16_BASEREL ENUMX   BFD_RELOC_HI16_S_BASEREL ENUMX   BFD_RELOC_8_BASEREL ENUMX   BFD_RELOC_RVA ENUMDOC   Linkage-table relative.  ENUM   BFD_RELOC_8_FFnn ENUMDOC   Absolute 8-bit relocation, but used to form an address like 0xFFnn.  ENUM   BFD_RELOC_32_PCREL_S2 ENUMX   BFD_RELOC_16_PCREL_S2 ENUMX   BFD_RELOC_23_PCREL_S2 ENUMDOC   These PC-relative relocations are stored as word displacements -- i.e., byte displacements shifted right two bits.  The 30-bit word displacement (<<32_PCREL_S2>> -- 32 bits, shifted 2) is used on the SPARC.  (SPARC tools generally refer to this as<<WDISP30>>.)  The signed 16-bit displacement is used on the MIPS, and the 23-bit displacement is used on the Alpha.  ENUM   BFD_RELOC_HI22 ENUMX   BFD_RELOC_LO10 ENUMDOC   High 22 bits and low 10 bits of 32-bit value, placed into lower bits of the target word.  These are used on the SPARC.  ENUM   BFD_RELOC_GPREL16 ENUMX   BFD_RELOC_GPREL32 ENUMDOC   For systems that allocate a Global Pointer register, these are displacements off that register.  These relocation types are handled specially, because the value the register will have is decided relatively late.   ENUM   BFD_RELOC_I960_CALLJ ENUMDOC   Reloc types used for i960/b.out.  ENUM   BFD_RELOC_NONE ENUMX   BFD_RELOC_SPARC_WDISP22 ENUMX   BFD_RELOC_SPARC22 ENUMX   BFD_RELOC_SPARC13 ENUMX   BFD_RELOC_SPARC_GOT10 ENUMX   BFD_RELOC_SPARC_GOT13 ENUMX   BFD_RELOC_SPARC_GOT22 ENUMX   BFD_RELOC_SPARC_PC10 ENUMX   BFD_RELOC_SPARC_PC22 ENUMX   BFD_RELOC_SPARC_WPLT30 ENUMX   BFD_RELOC_SPARC_COPY ENUMX   BFD_RELOC_SPARC_GLOB_DAT ENUMX   BFD_RELOC_SPARC_JMP_SLOT ENUMX   BFD_RELOC_SPARC_RELATIVE ENUMX   BFD_RELOC_SPARC_UA32 ENUMDOC   SPARC ELF relocations.  There is probably some overlap with other   relocation types already defined.  ENUM   BFD_RELOC_SPARC_BASE13 ENUMX   BFD_RELOC_SPARC_BASE22 ENUMDOC   I think these are specific to SPARC a.out (e.g., Sun 4).  ENUMEQ   BFD_RELOC_SPARC_64   BFD_RELOC_64 ENUMX   BFD_RELOC_SPARC_10 ENUMX   BFD_RELOC_SPARC_11 ENUMX   BFD_RELOC_SPARC_OLO10 ENUMX   BFD_RELOC_SPARC_HH22 ENUMX   BFD_RELOC_SPARC_HM10 ENUMX   BFD_RELOC_SPARC_LM22 ENUMX   BFD_RELOC_SPARC_PC_HH22 ENUMX   BFD_RELOC_SPARC_PC_HM10 ENUMX   BFD_RELOC_SPARC_PC_LM22 ENUMX   BFD_RELOC_SPARC_WDISP16 ENUMX   BFD_RELOC_SPARC_WDISP19 ENUMX   BFD_RELOC_SPARC_GLOB_JMP ENUMX   BFD_RELOC_SPARC_7 ENUMX   BFD_RELOC_SPARC_6 ENUMX   BFD_RELOC_SPARC_5 ENUMDOC   Some relocations we're using for SPARC V9 -- subject to change.  ENUM   BFD_RELOC_ALPHA_GPDISP_HI16 ENUMDOC   Alpha ECOFF and ELF relocations.  Some of these treat the symbol or      "addend" in some special way.   For GPDISP_HI16 ("gpdisp") relocations, the symbol is ignored when      writing; when reading, it will be the absolute section symbol.  The      addend is the displacement in bytes of the "lda" instruction from      the "ldah" instruction (which is at the address of this reloc). ENUM   BFD_RELOC_ALPHA_GPDISP_LO16 ENUMDOC   For GPDISP_LO16 ("ignore") relocations, the symbol is handled as      with GPDISP_HI16 relocs.  The addend is ignored when writing the      relocations out, and is filled in with the file's GP value on      reading, for convenience.  ENUM   BFD_RELOC_ALPHA_GPDISP ENUMDOC   The ELF GPDISP relocation is exactly the same as the GPDISP_HI16      relocation except that there is no accompanying GPDISP_LO16      relocation.  ENUM   BFD_RELOC_ALPHA_LITERAL ENUMX   BFD_RELOC_ALPHA_ELF_LITERAL ENUMX   BFD_RELOC_ALPHA_LITUSE ENUMDOC   The Alpha LITERAL/LITUSE relocs are produced by a symbol reference;      the assembler turns it into a LDQ instruction to load the address of      the symbol, and then fills in a register in the real instruction.       The LITERAL reloc, at the LDQ instruction, refers to the .lita      section symbol.  The addend is ignored when writing, but is filled      in with the file's GP value on reading, for convenience, as with the      GPDISP_LO16 reloc.       The ELF_LITERAL reloc is somewhere between 16_GOTOFF and GPDISP_LO16.      It should refer to the symbol to be referenced, as with 16_GOTOFF,      but it generates output not based on the position within the .got      section, but relative to the GP value chosen for the file during the      final link stage.       The LITUSE reloc, on the instruction using the loaded address, gives      information to the linker that it might be able to use to optimize      away some literal section references.  The symbol is ignored (read      as the absolute section symbol), and the "addend" indicates the type      of instruction using the register:               1 - "memory" fmt insn               2 - byte-manipulation (byte offset reg)               3 - jsr (target of branch)       The GNU linker currently doesn't do any of this optimizing.  ENUM   BFD_RELOC_ALPHA_HINT ENUMDOC   The HINT relocation indicates a value that should be filled into the      "hint" field of a jmp/jsr/ret instruction, for possible branch-      prediction logic which may be provided on some processors.  ENUM   BFD_RELOC_ALPHA_LINKAGE ENUMDOC   The LINKAGE relocation outputs a linkage pair in the object file,      which is filled by the linker.  ENUM   BFD_RELOC_ALPHA_CODEADDR ENUMDOC   The CODEADDR relocation outputs a STO_CA in the object file,      which is filled by the linker.  ENUM   BFD_RELOC_MIPS_JMP ENUMDOC   Bits 27..2 of the relocation address shifted right 2 bits;      simple reloc otherwise.  ENUM   BFD_RELOC_MIPS16_JMP ENUMDOC   The MIPS16 jump instruction.  ENUM   BFD_RELOC_MIPS16_GPREL ENUMDOC   MIPS16 GP relative reloc.  ENUM   BFD_RELOC_HI16 ENUMDOC   High 16 bits of 32-bit value; simple reloc. ENUM   BFD_RELOC_HI16_S ENUMDOC   High 16 bits of 32-bit value but the low 16 bits will be sign      extended and added to form the final result.  If the low 16      bits form a negative number, we need to add one to the high value      to compensate for the borrow when the low bits are added. ENUM   BFD_RELOC_LO16 ENUMDOC   Low 16 bits. ENUM   BFD_RELOC_PCREL_HI16_S ENUMDOC   Like BFD_RELOC_HI16_S, but PC relative. ENUM   BFD_RELOC_PCREL_LO16 ENUMDOC   Like BFD_RELOC_LO16, but PC relative.  ENUMEQ   BFD_RELOC_MIPS_GPREL   BFD_RELOC_GPREL16 ENUMDOC   Relocation relative to the global pointer.  ENUM   BFD_RELOC_MIPS_LITERAL ENUMDOC   Relocation against a MIPS literal section.  ENUM   BFD_RELOC_MIPS_GOT16 ENUMX   BFD_RELOC_MIPS_CALL16 ENUMEQX   BFD_RELOC_MIPS_GPREL32   BFD_RELOC_GPREL32 ENUMX   BFD_RELOC_MIPS_GOT_HI16 ENUMX   BFD_RELOC_MIPS_GOT_LO16 ENUMX   BFD_RELOC_MIPS_CALL_HI16 ENUMX   BFD_RELOC_MIPS_CALL_LO16 ENUMDOC   MIPS ELF relocations.  ENUM   BFD_RELOC_386_GOT32 ENUMX   BFD_RELOC_386_PLT32 ENUMX   BFD_RELOC_386_COPY ENUMX   BFD_RELOC_386_GLOB_DAT ENUMX   BFD_RELOC_386_JUMP_SLOT ENUMX   BFD_RELOC_386_RELATIVE ENUMX   BFD_RELOC_386_GOTOFF ENUMX   BFD_RELOC_386_GOTPC ENUMDOC   i386/elf relocations  ENUM   BFD_RELOC_NS32K_IMM_8 ENUMX   BFD_RELOC_NS32K_IMM_16 ENUMX   BFD_RELOC_NS32K_IMM_32 ENUMX   BFD_RELOC_NS32K_IMM_8_PCREL ENUMX   BFD_RELOC_NS32K_IMM_16_PCREL ENUMX   BFD_RELOC_NS32K_IMM_32_PCREL ENUMX   BFD_RELOC_NS32K_DISP_8 ENUMX   BFD_RELOC_NS32K_DISP_16 ENUMX   BFD_RELOC_NS32K_DISP_32 ENUMX   BFD_RELOC_NS32K_DISP_8_PCREL ENUMX   BFD_RELOC_NS32K_DISP_16_PCREL ENUMX   BFD_RELOC_NS32K_DISP_32_PCREL ENUMDOC   ns32k relocations  ENUM   BFD_RELOC_PPC_B26 ENUMX   BFD_RELOC_PPC_BA26 ENUMX   BFD_RELOC_PPC_TOC16 ENUMX   BFD_RELOC_PPC_B16 ENUMX   BFD_RELOC_PPC_B16_BRTAKEN ENUMX   BFD_RELOC_PPC_B16_BRNTAKEN ENUMX   BFD_RELOC_PPC_BA16 ENUMX   BFD_RELOC_PPC_BA16_BRTAKEN ENUMX   BFD_RELOC_PPC_BA16_BRNTAKEN ENUMX   BFD_RELOC_PPC_COPY ENUMX   BFD_RELOC_PPC_GLOB_DAT ENUMX   BFD_RELOC_PPC_JMP_SLOT ENUMX   BFD_RELOC_PPC_RELATIVE ENUMX   BFD_RELOC_PPC_LOCAL24PC ENUMX   BFD_RELOC_PPC_EMB_NADDR32 ENUMX   BFD_RELOC_PPC_EMB_NADDR16 ENUMX   BFD_RELOC_PPC_EMB_NADDR16_LO ENUMX   BFD_RELOC_PPC_EMB_NADDR16_HI ENUMX   BFD_RELOC_PPC_EMB_NADDR16_HA ENUMX   BFD_RELOC_PPC_EMB_SDAI16 ENUMX   BFD_RELOC_PPC_EMB_SDA2I16 ENUMX   BFD_RELOC_PPC_EMB_SDA2REL ENUMX   BFD_RELOC_PPC_EMB_SDA21 ENUMX   BFD_RELOC_PPC_EMB_MRKREF ENUMX   BFD_RELOC_PPC_EMB_RELSEC16 ENUMX   BFD_RELOC_PPC_EMB_RELST_LO ENUMX   BFD_RELOC_PPC_EMB_RELST_HI ENUMX   BFD_RELOC_PPC_EMB_RELST_HA ENUMX   BFD_RELOC_PPC_EMB_BIT_FLD ENUMX   BFD_RELOC_PPC_EMB_RELSDA ENUMDOC   Power(rs6000) and PowerPC relocations.  ENUM   BFD_RELOC_CTOR ENUMDOC   The type of reloc used to build a contructor table - at the moment   probably a 32 bit wide absolute relocation, but the target can choose.   It generally does map to one of the other relocation types.  ENUM   BFD_RELOC_ARM_PCREL_BRANCH ENUMDOC   ARM 26 bit pc-relative branch.  The lowest two bits must be zero and are   not stored in the instruction. ENUM   BFD_RELOC_ARM_IMMEDIATE ENUMX   BFD_RELOC_ARM_OFFSET_IMM ENUMX   BFD_RELOC_ARM_SHIFT_IMM ENUMX   BFD_RELOC_ARM_SWI ENUMX   BFD_RELOC_ARM_MULTI ENUMX   BFD_RELOC_ARM_CP_OFF_IMM ENUMX   BFD_RELOC_ARM_ADR_IMM ENUMX   BFD_RELOC_ARM_LDR_IMM ENUMX   BFD_RELOC_ARM_LITERAL ENUMX   BFD_RELOC_ARM_IN_POOL ENUMX   BFD_RELOC_ARM_OFFSET_IMM8 ENUMX   BFD_RELOC_ARM_HWLITERAL ENUMX   BFD_RELOC_ARM_THUMB_ADD ENUMX   BFD_RELOC_ARM_THUMB_IMM ENUMX   BFD_RELOC_ARM_THUMB_SHIFT ENUMX   BFD_RELOC_ARM_THUMB_OFFSET ENUMDOC   These relocs are only used within the ARM assembler.  They are not   (at present) written to any object files.  ENUM   BFD_RELOC_SH_PCDISP8BY2 ENUMX   BFD_RELOC_SH_PCDISP12BY2 ENUMX   BFD_RELOC_SH_IMM4 ENUMX   BFD_RELOC_SH_IMM4BY2 ENUMX   BFD_RELOC_SH_IMM4BY4 ENUMX   BFD_RELOC_SH_IMM8 ENUMX   BFD_RELOC_SH_IMM8BY2 ENUMX   BFD_RELOC_SH_IMM8BY4 ENUMX   BFD_RELOC_SH_PCRELIMM8BY2 ENUMX   BFD_RELOC_SH_PCRELIMM8BY4 ENUMX   BFD_RELOC_SH_SWITCH16 ENUMX   BFD_RELOC_SH_SWITCH32 ENUMX   BFD_RELOC_SH_USES ENUMX   BFD_RELOC_SH_COUNT ENUMX   BFD_RELOC_SH_ALIGN ENUMX   BFD_RELOC_SH_CODE ENUMX   BFD_RELOC_SH_DATA ENUMX   BFD_RELOC_SH_LABEL ENUMDOC   Hitachi SH relocs.  Not all of these appear in object files.  COMMENT  COMMENT ENUM   BFD_RELOC_D10V_10_PCREL_R ENUMDOC   Mitsubishi D10V relocs.   This is a 10-bit reloc with the right 2 bits   assumed to be 0. ENUM   BFD_RELOC_D10V_10_PCREL_L ENUMDOC   Mitsubishi D10V relocs.   This is a 10-bit reloc with the right 2 bits   assumed to be 0.  This is the same as the previous reloc   except it is in the left container, i.e.,   shifted left 15 bits. ENUM   BFD_RELOC_D10V_18 ENUMDOC   This is an 18-bit reloc with the right 2 bits   assumed to be 0. ENUM   BFD_RELOC_D10V_18_PCREL ENUMDOC   This is an 18-bit reloc with the right 2 bits   assumed to be 0. COMMENT  COMMENT  ENUM   BFD_RELOC_M32R_24 ENUMDOC   Mitsubishi M32R relocs.   This is a 24 bit absolute address. ENUM   BFD_RELOC_M32R_10_PCREL ENUMDOC   This is a 10-bit pc-relative reloc with the right 2 bits assumed to be 0. ENUM   BFD_RELOC_M32R_18_PCREL ENUMDOC   This is an 18-bit reloc with the right 2 bits assumed to be 0. ENUM   BFD_RELOC_M32R_26_PCREL ENUMDOC   This is a 26-bit reloc with the right 2 bits assumed to be 0. ENUM   BFD_RELOC_M32R_HI16_ULO ENUMDOC   This is a 16-bit reloc containing the high 16 bits of an address   used when the lower 16 bits are treated as unsigned. ENUM   BFD_RELOC_M32R_HI16_SLO ENUMDOC   This is a 16-bit reloc containing the high 16 bits of an address   used when the lower 16 bits are treated as signed. ENUM   BFD_RELOC_M32R_LO16 ENUMDOC   This is a 16-bit reloc containing the lower 16 bits of an address. ENUM   BFD_RELOC_M32R_SDA16 ENUMDOC   This is a 16-bit reloc containing the small data area offset for use in   add3, load, and store instructions.  COMMENT  ENUM   BFD_RELOC_MN10300_32_PCREL ENUMDOC   This is a 32bit pcrel reloc for the mn10300, offset by two bytes in the   instruction. ENUM   BFD_RELOC_MN10300_16_PCREL ENUMDOC   This is a 16bit pcrel reloc for the mn10300, offset by two bytes in the   instruction. ENDSENUM   BFD_RELOC_UNUSED CODE_FRAGMENT . .typedef enum bfd_reloc_code_real bfd_reloc_code_real_type; */
end_comment

begin_comment
comment|/* FUNCTION 	bfd_reloc_type_lookup  SYNOPSIS 	reloc_howto_type * 	bfd_reloc_type_lookup (bfd *abfd, bfd_reloc_code_real_type code);  DESCRIPTION 	Return a pointer to a howto structure which, when 	invoked, will perform the relocation @var{code} on data from the 	architecture noted.  */
end_comment

begin_function
name|reloc_howto_type
modifier|*
name|bfd_reloc_type_lookup
parameter_list|(
name|abfd
parameter_list|,
name|code
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
block|{
return|return
name|BFD_SEND
argument_list|(
name|abfd
argument_list|,
name|reloc_type_lookup
argument_list|,
operator|(
name|abfd
operator|,
name|code
operator|)
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|bfd_howto_32
init|=
name|HOWTO
argument_list|(
literal|0
argument_list|,
literal|00
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"VRT32"
argument_list|,
name|false
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|true
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* INTERNAL_FUNCTION 	bfd_default_reloc_type_lookup  SYNOPSIS 	reloc_howto_type *bfd_default_reloc_type_lookup 	(bfd *abfd, bfd_reloc_code_real_type  code);  DESCRIPTION 	Provides a default relocation lookup routine for any architecture.   */
end_comment

begin_function
name|reloc_howto_type
modifier|*
name|bfd_default_reloc_type_lookup
parameter_list|(
name|abfd
parameter_list|,
name|code
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|BFD_RELOC_CTOR
case|:
comment|/* The type of reloc used in a ctor, which will be as wide as the 	 address - so either a 64, 32, or 16 bitter.  */
switch|switch
condition|(
name|bfd_get_arch_info
argument_list|(
name|abfd
argument_list|)
operator|->
name|bits_per_address
condition|)
block|{
case|case
literal|64
case|:
name|BFD_FAIL
argument_list|()
expr_stmt|;
case|case
literal|32
case|:
return|return
operator|&
name|bfd_howto_32
return|;
case|case
literal|16
case|:
name|BFD_FAIL
argument_list|()
expr_stmt|;
default|default:
name|BFD_FAIL
argument_list|()
expr_stmt|;
block|}
default|default:
name|BFD_FAIL
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|reloc_howto_type
operator|*
operator|)
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* FUNCTION 	bfd_get_reloc_code_name  SYNOPSIS 	const char *bfd_get_reloc_code_name (bfd_reloc_code_real_type code);  DESCRIPTION 	Provides a printable name for the supplied relocation code. 	Useful mainly for printing error messages. */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|bfd_get_reloc_code_name
parameter_list|(
name|code
parameter_list|)
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
block|{
if|if
condition|(
name|code
operator|>
name|BFD_RELOC_UNUSED
condition|)
return|return
literal|0
return|;
return|return
name|bfd_reloc_code_real_names
index|[
operator|(
name|int
operator|)
name|code
index|]
return|;
block|}
end_function

begin_comment
comment|/* INTERNAL_FUNCTION 	bfd_generic_relax_section  SYNOPSIS 	boolean bfd_generic_relax_section 	 (bfd *abfd, 	  asection *section, 	  struct bfd_link_info *, 	  boolean *);  DESCRIPTION 	Provides default handling for relaxing for back ends which 	don't do relaxing -- i.e., does nothing. */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|boolean
name|bfd_generic_relax_section
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|link_info
parameter_list|,
name|again
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|link_info
decl_stmt|;
name|boolean
modifier|*
name|again
decl_stmt|;
block|{
operator|*
name|again
operator|=
name|false
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* INTERNAL_FUNCTION 	bfd_generic_get_relocated_section_contents  SYNOPSIS 	bfd_byte * 	   bfd_generic_get_relocated_section_contents (bfd *abfd, 	     struct bfd_link_info *link_info, 	     struct bfd_link_order *link_order, 	     bfd_byte *data, 	     boolean relocateable, 	     asymbol **symbols);  DESCRIPTION 	Provides default handling of relocation effort for back ends 	which can't be bothered to do it efficiently.  */
end_comment

begin_function
name|bfd_byte
modifier|*
name|bfd_generic_get_relocated_section_contents
parameter_list|(
name|abfd
parameter_list|,
name|link_info
parameter_list|,
name|link_order
parameter_list|,
name|data
parameter_list|,
name|relocateable
parameter_list|,
name|symbols
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|link_info
decl_stmt|;
name|struct
name|bfd_link_order
modifier|*
name|link_order
decl_stmt|;
name|bfd_byte
modifier|*
name|data
decl_stmt|;
name|boolean
name|relocateable
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
block|{
comment|/* Get enough memory to hold the stuff */
name|bfd
modifier|*
name|input_bfd
init|=
name|link_order
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
operator|->
name|owner
decl_stmt|;
name|asection
modifier|*
name|input_section
init|=
name|link_order
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
decl_stmt|;
name|long
name|reloc_size
init|=
name|bfd_get_reloc_upper_bound
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|reloc_vector
init|=
name|NULL
decl_stmt|;
name|long
name|reloc_count
decl_stmt|;
if|if
condition|(
name|reloc_size
operator|<
literal|0
condition|)
goto|goto
name|error_return
goto|;
name|reloc_vector
operator|=
operator|(
name|arelent
operator|*
operator|*
operator|)
name|bfd_malloc
argument_list|(
operator|(
name|size_t
operator|)
name|reloc_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc_vector
operator|==
name|NULL
operator|&&
name|reloc_size
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
comment|/* read in the section */
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
name|PTR
operator|)
name|data
argument_list|,
literal|0
argument_list|,
name|input_section
operator|->
name|_raw_size
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* We're not relaxing the section, so just copy the size info */
name|input_section
operator|->
name|_cooked_size
operator|=
name|input_section
operator|->
name|_raw_size
expr_stmt|;
name|input_section
operator|->
name|reloc_done
operator|=
name|true
expr_stmt|;
name|reloc_count
operator|=
name|bfd_canonicalize_reloc
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|reloc_vector
argument_list|,
name|symbols
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc_count
operator|<
literal|0
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|reloc_count
operator|>
literal|0
condition|)
block|{
name|arelent
modifier|*
modifier|*
name|parent
decl_stmt|;
for|for
control|(
name|parent
operator|=
name|reloc_vector
init|;
operator|*
name|parent
operator|!=
operator|(
name|arelent
operator|*
operator|)
name|NULL
condition|;
name|parent
operator|++
control|)
block|{
name|char
modifier|*
name|error_message
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
name|bfd_reloc_status_type
name|r
init|=
name|bfd_perform_relocation
argument_list|(
name|input_bfd
argument_list|,
operator|*
name|parent
argument_list|,
operator|(
name|PTR
operator|)
name|data
argument_list|,
name|input_section
argument_list|,
name|relocateable
condition|?
name|abfd
else|:
operator|(
name|bfd
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|error_message
argument_list|)
decl_stmt|;
if|if
condition|(
name|relocateable
condition|)
block|{
name|asection
modifier|*
name|os
init|=
name|input_section
operator|->
name|output_section
decl_stmt|;
comment|/* A partial link, so keep the relocs */
name|os
operator|->
name|orelocation
index|[
name|os
operator|->
name|reloc_count
index|]
operator|=
operator|*
name|parent
expr_stmt|;
name|os
operator|->
name|reloc_count
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|!=
name|bfd_reloc_ok
condition|)
block|{
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|bfd_reloc_undefined
case|:
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|link_info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|link_info
argument_list|,
name|bfd_asymbol_name
argument_list|(
operator|*
operator|(
operator|*
name|parent
operator|)
operator|->
name|sym_ptr_ptr
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
operator|*
name|parent
operator|)
operator|->
name|address
argument_list|)
operator|)
condition|)
goto|goto
name|error_return
goto|;
break|break;
case|case
name|bfd_reloc_dangerous
case|:
name|BFD_ASSERT
argument_list|(
name|error_message
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|link_info
operator|->
name|callbacks
operator|->
name|reloc_dangerous
call|)
argument_list|(
name|link_info
argument_list|,
name|error_message
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
operator|*
name|parent
operator|)
operator|->
name|address
argument_list|)
operator|)
condition|)
goto|goto
name|error_return
goto|;
break|break;
case|case
name|bfd_reloc_overflow
case|:
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|link_info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|link_info
argument_list|,
name|bfd_asymbol_name
argument_list|(
operator|*
operator|(
operator|*
name|parent
operator|)
operator|->
name|sym_ptr_ptr
argument_list|)
argument_list|,
operator|(
operator|*
name|parent
operator|)
operator|->
name|howto
operator|->
name|name
argument_list|,
operator|(
operator|*
name|parent
operator|)
operator|->
name|addend
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
operator|*
name|parent
operator|)
operator|->
name|address
argument_list|)
operator|)
condition|)
goto|goto
name|error_return
goto|;
break|break;
case|case
name|bfd_reloc_outofrange
case|:
default|default:
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
name|reloc_vector
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|reloc_vector
argument_list|)
expr_stmt|;
return|return
name|data
return|;
name|error_return
label|:
if|if
condition|(
name|reloc_vector
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|reloc_vector
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

end_unit

