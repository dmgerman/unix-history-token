begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* MIPS-specific support for 64-bit ELF    Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002    Free Software Foundation, Inc.    Ian Lance Taylor, Cygnus Support    Linker support added by Mark Mitchell, CodeSourcery, LLC.<mark@codesourcery.com>  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file supports the 64-bit MIPS ELF ABI.     The MIPS 64-bit ELF ABI uses an unusual reloc format.  This file    overrides the usual ELF reloc handling, and handles reading and    writing the relocations here.  */
end_comment

begin_comment
comment|/* TODO: Many things are unsupported, even if there is some code for it  .       (which was mostly stolen from elf32-mips.c and slightly adapted).  .  .   - Relocation handling for REL relocs is wrong in many cases and  .     generally untested.  .   - Relocation handling for RELA relocs related to GOT support are  .     also likely to be wrong.  .   - Support for MIPS16 is only partially implemented.  .   - Embedded PIC  is only partially implemented (is it needed?).  .   - Combined relocs with RSS_* entries are unsupported.  .   - The whole GOT handling for NewABI is missing, some parts of  .     the OldABI version is still lying around and shold be removed.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"aout/ar.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"genlink.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf/mips.h"
end_include

begin_comment
comment|/* Get the ECOFF swapping routines.  The 64-bit ABI is not supposed to    use ECOFF.  However, we support it anyhow for an easier changeover.  */
end_comment

begin_include
include|#
directive|include
file|"coff/sym.h"
end_include

begin_include
include|#
directive|include
file|"coff/symconst.h"
end_include

begin_include
include|#
directive|include
file|"coff/internal.h"
end_include

begin_include
include|#
directive|include
file|"coff/ecoff.h"
end_include

begin_comment
comment|/* The 64 bit versions of the mdebug data structures are in alpha.h.  */
end_comment

begin_include
include|#
directive|include
file|"coff/alpha.h"
end_include

begin_define
define|#
directive|define
name|ECOFF_SIGNED_64
end_define

begin_include
include|#
directive|include
file|"ecoffswap.h"
end_include

begin_struct_decl
struct_decl|struct
name|mips_elf64_link_hash_entry
struct_decl|;
end_struct_decl

begin_decl_stmt
specifier|static
name|void
name|mips_elf64_swap_reloc_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf64_Mips_External_Rel
operator|*
operator|,
name|Elf64_Mips_Internal_Rel
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mips_elf64_swap_reloca_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf64_Mips_External_Rela
operator|*
operator|,
name|Elf64_Mips_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mips_elf64_swap_reloc_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf64_Mips_Internal_Rel
operator|*
operator|,
name|Elf64_Mips_External_Rel
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mips_elf64_swap_reloca_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf64_Mips_Internal_Rela
operator|*
operator|,
name|Elf64_Mips_External_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mips_elf64_be_swap_reloc_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|bfd_byte
operator|*
operator|,
name|Elf_Internal_Rel
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mips_elf64_be_swap_reloc_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf_Internal_Rel
operator|*
operator|,
name|bfd_byte
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mips_elf64_be_swap_reloca_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|bfd_byte
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mips_elf64_be_swap_reloca_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
operator|,
name|bfd_byte
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|mips_elf64_high
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|mips_elf64_higher
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|mips_elf64_highest
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
modifier|*
name|mips_elf64_reloc_type_lookup
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd_reloc_code_real_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mips_elf64_info_to_howto_rel
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|Elf64_Internal_Rel
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mips_elf64_info_to_howto_rela
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|Elf64_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|mips_elf64_get_reloc_upper_bound
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|mips_elf64_slurp_one_reloc_table
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|asymbol
operator|*
operator|*
operator|,
specifier|const
name|Elf_Internal_Shdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|mips_elf64_slurp_reloc_table
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|asymbol
operator|*
operator|*
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mips_elf64_write_relocs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mips_elf64_write_rel
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|Elf_Internal_Shdr
operator|*
operator|,
name|int
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mips_elf64_write_rela
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|Elf_Internal_Shdr
operator|*
operator|,
name|int
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|mips_elf64_link_hash_newfunc
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|,
expr|struct
name|bfd_hash_table
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|mips_elf64_hi16_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|mips_elf64_higher_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|mips_elf64_highest_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|mips_elf64_gprel16_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|mips_elf64_gprel16_reloca
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|mips_elf64_literal_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|mips_elf64_gprel32_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|mips_elf64_shift6_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|mips_elf64_got16_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|mips_elf64_assign_gp
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd_vma
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|mips_elf64_final_gp
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|boolean
operator|,
name|char
operator|*
operator|*
operator|,
name|bfd_vma
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|gprel16_with_gp
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asection
operator|*
operator|,
name|boolean
operator|,
name|PTR
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mips_elf64_additional_program_headers
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bfd_link_hash_table
modifier|*
name|mips_elf64_link_hash_table_create
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|mips_elf64_got_offset_from_index
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mips_elf64_got_info
modifier|*
name|_mips_elf64_got_info
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|mips_elf64_sign_extend
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|mips_elf64_overflow_p
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|mips_elf64_global_got_index
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|mips_elf64_sort_hash_table_f
name|PARAMS
argument_list|(
operator|(
expr|struct
name|mips_elf64_link_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|mips_elf64_sort_hash_table
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mips_elf64_swap_msym_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf32_Internal_Msym
operator|*
operator|,
name|Elf32_External_Msym
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|mips_elf64_create_local_got_entry
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
expr|struct
name|mips_elf64_got_info
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_vma
name|value
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|mips_elf64_local_got_index
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|mips_elf64_got_page
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd_vma
operator|,
name|bfd_vma
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|mips_elf64_got16_entry
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd_vma
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|mips_elf64_local_relocation_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
operator|,
name|asection
operator|*
operator|*
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|Elf_Internal_Rela
modifier|*
name|mips_elf64_next_relocation
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|mips_elf64_create_dynamic_relocation
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
operator|,
expr|struct
name|mips_elf64_link_hash_entry
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_vma
operator|,
name|bfd_vma
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|mips_elf64_calculate_relocation
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
operator|,
name|bfd_vma
operator|,
name|reloc_howto_type
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|,
name|asection
operator|*
operator|*
operator|,
name|bfd_vma
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|boolean
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|mips_elf64_obtain_contents
name|PARAMS
argument_list|(
operator|(
name|reloc_howto_type
operator|*
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
operator|,
name|bfd
operator|*
operator|,
name|bfd_byte
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|mips_elf64_perform_relocation
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
name|reloc_howto_type
operator|*
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
operator|,
name|bfd_vma
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|mips_elf64_relocate_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|,
name|asection
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|mips_elf64_create_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|mips_elf64_adjust_dynamic_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
name|h
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|mips_elf64_always_size_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|mips_elf64_check_mips16_stubs
name|PARAMS
argument_list|(
operator|(
expr|struct
name|mips_elf64_link_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|mips_elf64_size_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|mips_elf64_finish_dynamic_symbol
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|mips_elf64_finish_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|asection
modifier|*
name|mips_elf64_gc_mark_hook
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|mips_elf64_gc_sweep_hook
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|asection
operator|*
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|mips_elf64_create_got_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|mips_elf64_record_global_got_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|mips_elf64_got_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asection
modifier|*
name|mips_elf64_create_msym_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mips_elf64_allocate_dynamic_relocations
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|mips_elf64_stub_section_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|mips_elf64_check_relocs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|asection
operator|*
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|mips_elf64_output_extsym
name|PARAMS
argument_list|(
operator|(
expr|struct
name|mips_elf64_link_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mips_elf64_swap_gptab_in
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf32_External_gptab
operator|*
operator|,
name|Elf32_gptab
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mips_elf64_swap_gptab_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|Elf32_gptab
operator|*
operator|,
name|Elf32_External_gptab
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|gptab_compare
name|PARAMS
argument_list|(
operator|(
specifier|const
name|PTR
operator|,
specifier|const
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|mips_elf64_final_link
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
specifier|const
name|bfd_target
name|bfd_elf64_bigmips_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
specifier|const
name|bfd_target
name|bfd_elf64_littlemips_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|prev_reloc_addend
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_size_type
name|prev_reloc_address
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether we are trying to be compatible with IRIX6 (or little endianers    which are otherwise IRIX-ABI compliant).  */
end_comment

begin_define
define|#
directive|define
name|SGI_COMPAT
parameter_list|(
name|abfd
parameter_list|)
define|\
value|((abfd->xvec ==&bfd_elf64_bigmips_vec) \    || (abfd->xvec ==&bfd_elf64_littlemips_vec) ? true : false)
end_define

begin_comment
comment|/* In case we're on a 32-bit machine, construct a 64-bit "-1" value    from smaller values.  Start with zero, widen, *then* decrement.  */
end_comment

begin_define
define|#
directive|define
name|MINUS_ONE
value|(((bfd_vma)0) - 1)
end_define

begin_comment
comment|/* The number of local .got entries we reserve.  */
end_comment

begin_define
define|#
directive|define
name|MIPS_RESERVED_GOTNO
value|(2)
end_define

begin_comment
comment|/* Instructions which appear in a stub.  */
end_comment

begin_define
define|#
directive|define
name|ELF_MIPS_GP_OFFSET
parameter_list|(
name|abfd
parameter_list|)
value|0x7ff0
end_define

begin_define
define|#
directive|define
name|STUB_LW
value|0xdf998010
end_define

begin_comment
comment|/* ld t9,0x8010(gp) */
end_comment

begin_define
define|#
directive|define
name|STUB_MOVE
value|0x03e07825
end_define

begin_comment
comment|/* move t7,ra */
end_comment

begin_define
define|#
directive|define
name|STUB_JALR
value|0x0320f809
end_define

begin_comment
comment|/* jal t9 */
end_comment

begin_define
define|#
directive|define
name|STUB_LI16
value|0x34180000
end_define

begin_comment
comment|/* ori t8,zero,0 */
end_comment

begin_define
define|#
directive|define
name|MIPS_FUNCTION_STUB_SIZE
value|(16)
end_define

begin_comment
comment|/* The relocation table used for SHT_REL sections.  */
end_comment

begin_define
define|#
directive|define
name|UNUSED_RELOC
parameter_list|(
name|num
parameter_list|)
value|{ num, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
end_define

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|mips_elf64_howto_table_rel
index|[]
init|=
block|{
comment|/* No relocation.  */
name|HOWTO
argument_list|(
name|R_MIPS_NONE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_NONE"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16 bit relocation.  */
name|HOWTO
argument_list|(
name|R_MIPS_16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_16"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 32 bit relocation.  */
name|HOWTO
argument_list|(
name|R_MIPS_32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_32"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 32 bit symbol relative relocation.  */
name|HOWTO
argument_list|(
name|R_MIPS_REL32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_REL32"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 26 bit jump address.  */
name|HOWTO
argument_list|(
name|R_MIPS_26
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|26
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
comment|/* This needs complex overflow 				   detection, because the upper 36 				   bits must match the PC + 4.  */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_26"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0x03ffffff
argument_list|,
comment|/* src_mask */
literal|0x03ffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* High 16 bits of symbol value.  */
name|HOWTO
argument_list|(
name|R_MIPS_HI16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_HI16"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Low 16 bits of symbol value.  */
name|HOWTO
argument_list|(
name|R_MIPS_LO16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_LO16"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* GP relative reference.  */
name|HOWTO
argument_list|(
name|R_MIPS_GPREL16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|mips_elf64_gprel16_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_GPREL16"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Reference to literal section.  */
name|HOWTO
argument_list|(
name|R_MIPS_LITERAL
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|mips_elf64_literal_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_LITERAL"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Reference to global offset table.  */
name|HOWTO
argument_list|(
name|R_MIPS_GOT16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|mips_elf64_got16_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_GOT16"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16 bit PC relative reference.  */
name|HOWTO
argument_list|(
name|R_MIPS_PC16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_PC16"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16 bit call through global offset table.  */
comment|/* FIXME: This is not handled correctly.  */
name|HOWTO
argument_list|(
name|R_MIPS_CALL16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_CALL16"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 32 bit GP relative reference.  */
name|HOWTO
argument_list|(
name|R_MIPS_GPREL32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|mips_elf64_gprel32_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_GPREL32"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
name|UNUSED_RELOC
argument_list|(
literal|13
argument_list|)
block|,
name|UNUSED_RELOC
argument_list|(
literal|14
argument_list|)
block|,
name|UNUSED_RELOC
argument_list|(
literal|15
argument_list|)
block|,
comment|/* A 5 bit shift field.  */
name|HOWTO
argument_list|(
name|R_MIPS_SHIFT5
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|5
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|6
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_SHIFT5"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0x000007c0
argument_list|,
comment|/* src_mask */
literal|0x000007c0
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 6 bit shift field.  */
name|HOWTO
argument_list|(
name|R_MIPS_SHIFT6
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|6
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|6
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|mips_elf64_shift6_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_SHIFT6"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0x000007c4
argument_list|,
comment|/* src_mask */
literal|0x000007c4
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 64 bit relocation.  */
name|HOWTO
argument_list|(
name|R_MIPS_64
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_64"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
name|MINUS_ONE
argument_list|,
comment|/* src_mask */
name|MINUS_ONE
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Displacement in the global offset table.  */
comment|/* FIXME: Not handled correctly.  */
name|HOWTO
argument_list|(
name|R_MIPS_GOT_DISP
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_GOT_DISP"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Displacement to page pointer in the global offset table.  */
comment|/* FIXME: Not handled correctly.  */
name|HOWTO
argument_list|(
name|R_MIPS_GOT_PAGE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_GOT_PAGE"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Offset from page pointer in the global offset table.  */
comment|/* FIXME: Not handled correctly.  */
name|HOWTO
argument_list|(
name|R_MIPS_GOT_OFST
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_GOT_OFST"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* High 16 bits of displacement in global offset table.  */
comment|/* FIXME: Not handled correctly.  */
name|HOWTO
argument_list|(
name|R_MIPS_GOT_HI16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_GOT_HI16"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Low 16 bits of displacement in global offset table.  */
comment|/* FIXME: Not handled correctly.  */
name|HOWTO
argument_list|(
name|R_MIPS_GOT_LO16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_GOT_LO16"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 64 bit substraction.  */
comment|/* FIXME: Not handled correctly.  */
name|HOWTO
argument_list|(
name|R_MIPS_SUB
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_SUB"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
name|MINUS_ONE
argument_list|,
comment|/* src_mask */
name|MINUS_ONE
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Insert the addend as an instruction.  */
comment|/* FIXME: Not handled correctly.  */
name|HOWTO
argument_list|(
name|R_MIPS_INSERT_A
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_INSERT_A"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Insert the addend as an instruction, and change all relocations      to refer to the old instruction at the address.  */
comment|/* FIXME: Not handled correctly.  */
name|HOWTO
argument_list|(
name|R_MIPS_INSERT_B
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_INSERT_B"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Delete a 32 bit instruction.  */
comment|/* FIXME: Not handled correctly.  */
name|HOWTO
argument_list|(
name|R_MIPS_DELETE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_DELETE"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Get the higher value of a 64 bit addend.  */
name|HOWTO
argument_list|(
name|R_MIPS_HIGHER
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|mips_elf64_higher_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_HIGHER"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Get the highest value of a 64 bit addend.  */
name|HOWTO
argument_list|(
name|R_MIPS_HIGHEST
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|mips_elf64_highest_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_HIGHEST"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* High 16 bits of displacement in global offset table.  */
comment|/* FIXME: Not handled correctly.  */
name|HOWTO
argument_list|(
name|R_MIPS_CALL_HI16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_CALL_HI16"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Low 16 bits of displacement in global offset table.  */
comment|/* FIXME: Not handled correctly.  */
name|HOWTO
argument_list|(
name|R_MIPS_CALL_LO16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_CALL_LO16"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Section displacement, used by an associated event location section.  */
comment|/* FIXME: Not handled correctly.  */
name|HOWTO
argument_list|(
name|R_MIPS_SCN_DISP
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_SCN_DISP"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_MIPS_REL16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_REL16"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* These two are obsolete.  */
name|EMPTY_HOWTO
argument_list|(
name|R_MIPS_ADD_IMMEDIATE
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
name|R_MIPS_PJUMP
argument_list|)
block|,
comment|/* Similiar to R_MIPS_REL32, but used for relocations in a GOT section.      It must be used for multigot GOT's (and only there).  */
name|HOWTO
argument_list|(
name|R_MIPS_RELGOT
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_RELGOT"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Protected jump conversion.  This is an optimization hint.  No      relocation is required for correctness.  */
name|HOWTO
argument_list|(
name|R_MIPS_JALR
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_JALR"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x00000000
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The relocation table used for SHT_RELA sections.  */
end_comment

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|mips_elf64_howto_table_rela
index|[]
init|=
block|{
comment|/* No relocation.  */
name|HOWTO
argument_list|(
name|R_MIPS_NONE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_NONE"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16 bit relocation.  */
name|HOWTO
argument_list|(
name|R_MIPS_16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 32 bit relocation.  */
name|HOWTO
argument_list|(
name|R_MIPS_32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_32"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 32 bit symbol relative relocation.  */
name|HOWTO
argument_list|(
name|R_MIPS_REL32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_REL32"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 26 bit jump address.  */
name|HOWTO
argument_list|(
name|R_MIPS_26
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|26
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
comment|/* This needs complex overflow 				   detection, because the upper 36 				   bits must match the PC + 4.  */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_26"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x03ffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* R_MIPS_HI16 and R_MIPS_LO16 are unsupported for 64 bit REL.  */
comment|/* High 16 bits of symbol value.  */
name|HOWTO
argument_list|(
name|R_MIPS_HI16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_HI16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Low 16 bits of symbol value.  */
name|HOWTO
argument_list|(
name|R_MIPS_LO16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_LO16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* GP relative reference.  */
name|HOWTO
argument_list|(
name|R_MIPS_GPREL16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|mips_elf64_gprel16_reloca
argument_list|,
comment|/* special_function */
literal|"R_MIPS_GPREL16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Reference to literal section.  */
name|HOWTO
argument_list|(
name|R_MIPS_LITERAL
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|mips_elf64_literal_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_LITERAL"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Reference to global offset table.  */
comment|/* FIXME: This is not handled correctly.  */
name|HOWTO
argument_list|(
name|R_MIPS_GOT16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_GOT16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16 bit PC relative reference.  */
name|HOWTO
argument_list|(
name|R_MIPS_PC16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_PC16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 16 bit call through global offset table.  */
comment|/* FIXME: This is not handled correctly.  */
name|HOWTO
argument_list|(
name|R_MIPS_CALL16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_CALL16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 32 bit GP relative reference.  */
name|HOWTO
argument_list|(
name|R_MIPS_GPREL32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|mips_elf64_gprel32_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_GPREL32"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
name|UNUSED_RELOC
argument_list|(
literal|13
argument_list|)
block|,
name|UNUSED_RELOC
argument_list|(
literal|14
argument_list|)
block|,
name|UNUSED_RELOC
argument_list|(
literal|15
argument_list|)
block|,
comment|/* A 5 bit shift field.  */
name|HOWTO
argument_list|(
name|R_MIPS_SHIFT5
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|5
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|6
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_SHIFT5"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x000007c0
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 6 bit shift field.  */
name|HOWTO
argument_list|(
name|R_MIPS_SHIFT6
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|6
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|6
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|mips_elf64_shift6_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_SHIFT6"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x000007c4
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 64 bit relocation.  */
name|HOWTO
argument_list|(
name|R_MIPS_64
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_64"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
name|MINUS_ONE
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Displacement in the global offset table.  */
comment|/* FIXME: Not handled correctly.  */
name|HOWTO
argument_list|(
name|R_MIPS_GOT_DISP
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_GOT_DISP"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Displacement to page pointer in the global offset table.  */
comment|/* FIXME: Not handled correctly.  */
name|HOWTO
argument_list|(
name|R_MIPS_GOT_PAGE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_GOT_PAGE"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Offset from page pointer in the global offset table.  */
comment|/* FIXME: Not handled correctly.  */
name|HOWTO
argument_list|(
name|R_MIPS_GOT_OFST
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_GOT_OFST"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* High 16 bits of displacement in global offset table.  */
comment|/* FIXME: Not handled correctly.  */
name|HOWTO
argument_list|(
name|R_MIPS_GOT_HI16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_GOT_HI16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Low 16 bits of displacement in global offset table.  */
comment|/* FIXME: Not handled correctly.  */
name|HOWTO
argument_list|(
name|R_MIPS_GOT_LO16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_GOT_LO16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 64 bit substraction.  */
comment|/* FIXME: Not handled correctly.  */
name|HOWTO
argument_list|(
name|R_MIPS_SUB
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_SUB"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
name|MINUS_ONE
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Insert the addend as an instruction.  */
comment|/* FIXME: Not handled correctly.  */
name|HOWTO
argument_list|(
name|R_MIPS_INSERT_A
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_INSERT_A"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Insert the addend as an instruction, and change all relocations      to refer to the old instruction at the address.  */
comment|/* FIXME: Not handled correctly.  */
name|HOWTO
argument_list|(
name|R_MIPS_INSERT_B
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_INSERT_B"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Delete a 32 bit instruction.  */
comment|/* FIXME: Not handled correctly.  */
name|HOWTO
argument_list|(
name|R_MIPS_DELETE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_DELETE"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Get the higher value of a 64 bit addend.  */
name|HOWTO
argument_list|(
name|R_MIPS_HIGHER
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_HIGHER"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Get the highest value of a 64 bit addend.  */
name|HOWTO
argument_list|(
name|R_MIPS_HIGHEST
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_HIGHEST"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* High 16 bits of displacement in global offset table.  */
comment|/* FIXME: Not handled correctly.  */
name|HOWTO
argument_list|(
name|R_MIPS_CALL_HI16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_CALL_HI16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Low 16 bits of displacement in global offset table.  */
comment|/* FIXME: Not handled correctly.  */
name|HOWTO
argument_list|(
name|R_MIPS_CALL_LO16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_CALL_LO16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Section displacement, used by an associated event location section.  */
comment|/* FIXME: Not handled correctly.  */
name|HOWTO
argument_list|(
name|R_MIPS_SCN_DISP
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_SCN_DISP"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_MIPS_REL16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_REL16"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* These two are obsolete.  */
name|EMPTY_HOWTO
argument_list|(
name|R_MIPS_ADD_IMMEDIATE
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
name|R_MIPS_PJUMP
argument_list|)
block|,
comment|/* Similiar to R_MIPS_REL32, but used for relocations in a GOT section.      It must be used for multigot GOT's (and only there).  */
name|HOWTO
argument_list|(
name|R_MIPS_RELGOT
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_RELGOT"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Protected jump conversion.  This is an optimization hint.  No      relocation is required for correctness.  */
name|HOWTO
argument_list|(
name|R_MIPS_JALR
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MIPS_JALR"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x00000000
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Swap in a MIPS 64-bit Rel reloc.  */
end_comment

begin_function
specifier|static
name|void
name|mips_elf64_swap_reloc_in
parameter_list|(
name|abfd
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|Elf64_Mips_External_Rel
modifier|*
name|src
decl_stmt|;
name|Elf64_Mips_Internal_Rel
modifier|*
name|dst
decl_stmt|;
block|{
name|dst
operator|->
name|r_offset
operator|=
name|H_GET_64
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|dst
operator|->
name|r_sym
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|r_sym
argument_list|)
expr_stmt|;
name|dst
operator|->
name|r_ssym
operator|=
name|H_GET_8
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|r_ssym
argument_list|)
expr_stmt|;
name|dst
operator|->
name|r_type3
operator|=
name|H_GET_8
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|r_type3
argument_list|)
expr_stmt|;
name|dst
operator|->
name|r_type2
operator|=
name|H_GET_8
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|r_type2
argument_list|)
expr_stmt|;
name|dst
operator|->
name|r_type
operator|=
name|H_GET_8
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|r_type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Swap in a MIPS 64-bit Rela reloc.  */
end_comment

begin_function
specifier|static
name|void
name|mips_elf64_swap_reloca_in
parameter_list|(
name|abfd
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|Elf64_Mips_External_Rela
modifier|*
name|src
decl_stmt|;
name|Elf64_Mips_Internal_Rela
modifier|*
name|dst
decl_stmt|;
block|{
name|dst
operator|->
name|r_offset
operator|=
name|H_GET_64
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|dst
operator|->
name|r_sym
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|r_sym
argument_list|)
expr_stmt|;
name|dst
operator|->
name|r_ssym
operator|=
name|H_GET_8
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|r_ssym
argument_list|)
expr_stmt|;
name|dst
operator|->
name|r_type3
operator|=
name|H_GET_8
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|r_type3
argument_list|)
expr_stmt|;
name|dst
operator|->
name|r_type2
operator|=
name|H_GET_8
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|r_type2
argument_list|)
expr_stmt|;
name|dst
operator|->
name|r_type
operator|=
name|H_GET_8
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|r_type
argument_list|)
expr_stmt|;
name|dst
operator|->
name|r_addend
operator|=
name|H_GET_S64
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|r_addend
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Swap out a MIPS 64-bit Rel reloc.  */
end_comment

begin_function
specifier|static
name|void
name|mips_elf64_swap_reloc_out
parameter_list|(
name|abfd
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|Elf64_Mips_Internal_Rel
modifier|*
name|src
decl_stmt|;
name|Elf64_Mips_External_Rel
modifier|*
name|dst
decl_stmt|;
block|{
name|H_PUT_64
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|r_offset
argument_list|,
name|dst
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|r_sym
argument_list|,
name|dst
operator|->
name|r_sym
argument_list|)
expr_stmt|;
name|H_PUT_8
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|r_ssym
argument_list|,
name|dst
operator|->
name|r_ssym
argument_list|)
expr_stmt|;
name|H_PUT_8
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|r_type3
argument_list|,
name|dst
operator|->
name|r_type3
argument_list|)
expr_stmt|;
name|H_PUT_8
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|r_type2
argument_list|,
name|dst
operator|->
name|r_type2
argument_list|)
expr_stmt|;
name|H_PUT_8
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|r_type
argument_list|,
name|dst
operator|->
name|r_type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Swap out a MIPS 64-bit Rela reloc.  */
end_comment

begin_function
specifier|static
name|void
name|mips_elf64_swap_reloca_out
parameter_list|(
name|abfd
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|Elf64_Mips_Internal_Rela
modifier|*
name|src
decl_stmt|;
name|Elf64_Mips_External_Rela
modifier|*
name|dst
decl_stmt|;
block|{
name|H_PUT_64
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|r_offset
argument_list|,
name|dst
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|r_sym
argument_list|,
name|dst
operator|->
name|r_sym
argument_list|)
expr_stmt|;
name|H_PUT_8
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|r_ssym
argument_list|,
name|dst
operator|->
name|r_ssym
argument_list|)
expr_stmt|;
name|H_PUT_8
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|r_type3
argument_list|,
name|dst
operator|->
name|r_type3
argument_list|)
expr_stmt|;
name|H_PUT_8
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|r_type2
argument_list|,
name|dst
operator|->
name|r_type2
argument_list|)
expr_stmt|;
name|H_PUT_8
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|r_type
argument_list|,
name|dst
operator|->
name|r_type
argument_list|)
expr_stmt|;
name|H_PUT_S64
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|r_addend
argument_list|,
name|dst
operator|->
name|r_addend
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Swap in a MIPS 64-bit Rel reloc.  */
end_comment

begin_function
specifier|static
name|void
name|mips_elf64_be_swap_reloc_in
parameter_list|(
name|abfd
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|bfd_byte
modifier|*
name|src
decl_stmt|;
name|Elf_Internal_Rel
modifier|*
name|dst
decl_stmt|;
block|{
name|Elf64_Mips_Internal_Rel
name|mirel
decl_stmt|;
name|mips_elf64_swap_reloc_in
argument_list|(
name|abfd
argument_list|,
operator|(
specifier|const
name|Elf64_Mips_External_Rel
operator|*
operator|)
name|src
argument_list|,
operator|&
name|mirel
argument_list|)
expr_stmt|;
name|dst
index|[
literal|0
index|]
operator|.
name|r_offset
operator|=
name|mirel
operator|.
name|r_offset
expr_stmt|;
name|dst
index|[
literal|0
index|]
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|mirel
operator|.
name|r_sym
argument_list|,
name|mirel
operator|.
name|r_type
argument_list|)
expr_stmt|;
name|dst
index|[
literal|1
index|]
operator|.
name|r_offset
operator|=
name|mirel
operator|.
name|r_offset
expr_stmt|;
name|dst
index|[
literal|1
index|]
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|mirel
operator|.
name|r_ssym
argument_list|,
name|mirel
operator|.
name|r_type2
argument_list|)
expr_stmt|;
name|dst
index|[
literal|2
index|]
operator|.
name|r_offset
operator|=
name|mirel
operator|.
name|r_offset
expr_stmt|;
name|dst
index|[
literal|2
index|]
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|STN_UNDEF
argument_list|,
name|mirel
operator|.
name|r_type3
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Swap in a MIPS 64-bit Rela reloc.  */
end_comment

begin_function
specifier|static
name|void
name|mips_elf64_be_swap_reloca_in
parameter_list|(
name|abfd
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|bfd_byte
modifier|*
name|src
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|dst
decl_stmt|;
block|{
name|Elf64_Mips_Internal_Rela
name|mirela
decl_stmt|;
name|mips_elf64_swap_reloca_in
argument_list|(
name|abfd
argument_list|,
operator|(
specifier|const
name|Elf64_Mips_External_Rela
operator|*
operator|)
name|src
argument_list|,
operator|&
name|mirela
argument_list|)
expr_stmt|;
name|dst
index|[
literal|0
index|]
operator|.
name|r_offset
operator|=
name|mirela
operator|.
name|r_offset
expr_stmt|;
name|dst
index|[
literal|0
index|]
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|mirela
operator|.
name|r_sym
argument_list|,
name|mirela
operator|.
name|r_type
argument_list|)
expr_stmt|;
name|dst
index|[
literal|0
index|]
operator|.
name|r_addend
operator|=
name|mirela
operator|.
name|r_addend
expr_stmt|;
name|dst
index|[
literal|1
index|]
operator|.
name|r_offset
operator|=
name|mirela
operator|.
name|r_offset
expr_stmt|;
name|dst
index|[
literal|1
index|]
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|mirela
operator|.
name|r_ssym
argument_list|,
name|mirela
operator|.
name|r_type2
argument_list|)
expr_stmt|;
name|dst
index|[
literal|1
index|]
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
name|dst
index|[
literal|2
index|]
operator|.
name|r_offset
operator|=
name|mirela
operator|.
name|r_offset
expr_stmt|;
name|dst
index|[
literal|2
index|]
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|STN_UNDEF
argument_list|,
name|mirela
operator|.
name|r_type3
argument_list|)
expr_stmt|;
name|dst
index|[
literal|2
index|]
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Swap out a MIPS 64-bit Rel reloc.  */
end_comment

begin_function
specifier|static
name|void
name|mips_elf64_be_swap_reloc_out
parameter_list|(
name|abfd
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|Elf_Internal_Rel
modifier|*
name|src
decl_stmt|;
name|bfd_byte
modifier|*
name|dst
decl_stmt|;
block|{
name|Elf64_Mips_Internal_Rel
name|mirel
decl_stmt|;
name|mirel
operator|.
name|r_offset
operator|=
name|src
index|[
literal|0
index|]
operator|.
name|r_offset
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|src
index|[
literal|0
index|]
operator|.
name|r_offset
operator|==
name|src
index|[
literal|1
index|]
operator|.
name|r_offset
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|src
index|[
literal|0
index|]
operator|.
name|r_offset
operator|==
name|src
index|[
literal|2
index|]
operator|.
name|r_offset
argument_list|)
expr_stmt|;
name|mirel
operator|.
name|r_type
operator|=
name|ELF64_MIPS_R_TYPE
argument_list|(
name|src
index|[
literal|0
index|]
operator|.
name|r_info
argument_list|)
expr_stmt|;
name|mirel
operator|.
name|r_sym
operator|=
name|ELF64_R_SYM
argument_list|(
name|src
index|[
literal|0
index|]
operator|.
name|r_info
argument_list|)
expr_stmt|;
name|mirel
operator|.
name|r_type2
operator|=
name|ELF64_MIPS_R_TYPE2
argument_list|(
name|src
index|[
literal|1
index|]
operator|.
name|r_info
argument_list|)
expr_stmt|;
name|mirel
operator|.
name|r_ssym
operator|=
name|ELF64_MIPS_R_SSYM
argument_list|(
name|src
index|[
literal|1
index|]
operator|.
name|r_info
argument_list|)
expr_stmt|;
name|mirel
operator|.
name|r_type3
operator|=
name|ELF64_MIPS_R_TYPE3
argument_list|(
name|src
index|[
literal|2
index|]
operator|.
name|r_info
argument_list|)
expr_stmt|;
name|mips_elf64_swap_reloc_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|mirel
argument_list|,
operator|(
name|Elf64_Mips_External_Rel
operator|*
operator|)
name|dst
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Swap out a MIPS 64-bit Rela reloc.  */
end_comment

begin_function
specifier|static
name|void
name|mips_elf64_be_swap_reloca_out
parameter_list|(
name|abfd
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|src
decl_stmt|;
name|bfd_byte
modifier|*
name|dst
decl_stmt|;
block|{
name|Elf64_Mips_Internal_Rela
name|mirela
decl_stmt|;
name|mirela
operator|.
name|r_offset
operator|=
name|src
index|[
literal|0
index|]
operator|.
name|r_offset
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|src
index|[
literal|0
index|]
operator|.
name|r_offset
operator|==
name|src
index|[
literal|1
index|]
operator|.
name|r_offset
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|src
index|[
literal|0
index|]
operator|.
name|r_offset
operator|==
name|src
index|[
literal|2
index|]
operator|.
name|r_offset
argument_list|)
expr_stmt|;
name|mirela
operator|.
name|r_type
operator|=
name|ELF64_MIPS_R_TYPE
argument_list|(
name|src
index|[
literal|0
index|]
operator|.
name|r_info
argument_list|)
expr_stmt|;
name|mirela
operator|.
name|r_sym
operator|=
name|ELF64_R_SYM
argument_list|(
name|src
index|[
literal|0
index|]
operator|.
name|r_info
argument_list|)
expr_stmt|;
name|mirela
operator|.
name|r_addend
operator|=
name|src
index|[
literal|0
index|]
operator|.
name|r_addend
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|src
index|[
literal|1
index|]
operator|.
name|r_addend
operator|==
literal|0
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|src
index|[
literal|2
index|]
operator|.
name|r_addend
operator|==
literal|0
argument_list|)
expr_stmt|;
name|mirela
operator|.
name|r_type2
operator|=
name|ELF64_MIPS_R_TYPE2
argument_list|(
name|src
index|[
literal|1
index|]
operator|.
name|r_info
argument_list|)
expr_stmt|;
name|mirela
operator|.
name|r_ssym
operator|=
name|ELF64_MIPS_R_SSYM
argument_list|(
name|src
index|[
literal|1
index|]
operator|.
name|r_info
argument_list|)
expr_stmt|;
name|mirela
operator|.
name|r_type3
operator|=
name|ELF64_MIPS_R_TYPE3
argument_list|(
name|src
index|[
literal|2
index|]
operator|.
name|r_info
argument_list|)
expr_stmt|;
name|mips_elf64_swap_reloca_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|mirela
argument_list|,
operator|(
name|Elf64_Mips_External_Rela
operator|*
operator|)
name|dst
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Calculate the %high function.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|mips_elf64_high
parameter_list|(
name|value
parameter_list|)
name|bfd_vma
name|value
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|value
operator|+
operator|(
name|bfd_vma
operator|)
literal|0x8000
operator|)
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
return|;
block|}
end_function

begin_comment
comment|/* Calculate the %higher function.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|mips_elf64_higher
parameter_list|(
name|value
parameter_list|)
name|bfd_vma
name|value
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|value
operator|+
operator|(
name|bfd_vma
operator|)
literal|0x80008000
operator|)
operator|>>
literal|32
operator|)
operator|&
literal|0xffff
return|;
block|}
end_function

begin_comment
comment|/* Calculate the %highest function.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|mips_elf64_highest
parameter_list|(
name|value
parameter_list|)
name|bfd_vma
name|value
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|value
operator|+
operator|(
name|bfd_vma
operator|)
literal|0x800080008000
operator|)
operator|>>
literal|48
operator|)
operator|&
literal|0xffff
return|;
block|}
end_function

begin_comment
comment|/* Do a R_MIPS_HI16 relocation.  */
end_comment

begin_function
name|bfd_reloc_status_type
name|mips_elf64_hi16_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* If we're relocating, and this is an external symbol, we don't      want to change anything.  */
if|if
condition|(
name|output_bfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
operator|&&
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|!
name|reloc_entry
operator|->
name|howto
operator|->
name|partial_inplace
operator|||
name|reloc_entry
operator|->
name|addend
operator|==
literal|0
operator|)
condition|)
block|{
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
if|if
condition|(
operator|(
operator|(
name|reloc_entry
operator|->
name|addend
operator|&
literal|0xffff
operator|)
operator|+
literal|0x8000
operator|)
operator|&
operator|~
literal|0xffff
condition|)
name|reloc_entry
operator|->
name|addend
operator|+=
literal|0x8000
expr_stmt|;
return|return
name|bfd_reloc_continue
return|;
block|}
end_function

begin_comment
comment|/* Do a R_MIPS_HIGHER relocation.  */
end_comment

begin_function
name|bfd_reloc_status_type
name|mips_elf64_higher_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* If we're relocating, and this is an external symbol, we don't      want to change anything.  */
if|if
condition|(
name|output_bfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
operator|&&
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|!
name|reloc_entry
operator|->
name|howto
operator|->
name|partial_inplace
operator|||
name|reloc_entry
operator|->
name|addend
operator|==
literal|0
operator|)
condition|)
block|{
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
if|if
condition|(
operator|(
operator|(
name|reloc_entry
operator|->
name|addend
operator|&
literal|0xffffffff
operator|)
operator|+
literal|0x80008000
operator|)
operator|&
operator|~
literal|0xffffffff
condition|)
name|reloc_entry
operator|->
name|addend
operator|+=
literal|0x80008000
expr_stmt|;
return|return
name|bfd_reloc_continue
return|;
block|}
end_function

begin_comment
comment|/* Do a R_MIPS_HIGHEST relocation.  */
end_comment

begin_function
name|bfd_reloc_status_type
name|mips_elf64_highest_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* If we're relocating, and this is an external symbol, we don't      want to change anything.  */
if|if
condition|(
name|output_bfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
operator|&&
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|!
name|reloc_entry
operator|->
name|howto
operator|->
name|partial_inplace
operator|||
name|reloc_entry
operator|->
name|addend
operator|==
literal|0
operator|)
condition|)
block|{
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
if|if
condition|(
operator|(
operator|(
name|reloc_entry
operator|->
name|addend
operator|&
literal|0xffffffffffff
operator|)
operator|+
literal|0x800080008000
operator|)
operator|&
operator|~
literal|0xffffffffffff
condition|)
name|reloc_entry
operator|->
name|addend
operator|+=
literal|0x800080008000
expr_stmt|;
return|return
name|bfd_reloc_continue
return|;
block|}
end_function

begin_comment
comment|/* Do a R_MIPS_GOT16 reloc.  This is a reloc against the global offset    table used for PIC code.  If the symbol is an external symbol, the    instruction is modified to contain the offset of the appropriate    entry in the global offset table.  If the symbol is a section    symbol, the next reloc is a R_MIPS_LO16 reloc.  The two 16 bit    addends are combined to form the real addend against the section    symbol; the GOT16 is modified to contain the offset of an entry in    the global offset table, and the LO16 is modified to offset it    appropriately.  Thus an offset larger than 16 bits requires a    modified value in the global offset table.     This implementation suffices for the assembler, but the linker does    not yet know how to create global offset tables.  */
end_comment

begin_function
name|bfd_reloc_status_type
name|mips_elf64_got16_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
block|{
comment|/* If we're relocating, and this an external symbol, we don't want      to change anything.  */
if|if
condition|(
name|output_bfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
operator|&&
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|==
literal|0
operator|&&
name|reloc_entry
operator|->
name|addend
operator|==
literal|0
condition|)
block|{
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
comment|/* If we're relocating, and this is a local symbol, we can handle it      just like HI16.  */
if|if
condition|(
name|output_bfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
operator|&&
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|!=
literal|0
condition|)
return|return
name|mips_elf64_hi16_reloc
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
argument_list|,
name|symbol
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
name|error_message
argument_list|)
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the GP value for OUTPUT_BFD.  Returns false if this is a    dangerous relocation.  */
end_comment

begin_function
specifier|static
name|boolean
name|mips_elf64_assign_gp
parameter_list|(
name|output_bfd
parameter_list|,
name|pgp
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|bfd_vma
modifier|*
name|pgp
decl_stmt|;
block|{
name|unsigned
name|int
name|count
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|sym
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* If we've already figured out what GP will be, just return it.  */
operator|*
name|pgp
operator|=
name|_bfd_get_gp_value
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pgp
condition|)
return|return
name|true
return|;
name|count
operator|=
name|bfd_get_symcount
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
name|sym
operator|=
name|bfd_get_outsymbols
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
comment|/* The linker script will have created a symbol named `_gp' with the      appropriate value.  */
if|if
condition|(
name|sym
operator|==
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|NULL
condition|)
name|i
operator|=
name|count
expr_stmt|;
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|sym
operator|++
control|)
block|{
specifier|register
name|CONST
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|bfd_asymbol_name
argument_list|(
operator|*
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'_'
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"_gp"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|pgp
operator|=
name|bfd_asymbol_value
argument_list|(
operator|*
name|sym
argument_list|)
expr_stmt|;
name|_bfd_set_gp_value
argument_list|(
name|output_bfd
argument_list|,
operator|*
name|pgp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|i
operator|>=
name|count
condition|)
block|{
comment|/* Only get the error once.  */
operator|*
name|pgp
operator|=
literal|4
expr_stmt|;
name|_bfd_set_gp_value
argument_list|(
name|output_bfd
argument_list|,
operator|*
name|pgp
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* We have to figure out the gp value, so that we can adjust the    symbol value correctly.  We look up the symbol _gp in the output    BFD.  If we can't find it, we're stuck.  We cache it in the ELF    target data.  We don't need to adjust the symbol value for an    external symbol if we are producing relocateable output.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|mips_elf64_final_gp
parameter_list|(
name|output_bfd
parameter_list|,
name|symbol
parameter_list|,
name|relocateable
parameter_list|,
name|error_message
parameter_list|,
name|pgp
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|boolean
name|relocateable
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
name|bfd_vma
modifier|*
name|pgp
decl_stmt|;
block|{
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
operator|&&
operator|!
name|relocateable
condition|)
block|{
operator|*
name|pgp
operator|=
literal|0
expr_stmt|;
return|return
name|bfd_reloc_undefined
return|;
block|}
operator|*
name|pgp
operator|=
name|_bfd_get_gp_value
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pgp
operator|==
literal|0
operator|&&
operator|(
operator|!
name|relocateable
operator|||
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|relocateable
condition|)
block|{
comment|/* Make up a value.  */
operator|*
name|pgp
operator|=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
literal|0x4000
expr_stmt|;
name|_bfd_set_gp_value
argument_list|(
name|output_bfd
argument_list|,
operator|*
name|pgp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|mips_elf64_assign_gp
argument_list|(
name|output_bfd
argument_list|,
name|pgp
argument_list|)
condition|)
block|{
operator|*
name|error_message
operator|=
operator|(
name|char
operator|*
operator|)
name|_
argument_list|(
literal|"GP relative relocation when _gp not defined"
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_dangerous
return|;
block|}
block|}
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_comment
comment|/* Do a R_MIPS_GPREL16 relocation.  This is a 16 bit value which must    become the offset from the gp register.  */
end_comment

begin_function
name|bfd_reloc_status_type
name|mips_elf64_gprel16_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
block|{
name|boolean
name|relocateable
decl_stmt|;
name|bfd_reloc_status_type
name|ret
decl_stmt|;
name|bfd_vma
name|gp
decl_stmt|;
comment|/* If we're relocating, and this is an external symbol with no      addend, we don't want to change anything.  We will only have an      addend if this is a newly created reloc, not read from an ELF      file.  */
if|if
condition|(
name|output_bfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
operator|&&
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|==
literal|0
operator|&&
name|reloc_entry
operator|->
name|addend
operator|==
literal|0
condition|)
block|{
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
if|if
condition|(
name|output_bfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
name|relocateable
operator|=
name|true
expr_stmt|;
else|else
block|{
name|relocateable
operator|=
name|false
expr_stmt|;
name|output_bfd
operator|=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|owner
expr_stmt|;
block|}
name|ret
operator|=
name|mips_elf64_final_gp
argument_list|(
name|output_bfd
argument_list|,
name|symbol
argument_list|,
name|relocateable
argument_list|,
name|error_message
argument_list|,
operator|&
name|gp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|bfd_reloc_ok
condition|)
return|return
name|ret
return|;
return|return
name|gprel16_with_gp
argument_list|(
name|abfd
argument_list|,
name|symbol
argument_list|,
name|reloc_entry
argument_list|,
name|input_section
argument_list|,
name|relocateable
argument_list|,
name|data
argument_list|,
name|gp
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_status_type
name|gprel16_with_gp
parameter_list|(
name|abfd
parameter_list|,
name|symbol
parameter_list|,
name|reloc_entry
parameter_list|,
name|input_section
parameter_list|,
name|relocateable
parameter_list|,
name|data
parameter_list|,
name|gp
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|boolean
name|relocateable
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|bfd_vma
name|gp
decl_stmt|;
block|{
name|bfd_vma
name|relocation
decl_stmt|;
name|unsigned
name|long
name|insn
decl_stmt|;
name|unsigned
name|long
name|val
decl_stmt|;
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
else|else
name|relocation
operator|=
name|symbol
operator|->
name|value
expr_stmt|;
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
if|if
condition|(
name|reloc_entry
operator|->
name|address
operator|>
name|input_section
operator|->
name|_cooked_size
condition|)
return|return
name|bfd_reloc_outofrange
return|;
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
argument_list|)
expr_stmt|;
comment|/* Set val to the offset into the section or symbol.  */
if|if
condition|(
name|reloc_entry
operator|->
name|howto
operator|->
name|src_mask
operator|==
literal|0
condition|)
block|{
comment|/* This case occurs with the 64-bit MIPS ELF ABI.  */
name|val
operator|=
name|reloc_entry
operator|->
name|addend
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
operator|(
operator|(
name|insn
operator|&
literal|0xffff
operator|)
operator|+
name|reloc_entry
operator|->
name|addend
operator|)
operator|&
literal|0xffff
expr_stmt|;
if|if
condition|(
name|val
operator|&
literal|0x8000
condition|)
name|val
operator|-=
literal|0x10000
expr_stmt|;
block|}
comment|/* Adjust val for the final section location and GP value.  If we      are producing relocateable output, we don't want to do this for      an external symbol.  */
if|if
condition|(
operator|!
name|relocateable
operator|||
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|!=
literal|0
condition|)
name|val
operator|+=
name|relocation
operator|-
name|gp
expr_stmt|;
name|insn
operator|=
operator|(
name|insn
operator|&
operator|~
literal|0xffff
operator|)
operator||
operator|(
name|val
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|insn
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
argument_list|)
expr_stmt|;
if|if
condition|(
name|relocateable
condition|)
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|long
operator|)
name|val
operator|>=
literal|0x8000
operator|||
operator|(
name|long
operator|)
name|val
operator|<
operator|-
literal|0x8000
condition|)
return|return
name|bfd_reloc_overflow
return|;
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_comment
comment|/* Do a R_MIPS_GPREL16 RELA relocation.  */
end_comment

begin_function
name|bfd_reloc_status_type
name|mips_elf64_gprel16_reloca
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
block|{
name|boolean
name|relocateable
decl_stmt|;
name|bfd_vma
name|gp
decl_stmt|;
comment|/* This works only for NewABI.  */
name|BFD_ASSERT
argument_list|(
name|reloc_entry
operator|->
name|howto
operator|->
name|src_mask
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* If we're relocating, and this is an external symbol with no      addend, we don't want to change anything.  We will only have an      addend if this is a newly created reloc, not read from an ELF      file.  */
if|if
condition|(
name|output_bfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
operator|&&
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|==
literal|0
operator|&&
name|reloc_entry
operator|->
name|addend
operator|==
literal|0
condition|)
block|{
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
if|if
condition|(
name|output_bfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
name|relocateable
operator|=
name|true
expr_stmt|;
else|else
block|{
name|relocateable
operator|=
name|false
expr_stmt|;
name|output_bfd
operator|=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|owner
expr_stmt|;
block|}
if|if
condition|(
name|prev_reloc_address
operator|!=
name|reloc_entry
operator|->
name|address
condition|)
name|prev_reloc_address
operator|=
name|reloc_entry
operator|->
name|address
expr_stmt|;
else|else
block|{
name|mips_elf64_final_gp
argument_list|(
name|output_bfd
argument_list|,
name|symbol
argument_list|,
name|relocateable
argument_list|,
name|error_message
argument_list|,
operator|&
name|gp
argument_list|)
expr_stmt|;
name|prev_reloc_addend
operator|=
name|reloc_entry
operator|->
name|addend
operator|+
name|reloc_entry
operator|->
name|address
operator|-
name|gp
expr_stmt|;
if|if
condition|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_LOCAL
condition|)
name|prev_reloc_addend
operator|+=
name|_bfd_get_gp_value
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/*fprintf(stderr, "Addend: %lx, Next Addend: %lx\n", reloc_entry->addend, prev_reloc_addend);*/
block|}
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_comment
comment|/* Do a R_MIPS_LITERAL relocation.  */
end_comment

begin_function
name|bfd_reloc_status_type
name|mips_elf64_literal_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
block|{
comment|/* If we're relocating, and this is an external symbol, we don't      want to change anything.  */
if|if
condition|(
name|output_bfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
operator|&&
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|!
name|reloc_entry
operator|->
name|howto
operator|->
name|partial_inplace
operator|||
name|reloc_entry
operator|->
name|addend
operator|==
literal|0
operator|)
condition|)
block|{
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
comment|/* FIXME: The entries in the .lit8 and .lit4 sections should be merged.      Currently we simply call mips_elf64_gprel16_reloc.  */
return|return
name|mips_elf64_gprel16_reloc
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
argument_list|,
name|symbol
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
name|error_message
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Do a R_MIPS_GPREL32 relocation.  Is this 32 bit value the offset    from the gp register? XXX */
end_comment

begin_function
name|bfd_reloc_status_type
name|mips_elf64_gprel32_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
block|{
name|boolean
name|relocateable
decl_stmt|;
name|bfd_reloc_status_type
name|ret
decl_stmt|;
name|bfd_vma
name|gp
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|unsigned
name|long
name|val
decl_stmt|;
comment|/* If we're relocating, and this is an external symbol with no      addend, we don't want to change anything.  We will only have an      addend if this is a newly created reloc, not read from an ELF      file.  */
if|if
condition|(
name|output_bfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
operator|&&
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|==
literal|0
operator|&&
name|reloc_entry
operator|->
name|addend
operator|==
literal|0
condition|)
block|{
operator|*
name|error_message
operator|=
operator|(
name|char
operator|*
operator|)
name|_
argument_list|(
literal|"32bits gp relative relocation occurs for an external symbol"
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_outofrange
return|;
block|}
if|if
condition|(
name|output_bfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
block|{
name|relocateable
operator|=
name|true
expr_stmt|;
name|gp
operator|=
name|_bfd_get_gp_value
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|relocateable
operator|=
name|false
expr_stmt|;
name|output_bfd
operator|=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|owner
expr_stmt|;
name|ret
operator|=
name|mips_elf64_final_gp
argument_list|(
name|output_bfd
argument_list|,
name|symbol
argument_list|,
name|relocateable
argument_list|,
name|error_message
argument_list|,
operator|&
name|gp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|bfd_reloc_ok
condition|)
return|return
name|ret
return|;
block|}
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
else|else
name|relocation
operator|=
name|symbol
operator|->
name|value
expr_stmt|;
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
if|if
condition|(
name|reloc_entry
operator|->
name|address
operator|>
name|input_section
operator|->
name|_cooked_size
condition|)
return|return
name|bfd_reloc_outofrange
return|;
if|if
condition|(
name|reloc_entry
operator|->
name|howto
operator|->
name|src_mask
operator|==
literal|0
condition|)
block|{
comment|/* This case arises with the 64-bit MIPS ELF ABI.  */
name|val
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|val
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
argument_list|)
expr_stmt|;
comment|/* Set val to the offset into the section or symbol.  */
name|val
operator|+=
name|reloc_entry
operator|->
name|addend
expr_stmt|;
comment|/* Adjust val for the final section location and GP value.  If we      are producing relocateable output, we don't want to do this for      an external symbol.  */
if|if
condition|(
operator|!
name|relocateable
operator|||
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|!=
literal|0
condition|)
name|val
operator|+=
name|relocation
operator|-
name|gp
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|val
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
argument_list|)
expr_stmt|;
if|if
condition|(
name|relocateable
condition|)
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_comment
comment|/* Do a R_MIPS_SHIFT6 relocation. The MSB of the shift is stored at bit 2,    the rest is at bits 6-10. The bitpos alredy got right by the howto.   */
end_comment

begin_function
name|bfd_reloc_status_type
name|mips_elf64_shift6_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* If we're relocating, and this is an external symbol, we don't      want to change anything.  */
if|if
condition|(
name|output_bfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
operator|&&
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|!
name|reloc_entry
operator|->
name|howto
operator|->
name|partial_inplace
operator|||
name|reloc_entry
operator|->
name|addend
operator|==
literal|0
operator|)
condition|)
block|{
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
name|reloc_entry
operator|->
name|addend
operator|=
operator|(
name|reloc_entry
operator|->
name|addend
operator|&
literal|0x00007c0
operator|)
operator||
operator|(
name|reloc_entry
operator|->
name|addend
operator|&
literal|0x00000800
operator|)
operator|>>
literal|9
expr_stmt|;
return|return
name|bfd_reloc_continue
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mips_elf64_additional_program_headers
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
comment|/* See if we need a PT_MIPS_OPTIONS segment.  */
if|if
condition|(
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".MIPS.options"
argument_list|)
condition|)
operator|++
name|ret
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Given a BFD reloc type, return a howto structure.  */
end_comment

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|mips_elf64_reloc_type_lookup
parameter_list|(
name|abfd
parameter_list|,
name|code
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
block|{
comment|/* FIXME: We default to RELA here instead of choosing the right      relocation variant.  */
name|reloc_howto_type
modifier|*
name|howto_table
init|=
name|mips_elf64_howto_table_rela
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|BFD_RELOC_NONE
case|:
return|return
operator|&
name|howto_table
index|[
name|R_MIPS_NONE
index|]
return|;
case|case
name|BFD_RELOC_16
case|:
return|return
operator|&
name|howto_table
index|[
name|R_MIPS_16
index|]
return|;
case|case
name|BFD_RELOC_32
case|:
return|return
operator|&
name|howto_table
index|[
name|R_MIPS_32
index|]
return|;
case|case
name|BFD_RELOC_64
case|:
case|case
name|BFD_RELOC_CTOR
case|:
comment|/* We need to handle these specially.  Select the right 	 relocation (R_MIPS_32 or R_MIPS_64) based on the 	 size of addresses on this architecture.  */
if|if
condition|(
name|bfd_arch_bits_per_address
argument_list|(
name|abfd
argument_list|)
operator|==
literal|32
condition|)
return|return
operator|&
name|howto_table
index|[
name|R_MIPS_32
index|]
return|;
else|else
return|return
operator|&
name|howto_table
index|[
name|R_MIPS_64
index|]
return|;
case|case
name|BFD_RELOC_16_PCREL
case|:
return|return
operator|&
name|howto_table
index|[
name|R_MIPS_PC16
index|]
return|;
case|case
name|BFD_RELOC_HI16_S
case|:
return|return
operator|&
name|howto_table
index|[
name|R_MIPS_HI16
index|]
return|;
case|case
name|BFD_RELOC_LO16
case|:
return|return
operator|&
name|howto_table
index|[
name|R_MIPS_LO16
index|]
return|;
case|case
name|BFD_RELOC_GPREL16
case|:
return|return
operator|&
name|howto_table
index|[
name|R_MIPS_GPREL16
index|]
return|;
case|case
name|BFD_RELOC_GPREL32
case|:
return|return
operator|&
name|howto_table
index|[
name|R_MIPS_GPREL32
index|]
return|;
case|case
name|BFD_RELOC_MIPS_JMP
case|:
return|return
operator|&
name|howto_table
index|[
name|R_MIPS_26
index|]
return|;
case|case
name|BFD_RELOC_MIPS_LITERAL
case|:
return|return
operator|&
name|howto_table
index|[
name|R_MIPS_LITERAL
index|]
return|;
case|case
name|BFD_RELOC_MIPS_GOT16
case|:
return|return
operator|&
name|howto_table
index|[
name|R_MIPS_GOT16
index|]
return|;
case|case
name|BFD_RELOC_MIPS_CALL16
case|:
return|return
operator|&
name|howto_table
index|[
name|R_MIPS_CALL16
index|]
return|;
case|case
name|BFD_RELOC_MIPS_SHIFT5
case|:
return|return
operator|&
name|howto_table
index|[
name|R_MIPS_SHIFT5
index|]
return|;
case|case
name|BFD_RELOC_MIPS_SHIFT6
case|:
return|return
operator|&
name|howto_table
index|[
name|R_MIPS_SHIFT6
index|]
return|;
case|case
name|BFD_RELOC_MIPS_GOT_DISP
case|:
return|return
operator|&
name|howto_table
index|[
name|R_MIPS_GOT_DISP
index|]
return|;
case|case
name|BFD_RELOC_MIPS_GOT_PAGE
case|:
return|return
operator|&
name|howto_table
index|[
name|R_MIPS_GOT_PAGE
index|]
return|;
case|case
name|BFD_RELOC_MIPS_GOT_OFST
case|:
return|return
operator|&
name|howto_table
index|[
name|R_MIPS_GOT_OFST
index|]
return|;
case|case
name|BFD_RELOC_MIPS_GOT_HI16
case|:
return|return
operator|&
name|howto_table
index|[
name|R_MIPS_GOT_HI16
index|]
return|;
case|case
name|BFD_RELOC_MIPS_GOT_LO16
case|:
return|return
operator|&
name|howto_table
index|[
name|R_MIPS_GOT_LO16
index|]
return|;
case|case
name|BFD_RELOC_MIPS_SUB
case|:
return|return
operator|&
name|howto_table
index|[
name|R_MIPS_SUB
index|]
return|;
case|case
name|BFD_RELOC_MIPS_INSERT_A
case|:
return|return
operator|&
name|howto_table
index|[
name|R_MIPS_INSERT_A
index|]
return|;
case|case
name|BFD_RELOC_MIPS_INSERT_B
case|:
return|return
operator|&
name|howto_table
index|[
name|R_MIPS_INSERT_B
index|]
return|;
case|case
name|BFD_RELOC_MIPS_DELETE
case|:
return|return
operator|&
name|howto_table
index|[
name|R_MIPS_DELETE
index|]
return|;
case|case
name|BFD_RELOC_MIPS_HIGHEST
case|:
return|return
operator|&
name|howto_table
index|[
name|R_MIPS_HIGHEST
index|]
return|;
case|case
name|BFD_RELOC_MIPS_HIGHER
case|:
return|return
operator|&
name|howto_table
index|[
name|R_MIPS_HIGHER
index|]
return|;
case|case
name|BFD_RELOC_MIPS_CALL_HI16
case|:
return|return
operator|&
name|howto_table
index|[
name|R_MIPS_CALL_HI16
index|]
return|;
case|case
name|BFD_RELOC_MIPS_CALL_LO16
case|:
return|return
operator|&
name|howto_table
index|[
name|R_MIPS_CALL_LO16
index|]
return|;
case|case
name|BFD_RELOC_MIPS_SCN_DISP
case|:
return|return
operator|&
name|howto_table
index|[
name|R_MIPS_SCN_DISP
index|]
return|;
case|case
name|BFD_RELOC_MIPS_REL16
case|:
return|return
operator|&
name|howto_table
index|[
name|R_MIPS_REL16
index|]
return|;
comment|/* Use of R_MIPS_ADD_IMMEDIATE and R_MIPS_PJUMP is deprecated.  */
case|case
name|BFD_RELOC_MIPS_RELGOT
case|:
return|return
operator|&
name|howto_table
index|[
name|R_MIPS_RELGOT
index|]
return|;
case|case
name|BFD_RELOC_MIPS_JALR
case|:
return|return
operator|&
name|howto_table
index|[
name|R_MIPS_JALR
index|]
return|;
comment|/*     case BFD_RELOC_MIPS16_JMP:       return&elf_mips16_jump_howto;     case BFD_RELOC_MIPS16_GPREL:       return&elf_mips16_gprel_howto;     case BFD_RELOC_VTABLE_INHERIT:       return&elf_mips_gnu_vtinherit_howto;     case BFD_RELOC_VTABLE_ENTRY:       return&elf_mips_gnu_vtentry_howto;     case BFD_RELOC_PCREL_HI16_S:       return&elf_mips_gnu_rel_hi16;     case BFD_RELOC_PCREL_LO16:       return&elf_mips_gnu_rel_lo16;     case BFD_RELOC_16_PCREL_S2:       return&elf_mips_gnu_rel16_s2;     case BFD_RELOC_64_PCREL:       return&elf_mips_gnu_pcrel64;     case BFD_RELOC_32_PCREL:       return&elf_mips_gnu_pcrel32; */
default|default:
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_comment
comment|/* Prevent relocation handling by bfd for MIPS ELF64.  */
end_comment

begin_function
specifier|static
name|void
name|mips_elf64_info_to_howto_rel
parameter_list|(
name|abfd
parameter_list|,
name|cache_ptr
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|arelent
modifier|*
name|cache_ptr
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|Elf64_Internal_Rel
modifier|*
name|dst
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|BFD_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mips_elf64_info_to_howto_rela
parameter_list|(
name|abfd
parameter_list|,
name|cache_ptr
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|arelent
modifier|*
name|cache_ptr
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|Elf64_Internal_Rela
modifier|*
name|dst
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|BFD_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Since each entry in an SHT_REL or SHT_RELA section can represent up    to three relocs, we must tell the user to allocate more space.  */
end_comment

begin_function
specifier|static
name|long
name|mips_elf64_get_reloc_upper_bound
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
block|{
return|return
operator|(
name|sec
operator|->
name|reloc_count
operator|*
literal|3
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Read the relocations from one reloc section.  */
end_comment

begin_function
specifier|static
name|boolean
name|mips_elf64_slurp_one_reloc_table
parameter_list|(
name|abfd
parameter_list|,
name|asect
parameter_list|,
name|symbols
parameter_list|,
name|rel_hdr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|asect
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
specifier|const
name|Elf_Internal_Shdr
modifier|*
name|rel_hdr
decl_stmt|;
block|{
name|PTR
name|allocated
init|=
name|NULL
decl_stmt|;
name|bfd_byte
modifier|*
name|native_relocs
decl_stmt|;
name|arelent
modifier|*
name|relents
decl_stmt|;
name|arelent
modifier|*
name|relent
decl_stmt|;
name|bfd_vma
name|count
decl_stmt|;
name|bfd_vma
name|i
decl_stmt|;
name|int
name|entsize
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto_table
decl_stmt|;
name|allocated
operator|=
operator|(
name|PTR
operator|)
name|bfd_malloc
argument_list|(
name|rel_hdr
operator|->
name|sh_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|allocated
operator|==
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|rel_hdr
operator|->
name|sh_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|bfd_bread
argument_list|(
name|allocated
argument_list|,
name|rel_hdr
operator|->
name|sh_size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|rel_hdr
operator|->
name|sh_size
operator|)
condition|)
goto|goto
name|error_return
goto|;
name|native_relocs
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|allocated
expr_stmt|;
name|relents
operator|=
name|asect
operator|->
name|relocation
operator|+
name|asect
operator|->
name|reloc_count
expr_stmt|;
name|entsize
operator|=
name|rel_hdr
operator|->
name|sh_entsize
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|entsize
operator|==
sizeof|sizeof
argument_list|(
name|Elf64_Mips_External_Rel
argument_list|)
operator|||
name|entsize
operator|==
sizeof|sizeof
argument_list|(
name|Elf64_Mips_External_Rela
argument_list|)
argument_list|)
expr_stmt|;
name|count
operator|=
name|rel_hdr
operator|->
name|sh_size
operator|/
name|entsize
expr_stmt|;
if|if
condition|(
name|entsize
operator|==
sizeof|sizeof
argument_list|(
name|Elf64_Mips_External_Rel
argument_list|)
condition|)
name|howto_table
operator|=
name|mips_elf64_howto_table_rel
expr_stmt|;
else|else
name|howto_table
operator|=
name|mips_elf64_howto_table_rela
expr_stmt|;
name|relent
operator|=
name|relents
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|native_relocs
operator|+=
name|entsize
control|)
block|{
name|Elf64_Mips_Internal_Rela
name|rela
decl_stmt|;
name|boolean
name|used_sym
decl_stmt|,
name|used_ssym
decl_stmt|;
name|int
name|ir
decl_stmt|;
if|if
condition|(
name|entsize
operator|==
sizeof|sizeof
argument_list|(
name|Elf64_Mips_External_Rela
argument_list|)
condition|)
name|mips_elf64_swap_reloca_in
argument_list|(
name|abfd
argument_list|,
operator|(
name|Elf64_Mips_External_Rela
operator|*
operator|)
name|native_relocs
argument_list|,
operator|&
name|rela
argument_list|)
expr_stmt|;
else|else
block|{
name|Elf64_Mips_Internal_Rel
name|rel
decl_stmt|;
name|mips_elf64_swap_reloc_in
argument_list|(
name|abfd
argument_list|,
operator|(
name|Elf64_Mips_External_Rel
operator|*
operator|)
name|native_relocs
argument_list|,
operator|&
name|rel
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_offset
operator|=
name|rel
operator|.
name|r_offset
expr_stmt|;
name|rela
operator|.
name|r_sym
operator|=
name|rel
operator|.
name|r_sym
expr_stmt|;
name|rela
operator|.
name|r_ssym
operator|=
name|rel
operator|.
name|r_ssym
expr_stmt|;
name|rela
operator|.
name|r_type3
operator|=
name|rel
operator|.
name|r_type3
expr_stmt|;
name|rela
operator|.
name|r_type2
operator|=
name|rel
operator|.
name|r_type2
expr_stmt|;
name|rela
operator|.
name|r_type
operator|=
name|rel
operator|.
name|r_type
expr_stmt|;
name|rela
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Each entry represents up to three actual relocations.  */
name|used_sym
operator|=
name|false
expr_stmt|;
name|used_ssym
operator|=
name|false
expr_stmt|;
for|for
control|(
name|ir
operator|=
literal|0
init|;
name|ir
operator|<
literal|3
condition|;
name|ir
operator|++
control|)
block|{
name|enum
name|elf_mips_reloc_type
name|type
decl_stmt|;
switch|switch
condition|(
name|ir
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
literal|0
case|:
name|type
operator|=
operator|(
expr|enum
name|elf_mips_reloc_type
operator|)
name|rela
operator|.
name|r_type
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|type
operator|=
operator|(
expr|enum
name|elf_mips_reloc_type
operator|)
name|rela
operator|.
name|r_type2
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|type
operator|=
operator|(
expr|enum
name|elf_mips_reloc_type
operator|)
name|rela
operator|.
name|r_type3
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|type
operator|==
name|R_MIPS_NONE
condition|)
block|{
comment|/* There are no more relocations in this entry.  If this                  is the first entry, we need to generate a dummy                  relocation so that the generic linker knows that                  there has been a break in the sequence of relocations                  applying to a particular address.  */
if|if
condition|(
name|ir
operator|==
literal|0
condition|)
block|{
name|relent
operator|->
name|sym_ptr_ptr
operator|=
name|bfd_abs_section_ptr
operator|->
name|symbol_ptr_ptr
expr_stmt|;
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
operator|(
name|EXEC_P
operator||
name|DYNAMIC
operator|)
operator|)
operator|==
literal|0
condition|)
name|relent
operator|->
name|address
operator|=
name|rela
operator|.
name|r_offset
expr_stmt|;
else|else
name|relent
operator|->
name|address
operator|=
name|rela
operator|.
name|r_offset
operator|-
name|asect
operator|->
name|vma
expr_stmt|;
name|relent
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
name|relent
operator|->
name|howto
operator|=
operator|&
name|howto_table
index|[
operator|(
name|int
operator|)
name|R_MIPS_NONE
index|]
expr_stmt|;
operator|++
name|relent
expr_stmt|;
block|}
break|break;
block|}
comment|/* Some types require symbols, whereas some do not.  */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|R_MIPS_NONE
case|:
case|case
name|R_MIPS_LITERAL
case|:
case|case
name|R_MIPS_INSERT_A
case|:
case|case
name|R_MIPS_INSERT_B
case|:
case|case
name|R_MIPS_DELETE
case|:
name|relent
operator|->
name|sym_ptr_ptr
operator|=
name|bfd_abs_section_ptr
operator|->
name|symbol_ptr_ptr
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|!
name|used_sym
condition|)
block|{
if|if
condition|(
name|rela
operator|.
name|r_sym
operator|==
literal|0
condition|)
name|relent
operator|->
name|sym_ptr_ptr
operator|=
name|bfd_abs_section_ptr
operator|->
name|symbol_ptr_ptr
expr_stmt|;
else|else
block|{
name|asymbol
modifier|*
modifier|*
name|ps
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|ps
operator|=
name|symbols
operator|+
name|rela
operator|.
name|r_sym
operator|-
literal|1
expr_stmt|;
name|s
operator|=
operator|*
name|ps
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|==
literal|0
condition|)
name|relent
operator|->
name|sym_ptr_ptr
operator|=
name|ps
expr_stmt|;
else|else
name|relent
operator|->
name|sym_ptr_ptr
operator|=
name|s
operator|->
name|section
operator|->
name|symbol_ptr_ptr
expr_stmt|;
block|}
name|used_sym
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|used_ssym
condition|)
block|{
switch|switch
condition|(
name|rela
operator|.
name|r_ssym
condition|)
block|{
case|case
name|RSS_UNDEF
case|:
name|relent
operator|->
name|sym_ptr_ptr
operator|=
name|bfd_abs_section_ptr
operator|->
name|symbol_ptr_ptr
expr_stmt|;
break|break;
case|case
name|RSS_GP
case|:
case|case
name|RSS_GP0
case|:
case|case
name|RSS_LOC
case|:
comment|/* FIXME: I think these need to be handled using                          special howto structures.  */
name|BFD_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|BFD_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|used_ssym
operator|=
name|true
expr_stmt|;
block|}
else|else
name|relent
operator|->
name|sym_ptr_ptr
operator|=
name|bfd_abs_section_ptr
operator|->
name|symbol_ptr_ptr
expr_stmt|;
break|break;
block|}
comment|/* The address of an ELF reloc is section relative for an 	     object file, and absolute for an executable file or 	     shared library.  The address of a BFD reloc is always 	     section relative.  */
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
operator|(
name|EXEC_P
operator||
name|DYNAMIC
operator|)
operator|)
operator|==
literal|0
condition|)
name|relent
operator|->
name|address
operator|=
name|rela
operator|.
name|r_offset
expr_stmt|;
else|else
name|relent
operator|->
name|address
operator|=
name|rela
operator|.
name|r_offset
operator|-
name|asect
operator|->
name|vma
expr_stmt|;
name|relent
operator|->
name|addend
operator|=
name|rela
operator|.
name|r_addend
expr_stmt|;
name|relent
operator|->
name|howto
operator|=
operator|&
name|howto_table
index|[
operator|(
name|int
operator|)
name|type
index|]
expr_stmt|;
operator|++
name|relent
expr_stmt|;
block|}
block|}
name|asect
operator|->
name|reloc_count
operator|+=
name|relent
operator|-
name|relents
expr_stmt|;
if|if
condition|(
name|allocated
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|allocated
argument_list|)
expr_stmt|;
return|return
name|true
return|;
name|error_return
label|:
if|if
condition|(
name|allocated
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|allocated
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Read the relocations.  On Irix 6, there can be two reloc sections    associated with a single data section.  */
end_comment

begin_function
specifier|static
name|boolean
name|mips_elf64_slurp_reloc_table
parameter_list|(
name|abfd
parameter_list|,
name|asect
parameter_list|,
name|symbols
parameter_list|,
name|dynamic
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|asect
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
name|boolean
name|dynamic
decl_stmt|;
block|{
name|bfd_size_type
name|amt
decl_stmt|;
name|struct
name|bfd_elf_section_data
modifier|*
specifier|const
name|d
init|=
name|elf_section_data
argument_list|(
name|asect
argument_list|)
decl_stmt|;
if|if
condition|(
name|dynamic
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|asect
operator|->
name|relocation
operator|!=
name|NULL
operator|||
operator|(
name|asect
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
operator|||
name|asect
operator|->
name|reloc_count
operator|==
literal|0
condition|)
return|return
name|true
return|;
comment|/* Allocate space for 3 arelent structures for each Rel structure.  */
name|amt
operator|=
name|asect
operator|->
name|reloc_count
expr_stmt|;
name|amt
operator|*=
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
expr_stmt|;
name|asect
operator|->
name|relocation
operator|=
operator|(
name|arelent
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|asect
operator|->
name|relocation
operator|==
name|NULL
condition|)
return|return
name|false
return|;
comment|/* The slurp_one_reloc_table routine increments reloc_count.  */
name|asect
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|mips_elf64_slurp_one_reloc_table
argument_list|(
name|abfd
argument_list|,
name|asect
argument_list|,
name|symbols
argument_list|,
operator|&
name|d
operator|->
name|rel_hdr
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|d
operator|->
name|rel_hdr2
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|mips_elf64_slurp_one_reloc_table
argument_list|(
name|abfd
argument_list|,
name|asect
argument_list|,
name|symbols
argument_list|,
name|d
operator|->
name|rel_hdr2
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Write out the relocations.  */
end_comment

begin_function
specifier|static
name|void
name|mips_elf64_write_relocs
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|data
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
name|boolean
modifier|*
name|failedp
init|=
operator|(
name|boolean
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|count
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|rel_hdr
decl_stmt|;
name|unsigned
name|int
name|idx
decl_stmt|;
comment|/* If we have already failed, don't do anything.  */
if|if
condition|(
operator|*
name|failedp
condition|)
return|return;
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
condition|)
return|return;
comment|/* The linker backend writes the relocs out itself, and sets the      reloc_count field to zero to inhibit writing them here.  Also,      sometimes the SEC_RELOC flag gets set even when there aren't any      relocs.  */
if|if
condition|(
name|sec
operator|->
name|reloc_count
operator|==
literal|0
condition|)
return|return;
comment|/* We can combine up to three relocs that refer to the same address      if the latter relocs have no associated symbol.  */
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|sec
operator|->
name|reloc_count
condition|;
name|idx
operator|++
control|)
block|{
name|bfd_vma
name|addr
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
operator|++
name|count
expr_stmt|;
name|addr
operator|=
name|sec
operator|->
name|orelocation
index|[
name|idx
index|]
operator|->
name|address
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|arelent
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|idx
operator|+
literal|1
operator|>=
name|sec
operator|->
name|reloc_count
condition|)
break|break;
name|r
operator|=
name|sec
operator|->
name|orelocation
index|[
name|idx
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|address
operator|!=
name|addr
operator|||
operator|!
name|bfd_is_abs_section
argument_list|(
operator|(
operator|*
name|r
operator|->
name|sym_ptr_ptr
operator|)
operator|->
name|section
argument_list|)
operator|||
operator|(
operator|*
name|r
operator|->
name|sym_ptr_ptr
operator|)
operator|->
name|value
operator|!=
literal|0
condition|)
break|break;
comment|/* We can merge the reloc at IDX + 1 with the reloc at IDX.  */
operator|++
name|idx
expr_stmt|;
block|}
block|}
name|rel_hdr
operator|=
operator|&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|rel_hdr
expr_stmt|;
comment|/* Do the actual relocation.  */
if|if
condition|(
name|rel_hdr
operator|->
name|sh_entsize
operator|==
sizeof|sizeof
argument_list|(
name|Elf64_Mips_External_Rel
argument_list|)
condition|)
name|mips_elf64_write_rel
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|rel_hdr
argument_list|,
operator|&
name|count
argument_list|,
name|data
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rel_hdr
operator|->
name|sh_entsize
operator|==
sizeof|sizeof
argument_list|(
name|Elf64_Mips_External_Rela
argument_list|)
condition|)
name|mips_elf64_write_rela
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|rel_hdr
argument_list|,
operator|&
name|count
argument_list|,
name|data
argument_list|)
expr_stmt|;
else|else
name|BFD_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mips_elf64_write_rel
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|rel_hdr
parameter_list|,
name|count
parameter_list|,
name|data
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|rel_hdr
decl_stmt|;
name|int
modifier|*
name|count
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
name|boolean
modifier|*
name|failedp
init|=
operator|(
name|boolean
operator|*
operator|)
name|data
decl_stmt|;
name|Elf64_Mips_External_Rel
modifier|*
name|ext_rel
decl_stmt|;
name|unsigned
name|int
name|idx
decl_stmt|;
name|asymbol
modifier|*
name|last_sym
init|=
literal|0
decl_stmt|;
name|int
name|last_sym_idx
init|=
literal|0
decl_stmt|;
name|rel_hdr
operator|->
name|sh_size
operator|=
call|(
name|bfd_vma
call|)
argument_list|(
name|rel_hdr
operator|->
name|sh_entsize
operator|*
operator|*
name|count
argument_list|)
expr_stmt|;
name|rel_hdr
operator|->
name|contents
operator|=
operator|(
name|PTR
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|rel_hdr
operator|->
name|sh_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|rel_hdr
operator|->
name|contents
operator|==
name|NULL
condition|)
block|{
operator|*
name|failedp
operator|=
name|true
expr_stmt|;
return|return;
block|}
name|ext_rel
operator|=
operator|(
name|Elf64_Mips_External_Rel
operator|*
operator|)
name|rel_hdr
operator|->
name|contents
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|sec
operator|->
name|reloc_count
condition|;
name|idx
operator|++
operator|,
name|ext_rel
operator|++
control|)
block|{
name|arelent
modifier|*
name|ptr
decl_stmt|;
name|Elf64_Mips_Internal_Rel
name|int_rel
decl_stmt|;
name|asymbol
modifier|*
name|sym
decl_stmt|;
name|int
name|n
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|ptr
operator|=
name|sec
operator|->
name|orelocation
index|[
name|idx
index|]
expr_stmt|;
comment|/* The address of an ELF reloc is section relative for an object 	 file, and absolute for an executable file or shared library. 	 The address of a BFD reloc is always section relative.  */
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
operator|(
name|EXEC_P
operator||
name|DYNAMIC
operator|)
operator|)
operator|==
literal|0
condition|)
name|int_rel
operator|.
name|r_offset
operator|=
name|ptr
operator|->
name|address
expr_stmt|;
else|else
name|int_rel
operator|.
name|r_offset
operator|=
name|ptr
operator|->
name|address
operator|+
name|sec
operator|->
name|vma
expr_stmt|;
name|sym
operator|=
operator|*
name|ptr
operator|->
name|sym_ptr_ptr
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|last_sym
condition|)
name|n
operator|=
name|last_sym_idx
expr_stmt|;
else|else
block|{
name|last_sym
operator|=
name|sym
expr_stmt|;
name|n
operator|=
name|_bfd_elf_symbol_from_bfd_symbol
argument_list|(
name|abfd
argument_list|,
operator|&
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
operator|*
name|failedp
operator|=
name|true
expr_stmt|;
return|return;
block|}
name|last_sym_idx
operator|=
name|n
expr_stmt|;
block|}
name|int_rel
operator|.
name|r_sym
operator|=
name|n
expr_stmt|;
name|int_rel
operator|.
name|r_ssym
operator|=
name|RSS_UNDEF
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|ptr
operator|->
name|sym_ptr_ptr
operator|)
operator|->
name|the_bfd
operator|->
name|xvec
operator|!=
name|abfd
operator|->
name|xvec
operator|&&
operator|!
name|_bfd_elf_validate_reloc
argument_list|(
name|abfd
argument_list|,
name|ptr
argument_list|)
condition|)
block|{
operator|*
name|failedp
operator|=
name|true
expr_stmt|;
return|return;
block|}
name|int_rel
operator|.
name|r_type
operator|=
name|ptr
operator|->
name|howto
operator|->
name|type
expr_stmt|;
name|int_rel
operator|.
name|r_type2
operator|=
operator|(
name|int
operator|)
name|R_MIPS_NONE
expr_stmt|;
name|int_rel
operator|.
name|r_type3
operator|=
operator|(
name|int
operator|)
name|R_MIPS_NONE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|arelent
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|idx
operator|+
literal|1
operator|>=
name|sec
operator|->
name|reloc_count
condition|)
break|break;
name|r
operator|=
name|sec
operator|->
name|orelocation
index|[
name|idx
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|address
operator|!=
name|ptr
operator|->
name|address
operator|||
operator|!
name|bfd_is_abs_section
argument_list|(
operator|(
operator|*
name|r
operator|->
name|sym_ptr_ptr
operator|)
operator|->
name|section
argument_list|)
operator|||
operator|(
operator|*
name|r
operator|->
name|sym_ptr_ptr
operator|)
operator|->
name|value
operator|!=
literal|0
condition|)
break|break;
comment|/* We can merge the reloc at IDX + 1 with the reloc at IDX.  */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|int_rel
operator|.
name|r_type2
operator|=
name|r
operator|->
name|howto
operator|->
name|type
expr_stmt|;
else|else
name|int_rel
operator|.
name|r_type3
operator|=
name|r
operator|->
name|howto
operator|->
name|type
expr_stmt|;
operator|++
name|idx
expr_stmt|;
block|}
name|mips_elf64_swap_reloc_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|int_rel
argument_list|,
name|ext_rel
argument_list|)
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
name|ext_rel
operator|-
operator|(
name|Elf64_Mips_External_Rel
operator|*
operator|)
name|rel_hdr
operator|->
name|contents
operator|==
operator|*
name|count
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mips_elf64_write_rela
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|rela_hdr
parameter_list|,
name|count
parameter_list|,
name|data
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|rela_hdr
decl_stmt|;
name|int
modifier|*
name|count
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
name|boolean
modifier|*
name|failedp
init|=
operator|(
name|boolean
operator|*
operator|)
name|data
decl_stmt|;
name|Elf64_Mips_External_Rela
modifier|*
name|ext_rela
decl_stmt|;
name|unsigned
name|int
name|idx
decl_stmt|;
name|asymbol
modifier|*
name|last_sym
init|=
literal|0
decl_stmt|;
name|int
name|last_sym_idx
init|=
literal|0
decl_stmt|;
name|rela_hdr
operator|->
name|sh_size
operator|=
call|(
name|bfd_vma
call|)
argument_list|(
name|rela_hdr
operator|->
name|sh_entsize
operator|*
operator|*
name|count
argument_list|)
expr_stmt|;
name|rela_hdr
operator|->
name|contents
operator|=
operator|(
name|PTR
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|rela_hdr
operator|->
name|sh_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|rela_hdr
operator|->
name|contents
operator|==
name|NULL
condition|)
block|{
operator|*
name|failedp
operator|=
name|true
expr_stmt|;
return|return;
block|}
name|ext_rela
operator|=
operator|(
name|Elf64_Mips_External_Rela
operator|*
operator|)
name|rela_hdr
operator|->
name|contents
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|sec
operator|->
name|reloc_count
condition|;
name|idx
operator|++
operator|,
name|ext_rela
operator|++
control|)
block|{
name|arelent
modifier|*
name|ptr
decl_stmt|;
name|Elf64_Mips_Internal_Rela
name|int_rela
decl_stmt|;
name|asymbol
modifier|*
name|sym
decl_stmt|;
name|int
name|n
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|ptr
operator|=
name|sec
operator|->
name|orelocation
index|[
name|idx
index|]
expr_stmt|;
comment|/* The address of an ELF reloc is section relative for an object 	 file, and absolute for an executable file or shared library. 	 The address of a BFD reloc is always section relative.  */
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
operator|(
name|EXEC_P
operator||
name|DYNAMIC
operator|)
operator|)
operator|==
literal|0
condition|)
name|int_rela
operator|.
name|r_offset
operator|=
name|ptr
operator|->
name|address
expr_stmt|;
else|else
name|int_rela
operator|.
name|r_offset
operator|=
name|ptr
operator|->
name|address
operator|+
name|sec
operator|->
name|vma
expr_stmt|;
name|sym
operator|=
operator|*
name|ptr
operator|->
name|sym_ptr_ptr
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|last_sym
condition|)
name|n
operator|=
name|last_sym_idx
expr_stmt|;
else|else
block|{
name|last_sym
operator|=
name|sym
expr_stmt|;
name|n
operator|=
name|_bfd_elf_symbol_from_bfd_symbol
argument_list|(
name|abfd
argument_list|,
operator|&
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
operator|*
name|failedp
operator|=
name|true
expr_stmt|;
return|return;
block|}
name|last_sym_idx
operator|=
name|n
expr_stmt|;
block|}
name|int_rela
operator|.
name|r_sym
operator|=
name|n
expr_stmt|;
name|int_rela
operator|.
name|r_addend
operator|=
name|ptr
operator|->
name|addend
expr_stmt|;
name|int_rela
operator|.
name|r_ssym
operator|=
name|RSS_UNDEF
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|ptr
operator|->
name|sym_ptr_ptr
operator|)
operator|->
name|the_bfd
operator|->
name|xvec
operator|!=
name|abfd
operator|->
name|xvec
operator|&&
operator|!
name|_bfd_elf_validate_reloc
argument_list|(
name|abfd
argument_list|,
name|ptr
argument_list|)
condition|)
block|{
operator|*
name|failedp
operator|=
name|true
expr_stmt|;
return|return;
block|}
name|int_rela
operator|.
name|r_type
operator|=
name|ptr
operator|->
name|howto
operator|->
name|type
expr_stmt|;
name|int_rela
operator|.
name|r_type2
operator|=
operator|(
name|int
operator|)
name|R_MIPS_NONE
expr_stmt|;
name|int_rela
operator|.
name|r_type3
operator|=
operator|(
name|int
operator|)
name|R_MIPS_NONE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|arelent
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|idx
operator|+
literal|1
operator|>=
name|sec
operator|->
name|reloc_count
condition|)
break|break;
name|r
operator|=
name|sec
operator|->
name|orelocation
index|[
name|idx
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|address
operator|!=
name|ptr
operator|->
name|address
operator|||
operator|!
name|bfd_is_abs_section
argument_list|(
operator|(
operator|*
name|r
operator|->
name|sym_ptr_ptr
operator|)
operator|->
name|section
argument_list|)
operator|||
operator|(
operator|*
name|r
operator|->
name|sym_ptr_ptr
operator|)
operator|->
name|value
operator|!=
literal|0
condition|)
break|break;
comment|/* We can merge the reloc at IDX + 1 with the reloc at IDX.  */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|int_rela
operator|.
name|r_type2
operator|=
name|r
operator|->
name|howto
operator|->
name|type
expr_stmt|;
else|else
name|int_rela
operator|.
name|r_type3
operator|=
name|r
operator|->
name|howto
operator|->
name|type
expr_stmt|;
operator|++
name|idx
expr_stmt|;
block|}
name|mips_elf64_swap_reloca_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|int_rela
argument_list|,
name|ext_rela
argument_list|)
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
name|ext_rela
operator|-
operator|(
name|Elf64_Mips_External_Rela
operator|*
operator|)
name|rela_hdr
operator|->
name|contents
operator|==
operator|*
name|count
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This structure is used to hold .got information when linking.  It    is stored in the tdata field of the bfd_elf_section_data structure.  */
end_comment

begin_struct
struct|struct
name|mips_elf64_got_info
block|{
comment|/* The global symbol in the GOT with the lowest index in the dynamic      symbol table.  */
name|struct
name|elf_link_hash_entry
modifier|*
name|global_gotsym
decl_stmt|;
comment|/* The number of global .got entries.  */
name|unsigned
name|int
name|global_gotno
decl_stmt|;
comment|/* The number of local .got entries.  */
name|unsigned
name|int
name|local_gotno
decl_stmt|;
comment|/* The number of local .got entries we have used.  */
name|unsigned
name|int
name|assigned_gotno
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The MIPS ELF64 linker needs additional information for each symbol in    the global hash table.  */
end_comment

begin_struct
struct|struct
name|mips_elf64_link_hash_entry
block|{
name|struct
name|elf_link_hash_entry
name|root
decl_stmt|;
comment|/* External symbol information.  */
name|EXTR
name|esym
decl_stmt|;
comment|/* Number of R_MIPS_32, R_MIPS_REL32, or R_MIPS_64 relocs against      this symbol.  */
name|unsigned
name|int
name|possibly_dynamic_relocs
decl_stmt|;
comment|/* If the R_MIPS_32, R_MIPS_REL32, or R_MIPS_64 reloc is against      a readonly section.  */
name|boolean
name|readonly_reloc
decl_stmt|;
comment|/* The index of the first dynamic relocation (in the .rel.dyn      section) against this symbol.  */
name|unsigned
name|int
name|min_dyn_reloc_index
decl_stmt|;
comment|/* We must not create a stub for a symbol that has relocations      related to taking the function's address, i.e. any but      R_MIPS_CALL*16 ones -- see "MIPS ABI Supplement, 3rd Edition",      p. 4-20.  */
name|boolean
name|no_fn_stub
decl_stmt|;
comment|/* If there is a stub that 32 bit functions should use to call this      16 bit function, this points to the section containing the stub.  */
name|asection
modifier|*
name|fn_stub
decl_stmt|;
comment|/* Whether we need the fn_stub; this is set if this symbol appears      in any relocs other than a 16 bit call.  */
name|boolean
name|need_fn_stub
decl_stmt|;
comment|/* If there is a stub that 16 bit functions should use to call this      32 bit function, this points to the section containing the stub.  */
name|asection
modifier|*
name|call_stub
decl_stmt|;
comment|/* This is like the call_stub field, but it is used if the function      being called returns a floating point value.  */
name|asection
modifier|*
name|call_fp_stub
decl_stmt|;
block|}
struct|;
end_struct

begin_escape
end_escape

begin_comment
comment|/* The mips16 compiler uses a couple of special sections to handle      floating point arguments.       Section names that look like .mips16.fn.FNNAME contain stubs that      copy floating point arguments from the fp regs to the gp regs and      then jump to FNNAME.  If any 32 bit function calls FNNAME, the      call should be redirected to the stub instead.  If no 32 bit      function calls FNNAME, the stub should be discarded.  We need to      consider any reference to the function, not just a call, because      if the address of the function is taken we will need the stub,      since the address might be passed to a 32 bit function.       Section names that look like .mips16.call.FNNAME contain stubs      that copy floating point arguments from the gp regs to the fp      regs and then jump to FNNAME.  If FNNAME is a 32 bit function,      then any 16 bit function that calls FNNAME should be redirected      to the stub instead.  If FNNAME is not a 32 bit function, the      stub should be discarded.       .mips16.call.fp.FNNAME sections are similar, but contain stubs      which call FNNAME and then copy the return value from the fp regs      to the gp regs.  These stubs store the return value in $18 while      calling FNNAME; any function which might call one of these stubs      must arrange to save $18 around the call.  (This case is not      needed for 32 bit functions that call 16 bit functions, because      16 bit functions always return floating point values in both      $f0/$f1 and $2/$3.)       Note that in all cases FNNAME might be defined statically.      Therefore, FNNAME is not used literally.  Instead, the relocation      information will indicate which symbol the section is for.       We record any stubs that we find in the symbol table.  */
end_comment

begin_define
define|#
directive|define
name|FN_STUB
value|".mips16.fn."
end_define

begin_define
define|#
directive|define
name|CALL_STUB
value|".mips16.call."
end_define

begin_define
define|#
directive|define
name|CALL_FP_STUB
value|".mips16.call.fp."
end_define

begin_comment
comment|/* MIPS ELF64 linker hash table.  */
end_comment

begin_struct
struct|struct
name|mips_elf64_link_hash_table
block|{
name|struct
name|elf_link_hash_table
name|root
decl_stmt|;
comment|/* This is set if we see any mips16 stub sections.  */
name|boolean
name|mips16_stubs_seen
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Look up an entry in a MIPS ELF64 linker hash table.  */
end_comment

begin_define
define|#
directive|define
name|mips_elf64_link_hash_lookup
parameter_list|(
name|table
parameter_list|,
name|string
parameter_list|,
name|create
parameter_list|,
name|copy
parameter_list|,
name|follow
parameter_list|)
define|\
value|((struct mips_elf64_link_hash_entry *)				\    elf_link_hash_lookup (&(table)->root, (string), (create),		\ 			 (copy), (follow)))
end_define

begin_comment
comment|/* Traverse a MIPS ELF linker hash table.  */
end_comment

begin_define
define|#
directive|define
name|mips_elf64_link_hash_traverse
parameter_list|(
name|table
parameter_list|,
name|func
parameter_list|,
name|info
parameter_list|)
define|\
value|(elf_link_hash_traverse						\    (&(table)->root,							\     (boolean (*) PARAMS ((struct elf_link_hash_entry *, PTR))) (func),	\     (info)))
end_define

begin_comment
comment|/* Get the MIPS ELF64 linker hash table from a link_info structure.  */
end_comment

begin_define
define|#
directive|define
name|mips_elf64_hash_table
parameter_list|(
name|p
parameter_list|)
define|\
value|((struct mips_elf64_link_hash_table *) ((p)->hash))
end_define

begin_comment
comment|/* Create an entry in a MIPS ELF64 linker hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|mips_elf64_link_hash_newfunc
parameter_list|(
name|entry
parameter_list|,
name|table
parameter_list|,
name|string
parameter_list|)
name|struct
name|bfd_hash_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|bfd_hash_table
modifier|*
name|table
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|struct
name|mips_elf64_link_hash_entry
modifier|*
name|ret
init|=
operator|(
expr|struct
name|mips_elf64_link_hash_entry
operator|*
operator|)
name|entry
decl_stmt|;
comment|/* Allocate the structure if it has not already been allocated by a      subclass.  */
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|mips_elf64_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
name|ret
operator|=
operator|(
operator|(
expr|struct
name|mips_elf64_link_hash_entry
operator|*
operator|)
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mips_elf64_link_hash_entry
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|mips_elf64_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
comment|/* Call the allocation method of the superclass.  */
name|ret
operator|=
operator|(
operator|(
expr|struct
name|mips_elf64_link_hash_entry
operator|*
operator|)
name|_bfd_elf_link_hash_newfunc
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
operator|(
expr|struct
name|mips_elf64_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* Set local fields.  */
name|memset
argument_list|(
operator|&
name|ret
operator|->
name|esym
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|EXTR
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We use -2 as a marker to indicate that the information has 	 not been set.  -1 means there is no associated ifd.  */
name|ret
operator|->
name|esym
operator|.
name|ifd
operator|=
operator|-
literal|2
expr_stmt|;
name|ret
operator|->
name|possibly_dynamic_relocs
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|readonly_reloc
operator|=
name|false
expr_stmt|;
name|ret
operator|->
name|min_dyn_reloc_index
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|no_fn_stub
operator|=
name|false
expr_stmt|;
name|ret
operator|->
name|fn_stub
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|need_fn_stub
operator|=
name|false
expr_stmt|;
name|ret
operator|->
name|call_stub
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|call_fp_stub
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Create a MIPS ELF64 linker hash table.  */
end_comment

begin_function
name|struct
name|bfd_link_hash_table
modifier|*
name|mips_elf64_link_hash_table_create
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|mips_elf64_link_hash_table
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
operator|(
operator|(
expr|struct
name|mips_elf64_link_hash_table
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mips_elf64_link_hash_table
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|mips_elf64_link_hash_table
operator|*
operator|)
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|_bfd_elf_link_hash_table_init
argument_list|(
operator|&
name|ret
operator|->
name|root
argument_list|,
name|abfd
argument_list|,
name|mips_elf64_link_hash_newfunc
argument_list|)
condition|)
block|{
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ret
operator|->
name|mips16_stubs_seen
operator|=
name|false
expr_stmt|;
return|return
operator|&
name|ret
operator|->
name|root
operator|.
name|root
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Returns the offset for the entry at the INDEXth position    in the GOT.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|mips_elf64_got_offset_from_index
parameter_list|(
name|dynobj
parameter_list|,
name|output_bfd
parameter_list|,
name|index
parameter_list|)
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|bfd_vma
name|index
decl_stmt|;
block|{
name|asection
modifier|*
name|sgot
decl_stmt|;
name|bfd_vma
name|gp
decl_stmt|;
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
name|gp
operator|=
name|_bfd_get_gp_value
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
return|return
operator|(
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
name|index
operator|-
name|gp
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns the GOT information associated with the link indicated by    INFO.  If SGOTP is non-NULL, it is filled in with the GOT     section.  */
end_comment

begin_function
specifier|static
name|struct
name|mips_elf64_got_info
modifier|*
name|_mips_elf64_got_info
parameter_list|(
name|abfd
parameter_list|,
name|sgotp
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
modifier|*
name|sgotp
decl_stmt|;
block|{
name|asection
modifier|*
name|sgot
decl_stmt|;
name|struct
name|mips_elf64_got_info
modifier|*
name|g
decl_stmt|;
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|elf_section_data
argument_list|(
name|sgot
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g
operator|=
operator|(
expr|struct
name|mips_elf64_got_info
operator|*
operator|)
name|elf_section_data
argument_list|(
name|sgot
argument_list|)
operator|->
name|tdata
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|g
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sgotp
condition|)
operator|*
name|sgotp
operator|=
name|sgot
expr_stmt|;
return|return
name|g
return|;
block|}
end_function

begin_comment
comment|/* Sign-extend VALUE, which has the indicated number of BITS.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|mips_elf64_sign_extend
parameter_list|(
name|value
parameter_list|,
name|bits
parameter_list|)
name|bfd_vma
name|value
decl_stmt|;
name|int
name|bits
decl_stmt|;
block|{
if|if
condition|(
name|value
operator|&
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
operator|(
name|bits
operator|-
literal|1
operator|)
operator|)
condition|)
comment|/* VALUE is negative.  */
name|value
operator||=
operator|(
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|)
operator|<<
name|bits
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if the indicated VALUE has overflowed the maximum    range expressable by a signed number with the indicated number of    BITS.  */
end_comment

begin_function
specifier|static
name|boolean
name|mips_elf64_overflow_p
parameter_list|(
name|value
parameter_list|,
name|bits
parameter_list|)
name|bfd_vma
name|value
decl_stmt|;
name|int
name|bits
decl_stmt|;
block|{
name|bfd_signed_vma
name|svalue
init|=
operator|(
name|bfd_signed_vma
operator|)
name|value
decl_stmt|;
if|if
condition|(
name|svalue
operator|>
operator|(
literal|1
operator|<<
operator|(
name|bits
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
condition|)
comment|/* The value is too big.  */
return|return
name|true
return|;
elseif|else
if|if
condition|(
name|svalue
operator|<
operator|-
operator|(
literal|1
operator|<<
operator|(
name|bits
operator|-
literal|1
operator|)
operator|)
condition|)
comment|/* The value is too small.  */
return|return
name|true
return|;
comment|/* All is well.  */
return|return
name|false
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Returns the GOT index for the global symbol indicated by H.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|mips_elf64_global_got_index
parameter_list|(
name|abfd
parameter_list|,
name|h
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
block|{
name|bfd_vma
name|index
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
name|struct
name|mips_elf64_got_info
modifier|*
name|g
decl_stmt|;
name|g
operator|=
name|_mips_elf64_got_info
argument_list|(
name|abfd
argument_list|,
operator|&
name|sgot
argument_list|)
expr_stmt|;
comment|/* Once we determine the global GOT entry with the lowest dynamic      symbol table index, we must put all dynamic symbols with greater      indices into the GOT.  That makes it easy to calculate the GOT      offset.  */
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|dynindx
operator|>=
name|g
operator|->
name|global_gotsym
operator|->
name|dynindx
argument_list|)
expr_stmt|;
name|index
operator|=
operator|(
operator|(
name|h
operator|->
name|dynindx
operator|-
name|g
operator|->
name|global_gotsym
operator|->
name|dynindx
operator|+
name|g
operator|->
name|local_gotno
operator|)
operator|*
operator|(
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|s
operator|->
name|arch_size
operator|/
literal|8
operator|)
operator|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|index
operator|<
name|sgot
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
return|return
name|index
return|;
block|}
end_function

begin_struct
struct|struct
name|mips_elf64_hash_sort_data
block|{
comment|/* The symbol in the global GOT with the lowest dynamic symbol table      index.  */
name|struct
name|elf_link_hash_entry
modifier|*
name|low
decl_stmt|;
comment|/* The least dynamic symbol table index corresponding to a symbol      with a GOT entry.  */
name|long
name|min_got_dynindx
decl_stmt|;
comment|/* The greatest dynamic symbol table index not corresponding to a      symbol without a GOT entry.  */
name|long
name|max_non_got_dynindx
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* If H needs a GOT entry, assign it the highest available dynamic    index.  Otherwise, assign it the lowest available dynamic     index.  */
end_comment

begin_function
specifier|static
name|boolean
name|mips_elf64_sort_hash_table_f
parameter_list|(
name|h
parameter_list|,
name|data
parameter_list|)
name|struct
name|mips_elf64_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
name|struct
name|mips_elf64_hash_sort_data
modifier|*
name|hsd
init|=
operator|(
expr|struct
name|mips_elf64_hash_sort_data
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|mips_elf64_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
comment|/* Symbols without dynamic symbol table entries aren't interesting      at all.  */
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|dynindx
operator|==
operator|-
literal|1
condition|)
return|return
name|true
return|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|got
operator|.
name|offset
operator|!=
literal|1
condition|)
name|h
operator|->
name|root
operator|.
name|dynindx
operator|=
name|hsd
operator|->
name|max_non_got_dynindx
operator|++
expr_stmt|;
else|else
block|{
name|h
operator|->
name|root
operator|.
name|dynindx
operator|=
operator|--
name|hsd
operator|->
name|min_got_dynindx
expr_stmt|;
name|hsd
operator|->
name|low
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Sort the dynamic symbol table so that symbols that need GOT entries    appear towards the end.  This reduces the amount of GOT space    required.  MAX_LOCAL is used to set the number of local symbols    known to be in the dynamic symbol table.  During    mips_elf64_size_dynamic_sections, this value is 1.  Afterward, the    section symbols are added and the count is higher.  */
end_comment

begin_function
specifier|static
name|boolean
name|mips_elf64_sort_hash_table
parameter_list|(
name|info
parameter_list|,
name|max_local
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|unsigned
name|long
name|max_local
decl_stmt|;
block|{
name|struct
name|mips_elf64_hash_sort_data
name|hsd
decl_stmt|;
name|struct
name|mips_elf64_got_info
modifier|*
name|g
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|hsd
operator|.
name|low
operator|=
name|NULL
expr_stmt|;
name|hsd
operator|.
name|min_got_dynindx
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynsymcount
expr_stmt|;
name|hsd
operator|.
name|max_non_got_dynindx
operator|=
name|max_local
expr_stmt|;
name|mips_elf64_link_hash_traverse
argument_list|(
operator|(
operator|(
expr|struct
name|mips_elf64_link_hash_table
operator|*
operator|)
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|)
argument_list|,
name|mips_elf64_sort_hash_table_f
argument_list|,
operator|&
name|hsd
argument_list|)
expr_stmt|;
comment|/* There shoud have been enough room in the symbol table to      accomodate both the GOT and non-GOT symbols.  */
name|BFD_ASSERT
argument_list|(
name|hsd
operator|.
name|max_non_got_dynindx
operator|<=
name|hsd
operator|.
name|min_got_dynindx
argument_list|)
expr_stmt|;
comment|/* Now we know which dynamic symbol has the lowest dynamic symbol      table index in the GOT.  */
name|g
operator|=
name|_mips_elf64_got_info
argument_list|(
name|dynobj
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g
operator|->
name|global_gotsym
operator|=
name|hsd
operator|.
name|low
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Swap in an MSYM entry.  */
end_comment

begin_endif
unit|static void mips_elf64_swap_msym_in (abfd, ex, in)      bfd *abfd;      const Elf32_External_Msym *ex;      Elf32_Internal_Msym *in; {   in->ms_hash_value = H_GET_32 (abfd, ex->ms_hash_value);   in->ms_info = H_GET_32 (abfd, ex->ms_info); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Swap out an MSYM entry.  */
end_comment

begin_function
specifier|static
name|void
name|mips_elf64_swap_msym_out
parameter_list|(
name|abfd
parameter_list|,
name|in
parameter_list|,
name|ex
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|Elf32_Internal_Msym
modifier|*
name|in
decl_stmt|;
name|Elf32_External_Msym
modifier|*
name|ex
decl_stmt|;
block|{
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|ms_hash_value
argument_list|,
name|ex
operator|->
name|ms_hash_value
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|ms_info
argument_list|,
name|ex
operator|->
name|ms_info
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create a local GOT entry for VALUE.  Return the index of the entry,    or -1 if it could not be created.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|mips_elf64_create_local_got_entry
parameter_list|(
name|abfd
parameter_list|,
name|g
parameter_list|,
name|sgot
parameter_list|,
name|value
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|mips_elf64_got_info
modifier|*
name|g
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
block|{
name|CONST
name|bfd_vma
name|got_size
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|s
operator|->
name|arch_size
operator|/
literal|8
decl_stmt|;
if|if
condition|(
name|g
operator|->
name|assigned_gotno
operator|>=
name|g
operator|->
name|local_gotno
condition|)
block|{
comment|/* We didn't allocate enough space in the GOT.  */
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"not enough GOT space for local GOT entries"
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
return|;
block|}
name|bfd_put_64
argument_list|(
name|abfd
argument_list|,
name|value
argument_list|,
operator|(
name|sgot
operator|->
name|contents
operator|+
name|got_size
operator|*
name|g
operator|->
name|assigned_gotno
operator|)
argument_list|)
expr_stmt|;
return|return
name|got_size
operator|*
name|g
operator|->
name|assigned_gotno
operator|++
return|;
block|}
end_function

begin_comment
comment|/* Returns the GOT offset at which the indicated address can be found.    If there is not yet a GOT entry for this value, create one.  Returns    -1 if no satisfactory GOT offset can be found.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|mips_elf64_local_got_index
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|value
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
block|{
name|CONST
name|bfd_vma
name|got_size
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|s
operator|->
name|arch_size
operator|/
literal|8
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
name|struct
name|mips_elf64_got_info
modifier|*
name|g
decl_stmt|;
name|bfd_byte
modifier|*
name|entry
decl_stmt|;
name|g
operator|=
name|_mips_elf64_got_info
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
argument_list|,
operator|&
name|sgot
argument_list|)
expr_stmt|;
comment|/* Look to see if we already have an appropriate entry.  */
for|for
control|(
name|entry
operator|=
operator|(
name|sgot
operator|->
name|contents
operator|+
name|got_size
operator|*
name|MIPS_RESERVED_GOTNO
operator|)
init|;
name|entry
operator|!=
name|sgot
operator|->
name|contents
operator|+
name|got_size
operator|*
name|g
operator|->
name|assigned_gotno
condition|;
name|entry
operator|+=
name|got_size
control|)
block|{
name|bfd_vma
name|address
init|=
name|bfd_get_64
argument_list|(
name|abfd
argument_list|,
name|entry
argument_list|)
decl_stmt|;
if|if
condition|(
name|address
operator|==
name|value
condition|)
return|return
name|entry
operator|-
name|sgot
operator|->
name|contents
return|;
block|}
return|return
name|mips_elf64_create_local_got_entry
argument_list|(
name|abfd
argument_list|,
name|g
argument_list|,
name|sgot
argument_list|,
name|value
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Find a GOT entry that is within 32KB of the VALUE.  These entries    are supposed to be placed at small offsets in the GOT, i.e.,    within 32KB of GP.  Return the index into the GOT for this page,    and store the offset from this entry to the desired address in    OFFSETP, if it is non-NULL.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|mips_elf64_got_page
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|value
parameter_list|,
name|offsetp
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
name|bfd_vma
modifier|*
name|offsetp
decl_stmt|;
block|{
name|CONST
name|bfd_vma
name|got_size
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|s
operator|->
name|arch_size
operator|/
literal|8
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
name|struct
name|mips_elf64_got_info
modifier|*
name|g
decl_stmt|;
name|bfd_byte
modifier|*
name|entry
decl_stmt|;
name|bfd_byte
modifier|*
name|last_entry
decl_stmt|;
name|bfd_vma
name|index
init|=
literal|0
decl_stmt|;
name|bfd_vma
name|address
decl_stmt|;
name|g
operator|=
name|_mips_elf64_got_info
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
argument_list|,
operator|&
name|sgot
argument_list|)
expr_stmt|;
comment|/* Look to see if we aleady have an appropriate entry.  */
name|last_entry
operator|=
name|sgot
operator|->
name|contents
operator|+
name|got_size
operator|*
name|g
operator|->
name|assigned_gotno
expr_stmt|;
for|for
control|(
name|entry
operator|=
operator|(
name|sgot
operator|->
name|contents
operator|+
name|got_size
operator|*
name|MIPS_RESERVED_GOTNO
operator|)
init|;
name|entry
operator|!=
name|last_entry
condition|;
name|entry
operator|+=
name|got_size
control|)
block|{
name|address
operator|=
name|bfd_get_64
argument_list|(
name|abfd
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mips_elf64_overflow_p
argument_list|(
name|value
operator|-
name|address
argument_list|,
literal|16
argument_list|)
condition|)
block|{
comment|/* This entry will serve as the page pointer.  We can add a 	     16-bit number to it to get the actual address.  */
name|index
operator|=
name|entry
operator|-
name|sgot
operator|->
name|contents
expr_stmt|;
break|break;
block|}
block|}
comment|/* If we didn't have an appropriate entry, we create one now.  */
if|if
condition|(
name|entry
operator|==
name|last_entry
condition|)
name|index
operator|=
name|mips_elf64_create_local_got_entry
argument_list|(
name|abfd
argument_list|,
name|g
argument_list|,
name|sgot
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|offsetp
condition|)
block|{
name|address
operator|=
name|bfd_get_64
argument_list|(
name|abfd
argument_list|,
name|entry
argument_list|)
expr_stmt|;
operator|*
name|offsetp
operator|=
name|value
operator|-
name|address
expr_stmt|;
block|}
return|return
name|index
return|;
block|}
end_function

begin_comment
comment|/* Find a GOT entry whose higher-order 16 bits are the same as those    for value.  Return the index into the GOT for this entry.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|mips_elf64_got16_entry
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|value
parameter_list|,
name|external
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
name|boolean
name|external
decl_stmt|;
block|{
name|CONST
name|bfd_vma
name|got_size
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|s
operator|->
name|arch_size
operator|/
literal|8
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
name|struct
name|mips_elf64_got_info
modifier|*
name|g
decl_stmt|;
name|bfd_byte
modifier|*
name|entry
decl_stmt|;
name|bfd_byte
modifier|*
name|last_entry
decl_stmt|;
name|bfd_vma
name|index
init|=
literal|0
decl_stmt|;
name|bfd_vma
name|address
decl_stmt|;
if|if
condition|(
operator|!
name|external
condition|)
block|{
comment|/* Although the ABI says that it is "the high-order 16 bits" that we 	 want, it is really the %high value.  The complete value is 	 calculated with a `addiu' of a LO16 relocation, just as with a 	 HI16/LO16 pair.  */
name|value
operator|=
name|mips_elf64_high
argument_list|(
name|value
argument_list|)
operator|<<
literal|16
expr_stmt|;
block|}
name|g
operator|=
name|_mips_elf64_got_info
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
argument_list|,
operator|&
name|sgot
argument_list|)
expr_stmt|;
comment|/* Look to see if we already have an appropriate entry.  */
name|last_entry
operator|=
name|sgot
operator|->
name|contents
operator|+
name|got_size
operator|*
name|g
operator|->
name|assigned_gotno
expr_stmt|;
for|for
control|(
name|entry
operator|=
operator|(
name|sgot
operator|->
name|contents
operator|+
name|got_size
operator|*
name|MIPS_RESERVED_GOTNO
operator|)
init|;
name|entry
operator|!=
name|last_entry
condition|;
name|entry
operator|+=
name|got_size
control|)
block|{
name|address
operator|=
name|bfd_get_64
argument_list|(
name|abfd
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|address
operator|==
name|value
condition|)
block|{
comment|/* This entry has the right high-order 16 bits, and the low-order 	     16 bits are set to zero.  */
name|index
operator|=
name|entry
operator|-
name|sgot
operator|->
name|contents
expr_stmt|;
break|break;
block|}
block|}
comment|/* If we didn't have an appropriate entry, we create one now.  */
if|if
condition|(
name|entry
operator|==
name|last_entry
condition|)
name|index
operator|=
name|mips_elf64_create_local_got_entry
argument_list|(
name|abfd
argument_list|,
name|g
argument_list|,
name|sgot
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|index
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return whether a relocation is against a local symbol.  */
end_comment

begin_function
specifier|static
name|boolean
name|mips_elf64_local_relocation_p
parameter_list|(
name|input_bfd
parameter_list|,
name|relocation
parameter_list|,
name|local_sections
parameter_list|,
name|check_forced
parameter_list|)
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocation
decl_stmt|;
name|asection
modifier|*
modifier|*
name|local_sections
decl_stmt|;
name|boolean
name|check_forced
decl_stmt|;
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|mips_elf64_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|size_t
name|extsymoff
decl_stmt|;
name|r_symndx
operator|=
name|ELF64_R_SYM
argument_list|(
name|relocation
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|extsymoff
operator|=
operator|(
name|elf_bad_symtab
argument_list|(
name|input_bfd
argument_list|)
operator|)
condition|?
literal|0
else|:
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|extsymoff
condition|)
return|return
name|true
return|;
if|if
condition|(
name|elf_bad_symtab
argument_list|(
name|input_bfd
argument_list|)
operator|&&
name|local_sections
index|[
name|r_symndx
index|]
operator|!=
name|NULL
condition|)
return|return
name|true
return|;
if|if
condition|(
name|check_forced
condition|)
block|{
comment|/* Look up the hash table to check whether the symbol  	 was forced local.  */
name|h
operator|=
operator|(
expr|struct
name|mips_elf64_link_hash_entry
operator|*
operator|)
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
index|[
name|r_symndx
operator|-
name|extsymoff
index|]
expr_stmt|;
comment|/* Find the real hash-table entry for this symbol.  */
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|mips_elf64_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
operator|(
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_FORCED_LOCAL
operator|)
operator|!=
literal|0
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Returns the first relocation of type r_type found, beginning with    RELOCATION.  RELEND is one-past-the-end of the relocation table.  */
end_comment

begin_function
specifier|static
specifier|const
name|Elf_Internal_Rela
modifier|*
name|mips_elf64_next_relocation
parameter_list|(
name|r_type
parameter_list|,
name|relocation
parameter_list|,
name|relend
parameter_list|)
name|unsigned
name|int
name|r_type
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocation
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relend
decl_stmt|;
block|{
comment|/* According to the MIPS ELF ABI, the R_MIPS_LO16 relocation must be      immediately following.  However, for the IRIX6 ABI, the next      relocation may be a composed relocation consisting of several      relocations for the same address.  In that case, the R_MIPS_LO16      relocation may occur as one of these.  We permit a similar      extension in general, as that is useful for GCC.  */
while|while
condition|(
name|relocation
operator|<
name|relend
condition|)
block|{
if|if
condition|(
name|ELF64_MIPS_R_TYPE
argument_list|(
name|relocation
operator|->
name|r_info
argument_list|)
operator|==
name|r_type
condition|)
return|return
name|relocation
return|;
operator|++
name|relocation
expr_stmt|;
block|}
comment|/* We didn't find it.  */
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Create a rel.dyn relocation for the dynamic linker to resolve.  REL    is the original relocation, which is now being transformed into a    dynamic relocation.  The ADDENDP is adjusted if necessary; the    caller should store the result in place of the original addend.  */
end_comment

begin_function
specifier|static
name|boolean
name|mips_elf64_create_dynamic_relocation
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|rel
parameter_list|,
name|h
parameter_list|,
name|sec
parameter_list|,
name|symbol
parameter_list|,
name|addendp
parameter_list|,
name|input_section
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|struct
name|mips_elf64_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_vma
name|symbol
decl_stmt|;
name|bfd_vma
modifier|*
name|addendp
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
block|{
name|Elf_Internal_Rel
name|outrel
index|[
literal|3
index|]
decl_stmt|;
name|boolean
name|skip
decl_stmt|;
name|asection
modifier|*
name|sreloc
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|int
name|r_type
decl_stmt|;
name|r_type
operator|=
name|ELF64_MIPS_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|sreloc
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rel.dyn"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sreloc
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sreloc
operator|->
name|contents
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
operator|(
name|sreloc
operator|->
name|reloc_count
operator|*
name|get_elf_backend_data
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|s
operator|->
name|sizeof_rel
operator|)
operator|<
name|sreloc
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
name|skip
operator|=
name|false
expr_stmt|;
name|outrel
index|[
literal|0
index|]
operator|.
name|r_offset
operator|=
name|_bfd_elf_section_offset
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|input_section
argument_list|,
name|rel
index|[
literal|0
index|]
operator|.
name|r_offset
argument_list|)
expr_stmt|;
comment|/* FIXME: For -2 runtime relocation needs to be skipped, but      properly resolved statically and installed.  */
name|BFD_ASSERT
argument_list|(
name|outrel
index|[
literal|0
index|]
operator|.
name|r_offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/* We begin by assuming that the offset for the dynamic relocation      is the same as for the original relocation.  We'll adjust this      later to reflect the correct output offsets.  */
if|if
condition|(
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|sec_info_type
operator|!=
name|ELF_INFO_TYPE_STABS
condition|)
block|{
name|outrel
index|[
literal|1
index|]
operator|.
name|r_offset
operator|=
name|rel
index|[
literal|1
index|]
operator|.
name|r_offset
expr_stmt|;
name|outrel
index|[
literal|2
index|]
operator|.
name|r_offset
operator|=
name|rel
index|[
literal|2
index|]
operator|.
name|r_offset
expr_stmt|;
block|}
else|else
block|{
comment|/* Except that in a stab section things are more complex. 	 Because we compress stab information, the offset given in the 	 relocation may not be the one we want; we must let the stabs 	 machinery tell us the offset.  */
name|outrel
index|[
literal|1
index|]
operator|.
name|r_offset
operator|=
name|outrel
index|[
literal|0
index|]
operator|.
name|r_offset
expr_stmt|;
name|outrel
index|[
literal|2
index|]
operator|.
name|r_offset
operator|=
name|outrel
index|[
literal|0
index|]
operator|.
name|r_offset
expr_stmt|;
comment|/* If we didn't need the relocation at all, this value will be 	 -1.  */
if|if
condition|(
name|outrel
index|[
literal|0
index|]
operator|.
name|r_offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
name|skip
operator|=
name|true
expr_stmt|;
block|}
comment|/* If we've decided to skip this relocation, just output an empty      record.  Note that R_MIPS_NONE == 0, so that this call to memset      is a way of setting R_TYPE to R_MIPS_NONE.  */
if|if
condition|(
name|skip
condition|)
name|memset
argument_list|(
name|outrel
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf_Internal_Rel
argument_list|)
operator|*
literal|3
argument_list|)
expr_stmt|;
else|else
block|{
name|long
name|indx
decl_stmt|;
name|bfd_vma
name|section_offset
decl_stmt|;
comment|/* We must now calculate the dynamic symbol table index to use 	 in the relocation.  */
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
operator|!
name|info
operator|->
name|symbolic
operator|||
operator|(
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|indx
operator|=
name|h
operator|->
name|root
operator|.
name|dynindx
expr_stmt|;
comment|/* h->root.dynindx may be -1 if this symbol was marked to 	     become local.  */
if|if
condition|(
name|indx
operator|==
operator|-
literal|1
condition|)
name|indx
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sec
operator|!=
name|NULL
operator|&&
name|bfd_is_abs_section
argument_list|(
name|sec
argument_list|)
condition|)
name|indx
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|sec
operator|==
name|NULL
operator|||
name|sec
operator|->
name|owner
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
else|else
block|{
name|indx
operator|=
name|elf_section_data
argument_list|(
name|sec
operator|->
name|output_section
argument_list|)
operator|->
name|dynindx
expr_stmt|;
if|if
condition|(
name|indx
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Figure out how far the target of the relocation is from 	     the beginning of its section.  */
name|section_offset
operator|=
name|symbol
operator|-
name|sec
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
comment|/* The relocation we're building is section-relative. 	     Therefore, the original addend must be adjusted by the 	     section offset.  */
operator|*
name|addendp
operator|+=
name|section_offset
expr_stmt|;
comment|/* Now, the relocation is just against the section.  */
name|symbol
operator|=
name|sec
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
block|}
comment|/* If the relocation was previously an absolute relocation and 	 this symbol will not be referred to by the relocation, we must 	 adjust it by the value we give it in the dynamic symbol table. 	 Otherwise leave the job up to the dynamic linker.  */
if|if
condition|(
operator|!
name|indx
operator|&&
name|r_type
operator|!=
name|R_MIPS_REL32
condition|)
operator|*
name|addendp
operator|+=
name|symbol
expr_stmt|;
comment|/* The relocation is always an REL32 relocation because we don't 	 know where the shared library will wind up at load-time.  */
name|outrel
index|[
literal|0
index|]
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|indx
argument_list|,
name|R_MIPS_REL32
argument_list|)
expr_stmt|;
comment|/* Adjust the output offset of the relocation to reference the 	 correct location in the output file.  */
name|outrel
index|[
literal|0
index|]
operator|.
name|r_offset
operator|+=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|outrel
index|[
literal|1
index|]
operator|.
name|r_offset
operator|+=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|outrel
index|[
literal|2
index|]
operator|.
name|r_offset
operator|+=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
comment|/* Put the relocation back out.  */
name|mips_elf64_be_swap_reloc_out
argument_list|(
name|output_bfd
argument_list|,
name|outrel
argument_list|,
operator|(
name|sreloc
operator|->
name|contents
operator|+
name|sreloc
operator|->
name|reloc_count
operator|*
sizeof|sizeof
argument_list|(
name|Elf64_Mips_External_Rel
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Record the index of the first relocation referencing H.  This      information is later emitted in the .msym section.  */
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|min_dyn_reloc_index
operator|==
literal|0
operator|||
name|sreloc
operator|->
name|reloc_count
operator|<
name|h
operator|->
name|min_dyn_reloc_index
operator|)
condition|)
name|h
operator|->
name|min_dyn_reloc_index
operator|=
name|sreloc
operator|->
name|reloc_count
expr_stmt|;
comment|/* We've now added another relocation.  */
operator|++
name|sreloc
operator|->
name|reloc_count
expr_stmt|;
comment|/* Make sure the output section is writable.  The dynamic linker      will be writing to it.  */
name|elf_section_data
argument_list|(
name|input_section
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_flags
operator||=
name|SHF_WRITE
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Calculate the value produced by the RELOCATION (which comes from    the INPUT_BFD).  The ADDEND is the addend to use for this    RELOCATION; RELOCATION->R_ADDEND is ignored.     The result of the relocation calculation is stored in VALUEP.    REQUIRE_JALXP indicates whether or not the opcode used with this    relocation must be JALX.     This function returns bfd_reloc_continue if the caller need take no    further action regarding this relocation, bfd_reloc_notsupported if    something goes dramatically wrong, bfd_reloc_overflow if an    overflow occurs, and bfd_reloc_ok to indicate success.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|mips_elf64_calculate_relocation
parameter_list|(
name|abfd
parameter_list|,
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|info
parameter_list|,
name|relocation
parameter_list|,
name|addend
parameter_list|,
name|howto
parameter_list|,
name|local_syms
parameter_list|,
name|local_sections
parameter_list|,
name|valuep
parameter_list|,
name|namep
parameter_list|,
name|require_jalxp
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocation
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|local_syms
decl_stmt|;
name|asection
modifier|*
modifier|*
name|local_sections
decl_stmt|;
name|bfd_vma
modifier|*
name|valuep
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|namep
decl_stmt|;
name|boolean
modifier|*
name|require_jalxp
decl_stmt|;
block|{
comment|/* The eventual value we will return.  */
name|bfd_vma
name|value
decl_stmt|;
comment|/* The address of the symbol against which the relocation is      occurring.  */
name|bfd_vma
name|symbol
init|=
literal|0
decl_stmt|;
comment|/* The final GP value to be used for the relocatable, executable, or      shared object file being produced.  */
name|bfd_vma
name|gp
init|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
decl_stmt|;
comment|/* The place (section offset or address) of the storage unit being      relocated.  */
name|bfd_vma
name|p
decl_stmt|;
comment|/* The value of GP used to create the relocatable object.  */
name|bfd_vma
name|gp0
init|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
decl_stmt|;
comment|/* The offset into the global offset table at which the address of      the relocation entry symbol, adjusted by the addend, resides      during execution.  */
name|bfd_vma
name|g
init|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
decl_stmt|;
comment|/* The section in which the symbol referenced by the relocation is      located.  */
name|asection
modifier|*
name|sec
init|=
name|NULL
decl_stmt|;
name|struct
name|mips_elf64_link_hash_entry
modifier|*
name|h
init|=
name|NULL
decl_stmt|;
comment|/* True if the symbol referred to by this relocation is a local      symbol.  */
name|boolean
name|local_p
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|size_t
name|extsymoff
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|int
name|r_type
decl_stmt|;
comment|/* True if overflow occurred during the calculation of the      relocation value.  */
name|boolean
name|overflowed_p
decl_stmt|;
comment|/* True if this relocation refers to a MIPS16 function.  */
name|boolean
name|target_is_16_bit_code_p
init|=
name|false
decl_stmt|;
comment|/* Parse the relocation.  */
name|r_symndx
operator|=
name|ELF64_R_SYM
argument_list|(
name|relocation
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|ELF64_MIPS_R_TYPE
argument_list|(
name|relocation
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|relocation
operator|->
name|r_offset
operator|)
expr_stmt|;
comment|/* Assume that there will be no overflow.  */
name|overflowed_p
operator|=
name|false
expr_stmt|;
comment|/* Figure out whether or not the symbol is local, and get the offset      used in the array of hash table entries.  */
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|local_p
operator|=
name|mips_elf64_local_relocation_p
argument_list|(
name|input_bfd
argument_list|,
name|relocation
argument_list|,
name|local_sections
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|elf_bad_symtab
argument_list|(
name|input_bfd
argument_list|)
condition|)
name|extsymoff
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
else|else
block|{
comment|/* The symbol table does not follow the rule that local symbols 	 must come before globals.  */
name|extsymoff
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Figure out the value of the symbol.  */
if|if
condition|(
name|local_p
condition|)
block|{
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|symbol
operator|=
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
expr_stmt|;
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|!=
name|STT_SECTION
condition|)
name|symbol
operator|+=
name|sym
operator|->
name|st_value
expr_stmt|;
comment|/* MIPS16 text labels should be treated as odd.  */
if|if
condition|(
name|sym
operator|->
name|st_other
operator|==
name|STO_MIPS16
condition|)
operator|++
name|symbol
expr_stmt|;
comment|/* Record the name of this symbol, for our caller.  */
operator|*
name|namep
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_link
argument_list|,
name|sym
operator|->
name|st_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|namep
operator|==
literal|'\0'
condition|)
operator|*
name|namep
operator|=
name|bfd_section_name
argument_list|(
name|input_bfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|target_is_16_bit_code_p
operator|=
operator|(
name|sym
operator|->
name|st_other
operator|==
name|STO_MIPS16
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* For global symbols we look up the symbol in the hash-table.  */
name|h
operator|=
operator|(
operator|(
expr|struct
name|mips_elf64_link_hash_entry
operator|*
operator|)
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
index|[
name|r_symndx
operator|-
name|extsymoff
index|]
operator|)
expr_stmt|;
comment|/* Find the real hash-table entry for this symbol.  */
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|mips_elf64_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
comment|/* Record the name of this symbol, for our caller.  */
operator|*
name|namep
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
comment|/* If this symbol is defined, calculate its address.  */
if|if
condition|(
operator|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
condition|)
block|{
name|sec
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|output_section
condition|)
name|symbol
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|)
expr_stmt|;
else|else
name|symbol
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
comment|/* We allow relocations against undefined weak symbols, giving 	   it the value zero, so that you can undefined weak functions 	   and check to see if they exist by looking at their 	   addresses.  */
name|symbol
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
operator|(
operator|!
name|info
operator|->
name|symbolic
operator|||
name|info
operator|->
name|allow_shlib_undefined
operator|)
operator|&&
operator|!
name|info
operator|->
name|no_undefined
operator|&&
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|root
operator|.
name|other
argument_list|)
operator|==
name|STV_DEFAULT
condition|)
name|symbol
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_DYNAMIC_LINK"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_DYNAMIC_LINKING"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* If this is a dynamic link, we should have created a 	     _DYNAMIC_LINK symbol or _DYNAMIC_LINKING(for normal mips) symbol  	     in in mips_elf64_create_dynamic_sections. 	     Otherwise, we should define the symbol with a value of 0. 	     FIXME: It should probably get into the symbol table 	     somehow as well.  */
name|BFD_ASSERT
argument_list|(
operator|!
name|info
operator|->
name|shared
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynamic"
argument_list|)
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|symbol
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|relocation
operator|->
name|r_offset
argument_list|,
operator|(
operator|!
name|info
operator|->
name|shared
operator|||
name|info
operator|->
name|no_undefined
operator|||
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|root
operator|.
name|other
argument_list|)
operator|)
argument_list|)
operator|)
condition|)
return|return
name|bfd_reloc_undefined
return|;
name|symbol
operator|=
literal|0
expr_stmt|;
block|}
name|target_is_16_bit_code_p
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|other
operator|==
name|STO_MIPS16
operator|)
expr_stmt|;
block|}
comment|/* If this is a 64-bit call to a 16-bit function with a stub, we      need to redirect the call to the stub, unless we're already *in*      a stub.  */
if|if
condition|(
name|r_type
operator|!=
name|R_MIPS16_26
operator|&&
operator|!
name|info
operator|->
name|relocateable
operator|&&
operator|(
operator|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|fn_stub
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|local_p
operator|&&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|local_stubs
operator|!=
name|NULL
operator|&&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|local_stubs
index|[
name|r_symndx
index|]
operator|!=
name|NULL
operator|)
operator|)
operator|&&
operator|!
name|mips_elf64_stub_section_p
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
condition|)
block|{
comment|/* This is a 64-bit call to a 16-bit function.  We should 	 have already noticed that we were going to need the 	 stub.  */
if|if
condition|(
name|local_p
condition|)
name|sec
operator|=
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|local_stubs
index|[
name|r_symndx
index|]
expr_stmt|;
else|else
block|{
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|need_fn_stub
argument_list|)
expr_stmt|;
name|sec
operator|=
name|h
operator|->
name|fn_stub
expr_stmt|;
block|}
name|symbol
operator|=
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
expr_stmt|;
block|}
comment|/* If this is a 16-bit call to a 64-bit function with a stub, we      need to redirect the call to the stub.  */
elseif|else
if|if
condition|(
name|r_type
operator|==
name|R_MIPS16_26
operator|&&
operator|!
name|info
operator|->
name|relocateable
operator|&&
name|h
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|call_stub
operator|!=
name|NULL
operator|||
name|h
operator|->
name|call_fp_stub
operator|!=
name|NULL
operator|)
operator|&&
operator|!
name|target_is_16_bit_code_p
condition|)
block|{
comment|/* If both call_stub and call_fp_stub are defined, we can figure 	 out which one to use by seeing which one appears in the input 	 file.  */
if|if
condition|(
name|h
operator|->
name|call_stub
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|call_fp_stub
operator|!=
name|NULL
condition|)
block|{
name|asection
modifier|*
name|o
decl_stmt|;
name|sec
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|o
operator|=
name|input_bfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|input_bfd
argument_list|,
name|o
argument_list|)
argument_list|,
name|CALL_FP_STUB
argument_list|,
sizeof|sizeof
name|CALL_FP_STUB
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sec
operator|=
name|h
operator|->
name|call_fp_stub
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
name|sec
operator|=
name|h
operator|->
name|call_stub
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|->
name|call_stub
operator|!=
name|NULL
condition|)
name|sec
operator|=
name|h
operator|->
name|call_stub
expr_stmt|;
else|else
name|sec
operator|=
name|h
operator|->
name|call_fp_stub
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sec
operator|->
name|_raw_size
operator|>
literal|0
argument_list|)
expr_stmt|;
name|symbol
operator|=
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
expr_stmt|;
block|}
comment|/* Calls from 16-bit code to 32-bit code and vice versa require the      special jalx instruction.  */
operator|*
name|require_jalxp
operator|=
operator|(
operator|!
name|info
operator|->
name|relocateable
operator|&&
operator|(
operator|(
name|r_type
operator|==
name|R_MIPS16_26
operator|)
operator|!=
name|target_is_16_bit_code_p
operator|)
operator|)
expr_stmt|;
name|local_p
operator|=
name|mips_elf64_local_relocation_p
argument_list|(
name|input_bfd
argument_list|,
name|relocation
argument_list|,
name|local_sections
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* If we haven't already determined the GOT offset, or the GP value,      and we're going to need it, get it now.  */
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_MIPS_CALL16
case|:
case|case
name|R_MIPS_GOT16
case|:
case|case
name|R_MIPS_GOT_DISP
case|:
case|case
name|R_MIPS_GOT_HI16
case|:
case|case
name|R_MIPS_CALL_HI16
case|:
case|case
name|R_MIPS_GOT_LO16
case|:
case|case
name|R_MIPS_CALL_LO16
case|:
comment|/* Find the index into the GOT where this value is located.  */
if|if
condition|(
operator|!
name|local_p
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|addend
operator|==
literal|0
argument_list|)
expr_stmt|;
name|g
operator|=
name|mips_elf64_global_got_index
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
argument_list|,
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
operator|||
operator|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|info
operator|->
name|symbolic
operator|||
name|h
operator|->
name|root
operator|.
name|dynindx
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|)
condition|)
block|{
comment|/* This is a static link or a -Bsymbolic link.  The 		 symbol is defined locally, or was forced to be local. 		 We must initialize this entry in the GOT.  */
name|bfd
modifier|*
name|tmpbfd
init|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|sgot
init|=
name|bfd_get_section_by_name
argument_list|(
name|tmpbfd
argument_list|,
literal|".got"
argument_list|)
decl_stmt|;
name|bfd_put_64
argument_list|(
name|tmpbfd
argument_list|,
name|symbol
operator|+
name|addend
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|g
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|r_type
operator|==
name|R_MIPS_GOT16
operator|||
name|r_type
operator|==
name|R_MIPS_CALL16
condition|)
comment|/* There's no need to create a local GOT entry here; the 	   calculation for a local GOT16 entry does not involve G.  */
break|break;
else|else
block|{
name|g
operator|=
name|mips_elf64_local_got_index
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|symbol
operator|+
name|addend
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
return|return
name|false
return|;
block|}
comment|/* Convert GOT indices to actual offsets.  */
name|g
operator|=
name|mips_elf64_got_offset_from_index
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
argument_list|,
name|abfd
argument_list|,
name|g
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_MIPS_HI16
case|:
case|case
name|R_MIPS_LO16
case|:
case|case
name|R_MIPS_GPREL16
case|:
case|case
name|R_MIPS_GPREL32
case|:
case|case
name|R_MIPS_LITERAL
case|:
name|gp0
operator|=
name|_bfd_get_gp_value
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|gp
operator|=
name|_bfd_get_gp_value
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* Figure out what kind of relocation is being performed.  */
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_MIPS_NONE
case|:
return|return
name|bfd_reloc_continue
return|;
case|case
name|R_MIPS_16
case|:
name|value
operator|=
name|symbol
operator|+
name|mips_elf64_sign_extend
argument_list|(
name|addend
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|overflowed_p
operator|=
name|mips_elf64_overflow_p
argument_list|(
name|value
argument_list|,
literal|16
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_MIPS_32
case|:
case|case
name|R_MIPS_REL32
case|:
case|case
name|R_MIPS_64
case|:
if|if
condition|(
operator|(
name|info
operator|->
name|shared
operator|||
operator|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
operator|&&
name|h
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
operator|)
operator|)
operator|&&
name|r_symndx
operator|!=
literal|0
operator|&&
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* If we're creating a shared library, or this relocation is 	     against a symbol in a shared library, then we can't know 	     where the symbol will end up.  So, we create a relocation 	     record in the output, and leave the job up to the dynamic 	     linker.  */
name|value
operator|=
name|addend
expr_stmt|;
if|if
condition|(
operator|!
name|mips_elf64_create_dynamic_relocation
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|relocation
argument_list|,
name|h
argument_list|,
name|sec
argument_list|,
name|symbol
argument_list|,
operator|&
name|value
argument_list|,
name|input_section
argument_list|)
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
if|if
condition|(
name|r_type
operator|!=
name|R_MIPS_REL32
condition|)
name|value
operator|=
name|symbol
operator|+
name|addend
expr_stmt|;
else|else
name|value
operator|=
name|addend
expr_stmt|;
block|}
name|value
operator|&=
name|howto
operator|->
name|dst_mask
expr_stmt|;
break|break;
case|case
name|R_MIPS_PC32
case|:
case|case
name|R_MIPS_PC64
case|:
case|case
name|R_MIPS_GNU_REL_LO16
case|:
name|value
operator|=
name|symbol
operator|+
name|addend
operator|-
name|p
expr_stmt|;
name|value
operator|&=
name|howto
operator|->
name|dst_mask
expr_stmt|;
break|break;
case|case
name|R_MIPS_GNU_REL16_S2
case|:
name|value
operator|=
name|symbol
operator|+
name|mips_elf64_sign_extend
argument_list|(
name|addend
operator|<<
literal|2
argument_list|,
literal|18
argument_list|)
operator|-
name|p
expr_stmt|;
name|overflowed_p
operator|=
name|mips_elf64_overflow_p
argument_list|(
name|value
argument_list|,
literal|18
argument_list|)
expr_stmt|;
name|value
operator|=
operator|(
name|value
operator|>>
literal|2
operator|)
operator|&
name|howto
operator|->
name|dst_mask
expr_stmt|;
break|break;
case|case
name|R_MIPS_GNU_REL_HI16
case|:
name|value
operator|=
name|mips_elf64_high
argument_list|(
name|addend
operator|+
name|symbol
operator|-
name|p
argument_list|)
expr_stmt|;
name|value
operator|&=
name|howto
operator|->
name|dst_mask
expr_stmt|;
break|break;
case|case
name|R_MIPS16_26
case|:
comment|/* The calculation for R_MIPS16_26 is just the same as for an 	 R_MIPS_26.  It's only the storage of the relocated field into 	 the output file that's different.  That's handled in 	 mips_elf_perform_relocation.  So, we just fall through to the 	 R_MIPS_26 case here.  */
case|case
name|R_MIPS_26
case|:
if|if
condition|(
name|local_p
condition|)
name|value
operator|=
operator|(
operator|(
operator|(
name|addend
operator|<<
literal|2
operator|)
operator||
operator|(
operator|(
name|p
operator|+
literal|4
operator|)
operator|&
literal|0xf0000000
operator|)
operator|)
operator|+
name|symbol
operator|)
operator|>>
literal|2
expr_stmt|;
else|else
name|value
operator|=
operator|(
name|mips_elf64_sign_extend
argument_list|(
name|addend
operator|<<
literal|2
argument_list|,
literal|28
argument_list|)
operator|+
name|symbol
operator|)
operator|>>
literal|2
expr_stmt|;
name|value
operator|&=
name|howto
operator|->
name|dst_mask
expr_stmt|;
break|break;
case|case
name|R_MIPS_HI16
case|:
name|value
operator|=
name|mips_elf64_high
argument_list|(
name|addend
operator|+
name|symbol
argument_list|)
expr_stmt|;
name|value
operator|&=
name|howto
operator|->
name|dst_mask
expr_stmt|;
break|break;
case|case
name|R_MIPS_LO16
case|:
name|value
operator|=
operator|(
name|addend
operator|+
name|symbol
operator|)
operator|&
literal|0xffff
expr_stmt|;
name|value
operator|&=
name|howto
operator|->
name|dst_mask
expr_stmt|;
break|break;
case|case
name|R_MIPS_LITERAL
case|:
comment|/* Because we don't merge literal sections, we can handle this 	 just like R_MIPS_GPREL16.  In the long run, we should merge 	 shared literals, and then we will need to additional work 	 here.  */
comment|/* Fall through.  */
case|case
name|R_MIPS_GPREL16
case|:
if|if
condition|(
name|local_p
condition|)
name|value
operator|=
name|mips_elf64_sign_extend
argument_list|(
name|addend
argument_list|,
literal|16
argument_list|)
operator|+
name|symbol
operator|+
name|gp0
operator|-
name|gp
expr_stmt|;
else|else
name|value
operator|=
name|mips_elf64_sign_extend
argument_list|(
name|addend
argument_list|,
literal|16
argument_list|)
operator|+
name|symbol
operator|-
name|gp
expr_stmt|;
name|overflowed_p
operator|=
name|mips_elf64_overflow_p
argument_list|(
name|value
argument_list|,
literal|16
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_MIPS_PC16
case|:
name|value
operator|=
name|mips_elf64_sign_extend
argument_list|(
name|addend
argument_list|,
literal|16
argument_list|)
operator|+
name|symbol
operator|-
name|p
expr_stmt|;
name|overflowed_p
operator|=
name|mips_elf64_overflow_p
argument_list|(
name|value
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|value
operator|=
call|(
name|bfd_vma
call|)
argument_list|(
operator|(
name|bfd_signed_vma
operator|)
name|value
operator|/
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_MIPS_GOT16
case|:
case|case
name|R_MIPS_CALL16
case|:
if|if
condition|(
name|local_p
condition|)
block|{
name|boolean
name|forced
decl_stmt|;
comment|/* The special case is when the symbol is forced to be local.  We 	     need the full address in the GOT since no R_MIPS_LO16 relocation 	     follows.  */
name|forced
operator|=
operator|!
name|mips_elf64_local_relocation_p
argument_list|(
name|input_bfd
argument_list|,
name|relocation
argument_list|,
name|local_sections
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|value
operator|=
name|mips_elf64_got16_entry
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|symbol
operator|+
name|addend
argument_list|,
name|forced
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
return|return
name|false
return|;
name|value
operator|=
name|mips_elf64_got_offset_from_index
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
argument_list|,
name|abfd
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|overflowed_p
operator|=
name|mips_elf64_overflow_p
argument_list|(
name|value
argument_list|,
literal|16
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Fall through.  */
case|case
name|R_MIPS_GOT_DISP
case|:
name|value
operator|=
name|g
expr_stmt|;
name|overflowed_p
operator|=
name|mips_elf64_overflow_p
argument_list|(
name|value
argument_list|,
literal|16
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_MIPS_GPREL32
case|:
name|value
operator|=
operator|(
name|addend
operator|+
name|symbol
operator|+
name|gp0
operator|-
name|gp
operator|)
operator|&
name|howto
operator|->
name|dst_mask
expr_stmt|;
break|break;
case|case
name|R_MIPS_GOT_HI16
case|:
case|case
name|R_MIPS_CALL_HI16
case|:
comment|/* We're allowed to handle these two relocations identically. 	 The dynamic linker is allowed to handle the CALL relocations 	 differently by creating a lazy evaluation stub.  */
name|value
operator|=
name|g
expr_stmt|;
name|value
operator|=
name|mips_elf64_high
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|value
operator|&=
name|howto
operator|->
name|dst_mask
expr_stmt|;
break|break;
case|case
name|R_MIPS_GOT_LO16
case|:
case|case
name|R_MIPS_CALL_LO16
case|:
name|value
operator|=
name|g
operator|&
name|howto
operator|->
name|dst_mask
expr_stmt|;
break|break;
case|case
name|R_MIPS_GOT_PAGE
case|:
name|value
operator|=
name|mips_elf64_got_page
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|symbol
operator|+
name|addend
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
return|return
name|false
return|;
name|value
operator|=
name|mips_elf64_got_offset_from_index
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
argument_list|,
name|abfd
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|overflowed_p
operator|=
name|mips_elf64_overflow_p
argument_list|(
name|value
argument_list|,
literal|16
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_MIPS_GOT_OFST
case|:
name|mips_elf64_got_page
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|symbol
operator|+
name|addend
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
name|overflowed_p
operator|=
name|mips_elf64_overflow_p
argument_list|(
name|value
argument_list|,
literal|16
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_MIPS_SUB
case|:
name|value
operator|=
name|symbol
operator|-
name|addend
expr_stmt|;
name|value
operator|&=
name|howto
operator|->
name|dst_mask
expr_stmt|;
break|break;
case|case
name|R_MIPS_HIGHER
case|:
name|value
operator|=
name|mips_elf64_higher
argument_list|(
name|addend
operator|+
name|symbol
argument_list|)
expr_stmt|;
name|value
operator|&=
name|howto
operator|->
name|dst_mask
expr_stmt|;
break|break;
case|case
name|R_MIPS_HIGHEST
case|:
name|value
operator|=
name|mips_elf64_highest
argument_list|(
name|addend
operator|+
name|symbol
argument_list|)
expr_stmt|;
name|value
operator|&=
name|howto
operator|->
name|dst_mask
expr_stmt|;
break|break;
case|case
name|R_MIPS_SCN_DISP
case|:
name|value
operator|=
name|symbol
operator|+
name|addend
operator|-
name|sec
operator|->
name|output_offset
expr_stmt|;
name|value
operator|&=
name|howto
operator|->
name|dst_mask
expr_stmt|;
break|break;
case|case
name|R_MIPS_PJUMP
case|:
case|case
name|R_MIPS_JALR
case|:
comment|/* Both of these may be ignored.  R_MIPS_JALR is an optimization 	 hint; we could improve performance by honoring that hint.  */
return|return
name|bfd_reloc_continue
return|;
case|case
name|R_MIPS_GNU_VTINHERIT
case|:
case|case
name|R_MIPS_GNU_VTENTRY
case|:
comment|/* We don't do anything with these at present.  */
return|return
name|bfd_reloc_continue
return|;
default|default:
comment|/* An unrecognized relocation type.  */
return|return
name|bfd_reloc_notsupported
return|;
block|}
comment|/* Store the VALUE for our caller.  */
operator|*
name|valuep
operator|=
name|value
expr_stmt|;
return|return
name|overflowed_p
condition|?
name|bfd_reloc_overflow
else|:
name|bfd_reloc_ok
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Obtain the field relocated by RELOCATION.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|mips_elf64_obtain_contents
parameter_list|(
name|howto
parameter_list|,
name|relocation
parameter_list|,
name|input_bfd
parameter_list|,
name|contents
parameter_list|)
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocation
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
block|{
name|bfd_byte
modifier|*
name|location
init|=
name|contents
operator|+
name|relocation
operator|->
name|r_offset
decl_stmt|;
comment|/* Obtain the bytes.  */
return|return
name|bfd_get
argument_list|(
literal|8
operator|*
name|bfd_get_reloc_size
argument_list|(
name|howto
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|location
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* It has been determined that the result of the RELOCATION is the    VALUE.  Use HOWTO to place VALUE into the output file at the    appropriate position.  The SECTION is the section to which the    relocation applies.  If REQUIRE_JALX is true, then the opcode used    for the relocation must be either JAL or JALX, and it is    unconditionally converted to JALX.     Returns false if anything goes wrong.  */
end_comment

begin_function
specifier|static
name|boolean
name|mips_elf64_perform_relocation
parameter_list|(
name|info
parameter_list|,
name|howto
parameter_list|,
name|relocation
parameter_list|,
name|value
parameter_list|,
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|contents
parameter_list|,
name|require_jalx
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocation
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|boolean
name|require_jalx
decl_stmt|;
block|{
name|bfd_vma
name|x
decl_stmt|;
name|bfd_byte
modifier|*
name|location
decl_stmt|;
name|int
name|r_type
init|=
name|ELF32_R_TYPE
argument_list|(
name|relocation
operator|->
name|r_info
argument_list|)
decl_stmt|;
comment|/* Figure out where the relocation is occurring.  */
name|location
operator|=
name|contents
operator|+
name|relocation
operator|->
name|r_offset
expr_stmt|;
comment|/* Obtain the current value.  */
name|x
operator|=
name|mips_elf64_obtain_contents
argument_list|(
name|howto
argument_list|,
name|relocation
argument_list|,
name|input_bfd
argument_list|,
name|contents
argument_list|)
expr_stmt|;
comment|/* Clear the field we are setting.  */
name|x
operator|&=
operator|~
name|howto
operator|->
name|dst_mask
expr_stmt|;
comment|/* If this is the R_MIPS16_26 relocation, we must store the      value in a funny way.  */
if|if
condition|(
name|r_type
operator|==
name|R_MIPS16_26
condition|)
block|{
comment|/* R_MIPS16_26 is used for the mips16 jal and jalx instructions. 	 Most mips16 instructions are 16 bits, but these instructions 	 are 32 bits.  	 The format of these instructions is:  	 +--------------+--------------------------------+ 	 !     JALX     ! X!   Imm 20:16  !   Imm 25:21  ! 	 +--------------+--------------------------------+ 	 !	  	  Immediate  15:0		    ! 	 +-----------------------------------------------+  	 JALX is the 5-bit value 00011.  X is 0 for jal, 1 for jalx. 	 Note that the immediate value in the first word is swapped.  	 When producing a relocateable object file, R_MIPS16_26 is 	 handled mostly like R_MIPS_26.  In particular, the addend is 	 stored as a straight 26-bit value in a 32-bit instruction. 	 (gas makes life simpler for itself by never adjusting a 	 R_MIPS16_26 reloc to be against a section, so the addend is 	 always zero).  However, the 32 bit instruction is stored as 2 	 16-bit values, rather than a single 32-bit value.  In a 	 big-endian file, the result is the same; in a little-endian 	 file, the two 16-bit halves of the 32 bit value are swapped. 	 This is so that a disassembler can recognize the jal 	 instruction.  	 When doing a final link, R_MIPS16_26 is treated as a 32 bit 	 instruction stored as two 16-bit values.  The addend A is the 	 contents of the targ26 field.  The calculation is the same as 	 R_MIPS_26.  When storing the calculated value, reorder the 	 immediate value as shown above, and don't forget to store the 	 value as two 16-bit values.  	 To put it in MIPS ABI terms, the relocation field is T-targ26-16, 	 defined as  	 big-endian: 	 +--------+----------------------+ 	 |        |                      | 	 |        |    targ26-16         | 	 |31    26|25                   0| 	 +--------+----------------------+  	 little-endian: 	 +----------+------+-------------+ 	 |          |      |             | 	 |  sub1    |      |     sub2    | 	 |0        9|10  15|16         31| 	 +----------+--------------------+ 	 where targ26-16 is sub1 followed by sub2 (i.e., the addend field A is 	 ((sub1<< 16) | sub2)).  	 When producing a relocateable object file, the calculation is 	 (((A< 2) | ((P + 4)& 0xf0000000) + S)>> 2) 	 When producing a fully linked file, the calculation is 	 let R = (((A< 2) | ((P + 4)& 0xf0000000) + S)>> 2) 	 ((R& 0x1f0000)<< 5) | ((R& 0x3e00000)>> 5) | (R& 0xffff)  */
if|if
condition|(
operator|!
name|info
operator|->
name|relocateable
condition|)
comment|/* Shuffle the bits according to the formula above.  */
name|value
operator|=
operator|(
operator|(
operator|(
name|value
operator|&
literal|0x1f0000
operator|)
operator|<<
literal|5
operator|)
operator||
operator|(
operator|(
name|value
operator|&
literal|0x3e00000
operator|)
operator|>>
literal|5
operator|)
operator||
operator|(
name|value
operator|&
literal|0xffff
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r_type
operator|==
name|R_MIPS16_GPREL
condition|)
block|{
comment|/* R_MIPS16_GPREL is used for GP-relative addressing in mips16 	 mode.  A typical instruction will have a format like this:  	 +--------------+--------------------------------+ 	 !    EXTEND    !     Imm 10:5    !   Imm 15:11  ! 	 +--------------+--------------------------------+ 	 !    Major     !   rx   !   ry   !   Imm  4:0   ! 	 +--------------+--------------------------------+  	 EXTEND is the five bit value 11110.  Major is the instruction 	 opcode.  	 This is handled exactly like R_MIPS_GPREL16, except that the 	 addend is retrieved and stored as shown in this diagram; that 	 is, the Imm fields above replace the V-rel16 field.           All we need to do here is shuffle the bits appropriately.  As 	 above, the two 16-bit halves must be swapped on a 	 little-endian system.  */
name|value
operator|=
operator|(
operator|(
operator|(
name|value
operator|&
literal|0x7e0
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|value
operator|&
literal|0xf800
operator|)
operator|<<
literal|5
operator|)
operator||
operator|(
name|value
operator|&
literal|0x1f
operator|)
operator|)
expr_stmt|;
block|}
comment|/* Set the field.  */
name|x
operator||=
operator|(
name|value
operator|&
name|howto
operator|->
name|dst_mask
operator|)
expr_stmt|;
comment|/* If required, turn JAL into JALX.  */
if|if
condition|(
name|require_jalx
condition|)
block|{
name|boolean
name|ok
decl_stmt|;
name|bfd_vma
name|opcode
init|=
name|x
operator|>>
literal|26
decl_stmt|;
name|bfd_vma
name|jalx_opcode
decl_stmt|;
comment|/* Check to see if the opcode is already JAL or JALX.  */
if|if
condition|(
name|r_type
operator|==
name|R_MIPS16_26
condition|)
block|{
name|ok
operator|=
operator|(
operator|(
name|opcode
operator|==
literal|0x6
operator|)
operator|||
operator|(
name|opcode
operator|==
literal|0x7
operator|)
operator|)
expr_stmt|;
name|jalx_opcode
operator|=
literal|0x7
expr_stmt|;
block|}
else|else
block|{
name|ok
operator|=
operator|(
operator|(
name|opcode
operator|==
literal|0x3
operator|)
operator|||
operator|(
name|opcode
operator|==
literal|0x1d
operator|)
operator|)
expr_stmt|;
name|jalx_opcode
operator|=
literal|0x1d
expr_stmt|;
block|}
comment|/* If the opcode is not JAL or JALX, there's a problem.  */
if|if
condition|(
operator|!
name|ok
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: %s+0x%lx: jump to stub routine which is not jal"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|input_section
operator|->
name|name
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|relocation
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Make this the JALX opcode.  */
name|x
operator|=
operator|(
name|x
operator|&
operator|~
operator|(
literal|0x3f
operator|<<
literal|26
operator|)
operator|)
operator||
operator|(
name|jalx_opcode
operator|<<
literal|26
operator|)
expr_stmt|;
block|}
comment|/* Swap the high- and low-order 16 bits on little-endian systems      when doing a MIPS16 relocation.  */
if|if
condition|(
operator|(
name|r_type
operator|==
name|R_MIPS16_GPREL
operator|||
name|r_type
operator|==
name|R_MIPS16_26
operator|)
operator|&&
name|bfd_little_endian
argument_list|(
name|input_bfd
argument_list|)
condition|)
name|x
operator|=
operator|(
operator|(
operator|(
name|x
operator|&
literal|0xffff
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|x
operator|&
literal|0xffff0000
operator|)
operator|>>
literal|16
operator|)
operator|)
expr_stmt|;
comment|/* Put the value into the output.  */
name|bfd_put
argument_list|(
literal|8
operator|*
name|bfd_get_reloc_size
argument_list|(
name|howto
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|x
argument_list|,
name|location
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Returns true if SECTION is a MIPS16 stub section.  */
end_comment

begin_function
specifier|static
name|boolean
name|mips_elf64_stub_section_p
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
decl_stmt|;
return|return
operator|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|FN_STUB
argument_list|,
sizeof|sizeof
name|FN_STUB
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|name
argument_list|,
name|CALL_STUB
argument_list|,
sizeof|sizeof
name|CALL_STUB
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|name
argument_list|,
name|CALL_FP_STUB
argument_list|,
sizeof|sizeof
name|CALL_FP_STUB
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Relocate a MIPS ELF64 section.  */
end_comment

begin_function
specifier|static
name|boolean
name|mips_elf64_relocate_section
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|contents
parameter_list|,
name|relocs
parameter_list|,
name|local_syms
parameter_list|,
name|local_sections
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|local_syms
decl_stmt|;
name|asection
modifier|*
modifier|*
name|local_sections
decl_stmt|;
block|{
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relend
decl_stmt|;
name|bfd_vma
name|addend
init|=
literal|0
decl_stmt|;
name|boolean
name|use_saved_addend_p
init|=
name|false
decl_stmt|;
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|input_section
operator|->
name|reloc_count
operator|*
name|bed
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|relend
condition|;
operator|++
name|rel
control|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|boolean
name|require_jalx
decl_stmt|;
comment|/* True if the relocation is a RELA relocation, rather than a          REL relocation.  */
name|boolean
name|rela_relocation_p
init|=
name|true
decl_stmt|;
name|int
name|r_type
init|=
name|ELF64_MIPS_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
comment|/* Find the relocation howto for this relocation.  */
name|howto
operator|=
operator|&
name|mips_elf64_howto_table_rela
index|[
name|r_type
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|use_saved_addend_p
condition|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|rel_hdr
decl_stmt|;
comment|/* If these relocations were originally of the REL variety, 	     we must pull the addend out of the field that will be 	     relocated.  Otherwise, we simply use the contents of the 	     RELA relocation.  To determine which flavor or relocation 	     this is, we depend on the fact that the INPUT_SECTION's 	     REL_HDR is read before its REL_HDR2.  */
name|rel_hdr
operator|=
operator|&
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|rel_hdr
expr_stmt|;
if|if
condition|(
call|(
name|size_t
call|)
argument_list|(
name|rel
operator|-
name|relocs
argument_list|)
operator|>=
operator|(
name|NUM_SHDR_ENTRIES
argument_list|(
name|rel_hdr
argument_list|)
operator|*
name|bed
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
operator|)
condition|)
name|rel_hdr
operator|=
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|rel_hdr2
expr_stmt|;
if|if
condition|(
name|rel_hdr
operator|->
name|sh_entsize
operator|==
operator|(
name|get_elf_backend_data
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|s
operator|->
name|sizeof_rel
operator|)
condition|)
block|{
comment|/* Note that this is a REL relocation.  */
name|rela_relocation_p
operator|=
name|false
expr_stmt|;
comment|/* Find the relocation howto for this relocation.  */
name|howto
operator|=
operator|&
name|mips_elf64_howto_table_rel
index|[
name|r_type
index|]
expr_stmt|;
comment|/* Get the addend, which is stored in the input file.  */
name|addend
operator|=
name|mips_elf64_obtain_contents
argument_list|(
name|howto
argument_list|,
name|rel
argument_list|,
name|input_bfd
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|addend
operator|&=
name|howto
operator|->
name|src_mask
expr_stmt|;
comment|/* For some kinds of relocations, the ADDEND is a 		 combination of the addend stored in two different 		 relocations.   */
if|if
condition|(
name|r_type
operator|==
name|R_MIPS_HI16
operator|||
name|r_type
operator|==
name|R_MIPS_GNU_REL_HI16
operator|||
operator|(
name|r_type
operator|==
name|R_MIPS_GOT16
operator|&&
name|mips_elf64_local_relocation_p
argument_list|(
name|input_bfd
argument_list|,
name|rel
argument_list|,
name|local_sections
argument_list|,
name|false
argument_list|)
operator|)
condition|)
block|{
name|bfd_vma
name|l
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|lo16_relocation
decl_stmt|;
name|reloc_howto_type
modifier|*
name|lo16_howto
decl_stmt|;
name|int
name|lo
decl_stmt|;
comment|/* The combined value is the sum of the HI16 addend, 		     left-shifted by sixteen bits, and the LO16 		     addend, sign extended.  (Usually, the code does 		     a `lui' of the HI16 value, and then an `addiu' of 		     the LO16 value.)    		     Scan ahead to find a matching LO16 relocation.  */
if|if
condition|(
name|r_type
operator|==
name|R_MIPS_GNU_REL_HI16
condition|)
name|lo
operator|=
name|R_MIPS_GNU_REL_LO16
expr_stmt|;
else|else
name|lo
operator|=
name|R_MIPS_LO16
expr_stmt|;
name|lo16_relocation
operator|=
name|mips_elf64_next_relocation
argument_list|(
name|lo
argument_list|,
name|rel
argument_list|,
name|relend
argument_list|)
expr_stmt|;
if|if
condition|(
name|lo16_relocation
operator|==
name|NULL
condition|)
return|return
name|false
return|;
comment|/* Obtain the addend kept there.  */
if|if
condition|(
name|rela_relocation_p
operator|==
name|false
condition|)
name|lo16_howto
operator|=
operator|&
name|mips_elf64_howto_table_rel
index|[
name|lo
index|]
expr_stmt|;
else|else
name|lo16_howto
operator|=
operator|&
name|mips_elf64_howto_table_rela
index|[
name|lo
index|]
expr_stmt|;
name|l
operator|=
name|mips_elf64_obtain_contents
argument_list|(
name|lo16_howto
argument_list|,
name|lo16_relocation
argument_list|,
name|input_bfd
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|l
operator|&=
name|lo16_howto
operator|->
name|src_mask
expr_stmt|;
name|l
operator|=
name|mips_elf64_sign_extend
argument_list|(
name|l
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|addend
operator|<<=
literal|16
expr_stmt|;
comment|/* Compute the combined addend.  */
name|addend
operator|+=
name|l
expr_stmt|;
block|}
block|}
else|else
name|addend
operator|=
name|rel
operator|->
name|r_addend
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|relocateable
condition|)
block|{
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
comment|/* Since we're just relocating, all we need to do is copy 	     the relocations back out to the object file, unless 	     they're against a section symbol, in which case we need 	     to adjust by the section offset, or unless they're GP 	     relative in which case we need to adjust by the amount 	     that we're adjusting GP in this relocateable object.  */
if|if
condition|(
operator|!
name|mips_elf64_local_relocation_p
argument_list|(
name|input_bfd
argument_list|,
name|rel
argument_list|,
name|local_sections
argument_list|,
name|false
argument_list|)
condition|)
comment|/* There's nothing to do for non-local relocations.  */
continue|continue;
if|if
condition|(
name|r_type
operator|==
name|R_MIPS_GPREL16
operator|||
name|r_type
operator|==
name|R_MIPS_GPREL32
operator|||
name|r_type
operator|==
name|R_MIPS_LITERAL
condition|)
name|addend
operator|-=
operator|(
name|_bfd_get_gp_value
argument_list|(
name|output_bfd
argument_list|)
operator|-
name|_bfd_get_gp_value
argument_list|(
name|input_bfd
argument_list|)
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|r_type
operator|==
name|R_MIPS_26
operator|||
name|r_type
operator|==
name|R_MIPS_GNU_REL16_S2
condition|)
comment|/* The addend is stored without its two least 	       significant bits (which are always zero.)  In a 	       non-relocateable link, calculate_relocation will do 	       this shift; here, we must do it ourselves.  */
name|addend
operator|<<=
literal|2
expr_stmt|;
name|r_symndx
operator|=
name|ELF64_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_SECTION
condition|)
comment|/* Adjust the addend appropriately.  */
name|addend
operator|+=
name|local_sections
index|[
name|r_symndx
index|]
operator|->
name|output_offset
expr_stmt|;
if|#
directive|if
literal|0
comment|/* If the relocation is for a R_MIPS_HI16 or R_MIPS_GOT16, 	     then we only want to write out the high-order 16 bits. 	     The subsequent R_MIPS_LO16 will handle the low-order bits.  */
block|if (r_type == R_MIPS_HI16 || r_type == R_MIPS_GOT16 	      || r_type == R_MIPS_GNU_REL_HI16) 	    addend = mips_elf64_high (addend); 	  else if (r_type == R_MIPS_HIGHER) 	    addend = mips_elf64_higher (addend); 	  else if (r_type == R_MIPS_HIGHEST) 	    addend = mips_elf64_highest (addend);
endif|#
directive|endif
comment|/* If the relocation is for an R_MIPS_26 relocation, then 	     the two low-order bits are not stored in the object file; 	     they are implicitly zero.  */
if|if
condition|(
name|r_type
operator|==
name|R_MIPS_26
operator|||
name|r_type
operator|==
name|R_MIPS_GNU_REL16_S2
condition|)
name|addend
operator|>>=
literal|2
expr_stmt|;
if|if
condition|(
name|rela_relocation_p
condition|)
comment|/* If this is a RELA relocation, just update the addend. 	       We have to cast away constness for REL.  */
name|rel
operator|->
name|r_addend
operator|=
name|addend
expr_stmt|;
else|else
block|{
comment|/* Otherwise, we have to write the value back out.  Note 		 that we use the source mask, rather than the 		 destination mask because the place to which we are 		 writing will be source of the addend in the final 		 link.  */
name|addend
operator|&=
name|howto
operator|->
name|src_mask
expr_stmt|;
if|if
condition|(
operator|!
name|mips_elf64_perform_relocation
argument_list|(
name|info
argument_list|,
name|howto
argument_list|,
name|rel
argument_list|,
name|addend
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|false
argument_list|)
condition|)
return|return
name|false
return|;
block|}
comment|/* Go on to the next relocation.  */
continue|continue;
block|}
comment|/* In the N32 and 64-bit ABIs there may be multiple consecutive 	 relocations for the same offset.  In that case we are 	 supposed to treat the output of each relocation as the addend 	 for the next.  */
if|if
condition|(
name|rel
operator|+
literal|1
operator|<
name|relend
operator|&&
name|rel
operator|->
name|r_offset
operator|==
name|rel
index|[
literal|1
index|]
operator|.
name|r_offset
operator|&&
name|ELF64_MIPS_R_TYPE
argument_list|(
name|rel
index|[
literal|1
index|]
operator|.
name|r_info
argument_list|)
operator|!=
name|R_MIPS_NONE
condition|)
name|use_saved_addend_p
operator|=
name|true
expr_stmt|;
else|else
name|use_saved_addend_p
operator|=
name|false
expr_stmt|;
comment|/* Figure out what value we are supposed to relocate.  */
switch|switch
condition|(
name|mips_elf64_calculate_relocation
argument_list|(
name|output_bfd
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|info
argument_list|,
name|rel
argument_list|,
name|addend
argument_list|,
name|howto
argument_list|,
name|local_syms
argument_list|,
name|local_sections
argument_list|,
operator|&
name|value
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|require_jalx
argument_list|)
condition|)
block|{
case|case
name|bfd_reloc_continue
case|:
comment|/* There's nothing to do.  */
continue|continue;
case|case
name|bfd_reloc_undefined
case|:
comment|/* mips_elf64_calculate_relocation already called the 	     undefined_symbol callback.  There's no real point in 	     trying to perform the relocation at this point, so we 	     just skip ahead to the next relocation.  */
continue|continue;
case|case
name|bfd_reloc_notsupported
case|:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: unsupported relocation error"
argument_list|)
expr_stmt|;
name|info
operator|->
name|callbacks
operator|->
name|warning
argument_list|(
name|info
argument_list|,
name|msg
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
name|bfd_reloc_overflow
case|:
if|if
condition|(
name|use_saved_addend_p
condition|)
comment|/* Ignore overflow until we reach the last relocation for 	       a given location.  */
empty_stmt|;
else|else
block|{
name|BFD_ASSERT
argument_list|(
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|info
argument_list|,
name|name
argument_list|,
name|howto
operator|->
name|name
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
block|}
break|break;
case|case
name|bfd_reloc_ok
case|:
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
comment|/* If we've got another relocation for the address, keep going 	 until we reach the last one.  */
if|if
condition|(
name|use_saved_addend_p
condition|)
block|{
name|addend
operator|=
name|value
expr_stmt|;
continue|continue;
block|}
comment|/* Actually perform the relocation.  */
if|if
condition|(
operator|!
name|mips_elf64_perform_relocation
argument_list|(
name|info
argument_list|,
name|howto
argument_list|,
name|rel
argument_list|,
name|value
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|require_jalx
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Create dynamic sections when linking against a dynamic object.  */
end_comment

begin_function
name|boolean
name|mips_elf64_create_dynamic_sections
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|flagword
name|flags
decl_stmt|;
specifier|register
name|asection
modifier|*
name|s
decl_stmt|;
name|flags
operator|=
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_READONLY
operator|)
expr_stmt|;
comment|/* Mips ABI requests the .dynamic section to be read only.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|flags
argument_list|)
condition|)
return|return
name|false
return|;
block|}
comment|/* We need to create .got section.  */
if|if
condition|(
operator|!
name|mips_elf64_create_got_section
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Create the .msym section on IRIX6.  It is used by the dynamic      linker to speed up dynamic relocations, and to avoid computing      the ELF hash for symbols.  */
if|if
condition|(
operator|!
name|mips_elf64_create_msym_section
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Create .stub section.  */
if|if
condition|(
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".MIPS.stubs"
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".MIPS.stubs"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|flags
operator||
name|SEC_CODE
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
literal|3
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Adjust a symbol defined by a dynamic object and referenced by a    regular object.  The current definition is in some section of the    dynamic object, but we're not including those sections.  We have to    change the definition to something the rest of the link can    understand.  */
end_comment

begin_function
name|boolean
name|mips_elf64_adjust_dynamic_symbol
parameter_list|(
name|info
parameter_list|,
name|h
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|struct
name|mips_elf64_link_hash_entry
modifier|*
name|hmips
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
comment|/* Make sure we know what is going on here.  */
name|BFD_ASSERT
argument_list|(
name|dynobj
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_NEEDS_PLT
operator|)
operator|||
name|h
operator|->
name|weakdef
operator|!=
name|NULL
operator|||
operator|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_REF_REGULAR
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* If this symbol is defined in a dynamic object, we need to copy      any R_MIPS_32 or R_MIPS_REL32 relocs against it into the output      file.  */
name|hmips
operator|=
operator|(
expr|struct
name|mips_elf64_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|relocateable
operator|&&
name|hmips
operator|->
name|possibly_dynamic_relocs
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|mips_elf64_allocate_dynamic_relocations
argument_list|(
name|dynobj
argument_list|,
name|hmips
operator|->
name|possibly_dynamic_relocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|hmips
operator|->
name|readonly_reloc
condition|)
comment|/* We tell the dynamic linker that there are relocations 	   against the text segment.  */
name|info
operator|->
name|flags
operator||=
name|DF_TEXTREL
expr_stmt|;
block|}
comment|/* For a function, create a stub, if allowed.  */
if|if
condition|(
operator|!
name|hmips
operator|->
name|no_fn_stub
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_NEEDS_PLT
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
return|return
name|true
return|;
comment|/* If this symbol is not defined in a regular file, then set 	 the symbol to the stub location.  This is required to make 	 function pointers compare as equal between the normal 	 executable and the shared library.  */
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* We need .stub section.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".MIPS.stubs"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|s
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
comment|/* XXX Write this stub address somewhere.  */
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
comment|/* Make room for this stub code.  */
name|s
operator|->
name|_raw_size
operator|+=
name|MIPS_FUNCTION_STUB_SIZE
expr_stmt|;
comment|/* The last half word of the stub will be filled with the index 	     of this symbol in .dynsym section.  */
return|return
name|true
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|h
operator|->
name|type
operator|==
name|STT_FUNC
operator|)
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_NEEDS_PLT
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* This will set the entry for this symbol in the GOT to 0, and          the dynamic linker will take care of this.  */
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
literal|0
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* If this is a weak symbol, and there is a real definition, the      processor independent code will have arranged for us to see the      real definition first, and we can just use the same value.  */
if|if
condition|(
name|h
operator|->
name|weakdef
operator|!=
name|NULL
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
argument_list|)
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* This is a reference to a symbol defined by a dynamic object which      is not a function.  */
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* This function is called after all the input files have been read,    and the input sections have been assigned to output sections.  */
end_comment

begin_function
name|boolean
name|mips_elf64_always_size_sections
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|info
operator|->
name|relocateable
operator|||
operator|!
name|mips_elf64_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|mips16_stubs_seen
condition|)
return|return
name|true
return|;
name|mips_elf64_link_hash_traverse
argument_list|(
name|mips_elf64_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|mips_elf64_check_mips16_stubs
argument_list|,
operator|(
name|PTR
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Check the mips16 stubs for a particular symbol, and see if we can    discard them.  */
end_comment

begin_function
specifier|static
name|boolean
name|mips_elf64_check_mips16_stubs
parameter_list|(
name|h
parameter_list|,
name|data
parameter_list|)
name|struct
name|mips_elf64_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|PTR
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|mips_elf64_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|fn_stub
operator|!=
name|NULL
operator|&&
operator|!
name|h
operator|->
name|need_fn_stub
condition|)
block|{
comment|/* We don't need the fn_stub; the only references to this symbol          are 16 bit calls.  Clobber the size to 0 to prevent it from          being included in the link.  */
name|h
operator|->
name|fn_stub
operator|->
name|_raw_size
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|fn_stub
operator|->
name|_cooked_size
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|fn_stub
operator|->
name|flags
operator|&=
operator|~
name|SEC_RELOC
expr_stmt|;
name|h
operator|->
name|fn_stub
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|fn_stub
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|->
name|call_stub
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|root
operator|.
name|other
operator|==
name|STO_MIPS16
condition|)
block|{
comment|/* We don't need the call_stub; this is a 16 bit function, so          calls from other 16 bit functions are OK.  Clobber the size          to 0 to prevent it from being included in the link.  */
name|h
operator|->
name|call_stub
operator|->
name|_raw_size
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|call_stub
operator|->
name|_cooked_size
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|call_stub
operator|->
name|flags
operator|&=
operator|~
name|SEC_RELOC
expr_stmt|;
name|h
operator|->
name|call_stub
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|call_stub
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|->
name|call_fp_stub
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|root
operator|.
name|other
operator|==
name|STO_MIPS16
condition|)
block|{
comment|/* We don't need the call_stub; this is a 16 bit function, so          calls from other 16 bit functions are OK.  Clobber the size          to 0 to prevent it from being included in the link.  */
name|h
operator|->
name|call_fp_stub
operator|->
name|_raw_size
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|call_fp_stub
operator|->
name|_cooked_size
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|call_fp_stub
operator|->
name|flags
operator|&=
operator|~
name|SEC_RELOC
expr_stmt|;
name|h
operator|->
name|call_fp_stub
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|call_fp_stub
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Set the sizes of the dynamic sections.  */
end_comment

begin_function
name|boolean
name|mips_elf64_size_dynamic_sections
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|boolean
name|reltext
decl_stmt|;
name|struct
name|mips_elf64_got_info
modifier|*
name|g
init|=
name|NULL
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|dynobj
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
comment|/* Set the contents of the .interp section to the interpreter.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".interp"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|=
name|strlen
argument_list|(
literal|"/usr/lib64/libc.so.1"
argument_list|)
operator|+
literal|1
expr_stmt|;
name|s
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
literal|"/usr/lib64/libc.so.1"
expr_stmt|;
block|}
block|}
comment|/* The check_relocs and adjust_dynamic_symbol entry points have      determined the sizes of the various dynamic sections.  Allocate      memory for them.  */
name|reltext
operator|=
name|false
expr_stmt|;
for|for
control|(
name|s
operator|=
name|dynobj
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|boolean
name|strip
decl_stmt|;
comment|/* It's OK to base decisions on the section name, because none 	 of the dynobj section names depend upon the input files.  */
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LINKER_CREATED
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|strip
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".rel"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|_raw_size
operator|==
literal|0
condition|)
block|{
comment|/* We only strip the section if the output section name                  has the same name.  Otherwise, there might be several                  input sections for this output section.  FIXME: This                  code is probably not needed these days anyhow, since                  the linker now does not create empty output sections.  */
if|if
condition|(
name|s
operator|->
name|output_section
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|bfd_get_section_name
argument_list|(
name|s
operator|->
name|output_section
operator|->
name|owner
argument_list|,
name|s
operator|->
name|output_section
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|strip
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|outname
decl_stmt|;
name|asection
modifier|*
name|target
decl_stmt|;
comment|/* If this relocation section applies to a read only                  section, then we probably need a DT_TEXTREL entry.                  If the relocation section is .rel.dyn, we always                  assert a DT_TEXTREL entry rather than testing whether                  there exists a relocation to a read only section or                  not.  */
name|outname
operator|=
name|bfd_get_section_name
argument_list|(
name|output_bfd
argument_list|,
name|s
operator|->
name|output_section
argument_list|)
expr_stmt|;
name|target
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
name|outname
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|target
operator|!=
name|NULL
operator|&&
operator|(
name|target
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|target
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
operator|)
operator|||
name|strcmp
argument_list|(
name|outname
argument_list|,
literal|"rel.dyn"
argument_list|)
operator|==
literal|0
condition|)
name|reltext
operator|=
name|true
expr_stmt|;
comment|/* We use the reloc_count field as a counter if we need 		 to copy relocs into the output file.  */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"rel.dyn"
argument_list|)
operator|!=
literal|0
condition|)
name|s
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".got"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
name|bfd_size_type
name|loadable_size
init|=
literal|0
decl_stmt|;
name|bfd_size_type
name|local_gotno
decl_stmt|;
name|bfd
modifier|*
name|sub
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g
operator|=
operator|(
expr|struct
name|mips_elf64_got_info
operator|*
operator|)
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|tdata
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|g
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Calculate the total loadable size of the output.  That 	     will give us the maximum number of GOT_PAGE entries 	     required.  */
for|for
control|(
name|sub
operator|=
name|info
operator|->
name|input_bfds
init|;
name|sub
condition|;
name|sub
operator|=
name|sub
operator|->
name|link_next
control|)
block|{
name|asection
modifier|*
name|subsection
decl_stmt|;
for|for
control|(
name|subsection
operator|=
name|sub
operator|->
name|sections
init|;
name|subsection
condition|;
name|subsection
operator|=
name|subsection
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|subsection
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|loadable_size
operator|+=
operator|(
name|subsection
operator|->
name|_raw_size
operator|+
literal|0xf
operator|)
operator|&
operator|~
literal|0xf
expr_stmt|;
block|}
block|}
name|loadable_size
operator|+=
name|MIPS_FUNCTION_STUB_SIZE
expr_stmt|;
comment|/* Assume there are two loadable segments consisting of 	     contiguous sections.  Is 5 enough?  */
name|local_gotno
operator|=
operator|(
name|loadable_size
operator|>>
literal|16
operator|)
operator|+
literal|5
expr_stmt|;
comment|/* It's possible we will need GOT_PAGE entries as well as 	       GOT16 entries.  Often, these will be able to share GOT 	       entries, but not always.  */
name|local_gotno
operator|*=
literal|2
expr_stmt|;
name|g
operator|->
name|local_gotno
operator|+=
name|local_gotno
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|+=
name|local_gotno
operator|*
literal|8
expr_stmt|;
comment|/* There has to be a global GOT entry for every symbol with 	     a dynamic symbol table index of DT_MIPS_GOTSYM or 	     higher.  Therefore, it make sense to put those symbols 	     that need GOT entries at the end of the symbol table.  We 	     do that here.  */
if|if
condition|(
operator|!
name|mips_elf64_sort_hash_table
argument_list|(
name|info
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|g
operator|->
name|global_gotsym
operator|!=
name|NULL
condition|)
name|i
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynsymcount
operator|-
name|g
operator|->
name|global_gotsym
operator|->
name|dynindx
expr_stmt|;
else|else
comment|/* If there are no global symbols, or none requiring 	       relocations, then GLOBAL_GOTSYM will be NULL.  */
name|i
operator|=
literal|0
expr_stmt|;
name|g
operator|->
name|global_gotno
operator|=
name|i
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|+=
name|i
operator|*
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".MIPS.stubs"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Irix rld assumes that the function stub isn't at the end 	     of .text section. So put a dummy. XXX  */
name|s
operator|->
name|_raw_size
operator|+=
name|MIPS_FUNCTION_STUB_SIZE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".msym"
argument_list|)
operator|==
literal|0
condition|)
name|s
operator|->
name|_raw_size
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|Elf32_External_Msym
argument_list|)
operator|*
operator|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynsymcount
operator|+
name|bfd_count_sections
argument_list|(
name|output_bfd
argument_list|)
operator|)
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".init"
argument_list|,
literal|5
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* It's not one of our sections, so don't allocate space.  */
continue|continue;
block|}
if|if
condition|(
name|strip
condition|)
block|{
name|_bfd_strip_section_from_output
argument_list|(
name|info
argument_list|,
name|s
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Allocate memory for the section contents.  */
name|s
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|dynobj
argument_list|,
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|contents
operator|==
name|NULL
operator|&&
name|s
operator|->
name|_raw_size
operator|!=
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
comment|/* Add some entries to the .dynamic section.  We fill in the 	 values later, in elf_mips_finish_dynamic_sections, but we 	 must add the entries now so that we get the correct size for 	 the .dynamic section.  The DT_DEBUG entry is filled in by the 	 dynamic linker and used by the debugger.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
comment|/* SGI object has the equivalence of DT_DEBUG in the 	     DT_MIPS_RLD_MAP entry.  */
if|if
condition|(
operator|!
name|bfd_elf64_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_MIPS_RLD_MAP
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|SGI_COMPAT
argument_list|(
name|output_bfd
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf64_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_DEBUG
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
else|else
block|{
comment|/* Shared libraries on traditional mips have DT_DEBUG.  */
if|if
condition|(
operator|!
name|SGI_COMPAT
argument_list|(
name|output_bfd
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf64_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_DEBUG
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
if|if
condition|(
name|reltext
operator|&&
name|SGI_COMPAT
argument_list|(
name|output_bfd
argument_list|)
condition|)
name|info
operator|->
name|flags
operator||=
name|DF_TEXTREL
expr_stmt|;
if|if
condition|(
operator|(
name|info
operator|->
name|flags
operator|&
name|DF_TEXTREL
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf64_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_TEXTREL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|bfd_elf64_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_PLTGOT
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|"rel.dyn"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf64_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_REL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|bfd_elf64_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_RELSZ
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|bfd_elf64_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_RELENT
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|output_bfd
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf64_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_MIPS_CONFLICTNO
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|output_bfd
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf64_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_MIPS_LIBLISTNO
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".conflict"
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf64_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_MIPS_CONFLICT
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".liblist"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_elf64_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_MIPS_LIBLIST
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|bfd_elf64_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_MIPS_RLD_VERSION
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|bfd_elf64_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_MIPS_FLAGS
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
if|#
directive|if
literal|0
comment|/* Time stamps in executable files are a bad idea.  */
block|if (! bfd_elf64_add_dynamic_entry (info, DT_MIPS_TIME_STAMP, 0)) 	return false;
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* FIXME  */
block|if (! bfd_elf64_add_dynamic_entry (info, DT_MIPS_ICHECKSUM, 0)) 	return false;
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* FIXME  */
block|if (! bfd_elf64_add_dynamic_entry (info, DT_MIPS_IVERSION, 0)) 	return false;
endif|#
directive|endif
if|if
condition|(
operator|!
name|bfd_elf64_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_MIPS_BASE_ADDRESS
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|bfd_elf64_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_MIPS_LOCAL_GOTNO
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|bfd_elf64_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_MIPS_SYMTABNO
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|bfd_elf64_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_MIPS_UNREFEXTNO
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|bfd_elf64_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_MIPS_GOTSYM
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|(
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".MIPS.options"
argument_list|)
operator|)
operator|&&
operator|!
name|bfd_elf64_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_MIPS_OPTIONS
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".msym"
argument_list|)
operator|&&
operator|!
name|bfd_elf64_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_MIPS_MSYM
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Finish up dynamic symbol handling.  We set the contents of various    dynamic sections here.  */
end_comment

begin_function
name|boolean
name|mips_elf64_finish_dynamic_symbol
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|h
parameter_list|,
name|sym
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|bfd_vma
name|gval
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
name|asection
modifier|*
name|smsym
decl_stmt|;
name|struct
name|mips_elf64_got_info
modifier|*
name|g
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|mips_elf64_link_hash_entry
modifier|*
name|mh
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|gval
operator|=
name|sym
operator|->
name|st_value
expr_stmt|;
name|mh
operator|=
operator|(
expr|struct
name|mips_elf64_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_byte
name|stub
index|[
name|MIPS_FUNCTION_STUB_SIZE
index|]
decl_stmt|;
comment|/* This symbol has a stub.  Set it up.  */
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".MIPS.stubs"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* FIXME: Can h->dynindex be more than 64K?  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|&
literal|0xffff0000
condition|)
return|return
name|false
return|;
comment|/* Fill the stub.  */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|STUB_LW
argument_list|,
name|stub
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|STUB_MOVE
argument_list|,
name|stub
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|STUB_JALR
argument_list|,
name|stub
operator|+
literal|8
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|STUB_LI16
operator|+
name|h
operator|->
name|dynindx
argument_list|,
name|stub
operator|+
literal|12
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|<=
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|s
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
argument_list|,
name|stub
argument_list|,
name|MIPS_FUNCTION_STUB_SIZE
argument_list|)
expr_stmt|;
comment|/* Mark the symbol as undefined.  plt.offset != -1 occurs 	 only for the referenced symbol.  */
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_UNDEF
expr_stmt|;
comment|/* The run-time linker uses the st_value field of the symbol 	 to reset the global offset table entry for this external 	 to its stub address when unlinking a shared object.  */
name|gval
operator|=
name|s
operator|->
name|output_section
operator|->
name|vma
operator|+
name|s
operator|->
name|output_offset
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
expr_stmt|;
name|sym
operator|->
name|st_value
operator|=
name|gval
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_FORCED_LOCAL
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|elf_section_data
argument_list|(
name|sgot
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g
operator|=
operator|(
expr|struct
name|mips_elf64_got_info
operator|*
operator|)
name|elf_section_data
argument_list|(
name|sgot
argument_list|)
operator|->
name|tdata
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|g
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Run through the global symbol table, creating GOT entries for all      the symbols that need them.  */
if|if
condition|(
name|g
operator|->
name|global_gotsym
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|dynindx
operator|>=
name|g
operator|->
name|global_gotsym
operator|->
name|dynindx
condition|)
block|{
name|bfd_vma
name|offset
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
if|if
condition|(
name|sym
operator|->
name|st_value
condition|)
name|value
operator|=
name|sym
operator|->
name|st_value
expr_stmt|;
else|else
block|{
comment|/* For an entity defined in a shared object, this will be 	     NULL.  (For functions in shared objects for 	     which we have created stubs, ST_VALUE will be non-NULL. 	     That's because such the functions are now no longer defined 	     in a shared object.)  */
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
condition|)
name|value
operator|=
literal|0
expr_stmt|;
else|else
name|value
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
block|}
name|offset
operator|=
name|mips_elf64_global_got_index
argument_list|(
name|dynobj
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|bfd_put_64
argument_list|(
name|output_bfd
argument_list|,
name|value
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|offset
argument_list|)
expr_stmt|;
block|}
comment|/* Create a .msym entry, if appropriate.  */
name|smsym
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".msym"
argument_list|)
expr_stmt|;
if|if
condition|(
name|smsym
condition|)
block|{
name|Elf32_Internal_Msym
name|msym
decl_stmt|;
name|msym
operator|.
name|ms_hash_value
operator|=
name|bfd_elf_hash
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
comment|/* It is undocumented what the `1' indicates, but IRIX6 uses 	 this value.  */
name|msym
operator|.
name|ms_info
operator|=
name|ELF32_MS_INFO
argument_list|(
name|mh
operator|->
name|min_dyn_reloc_index
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mips_elf64_swap_msym_out
argument_list|(
name|dynobj
argument_list|,
operator|&
name|msym
argument_list|,
operator|(
operator|(
name|Elf32_External_Msym
operator|*
operator|)
name|smsym
operator|->
name|contents
operator|)
operator|+
name|h
operator|->
name|dynindx
argument_list|)
expr_stmt|;
block|}
comment|/* Mark _DYNAMIC and _GLOBAL_OFFSET_TABLE_ as absolute.  */
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"_DYNAMIC"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|)
operator|==
literal|0
condition|)
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_ABS
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"_DYNAMIC_LINK"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"_DYNAMIC_LINKING"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_ABS
expr_stmt|;
name|sym
operator|->
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_GLOBAL
argument_list|,
name|STT_SECTION
argument_list|)
expr_stmt|;
name|sym
operator|->
name|st_value
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sym
operator|->
name|st_shndx
operator|!=
name|SHN_UNDEF
operator|&&
name|sym
operator|->
name|st_shndx
operator|!=
name|SHN_ABS
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|type
operator|==
name|STT_FUNC
condition|)
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_MIPS_TEXT
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|->
name|type
operator|==
name|STT_OBJECT
condition|)
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_MIPS_DATA
expr_stmt|;
block|}
comment|/* Handle the IRIX6-specific symbols.  */
block|{
comment|/* The linker script takes care of providing names and values for      these, but we must place them into the right sections.  */
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|text_section_symbols
index|[]
init|=
block|{
literal|"_ftext"
block|,
literal|"_etext"
block|,
literal|"__dso_displacement"
block|,
literal|"__elf_header"
block|,
literal|"__program_header_table"
block|,
name|NULL
block|}
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|data_section_symbols
index|[]
init|=
block|{
literal|"_fdata"
block|,
literal|"_edata"
block|,
literal|"_end"
block|,
literal|"_fbss"
block|,
name|NULL
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
operator|++
name|i
control|)
for|for
control|(
name|p
operator|=
operator|(
name|i
operator|==
literal|0
operator|)
condition|?
name|text_section_symbols
else|:
name|data_section_symbols
init|;
operator|*
name|p
condition|;
operator|++
name|p
control|)
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|p
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* All of these symbols are given type STT_SECTION by the 	     IRIX6 linker.  */
name|sym
operator|->
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_GLOBAL
argument_list|,
name|STT_SECTION
argument_list|)
expr_stmt|;
comment|/* The IRIX linker puts these symbols in special sections.  */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_MIPS_TEXT
expr_stmt|;
else|else
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_MIPS_DATA
expr_stmt|;
break|break;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Finish up the dynamic sections.  */
end_comment

begin_function
name|boolean
name|mips_elf64_finish_dynamic_sections
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|sdyn
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
name|struct
name|mips_elf64_got_info
modifier|*
name|g
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|sdyn
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sgot
operator|==
name|NULL
condition|)
name|g
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|BFD_ASSERT
argument_list|(
name|elf_section_data
argument_list|(
name|sgot
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g
operator|=
operator|(
expr|struct
name|mips_elf64_got_info
operator|*
operator|)
name|elf_section_data
argument_list|(
name|sgot
argument_list|)
operator|->
name|tdata
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|g
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
name|bfd_byte
modifier|*
name|b
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|sdyn
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|g
operator|!=
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|b
operator|=
name|sdyn
operator|->
name|contents
init|;
name|b
operator|<
name|sdyn
operator|->
name|contents
operator|+
name|sdyn
operator|->
name|_raw_size
condition|;
name|b
operator|+=
name|get_elf_backend_data
argument_list|(
name|dynobj
argument_list|)
operator|->
name|s
operator|->
name|sizeof_dyn
control|)
block|{
name|Elf_Internal_Dyn
name|dyn
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|size_t
name|elemsize
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|boolean
name|swap_out_p
decl_stmt|;
comment|/* Read in the current dynamic entry.  */
operator|(
operator|*
name|get_elf_backend_data
argument_list|(
name|dynobj
argument_list|)
operator|->
name|s
operator|->
name|swap_dyn_in
operator|)
operator|(
name|dynobj
operator|,
name|b
operator|,
operator|&
name|dyn
operator|)
expr_stmt|;
comment|/* Assume that we're going to modify it and write it out.  */
name|swap_out_p
operator|=
name|true
expr_stmt|;
switch|switch
condition|(
name|dyn
operator|.
name|d_tag
condition|)
block|{
case|case
name|DT_RELENT
case|:
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|"rel.dyn"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|get_elf_backend_data
argument_list|(
name|dynobj
argument_list|)
operator|->
name|s
operator|->
name|sizeof_rel
expr_stmt|;
break|break;
case|case
name|DT_STRSZ
case|:
comment|/* Rewrite DT_STRSZ.  */
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|_bfd_elf_strtab_size
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_PLTGOT
case|:
name|name
operator|=
literal|".got"
expr_stmt|;
goto|goto
name|get_vma
goto|;
case|case
name|DT_MIPS_CONFLICT
case|:
name|name
operator|=
literal|".conflict"
expr_stmt|;
goto|goto
name|get_vma
goto|;
case|case
name|DT_MIPS_LIBLIST
case|:
name|name
operator|=
literal|".liblist"
expr_stmt|;
name|get_vma
label|:
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|s
operator|->
name|vma
expr_stmt|;
break|break;
case|case
name|DT_MIPS_RLD_VERSION
case|:
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
literal|1
expr_stmt|;
comment|/* XXX */
break|break;
case|case
name|DT_MIPS_FLAGS
case|:
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|RHF_NOTPOT
expr_stmt|;
comment|/* XXX */
break|break;
case|case
name|DT_MIPS_CONFLICTNO
case|:
name|name
operator|=
literal|".conflict"
expr_stmt|;
name|elemsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf32_Conflict
argument_list|)
expr_stmt|;
goto|goto
name|set_elemno
goto|;
case|case
name|DT_MIPS_LIBLISTNO
case|:
name|name
operator|=
literal|".liblist"
expr_stmt|;
name|elemsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf32_Lib
argument_list|)
expr_stmt|;
name|set_elemno
label|:
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|_cooked_size
operator|!=
literal|0
condition|)
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|s
operator|->
name|_cooked_size
operator|/
name|elemsize
expr_stmt|;
else|else
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|s
operator|->
name|_raw_size
operator|/
name|elemsize
expr_stmt|;
block|}
else|else
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|DT_MIPS_TIME_STAMP
case|:
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
operator|&
name|dyn
operator|.
name|d_un
operator|.
name|d_val
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_MIPS_ICHECKSUM
case|:
comment|/* XXX FIXME: */
name|swap_out_p
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|DT_MIPS_IVERSION
case|:
comment|/* XXX FIXME: */
name|swap_out_p
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|DT_MIPS_BASE_ADDRESS
case|:
name|s
operator|=
name|output_bfd
operator|->
name|sections
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|s
operator|->
name|vma
operator|&
operator|~
operator|(
literal|0xffff
operator|)
expr_stmt|;
break|break;
case|case
name|DT_MIPS_LOCAL_GOTNO
case|:
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|g
operator|->
name|local_gotno
expr_stmt|;
break|break;
case|case
name|DT_MIPS_UNREFEXTNO
case|:
comment|/* The index into the dynamic symbol table which is the 		 entry of the first external symbol that is not 		 referenced within the same object.  */
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|bfd_count_sections
argument_list|(
name|output_bfd
argument_list|)
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|DT_MIPS_GOTSYM
case|:
if|if
condition|(
name|g
operator|->
name|global_gotsym
condition|)
block|{
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|g
operator|->
name|global_gotsym
operator|->
name|dynindx
expr_stmt|;
break|break;
block|}
comment|/* In case if we don't have global got symbols we default 		 to setting DT_MIPS_GOTSYM to the same value as 		 DT_MIPS_SYMTABNO, so we just fall through.  */
case|case
name|DT_MIPS_SYMTABNO
case|:
name|name
operator|=
literal|".dynsym"
expr_stmt|;
name|elemsize
operator|=
name|get_elf_backend_data
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|s
operator|->
name|sizeof_sym
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|_cooked_size
operator|!=
literal|0
condition|)
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|s
operator|->
name|_cooked_size
operator|/
name|elemsize
expr_stmt|;
else|else
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|s
operator|->
name|_raw_size
operator|/
name|elemsize
expr_stmt|;
break|break;
case|case
name|DT_MIPS_HIPAGENO
case|:
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|g
operator|->
name|local_gotno
operator|-
name|MIPS_RESERVED_GOTNO
expr_stmt|;
break|break;
case|case
name|DT_MIPS_OPTIONS
case|:
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
literal|".MIPS.options"
argument_list|)
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|s
operator|->
name|vma
expr_stmt|;
break|break;
case|case
name|DT_MIPS_MSYM
case|:
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
literal|".msym"
argument_list|)
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|s
operator|->
name|vma
expr_stmt|;
break|break;
default|default:
name|swap_out_p
operator|=
name|false
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|swap_out_p
condition|)
operator|(
operator|*
name|get_elf_backend_data
argument_list|(
name|dynobj
argument_list|)
operator|->
name|s
operator|->
name|swap_dyn_out
operator|)
operator|(
name|dynobj
operator|,
operator|&
name|dyn
operator|,
name|b
operator|)
expr_stmt|;
block|}
block|}
comment|/* The first entry of the global offset table will be filled at      runtime. The second entry will be used by some runtime loaders.      This isn't the case of Irix rld.  */
if|if
condition|(
name|sgot
operator|!=
name|NULL
operator|&&
name|sgot
operator|->
name|_raw_size
operator|>
literal|0
condition|)
block|{
name|bfd_put_64
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|sgot
operator|->
name|contents
argument_list|)
expr_stmt|;
name|bfd_put_64
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0x80000000
argument_list|,
name|sgot
operator|->
name|contents
operator|+
literal|8
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sgot
operator|!=
name|NULL
condition|)
name|elf_section_data
argument_list|(
name|sgot
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
operator|=
literal|8
expr_stmt|;
block|{
name|asection
modifier|*
name|smsym
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
comment|/* ??? The section symbols for the output sections were set up in        _bfd_elf_final_link.  SGI sets the STT_NOTYPE attribute for these        symbols.  Should we do so?  */
name|smsym
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".msym"
argument_list|)
expr_stmt|;
if|if
condition|(
name|smsym
operator|!=
name|NULL
condition|)
block|{
name|Elf32_Internal_Msym
name|msym
decl_stmt|;
name|msym
operator|.
name|ms_hash_value
operator|=
literal|0
expr_stmt|;
name|msym
operator|.
name|ms_info
operator|=
name|ELF32_MS_INFO
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|output_bfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|long
name|dynindx
init|=
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|dynindx
decl_stmt|;
name|mips_elf64_swap_msym_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|msym
argument_list|,
operator|(
operator|(
operator|(
name|Elf32_External_Msym
operator|*
operator|)
name|smsym
operator|->
name|contents
operator|)
operator|+
name|dynindx
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Clean up a first relocation in .rel.dyn.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|"rel.dyn"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
name|s
operator|->
name|_raw_size
operator|>
literal|0
condition|)
name|memset
argument_list|(
name|s
operator|->
name|contents
argument_list|,
literal|0
argument_list|,
name|get_elf_backend_data
argument_list|(
name|dynobj
argument_list|)
operator|->
name|s
operator|->
name|sizeof_rel
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Return the section that should be marked against GC for a given    relocation.  */
end_comment

begin_function
name|asection
modifier|*
name|mips_elf64_gc_mark_hook
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|rel
parameter_list|,
name|h
parameter_list|,
name|sym
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
block|{
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|ELF64_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_MIPS_GNU_VTINHERIT
case|:
case|case
name|R_MIPS_GNU_VTENTRY
case|:
break|break;
default|default:
switch|switch
condition|(
name|h
operator|->
name|root
operator|.
name|type
condition|)
block|{
case|case
name|bfd_link_hash_defined
case|:
case|case
name|bfd_link_hash_defweak
case|:
return|return
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
return|;
case|case
name|bfd_link_hash_common
case|:
return|return
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
return|;
default|default:
break|break;
block|}
block|}
block|}
else|else
block|{
return|return
name|bfd_section_from_elf_index
argument_list|(
name|abfd
argument_list|,
name|sym
operator|->
name|st_shndx
argument_list|)
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Update the got entry reference counts for the section being removed.  */
end_comment

begin_function
name|boolean
name|mips_elf64_gc_sweep_hook
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|sec
parameter_list|,
name|relocs
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|sec
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|#
directive|if
literal|0
block|Elf_Internal_Shdr *symtab_hdr;   struct elf_link_hash_entry **sym_hashes;   bfd_signed_vma *local_got_refcounts;   const Elf_Internal_Rela *rel, *relend;   unsigned long r_symndx;   struct elf_link_hash_entry *h;    symtab_hdr =&elf_tdata (abfd)->symtab_hdr;   sym_hashes = elf_sym_hashes (abfd);   local_got_refcounts = elf_local_got_refcounts (abfd);    relend = relocs + sec->reloc_count;   for (rel = relocs; rel< relend; rel++)     switch (ELF64_R_TYPE (rel->r_info))       {       case R_MIPS_GOT16:       case R_MIPS_CALL16:       case R_MIPS_CALL_HI16:       case R_MIPS_CALL_LO16:       case R_MIPS_GOT_HI16:       case R_MIPS_GOT_LO16:
comment|/* ??? It would seem that the existing MIPS code does no sort 	   of reference counting or whatnot on its GOT and PLT entries, 	   so it is not possible to garbage collect them at this time.  */
block|break;        default: 	break;       }
endif|#
directive|endif
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create the .got section to hold the global offset table. */
end_comment

begin_function
specifier|static
name|boolean
name|mips_elf64_create_got_section
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|flagword
name|flags
decl_stmt|;
specifier|register
name|asection
modifier|*
name|s
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|mips_elf64_got_info
modifier|*
name|g
decl_stmt|;
comment|/* This function may be called more than once.  */
if|if
condition|(
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".got"
argument_list|)
condition|)
return|return
name|true
return|;
name|flags
operator|=
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator|)
expr_stmt|;
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|flags
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
literal|4
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Define the symbol _GLOBAL_OFFSET_TABLE_.  We don't do this in the      linker script because we don't want to define the symbol if we      are not creating a global offset table.  */
name|h
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|,
name|BSF_GLOBAL
argument_list|,
name|s
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|false
argument_list|,
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|collect
argument_list|,
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|*
operator|)
operator|&
name|h
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
name|h
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_NON_ELF
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_DEF_REGULAR
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|STT_OBJECT
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
operator|!
name|bfd_elf64_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* The first several global offset table entries are reserved.  */
name|s
operator|->
name|_raw_size
operator|=
name|MIPS_RESERVED_GOTNO
operator|*
operator|(
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|s
operator|->
name|arch_size
operator|/
literal|8
operator|)
expr_stmt|;
name|g
operator|=
operator|(
expr|struct
name|mips_elf64_got_info
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mips_elf64_got_info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|g
operator|->
name|global_gotsym
operator|=
name|NULL
expr_stmt|;
name|g
operator|->
name|local_gotno
operator|=
name|MIPS_RESERVED_GOTNO
expr_stmt|;
name|g
operator|->
name|assigned_gotno
operator|=
name|MIPS_RESERVED_GOTNO
expr_stmt|;
if|if
condition|(
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|s
operator|->
name|used_by_bfd
operator|=
operator|(
name|PTR
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bfd_elf_section_data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|false
return|;
block|}
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|tdata
operator|=
operator|(
name|PTR
operator|)
name|g
expr_stmt|;
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_flags
operator||=
name|SHF_ALLOC
operator||
name|SHF_WRITE
operator||
name|SHF_MIPS_GPREL
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* If H is a symbol that needs a global GOT entry, but has a dynamic    symbol table index lower than any we've seen to date, record it for    posterity.  */
end_comment

begin_function
specifier|static
name|boolean
name|mips_elf64_record_global_got_symbol
parameter_list|(
name|h
parameter_list|,
name|info
parameter_list|,
name|g
parameter_list|)
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|mips_elf64_got_info
modifier|*
name|g
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* A global symbol in the GOT must also be in the dynamic symbol      table.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|&&
operator|!
name|bfd_elf64_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* If we've already marked this entry as needing GOT space, we don't      need to do it again.  */
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
return|return
name|true
return|;
comment|/* By setting this to a value other than -1, we are indicating that      there needs to be a GOT entry for H.  Avoid using zero, as the      generic ELF copy_indirect_symbol tests for<= 0.  */
name|h
operator|->
name|got
operator|.
name|offset
operator|=
literal|1
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Returns the .msym section for ABFD, creating it if it does not    already exist.  Returns NULL to indicate error.  */
end_comment

begin_function
specifier|static
name|asection
modifier|*
name|mips_elf64_create_msym_section
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".msym"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
block|{
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".msym"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_READONLY
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
literal|3
argument_list|)
condition|)
return|return
name|NULL
return|;
block|}
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* Add room for N relocations to the .rel.dyn section in ABFD.  */
end_comment

begin_function
specifier|static
name|void
name|mips_elf64_allocate_dynamic_relocations
parameter_list|(
name|abfd
parameter_list|,
name|n
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|unsigned
name|int
name|n
decl_stmt|;
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".rel.dyn"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|_raw_size
operator|==
literal|0
condition|)
block|{
comment|/* Make room for a null element. */
name|s
operator|->
name|_raw_size
operator|+=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|s
operator|->
name|sizeof_rel
expr_stmt|;
operator|++
name|s
operator|->
name|reloc_count
expr_stmt|;
block|}
name|s
operator|->
name|_raw_size
operator|+=
name|n
operator|*
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|s
operator|->
name|sizeof_rel
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Look through the relocs for a section during the first phase, and    allocate space in the global offset table.  */
end_comment

begin_function
name|boolean
name|mips_elf64_check_relocs
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|sec
parameter_list|,
name|relocs
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|struct
name|mips_elf64_got_info
modifier|*
name|g
decl_stmt|;
name|size_t
name|extsymoff
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel_end
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
name|asection
modifier|*
name|sreloc
decl_stmt|;
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocateable
condition|)
return|return
name|true
return|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|extsymoff
operator|=
operator|(
name|elf_bad_symtab
argument_list|(
name|abfd
argument_list|)
operator|)
condition|?
literal|0
else|:
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
comment|/* Check for the mips16 stub sections.  */
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|FN_STUB
argument_list|,
sizeof|sizeof
name|FN_STUB
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
comment|/* Look at the relocation information to figure out which symbol          this is for.  */
name|r_symndx
operator|=
name|ELF64_R_SYM
argument_list|(
name|relocs
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|extsymoff
operator|||
name|sym_hashes
index|[
name|r_symndx
operator|-
name|extsymoff
index|]
operator|==
name|NULL
condition|)
block|{
name|asection
modifier|*
name|o
decl_stmt|;
comment|/* This stub is for a local symbol.  This stub will only be              needed if there is some relocation in this BFD, other              than a 16 bit function call, which refers to this symbol.  */
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
name|Elf_Internal_Rela
modifier|*
name|sec_relocs
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|r
decl_stmt|,
modifier|*
name|rend
decl_stmt|;
comment|/* We can ignore stub sections when looking for relocs.  */
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
operator|||
name|o
operator|->
name|reloc_count
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|o
argument_list|)
argument_list|,
name|FN_STUB
argument_list|,
sizeof|sizeof
name|FN_STUB
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|o
argument_list|)
argument_list|,
name|CALL_STUB
argument_list|,
sizeof|sizeof
name|CALL_STUB
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|o
argument_list|)
argument_list|,
name|CALL_FP_STUB
argument_list|,
sizeof|sizeof
name|CALL_FP_STUB
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|sec_relocs
operator|=
operator|(
name|_bfd_elf64_link_read_relocs
argument_list|(
name|abfd
argument_list|,
name|o
argument_list|,
operator|(
name|PTR
operator|)
name|NULL
argument_list|,
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
name|NULL
argument_list|,
name|info
operator|->
name|keep_memory
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|sec_relocs
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|rend
operator|=
name|sec_relocs
operator|+
name|o
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|r
operator|=
name|sec_relocs
init|;
name|r
operator|<
name|rend
condition|;
name|r
operator|++
control|)
if|if
condition|(
name|ELF64_R_SYM
argument_list|(
name|r
operator|->
name|r_info
argument_list|)
operator|==
name|r_symndx
operator|&&
name|ELF64_R_TYPE
argument_list|(
name|r
operator|->
name|r_info
argument_list|)
operator|!=
name|R_MIPS16_26
condition|)
break|break;
if|if
condition|(
operator|!
name|info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|sec_relocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
name|rend
condition|)
break|break;
block|}
if|if
condition|(
name|o
operator|==
name|NULL
condition|)
block|{
comment|/* There is no non-call reloc for this stub, so we do                  not need it.  Since this function is called before                  the linker maps input sections to output sections, we                  can easily discard it by setting the SEC_EXCLUDE                  flag.  */
name|sec
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* Record this stub in an array of local symbol stubs for              this BFD.  */
if|if
condition|(
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|local_stubs
operator|==
name|NULL
condition|)
block|{
name|unsigned
name|long
name|symcount
decl_stmt|;
name|asection
modifier|*
modifier|*
name|n
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
if|if
condition|(
name|elf_bad_symtab
argument_list|(
name|abfd
argument_list|)
condition|)
name|symcount
operator|=
name|NUM_SHDR_ENTRIES
argument_list|(
name|symtab_hdr
argument_list|)
expr_stmt|;
else|else
name|symcount
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|amt
operator|=
name|symcount
operator|*
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
expr_stmt|;
name|n
operator|=
operator|(
name|asection
operator|*
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|local_stubs
operator|=
name|n
expr_stmt|;
block|}
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|local_stubs
index|[
name|r_symndx
index|]
operator|=
name|sec
expr_stmt|;
comment|/* We don't need to set mips16_stubs_seen in this case.              That flag is used to see whether we need to look through              the global symbol table for stubs.  We don't need to set              it here, because we just have a local stub.  */
block|}
else|else
block|{
name|struct
name|mips_elf64_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
operator|(
operator|(
expr|struct
name|mips_elf64_link_hash_entry
operator|*
operator|)
name|sym_hashes
index|[
name|r_symndx
operator|-
name|extsymoff
index|]
operator|)
expr_stmt|;
comment|/* H is the symbol this stub is for.  */
name|h
operator|->
name|fn_stub
operator|=
name|sec
expr_stmt|;
name|mips_elf64_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|mips16_stubs_seen
operator|=
name|true
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|CALL_STUB
argument_list|,
sizeof|sizeof
name|CALL_STUB
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|name
argument_list|,
name|CALL_FP_STUB
argument_list|,
sizeof|sizeof
name|CALL_FP_STUB
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|struct
name|mips_elf64_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|asection
modifier|*
modifier|*
name|loc
decl_stmt|;
comment|/* Look at the relocation information to figure out which symbol          this is for.  */
name|r_symndx
operator|=
name|ELF64_R_SYM
argument_list|(
name|relocs
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|extsymoff
operator|||
name|sym_hashes
index|[
name|r_symndx
operator|-
name|extsymoff
index|]
operator|==
name|NULL
condition|)
block|{
comment|/* This stub was actually built for a static symbol defined 	     in the same file.  We assume that all static symbols in 	     mips16 code are themselves mips16, so we can simply 	     discard this stub.  Since this function is called before 	     the linker maps input sections to output sections, we can 	     easily discard it by setting the SEC_EXCLUDE flag.  */
name|sec
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
return|return
name|true
return|;
block|}
name|h
operator|=
operator|(
operator|(
expr|struct
name|mips_elf64_link_hash_entry
operator|*
operator|)
name|sym_hashes
index|[
name|r_symndx
operator|-
name|extsymoff
index|]
operator|)
expr_stmt|;
comment|/* H is the symbol this stub is for.  */
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|CALL_FP_STUB
argument_list|,
sizeof|sizeof
name|CALL_FP_STUB
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|loc
operator|=
operator|&
name|h
operator|->
name|call_fp_stub
expr_stmt|;
else|else
name|loc
operator|=
operator|&
name|h
operator|->
name|call_stub
expr_stmt|;
comment|/* If we already have an appropriate stub for this function, we 	 don't need another one, so we can discard this one.  Since 	 this function is called before the linker maps input sections 	 to output sections, we can easily discard it by setting the 	 SEC_EXCLUDE flag.  We can also discard this section if we 	 happen to already know that this is a mips16 function; it is 	 not necessary to check this here, as it is checked later, but 	 it is slightly faster to check now.  */
if|if
condition|(
operator|*
name|loc
operator|!=
name|NULL
operator|||
name|h
operator|->
name|root
operator|.
name|other
operator|==
name|STO_MIPS16
condition|)
block|{
name|sec
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
return|return
name|true
return|;
block|}
operator|*
name|loc
operator|=
name|sec
expr_stmt|;
name|mips_elf64_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|mips16_stubs_seen
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|dynobj
operator|==
name|NULL
condition|)
block|{
name|sgot
operator|=
name|NULL
expr_stmt|;
name|g
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sgot
operator|==
name|NULL
condition|)
name|g
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|BFD_ASSERT
argument_list|(
name|elf_section_data
argument_list|(
name|sgot
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g
operator|=
operator|(
expr|struct
name|mips_elf64_got_info
operator|*
operator|)
name|elf_section_data
argument_list|(
name|sgot
argument_list|)
operator|->
name|tdata
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|g
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
name|sreloc
operator|=
name|NULL
expr_stmt|;
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|rel_end
operator|=
name|relocs
operator|+
name|sec
operator|->
name|reloc_count
operator|*
name|bed
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|rel_end
condition|;
operator|++
name|rel
control|)
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|int
name|r_type
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|r_symndx
operator|=
name|ELF64_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|ELF64_MIPS_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|extsymoff
condition|)
name|h
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|r_symndx
operator|>=
name|extsymoff
operator|+
name|NUM_SHDR_ENTRIES
argument_list|(
name|symtab_hdr
argument_list|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: Malformed reloc detected for section %s"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
else|else
block|{
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|extsymoff
index|]
expr_stmt|;
comment|/* This may be an indirect symbol created because of a version.  */
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
block|}
block|}
comment|/* Some relocs require a global offset table.  */
if|if
condition|(
name|dynobj
operator|==
name|NULL
operator|||
name|sgot
operator|==
name|NULL
condition|)
block|{
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_MIPS_GOT16
case|:
case|case
name|R_MIPS_CALL16
case|:
case|case
name|R_MIPS_CALL_HI16
case|:
case|case
name|R_MIPS_CALL_LO16
case|:
case|case
name|R_MIPS_GOT_HI16
case|:
case|case
name|R_MIPS_GOT_LO16
case|:
case|case
name|R_MIPS_GOT_PAGE
case|:
case|case
name|R_MIPS_GOT_OFST
case|:
case|case
name|R_MIPS_GOT_DISP
case|:
if|if
condition|(
name|dynobj
operator|==
name|NULL
condition|)
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
operator|=
name|dynobj
operator|=
name|abfd
expr_stmt|;
if|if
condition|(
operator|!
name|mips_elf64_create_got_section
argument_list|(
name|dynobj
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|false
return|;
name|g
operator|=
name|_mips_elf64_got_info
argument_list|(
name|dynobj
argument_list|,
operator|&
name|sgot
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_MIPS_32
case|:
case|case
name|R_MIPS_REL32
case|:
case|case
name|R_MIPS_64
case|:
if|if
condition|(
name|dynobj
operator|==
name|NULL
operator|&&
operator|(
name|info
operator|->
name|shared
operator|||
name|h
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
operator|=
name|dynobj
operator|=
name|abfd
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|h
operator|&&
operator|(
name|r_type
operator|==
name|R_MIPS_CALL_LO16
operator|||
name|r_type
operator|==
name|R_MIPS_GOT_LO16
operator|||
name|r_type
operator|==
name|R_MIPS_GOT_DISP
operator|)
condition|)
block|{
comment|/* We may need a local GOT entry for this relocation.  We 	     don't count R_MIPS_GOT_PAGE because we can estimate the 	     maximum number of pages needed by looking at the size of 	     the segment.  Similar comments apply to R_MIPS_GOT16 and 	     R_MIPS_CALL16.  We don't count R_MIPS_GOT_HI16, or 	     R_MIPS_CALL_HI16 because these are always followed by an 	     R_MIPS_GOT_LO16 or R_MIPS_CALL_LO16.  	     This estimation is very conservative since we can merge 	     duplicate entries in the GOT.  In order to be less 	     conservative, we could actually build the GOT here, 	     rather than in relocate_section.  */
name|g
operator|->
name|local_gotno
operator|++
expr_stmt|;
name|sgot
operator|->
name|_raw_size
operator|+=
name|get_elf_backend_data
argument_list|(
name|dynobj
argument_list|)
operator|->
name|s
operator|->
name|arch_size
operator|/
literal|8
expr_stmt|;
block|}
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_MIPS_CALL16
case|:
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: CALL16 reloc at 0x%lx not against global symbol"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Fall through.  */
case|case
name|R_MIPS_CALL_HI16
case|:
case|case
name|R_MIPS_CALL_LO16
case|:
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
comment|/* This symbol requires a global offset table entry.  */
if|if
condition|(
operator|!
name|mips_elf64_record_global_got_symbol
argument_list|(
name|h
argument_list|,
name|info
argument_list|,
name|g
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* We need a stub, not a plt entry for the undefined 		 function.  But we record it as if it needs plt.  See 		 elf_adjust_dynamic_symbol in elflink.h.  */
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_NEEDS_PLT
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|STT_FUNC
expr_stmt|;
block|}
break|break;
case|case
name|R_MIPS_GOT16
case|:
case|case
name|R_MIPS_GOT_HI16
case|:
case|case
name|R_MIPS_GOT_LO16
case|:
case|case
name|R_MIPS_GOT_DISP
case|:
comment|/* This symbol requires a global offset table entry.  */
if|if
condition|(
name|h
operator|&&
operator|!
name|mips_elf64_record_global_got_symbol
argument_list|(
name|h
argument_list|,
name|info
argument_list|,
name|g
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|R_MIPS_32
case|:
case|case
name|R_MIPS_REL32
case|:
case|case
name|R_MIPS_64
case|:
if|if
condition|(
operator|(
name|info
operator|->
name|shared
operator|||
name|h
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
literal|".rel.dyn"
decl_stmt|;
name|sreloc
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
block|{
name|sreloc
operator|=
name|bfd_make_section
argument_list|(
name|dynobj
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|dynobj
argument_list|,
name|sreloc
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_READONLY
operator|)
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|sreloc
argument_list|,
literal|4
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
define|#
directive|define
name|MIPS_READONLY_SECTION
value|(SEC_ALLOC | SEC_LOAD | SEC_READONLY)
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
comment|/* When creating a shared object, we must copy these 		     reloc types into the output file as R_MIPS_REL32 		     relocs.  We make room for this reloc in the 		     .rel.dyn reloc section.  */
name|mips_elf64_allocate_dynamic_relocations
argument_list|(
name|dynobj
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|MIPS_READONLY_SECTION
operator|)
operator|==
name|MIPS_READONLY_SECTION
condition|)
comment|/* We tell the dynamic linker that there are 		       relocations against the text segment.  */
name|info
operator|->
name|flags
operator||=
name|DF_TEXTREL
expr_stmt|;
block|}
else|else
block|{
name|struct
name|mips_elf64_link_hash_entry
modifier|*
name|hmips
decl_stmt|;
comment|/* We only need to copy this reloc if the symbol is                      defined in a dynamic object.  */
name|hmips
operator|=
operator|(
expr|struct
name|mips_elf64_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
operator|++
name|hmips
operator|->
name|possibly_dynamic_relocs
expr_stmt|;
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|MIPS_READONLY_SECTION
operator|)
operator|==
name|MIPS_READONLY_SECTION
condition|)
comment|/* We need it to tell the dynamic linker if there 		       are relocations against the text segment.  */
name|hmips
operator|->
name|readonly_reloc
operator|=
name|true
expr_stmt|;
block|}
comment|/* Even though we don't directly need a GOT entry for 		 this symbol, a symbol must have a dynamic symbol 		 table index greater that DT_MIPS_GOTSYM if there are 		 dynamic relocations against it.  */
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|!
name|mips_elf64_record_global_got_symbol
argument_list|(
name|h
argument_list|,
name|info
argument_list|,
name|g
argument_list|)
condition|)
return|return
name|false
return|;
block|}
break|break;
case|case
name|R_MIPS_26
case|:
case|case
name|R_MIPS_GPREL16
case|:
case|case
name|R_MIPS_LITERAL
case|:
case|case
name|R_MIPS_GPREL32
case|:
break|break;
comment|/* This relocation describes the C++ object vtable hierarchy. 	     Reconstruct it for later use during GC.  */
case|case
name|R_MIPS_GNU_VTINHERIT
case|:
if|if
condition|(
operator|!
name|_bfd_elf64_gc_record_vtinherit
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|h
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
comment|/* This relocation describes which C++ vtable entries are actually 	     used.  Record for later use during GC.  */
case|case
name|R_MIPS_GNU_VTENTRY
case|:
if|if
condition|(
operator|!
name|_bfd_elf64_gc_record_vtentry
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|h
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
default|default:
break|break;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Structure used to pass information to mips_elf64_output_extsym.  */
end_comment

begin_struct
struct|struct
name|extsym_info
block|{
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|ecoff_debug_info
modifier|*
name|debug
decl_stmt|;
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|swap
decl_stmt|;
name|boolean
name|failed
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This routine is used to write out ECOFF debugging external symbol    information.  It is called via mips_elf64_link_hash_traverse.  The    ECOFF external symbol information must match the ELF external    symbol information.  Unfortunately, at this point we don't know    whether a symbol is required by reloc information, so the two    tables may wind up being different.  We must sort out the external    symbol information before we can set the final size of the .mdebug    section, and we must set the size of the .mdebug section before we    can relocate any sections, and we can't know which symbols are    required by relocation until we relocate the sections.    Fortunately, it is relatively unlikely that any symbol will be    stripped but required by a reloc.  In particular, it can not happen    when generating a final executable.  */
end_comment

begin_function
specifier|static
name|boolean
name|mips_elf64_output_extsym
parameter_list|(
name|h
parameter_list|,
name|data
parameter_list|)
name|struct
name|mips_elf64_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
name|struct
name|extsym_info
modifier|*
name|einfo
init|=
operator|(
expr|struct
name|extsym_info
operator|*
operator|)
name|data
decl_stmt|;
name|boolean
name|strip
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|,
modifier|*
name|output_section
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|mips_elf64_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|indx
operator|==
operator|-
literal|2
condition|)
name|strip
operator|=
name|false
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|(
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|||
operator|(
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_REF_DYNAMIC
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_REF_REGULAR
operator|)
operator|==
literal|0
condition|)
name|strip
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|einfo
operator|->
name|info
operator|->
name|strip
operator|==
name|strip_all
operator|||
operator|(
name|einfo
operator|->
name|info
operator|->
name|strip
operator|==
name|strip_some
operator|&&
name|bfd_hash_lookup
argument_list|(
name|einfo
operator|->
name|info
operator|->
name|keep_hash
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
operator|==
name|NULL
operator|)
condition|)
name|strip
operator|=
name|true
expr_stmt|;
else|else
name|strip
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|strip
condition|)
return|return
name|true
return|;
if|if
condition|(
name|h
operator|->
name|esym
operator|.
name|ifd
operator|==
operator|-
literal|2
condition|)
block|{
name|h
operator|->
name|esym
operator|.
name|jmptbl
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|cobol_main
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|weakext
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|reserved
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|ifd
operator|=
name|ifdNil
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|st
operator|=
name|stGlobal
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
operator|||
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Use undefined class.  Also, set class and type for some              special symbols.  */
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scUndefined
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defined
operator|&&
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scAbs
expr_stmt|;
else|else
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|sec
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|output_section
operator|=
name|sec
operator|->
name|output_section
expr_stmt|;
comment|/* When making a shared library and symbol h is the one from 	     the another shared library, OUTPUT_SECTION may be null.  */
if|if
condition|(
name|output_section
operator|==
name|NULL
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scUndefined
expr_stmt|;
else|else
block|{
name|name
operator|=
name|bfd_section_name
argument_list|(
name|output_section
operator|->
name|owner
argument_list|,
name|output_section
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".text"
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scText
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".data"
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scData
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sdata"
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scSData
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".rodata"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".rdata"
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scRData
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".bss"
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scBss
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sbss"
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scSBss
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".init"
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scInit
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".fini"
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scFini
expr_stmt|;
else|else
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scAbs
expr_stmt|;
block|}
block|}
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|reserved
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|index
operator|=
name|indexNil
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_common
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|size
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|==
name|scCommon
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scBss
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|==
name|scSCommon
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scSBss
expr_stmt|;
name|sec
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|output_section
operator|=
name|sec
operator|->
name|output_section
expr_stmt|;
if|if
condition|(
name|output_section
operator|!=
name|NULL
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
else|else
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_NEEDS_PLT
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|mips_elf64_link_hash_entry
modifier|*
name|hd
init|=
name|h
decl_stmt|;
name|boolean
name|no_fn_stub
init|=
name|h
operator|->
name|no_fn_stub
decl_stmt|;
while|while
condition|(
name|hd
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
condition|)
block|{
name|hd
operator|=
operator|(
expr|struct
name|mips_elf64_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|no_fn_stub
operator|=
name|no_fn_stub
operator|||
name|hd
operator|->
name|no_fn_stub
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|no_fn_stub
condition|)
block|{
comment|/* Set type and value for a symbol with a function stub.  */
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|st
operator|=
name|stProc
expr_stmt|;
name|sec
operator|=
name|hd
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|output_section
operator|=
name|sec
operator|->
name|output_section
expr_stmt|;
if|if
condition|(
name|output_section
operator|!=
name|NULL
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
operator|(
name|hd
operator|->
name|root
operator|.
name|plt
operator|.
name|offset
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
else|else
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
literal|0
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* FIXME?  */
block|h->esym.ifd = 0;
endif|#
directive|endif
block|}
block|}
if|if
condition|(
operator|!
name|bfd_ecoff_debug_one_external
argument_list|(
name|einfo
operator|->
name|abfd
argument_list|,
name|einfo
operator|->
name|debug
argument_list|,
name|einfo
operator|->
name|swap
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
operator|&
name|h
operator|->
name|esym
argument_list|)
condition|)
block|{
name|einfo
operator|->
name|failed
operator|=
name|true
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Swap an entry in a .gptab section.  Note that these routines rely    on the equivalence of the two elements of the union.  */
end_comment

begin_function
specifier|static
name|void
name|mips_elf64_swap_gptab_in
parameter_list|(
name|abfd
parameter_list|,
name|ex
parameter_list|,
name|in
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|Elf32_External_gptab
modifier|*
name|ex
decl_stmt|;
name|Elf32_gptab
modifier|*
name|in
decl_stmt|;
block|{
name|in
operator|->
name|gt_entry
operator|.
name|gt_g_value
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ex
operator|->
name|gt_entry
operator|.
name|gt_g_value
argument_list|)
expr_stmt|;
name|in
operator|->
name|gt_entry
operator|.
name|gt_bytes
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ex
operator|->
name|gt_entry
operator|.
name|gt_bytes
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mips_elf64_swap_gptab_out
parameter_list|(
name|abfd
parameter_list|,
name|in
parameter_list|,
name|ex
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|Elf32_gptab
modifier|*
name|in
decl_stmt|;
name|Elf32_External_gptab
modifier|*
name|ex
decl_stmt|;
block|{
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|in
operator|->
name|gt_entry
operator|.
name|gt_g_value
argument_list|,
name|ex
operator|->
name|gt_entry
operator|.
name|gt_g_value
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|in
operator|->
name|gt_entry
operator|.
name|gt_bytes
argument_list|,
name|ex
operator|->
name|gt_entry
operator|.
name|gt_bytes
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A comparison routine used to sort .gptab entries.  */
end_comment

begin_function
specifier|static
name|int
name|gptab_compare
parameter_list|(
name|p1
parameter_list|,
name|p2
parameter_list|)
specifier|const
name|PTR
name|p1
decl_stmt|;
specifier|const
name|PTR
name|p2
decl_stmt|;
block|{
specifier|const
name|Elf32_gptab
modifier|*
name|a1
init|=
operator|(
specifier|const
name|Elf32_gptab
operator|*
operator|)
name|p1
decl_stmt|;
specifier|const
name|Elf32_gptab
modifier|*
name|a2
init|=
operator|(
specifier|const
name|Elf32_gptab
operator|*
operator|)
name|p2
decl_stmt|;
return|return
name|a1
operator|->
name|gt_entry
operator|.
name|gt_g_value
operator|-
name|a2
operator|->
name|gt_entry
operator|.
name|gt_g_value
return|;
block|}
end_function

begin_comment
comment|/* We need to use a special link routine to handle the .mdebug section.    We need to merge all instances of this section together, not write    them all out sequentially.  */
end_comment

begin_function
name|boolean
name|mips_elf64_final_link
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|asection
modifier|*
modifier|*
name|secpp
decl_stmt|;
name|asection
modifier|*
name|o
decl_stmt|;
name|struct
name|bfd_link_order
modifier|*
name|p
decl_stmt|;
name|asection
modifier|*
name|mdebug_sec
decl_stmt|,
modifier|*
name|gptab_data_sec
decl_stmt|,
modifier|*
name|gptab_bss_sec
decl_stmt|;
name|struct
name|ecoff_debug_info
name|debug
decl_stmt|;
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|swap
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_backend_ecoff_debug_swap
decl_stmt|;
name|HDRR
modifier|*
name|symhdr
init|=
operator|&
name|debug
operator|.
name|symbolic_header
decl_stmt|;
name|PTR
name|mdebug_handle
init|=
name|NULL
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|EXTR
name|esym
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|secname
index|[]
init|=
block|{
literal|".text"
block|,
literal|".init"
block|,
literal|".fini"
block|,
literal|".data"
block|,
literal|".rodata"
block|,
literal|".sdata"
block|,
literal|".sbss"
block|,
literal|".bss"
block|}
decl_stmt|;
specifier|static
specifier|const
name|int
name|sc
index|[]
init|=
block|{
name|scText
block|,
name|scInit
block|,
name|scFini
block|,
name|scData
block|,
name|scRData
block|,
name|scSData
block|,
name|scSBss
block|,
name|scBss
block|}
decl_stmt|;
comment|/* If all the things we linked together were PIC, but we're      producing an executable (rather than a shared object), then the      resulting file is CPIC (i.e., it calls PIC code.)  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
operator|&&
operator|!
name|info
operator|->
name|relocateable
operator|&&
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_MIPS_PIC
condition|)
block|{
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&=
operator|~
name|EF_MIPS_PIC
expr_stmt|;
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator||=
name|EF_MIPS_CPIC
expr_stmt|;
block|}
comment|/* We'd carefully arranged the dynamic symbol indices, and then the      generic size_dynamic_sections renumbered them out from under us.      Rather than trying somehow to prevent the renumbering, just do      the sort again.  */
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|got
decl_stmt|;
name|struct
name|mips_elf64_got_info
modifier|*
name|g
decl_stmt|;
comment|/* When we resort, we must tell mips_elf64_sort_hash_table what 	 the lowest index it may use is.  That's the number of section 	 symbols we're going to add.  The generic ELF linker only 	 adds these symbols when building a shared object.  Note that 	 we count the sections after (possibly) removing the .options 	 section above.  */
if|if
condition|(
operator|!
name|mips_elf64_sort_hash_table
argument_list|(
name|info
argument_list|,
operator|(
name|info
operator|->
name|shared
condition|?
name|bfd_count_sections
argument_list|(
name|abfd
argument_list|)
operator|+
literal|1
else|:
literal|1
operator|)
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Make sure we didn't grow the global .got region.  */
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|got
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
name|g
operator|=
operator|(
expr|struct
name|mips_elf64_got_info
operator|*
operator|)
name|elf_section_data
argument_list|(
name|got
argument_list|)
operator|->
name|tdata
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|global_gotsym
operator|!=
name|NULL
condition|)
name|BFD_ASSERT
argument_list|(
operator|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynsymcount
operator|-
name|g
operator|->
name|global_gotsym
operator|->
name|dynindx
operator|)
operator|<=
name|g
operator|->
name|global_gotno
argument_list|)
expr_stmt|;
block|}
comment|/* We include .MIPS.options, even though we don't process it quite right.      (Some entries are supposed to be merged.)  At IRIX6 empirically we seem      to be better off including it than not.  */
for|for
control|(
name|secpp
operator|=
operator|&
name|abfd
operator|->
name|sections
init|;
operator|*
name|secpp
operator|!=
name|NULL
condition|;
name|secpp
operator|=
operator|&
operator|(
operator|*
name|secpp
operator|)
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|(
operator|*
name|secpp
operator|)
operator|->
name|name
argument_list|,
literal|".MIPS.options"
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|p
operator|=
operator|(
operator|*
name|secpp
operator|)
operator|->
name|link_order_head
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_indirect_link_order
condition|)
name|p
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
operator|->
name|flags
operator|&=
operator|~
name|SEC_HAS_CONTENTS
expr_stmt|;
operator|(
operator|*
name|secpp
operator|)
operator|->
name|link_order_head
operator|=
name|NULL
expr_stmt|;
name|bfd_section_list_remove
argument_list|(
name|abfd
argument_list|,
name|secpp
argument_list|)
expr_stmt|;
operator|--
name|abfd
operator|->
name|section_count
expr_stmt|;
break|break;
block|}
block|}
comment|/* Get a value for the GP register.  */
if|if
condition|(
name|elf_gp
argument_list|(
name|abfd
argument_list|)
operator|==
literal|0
condition|)
block|{
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|info
operator|->
name|hash
argument_list|,
literal|"_gp"
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|)
name|NULL
operator|&&
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_defined
condition|)
name|elf_gp
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|info
operator|->
name|relocateable
condition|)
block|{
name|bfd_vma
name|lo
init|=
name|MINUS_ONE
decl_stmt|;
comment|/* Find the GP-relative section with the lowest offset.  */
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
if|if
condition|(
name|o
operator|->
name|vma
operator|<
name|lo
operator|&&
operator|(
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_flags
operator|&
name|SHF_MIPS_GPREL
operator|)
condition|)
name|lo
operator|=
name|o
operator|->
name|vma
expr_stmt|;
comment|/* And calculate GP relative to that.  */
name|elf_gp
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
name|lo
operator|+
literal|0x7ff0
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If the relocate_section function needs to do a reloc 	     involving the GP value, it should make a reloc_dangerous 	     callback to warn that GP is not defined.  */
block|}
block|}
comment|/* Go through the sections and collect the .mdebug information.  */
name|mdebug_sec
operator|=
name|NULL
expr_stmt|;
name|gptab_data_sec
operator|=
name|NULL
expr_stmt|;
name|gptab_bss_sec
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|o
operator|->
name|name
argument_list|,
literal|".mdebug"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|struct
name|extsym_info
name|einfo
decl_stmt|;
name|bfd_vma
name|last
decl_stmt|;
comment|/* We have found the .mdebug section in the output file. 	     Look through all the link_orders comprising it and merge 	     the information together.  */
name|symhdr
operator|->
name|magic
operator|=
name|swap
operator|->
name|sym_magic
expr_stmt|;
comment|/* FIXME: What should the version stamp be?  */
name|symhdr
operator|->
name|vstamp
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|ilineMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|cbLine
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|idnMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|ipdMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|isymMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|ioptMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|iauxMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|issMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|issExtMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|ifdMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|crfd
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|iextMax
operator|=
literal|0
expr_stmt|;
comment|/* We accumulate the debugging information itself in the 	     debug_info structure.  */
name|debug
operator|.
name|line
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|external_dnr
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|external_pdr
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|external_sym
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|external_opt
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|external_aux
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|ss
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|ssext
operator|=
name|debug
operator|.
name|ssext_end
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|external_fdr
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|external_rfd
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|external_ext
operator|=
name|debug
operator|.
name|external_ext_end
operator|=
name|NULL
expr_stmt|;
name|mdebug_handle
operator|=
name|bfd_ecoff_debug_init
argument_list|(
name|abfd
argument_list|,
operator|&
name|debug
argument_list|,
name|swap
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|mdebug_handle
operator|==
operator|(
name|PTR
operator|)
name|NULL
condition|)
return|return
name|false
return|;
name|esym
operator|.
name|jmptbl
operator|=
literal|0
expr_stmt|;
name|esym
operator|.
name|cobol_main
operator|=
literal|0
expr_stmt|;
name|esym
operator|.
name|weakext
operator|=
literal|0
expr_stmt|;
name|esym
operator|.
name|reserved
operator|=
literal|0
expr_stmt|;
name|esym
operator|.
name|ifd
operator|=
name|ifdNil
expr_stmt|;
name|esym
operator|.
name|asym
operator|.
name|iss
operator|=
name|issNil
expr_stmt|;
name|esym
operator|.
name|asym
operator|.
name|st
operator|=
name|stLocal
expr_stmt|;
name|esym
operator|.
name|asym
operator|.
name|reserved
operator|=
literal|0
expr_stmt|;
name|esym
operator|.
name|asym
operator|.
name|index
operator|=
name|indexNil
expr_stmt|;
name|last
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|secname
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|secname
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|sc
index|[
name|i
index|]
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|secname
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
name|s
operator|->
name|vma
expr_stmt|;
name|last
operator|=
name|s
operator|->
name|vma
operator|+
name|s
operator|->
name|_raw_size
expr_stmt|;
block|}
else|else
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
name|last
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_ecoff_debug_one_external
argument_list|(
name|abfd
argument_list|,
operator|&
name|debug
argument_list|,
name|swap
argument_list|,
name|secname
index|[
name|i
index|]
argument_list|,
operator|&
name|esym
argument_list|)
condition|)
return|return
name|false
return|;
block|}
for|for
control|(
name|p
operator|=
name|o
operator|->
name|link_order_head
init|;
name|p
operator|!=
operator|(
expr|struct
name|bfd_link_order
operator|*
operator|)
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|input_swap
decl_stmt|;
name|struct
name|ecoff_debug_info
name|input_debug
decl_stmt|;
name|char
modifier|*
name|eraw_src
decl_stmt|;
name|char
modifier|*
name|eraw_end
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|type
operator|!=
name|bfd_indirect_link_order
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_fill_link_order
condition|)
continue|continue;
name|abort
argument_list|()
expr_stmt|;
block|}
name|input_section
operator|=
name|p
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
expr_stmt|;
name|input_bfd
operator|=
name|input_section
operator|->
name|owner
expr_stmt|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|input_bfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
operator|||
operator|(
name|get_elf_backend_data
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|elf_backend_ecoff_debug_swap
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* I don't know what a non MIPS ELF bfd would be 		     doing with a .mdebug section, but I don't really 		     want to deal with it.  */
continue|continue;
block|}
name|input_swap
operator|=
operator|(
name|get_elf_backend_data
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|elf_backend_ecoff_debug_swap
operator|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|p
operator|->
name|size
operator|==
name|input_section
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
comment|/* The ECOFF linking code expects that we have already 		 read in the debugging information and set up an 		 ecoff_debug_info structure, so we do that now.  */
if|if
condition|(
operator|!
name|_bfd_mips_elf_read_ecoff_info
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|&
name|input_debug
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
operator|(
name|bfd_ecoff_debug_accumulate
argument_list|(
name|mdebug_handle
argument_list|,
name|abfd
argument_list|,
operator|&
name|debug
argument_list|,
name|swap
argument_list|,
name|input_bfd
argument_list|,
operator|&
name|input_debug
argument_list|,
name|input_swap
argument_list|,
name|info
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
comment|/* Loop through the external symbols.  For each one with 		 interesting information, try to find the symbol in 		 the linker global hash table and save the information 		 for the output external symbols.  */
name|eraw_src
operator|=
name|input_debug
operator|.
name|external_ext
expr_stmt|;
name|eraw_end
operator|=
operator|(
name|eraw_src
operator|+
operator|(
name|input_debug
operator|.
name|symbolic_header
operator|.
name|iextMax
operator|*
name|input_swap
operator|->
name|external_ext_size
operator|)
operator|)
expr_stmt|;
for|for
control|(
init|;
name|eraw_src
operator|<
name|eraw_end
condition|;
name|eraw_src
operator|+=
name|input_swap
operator|->
name|external_ext_size
control|)
block|{
name|EXTR
name|ext
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|mips_elf64_link_hash_entry
modifier|*
name|h
decl_stmt|;
call|(
modifier|*
name|input_swap
operator|->
name|swap_ext_in
call|)
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|PTR
operator|)
name|eraw_src
argument_list|,
operator|&
name|ext
argument_list|)
expr_stmt|;
if|if
condition|(
name|ext
operator|.
name|asym
operator|.
name|sc
operator|==
name|scNil
operator|||
name|ext
operator|.
name|asym
operator|.
name|sc
operator|==
name|scUndefined
operator|||
name|ext
operator|.
name|asym
operator|.
name|sc
operator|==
name|scSUndefined
condition|)
continue|continue;
name|name
operator|=
name|input_debug
operator|.
name|ssext
operator|+
name|ext
operator|.
name|asym
operator|.
name|iss
expr_stmt|;
name|h
operator|=
name|mips_elf64_link_hash_lookup
argument_list|(
name|mips_elf64_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|name
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
name|h
operator|->
name|esym
operator|.
name|ifd
operator|!=
operator|-
literal|2
condition|)
continue|continue;
if|if
condition|(
name|ext
operator|.
name|ifd
operator|!=
operator|-
literal|1
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|ext
operator|.
name|ifd
operator|<
name|input_debug
operator|.
name|symbolic_header
operator|.
name|ifdMax
argument_list|)
expr_stmt|;
name|ext
operator|.
name|ifd
operator|=
name|input_debug
operator|.
name|ifdmap
index|[
name|ext
operator|.
name|ifd
index|]
expr_stmt|;
block|}
name|h
operator|->
name|esym
operator|=
name|ext
expr_stmt|;
block|}
comment|/* Free up the information we just read.  */
name|free
argument_list|(
name|input_debug
operator|.
name|line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|external_dnr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|external_pdr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|external_sym
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|external_opt
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|external_aux
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|ss
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|ssext
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|external_fdr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|external_rfd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|external_ext
argument_list|)
expr_stmt|;
comment|/* Hack: reset the SEC_HAS_CONTENTS flag so that 		 elf_link_input_bfd ignores this section.  */
name|input_section
operator|->
name|flags
operator|&=
operator|~
name|SEC_HAS_CONTENTS
expr_stmt|;
block|}
comment|/* Build the external symbol information.  */
name|einfo
operator|.
name|abfd
operator|=
name|abfd
expr_stmt|;
name|einfo
operator|.
name|info
operator|=
name|info
expr_stmt|;
name|einfo
operator|.
name|debug
operator|=
operator|&
name|debug
expr_stmt|;
name|einfo
operator|.
name|swap
operator|=
name|swap
expr_stmt|;
name|einfo
operator|.
name|failed
operator|=
name|false
expr_stmt|;
name|mips_elf64_link_hash_traverse
argument_list|(
name|mips_elf64_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|mips_elf64_output_extsym
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|einfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|einfo
operator|.
name|failed
condition|)
return|return
name|false
return|;
comment|/* Set the size of the .mdebug section.  */
name|o
operator|->
name|_raw_size
operator|=
name|bfd_ecoff_debug_size
argument_list|(
name|abfd
argument_list|,
operator|&
name|debug
argument_list|,
name|swap
argument_list|)
expr_stmt|;
comment|/* Skip this section later on (I don't think this currently 	     matters, but someday it might).  */
name|o
operator|->
name|link_order_head
operator|=
operator|(
expr|struct
name|bfd_link_order
operator|*
operator|)
name|NULL
expr_stmt|;
name|mdebug_sec
operator|=
name|o
expr_stmt|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|o
operator|->
name|name
argument_list|,
literal|".gptab."
argument_list|,
sizeof|sizeof
expr|".gptab."
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|subname
decl_stmt|;
name|unsigned
name|int
name|c
decl_stmt|;
name|Elf32_gptab
modifier|*
name|tab
decl_stmt|;
name|Elf32_External_gptab
modifier|*
name|ext_tab
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* The .gptab.sdata and .gptab.sbss sections hold 	     information describing how the small data area would 	     change depending upon the -G switch.  These sections 	     not used in executables files.  */
if|if
condition|(
operator|!
name|info
operator|->
name|relocateable
condition|)
block|{
name|asection
modifier|*
modifier|*
name|secpp
decl_stmt|;
for|for
control|(
name|p
operator|=
name|o
operator|->
name|link_order_head
init|;
name|p
operator|!=
operator|(
expr|struct
name|bfd_link_order
operator|*
operator|)
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|asection
modifier|*
name|input_section
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|type
operator|!=
name|bfd_indirect_link_order
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_fill_link_order
condition|)
continue|continue;
name|abort
argument_list|()
expr_stmt|;
block|}
name|input_section
operator|=
name|p
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
expr_stmt|;
comment|/* Hack: reset the SEC_HAS_CONTENTS flag so that 		     elf_link_input_bfd ignores this section.  */
name|input_section
operator|->
name|flags
operator|&=
operator|~
name|SEC_HAS_CONTENTS
expr_stmt|;
block|}
comment|/* Skip this section later on (I don't think this 		 currently matters, but someday it might).  */
name|o
operator|->
name|link_order_head
operator|=
operator|(
expr|struct
name|bfd_link_order
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* Really remove the section.  */
for|for
control|(
name|secpp
operator|=
operator|&
name|abfd
operator|->
name|sections
init|;
operator|*
name|secpp
operator|!=
name|o
condition|;
name|secpp
operator|=
operator|&
operator|(
operator|*
name|secpp
operator|)
operator|->
name|next
control|)
empty_stmt|;
name|bfd_section_list_remove
argument_list|(
name|abfd
argument_list|,
name|secpp
argument_list|)
expr_stmt|;
operator|--
name|abfd
operator|->
name|section_count
expr_stmt|;
continue|continue;
block|}
comment|/* There is one gptab for initialized data, and one for 	     uninitialized data.  */
if|if
condition|(
name|strcmp
argument_list|(
name|o
operator|->
name|name
argument_list|,
literal|".gptab.sdata"
argument_list|)
operator|==
literal|0
condition|)
name|gptab_data_sec
operator|=
name|o
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|o
operator|->
name|name
argument_list|,
literal|".gptab.sbss"
argument_list|)
operator|==
literal|0
condition|)
name|gptab_bss_sec
operator|=
name|o
expr_stmt|;
else|else
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: illegal section name `%s'"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|o
operator|->
name|name
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_nonrepresentable_section
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* The linker script always combines .gptab.data and 	     .gptab.sdata into .gptab.sdata, and likewise for 	     .gptab.bss and .gptab.sbss.  It is possible that there is 	     no .sdata or .sbss section in the output file, in which 	     case we must change the name of the output section.  */
name|subname
operator|=
name|o
operator|->
name|name
operator|+
sizeof|sizeof
expr|".gptab"
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|subname
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|o
operator|==
name|gptab_data_sec
condition|)
name|o
operator|->
name|name
operator|=
literal|".gptab.data"
expr_stmt|;
else|else
name|o
operator|->
name|name
operator|=
literal|".gptab.bss"
expr_stmt|;
name|subname
operator|=
name|o
operator|->
name|name
operator|+
sizeof|sizeof
expr|".gptab"
operator|-
literal|1
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|subname
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Set up the first entry.  */
name|c
operator|=
literal|1
expr_stmt|;
name|tab
operator|=
operator|(
name|Elf32_gptab
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|c
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_gptab
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tab
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|tab
index|[
literal|0
index|]
operator|.
name|gt_header
operator|.
name|gt_current_g_value
operator|=
name|elf_gp_size
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|tab
index|[
literal|0
index|]
operator|.
name|gt_header
operator|.
name|gt_unused
operator|=
literal|0
expr_stmt|;
comment|/* Combine the input sections.  */
for|for
control|(
name|p
operator|=
name|o
operator|->
name|link_order_head
init|;
name|p
operator|!=
operator|(
expr|struct
name|bfd_link_order
operator|*
operator|)
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
name|unsigned
name|long
name|last
decl_stmt|;
name|bfd_size_type
name|gpentry
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|type
operator|!=
name|bfd_indirect_link_order
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_fill_link_order
condition|)
continue|continue;
name|abort
argument_list|()
expr_stmt|;
block|}
name|input_section
operator|=
name|p
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
expr_stmt|;
name|input_bfd
operator|=
name|input_section
operator|->
name|owner
expr_stmt|;
comment|/* Combine the gptab entries for this input section one 		 by one.  We know that the input gptab entries are 		 sorted by ascending -G value.  */
name|size
operator|=
name|bfd_section_size
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
expr_stmt|;
name|last
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|gpentry
operator|=
sizeof|sizeof
argument_list|(
name|Elf32_External_gptab
argument_list|)
init|;
name|gpentry
operator|<
name|size
condition|;
name|gpentry
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_gptab
argument_list|)
control|)
block|{
name|Elf32_External_gptab
name|ext_gptab
decl_stmt|;
name|Elf32_gptab
name|int_gptab
decl_stmt|;
name|unsigned
name|long
name|val
decl_stmt|;
name|unsigned
name|long
name|add
decl_stmt|;
name|boolean
name|exact
decl_stmt|;
name|unsigned
name|int
name|look
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|bfd_get_section_contents
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|ext_gptab
argument_list|,
name|gpentry
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf32_External_gptab
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|free
argument_list|(
name|tab
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|mips_elf64_swap_gptab_in
argument_list|(
name|input_bfd
argument_list|,
operator|&
name|ext_gptab
argument_list|,
operator|&
name|int_gptab
argument_list|)
expr_stmt|;
name|val
operator|=
name|int_gptab
operator|.
name|gt_entry
operator|.
name|gt_g_value
expr_stmt|;
name|add
operator|=
name|int_gptab
operator|.
name|gt_entry
operator|.
name|gt_bytes
operator|-
name|last
expr_stmt|;
name|exact
operator|=
name|false
expr_stmt|;
for|for
control|(
name|look
operator|=
literal|1
init|;
name|look
operator|<
name|c
condition|;
name|look
operator|++
control|)
block|{
if|if
condition|(
name|tab
index|[
name|look
index|]
operator|.
name|gt_entry
operator|.
name|gt_g_value
operator|>=
name|val
condition|)
name|tab
index|[
name|look
index|]
operator|.
name|gt_entry
operator|.
name|gt_bytes
operator|+=
name|add
expr_stmt|;
if|if
condition|(
name|tab
index|[
name|look
index|]
operator|.
name|gt_entry
operator|.
name|gt_g_value
operator|==
name|val
condition|)
name|exact
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|exact
condition|)
block|{
name|Elf32_gptab
modifier|*
name|new_tab
decl_stmt|;
name|unsigned
name|int
name|max
decl_stmt|;
comment|/* We need a new table entry.  */
name|new_tab
operator|=
operator|(
operator|(
name|Elf32_gptab
operator|*
operator|)
name|bfd_realloc
argument_list|(
operator|(
name|PTR
operator|)
name|tab
argument_list|,
operator|(
name|c
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_gptab
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|new_tab
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|tab
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|tab
operator|=
name|new_tab
expr_stmt|;
name|tab
index|[
name|c
index|]
operator|.
name|gt_entry
operator|.
name|gt_g_value
operator|=
name|val
expr_stmt|;
name|tab
index|[
name|c
index|]
operator|.
name|gt_entry
operator|.
name|gt_bytes
operator|=
name|add
expr_stmt|;
comment|/* Merge in the size for the next smallest -G 			 value, since that will be implied by this new 			 value.  */
name|max
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|look
operator|=
literal|1
init|;
name|look
operator|<
name|c
condition|;
name|look
operator|++
control|)
block|{
if|if
condition|(
name|tab
index|[
name|look
index|]
operator|.
name|gt_entry
operator|.
name|gt_g_value
operator|<
name|val
operator|&&
operator|(
name|max
operator|==
literal|0
operator|||
operator|(
name|tab
index|[
name|look
index|]
operator|.
name|gt_entry
operator|.
name|gt_g_value
operator|>
name|tab
index|[
name|max
index|]
operator|.
name|gt_entry
operator|.
name|gt_g_value
operator|)
operator|)
condition|)
name|max
operator|=
name|look
expr_stmt|;
block|}
if|if
condition|(
name|max
operator|!=
literal|0
condition|)
name|tab
index|[
name|c
index|]
operator|.
name|gt_entry
operator|.
name|gt_bytes
operator|+=
name|tab
index|[
name|max
index|]
operator|.
name|gt_entry
operator|.
name|gt_bytes
expr_stmt|;
operator|++
name|c
expr_stmt|;
block|}
name|last
operator|=
name|int_gptab
operator|.
name|gt_entry
operator|.
name|gt_bytes
expr_stmt|;
block|}
comment|/* Hack: reset the SEC_HAS_CONTENTS flag so that 		 elf_link_input_bfd ignores this section.  */
name|input_section
operator|->
name|flags
operator|&=
operator|~
name|SEC_HAS_CONTENTS
expr_stmt|;
block|}
comment|/* The table must be sorted by -G value.  */
if|if
condition|(
name|c
operator|>
literal|2
condition|)
name|qsort
argument_list|(
name|tab
operator|+
literal|1
argument_list|,
name|c
operator|-
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|tab
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|gptab_compare
argument_list|)
expr_stmt|;
comment|/* Swap out the table.  */
name|ext_tab
operator|=
operator|(
operator|(
name|Elf32_External_gptab
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|c
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_gptab
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ext_tab
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|tab
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|c
condition|;
name|i
operator|++
control|)
name|mips_elf64_swap_gptab_out
argument_list|(
name|abfd
argument_list|,
name|tab
operator|+
name|i
argument_list|,
name|ext_tab
operator|+
name|i
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tab
argument_list|)
expr_stmt|;
name|o
operator|->
name|_raw_size
operator|=
name|c
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_gptab
argument_list|)
expr_stmt|;
name|o
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|ext_tab
expr_stmt|;
comment|/* Skip this section later on (I don't think this currently 	     matters, but someday it might).  */
name|o
operator|->
name|link_order_head
operator|=
operator|(
expr|struct
name|bfd_link_order
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
block|}
comment|/* Invoke the regular ELF backend linker to do all the work.  */
if|if
condition|(
operator|!
name|bfd_elf64_bfd_final_link
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Now write out the computed sections.  */
if|if
condition|(
name|mdebug_sec
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|abfd
operator|->
name|output_has_begun
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_ecoff_write_accumulated_debug
argument_list|(
name|mdebug_handle
argument_list|,
name|abfd
argument_list|,
operator|&
name|debug
argument_list|,
name|swap
argument_list|,
name|info
argument_list|,
name|mdebug_sec
operator|->
name|filepos
argument_list|)
condition|)
return|return
name|false
return|;
name|bfd_ecoff_debug_free
argument_list|(
name|mdebug_handle
argument_list|,
name|abfd
argument_list|,
operator|&
name|debug
argument_list|,
name|swap
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gptab_data_sec
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|gptab_data_sec
argument_list|,
name|gptab_data_sec
operator|->
name|contents
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|gptab_data_sec
operator|->
name|_raw_size
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|gptab_bss_sec
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|gptab_bss_sec
argument_list|,
name|gptab_bss_sec
operator|->
name|contents
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|gptab_bss_sec
operator|->
name|_raw_size
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ECOFF swapping routines.  These are used when dealing with the    .mdebug section, which is in the ECOFF debugging format.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ecoff_debug_swap
name|mips_elf64_ecoff_debug_swap
init|=
block|{
comment|/* Symbol table magic number.  */
name|magicSym2
block|,
comment|/* Alignment of debugging information.  E.g., 4.  */
literal|8
block|,
comment|/* Sizes of external symbolic information.  */
sizeof|sizeof
argument_list|(
expr|struct
name|hdr_ext
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|dnr_ext
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|pdr_ext
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|sym_ext
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|opt_ext
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|fdr_ext
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|rfd_ext
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ext_ext
argument_list|)
block|,
comment|/* Functions to swap in external symbolic data.  */
name|ecoff_swap_hdr_in
block|,
name|ecoff_swap_dnr_in
block|,
name|ecoff_swap_pdr_in
block|,
name|ecoff_swap_sym_in
block|,
name|ecoff_swap_opt_in
block|,
name|ecoff_swap_fdr_in
block|,
name|ecoff_swap_rfd_in
block|,
name|ecoff_swap_ext_in
block|,
name|_bfd_ecoff_swap_tir_in
block|,
name|_bfd_ecoff_swap_rndx_in
block|,
comment|/* Functions to swap out external symbolic data.  */
name|ecoff_swap_hdr_out
block|,
name|ecoff_swap_dnr_out
block|,
name|ecoff_swap_pdr_out
block|,
name|ecoff_swap_sym_out
block|,
name|ecoff_swap_opt_out
block|,
name|ecoff_swap_fdr_out
block|,
name|ecoff_swap_rfd_out
block|,
name|ecoff_swap_ext_out
block|,
name|_bfd_ecoff_swap_tir_out
block|,
name|_bfd_ecoff_swap_rndx_out
block|,
comment|/* Function to read in symbolic data.  */
name|_bfd_mips_elf_read_ecoff_info
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Relocations in the 64 bit MIPS ELF ABI are more complex than in    standard ELF.  This structure is used to redirect the relocation    handling routines.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|elf_size_info
name|mips_elf64_size_info
init|=
block|{
sizeof|sizeof
argument_list|(
name|Elf64_External_Ehdr
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|Elf64_External_Phdr
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|Elf64_External_Shdr
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|Elf64_Mips_External_Rel
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|Elf64_Mips_External_Rela
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|Elf64_External_Sym
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|Elf64_External_Dyn
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|Elf_External_Note
argument_list|)
block|,
literal|4
block|,
comment|/* hash-table entry size */
literal|3
block|,
comment|/* internal relocations per external relocations */
literal|64
block|,
comment|/* arch_size */
literal|8
block|,
comment|/* file_align */
name|ELFCLASS64
block|,
name|EV_CURRENT
block|,
name|bfd_elf64_write_out_phdrs
block|,
name|bfd_elf64_write_shdrs_and_ehdr
block|,
name|mips_elf64_write_relocs
block|,
name|bfd_elf64_swap_symbol_out
block|,
name|mips_elf64_slurp_reloc_table
block|,
name|bfd_elf64_slurp_symbol_table
block|,
name|bfd_elf64_swap_dyn_in
block|,
name|bfd_elf64_swap_dyn_out
block|,
name|mips_elf64_be_swap_reloc_in
block|,
name|mips_elf64_be_swap_reloc_out
block|,
name|mips_elf64_be_swap_reloca_in
block|,
name|mips_elf64_be_swap_reloca_out
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ELF_ARCH
value|bfd_arch_mips
end_define

begin_define
define|#
directive|define
name|ELF_MACHINE_CODE
value|EM_MIPS
end_define

begin_define
define|#
directive|define
name|ELF_MAXPAGESIZE
value|0x1000
end_define

begin_define
define|#
directive|define
name|elf_backend_collect
value|true
end_define

begin_define
define|#
directive|define
name|elf_backend_type_change_ok
value|true
end_define

begin_define
define|#
directive|define
name|elf_backend_can_gc_sections
value|true
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto
value|mips_elf64_info_to_howto_rela
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto_rel
value|mips_elf64_info_to_howto_rel
end_define

begin_define
define|#
directive|define
name|elf_backend_object_p
value|_bfd_mips_elf_object_p
end_define

begin_define
define|#
directive|define
name|elf_backend_symbol_processing
value|_bfd_mips_elf_symbol_processing
end_define

begin_define
define|#
directive|define
name|elf_backend_section_processing
value|_bfd_mips_elf_section_processing
end_define

begin_define
define|#
directive|define
name|elf_backend_section_from_shdr
value|_bfd_mips_elf_section_from_shdr
end_define

begin_define
define|#
directive|define
name|elf_backend_fake_sections
value|_bfd_mips_elf_fake_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_section_from_bfd_section
define|\
value|_bfd_mips_elf_section_from_bfd_section
end_define

begin_define
define|#
directive|define
name|elf_backend_add_symbol_hook
value|_bfd_mips_elf_add_symbol_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_link_output_symbol_hook
define|\
value|_bfd_mips_elf_link_output_symbol_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_create_dynamic_sections
define|\
value|mips_elf64_create_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_check_relocs
value|mips_elf64_check_relocs
end_define

begin_define
define|#
directive|define
name|elf_backend_adjust_dynamic_symbol
define|\
value|mips_elf64_adjust_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_always_size_sections
define|\
value|mips_elf64_always_size_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_size_dynamic_sections
define|\
value|mips_elf64_size_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_relocate_section
value|mips_elf64_relocate_section
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_symbol
define|\
value|mips_elf64_finish_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_sections
define|\
value|mips_elf64_finish_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_final_write_processing
define|\
value|_bfd_mips_elf_final_write_processing
end_define

begin_define
define|#
directive|define
name|elf_backend_additional_program_headers
define|\
value|mips_elf64_additional_program_headers
end_define

begin_define
define|#
directive|define
name|elf_backend_modify_segment_map
value|_bfd_mips_elf_modify_segment_map
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_mark_hook
value|mips_elf64_gc_mark_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_sweep_hook
value|mips_elf64_gc_sweep_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_ecoff_debug_swap
value|&mips_elf64_ecoff_debug_swap
end_define

begin_define
define|#
directive|define
name|elf_backend_size_info
value|mips_elf64_size_info
end_define

begin_define
define|#
directive|define
name|elf_backend_got_header_size
value|(4 * MIPS_RESERVED_GOTNO)
end_define

begin_define
define|#
directive|define
name|elf_backend_plt_header_size
value|0
end_define

begin_comment
comment|/* MIPS ELF64 can use a mixture of REL and RELA, but some Relocations  * work better/work only in RELA, so we default to this.  */
end_comment

begin_define
define|#
directive|define
name|elf_backend_may_use_rel_p
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_may_use_rela_p
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_default_use_rela_p
value|1
end_define

begin_comment
comment|/* We don't set bfd_elf64_bfd_is_local_label_name because the 32-bit    MIPS-specific function only applies to IRIX5, which had no 64-bit    ABI.  */
end_comment

begin_define
define|#
directive|define
name|bfd_elf64_find_nearest_line
value|_bfd_mips_elf_find_nearest_line
end_define

begin_define
define|#
directive|define
name|bfd_elf64_set_section_contents
value|_bfd_mips_elf_set_section_contents
end_define

begin_define
define|#
directive|define
name|bfd_elf64_bfd_link_hash_table_create
define|\
value|mips_elf64_link_hash_table_create
end_define

begin_define
define|#
directive|define
name|bfd_elf64_bfd_final_link
value|mips_elf64_final_link
end_define

begin_define
define|#
directive|define
name|bfd_elf64_bfd_merge_private_bfd_data
define|\
value|_bfd_mips_elf_merge_private_bfd_data
end_define

begin_define
define|#
directive|define
name|bfd_elf64_bfd_set_private_flags
value|_bfd_mips_elf_set_private_flags
end_define

begin_define
define|#
directive|define
name|bfd_elf64_bfd_print_private_bfd_data
define|\
value|_bfd_mips_elf_print_private_bfd_data
end_define

begin_define
define|#
directive|define
name|bfd_elf64_get_reloc_upper_bound
value|mips_elf64_get_reloc_upper_bound
end_define

begin_define
define|#
directive|define
name|bfd_elf64_bfd_reloc_type_lookup
value|mips_elf64_reloc_type_lookup
end_define

begin_define
define|#
directive|define
name|bfd_elf64_archive_functions
end_define

begin_decl_stmt
specifier|extern
name|boolean
name|bfd_elf64_archive_slurp_armap
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|bfd_elf64_archive_write_armap
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|unsigned
name|int
operator|,
expr|struct
name|orl
operator|*
operator|,
name|unsigned
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|bfd_elf64_archive_slurp_extended_name_table
define|\
value|_bfd_archive_coff_slurp_extended_name_table
end_define

begin_define
define|#
directive|define
name|bfd_elf64_archive_construct_extended_name_table
define|\
value|_bfd_archive_coff_construct_extended_name_table
end_define

begin_define
define|#
directive|define
name|bfd_elf64_archive_truncate_arname
define|\
value|_bfd_archive_coff_truncate_arname
end_define

begin_define
define|#
directive|define
name|bfd_elf64_archive_read_ar_hdr
value|_bfd_archive_coff_read_ar_hdr
end_define

begin_define
define|#
directive|define
name|bfd_elf64_archive_openr_next_archived_file
define|\
value|_bfd_archive_coff_openr_next_archived_file
end_define

begin_define
define|#
directive|define
name|bfd_elf64_archive_get_elt_at_index
define|\
value|_bfd_archive_coff_get_elt_at_index
end_define

begin_define
define|#
directive|define
name|bfd_elf64_archive_generic_stat_arch_elt
define|\
value|_bfd_archive_coff_generic_stat_arch_elt
end_define

begin_define
define|#
directive|define
name|bfd_elf64_archive_update_armap_timestamp
define|\
value|_bfd_archive_coff_update_armap_timestamp
end_define

begin_comment
comment|/* The SGI style (n)64 NewABI.  */
end_comment

begin_define
define|#
directive|define
name|TARGET_LITTLE_SYM
value|bfd_elf64_littlemips_vec
end_define

begin_define
define|#
directive|define
name|TARGET_LITTLE_NAME
value|"elf64-littlemips"
end_define

begin_define
define|#
directive|define
name|TARGET_BIG_SYM
value|bfd_elf64_bigmips_vec
end_define

begin_define
define|#
directive|define
name|TARGET_BIG_NAME
value|"elf64-bigmips"
end_define

begin_include
include|#
directive|include
file|"elf64-target.h"
end_include

begin_define
define|#
directive|define
name|INCLUDED_TARGET_FILE
end_define

begin_comment
comment|/* More a type of flag.  */
end_comment

begin_comment
comment|/* The SYSV-style 'traditional' (n)64 NewABI.  */
end_comment

begin_undef
undef|#
directive|undef
name|TARGET_LITTLE_SYM
end_undef

begin_undef
undef|#
directive|undef
name|TARGET_LITTLE_NAME
end_undef

begin_undef
undef|#
directive|undef
name|TARGET_BIG_SYM
end_undef

begin_undef
undef|#
directive|undef
name|TARGET_BIG_NAME
end_undef

begin_define
define|#
directive|define
name|TARGET_LITTLE_SYM
value|bfd_elf64_tradlittlemips_vec
end_define

begin_define
define|#
directive|define
name|TARGET_LITTLE_NAME
value|"elf64-tradlittlemips"
end_define

begin_define
define|#
directive|define
name|TARGET_BIG_SYM
value|bfd_elf64_tradbigmips_vec
end_define

begin_define
define|#
directive|define
name|TARGET_BIG_NAME
value|"elf64-tradbigmips"
end_define

begin_comment
comment|/* Include the target file again for this target.  */
end_comment

begin_include
include|#
directive|include
file|"elf64-target.h"
end_include

end_unit

